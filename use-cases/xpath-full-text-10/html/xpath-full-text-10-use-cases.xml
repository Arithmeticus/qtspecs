<!--XSLT Processor: SAXON 9.1.0.2 from Saxonica SAXON SA 9.1.0.2--><?xml-stylesheet type="text/xsl" href="http://www.w3.org/XML/Group/qtspecs/use-cases/xpath-full-text-10/style/full-text.xsl"?><spec xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax" w3c-doctype="wgnote"><header><title>XQuery and XPath Full Text 1.0 Use Cases</title><w3c-designation>NOTE-xpath-full-text-10-use-cases</w3c-designation><w3c-doctype>W3C Working Group Note</w3c-doctype><pubdate><day>25</day><month>January</month><year>2011</year></pubdate><publoc>
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2011/NOTE-xpath-full-text-10-use-cases-20110125/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2011/NOTE-xpath-full-text-10-use-cases-20110125/</loc>
</publoc><altlocs><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2011/NOTE-xpath-full-text-10-use-cases-20110125/xpath-full-text-10-use-cases.xml" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML</loc></altlocs><latestloc>
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/xpath-full-text-10-use-cases/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xpath-full-text-10-use-cases/</loc>
</latestloc><prevlocs>
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2010/WD-xpath-full-text-10-use-cases-20100128/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
</prevlocs><authlist><author><name>Pat Case</name><affiliation>Library of Congress</affiliation><!-- <email xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:pcase@crs.loc.gov" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">pcase@crs.loc.gov</email> --></author><author><name>Sihem Amer-Yahia</name><affiliation>AT&amp;T Labs - Research</affiliation><!--<email xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:sihem@research.att.com" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">sihem@research.att.com</email> --></author></authlist><!--* Common status section for QT specs.
    * Use is currently not required, but it simplifies things.
    * 
    * Revisions:
    * 2007-01-15 : CMSMcQ : made file, to simplify publication of Rec.
    * 2008-02-15 : JimMelton : cloned from MSM's REC-only material
                     to generalize for all stages
    *--><status id="status"><!-- ************************************************************************** --><!-- * All Status sections must start with the standard boilerplate paragraph * --><!-- *   This entity is defined in status-entities.dtd                        * --><!-- ************************************************************************** --><p><emph>This section describes the status of this
         document at the time of its publication.
         Other documents may supersede this document.
         A list of current W3C publications and the latest
         revision of this technical report can be found in the
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">W3C technical reports index</loc>
         at http://www.w3.org/TR/.</emph></p><!-- ************************************************************************** --><!-- * QT publishes suites of documents, which must be described in the       * --><!--     Status section of each document within such a suite.                 * --><!-- *   This entity is defined in the host document.                         * --><!-- ************************************************************************** --><!-- ************************************************************************** --><!-- * There is a lot of detailed customization based on the document stage   * --><!-- *   This entity is defined in the host document.                         * --><!-- ************************************************************************** --><p>This is a <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2005/10/Process-20051014/tr.html#tr-end" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Working Group Note</loc> as described in the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2005/10/Process-20051014/tr.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Process Document</loc>. 
It has been jointly developed by the W3C 
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/Query/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML Query Working Group</loc> and the W3C <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Style/XSL/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XSL Working Group</loc>, each of which is part of the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/Activity" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML Activity</loc>.
The Working Groups expect to eventually publish this document as a Working Group Note.</p><!-- ************************************************************************** --><!-- * CR documents must cite features at risk                                * --><!-- *   This entity is defined in the host document.                         * --><!-- ************************************************************************** --><!-- ************************************************************************** --><!-- * Every Status section must have a customized paragraph                  * --><!-- *   This entity is defined completely in the host document.              * --><!-- ************************************************************************** --><p>This Use Cases document illustrates a number of use cases
that guided the development of the XQuery and XPath Full Text 1.0 specification. 
</p><!-- ************************************************************************** --><!-- * CR docs should, and PR docs must, have a pointer to an implementation  * --><!-- *   report.  We also want to point to the test suite.                    * --><!-- *   This entity is defined in the host document.                         * --><!-- ************************************************************************** --><!-- ************************************************************************** --><!-- * The Status section should point to a changelog                         * --><!-- *   This entity is defined in the host document.                         * --><!-- ************************************************************************** --><p>This document incorporates changes made against the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2005/10/Process-20051014/tr.html#last-call" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Last Call Working Draft</loc> of 18 May 2007.
  Changes to this document since the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2005/10/Process-20051014/tr.html#last-call" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Last Call Working Draft</loc> are detailed in
  <specref ref="ChangeLog"/>.</p><!-- ************************************************************************** --><!-- * The Status section must tell readers where to send comments            * --><!-- *   This entity is defined in status-entities.dtd                        * --><!-- ************************************************************************** --><p>Please report errors in this document using W3C's
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Bugs/Public/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public Bugzilla system</loc>
         (instructions can be found at
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/2005/04/qt-bugzilla" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/XML/2005/04/qt-bugzilla</loc>).
         If access to that system is not feasible, you may send your comments
         to the W3C XSLT/XPath/XQuery public comments mailing list,
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:public-qt-comments@w3.org" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public-qt-comments@w3.org</loc>.
         It will be very helpful if you include the string 
         “[FTUC]”
         in the subject line of your report, whether made in Bugzilla or in email.
         Please use multiple Bugzilla entries (or, if necessary, multiple email messages)
         if you have more than one comment to make.
         Archives of the comments and responses are available at
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://lists.w3.org/Archives/Public/public-qt-comments/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://lists.w3.org/Archives/Public/public-qt-comments/</loc>. </p><!-- ************************************************************************** --><!-- Status sections must state the stability (not stable, or REC) of the document --><!-- *   This entity is defined in the host document.                         * --><!-- ************************************************************************** --><p>Publication as a <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2005/10/Process-20051014/tr.html#tr-end" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Working Group Note</loc>
does not imply endorsement by the W3C Membership. 
At the time of publication, work on this document
was considered complete and no further revisions are anticipated. 
It is a stable document and may be used as reference material or
cited from another document. 
However, this document may be updated, replaced, or made obsolete by
other documents at any time.</p><!-- ************************************************************************** --><!-- * Finally, all Status sections must end with the appropriate IPR para    * --><!-- *   This entity is defined in status-entities.dtd                        * --><!-- ************************************************************************** --><p>This document was produced by groups operating under the
   <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Consortium/Patent-Policy-20040205/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">5 February 2004
   W3C Patent Policy</loc>.
   W3C maintains a <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2004/01/pp-impl/18797/status#disclosures" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public list of any 
   patent disclosures</loc> made in connection with the deliverables of the 
   XML Query Working Group and also maintains a <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2004/01/pp-impl/19552/status#disclosures" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public list of any patent 
   disclosures</loc> made in connection with the deliverables of the XSL 
   Working Group; those pages also include instructions for
   disclosing a patent.
   An individual who has actual knowledge of a patent which the individual believes
   contains
   <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Essential Claim(s)</loc>
   must disclose the information in accordance with
   <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">section 6 of the W3C Patent Policy</loc>. </p></status><abstract><p>This document specifies usage scenarios for full-text
queries as part of XQuery  <bibref ref="xquery"/> and XPath 
<bibref ref="xpath20"/>. </p></abstract><langusage><language id="EN">English</language></langusage><revisiondesc><p/></revisiondesc></header><body><div1 id="FT_UC_Prelim"><head>Full Text Use Cases: Preliminaries</head><div2 id="FT_UC_Display"><head>Proper Display of this Unicode Document</head><p>(1) Use a current operating system and browser.</p><p>(2) If necessary, set the character encoding in the browser manually to Unicode or UTF-8. Often this setting may be changed from the View menu.</p><p>(3) If after setting the character encoding to Unicode, the Chinese characters in the subject elements of the sample data still do not display, it is likely that the browser cannot locate a font that contains Chinese characters in Unicode encoding. It might be necessary to add a Unicode font, preferably Arial Unicode MS.</p></div2><div2 id="FT_UC_Intro"><head>Introduction</head><p>The use cases listed below were created by the
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/Query/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML Query Working Group</loc> and
the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Style/XSL/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XSL Working Group</loc> to
illustrate important applications of full-text
querying within an XML query language. Each use case exercises a specific functionality relevant to full-text querying. An XML Schema and sample input data 
are provided. Each use case specifies a query applied to the input data, a solution in XQuery, a solution in XPath (when possible), and the expected results.</p><p>The document supplements the XML Query Use Cases which can be found in the W3C
XML Query Use Cases <bibref ref="xquery-use-cases"/>. Use cases for character string querying are included in the XML Query Use Cases, not in this document.</p><p>These use cases:</p><p>(1) Present some possible functions and features for tokenized text support in XQuery and XPath.</p><p>(2) Illustrate simple and complex queries. The more complex queries would normally only be constructed by programmers, librarians, and other expert users.  
Sometimes they may be provided for novice users via saved queries and graphical user interfaces.  Each query illustrates a single functionality. Queries may overlap in their functionalities (e.g., phrases and ordered distance queries allowing no intervening words). Overlapping and similar functionalities are noted in 
the comments on query behavior.</p><p>(3) Draw from sample data which are almost entirely in English. Use cases in other languages are solicited, especially where they 
illustrate language-specific implementations of functions and features. Among the most sought after are use cases for queries 
using prefix and infix wildcards, proximity queries, and operators and queries requiring functionality which may not have Western language equivalents.</p><p>(4) Include queries which in most instances can be written with pure Boolean full-text predicates or 
with scoring (e.g., scoring on the number of occurrences of a word or phrase,
scoring on how close words are to one another within a distance
query, scoring on how similar a word is to the one being
stemmed) <bibref ref="BYR99"/>
<bibref ref="HTK00"/>. A few, those in Section 17 (SCORE), cannot be written with Boolean full-text predicates. Scoring methodologies will not be defined in this recommendation. Scoring will be 
implementation-defined. Results are provided in document order, except those in Section 17 (SCORE). 
Results could be returned ordered differently, such as by relevance (based on 
implementation-defined scoring) or explicitly by element.</p><p>(5) Query element content. See Section 4 (OTHER) for explicit queries on attribute values.</p><p>(6) Include queries which are case insensitive. When
returning a paragraph, the text is returned as it occurs in the data model. This approach was chosen to keep the sample data short and the expected 
results meaningful. It would have been equally valid to return only the words queried. A case-sensitive query is found in Section 9 (CHARACTER). </p><p>(7) Include queries which when they target XML elements are understood,
unless otherwise stated, to query text within any text node descendant of the element.</p><p>(8) Include queries which return only elements and attributes which meet all the conditions specified in the query. In particular, pure Boolean full-text predicate queries return results 
where the Boolean conditions in the query are satisfied, i.e., are used to select what is being returned to users.</p><p>Query results may be returned in different ways. From a query for books containing the word "usability", users might be interested in returning, for each
book containing the word "usability", its number and its entire content. In another situation for the same query, users might be interested in
returning, for each book containing the word "usability", its number and only the elements and attributes in the content which contain the word "usability". As in this second situation, the queries in
these use cases return only elements and attributes which meet all the conditions specified in the query.</p><p>The Return clause may also include additional or different elements and attributes if specified, and may construct new elements. </p><p>(9) Include queries which provide some of the basic functionality of fuzzy match querying  (e.g., wildcards, stemming, thesaurus support, proximity).</p><p>(10) Provide highlighting of found words and phrases in the expected results of queries as an aid to users. 
The presence of highlighting says nothing about whether highlighting will be a 	feature of XQuery or XPath full-text querying.</p><p>(11) Display query solutions in XQuery and when possible in XPath. Queries that may not be written in XPath include those that contain element constructors and that cannot be written without let, where, and order by clauses.</p><!---Several implementors have asked that we make the
            queries from these use cases available in a separate file
            to make it easier for them to test their parsers.  These
            queries may be found in <bibref ref="XQueryFullTextUseCaseQueries"/> and <bibref ref="XPathFullTextUseCaseQueries"/>. Also, the queries from the XQuery
            specification itself have been made available in <bibref ref="XQueryFullTextQueries"/>.--><p>Examples of full-text querying functionalities for XML query languages
can be found in <bibref ref="FGR01"/>, <bibref ref="HTK00"/>,
<bibref ref="MJK98"/>, <bibref ref="SCH01"/> and <bibref ref="TWE00"/>.</p><p>To make the output more readable, the output of queries has been 
formatted using whitespace which may not be returned by a query 
processor. This whitespace should not be considered normative 
for the correctness of results.</p></div2><div2 id="FT_UC_Presentation"><head>Presentation of Use Cases</head><p>The queries in these use cases are presented in the following format:</p><p>Query number   Query title</p><p>User statement of query</p><p>Statement of functionality illustrated by query</p><ulist><item><p>Operands: Parts of words, words, phrases</p></item><item><p>Functionality: Operators, functions, collations, other functionality</p></item><item><p>Data context: One XPath expression locating the data being queried.</p></item><item><p>Query context: One or more XPath expressions locating the elements and attributes to be queried. The context of elements and attributes used in the Query context is relative to the Data context defined above.</p></item><item><p>Return: One or more XPath expressions which are returned only if the conditions specified in the query are met. Returned elements or attributes may differ from those specified in the Query context. Newly constructed elements might be returned. As in the Query context, the context of elements and attributes in Return statements is relative to the Data context defined above.</p></item><item><p>Comments: Comments on query behavior in general, and against the sample data in particular, plus the rationale for including 
				this query in the use cases.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg xml:space="preserve">Solutions illustrating XQuery Full Text syntax  
appear here. All queries may be written in XQuery.

Solutions are written with pure Boolean full-text predicates 
and not to invoke scoring, except for those in Section 17 (SCORE), 
however all the queries in the document may be written as scored 
queries with the addition of a score variable.

All queries are written assuming the default function namespace, 
without the fn: prefix.</eg><p>
<emph>Solution in XPath:</emph>
</p><eg xml:space="preserve">Solutions illustrating XPath Full Text syntax appear 
(when the query may be written in XPath) here.

Solutions are written with pure Boolean full-text predicates 
and not to invoke scoring, except for those in Section 17 (SCORE), 
however most of the queries in the document may be written as 
scored queries with the addition of a score variable.

All queries are written assuming the default function namespace, 
without the fn: prefix.</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">Results are provided here.
				
Found words and phrases are <phrase role="found">highlighted</phrase>. 
				
For brevity, only the elements and attributes which meet 
the conditions specified in the query are displayed. Others are
replaced with ...s.

Results are provided in document order, except those 
in Section 17 (SCORE)</eg></div2><div2 id="FT_UC_Schema"><head>Schema for Sample Data</head><p>The example queries in these use cases are based on a
                collection with the following XML Schema:</p><eg role="schema" xml:space="preserve">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" 
version="1.0"&gt;
&lt;xs:import namespace="http://www.w3.org/XML/1998/namespace" 
schemaLocation = "http://www.w3.org/2001/xml.xsd"/&gt;
   &lt;xs:element name="books"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;A possible XML Schema for Sample Data 
         in XQuery and XPath Full Text Use Cases
         &lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:complexType&gt;
         &lt;xs:sequence maxOccurs="unbounded"&gt;
            &lt;xs:element name="book"&gt;
               &lt;xs:complexType&gt;
                  &lt;xs:sequence&gt;
                     &lt;xs:element name="metadata" 
                     type="metadataType"/&gt;
                     &lt;xs:element name="content" 
                     type="contentType"/&gt;
                  &lt;/xs:sequence&gt;
                  &lt;xs:attribute name="number" type="xs:integer"/&gt;
               &lt;/xs:complexType&gt;
            &lt;/xs:element&gt;
         &lt;/xs:sequence&gt;
      &lt;/xs:complexType&gt;
   &lt;/xs:element&gt;
   &lt;xs:complexType name="anyXMLTextType" mixed="true"&gt;
      &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;free text, contains any well-formed 
         XML&lt;/xs:documentation&gt;
      &lt;/xs:annotation&gt;
      &lt;xs:sequence&gt;
         &lt;xs:any processContents="skip" minOccurs="0" 
         maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="metadataType"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element name="title"&gt;
            &lt;xs:complexType&gt;
               &lt;xs:simpleContent&gt;
                  &lt;xs:extension base="xs:string"&gt;
                     &lt;xs:attribute name="shortTitle" 
                     type="xs:string"/&gt;
                  &lt;/xs:extension&gt;
               &lt;/xs:simpleContent&gt;
            &lt;/xs:complexType&gt;
         &lt;/xs:element&gt;
         &lt;xs:element name="author" type="xs:string" 
         minOccurs="0" 
         maxOccurs="unbounded"/&gt;
         &lt;xs:element name="publicationInfo" 
         type="publicationInfoType"/&gt;
         &lt;xs:element name="price" minOccurs="0"&gt;
            &lt;xs:simpleType&gt;
               &lt;xs:restriction base="xs:float"&gt;
                  &lt;xs:minInclusive value="0"/&gt;
                  &lt;xs:maxInclusive value="10000"/&gt;
               &lt;/xs:restriction&gt;
            &lt;/xs:simpleType&gt;
         &lt;/xs:element&gt;
         &lt;xs:element name="subjects" 
         maxOccurs="unbounded"&gt;
            &lt;xs:sequence&gt;
               &lt;xs:element name="subject" type="xs:string" 
               maxOccurs="unbounded"/&gt;
            &lt;/xs:sequence&gt;
               &lt;xs:attribute ref="xml:lang"/&gt;
         &lt;/xs:element&gt;
      &lt;/xs:sequence&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="publicationInfoType"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element name="place" type="xs:string" 
         minOccurs="0"/&gt;
         &lt;xs:element name="publisher" type="xs:string" 
         maxOccurs="unbounded"/&gt;
         &lt;xs:element name="dateIssued" type="xs:string"/&gt;
         &lt;xs:element name="dateRevised" type="xs:string"/&gt;
      &lt;/xs:sequence&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="contentType"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element name="introduction" 
         type="introductionType" 
         minOccurs="0"/&gt;
         &lt;xs:element name="part" type="partType" 
         maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="introductionType"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element name="author" type="xs:string" 
         minOccurs="0"/&gt;
         &lt;xs:element name="p" maxOccurs="unbounded"&gt;
            &lt;xs:complexType mixed="true"&gt;
               &lt;xs:choice minOccurs="0" 
               maxOccurs="unbounded"&gt;
                  &lt;xs:element name="b"/&gt;
                  &lt;xs:element name="emph"/&gt;
                  &lt;xs:element name="i"/&gt;
               &lt;/xs:choice&gt;
            &lt;/xs:complexType&gt;
         &lt;/xs:element&gt;
      &lt;/xs:sequence&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="partType"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element name="container" type="xs:string" 
         minOccurs="0"&gt;
             &lt;xs:complexType&gt;
               &lt;xs:simpleContent&gt;
                  &lt;xs:extension base="xs:string"&gt;
                     &lt;xs:attribute name="type" type="xs:string"/&gt;
                  &lt;/xs:extension&gt;
               &lt;/xs:simpleContent&gt;
            &lt;/xs:complexType&gt;
         &lt;/xs:element&gt;
         &lt;xs:element name="title" type="titleType" 
         minOccurs="0"/&gt;
         &lt;xs:element name="introduction" 
         type="introductionType" 
         minOccurs="0"/&gt;
         &lt;xs:element name="chapter" type="chapterType" 
         minOccurs="0" maxOccurs="unbounded"/&gt;
         &lt;xs:element name="component" 
         type="componentType" 
         minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
      &lt;xs:attribute name="number" type="xs:string"/&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="chapterType"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element name="title" type="xs:string"/&gt;
         &lt;xs:element name="p" type="anyXMLTextType" 
         maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="footnoteType" mixed="true"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element name="citation" type="xs:string"
         minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xs:complexType&gt;
               &lt;xs:simpleContent&gt;
                  &lt;xs:extension base="xs:string"&gt;
                     &lt;xs:attribute name="url" type="xs:anyURI"/&gt;
                  &lt;/xs:extension&gt;
               &lt;/xs:simpleContent&gt;
            &lt;/xs:complexType&gt;
         &lt;/xs:element&gt;
      &lt;/xs:sequence&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="componentType"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element name="container" type="xs:string" 
         minOccurs="0"&gt;
            &lt;xs:complexType&gt;
               &lt;xs:simpleContent&gt;
                  &lt;xs:extension base="xs:string"&gt;
                     &lt;xs:attribute name="type" type="xs:string"/&gt;
                  &lt;/xs:extension&gt;
               &lt;/xs:simpleContent&gt;
            &lt;/xs:complexType&gt;
         &lt;/xs:element&gt;
         &lt;xs:element name="componentTitle" 
         type="componentTitleType"/&gt;
         &lt;xs:element name="subComponent" 
         type="subComponentType" 
         minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="titleType" mixed="true"&gt;
      &lt;xs:all minOccurs="0"&gt;
         &lt;xs:element name="date" type="xs:string"&gt;
            &lt;xs:complexType&gt;
               &lt;xs:simpleContent&gt;
                  &lt;xs:extension base="xs:string"&gt;
                     &lt;xs:attribute name="normalize" 
                     type="xs:string"/&gt;
                  &lt;/xs:extension&gt;
               &lt;/xs:simpleContent&gt;
            &lt;/xs:complexType&gt;
         &lt;/xs:element&gt;
      &lt;/xs:all&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="componentTitleType" 
   mixed="true"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element name="componentDate" 
         type="xs:string" 
        minOccurs="0"&gt;
            &lt;xs:complexType&gt;
               &lt;xs:simpleContent&gt;
                  &lt;xs:extension base="xs:string"&gt;
                     &lt;xs:attribute name="normalize" 
                     type="xs:string"
                      use="optional"/&gt;
                  &lt;/xs:extension&gt;
               &lt;/xs:simpleContent&gt;
            &lt;/xs:complexType&gt; 
         &lt;/xs:element&gt;
      &lt;/xs:sequence&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="subComponentType"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element name="container" type="xs:string" 
         minOccurs="0"&gt;
            &lt;xs:complexType&gt;
               &lt;xs:simpleContent&gt;
                  &lt;xs:extension base="xs:string"&gt;
                     &lt;xs:attribute name="type" type="xs:string"/&gt;
                  &lt;/xs:extension&gt;
               &lt;/xs:simpleContent&gt;
            &lt;/xs:complexType&gt; 
        &lt;/xs:element&gt;
        &lt;xs:element type="componentTitleType"/&gt;
        &lt;xs:element name="subsubComponent" 
        type="subSubComponentType" 
        minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
   &lt;/xs:complexType&gt;
   &lt;xs:complexType name="subSubComponentType"&gt;
      &lt;xs:sequence&gt;
         &lt;xs:element name="container" type="xs:string" 
         minOccurs="0"&gt;
           &lt;xs:complexType&gt;
              &lt;xs:simpleContent&gt;
                 &lt;xs:extension base="xs:string"&gt;
                    &lt;xs:attribute name="type" type="xs:string"/&gt;
                 &lt;/xs:extension&gt;
              &lt;/xs:simpleContent&gt;
           &lt;/xs:complexType&gt; 
        &lt;/xs:element&gt;
        &lt;xs:element name="componentTitle" 
        type="componentTitleType"/&gt;
      &lt;/xs:sequence&gt;
   &lt;/xs:complexType&gt;
&lt;/xs:schema&gt;</eg></div2><div2 id="FT_UC_SampleData"><head>Sample Data</head><p>The data consists of a collection of three books. Two are primarily instructive text. The third is a guide to a manuscript collection. All 
contain metadata and full text.</p><p>The sample data binds to this URL: "http://bstore1.example.com/full-text.xml".</p><eg role="sample" xml:space="preserve">&lt;books&gt;
&lt;book number="1"&gt;
   &lt;metadata&gt;
      &lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
      the Usability of a Web Site Through Expert Reviews and 
      Usability Testing&lt;/title&gt;
      &lt;author&gt;Millicent Marigold&lt;/author&gt;
      &lt;author&gt;Montana Marigold&lt;/author&gt;
      &lt;publicationInfo&gt;
         &lt;place&gt;New York&lt;/place&gt;
         &lt;publisher&gt;Ersatz Publications&lt;/publisher&gt;
         &lt;dateIssued&gt;2001&lt;/dateIssued&gt;
         &lt;dateRevised&gt;2002&lt;/dateRevised&gt;
      &lt;/publicationInfo&gt;
      &lt;price&gt;25.99&lt;/price&gt;   
      &lt;subjects xml:lang="en"&gt;
         &lt;subject&gt;Usability testing&lt;/subject&gt;
         &lt;subject&gt;Web site development&lt;/subject&gt;        
         &lt;subject&gt;Heuristic evaluation&lt;/subject&gt;
         &lt;subject&gt;Cognitive walk-through&lt;/subject&gt;
         &lt;subject&gt;Web site usability&lt;/subject&gt;
      &lt;/subjects&gt;
      &lt;subjects xml:lang="fr"&gt;        
         &lt;subject&gt;Tests d'ergonomie&lt;/subject&gt;
         &lt;subject&gt;Développement de site web&lt;/subject&gt;        
         &lt;subject&gt;Évaluation heuristique&lt;/subject&gt;
         &lt;subject&gt;Parcours cognitif&lt;/subject&gt;
         &lt;subject&gt;Ergonomie de site web&lt;/subject&gt;     
      &lt;/subjects&gt;
      &lt;subjects xml:lang="zh"&gt;    
         &lt;subject&gt;可用性测试&lt;/subject&gt;
         &lt;subject&gt;网站建置&lt;/subject&gt;        
         &lt;subject&gt;启发式评价&lt;/subject&gt;
         &lt;subject&gt;认知推演&lt;/subject&gt;
         &lt;subject&gt;网站可用性&lt;/subject&gt;
      &lt;/subjects&gt;
   &lt;/metadata&gt;
   &lt;content&gt;
      &lt;introduction&gt;
         &lt;author&gt;Elina Rose&lt;/author&gt;
         &lt;p&gt;The usability of a Web site is how well the 
         site supports the user in achieving specified 
         goals. A Web site should facilitate learning, 
         and enable efficient and effective task 
         completion, while propagating few errors. 
         Satisfaction with the site is also important. 
         The user must not only be well-served, but must 
         feel well-served.&lt;/p&gt; 
         &lt;p&gt;Expert reviews and usability testing are 
         methods of identifying problems in layout, 
         terminology, and navigation before they frustrate
         users and drive them away from your site.&lt;/p&gt;
         &lt;p&gt;The most successful projects employ multiple 
         methods in multiple iterations. As Millicent 
         Marigold remarked during a recent conference, 
         "Don't stop. Iterate, iterate, then iterate 
         again."&lt;/p&gt;
         &lt;p&gt;This book has been approved by the Web Site 
         Users Association.&lt;/p&gt;
      &lt;/introduction&gt;
      &lt;part number="1"&gt;
         &lt;title&gt;Expert Reviews&lt;/title&gt;
         &lt;introduction&gt;
            &lt;p&gt;Expert reviewers identify problems 
            and recommend changes to web sites based 
            on research in human computer interaction 
            and their experience in the field.&lt;/p&gt; 
            &lt;p&gt;Two expert review methods are discussed 
            here. They are heuristic evaluation and 
            cognitive walk-through.&lt;/p&gt; 
            &lt;p&gt;Expert review methods should be 
            initiated early in the development process, 
            as soon as paper &lt;b&gt;p&lt;/b&gt;rototypes 
            (hand-drawn pictures of Web pages) or 
            &lt;b&gt;w&lt;/b&gt;ireframes (electronic mockups) are 
            available. They should be conducted using 
            the hardware and software similar to that 
            employed by users.&lt;/p&gt;
         &lt;/introduction&gt;
         &lt;chapter&gt;
            &lt;title&gt;Heuristic Evaluation&lt;/title&gt;
            &lt;p&gt;Expert reviewers critique an interface to 
            determine conformance with recognized 
            usability principles. &lt;footnote&gt;One of the 
            best known lists of heuristics is &lt;citation 
            url="http://www.useit.com/papers/heuristic
            /heuristic_list.html"&gt;Ten Usability 
            Heuristics by Jacob Nielson&lt;/citation&gt;. Another 
            is &lt;citation url="http://usability.gov
            /guidelines/index.html"&gt; Research-Based Web 
            Design and Usability Guidelines&lt;/citation&gt;
            &lt;/footnote&gt;&lt;/p&gt; 
         &lt;/chapter&gt;
         &lt;chapter&gt;
            &lt;title&gt;Cognitive Walk-Through&lt;/title&gt;
            &lt;p&gt;Expert reviewers evaluate Web site 
            understandability and ease of learning while 
            performing specified tasks. They walk through 
            the site answering questions such as "Would a 
            user know by looking at the screen how to 
            complete the first step of the task?" and "If 
            the user completed the first step, would the 
            user know what to do next?," with the goal of 
            identifying any obstacles to completing the 
            task and assessing whether the user would 
            cognitively be aware that he was successful in 
            completing a step in the process.&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Usability Testing&lt;/title&gt;
            &lt;p&gt;Once the problems identified by expert 
            reviews have been corrected, it is time to 
            conduct some tests of the site with your unique 
            audience or audiences by conducting usability 
            testing.&lt;/p&gt;
            &lt;p&gt;Users are asked to complete tasks which 
            measure the success of the information 
            architecture and navigational elements of the 
            site.&lt;/p&gt;
            &lt;p&gt;Then changes are made to improve service to 
            users.&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt; 
   &lt;/content&gt;
&lt;/book&gt;

&lt;book number="2"&gt;
   &lt;metadata&gt;
      &lt;title shortTitle="Usability Basics"&gt;Usability 
      Basics: How to Plan for and Conduct Usability Tests 
      on Web Site Thereby Improving the Usability of Your 
      Web Site&lt;/title&gt;
      &lt;publicationInfo&gt;
         &lt;place&gt;New York&lt;/place&gt;
         &lt;publisher&gt;Ersatz Publications&lt;/publisher&gt;
         &lt;publisher&gt;Electronic BookWorks&lt;/publisher&gt;         
         &lt;dateIssued&gt;2000&lt;/dateIssued&gt;
         &lt;dateRevised&gt;2001&lt;/dateRevised&gt;
      &lt;/publicationInfo&gt;
      &lt;price&gt;174.00&lt;/price&gt;   
      &lt;subjects xml:lang="en"&gt;
         &lt;subject&gt;Usability testing&lt;/subject&gt;
         &lt;subject&gt;Web site development&lt;/subject&gt;
         &lt;subject&gt;Guides and finding aids&lt;/subject&gt;
      &lt;/subjects&gt;
      &lt;subjects xml:lang="fr"&gt;
         &lt;subject&gt;Tests d'ergonomie&lt;/subject&gt;
         &lt;subject&gt;Développement de site web&lt;/subject&gt;
         &lt;subject&gt;Guides et outils de recherche&lt;/subject&gt;
      &lt;/subjects&gt;
      &lt;subjects xml:lang="zh"&gt;
         &lt;subject&gt;可用性测试&lt;/subject&gt;
         &lt;subject&gt;网站建置&lt;/subject&gt;
         &lt;subject&gt;指南和检索工具&lt;/subject&gt;
      &lt;/subjects&gt;
   &lt;/metadata&gt;
   &lt;content&gt;
      &lt;introduction&gt;
         &lt;p&gt;This is a basic handbook for planning and 
         conducting usability tests on Web sites. Usability 
         testing should be used in conjunction with other 
         expert review methods.&lt;/p&gt;
         &lt;p&gt;This book has not been approved by the Web Site 
         Users Association.&lt;/p&gt;
      &lt;/introduction&gt;
      &lt;part number="1"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Planning then Conducting Usability 
            Tests&lt;/title&gt; 
            &lt;p&gt;Take the following steps to plan usability 
            testing. &lt;step number="1"&gt;Clarify and 
            articulate the goal of the usability testing.
            &lt;/step&gt; &lt;step number="2"&gt;Identify tasks which 
            are critical for users to be able to complete 
            successfully.&lt;/step&gt; &lt;step number="3"&gt;Compile 
            a script of questions or instructions which 
            will prompt the user to attempt those 
            tasks.&lt;/step&gt; &lt;step number="4"&gt;Identify your 
            users and begin recruiting them.&lt;/step&gt; &lt;step 
            number="5"&gt;Conduct a pretest on a few users.
            &lt;/step&gt; &lt;step number="6"&gt;Edit the script based 
            on insights gleaned from the pretest.&lt;/step&gt; 
            &lt;step number="7"&gt;Resume testing.&lt;/step&gt;&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Conducting Usability Tests&lt;/title&gt; 
         &lt;p&gt;Users can be tested at any computer 
            workstation &lt;footnote&gt;They may be more 
            comfortable at their own workstation than in 
            a lab.&lt;/footnote&gt; or in a lab.&lt;/p&gt;
            &lt;p&gt;Give the user the script, then assure them 
            that you are testing the Web site, not them. 
            Users are asked to verbalize their thoughts as 
            they complete the tasks. The event is recorded 
            or someone takes notes. It is often preferable 
            to have two testers, &lt;footnote&gt;Usability 
            testing can be done at great expense or on a 
            shoe string, using &lt;testingProcedure&gt;in-house 
            expertise&lt;/testingProcedure&gt; or 
            &lt;testingProcedure&gt;contracting with human 
            computer interaction professionals
            &lt;/testingProcedure&gt;.&lt;/footnote&gt; one to ask the 
            questions, another to take notes. Testers should 
            offer no guidance or comments to the user. Mouse 
            movements, typing, expressions, and the user's 
            words should be recorded.&lt;/p&gt;
         &lt;/chapter&gt;
         &lt;chapter&gt;
            &lt;title&gt;Evaluating and Implementing Results&lt;/title&gt; 
            &lt;p&gt;Compile the results and review collectively. 
            Make changes to the site to alleviate the problems 
            found in Web site components which were propagating 
            the largest number of or the most devastating errors. 
            Begin new iterations of testing and changes, until 
            users are successful in the accomplishing the 
            tasks.&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;
   &lt;/content&gt;
&lt;/book&gt;

&lt;book number="3"&gt;
   &lt;metadata&gt;
      &lt;title shortTitle="Usabilityguy Manuscript 
      Guide"&gt;John Wesley Usabilityguy: A Register of His 
      Papers&lt;/title&gt;
      &lt;author&gt;Millicent Marigold&lt;/author&gt;
      &lt;author&gt;Morty Marigold&lt;/author&gt;
      &lt;publicationInfo&gt;  
         &lt;place&gt;Washington, D.C.&lt;/place&gt;    
         &lt;publisher&gt;Ersatz Manuscript Library&lt;/publisher&gt;
         &lt;dateIssued&gt;1998&lt;/dateIssued&gt;
         &lt;dateRevised&gt;2002&lt;/dateRevised&gt;
      &lt;/publicationInfo&gt;
      &lt;price&gt;21.49&lt;/price&gt;   
      &lt;subjects xml:lang="en"&gt;
         &lt;subject&gt;Computers&lt;/subject&gt;
         &lt;subject&gt;Software evaluation&lt;/subject&gt;
         &lt;subject&gt;Usability testing&lt;/subject&gt;
         &lt;subject&gt;Manuscript collections&lt;/subject&gt;
      &lt;/subjects&gt;
      &lt;subjects xml:lang="fr"&gt;
         &lt;subject&gt;Ordinateurs&lt;/subject&gt;
         &lt;subject&gt;Évaluation de logiciels&lt;/subject&gt;
         &lt;subject&gt;Tests d'ergonomie&lt;/subject&gt;
         &lt;subject&gt;Collections de manuscrits&lt;/subject&gt;
      &lt;/subjects&gt;
      &lt;subjects xml:lang="zh"&gt;
         &lt;subject&gt;计算机&lt;/subject&gt;
         &lt;subject&gt;软件评价&lt;/subject&gt;
         &lt;subject&gt;可用性测试&lt;/subject&gt;
         &lt;subject&gt;手稿专藏&lt;/subject&gt;
      &lt;/subjects&gt;
   &lt;/metadata&gt;
   &lt;content&gt;
      &lt;introduction&gt;
         &lt;p&gt;The papers of John Wesley Usabilityguy span the 
         years 1946-2001, with the bulk of the items 
         concentrated in the period from 1985 to 2001. The 
         papers feature his career as a developer of software 
         applications and usability specialist. The collection 
         consists of correspondence, memoranda, journals, 
         speeches, article drafts, book drafts, notes, charts, 
         graphs, family papers, clippings, printed matter, 
         photographs, résumés and other materials.&lt;/p&gt;
      &lt;/introduction&gt;
      &lt;part number="1"&gt;&lt;container type="box"&gt;1-12&lt;/container&gt;
         &lt;title&gt;Subject File, &lt;date normalize="1930/1974"&gt;
         1930-1974&lt;/date&gt;&lt;/title&gt;
         &lt;introduction&gt;
            &lt;p&gt;Correspondence, telegrams, memoranda, journals, 
            logs, testimony, approved travel orders, invitations, 
            charts, graphs, forms, biographical data, photographs, 
            book drafts, clippings and other printed matter, 
            résumés and miscellaneous material. Organized by 
            name of person or organization, topic, or type of 
            material.&lt;/p&gt;
         &lt;/introduction&gt;
         &lt;component&gt;&lt;container type="box"&gt;1&lt;/container&gt;
           &lt;componentTitle&gt;Computers&lt;/componentTitle&gt;
           &lt;subComponent&gt;
              &lt;componentTitle&gt;Software, 
              &lt;componentDate normalize="1946/1947"&gt;1946-1947
              &lt;/componentDate&gt;
              &lt;/componentTitle&gt;
           &lt;/subComponent&gt;
           &lt;subComponent&gt;
              &lt;componentTitle&gt;Human Computer Interaction 
              research, &lt;componentDate normalize="1945/1952"&gt;
              1945-1952&lt;/componentDate&gt;
              &lt;/componentTitle&gt;
              &lt;subsubComponent&gt;
                 &lt;componentTitle&gt;Flow diagram, 
                 &lt;componentDate normalize="1950"&gt;1950
                 &lt;/componentDate&gt;
                 &lt;/componentTitle&gt;
              &lt;/subsubComponent&gt;
              &lt;subsubComponent&gt;
                 &lt;componentTitle&gt;General, 
                 &lt;componentDate normalize="1947/1951"&gt;1947-1951
                 &lt;/componentDate&gt;
                 &lt;/componentTitle&gt;
              &lt;/subsubComponent&gt;
              &lt;subsubComponent&gt;&lt;container type="box"&gt;2&lt;/container&gt;
                 &lt;componentTitle&gt;Eye Movement research,
                 &lt;componentDate normalize="1949/1950"&gt;1949-1950
                 &lt;/componentDate&gt;
                 &lt;/componentTitle&gt;
              &lt;/subsubComponent&gt; 
              &lt;subsubComponent&gt;
                 &lt;componentTitle&gt;User profiling, 
                 &lt;componentDate normalize="1950/1959"&gt;1950s
                 &lt;/componentDate&gt;
                 &lt;/componentTitle&gt;
              &lt;/subsubComponent&gt;
            &lt;/subComponent&gt;
         &lt;/component&gt;
         &lt;component&gt;
           &lt;componentTitle&gt;Web User Appreciation Award, 
           &lt;componentDate normalize="1956"&gt;1956&lt;/componentDate&gt;
           &lt;/componentTitle&gt;
         &lt;/component&gt;
      &lt;/part&gt;
      &lt;part number="2"&gt;&lt;container type="box"&gt;3-5&lt;/container&gt;
         &lt;title&gt;Writings File, 
         &lt;date normalize="1985/1999"&gt;1985-1999&lt;/date&gt;
         &lt;/title&gt;
         &lt;introduction&gt;
            &lt;p&gt;Correspondence, articles, book drafts, notes, 
            contracts, clippings, and printed matter. Arranged 
            alphabetically by type (articles, books, reports, 
            and miscellaneous) and therein alphabetically by 
            type of material, subject, or title.&lt;/p&gt;
         &lt;/introduction&gt;
         &lt;component&gt;
            &lt;componentTitle&gt;Writings by Usabilityguy
            &lt;/componentTitle&gt;
            &lt;subComponent&gt;
               &lt;componentTitle&gt;&lt;componentDate normalize="1996"&gt;
               1996&lt;/componentDate&gt;
               &lt;/componentTitle&gt; 
               &lt;subsubComponent&gt;
                  &lt;componentTitle&gt;"How Many Users Are Enough 
                  for User Testing?"&lt;/componentTitle&gt;
               &lt;/subsubComponent&gt; 
               &lt;subsubComponent&gt;
                  &lt;componentTitle&gt;"How to Evaluate Results from 
                  User Tests."&lt;/componentTitle&gt;
               &lt;/subsubComponent&gt;
               &lt;subsubComponent&gt;
                  &lt;container type="box"&gt;5&lt;/container&gt;
                  &lt;componentTitle&gt;"When Are You Done Testing?"
                  &lt;/componentTitle&gt;
               &lt;/subsubComponent&gt;
               &lt;subsubComponent&gt;
                  &lt;componentTitle&gt;"Do-It-Yourself User Testing"
                  &lt;/componentTitle&gt;
               &lt;/subsubComponent&gt; 
            &lt;/subComponent&gt;
         &lt;/component&gt;
         &lt;component&gt;
            &lt;componentTitle&gt;Charitable Contributions
            &lt;/componentTitle&gt; 
            &lt;subComponent&gt;
               &lt;componentTitle&gt;Diseases: AIDS, Hepatitis, 
               Tuberculosis &lt;componentDate normalize=
               "1990/1999"&gt;1990-1999&lt;/componentDate&gt;
               &lt;/componentTitle&gt;
            &lt;/subComponent&gt; 
            &lt;subComponent&gt;
               &lt;componentTitle&gt;Environmental Conservation: 
               Rivers &lt;componentDate normalize="1995"&gt;1995
               &lt;/componentDate&gt;
               &lt;/componentTitle&gt;
            &lt;/subComponent&gt;
         &lt;/component&gt;
      &lt;/part&gt;
   &lt;/content&gt;
&lt;/book&gt;
&lt;/books&gt;</eg></div2></div1><div1 id="Element"><head>Use Case "ELEMENT": Queries on XML Elements with Simple Content</head><div2 id="element-description"><head>Description</head><p>These use cases query words and phrases in XML elements with simple content.</p><p>These use cases begin with the simplest queries possible. They query a word or phrase in an element with simple content and no descendants. One of these queries is on Chinese characters. Some queries return additional or different elements than were queried. A query queries and returns the full document. Others find a phrase only when it starts an element and find a exact phrase when it is the entire content of an element, allowing full-text variations, such as case, diacritics, and wildcards.</p></div2><div2 id="element-queries-results"><head>Queries and Results</head><div3 id="element-queries-results-q1"><head>Q1 Word Query in an Element</head><p>Find all book titles containing the word "usability".</p><p>This query finds a word in an element.</p><ulist><item><p>Operands: "usability"</p></item><item><p>Functionality: word query</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./metadata/title</p></item><item><p>Return: ./metadata/title</p></item><item><p>Comments: This is the simplest query possible, a query on a word in an element. This
						query does not employ wildcards, stemming, or thesaurus support. While this query finds useful results in the sample 
						data, many queries such as one on the word "test" would not. A query on the word "test" would return no results, missing the word 
						variants which exist in the sample data: "pretest", "tested", "testers", "testimony", "testing", and "tests".</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
   /books/book/metadata/title[. contains text "usability"]</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book/metadata/title[. contains text "usability"]</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
the <phrase role="found">Usability</phrase> of a Web Site Through Expert Reviews 
and <phrase role="found">Usability</phrase> Testing&lt;/title&gt;

&lt;title shortTitle="Usability Basics"&gt;<phrase role="found">Usability</phrase> 
Basics: How to Plan for and Conduct <phrase role="found">Usability</phrase> Tests 
on Web Site Thereby Improving the <phrase role="found">Usability</phrase> of Your 
Web Site&lt;/title&gt;</eg></div3><div3 id="element-queries-results-q2"><head>Q2 Phrase Query in an Element</head><p>Find all book subjects containing the phrase "usability testing".</p><p>This query finds a phrase in an element.</p><ulist><item><p>Operands: "usability testing"</p></item><item><p>Functionality: phrase query</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./metadata/subjects/subject</p></item><item><p>Return: ./metadata/subjects/subject</p></item><item><p>Comments: This is a simple query on a phrase in an element. Like an ordered distance query allowing no intervening words, the words in this phrase query must be adjacent to each other and must appear in the order specified. While this query finds useful results in the sample data, many queries such as one on "software developer" would not. A query on the phrase "software developer" would return no results, missing "developer of software" which exists 
in the sample data.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
   /books/book/metadata/subjects/subject[. contains text 
   "usability testing"]</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book/metadata/subjects/subject[. contains text 
"usability testing"]</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;subject&gt;<phrase role="found">Usability testing</phrase>&lt;/subject&gt;
						
&lt;subject&gt;<phrase role="found">Usability testing</phrase>&lt;/subject&gt;

&lt;subject&gt;<phrase role="found">Usability testing</phrase>&lt;/subject&gt;</eg></div3><div3 id="element-queries-results-q3"><head>Q3 Phrase Query on Chinese Characters in an Element</head><p>Find all book subjects containing the phrase (n-gram) "网站".</p><p>This query finds a phrase (n-gram) in an element.</p><ulist><item><p>Operands: "网站"</p></item><item><p>Functionality: phrase query, language qualifier</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./metadata/subjects/subject</p></item><item><p>Return: ./metadata/subjects/subject</p></item><item><p>Comments: This query finds a phrase (n-gram) consisting of two Chinese characters. It assumes a specific language dependent tokenization.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
   /books/book/metadata/subjects/subject[. contains text 
   "网站" using language "zh"]</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book/metadata/subjects/subject[. contains text 
"网站" using language "zh"]</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;subject&gt;<phrase role="found">网站</phrase>建置&lt;/subject&gt;  
					    
&lt;subject&gt;<phrase role="found">网站</phrase>可用性&lt;/subject&gt;

&lt;subject&gt;<phrase role="found">网站</phrase>建置&lt;/subject&gt;</eg></div3><div3 id="element-results-q4"><head>Q4 Query in Different Elements</head><p>Find all books with "usability tests" in book or chapter titles.</p><p>This query finds a phrase in different elements.</p><ulist><item><p>Operands: "usability tests"</p></item><item><p>Functionality: phrase query</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./metadata/title, ./content/part/chapter/title</p></item><item><p>Return: .</p></item><item><p>Comments: This query is an example of a query in two different elements.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $title := $book/(metadata|content/part/chapter)/title
where $title contains text "usability tests"
return $book</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[(metadata|content/part/chapter)
/title contains text "usability tests"]</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
      &lt;title shortTitle="Usability Basics"&gt;Usability 
      Basics: How to Plan for and Conduct <phrase role="found">Usability Tests</phrase> 
      on Web Site Thereby Improving the Usability of 
      Your Web Site&lt;/title&gt; 
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      ...
      &lt;part number="1"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Planning then Conducting <phrase role="found">Usability</phrase>
            <phrase role="found">Tests</phrase>&lt;/title&gt; 
            ...
         &lt;/chapter&gt;
      &lt;/part&gt;
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Conducting <phrase role="found">Usability Tests</phrase>&lt;/title&gt;
            ...
         &lt;/chapter&gt;
      &lt;/part&gt;
      .... 
   &lt;/content&gt;
&lt;/book&gt;</eg></div3><div3 id="element-results-q5"><head>Q5 Query in an Element Returning Different Elements</head><p>Find all books with the phrase "usability testing" in some subject.</p><p>This query finds a phrase in an element and returns different elements from the same document.</p><ulist><item><p>Operands: "usability testing"</p></item><item><p>Functionality: phrase query</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./metadata/subjects/subject</p></item><item><p>Return: ./metadata/title, ./metadata/author</p></item><item><p>Comments: This query queries the <code>subject</code> element, but does not return it. It returns two different elements.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
where $book/metadata/subjects/subject contains text "usability testing"
return $book/metadata/(title|author)</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[metadata/subjects/subject 
contains text "usability testing"]/metadata/(title|author)</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
the Usability of a Web Site Through Expert Reviews 
and Usability Testing&lt;/title&gt; 
&lt;author&gt;Millicent Marigold&lt;/author&gt;     
&lt;author&gt;Montana Marigold&lt;/author&gt; 
   
&lt;title shortTitle="Usability Basics"&gt;Usability 
Basics: How to Plan for and Conduct Usability Tests 
on Web Site Thereby Improving the Usability of Your 
Web Site&lt;/title&gt;
   
&lt;title shortTitle="Usabilityguy Manuscript 
Guide"&gt;John Wesley Usabilityguy: A Register of His 
Papers&lt;/title&gt;
&lt;author&gt;Millicent Marigold&lt;/author&gt;
&lt;author&gt;Morty Marigold&lt;/author&gt;</eg></div3><div3 id="element-queries-results-q6"><head>Q6 Starts-with Query</head><p>Find all book titles which start with "improving" followed within 2 words by "usability".</p><p>This query finds an element which starts with specific words.</p><ulist><item><p>Operands: "improving" "usability"</p></item><item><p>Functionality: word queries, ordered distance (0 to 2 intervening words), starts-with functionality</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./metadata/title</p></item><item><p>Return: ./metadata/title</p></item><item><p>Comments: The starts-with functionality restricts the query to the first words or phrase in an element. It is especially useful in querying journal 
titles (e.g., <emph>Journal of Psychology</emph>) in large library collections. This query does not find Book 2 which contains the phrase 
"improving the usability" in the <code>title</code> element, because the <code>title</code> element does not start with "improving".</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $title := $book/metadata/title 
where $title contains text "improving" ftand "usability" 
   ordered distance at most 2 words at start
return $title</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book/metadata/title[. contains text "improving" 
ftand "usability" ordered distance at most 2 words 
at start]</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;title shortTitle="Improving Web Site Usability"&gt;<phrase role="found">Improving 
the Usability</phrase> of a Web Site Through Expert Reviews and 
Usability Testing&lt;/title&gt;</eg></div3><div3 id="element-queries-results-q7"><head>Q7 Entire Element Content Query</head><p>Find all books with the entire title "improve the usability of a web site through expert reviews and 
usability testing", allowing any form of the word "improve".</p><p>This query finds the phrase when it is the entire content of an element.</p><ulist><item><p>Operands: "improve the usability of a web site through expert reviews and usability testing"</p></item><item><p>Functionality: phrase query, character wildcard (suffix) (0 or more), entire element content functionality</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./metadata/title</p></item><item><p>Return: ./metadata/title</p></item><item><p>Comments: This query insists that the element contains the entire phrase being queried, no more and no less. It allows full-text variations, such as case, diacritics, and wildcards.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $exactTitle := $book/metadata/title
where $exactTitle contains text "improv.* the usability of a 
   web site through expert reviews and usability testing" 
   using wildcards entire content
return $exactTitle</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book/metadata/title[. contains text 
"improv.* the usability of a web site through expert 
reviews and usability testing" using wildcards entire 
content]</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;title shortTitle="Improving Web Site Usability"&gt;<phrase role="found">Improving 
the Usability of a Web Site Through Expert Reviews and 
Usability Testing</phrase>&lt;/title&gt;</eg></div3></div2></div1><div1 id="Across"><head>Use Case "ACROSS": Queries Across XML Element Boundaries</head><div2 id="across-description"><head>Description</head><p>These use cases by default query across XML element boundaries.</p><p>Boundaries include XML tags: Start-Tags, End-Tags, and Empty-Element Tags. Descendant XML tags and attribute values are removed from the string to be queried by tokenization before the query. At the XQuery Data Model level tags are a syntactic element.</p><p>Find queries in an element which do not query some or all of its descendant elements in Section 14 (IGNORE).</p><p>Find queries on attribute values in Section 4 (OTHER).</p></div2><div2 id="across-queries-results"><head>Queries and Results</head><div3 id="across-queries-results-q1"><head>Q1 Query Across Descendant Elements (No Element Content)</head><p>Find all book chapters containing the phrase "one of the best known lists of heuristics is Ten Usability Heuristics".</p><p>  This query crosses element boundaries.</p><ulist><item><p>Operands: "one of the best known lists of heuristics is Ten Usability Heuristics"</p></item><item><p>Functionality: phrase query</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./content/part/chapter</p></item><item><p>Return: .</p></item><item><p>Comments: Querying across element boundaries is similar to an XQuery and XPath character string function converting the sub-tree 
under an element into a string by removing all markup. The <code>citation</code> element tags, including element names, attribute names, and attribute values, have been removed by tokenization.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $chap := $book//chapter
where $chap contains text "one of the best known lists of 
   heuristics is Ten Usability Heuristics"
return $book</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[.//chapter contains text "one of 
the best known lists of heuristics is Ten Usability 
Heuristics"]</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      ...
      &lt;part number="1"&gt;
         ...
         &lt;chapter&gt; 
            &lt;title&gt;Heuristic Evaluation&lt;/title&gt; 
            &lt;p&gt;Expert reviewers critique an interface to
            determine conformance with recognized 
            usability principles. &lt;footnote&gt;<phrase role="found">One of the</phrase>
            <phrase role="found">best known lists of heuristics is</phrase> &lt;citation
            url="http://www.useit.com/papers/heuristic
            /heuristic_list.html"&gt; <phrase role="found">Ten Usability</phrase> 
            <phrase role="found">Heuristics</phrase> by Jacob Nielson&lt;/citation&gt;. Another
            is &lt;citation url="http://usability.gov
            /guidelines/index.html"&gt; Research-Based Web
            Design and Usability Guidelines&lt;/citation&gt;
            &lt;/footnote&gt;&lt;/p&gt; 
         &lt;/chapter&gt;
         ...
      &lt;/part&gt;
      ...
   &lt;/content&gt;
&lt;/book&gt;</eg></div3><div3 id="across-queries-results-q2"><head>Q2 Query Across Descendant Elements (Highlighting Tags)</head><p>Find all part introductions containing the word "prototypes".</p><p>This query crosses element boundaries.</p><ulist><item><p>Operands: "prototypes"</p></item><item><p>Functionality: word query</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./content/part/introduction</p></item><item><p>Return: .</p></item><item><p>Comments: Querying across element boundaries is similar to an XQuery and XPath character string function converting the sub-tree 
under an element into a string by removing all markup. The <code>bold</code> element tags have been removed by tokenization.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $intro := $book/content/part/introduction
where $intro contains text "prototypes"
return $book</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[content/part/introduction contains text 
"prototypes"]</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="1"&gt; 
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      ...
      &lt;part number="1"&gt;
         &lt;introduction&gt;
            &lt;p&gt;Expert review methods should be
            initiated early in the development process, 
            as soon as paper &lt;b&gt;<phrase role="found">p</phrase>&lt;/b&gt;<phrase role="found">rototypes</phrase>
            (hand-drawn pictures of Web pages) or
            &lt;b&gt;w&lt;/b&gt;ireframes (electronic mockups) are
            available. They should be conducted using
            the hardware and software similar to that 
            employed by users.&lt;/p&gt;
         &lt;/introduction&gt;
         ...
      &lt;/part&gt;
      ...
   &lt;/content&gt;  
&lt;/book&gt;</eg></div3><div3 id="across-queries-results-q3"><head>Q3 Query Across Descendant Elements (Substantive Tags)</head><p>Find all book text with the word "tests".</p><p>This query finds a word in an element and its descendants.</p><ulist><item><p>Operands: "tests"</p></item><item><p>Functionality: word query</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./content</p></item><item><p>Return: .</p></item><item><p>Comments: Querying across element boundaries is similar to an XQuery and XPath character string function converting the sub-tree 
under an element into a string by removing all markup.  Element tags, including element names, attribute names, and attribute values, have been removed by tokenization, including <code>part</code>, 
<code>chapter</code>, <code>title</code>, <code>p</code>, <code>component</code>, <code>subComponent</code>, <code>subsubComponent</code>, and <code>componentTitle</code> tags.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content
where $cont contains text "tests"
return $book</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text "tests"]</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      ...
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Usability Testing&lt;/title&gt;
            &lt;p&gt;Once the problems identified by expert 
            reviews have been corrected, it is time to 
            conduct some <phrase role="found">tests</phrase> of the site with your unique 
            audience or audiences by conducting usability 
            testing.&lt;/p&gt;
            ...
         &lt;/chapter&gt;
      &lt;/part&gt; 
      ...
   &lt;/content&gt;
&lt;/book&gt;      
   
&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      &lt;introduction&gt;
         &lt;p&gt;This is a basic handbook for planning and 
         conducting usability <phrase role="found">tests</phrase> on Web sites. Usability 
         testing should be used in conjunction with other 
         expert review methods.&lt;/p&gt;
          ...
      &lt;/introduction&gt;
      &lt;part number="1"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Planning then Conducting Usability 
            <phrase role="found">Tests</phrase>&lt;/title&gt;   
            ...
         &lt;/chapter&gt;
      &lt;/part&gt;   
      ...
   &lt;/content&gt;
&lt;/book&gt;   

&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;     
   &lt;content&gt;
      ...
      &lt;component&gt;
         &lt;componentTitle&gt;Writings by Usabilityguy
         &lt;/componentTitle&gt;
         &lt;subComponent&gt;
           &lt;componentTitle&gt;&lt;componentDate normalize="1996"&gt;
           1996&lt;/componentDate&gt;
           &lt;/componentTitle&gt; 
           ...
           &lt;subsubComponent&gt;
           &lt;componentTitle&gt;"How to Evaluate Results from 
           User <phrase role="found">Tests</phrase>."&lt;/componentTitle&gt;
           &lt;/subsubComponent&gt;
         &lt;/subComponent&gt;
         ...
      &lt;component&gt;
      ...
   &lt;/content&gt;
&lt;/book&gt;</eg></div3><div3 id="across-queries-results-q4"><head>Q4 Query Across Siblings</head><p>Find all book text with the phrase "usability testing once the problems".</p><p>This query finds a phrase which begins in one element and ends in a sibling.</p><ulist><item><p>Operands: "usability testing once the problems"</p></item><item><p>Functionality: phrase query</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./content</p></item><item><p>Return: .</p></item><item><p>Comments: Querying across element boundaries is similar to an XQuery and XPath character string function converting the sub-tree 
under an element into a string by removing all markup. Element tags, including element names, attribute names, and attribute values, have been removed by tokenization, including <code>title</code> and <code>p</code> tags.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content 
where $cont contains text "usability testing once the 
   problems"
return $book</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text "usability 
testing once the problems"]</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ...   
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;<phrase role="found">Usability Testing</phrase>&lt;/title&gt;
            &lt;p&gt;<phrase role="found">Once the problems</phrase> identified by expert 
            reviews have been corrected, it is time to 
            conduct some tests of the site with your unique 
            audience or audiences by conducting usability 
            testing.&lt;/p&gt;
            ...
         &lt;/chapter&gt;
      &lt;/part&gt; 
   &lt;/content&gt;
&lt;/book&gt;</eg></div3><div3 id="across-queries-results-q5"><head>Q5 Query in Different Sub-Trees</head><p>Find all books with word "identify" in book introductions or part introductions.</p><p>This query finds a word in an element in different sub-trees.</p><ulist><item><p>Operands: "identify"</p></item><item><p>Functionality: word query, character wildcard (suffix) (0 or more)</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./content/introduction, ./content/part/introduction</p></item><item><p>Return: .</p></item><item><p>Comments: This query looks for a word in multiple instances of the <code>introduction</code> element which appear as children 
of the <code>content</code> or <code>part</code> elements.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $intro := $book/content/(introduction|part/introduction)   
where $intro [./p contains text "identif.*" using wildcards]
return $book</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[content/(introduction|part/introduction) 
contains text "identif.*" using wildcards]</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="1"&gt;  
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;					    
      &lt;introduction&gt;
         ...
         &lt;p&gt;Expert reviews and usability testing are 
         methods of <phrase role="found">identifying</phrase> problems in layout, 
         terminology, and navigation before they frustrate
         users and drive them away from your site.&lt;/p&gt;
         ...
      &lt;/introduction&gt;
      &lt;part number="1"&gt;
         &lt;title&gt;Expert Reviews&lt;/title&gt;    
         &lt;introduction&gt;
             &lt;p&gt;Expert reviewers <phrase role="found">identify</phrase> problems 
             and recommend changes to web sites based 
             on research in human computer interaction 
             and their experience in the field.&lt;/p&gt; 
             ...
         &lt;/introduction&gt;
         ...
      &lt;/part&gt; 
   &lt;/content&gt;
&lt;/book&gt; </eg></div3><div3 id="across-queries-results-q6"><head>Q6 Query on Entire Document</head><p>Find all books if any one contains the word "mouse".</p><p>This query finds a word in a document (anywhere in the document), crossing all element boundaries.</p><ulist><item><p>Operands: "mouse"</p></item><item><p>Functionality: word query</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books</p></item><item><p>Query context: .</p></item><item><p>Return: .</p></item><item><p>Comments: This query queries the root element and all its descendants. Querying across element boundaries is similar to an XQuery and XPath character string function converting the sub-tree under an element into a string by removing all markup. Element tags, including element names, attribute names, and attribute values, have been removed by tokenization. This query looks for a word inside an entire document and returns the entire document if the word exists. It does not employ wildcards, stemming, or thesaurus support. It is similar to search engine queries that search a collection of documents and return a subset of the searched collection.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")[. 
 contains text "mouse"]/books/book</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")[. 
 contains text "mouse"]/books/book</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      ...
   &lt;/content&gt;
&lt;/book&gt;

&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      ...
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Conducting Usability Tests&lt;/title&gt; 
            ...
            &lt;p&gt;Give the user the script, then assure them 
            that you are testing the Web site, not them. 
            Users are asked to verbalize their thoughts as 
            they complete the tasks. The event is recorded 
            or someone takes notes. It is often preferable 
            to have two testers, &lt;footnote&gt;Usability 
            testing can be done at great expense or on a 
            shoe string, using &lt;testingProcedure&gt;in-house 
            expertise&lt;/testingProcedure&gt; or 
            &lt;testingProcedure&gt;contracting with human 
            computer interaction professionals
            &lt;/testingProcedure&gt;.&lt;/footnote&gt; one to ask the 
            questions, another to take notes. Testers should 
            offer no guidance or comments to the user. <phrase role="found">Mouse</phrase> 
            movements, typing, expressions, and the user's 
            words should be recorded.&lt;/p&gt;
         &lt;/chapter&gt;
         ...
      &lt;/part&gt;
   &lt;/content&gt;
&lt;/book&gt;

&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      ...
   &lt;/content&gt;
&lt;/book&gt;</eg></div3></div2></div1><div1 id="Other"><head>Use Case "OTHER": Queries on Attribute Values</head><div2 id="other-description"><head>Description</head><p>Unlike all the other use cases in this document which query element content implicitly, these use cases query XML attribute values. Attribute values are not queried implicitly; they are queried explicitly.</p></div2><div2 id="other-queries-results"><head>Queries and Results</head><div3 id="other-queries-results-q1"><head>Q1 Query on Attribute</head><p>Find all books with "improve" "web" "usability" in the short title.</p><p>This query finds multiple words in an attribute allowing word variants and allowing the words in any order with up to a specified number of intervening words.</p><ulist><item><p>Operands: "improve" "web" "usability" </p></item><item><p>Functionality: word queries, stemming, unordered distance (0 to 2 intervening words)</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./metadata/title/@shortTitle</p></item><item><p>Return: ./metadata/title</p></item><item><p>Comments: This query illustrates full-text querying in an attribute.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
where $book/metadata/title/@shortTitle contains text "improve" 
   using stemming ftand "web" ftand "usability" distance 
   at most 2 words    
return $book/metadata/title</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[metadata/title/@shortTitle contains text 
"improve" using stemming ftand "web" ftand "usability" 
distance at most 2 words]/metadata/title</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;title shortTitle="<phrase role="found">Improving</phrase> <phrase role="found">Web</phrase> 
Site <phrase role="found">Usability</phrase>"&gt;Improving the Usability of a 
Web Site Through Expert Reviews and Usability 
Testing&lt;/title&gt;</eg></div3><div3 id="other-queries-results-q2"><head>Q2 Query on Element and Attribute</head><p>Find all books with the phrase "manuscript guides" in the short title and the phrase "user profiling" in a component title.</p><p>This query finds a phrase in an attribute and a phrase in an element.</p><ulist><item><p>Operands: "manuscript guides" "user profiling"</p></item><item><p>Functionality: phrase queries, stemming, <code>and</code> query</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./metadata/title/@shortTitle, ./componentTitle</p></item><item><p>Return: ./metadata/title/@shortTitle/text()</p></item><item><p>Comments: This query combines querying in an element with querying in an attribute.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $stitle := $book/metadata/title/@shortTitle    
let $ctitle := $book//componentTitle  
where $stitle contains text "manuscript guides"
   using stemming and $ctitle contains text "user profiling" 
   using stemming
return data($stitle)</eg><p>
<emph>Solution in XPath: None</emph>
</p><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">Usabilityguy <phrase role="found">Manuscript Guide</phrase>
</eg></div3></div2></div1><div1 id="Wildcard"><head>Use Case "WILDCARD": Character Wildcard Queries</head><div2 id="wildcard-description"><head>Description</head><p>These use cases illustrate queries which use wildcards to append or insert a character or sequence of characters to a word or a part of a word. Character wildcards may be prefix (appended before the first character), infix (inserted into a word), or suffix (appended after the last character).</p></div2><div2 id="wildcard-queries-results"><head>Queries and Results</head><div3 id="wildcard-queries-results-q1"><head>Q1 One Character Suffix Wildcard Query</head><p>Find all books with the word "test" with a one character suffix in the text.</p><p>This query finds a word with a one character suffix (one character after the last character).</p><ulist><item><p>Operands: "test"</p></item><item><p>Functionality: word query, character wildcard (suffix) (1)</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./content</p></item><item><p>Return: .</p></item><item><p>Comments: This query finds "tests", but not "pretest, "tested", "testers", "testimony", 
and "testing" which also appear in the sample data. There is no "test" in the sample data, but if there was, this query would not have found it.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content 
where $cont contains text "test." using wildcards
return $book</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text "test." 
using wildcards]</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ...   
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Usability Testing&lt;/title&gt;
            &lt;p&gt;Once the problems identified by expert 
            reviews have been corrected, it is time to 
            conduct some <phrase role="found">tests</phrase> of the site with your unique 
            audience or audiences by conducting usability 
            testing.&lt;/p&gt;
            ...
         &lt;/chapter&gt;
      &lt;/part&gt;   
   &lt;/content&gt;
&lt;/book&gt;      

&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt;
         &lt;p&gt;This is a basic handbook for planning and 
         conducting usability <phrase role="found">tests</phrase> on Web sites. Usability 
         testing should be used in conjunction with other 
         expert review methods.&lt;/p&gt;
         &lt;p&gt;This book has not been approved by the Web Site 
         Users Association.&lt;/p&gt;
      &lt;/introduction&gt;
      &lt;part number="1"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Planning then Conducting Usability 
            <phrase role="found">Tests</phrase>&lt;/title&gt; 
             ...
         &lt;/chapter&gt;
      &lt;/part&gt;
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Conducting Usability <phrase role="found">Tests</phrase>&lt;/title&gt;  
            ...  
         &lt;/chapter&gt;
         ...  
      &lt;/part&gt;      
      ...        				  
   &lt;/content&gt; 
&lt;/book&gt;     
   
&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ...   
     &lt;part number="2"&gt;&lt;container type="box"&gt;3-5&lt;/container&gt;
         &lt;title&gt;Writings File, 
         &lt;date normalize="1985/1999"&gt;1985-1999&lt;/date&gt;
         &lt;/title&gt;
         ...
         &lt;component&gt;
            &lt;componentTitle&gt;Writings by Usabilityguy
            &lt;/componentTitle&gt;
            &lt;subComponent&gt;
               &lt;componentTitle&gt;&lt;componentDate normalize="1996"&gt;
               1996&lt;/componentDate&gt;
               &lt;/componentTitle&gt; 
               ...
               &lt;subsubComponent&gt;
                  &lt;componentTitle&gt;"How to Evaluate Results from 
                  User <phrase role="found">Tests</phrase>."&lt;/componentTitle&gt;
               &lt;/subsubComponent&gt;
               ...
            &lt;/subComponent&gt;
            ...
         &lt;/component&gt;
         ...
      &lt;/part&gt;
      ...
   &lt;/content&gt;
&lt;/book&gt;</eg></div3><div3 id="wildcard-queries-results-q2"><head>Q2 Zero or One Character Prefix Wildcard Query</head><p>Find all books with the word "way" with no prefix or a one character prefix in the text.</p><p>This query finds a word with no prefix or a one character prefix (zero or one character before the first character).</p><ulist><item><p>Operands: "way"</p></item><item><p>Functionality: word query, character wildcard (prefix) (0 or 1)</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./content</p></item><item><p>Return: .</p></item><item><p>Comments: There is no "way" in the sample data but if there was, this query would have found it.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content
where $cont contains text ".?way" using wildcards
return $book</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text ".?way" 
using wildcards]</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt;
         ... 
         &lt;p&gt;Expert reviews and usability testing are 
         methods of identifying problems in layout, 
         terminology, and navigation before they frustrate
         users and drive them <phrase role="found">away</phrase> from your site.&lt;/p&gt;
         ...		    
      &lt;/introduction&gt;
      ...
   &lt;/content&gt;	
&lt;/book&gt;</eg></div3><div3 id="wildcard-queries-results-q3"><head>Q3 Zero or More Character Infix Wildcard Query</head><p>Find all books with the words "serve" or "service" in the text.</p><p>This query finds words with no infix character or any number of infix characters (zero or more characters inserted in the middle of a word).</p><ulist><item><p>Operands: "serv", "e"</p></item><item><p>Functionality: word query, character wildcard (infix) (0 or more)</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./content</p></item><item><p>Return: concat(./@number, ", ", ./metadata/title)</p></item><item><p>Comments: This query finds the word "service" and would find the word "serve" if it existed in the sample 
data. It does not find the word "served" which exists in the sample data.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content 
where $cont contains text "serv.*e" using wildcards
return (concat($book/@number, ", ", 
   $book/metadata/title))</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text "serv.*e" using wildcards]
/concat(@number, ", " , metadata/title)</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">1, Improving the Usability of a Web Site Through 
Expert Reviews and Usability Testing</eg></div3><div3 id="wildcard-queries-results-q4"><head>Q4 One or More Character Suffix Wildcard Query on Part of a Word</head><p>Find all books with the phrases "usability testing" or "user testing" in the text.</p><p>This query finds a phrase allowing a suffix of one or more characters (one or more characters after the last character) on a part of 
						one of the words.</p><ulist><item><p>Operands: "us testing"</p></item><item><p>Functionality: phrase query, character wildcard (suffix) (1 or more)</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./content</p></item><item><p>Return: concat(./@number, ", ", ./metadata/title)</p></item><item><p>Comments: This is a suffix query on a part of a word "us" which is not one of the words or one of the roots of the words desired in the results. The query on
"us" will find "usability" and "user". Where stemmed queries (Section 6 (STEMMING)) attempt to find linguistic variants of a word or the root of a word, wildcards may be applied to any part of a word and will find all character combinations found.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content 
where $cont contains text "us.+ testing" using wildcards
return (concat($book/@number, ", ", 
   $book/metadata/title))</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text "us.+ testing"
using wildcards]/concat(@number, ", ", metadata/title)</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">1, Improving the Usability of a Web Site Through 
Expert Reviews and Usability Testing
2, Usability Basics: How to Plan for and Conduct 
Usability Tests on Web Site Thereby Improving the 
Usability of Your Web Site
3, John Wesley Usabilityguy: A Register of His 
Papers</eg></div3><div3 id="wildcard-queries-results-q5"><head>Q5 Specified Range of Characters Suffix Wildcard Query</head><p>Find all books with the word "test" with a three to four character suffix in the text.</p><p>This query finds a word with a number of characters within a specified range in a suffix (specified range of characters after the last character).</p><ulist><item><p>Operands: "test"</p></item><item><p>Functionality: word query, character wildcard (suffix) (3 to 4)</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./content</p></item><item><p>Return: .</p></item><item><p>Comments: This query allows any three or four character suffix. It finds "testers" and "testing", but not "pretest" "tests" and "tested" 
						which also appear in the sample data. There is no "test" in the sample data, but if there was, this query would not have found it.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content 
where $cont contains text "test.{3,4}" using wildcards
return $book</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text "test.{3,4}"
using wildcards]</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      &lt;introduction&gt;
         ...
         &lt;p&gt;Expert reviews and usability <phrase role="found">testing</phrase> are 
         methods of identifying problems in layout, 
         terminology, and navigation before they frustrate
         users and drive them away from your site.&lt;/p&gt;
         ...
      &lt;/introduction&gt;
      ...
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Usability <phrase role="found">Testing</phrase>&lt;/title&gt;
            &lt;p&gt;Once the problems identified by expert 
            reviews have been corrected, it is time to 
            conduct some tests of the site with your unique 
            audience or audiences by conducting usability 
            <phrase role="found">testing</phrase>.&lt;/p&gt;
            ...
         &lt;/chapter&gt;
      &lt;/part&gt; 
   &lt;/content&gt;
&lt;/book&gt;
     						
&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      &lt;introduction&gt;
         &lt;p&gt;This is a basic handbook for planning and 
         conducting usability tests on Web sites. Usability
         <phrase role="found">testing</phrase> should be used in conjunction with other 
         expert review methods.&lt;/p&gt;
         ...
      &lt;/introduction&gt;
      &lt;part number="1"&gt;
         &lt;chapter&gt;
            &lt;p&gt;Take the following steps to plan usability
            <phrase role="found">testing</phrase>. &lt;step number="1"&gt;Clarify and 
            articulate the goal of the &gt;usability <phrase role="found">testing</phrase>. 
            &lt;step number="1"&gt;Clarify and 
            articulate the goal of the usability testing.
            &lt;/step&gt; &lt;step number="2"&gt;Identify tasks which 
            are critical for users to be able to complete 
            successfully.&lt;/step&gt; &lt;step number="3"&gt;Compile 
            a script of questions or instructions which 
            will prompt the user to attempt those 
            tasks.&lt;/step&gt; &lt;step number="4"&gt;Identify your 
            users and begin recruiting them.&lt;/step&gt; &lt;step 
            number="5"&gt;Conduct a pretest on a few users.
            &lt;/step&gt; &lt;step number="6"&gt;Edit the script based 
            on insights gleaned from the pretest.&lt;/step&gt; 
            &lt;step number="7"&gt;Resume testing.&lt;/step&gt;&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Conducting Usability Tests&lt;/title&gt; 
            ...
            &lt;p&gt;Give the user the script, then assure them 
            that you are testing the Web site, not them. 
            Users are asked to verbalize their thoughts as 
            they complete the tasks. The event is recorded 
            or someone takes notes. It is often preferable 
            to have two <phrase role="found">testers</phrase>, &lt;footnote&gt;Usability
            <phrase role="found">testing</phrase> can be done at great expense or on a 
            shoe string, using &lt;testingProcedure&gt;in-house 
            expertise&lt;/testingProcedure&gt; or 
            &lt;testingProcedure&gt;contracting with human 
            computer interaction professionals
            &lt;/testingProcedure&gt;.&lt;/footnote&gt; one to ask the 
            questions, another to take notes. <phrase role="found">Testers</phrase> should 
            offer no guidance or comments to the user. Mouse 
            movements, typing, expressions, and the user's 
            words should be recorded.&lt;/p&gt;
         &lt;/chapter&gt;
         &lt;chapter&gt;
            &lt;title&gt;Evaluating and Implementing Results&lt;/title&gt; 
            &lt;p&gt;Compile the results and review collectively. 
            Make changes to the site to alleviate the problems 
            found in Web site components which were propagating 
            the largest number of or the most devastating errors. 
            Begin new iterations of <phrase role="found">testing</phrase> and changes, until 
            users are successful in the accomplishing the 
            tasks.&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;
   &lt;/content&gt;
&lt;/book&gt;

&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      ...
      &lt;part number="2"&gt;&lt;container type="box"&gt;3-5&lt;/container&gt;
         &lt;title&gt;Writings File, 
         &lt;date normalize="1985/1999"&gt;1985-1999&lt;/date&gt;
         &lt;/title&gt;
         ...
         &lt;component&gt;
            &lt;componentTitle&gt;Writings by Usabilityguy
            &lt;/componentTitle&gt;
            &lt;subComponent&gt;
               &lt;componentTitle&gt;&lt;componentDate normalize="1996"&gt;
               1996&lt;/componentDate&gt;
               &lt;/componentTitle&gt; 
               &lt;subsubComponent&gt;
                  &lt;componentTitle&gt;"How Many Users Are Enough 
                  for User <phrase role="found">Testing</phrase>?"&lt;/componentTitle&gt;
               &lt;/subsubComponent&gt; 
               ...
               &lt;subsubComponent&gt;
                  &lt;componentTitle&gt;"When Are You Done <phrase role="found">Testing</phrase>?"
                  &lt;/componentTitle&gt;
               &lt;/subsubComponent&gt;
               &lt;subsubComponent&gt;
                  &lt;componentTitle&gt;"Do-It-Yourself User <phrase role="found">Testing</phrase>"
                  &lt;/componentTitle&gt;
               &lt;/subsubComponent&gt; 
            &lt;/subComponent&gt;
         &lt;/component&gt;
         ...
      &lt;/part&gt;      
   &lt;/content&gt;
&lt;/book&gt;
</eg></div3></div2></div1><div1 id="Stemming"><head>Use Case "STEMMING": Word Stemming Queries</head><div2 id="stemming-description"><head>Description</head><p>These use cases invoke a stemming algorithm (e.g., Porter) which finds noun, verb, adjective, and adverb 
forms of a word or root of a word in singular and plural.</p></div2><div2 id="stemming-queries-results"><head>Queries and Results</head><div3 id="stemming-queries-results-q1"><head>Q1 Query Stemming on Word Root</head><p>Find all books with the word "test" in the text.</p><p>This query finds a word and its variants applying a stemming algorithm.</p><ulist><item><p>Operands: "test"</p></item><item><p>Functionality: word query, stemming</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./content</p></item><item><p>Return: .</p></item><item><p>Comments: Unlike the wildcard queries in Section 5 (WILDCARD) which allow any suffix, this query will 
						not return the word "testimony" which occurs in the sample data.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content
where $cont contains text "test" using stemming
return $book</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text "test" 
using stemming]</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt;
         ...
         &lt;p&gt;Expert reviews and usability <phrase role="found">testing</phrase> are 
         methods of identifying problems in layout, 
         terminology, and navigation before they frustrate
         users and drive them away from your site.&lt;/p&gt;
         ...
      &lt;/introduction&gt;
      ...
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Usability <phrase role="found">Testing</phrase>&lt;/title&gt;
            &lt;p&gt;Once the problems identified by expert 
            reviews have been corrected, it is time to 
            conduct some <phrase role="found">tests</phrase> of the site with your unique 
            audience or audiences by conducting usability 
            <phrase role="found">testing</phrase>.&lt;/p&gt;
            ...
         &lt;/chapter&gt;
      &lt;/part&gt; 
   &lt;/content&gt;
&lt;/book&gt;     						

&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt;
         &lt;p&gt;This is a basic handbook for planning and 
         conducting usability <phrase role="found">tests</phrase> on Web sites. Usability 
         <phrase role="found">testing</phrase> should be used in conjunction with other 
         expert review methods.&lt;/p&gt;
         ...
      &lt;/introduction&gt;
      &lt;part number="1"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Planning then Conducting Usability 
            <phrase role="found">Tests</phrase>&lt;/title&gt; 
            &lt;p&gt;Take the following steps to plan usability 
            <phrase role="found">testing</phrase>. &lt;step number="1"&gt;Clarify and 
            articulate the goal of the usability <phrase role="found">testing</phrase>.
            &lt;/step&gt; &lt;step number="2"&gt;Identify tasks which 
            are critical for users to be able to complete 
            successfully.&lt;/step&gt; &lt;step number="3"&gt;Compile 
            a script of questions or instructions which 
            will prompt the user to attempt those 
            tasks.&lt;/step&gt; &lt;step number="4"&gt;Identify your 
            users and begin recruiting them.&lt;/step&gt; &lt;step 
            number="5"&gt;Conduct a pretest on a few users.
            &lt;/step&gt; &lt;step number="6"&gt;Edit the script based 
            on insights gleaned from the pretest.&lt;/step&gt; 
            &lt;step number="7"&gt;Resume <phrase role="found">testing</phrase>.&lt;/step&gt;&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Conducting Usability <phrase role="found">Tests</phrase>&lt;/title&gt; 
            &lt;p&gt;Users can be <phrase role="found">tested</phrase> at any computer 
            workstation &lt;footnote&gt;They may be more 
            comfortable at their own workstation than in 
            a lab.&lt;/footnote&gt; or in a lab.&lt;/p&gt;
            &lt;p&gt;Give the user the script, then assure them 
            that you are <phrase role="found">testing</phrase> the Web site, not them. 
            Users are asked to verbalize their thoughts as 
            they complete the tasks. The event is recorded 
            or someone takes notes. It is often preferable 
            to have two testers, &lt;footnote&gt;Usability 
            <phrase role="found">testing</phrase> can be done at great expense or on a 
            shoe string, using &lt;testingProcedure&gt;in-house 
            expertise&lt;/testingProcedure&gt; or 
            &lt;testingProcedure&gt;contracting with human 
            computer interaction professionals
            &lt;/testingProcedure&gt;.&lt;/footnote&gt; one to ask the 
            questions, another to take notes. Testers should 
            offer no guidance or comments to the user. Mouse 
            movements, typing, expressions, and the user's 
            words should be recorded.&lt;/p&gt;
         &lt;/chapter&gt;
         &lt;chapter&gt;
            &lt;title&gt;Evaluating and Implementing Results&lt;/title&gt; 
            &lt;p&gt;Compile the results and review collectively. 
            Make changes to the site to alleviate the problems 
            found in Web site components which were propagating 
            the largest number of or the most devastating errors. 
            Begin new iterations of <phrase role="found">testing</phrase> and changes, until  
            users are successful in the accomplishing the 
            tasks.&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;
   &lt;/content&gt;
&lt;/book&gt;    

&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ...   
      &lt;part number="2"&gt;&lt;container type="box"&gt;3-5&lt;/container&gt;
         &lt;title&gt;Writings File, 
         &lt;date normalize="1985/1999"&gt;1985-1999&lt;/date&gt;
         &lt;/title&gt;
         ...
         &lt;component&gt;
            &lt;componentTitle&gt;Writings by Usabilityguy
            &lt;/componentTitle&gt;
            &lt;subComponent&gt;
               &lt;componentTitle&gt;&lt;componentDate normalize="1996"&gt;
               1996&lt;/componentDate&gt;
               &lt;/componentTitle&gt; 
               &lt;subsubComponent&gt;
                  &lt;componentTitle&gt;"How Many Users Are Enough 
                  for User <phrase role="found">Testing</phrase>?"&lt;/componentTitle&gt;
               &lt;/subsubComponent&gt; 
               &lt;subsubComponent&gt;
                  &lt;componentTitle&gt;"How to Evaluate Results from 
                  User <phrase role="found">Tests</phrase>."&lt;/componentTitle&gt;
               &lt;/subsubComponent&gt;
               &lt;subsubComponent&gt;
                  &lt;container type="box"&gt;5&lt;/container&gt;
                  &lt;componentTitle&gt;"When Are You Done <phrase role="found">Testing</phrase>?
                  &lt;/componentTitle&gt;
               &lt;/subsubComponent&gt;
               &lt;subsubComponent&gt;
                  &lt;componentTitle&gt;"Do-It-Yourself User <phrase role="found">Testing</phrase>"
                  &lt;/componentTitle&gt;
               &lt;/subsubComponent&gt; 
            &lt;/subComponent&gt;
         &lt;/component&gt;
         ...
      &lt;/part&gt;   
   &lt;/content&gt;
&lt;/book&gt;</eg></div3><div3 id="stemming-queries-results-q2"><head>Q2 Query Stemming on Multiple Word Roots</head><p>Find all books with the phrases "usability testing" or "users testing" in the text.</p><p>This query finds phrases applying a stemming algorithm to selected words within the phrases.</p><ulist><item><p>Operands: "usability testing" "users testing" </p></item><item><p>Functionality: phrase queries, stemming</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./content</p></item><item><p>Return: .</p></item><item><p>Comments: This query applies stemming to one word in a phrase. Unlike the wildcard queries in Section 5 (WILDCARD) which allow any suffix, a stemmed query on "us" will not 
find "user" and "usability", because they do not share the same root. This query uses an <code>ftor</code> query introduced in Section 10 (LOGICAL).</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content 
where $cont contains text ("usability" using stemming ftand "testing" 
   phrase) ftor ("users" using stemming ftand "testing" phrase)
return $book</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text ("usability" using stemming
ftand "testing" phrase) ftor ("users" using stemming
ftand "testing" phrase)]</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      &lt;introduction&gt;
         ...
         &lt;p&gt;Expert reviews and <phrase role="found">usability testing</phrase> are 
         methods of identifying problems in layout, 
         terminology, and navigation before they frustrate
         users and drive them away from your site.&lt;/p&gt;
         ...
      &lt;/introduction&gt;
      ...
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;<phrase role="found">Usability Testing</phrase>&lt;/title&gt;
            &lt;p&gt;Once the problems identified by expert 
            reviews have been corrected, it is time to 
            conduct some tests of the site with your unique 
            audience or audiences by conducting <phrase role="found">usability</phrase> 
            <phrase role="found">testing</phrase>.&lt;/p&gt;
            ...
         &lt;/chapter&gt;
      &lt;/part&gt; 
   &lt;/content&gt;
&lt;/book&gt;
    
&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt;
         &lt;p&gt;This is a basic handbook for planning and 
         conducting usability tests on Web sites. <phrase role="found">Usability</phrase>
         <phrase role="found">testing</phrase> should be used in conjunction with other 
         expert review methods.&lt;/p&gt;
         ...
      &lt;/introduction&gt;
      &lt;part number="1"&gt;
         &lt;chapter&gt;
            &lt;p&gt;Take the following steps to plan <phrase role="found">usability</phrase>
            <phrase role="found">testing</phrase>. &lt;step number="1"&gt;Clarify and 
            articulate the goal of the <phrase role="found">usability testing</phrase>. 
            &lt;step number="1"&gt;Clarify and 
            articulate the goal of the usability testing.
            &lt;/step&gt; &lt;step number="2"&gt;Identify tasks which 
            are critical for users to be able to complete 
            successfully.&lt;/step&gt; &lt;step number="3"&gt;Compile 
            a script of questions or instructions which 
            will prompt the user to attempt those 
            tasks.&lt;/step&gt; &lt;step number="4"&gt;Identify your 
            users and begin recruiting them.&lt;/step&gt; &lt;step 
            number="5"&gt;Conduct a pretest on a few users.
            &lt;/step&gt; &lt;step number="6"&gt;Edit the script based 
            on insights gleaned from the pretest.&lt;/step&gt; 
            &lt;step number="7"&gt;Resume testing.&lt;/step&gt;&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Conducting Usability Tests&lt;/title&gt; 
            ...
            &lt;p&gt;Give the user the script, then assure them 
            that you are testing the Web site, not them. 
            Users are asked to verbalize their thoughts as 
            they complete the tasks. The event is recorded 
            or someone takes notes. It is often preferable 
            to have two testers, &lt;footnote&gt;<phrase role="found">Usability</phrase>
            <phrase role="found">testing</phrase> can be done at great expense or on a 
            shoe string, using &lt;testingProcedure&gt;in-house 
            expertise&lt;/testingProcedure&gt; or 
            &lt;testingProcedure&gt;contracting with human 
            computer interaction professionals
            &lt;/testingProcedure&gt;.&lt;/footnote&gt; one to ask the 
            questions, another to take notes. Testers should 
            offer no guidance or comments to the user. Mouse 
            movements, typing, expressions, and the user's 
            words should be recorded.&lt;/p&gt;
         &lt;/chapter&gt;
         ...
      &lt;/part&gt;
   &lt;/content&gt;
&lt;/book&gt;

&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ...
      &lt;part number="2"&gt;&lt;container type="box"&gt;3-5&lt;/container&gt;
         &lt;title&gt;Writings File, 
         &lt;date normalize="1985/1999"&gt;1985-1999&lt;/date&gt;
         &lt;/title&gt;
         ...
         &lt;component&gt;
            &lt;componentTitle&gt;Writings by Usabilityguy
            &lt;/componentTitle&gt;
            &lt;subComponent&gt;
               &lt;componentTitle&gt;&lt;componentDate normalize="1996"&gt;
               1996&lt;/componentDate&gt;
               &lt;/componentTitle&gt; 
               &lt;subsubComponent&gt;
                  &lt;componentTitle&gt;"How Many Users Are Enough 
                  for <phrase role="found">User Testing</phrase>?"&lt;/componentTitle&gt;
               &lt;/subsubComponent&gt; 
               ...
               &lt;subsubComponent&gt;
                  &lt;subsubComponent&gt;&lt;componentTitle&gt;"Do-It-
                  Yourself <phrase role="found">User Testing</phrase>"
                  &lt;/componentTitle&gt;
               &lt;/subsubComponent&gt; 
            &lt;/subComponent&gt;
         &lt;/component&gt;
         ...
      &lt;/part&gt;      
   &lt;/content&gt;
&lt;/book&gt;</eg></div3></div2></div1><div1 id="Thesaurus"><head>Use Case "THESAURUS": Queries Which Use Thesauri, Dictionaries, and Taxonomies</head><div2 id="thesaurus-description"><head>Description</head><p>These use cases illustrate queries which return synonyms or related words identified by thesauri, dictionaries, and taxonomies.</p></div2><div2 id="thesaurus-queries-results"><head>Queries and Results</head><div3 id="thesaurus-queries-results-q1"><head>Q1 Query on Synonyms Identified by a Thesaurus</head><p>Find all introductions which quote someone.</p><p>This query finds words and phrases using a thesaurus to return synonyms.</p><ulist><item><p>Operands: "quote"</p></item><item><p>Functionality: word query, thesaurus support</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: .//introduction</p></item><item><p>Return: .</p></item><item><p>Comments: This query uses thesaurus support to identify synonyms for the word "quote" 
						via preferred and used for terms: "said", "says", "stated", "states", 
						"spoke", "speaks", "replied", "replies", "reply", "remarks", "remarked", "responded", "response", "reports", "reported", 
						"quotes", "quoted", "according to",	"commented", "discussed", "expressed", and "told". These words and phrases become additional 
						operands.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $intro := $book//introduction 
where $intro contains text "quote" using thesaurus at
   "http://bstore1.example.com/UsabilityThesaurus.xml" 
   relationship "synonyms"
return $book</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[.//introduction contains text "quote" 
using thesaurus at 
"http://bstore1.example.com/UsabilityThesaurus.xml" 
relationship "synonyms"]</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ...   
      &lt;introduction&gt;
         ...
         &lt;p&gt;The most successful projects employ multiple 
         methods in multiple iterations. As Millicent 
         Marigold <phrase role="found">remarked</phrase> during a recent conference, 
         "Don't stop. Iterate, iterate, then iterate 
         again."&lt;/p&gt;
         ...
      &lt;/introduction&gt;
   &lt;/content&gt;      
&lt;/book&gt;</eg></div3><div3 id="thesaurus-queries-results-q2"><head>Q2 Query on Narrower Terms Identified by a Thesaurus</head><p>Find all books with text on improving "web site components".</p><p>This query finds words using a thesaurus to identify narrower terms.</p><ulist><item><p>Operands: "web site components"</p></item><item><p>Functionality: phrase query, thesaurus support</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./content</p></item><item><p>Return: .</p></item><item><p>Comments: This query employs a thesaurus to identify web site components via narrower terms: "layout", 
						"terminology", "graphics", "menus", and "navigation".  These words become additional operands.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content
where $cont contains text "web site components" 
   using thesaurus at 
   "http://bstore1.example.com/UsabilityThesaurus.xml" 
   relationship "narrower term" at most 2 levels
return $book</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text "web site components" 
using thesaurus at 
"http://bstore1.example.com/UsabilityThesaurus.xml" 
relationship "narrower term" at most 2 levels]</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt;
         ...   
         &lt;p&gt;Expert reviews and usability testing are 
         methods of identifying problems in <phrase role="found">layout</phrase>, 
         <phrase role="found">terminology</phrase>, and <phrase role="found">navigation</phrase> before they frustrate
         users and drive them away from your site.&lt;/p&gt; 
         ... 
      &lt;/introduction&gt;                   
      ... 
   &lt;/content&gt;  
&lt;/book&gt;   
      
&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ... 
      &lt;part number="2"&gt;
         ...
         &lt;chapter&gt;
            &lt;title&gt;Evaluating and Implementing Results&lt;/title&gt;   
            &lt;p&gt;Compile the results and review collectively. 
            Make changes to the site to alleviate the problems 
            found in <phrase role="found">Web site components</phrase> which were propagating 
            the largest number of or the most devastating errors. 
            Begin new iterations of testing and changes, until 
            users are successful in the accomplishing the 
            tasks.&lt;/p&gt;  
         &lt;/chapter&gt;
      &lt;/part&gt;       
   &lt;/content&gt;
&lt;/book&gt;</eg></div3><div3 id="thesaurus-queries-results-q3"><head>Q3 Query on Broader Terms Identified by a Thesaurus</head><p>Are there any "letters" or "holiday cards" in John Wesley Usabilityguy's papers?</p><p>This query finds words and phrases using a thesaurus to identify broader terms.</p><ulist><item><p>Operands: "letters" "holiday cards"</p></item><item><p>Functionality: word query, phrase query, thesaurus support</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book[@number="3"]</p></item><item><p>Query context: ./content</p></item><item><p>Return: .</p></item><item><p>Comments: This query employs a thesaurus to identify the broader term "correspondence". It becomes an additional operand.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book[@number="3"]
let $cont := $book/content 
where $cont contains text ("letters" ftor "holiday cards") 
   using thesaurus at 
   "http://bstore1.example.com/UsabilityThesaurus.xml" 
   relationship "BT" exactly 1 levels
return $book</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text ("letters" 
ftor "holiday cards") using thesaurus at 
"http://bstore1.example.com/UsabilityThesaurus.xml" 
relationship "BT" exactly 1 levels]</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt;
         &lt;p&gt;The papers of John Wesley Usabilityguy span the 
         years 1946-2001, with the bulk of the items 
         concentrated in the period from 1985 to 2001. The 
         papers feature his career as a developer of software 
         applications and usability specialist. The collection 
         consists of <phrase role="found">correspondence</phrase>, memoranda, journals, 
         speeches, article drafts, book drafts, notes, charts, 
         graphs, family papers, clippings, printed matter, 
         photographs, résumés and other materials.&lt;/p&gt;
      &lt;/introduction&gt;
      &lt;part number="1"&gt;&lt;container type="box"&gt;1-12&lt;/container&gt;
         &lt;title&gt;Subject File, &lt;date normalize="1930/1974"&gt;
         1930-1974&lt;/date&gt;&lt;/title&gt;
         &lt;introduction&gt;
            &lt;p&gt;<phrase role="found">Correspondence</phrase>, telegrams, memoranda, journals, 
            logs, testimony, approved travel orders, invitations, 
            charts, graphs, forms, biographical data, photographs, 
            book drafts, clippings and other printed matter, 
            résumés and miscellaneous material. Organized by 
            name of person or organization, topic, or type of 
            material.&lt;/p&gt;
         &lt;/introduction&gt;            
      &lt;/part&gt;
      &lt;part number="2"&gt;&lt;container type="box"&gt;3-5&lt;/container&gt;
         &lt;title&gt;Writings File, 
         &lt;date normalize="1985/1999"&gt;1985-1999&lt;/date&gt;
         &lt;/title&gt;
         &lt;introduction&gt;
            &lt;p&gt;<phrase role="found">Correspondence</phrase>, articles, book drafts, notes,
            contracts, clippings, and printed matter. Arranged 
            alphabetically by type (articles, books, reports, 
            and miscellaneous) and therein alphabetically by 
            type of material, subject, or title.&lt;/p&gt;
         &lt;/introduction&gt;    
         ...        
      &lt;/part&gt;
   &lt;/content&gt;    
&lt;/book&gt;</eg></div3><div3 id="thesaurus-queries-results-q4"><head>Q4 Query on Word Which Sounds Like Other Words</head><p>	Find all books with words which sound like "Merrygould".</p><p>This query finds words using a dictionary of words which sound like the word queried.</p><ulist><item><p>Operands: "Merrygould"</p></item><item><p>Functionality: word query, sounds-like dictionary support</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: .</p></item><item><p>Return: .</p></item><item><p>Comments: This query uses sounds-like support to identify words which sound
						like the word
						"Merrygould". It
						finds the word
						"Marigold". Examples of
						how this query is
						implemented include
						keeping a list of
						similar words (akin to
						a thesaurus) or using
						a system based on
						phonetic similarity. </p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book[. contains text "Merrygould" 
   using thesaurus at 
   "http://bstore1.example.com/UsabilitySoundex.xml" 
   relationship "sounds like"]
return $book</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[. contains text "Merrygould" 
using thesaurus at 
"http://bstore1.example.com/UsabilitySoundex.xml" 
relationship "sounds like"]</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="1"&gt;
   &lt;metadata&gt;
      &lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
      the Usability of a Web Site Through Expert Reviews and 
      Usability Testing&lt;/title&gt;
      &lt;author&gt;Millicent <phrase role="found">Marigold</phrase>&lt;/author&gt;
      &lt;author&gt;Montana <phrase role="found">Marigold</phrase>&lt;/author&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      &lt;introduction&gt;
         ...
         &lt;p&gt;The most successful projects employ multiple 
         methods in multiple iterations. As Millicent 
         <phrase role="found">Marigold</phrase> remarked during a recent conference, 
         "Don't stop. Iterate, iterate, then iterate 
         again."&lt;/p&gt;
         ...
      &lt;/introduction&gt;
   &lt;/content&gt;   
&lt;/book&gt;
   
&lt;book number="3"&gt;
   &lt;metadata&gt;
      &lt;title shortTitle="Usabilityguy Manuscript 
      Guide"&gt;John Wesley Usabilityguy: A Register of His 
      Papers&lt;/title&gt;
      &lt;author&gt;Millicent <phrase role="found">Marigold</phrase>&lt;/author&gt;
      &lt;author&gt;Morty <phrase role="found">Marigold</phrase>&lt;/author&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      ...   
   &lt;/content&gt;   
&lt;/book&gt;</eg></div3><div3 id="thesaurus-queries-results-q5"><head>Q5 Query on Word Spelled Similarly to Other Words</head><p>	Find all books which contain words that are close in spelling to "sucessfull".</p><p>This query finds words using a dictionary of words that are spelled similarly.</p><ulist><item><p>Operands: "sucessfull"</p></item><item><p>Functionality: word query, similarly spelled dictionary support</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: .</p></item><item><p>Return: .</p></item><item><p>Comments: This query uses support for similarly spelled words to identify words close in 
spelling to "sucessfull". It finds the word "successful". Examples of
						how this query is
						implemented include
						keeping a list of
						similar words (akin to
						a thesaurus) or using
						a system based on spelling
						similarities.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book[. contains text "sucessfull" 
   using thesaurus at 
   "http://bstore1.example.com/spellcheck.xml" 
   relationship "misspelling of"]
return $book</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[. contains text "sucessfull" 
using thesaurus at 
"http://bstore1.example.com/spellcheck.xml" 
relationship "misspelling of"]</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ...   
      &lt;introduction&gt;
         ...
         &lt;p&gt;The most <phrase role="found">successful</phrase> projects employ multiple 
         methods in multiple iterations. As Millicent 
         Marigold remarked during a recent conference, 
         "Don't stop. Iterate, iterate, then iterate 
         again."&lt;/p&gt;
         ...
      &lt;/introduction&gt;
      &lt;part number="1"&gt;
         &lt;title&gt;Expert Reviews&lt;/title&gt;
         ...
         &lt;chapter&gt;
            &lt;title&gt;Cognitive Walk-Through&lt;/title&gt;
            &lt;p&gt;Expert reviewers evaluate Web site 
            understandability and ease of learning while 
            performing specified tasks. They walk through 
            the site answering questions such as "Would a 
            user know by looking at the screen how to 
            complete the first step of the task?" and "If 
            the user completed the first step, would the 
            user know what to do next?," with the goal of 
            identifying any obstacles to completing the 
            task and assessing whether the user would 
            cognitively be aware that he was <phrase role="found">successful</phrase> in 
            completing a step in the process.&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;   
      ...
   &lt;/content&gt;  
&lt;/book&gt;	 

&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ...   
      &lt;part number="2"&gt;
         ...
         &lt;chapter&gt;
            &lt;title&gt;Evaluating and Implementing Results&lt;/title&gt; 
            &lt;p&gt;Compile the results and review collectively. 
            Make changes to the site to alleviate the problems 
            found in Web site components which were propagating 
            the largest number of or the most devastating errors. 
            Begin new iterations of testing and changes, until 
            users are <phrase role="found">successful</phrase> in the accomplishing the 
            tasks.&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;
   &lt;/content&gt;   
&lt;/book&gt;</eg></div3><div3 id="thesaurus-queries-results-q6"><head>Q6 Query on Subordinate Terms Identified by a Taxonomy</head><p>Find out whether John Wesley Usabilityguy included research on "AIDS" and "other infectious diseases" among the charities he supported.</p><p>This query finds words using a taxonomy to identify subordinate terms.</p><ulist><item><p>Operands: "AIDS"</p></item><item><p>Functionality: word query, case sensitivity (limited to upper case), 
taxonomy support</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book[@number="3"]</p></item><item><p>Query context: ./content/part/component</p></item><item><p>Return: .</p></item><item><p>Comments: This query uses a taxonomy to identify other infectious diseases: "Hepatitis" and "Tuberculosis". These words become additional operands.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book[@number="3"]
let $comp := $book//component
where $comp contains text "AIDS" using uppercase 
   using thesaurus at 
   "http://bstore1.example.com/OurTaxonomy.xml" 
   relationship "disease in this category"
return $book</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[@number="3" and .//component contains text 
"AIDS" using uppercase using thesaurus at 
"http://bstore1.example.com/OurTaxonomy.xml" 
relationship "disease in this category"]</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="3"&gt; 
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ...   
      &lt;part number="2"&gt;&lt;container type="box"&gt;3-5&lt;/container&gt;
         &lt;title&gt;Writings File, 
         &lt;date normalize="1985/1999"&gt;1985-1999&lt;/date&gt;
         &lt;/title&gt;
         ...
         &lt;component&gt;
            &lt;componentTitle&gt;Charitable Contributions
            &lt;/componentTitle&gt; 
            &lt;subComponent&gt;
               &lt;componentTitle&gt;Diseases: <phrase role="found">AIDS</phrase>, <phrase role="found">Hepatitis</phrase>, 
               <phrase role="found">Tuberculosis</phrase>&lt;componentDate normalize=
               "1990/1999"&gt;1990-1999&lt;/componentDate&gt;
               &lt;/componentTitle&gt;
            &lt;/subComponent&gt; 
            &lt;subComponent&gt;
               &lt;componentTitle&gt;Environmental Conservation: 
               Rivers &lt;componentDate normalize="1995"&gt;1995
               &lt;/componentDate&gt;
               &lt;/componentTitle&gt;
            &lt;/subComponent&gt;
         &lt;/component&gt;
      &lt;/part&gt;
   &lt;/content&gt;      
&lt;/book&gt;</eg></div3></div2></div1><div1 id="Stop-word"><head>Use Case "STOP-WORD": Queries on Stop Words</head><div2 id="stop-word-description"><head>Description</head><p>These use cases query a phrase, one word of which has been identified as a stop word via a stop word list. The first treats the stop word as a stop word. The second does not, making it available again for querying. Another query calls a stop word list then excludes a word on the list making that word available for querying.</p><p>Words identified as stop words may be routinely eliminated from queries, allowing any word to be substituted.</p></div2><div2 id="Stop-word-queries-results"><head>Queries and Results</head><div3 id="stop-word-queries-results-q1"><head>Q1 Query on Stop Word Treated as a Stop Word</head><p>Find all books with the phrase "planning then conducting" in the text where "then" is treated as a stop word.</p><p>This query finds a phrase substituting any word for a word which has been identified as a stop word via a stop word list.</p><ulist><item><p>Operands: "planning then conducting"</p></item><item><p>Functionality: stop word (then), phrase query</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./content</p></item><item><p>Return: .</p></item><item><p>Comments: Once the stop word "then" has been identified via the stop word list at http://bstore1.example.com/StopWordList.xml, this query is reduced to a query on the phrase "planning" any word "conducting", allowing any word as a substitute for the stop word. It finds both "planning and conducting" and "planning then conducting" in the sample data.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content
where $cont contains text "planning then conducting" 
   using stop words 
   at "http://bstore1.example.com/StopWordList.xml"
return $book</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text "planning then 
conducting" using stop words at 
"http://bstore1.example.com/StopWordList.xml"]</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt;
         &lt;p&gt;This is a basic handbook for <phrase role="found">planning and</phrase> 
         <phrase role="found">conducting</phrase> usability tests on Web sites. Usability  
         testing should be used in conjunction with other 
         expert review methods.&lt;/p&gt;
         &lt;p&gt;This book has not been approved by the Web Site 
         Users Association.&lt;/p&gt;
      &lt;/introduction&gt;
      &lt;part number="1"&gt;
         &lt;chapter&gt;
            &lt;title&gt;<phrase role="found">Planning then Conducting</phrase> Usability
            Tests&lt;/title&gt; 
            ...
         &lt;/chapter&gt;
      &lt;/part&gt; 
      ...
   &lt;/content&gt;
&lt;/book&gt;</eg></div3><div3 id="stop-word-queries-results-q2"><head>Q2 Query on Stop Word Not Treated as a Stop Word</head><p>Find all books with the phrase "planning then conducting" in the text where "then" is not treated as a stop word.</p><p>This query does not eliminate a word from the query even though it has been identified as a stop word in the stop word list, making it available again for querying.</p><ulist><item><p>Operands: "planning then conducting"</p></item><item><p>Functionality: stop word (then), phrase query</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./content</p></item><item><p>Return: .</p></item><item><p>Comments: Even though the word "then" has been identified as a stop word, this query makes it available again for querying. It finds only "planning then conducting" in the sample data.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content
where $cont contains text "planning then conducting" 
   using no stop words
return $book</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text "planning then 
conducting" using no stop words]</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ...
      &lt;part number="1"&gt;
         &lt;chapter&gt;
            &lt;title&gt;<phrase role="found">Planning then Conducting</phrase> Usability
            Tests&lt;/title&gt; 
            ...
         &lt;/chapter&gt;
      &lt;/part&gt; 
      ...
   &lt;/content&gt;
&lt;/book&gt;</eg></div3><div3 id="stop-word-queries-results-q3"><head>Q3 Query Excluding a Stop Word on a Stop Word List</head><p>Find books with the phrase "not been approved" in the text.</p><p>This query finds a phrase substituting any words for words which have been identified as stop words via a stop word list, removing the word "not" temporarily from the stop word list.</p><ulist><item><p>Operands: "not been approved"</p></item><item><p>Functionality: phrase query, stop word list (not, been), the stop word "not" is excluded from the list and used in the query</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./content</p></item><item><p>Return: ./metadata/title, ./content</p></item><item><p>Comments:  The stop words "not" and "been" are identified via a stop word list, however the stop word "not" is removed temporarily from the stop word list and used as an operand in the query. The query becomes a query on the phrase "not" [any word] "approved", allowing any word as a substitute for the stop word "been". It does not return books with the word "approved" in the phrases "been approved" and "approved travel orders" in the sample data.</p></item></ulist><p>
						<emph>Solution in XQuery:</emph>
					</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content
where $cont contains text 
   "not been approved" using stop words at
   "http://bstore1.example.com/StopWordList.xml" 
   except ("not")
return ($book/metadata/title, $cont)</eg><p>
						<emph>Solution in XPath:</emph>
					</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text "not been 
approved" using stop words at 
"http://bstore1.example.com/StopWordList.xml" 
except ("not")]/(metadata/title, content)</eg><p>
						<emph>Expected Result:</emph>
					</p><eg xml:space="preserve">&lt;title shortTitle="Usability Basics"&gt;Usability 
Basics: How to Plan for and Conduct 
Usability Tests on Web Site Thereby Improving the 
Usability of Your Web Site&lt;/title&gt;
&lt;content&gt;
   ...		
   &lt;p&gt;This book has <phrase role="found">not been approved</phrase> by the Web Site 
   Users Association&lt;/p&gt;
   ...     
&lt;/content&gt;</eg></div3></div2></div1><div1 id="Character"><head>Use Case "CHARACTER": Queries Specifying Normalized Forms of Characters and Tokenized Words</head><div2 id="character-description"><head>Description</head><p>These use cases illustrate queries on words entered with 
diacritics sometimes finding the same; other times finding words with and without diacritics. They query words 
entered in upper case sometimes finding the same; other times finding words in both upper and lower case.</p></div2><div2 id="character-queries-results"><head>Queries and Results</head><div3 id="character-queries-results-q1"><head>Q1 Diacritics Sensitive Query</head><p>Verify the existence of a "résumé" in the papers of John Wesley Usabilityguy.</p><p>This query finds a word only if it contains the diacritics as written in the query.</p><ulist><item><p>Operands: "résumé"</p></item><item><p>Functionality: word query, functionality requiring presence of diacritics as written in the query, character wildcard (suffix) (1)</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./content</p></item><item><p>Return: .</p></item><item><p>Comments: The desired results include only the words "résumé" and "résumés" with diacritics as written in the query, not the
						more often used words "resume" (which is present in the sample data) and "resumes".</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content
where $cont contains text "résumé.?" using wildcards 
   using diacritics sensitive
return $book</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text "résumé.?" 
using wildcards using diacritics sensitive]</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt;
         &lt;p&gt;The papers of John Wesley Usabilityguy span the 
         years 1946-2001, with the bulk of the items 
         concentrated in the period from 1985 to 2001. The 
         papers feature his career as a developer of software 
         applications and usability specialist. The collection 
         consists of correspondence, memoranda, journals, 
         speeches, article drafts, book drafts, notes, charts, 
         graphs, family papers, clippings, printed matter, 
         photographs, <phrase role="found">résumés</phrase> and other materials.&lt;/p&gt;
      &lt;/introduction&gt;
      &lt;part number="1"&gt;&lt;container type="box"&gt;1-12&lt;/container&gt;
         &lt;title&gt;Subject File, &lt;date normalize="1930/1974"&gt;
         1930-1974&lt;/date&gt;&lt;/title&gt;
         &lt;introduction&gt;
            &lt;p&gt;Correspondence, telegrams, memoranda, journals, 
            logs, testimony, approved travel orders, invitations, 
            charts, graphs, forms, biographical data, photographs, 
            book drafts, clippings and other printed matter, 
            <phrase role="found">résumés</phrase> and miscellaneous material. Organized by 
            name of person or organization, topic, or type of 
            material.&lt;/p&gt;
         &lt;/introduction&gt;
         ...
      &lt;/part&gt;
      ...   
   &lt;/content&gt;
&lt;/book&gt;</eg></div3><div3 id="character-queries-results-q2"><head>Q2 Diacritics Insensitive Query</head><p>Verify the existence of a résumé in the papers of John Wesley Usabilityguy.</p><p>This query finds a word whether diacritics are present or not.</p><ulist><item><p>Operands: "resume"</p></item><item><p>Functionality: word query, functionality finding words with and without diacritics, character wildcard (suffix) (1)</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./content</p></item><item><p>Return: .</p></item><item><p>Comments: The desired results include either the words "résumé" or "résumés" with diacritics or the words "resume" or "resumes" without diacritics. Whether diacritics are written in the query or not is not considered.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content
where $cont contains text "resume.?" using wildcards 
   using diacritics insensitive
return $book</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text "resume.?" 
using wildcards using diacritics insensitive]</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ...
      &lt;part number="1"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Planning then Conducting Usability 
            Tests&lt;/title&gt; 
            &lt;p&gt;Take the following steps to plan usability 
            testing. &lt;step number="1"&gt;Clarify and 
            articulate the goal of the usability testing.
            &lt;/step&gt; &lt;step number="2"&gt;Identify tasks which 
            are critical for users to be able to complete 
            successfully.&lt;/step&gt; &lt;step number="3"&gt;Compile 
            a script of questions or instructions which 
            will prompt the user to attempt those 
            tasks.&lt;/step&gt; &lt;step number="4"&gt;Identify your 
            users and begin recruiting them.&lt;/step&gt; &lt;step 
            number="5"&gt;Conduct a pretest on a few users.
            &lt;/step&gt; &lt;step number="6"&gt;Edit the script based 
            on insights gleaned from the pretest.&lt;/step&gt; 
            &lt;step number="7"&gt;<phrase role="found">Resume</phrase> testing.&lt;/step&gt;&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;  
      ... 
   &lt;/content&gt;
&lt;/book&gt;      
   
&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt;
         &lt;p&gt;The papers of John Wesley Usabilityguy span the 
         years 1946-2001, with the bulk of the items 
         concentrated in the period from 1985 to 2001. The 
         papers feature his career as a developer of software 
         applications and usability specialist. The collection 
         consists of correspondence, memoranda, journals, 
         speeches, article drafts, book drafts, notes, charts, 
         graphs, family papers, clippings, printed matter, 
         photographs, <phrase role="found">résumés</phrase> and other materials.&lt;/p&gt;
      &lt;/introduction&gt;
      &lt;part number="1"&gt;&lt;container type="box"&gt;1-12&lt;/container&gt;
         &lt;title&gt;Subject File, &lt;date normalize="1930/1974"&gt;
         1930-1974&lt;/date&gt;&lt;/title&gt;
         &lt;introduction&gt;
            &lt;p&gt;Correspondence, telegrams, memoranda, journals, 
            logs, testimony, approved travel orders, invitations, 
            charts, graphs, forms, biographical data, photographs, 
            book drafts, clippings and other printed matter, 
            <phrase role="found">résumés</phrase> and miscellaneous material. Organized by 
            name of person or organization, topic, or type of 
            material.&lt;/p&gt;
         &lt;/introduction&gt;
         ...
      &lt;/part&gt;
      ...   
   &lt;/content&gt;
&lt;/book&gt;</eg></div3><div3 id="character-queries-results-q3"><head>Q3 Query on Word with Upper Case Characters</head><p>	Find out whether John Wesley Usabilityguy included research on "AIDS" among the charities he supported.</p><p>This query finds a word in upper case characters.</p><ulist><item><p>Operands: "AIDS"</p></item><item><p>Functionality: case sensitivity (limited to upper case), word query</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: .</p></item><item><p>Return: .</p></item><item><p>Comments: This query does not return the word "aids" with lower case characters which exists in the sample data.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book  
where $book[. contains text "AIDS" using uppercase] 
return $book</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[. contains text "AIDS" using uppercase]</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ...   
      &lt;part number="2"&gt;&lt;container type="box"&gt;3-5&lt;/container&gt;
         &lt;title&gt;Writings File, 
         &lt;date normalize="1985/1999"&gt;1985-1999&lt;/date&gt;
         &lt;/title&gt;
         ...
         &lt;component&gt;
            &lt;componentTitle&gt;Charitable Contributions
            &lt;/componentTitle&gt; 
            &lt;subComponent&gt;
               &lt;componentTitle&gt;Diseases: <phrase role="found">AIDS</phrase>, Hepatitis, 
               Tuberculosis &lt;componentDate normalize=
               "1990/1999"&gt;1990-1999&lt;/componentDate&gt;
               &lt;/componentTitle&gt;
            &lt;/subComponent&gt; 
            ...
         &lt;/component&gt;
      &lt;/part&gt;
   &lt;/content&gt;
&lt;/book&gt;</eg></div3><div3 id="character-queries-results-q4"><head>Q4 Query on Word with Upper Case and Lower Case Characters</head><p>	Find out whether John Wesley Usabilityguy included research on "AIDS" among the charities he supported.</p><p>This query finds a word with upper or lower case characters.</p><ulist><item><p>Operands: "AIDS"</p></item><item><p>Functionality: word query, case insensitivity</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: .</p></item><item><p>Return: .</p></item><item><p>Comments: This query finds the word "aids" with characters in upper or lower case.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book  
where $book contains text "AIDS" using case insensitive
return $book</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[. contains text "AIDS" using case 
insensitive]</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
      &lt;subjects xml:lang="en"&gt;
         &lt;subject&gt;Usability testing&lt;/subject&gt;
         &lt;subject&gt;Web site development&lt;/subject&gt;
         &lt;subject&gt;Guides and finding <phrase role="found">aids</phrase>&lt;/subject&gt;
      &lt;/subjects&gt;      
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ...   
   &lt;/content&gt;   
&lt;/book&gt;     
   
&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ...   
      &lt;part number="2"&gt;&lt;container type="box"&gt;3-5&lt;/container&gt;
         &lt;title&gt;Writings File, 
         &lt;date normalize="1985/1999"&gt;1985-1999&lt;/date&gt;
         &lt;/title&gt;
         ...
         &lt;component&gt;
            &lt;componentTitle&gt;Charitable Contributions
            &lt;/componentTitle&gt; 
            &lt;subComponent&gt;
               &lt;componentTitle&gt;Diseases: <phrase role="found">AIDS</phrase>, Hepatitis, 
               Tuberculosis &lt;componentDate normalize=
               "1990/1999"&gt;1990-1999&lt;/componentDate&gt;
               &lt;/componentTitle&gt;
            &lt;/subComponent&gt; 
            ...
         &lt;/component&gt;
      &lt;/part&gt;
   &lt;/content&gt;
&lt;/book&gt;</eg></div3></div2></div1><div1 id="Logical"><head>Use Case "LOGICAL": Queries with Logical Expressions (Or, And, and Not Queries)</head><div2 id="logical-description"><head>Description</head><p>These use cases include queries containing logical expressions: <code>or</code>, <code>and</code>, the unary <code>not</code>, 
<code>and not</code>, and <code>mild not</code>.</p></div2><div2 id="logical-queries-results"><head>Queries and Results</head><div3 id="logical-queries-results-q1"><head>Q1 Or Query</head><p>Find all books with the words "web" or "software" in the text.</p><p>This query finds any or all of the words.</p><ulist><item><p>Operands: "web" "software"</p></item><item><p>Functionality: word query, <code>or</code> query</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./content</p></item><item><p>Return: .</p></item><item><p>Comment: The <code>or</code> query finds any or all of words queried.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content
where $cont contains text "web" ftor "software"
return $book</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text 
"web" ftor "software"]</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt;
         ...
         &lt;p&gt;The usability of a <phrase role="found">Web</phrase> site is how well the 
         site supports the user in achieving specified 
         goals. A <phrase role="found">Web</phrase> site should facilitate learning, 
         and enable efficient and effective task 
         completion, while propagating few errors. 
         Satisfaction with the site is also important. 
         The user must not only be well-served, but must 
         feel well-served.&lt;/p&gt; 
         ...
         &lt;p&gt;This book has been approved by the <phrase role="found">Web</phrase> Site 
         Users Association.&lt;/p&gt;
      &lt;/introduction&gt;
      &lt;part number="1"&gt;
         &lt;title&gt;Expert Reviews&lt;/title&gt;
         &lt;introduction&gt;
            &lt;p&gt;Expert reviewers identify problems 
            and recommend changes to <phrase role="found">web</phrase> sites based 
            on research in human computer interaction 
            and their experience in the field.&lt;/p&gt; 
            ...
            &lt;p&gt;Expert review methods should be 
            initiated early in the development process, 
            as soon as paper &lt;b&gt;p&lt;/b&gt;rototypes 
            (hand-drawn pictures of <phrase role="found">Web</phrase> pages) or
            &lt;b&gt;w&lt;/b&gt;ireframes (electronic mockups) are 
            available. They should be conducted using 
            the hardware and <phrase role="found">software</phrase> similar to that  
            employed by users.&lt;/p&gt;
         &lt;/introduction&gt;
         &lt;chapter&gt;
            &lt;title&gt;Heuristic Evaluation&lt;/title&gt;
            &lt;p&gt;Expert reviewers critique an interface to 
            determine conformance with recognized 
            usability principles. &lt;footnote&gt;One of the 
            best known lists of heuristics is &lt;citation 
            url="http://www.useit.com/papers/heuristic
            /heuristic_list.html"&gt;Ten Usability 
            Heuristics by Jacob Nielson&lt;/citation&gt;. Another 
            is &lt;citation url="http://usability.gov
            /guidelines/index.html"&gt; Research-Based <phrase role="found">Web</phrase>  
            Design and Usability Guidelines&lt;/citation&gt;
            &lt;/footnote&gt;&lt;/p&gt; 
         &lt;/chapter&gt;
         &lt;chapter&gt;
            &lt;title&gt;Cognitive Walk-Through&lt;/title&gt;
            &lt;p&gt;Expert reviewers evaluate <phrase role="found">Web</phrase> site 
            understandability and ease of learning while 
            performing specified tasks. They walk through 
            the site answering questions such as "Would a 
            user know by looking at the screen how to 
            complete the first step of the task?" and "If 
            the user completed the first step, would the 
            user know what to do next?," with the goal of 
            identifying any obstacles to completing the 
            task and assessing whether the user would 
            cognitively be aware that he was successful in 
            completing a step in the process.&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;
      ...
   &lt;/content&gt;
&lt;/book&gt;
        
&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;     
      &lt;introduction&gt;
         &lt;p&gt;This is a basic handbook for planning and 
         conducting usability tests on <phrase role="found">Web</phrase> sites. Usability 
         testing should be used in conjunction with other 
         expert review methods.&lt;/p&gt;
         &lt;p&gt;This book has not been approved by the <phrase role="found">Web</phrase> Site
         Users Association.&lt;/p&gt;
      &lt;/introduction&gt;
      &lt;part number="1"&gt;
         ...
      &lt;/part&gt;
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Conducting Usability Tests&lt;/title&gt; 
            ...
            &lt;p&gt;Give the user the script, then assure them 
            that you are testing the <phrase role="found">Web</phrase> site, not them. 
            Users are asked to verbalize their thoughts as 
            they complete the tasks. The event is recorded 
            or someone takes notes. It is often preferable 
            to have two testers, &lt;footnote&gt;Usability 
            testing can be done at great expense or on a 
            shoe string, using &lt;testingProcedure&gt;in-house 
            expertise&lt;/testingProcedure&gt; or 
            &lt;testingProcedure&gt;contracting with human 
            computer interaction professionals
            &lt;/testingProcedure&gt;.&lt;/footnote&gt; one to ask the 
            questions, another to take notes. Testers should 
            offer no guidance or comments to the user. Mouse 
            movements, typing, expressions, and the user's 
            words should be recorded.&lt;/p&gt;
         &lt;/chapter&gt;
         &lt;chapter&gt;
            &lt;title&gt;Evaluating and Implementing Results&lt;/title&gt; 
            &lt;p&gt;Compile the results and review collectively. 
            Make changes to the site to alleviate the problems 
            found in <phrase role="found">Web</phrase> site components which were propagating 
            the largest number of or the most devastating errors. 
            Begin new iterations of testing and changes, until 
            users are successful in the accomplishing the 
            tasks.&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;    
   &lt;/content&gt;
&lt;/book&gt;        
    
&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt; 
      &lt;introduction&gt;
         &lt;p&gt;The papers of John Wesley Usabilityguy span the 
         years 1946-2001, with the bulk of the items 
         concentrated in the period from 1985 to 2001. The 
         papers feature his career as a developer of <phrase role="found">software</phrase> 
         applications and usability specialist. The collection 
         consists of correspondence, memoranda, journals, 
         speeches, article drafts, book drafts, notes, charts, 
         graphs, family papers, clippings, printed matter, 
         photographs, résumés and other materials.&lt;/p&gt;
      &lt;/introduction&gt;
      &lt;part number="1"&gt;&lt;container type="box"&gt;1-12&lt;/container&gt;
         &lt;title&gt;Subject File, &lt;date normalize="1930/1974"&gt;
         1930-1974&lt;/date&gt;&lt;/title&gt;
         ...
         &lt;component&gt;&lt;container type="box"&gt;1&lt;/container&gt;
           &lt;componentTitle&gt;Computers&lt;/componentTitle&gt;
           &lt;subComponent&gt;
              &lt;componentTitle&gt;<phrase role="found">Software</phrase>, 
              &lt;componentDate normalize="1946/1947"&gt;1946-1947
              &lt;/componentDate&gt;
              &lt;/componentTitle&gt;
           &lt;/subComponent&gt;   
           ...
         &lt;/component&gt;
         &lt;component&gt;
           &lt;componentTitle&gt;<phrase role="found">Web</phrase> User Appreciation Award, 
           &lt;componentDate normalize="1956"&gt;1956&lt;/componentDate&gt;
           &lt;/componentTitle&gt;
         &lt;/component&gt;
         ...
      &lt;/part&gt;  
   &lt;/content&gt;
&lt;/book&gt;</eg></div3><div3 id="logical-queries-results-q2"><head>Q2 And Query</head><p>Find all books with the words "web" "software" in the text.</p><p>This query finds all of the words.</p><ulist><item><p>Operands: "web" "software"</p></item><item><p>Functionality: word queries, <code>and</code> query</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./content</p></item><item><p>Return: .</p></item><item><p>Comments: The <code>and</code> query finds all the words.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content
where $cont contains text "web" ftand "software"
return $book</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text 
"web" ftand "software"]</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt;
         &lt;author&gt;Elina Rose&lt;/author&gt;
         &lt;p&gt;The usability of a <phrase role="found">Web</phrase> site is how well the 
         site supports the user in achieving specified 
         goals. A <phrase role="found">Web</phrase> site should facilitate learning, 
         and enable efficient and effective task 
         completion, while propagating few errors. 
         Satisfaction with the site is also important. 
         The user must not only be well-served, but must 
         feel well-served.&lt;/p&gt; 
         ...
         &lt;p&gt;This book has been approved by the <phrase role="found">Web</phrase> Site 
         Users Association.&lt;/p&gt;
      &lt;/introduction&gt;
      &lt;part number="1"&gt;
         &lt;title&gt;Expert Reviews&lt;/title&gt;
         &lt;introduction&gt;
             &lt;p&gt;Expert reviewers identify problems 
            and recommend changes to <phrase role="found">web</phrase> sites based 
            on research in human computer interaction 
            and their experience in the field.&lt;/p&gt; 
            ...
            &lt;p&gt;Expert review methods should be 
            initiated early in the development process, 
            as soon as paper &lt;b&gt;p&lt;/b&gt;rototypes 
            (hand-drawn pictures of <phrase role="found">Web</phrase> pages) or
            &lt;b&gt;w&lt;/b&gt;ireframes (electronic mockups) are 
            available. They should be conducted using 
            the hardware and <phrase role="found">software</phrase> similar to that  
            employed by users.&lt;/p&gt;
         &lt;/introduction&gt;
         &lt;chapter&gt;
            &lt;title&gt;Heuristic Evaluation&lt;/title&gt;
            &lt;p&gt;Expert reviewers critique an interface to 
            determine conformance with recognized 
            usability principles. &lt;footnote&gt;One of the 
            best known lists of heuristics is &lt;citation 
            url="http://www.useit.com/papers/heuristic
            /heuristic_list.html"&gt;Ten Usability 
            Heuristics by Jacob Nielson&lt;/citation&gt;. Another 
            is &lt;citation url="http://usability.gov
            /guidelines/index.html"&gt; Research-Based <phrase role="found">Web</phrase>  
            Design and Usability Guidelines&lt;/citation&gt;
            &lt;/footnote&gt;&lt;/p&gt; 
         &lt;/chapter&gt;
         &lt;chapter&gt;
            &lt;title&gt;Cognitive Walk-Through&lt;/title&gt;
            &lt;p&gt;Expert reviewers evaluate <phrase role="found">Web</phrase> site 
            understandability and ease of learning while 
            performing specified tasks. They walk through 
            the site answering questions such as "Would a 
            user know by looking at the screen how to 
            complete the first step of the task?" and "If 
            the user completed the first step, would the 
            user know what to do next?," with the goal of 
            identifying any obstacles to completing the 
            task and assessing whether the user would 
            cognitively be aware that he was successful in 
            completing a step in the process.&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;
      ...
   &lt;/content&gt;
&lt;/book&gt;   
    
&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt; 
      &lt;introduction&gt;
         &lt;p&gt;The papers of John Wesley Usabilityguy span the 
         years 1946-2001, with the bulk of the items 
         concentrated in the period from 1985 to 2001. The 
         papers feature his career as a developer of <phrase role="found">software</phrase> 
         applications and usability specialist. The collection 
         consists of correspondence, memoranda, journals, 
         speeches, article drafts, book drafts, notes, charts, 
         graphs, family papers, clippings, printed matter, 
         photographs, résumés and other materials.&lt;/p&gt;
      &lt;/introduction&gt;
      &lt;part number="1"&gt;&lt;container type="box"&gt;1-12&lt;/container&gt;
         &lt;title&gt;Subject File, &lt;date normalize="1930/1974"&gt;
         1930-1974&lt;/date&gt;&lt;/title&gt;
         ...
         &lt;component&gt;&lt;container type="box"&gt;1&lt;/container&gt;
           &lt;componentTitle&gt;Computers&lt;/componentTitle&gt;
           &lt;subComponent&gt;
              &lt;componentTitle&gt;<phrase role="found">Software</phrase>, 
              &lt;componentDate normalize="1946/1947"&gt;1946-1947
              &lt;/componentDate&gt;
              &lt;/componentTitle&gt;
           &lt;/subComponent&gt;   
           ...
         &lt;/component&gt;
         &lt;component&gt;
           &lt;componentTitle&gt;<phrase role="found">Web</phrase> User Appreciation Award, 
           &lt;componentDate normalize="1956"&gt;1956&lt;/componentDate&gt;
           &lt;/componentTitle&gt;
         &lt;/component&gt;
         ...
      &lt;/part&gt;  
   &lt;/content&gt;
&lt;/book&gt;</eg></div3><div3 id="logical-results-q3"><head>Q3 And Query Ordered</head><p>Find all book text containing the words "goal" "obstacles" "task" in this order.</p><p>This query finds multiple words in the order queried.</p><ulist><item><p>Operands: "goal" "obstacles" "task"</p></item><item><p>Functionality: ordered word query</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./content</p></item><item><p>Return: .</p></item><item><p>Comments: This query finds multiple words in a specified 
order. It is more permissive than a phrase query. It is comparable to an 
ordered distance query where the number of intervening words is zero or more.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content
where $cont contains text "goal" ftand "obstacles" 
   ftand "task" ordered
return $book</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text 
"goal" ftand "obstacles" ftand "task" ordered]</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 					
   &lt;content&gt;
   ...
      &lt;part number="1"&gt;
         &lt;chapter&gt;
            &lt;p&gt;Expert reviewers evaluate Web site 
            understandability and ease of learning while 
            performing specified tasks. They walk through 
            the site answering questions such as "Would a 
            user know by looking at the screen how to 
            complete the first step of the task?" and "If 
            the user completed the first step, would the 
            user know what to do next?," with the <phrase role="found">goal</phrase> of 
            identifying any <phrase role="found">obstacles</phrase> to completing the 
            <phrase role="found">task</phrase> and assessing whether the user would 
            cognitively be aware that he was successful in 
            completing a step in the process.&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;
      ...
   &lt;/content&gt;
&lt;/book&gt;
</eg></div3><div3 id="logical-queries-results-q4"><head>Q4 Unary Not Query</head><p>Find all books which do not belong in a collection on "usability testing".</p><p>This query finds books which do not contain a phrase in an element and its descendants.</p><ulist><item><p>Operands: "usability testing" </p></item><item><p>Functionality: phrase query, character wildcard (suffix) (0 or more), unary <code>not</code> query</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: .</p></item><item><p>Return: .</p></item><item><p>Comments: Unlike the <code>and not</code> query below, the unary <code>not</code> query 
requires only one operand. This query has value for information architects and data managers 
who will use it for checks such as this one: to find nonconforming data in a document or a 
collection.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book 
where $book contains text ftnot "us.* testing" 
   using wildcards
return $book</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[. contains text ftnot "us.* testing" 
using wildcards]</eg><p>
<emph>Expected Result: No results returned.</emph>
</p></div3><div3 id="logical-queries-results-q5"><head>Q5 And Not Query</head><p>Find all books with the word "usability" and not the word "plan" in the metadata.</p><p>This query finds a word only when another is not found in an element or its descendants.</p><ulist><item><p>Operands: "usability" "plan"</p></item><item><p>Functionality: word query, <code>and not</code> query</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./metadata</p></item><item><p>Return: .</p></item><item><p>Comments: The <code>and not</code> query is also called a but, but not, without 
query. Unlike the unary <code>not</code> query above,this query requires two operands. Book 2
which contains the words "usability" and "plan" in the metadata is not returned.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $up := $book/metadata
where $up contains text "usability" ftand ftnot "plan"
return $book</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[./metadata contains text "usability" 
ftand ftnot "plan"]</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="1"&gt;
   &lt;metadata&gt;				
      &lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
      the <phrase role="found">Usability</phrase> of a Web Site Through Expert Reviews 
      and <phrase role="found">Usability</phrase> Testing&lt;/title&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
   ...   
   &lt;/content&gt;   
&lt;/book&gt;

&lt;book number="3"&gt;
   &lt;metadata&gt;	
      ...			
      &lt;subjects xml:lang="en"&gt;
         ...  
         &lt;subject&gt;<phrase role="found">Usability</phrase> Testing&lt;/subject&gt;
         ... 
      &lt;/subjects&gt;  
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
   ...   
   &lt;/content&gt;   
&lt;/book&gt;
</eg></div3><div3 id="logical-queries-results-q6"><head>Q6 And Not Query Where Second Operand Is a Subset of the First Operand</head><p>Find all books with listings for "résumés", "drafts", or "correspondence", and not "book drafts" in the text.</p><p>This query finds books with multiple words and not a phrase containing one of those words.</p><ulist><item><p>Operands: "résumés" "drafts" "correspondence" "book drafts"</p></item><item><p>Functionality: word queries,  <code>or</code> query, phrase query, <code>and not</code> query, 
						with diacritics as written in the query</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./content</p></item><item><p>Return: .</p></item><item><p>Comments: This query will not return a result the user wants because that result 
						also includes what the user does not want, "book drafts".</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content
where $cont contains text ("résumés" using diacritics sensitive 
   ftor "drafts" ftor "correspondence") ftand ftnot 
   "book drafts"
return $book</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[./content contains text ("résumés" 
using diacritics sensitive ftor "drafts" ftor "correspondence") 
ftand ftnot "book drafts"]</eg><p>
<emph>Expected Result: No results returned.</emph>
</p></div3><div3 id="logical-queries-results-q7"><head>Q7 Mild Not Query Where Second Operand Is a Subset of the First Operand</head><p>Find all books with listings for "résumés", "drafts", or "correspondence", and not "book 
						drafts", in the metadata or text.</p><p>This query finds books with multiple words and not a phrase which contains one of the words, while not eliminating a result if it contains the phrase as well as one of  the words searched.</p><ulist><item><p>Operands: "résumés" "drafts" "correspondence" "book drafts"</p></item><item><p>Functionality: word queries, <code>or</code> query, phrase query, <code>mild not</code> query, 
						with diacritics as written in the query</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./content</p></item><item><p>Return: .</p></item><item><p>Comments: This query will return a result
the user wants even though it contains the phrase the user
deprecated via the mild not, "book drafts". The user will not lose results which 
						contain what he wants when that book also contains what he does not want. Books containing 
						instances of "book drafts" (a subset of "drafts") are not automatically excluded. Instead the "book drafts" instances are not considered when determing whether or not to include books in the result set.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content
where $cont contains text ("résumés" using diacritics sensitive 
   ftor "drafts" ftor "correspondence") not in "book 
   drafts"
return $book</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text ("résumés" 
using diacritics sensitive ftor "drafts" ftor "correspondence") 
not in "book drafts"]</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt; 
         &lt;p&gt;The papers of John Wesley Usabilityguy span the 
         years 1946-2001, with the bulk of the items 
         concentrated in the period from 1985 to 2001. The 
         papers feature his career as a developer of software 
         applications and usability specialist. The collection 
         consists of <phrase role="found">correspondence</phrase>, memoranda, journals, 
         speeches, article <phrase role="found">drafts</phrase>, book drafts, notes, charts, 
         graphs, family papers, clippings, printed matter, 
         photographs, <phrase role="found">résumés</phrase> and other materials.&lt;/p&gt;
         &lt;/introduction&gt;
      ...      
   &lt;/content&gt;
&lt;/book&gt;</eg></div3></div2></div1><div1 id="Cardinality"><head>Use Case "CARDINALITY": Queries in Same, Any, Every Instance of an Element, and Occurrence Count Query</head><div2 id="cardinality-description"><head>Description</head><p>These use cases illustrate instance queries and occurrence count queries. They query words within the same, any, and every instance of an element. Another query finds a phrase only if it occurs over a specified number of times in a book.</p></div2><div2 id="cardinality-queries-results"><head>Queries and Results</head><div3 id="cardinality-queries-results-q1"><head>Q1 Query in Same Instance of an Element</head><p>Find all books with the phrase "web site" and the word "usability" in the same subject.</p><p>This query finds a word and a phrase in the same instance of an element.</p><ulist><item><p>Operands: "web site" "usability"</p></item><item><p>Functionality: phrase query, word query, <code>and</code> query</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./metadata/subjects/subject</p></item><item><p>Return: .</p></item><item><p>Comments: This query finds a word and a phrase in an instance of an element, not allowing one 
of the operands to be found in an instance of the element and the other operand in a different instance of 
the element. This query does not find Book 2 which has "usability" and "web site" in different instances of the <code>subject</code> element.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $subj := $book/metadata/subjects/subject
where $subj contains text "web site" ftand "usability"
return $book</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[metadata/subjects/subject contains text 
"web site" ftand "usability"]</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...  
      &lt;subjects xml:lang="en"&gt;
         &lt;subject&gt;Usability testing&lt;/subject&gt;
         &lt;subject&gt;Web site development&lt;/subject&gt;        
         &lt;subject&gt;Heuristic evaluation&lt;/subject&gt;
         &lt;subject&gt;Cognitive walk-through&lt;/subject&gt;
         &lt;subject&gt;<phrase role="found">Web site</phrase> <phrase role="found">usability</phrase>&lt;/subject&gt;
      &lt;/subjects&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      ...
   &lt;/content&gt;
&lt;/book&gt;</eg></div3><div3 id="cardinality-queries-results-q2"><head>Q2 Query in Any Instance of an Element (Existential Quantification)</head><p>Find all books with the phrase "web site" and the word "usability" in any subject.</p><p>This query finds a word and a phrase in any instance of an element across the siblings of the same element. The word and the phrase may be in different elements.</p><ulist><item><p>Operands: "web site" "usability"</p></item><item><p>Functionality: phrase query, word query, <code>and</code> query, existential quantification</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./metadata/subjects/subject</p></item><item><p>Return: .</p></item><item><p>Comments: This query finds words and phrases in any instance of an 
						element, allowing one of the operands to be found in one sibling and the other operand 
						in a different sibling of the same element name.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book                        
let $subj := $book/metadata/subjects/subject            
where (some $s1 in $subj satisfies $s1 contains text "web site")    
   and (some $s2 in $subj satisfies $s2 contains text "usability")
return $book</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[(some $s1 in ./metadata/subjects/subject satisfies 
$s1 contains text "web site") 
and (some $s2  in ./metadata/subjects/subject satisfies 
$s2 contains text "usability")]</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...  
      &lt;subjects xml:lang="en"&gt;
         &lt;subject&gt;<phrase role="found">Usability</phrase> testing&lt;/subject&gt;
         &lt;subject&gt;<phrase role="found">Web site</phrase> development&lt;/subject&gt;          
         &lt;subject&gt;Heuristic evaluation&lt;/subject&gt;
         &lt;subject&gt;Cognitive walk-through&lt;/subject&gt;
         &lt;subject&gt;<phrase role="found">Web site</phrase> <phrase role="found">usability</phrase>&lt;/subject&gt;
      &lt;/subjects&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      ...
   &lt;/content&gt;
&lt;/book&gt;
   
&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...  
      &lt;subjects xml:lang="en"&gt;
         &lt;subject&gt;<phrase role="found">Usability</phrase> testing&lt;/subject&gt;
         &lt;subject&gt;<phrase role="found">Web site</phrase> development&lt;/subject&gt;
         &lt;subject&gt;Guides and finding aids&lt;/subject&gt;
      &lt;/subjects&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      ...
   &lt;/content&gt;
&lt;/book&gt;</eg></div3><div3 id="cardinality-queries-results-q3"><head>Q3 Query in Every Instance of an Element (Universal Quantification)</head><p>Find all books with the words "ersatz" and "publications" in every publisher name.</p><p>This query finds two words in every instance of an element.</p><ulist><item><p>Operands: "ersatz" "publications"</p></item><item><p>Functionality: word query, <code>and</code> query, universal quantification</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./metadata/publicationInfo/publisher</p></item><item><p>Return: .</p></item><item><p>Comments: This query does not return a book if at least one of its publishers does not contain the words "ersatz" and 
"publications". Book 1 is returned because it has an instance of the <code>publisher</code> element which satisfies the full-text conditions (contains both "Ersatz" and
"Publications").  Book 2 is not returned because even though it has a publisher that satisfies the full-text conditions, it also has a publisher that
does not satisfy it. Book 3 is not returned because it has an instance of the <code>publisher</code> element which
does not satisfy the query (contains "Ersatz" but not "Publications").</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
where every $pub in $book//publisher satisfies 
   $pub contains text "ersatz" ftand "publications"
return $book</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[every $pub in .//publisher 
satisfies $pub contains text "ersatz" ftand "publications"]</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
      &lt;publicationInfo&gt;   
         &lt;publisher&gt;<phrase role="found">Ersatz Publications</phrase>&lt;/publisher&gt;
      &lt;/publicationInfo&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      ...
   &lt;/content&gt;
&lt;/book&gt;</eg></div3><div3 id="cardinality-queries-results-q4"><head>Q4 Occurrence Count Query</head><p>Find all books which repeat the phrase "expert review methods" in the text at least two times.</p><p>This query finds a phrase which is repeated a specified number of times.</p><ulist><item><p>Operands: "expert review methods"</p></item><item><p>Functionality: phrase query, at least functionality</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./content</p></item><item><p>Return: .</p></item><item><p>Comments: This query excludes books with 
only minor (single occurrence) references to "expert review methods".</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content
where $cont contains text "expert review methods" 
   occurs at least 2 times
return $book</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text "expert 
review methods" occurs at least 2 times]</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 					
   &lt;content&gt;
      ...
      &lt;part number="1"&gt;
         &lt;title&gt;Expert Reviews&lt;/title&gt;
         &lt;introduction&gt;
            ...
            &lt;p&gt;Two <phrase role="found">expert review methods</phrase> are discussed 
            here. They are heuristic evaluation and 
            cognitive walk-through.&lt;/p&gt; 
            &lt;p&gt;<phrase role="found">Expert review methods</phrase> should be 
            initiated early in the development process, 
            as soon as paper &lt;b&gt;p&lt;/b&gt;rototypes 
            (hand-drawn pictures of Web pages) or 
            &lt;b&gt;w&lt;/b&gt;ireframes (electronic mockups) are 
            available. They should be conducted using 
            the hardware and software similar to that 
            employed by users.&lt;/p&gt;
         &lt;/introduction&gt;
         ...
      &lt;/part&gt;      
   &lt;/content&gt;
&lt;/book&gt;</eg></div3></div2></div1><div1 id="Proximity"><head>Use Case "PROXIMITY": Queries on Proximity Relationships Including Distance, Window, Sentence, and Paragraph</head><div2 id="proximity-description"><head>Description</head><p>These use cases illustrate unordered and ordered distance queries which find  
					sequences of words allowing up to a specified number of intervening words. They also include a query 
					to find words within a window, within a sentence, and within a 
					paragraph.</p></div2><div2 id="proximity-queries-results"><head>Queries and Results</head><div3 id="proximity-queries-results-q1"><head>Q1 Unordered Distance Query</head><p>Find all books with information on "software developers".</p><p>This query finds multiple words in any order allowing up to a specified number of intervening words.</p><ulist><item><p>Operands: "software" "developer"</p></item><item><p>Functionality: word queries, stemming, unordered distance (0 to 3 intervening words)</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./content</p></item><item><p>Return: .</p></item><item><p>Comments: This query finds "developer of software", which occurs in the sample data.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content
where $cont contains text "software" ftand "developer" 
   using stemming distance at most 3 words
return $book</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text "software" 
ftand "developer" using stemming distance at most 3 words]</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt; 
         &lt;p&gt;The papers of John Wesley Usabilityguy span the 
         years 1946-2001, with the bulk of the items 
         concentrated in the period from 1985 to 2001. The 
         papers feature his career as a <phrase role="found">developer</phrase> of <phrase role="found">software</phrase> 
         applications and usability specialist. The collection 
         consists of correspondence, memoranda, journals, 
         speeches, article drafts, book drafts, notes, charts, 
         graphs, family papers, clippings, printed matter, 
         photographs, résumés and other materials.&lt;/p&gt;
      &lt;/introduction&gt;
      ...      
   &lt;/content&gt;
&lt;/book&gt;</eg></div3><div3 id="proximity-queries-results-q2"><head>Q2 Ordered Distance Query</head><p>Find all books with information on "efficient task completion".</p><p>This query finds multiple words in the order queried allowing up to a specified number 
						of intervening words.</p><ulist><item><p>Operands: "efficient" "task" "completion"</p></item><item><p>Functionality: word queries, ordered distance (0 to 10 intervening words)</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./content</p></item><item><p>Return: .</p></item><item><p>Comments: This query is more permissive than an phrase query on "efficient task completion" 
which would return no results.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content
where $cont contains text "efficient" ftand "task" ftand 
   "completion" ordered distance at most 10 words
return $book</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text "efficient" 
ftand "task" ftand "completion" ordered
distance at most 10 words]</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
   &lt;content&gt;
      &lt;introduction&gt;
         ... 
         &lt;p&gt;The usability of a Web site is how well the 
         site supports the user in achieving specified 
         goals. A Web site should facilitate learning, 
         and enable <phrase role="found">efficient</phrase> and effective <phrase role="found">task</phrase>
         <phrase role="found">completion</phrase>, while propagating few errors.
         Satisfaction with the site is also important. 
         The user must not only be well-served, but must 
         feel well-served.&lt;/p&gt; 
         ...
      &lt;/introduction&gt;
      ...   
   &lt;/content&gt;
&lt;/book&gt;</eg></div3><div3 id="proximity-queries-results-q3"><head>Q3 Ordered Window Query</head><p>Find all books about "users feeling well-served".</p><p>This query finds books with multiple words within an ordered window of up to a specified number of words.</p><ulist><item><p>Operands: "users" "feeling" "well served" "well-served"</p></item><item><p>Functionality: word queries, ordered window (0 to 15 words)</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./content</p></item><item><p>Return: .</p></item><item><p>Comments: This query opens a window on the first found word (which because of the <code>ordered</code> operator must be the first word queried) and counts a specified number 
						of words from that first word within which it may find the remaining word or words, finding them 
						in the order queried.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content
where $cont contains text ("users" ftand "feeling") 
   using stemming ftand "well served" ftor 
   "well-served" ordered window 15 words
return $book</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text ("users" ftand 
"feeling") using stemming ftand "well served" 
ftor "well-served" ordered window 15 words]</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt;
         ... 
         &lt;p&gt;The usability of a Web site is how well the 
         site supports the user in achieving specified 
         goals. A Web site should facilitate learning, 
         and enable efficient and effective task
         completion, while propagating few errors.         
         Satisfaction with the site is also important. 
         The <phrase role="found">user</phrase> must not only be well-served, but must
         <phrase role="found">feel</phrase> <phrase role="found">well</phrase>-<phrase role="found">served</phrase>.&lt;/p&gt;  
         ...
      &lt;/introduction&gt;
      ...   
   &lt;/content&gt;
&lt;/book&gt;</eg></div3><div3 id="proximity-queries-results-q4"><head>Q4 Unordered Within a Sentence Query</head><p>Find all books which discuss "questions asked during cognitive walk-throughs".</p><p>This query finds books with multiple words in any order within a sentence.</p><ulist><item><p>Operands: "users" "would" "know" "step"</p></item><item><p>Functionality: word queries, stemming, unordered sentence query</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./content</p></item><item><p>Return: .</p></item><item><p>Comments: This query expects an implementation-defined tokenized sentence or a <code>sentence</code> element.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content
where $cont contains text ("users" ftand "would" ftand "know" 
   ftand "step" same sentence) using stemming
return $book</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text ("users" ftand "would" 
ftand "know" ftand "step" same sentence) using stemming]</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 					
   &lt;content&gt;
      ...
      &lt;part number="1"&gt;
         &lt;chapter&gt;
            &lt;p&gt;Expert reviewers evaluate Web site 
            understandability and ease of learning while 
            performing specified tasks. They walk through 
            the site answering questions such as "<phrase role="found">Would</phrase> a
            <phrase role="found">user</phrase> <phrase role="found">know</phrase> by looking at the screen how to
            complete the first <phrase role="found">step</phrase> of the task?" and "If            
            the user completed the first step, would the 
            user know what to do next?," with the goal of 
            identifying any obstacles to completing the 
            task and assessing whether the user would 
            cognitively be aware that he was successful in 
            completing a step in the process.&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;
      ...
   &lt;/content&gt;
&lt;/book&gt;</eg></div3><div3 id="proximity-queries-results-q5"><head>Q5 Unordered Within a Paragraph Query</head><p>Find all paragraphs which define what "Web site usability" is.</p><p>This query finds books with multiple words and phrases in any order within a paragraph.</p><ulist><item><p>Operands: "usability" "web site" "efficiency" "satisfaction"</p></item><item><p>Functionality: word queries, phrase query, unordered paragraph query</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./content</p></item><item><p>Return: .</p></item><item><p>Comments: This query expects an implementation-defined tokenized paragraph or a <code>paragraph</code> element. Depending on the implementation, this query might return no result instead of the Expected Result presented.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content
where $cont contains text "usability" ftand "web site" 
   ftand "efficiency" ftand "satisfaction" same paragraph
return $book</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text "usability" 
ftand "web site" ftand "efficiency" ftand "satisfaction" 
same paragraph]</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
   &lt;content&gt;
      &lt;introduction&gt;
         ... 
         &lt;p&gt;The <phrase role="found">usability</phrase> of a <phrase role="found">Web site</phrase> is how well the 
         site supports the user in achieving specified 
         goals. A <phrase role="found">Web site</phrase> should facilitate learning, 
         and enable <phrase role="found">efficient</phrase> and effective task
         completion, while propagating few errors.         
         <phrase role="found">Satisfaction</phrase> with the site is also important.. 
         The user must not only be well-served, but must
         feel well-served.&lt;/p&gt;  
         ...
      &lt;/introduction&gt;
      ...   
   &lt;/content&gt;					
&lt;/book&gt;</eg></div3></div2></div1><div1 id="Axes"><head>Use Case "AXES": Queries Using Relative XPath Axes</head><div2 id="axes-description"><head>Description</head><p>These use cases illustrate queries traversing relative XPath axes.</p></div2><div2 id="axes-queries-results"><head>Queries and Results</head><div3 id="axes-queries-results-q1"><head>Q1 Query on Element and Its Children</head><p>Find all books with paragraphs containing the phrase "computer workstation" and footnotes 
within those paragraphs containing the word "comfortable".</p><p>This query finds a phrase in an element, then finds a word in a child element.</p><ulist><item><p>Operands: "computer workstation" "comfortable"</p></item><item><p>Functionality: phrase query, word query</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: .//p, .//p/footnote</p></item><item><p>Return: ./metadata/title, .//p</p></item><item><p>Comments: This query combines phrase and word search in different elements which have a parent-child relationship.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $para := $book//p
let $fn := $para/footnote
where $para contains text "computer workstation" 
   and $fn contains text "comfortable"
return ($book/metadata/title, $para)</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[.//p contains text "computer workstation" 
and .//p/footnote contains text "comfortable"]/(metadata/title, 
.//p)</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;title shortTitle="Usability Basics"&gt;Usability 
Basics: How to Plan for and Conduct Usability Tests 
on Web Site Thereby Improving the Usability of Your 
Web Site&lt;/title&gt;      
&lt;p&gt;This is a basic handbook for planning and 
conducting usability tests on Web sites. Usability 
testing should be used in conjunction with other 
expert review methods.&lt;/p&gt;
&lt;p&gt;This book has not been approved by the Web Site 
Users Association.&lt;/p&gt;
&lt;p&gt;Take the following steps to plan usability 
testing. &lt;step number="1"&gt;Clarify and 
articulate the goal of the usability testing.
&lt;/step&gt; &lt;step number="2"&gt;Identify tasks which 
are critical for users to be able to complete 
successfully.&lt;/step&gt; &lt;step number="3"&gt;Compile 
a script of questions or instructions which 
will prompt the user to attempt those 
tasks.&lt;/step&gt; &lt;step number="4"&gt;Identify your 
users and begin recruiting them.&lt;/step&gt; &lt;step 
number="5"&gt;Conduct a pretest on a few users.
&lt;/step&gt; &lt;step number="6"&gt;Edit the script based 
on insights gleaned from the pretest.&lt;/step&gt; 
&lt;step number="7"&gt;Resume testing.&lt;/step&gt;&lt;/p&gt;
&lt;p&gt;Users can be tested at any <phrase role="found">computer</phrase> 
<phrase role="found"> workstation</phrase>
&lt;footnote&gt;They may be more 
<phrase role="found">comfortable</phrase> at their own workstation than in 
a lab.&lt;/footnote&gt; or in a lab.&lt;/p&gt;
&lt;p&gt;Give the user the script, then assure them 
that you are testing the Web site, not them. 
Users are asked to verbalize their thoughts as 
they complete the tasks. The event is recorded 
or someone takes notes. It is often preferable 
to have two testers, &lt;footnote&gt;Usability 
testing can be done at great expense or on a 
shoe string, using &lt;testingProcedure&gt;in-house 
expertise&lt;/testingProcedure&gt; or 
&lt;testingProcedure&gt;contracting with human 
computer interaction professionals
&lt;/testingProcedure&gt;.&lt;/footnote&gt; one to ask the 
questions, another to take notes. Testers should 
offer no guidance or comments to the user. Mouse 
movements, typing, expressions, and the user's 
words should be recorded.&lt;/p&gt;
&lt;p&gt;Compile the results and review collectively. 
Make changes to the site to alleviate the problems 
found in Web site components which were propagating 
the largest number of or the most devastating errors. 
Begin new iterations of testing and changes, until 
users are successful in the accomplishing the 
tasks.&lt;/p&gt;</eg></div3><div3 id="axes-queries-results-q2"><head>Q2 Query on Element Returning Its First Two Children</head><p>Find the first two steps in chapters on "conducting usability tests."</p><p>This query finds words in an element, then returns its first two children elements.</p><ulist><item><p>Operands: "usability", "test"</p></item><item><p>Functionality: word queries, stemming</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./content/part/chapter/p</p></item><item><p>Return: ./metadata/title ./content/part/chapter/p/step[1], ./content/part/chapter/p/step[2]</p></item><item><p>Comments: This query finds words in a <code>p</code> element and uses XPath to return the first two children 
of the element.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $para := $book//chapter/p
where $para contains text "usability" ftand "test" 
   using stemming
return ($book/metadata/title, $para/step[1], $para/step[2])</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[.//chapter/p contains text "usability" 
ftand "test" using stemming]/(metadata/title, 
.//chapter/p/step[1], .//chapter/p/step[2])</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;title shortTitle="Usability Basics"&gt;Usability 
Basics: How to Plan for and Conduct Usability Tests 
on Web Site Thereby Improving the Usability of Your 
Web Site&lt;/title&gt;   
&lt;step number="1"&gt;Clarify and articulate 
the goal of the usability testing.&lt;/step&gt; 
&lt;step number="2"&gt;Identify tasks which 
are critical for users to be able to complete 
successfully.&lt;/step&gt;</eg></div3><div3 id="axes-queries-results-q3"><head>Q3 Query on Element and Its Ancestors</head><p>Are there any "flow diagrams" of "human computer interaction" scenarios in John Wesley 
						Usabilityguy's papers?</p><p>This query finds a phrase in an element, then finds another phrase in an ancestor element.</p><ulist><item><p>Operands: "flow diagrams" "human computer interaction"</p></item><item><p>Functionality: phrase queries, character wildcard (suffix) (0 or one)</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book[@number="3"]</p></item><item><p>Query context: ./content/part/component/(subComponent|subComponent/subsubComponent)/componentTitle</p></item><item><p>Return: ./metadata/title, ./content</p></item><item><p>Comments: This query looks for a phrase in an element and a different phrase in its ancestor elements.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book[@number="3"]
let $comp := $book/content/part/component/
   (subComponent|subComponent/subsubComponent)/
   componentTitle
let $parentComp := $comp[ancestor::node()]
where $comp contains text "flow diagram.?" 
   using wildcards and $parentComp 
   contains text "human computer interaction"
return ($book/metadata/title, $book/content)</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[@number="3" and content/part/component/
(subComponent|subComponent/subsubComponent)/ 
componentTitle contains text "flow diagram.?" using wildcards 
and ./ancestor::node()[.//componentTitle contains text "human computer 
interaction"]]/(metadata/title, content)</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;title shortTitle="Usabilityguy Manuscript 
Guide"&gt;John Wesley Usabilityguy: A Register of His 
Papers&lt;/title&gt;
&lt;content&gt;
   ...
   &lt;part number="1"&gt;&lt;container type="box"&gt;1-12&lt;/container&gt;
      &lt;title&gt;Subject File, &lt;date normalize="1930/1974"&gt;
      1930-1974&lt;/date&gt;&lt;/title&gt;
        ...
        &lt;subComponent&gt;
           &lt;componentTitle&gt;<phrase role="found">Human Computer Interaction</phrase> 
           research, &lt;componentDate normalize="1945/1952"&gt;
           1945-1952&lt;/componentDate&gt;
           &lt;/componentTitle&gt;
           &lt;subsubComponent&gt;
              &lt;componentTitle&gt;<phrase role="found">Flow diagram</phrase>, 
              &lt;componentDate normalize="1950"&gt;1950
              &lt;/componentDate&gt;
              &lt;/componentTitle&gt;
           &lt;/subsubComponent&gt;
           ...
         &lt;/subComponent&gt;
      &lt;/component&gt;
   &lt;/part&gt;
&lt;/content&gt;</eg></div3><div3 id="axes-queries-results-q4"><head>Q4 Query on Element and Its Right Siblings</head><p>Find all book chapters with paragraphs on "usability testing" followed by paragraphs on "information architecture".</p><p>This query finds a phrase in an element, then finds another phrase in one of its right siblings.</p><ulist><item><p>Operands: "usability testing" "information architecture"</p></item><item><p>Functionality: phrase queries</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./content/part/chapter/p</p></item><item><p>Return: ./metadata/title, ./content</p></item><item><p>Comments: This query returns book chapters if they contain paragraphs following each other 
as specified in the query.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $chapters := $book//chapter
where $chapters[./p contains text "usability 
   testing" and ./p/following-sibling::p contains text 
   "information architecture"]
return ($book/metadata/title, $chapters)</eg><p>
<emph>Solution in XPath: None</emph>
</p><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
the Usability of a Web Site Through Expert Reviews and 
Usability Testing&lt;/title&gt;
&lt;chapter&gt;
    &lt;title&gt;Heuristic Evaluation&lt;/title&gt;
    &lt;p&gt;Expert reviewers critique an interface to 
    determine conformance with recognized 
    usability principles. &lt;footnote&gt;One of the 
    best known lists of heuristics is &lt;citation 
    url="http://www.useit.com/papers/heuristic
    /heuristic_list.html"&gt;Ten Usability 
    Heuristics by Jacob Nielson&lt;/citation&gt;. Another 
    is &lt;citation url="http://usability.gov
    /guidelines/index.html"&gt; Research-Based Web 
    Design and Usability Guidelines&lt;/citation&gt;
    &lt;/footnote&gt;&lt;/p&gt; 
&lt;/chapter&gt;
&lt;chapter&gt;
    &lt;title&gt;Cognitive Walk-Through&lt;/title&gt;
    &lt;p&gt;Expert reviewers evaluate Web site 
    understandability and ease of learning while 
    performing specified tasks. They walk through 
    the site answering questions such as "Would a 
    user know by looking at the screen how to 
    complete the first step of the task?" and "If 
    the user completed the first step, would the 
    user know what to do next?," with the goal of 
    identifying any obstacles to completing the 
    task and assessing whether the user would 
    cognitively be aware that he was successful in 
    completing a step in the process.&lt;/p&gt;
&lt;/chapter&gt;
&lt;chapter&gt;
   &lt;p&gt;Once the problems identified by expert 
   reviews have been corrected, it is time to 
   conduct some tests of the site with your unique 
   audience or audiences by conducting <phrase role="found">usability</phrase>
   <phrase role="found">testing</phrase>.&lt;/p&gt;
   &lt;p&gt;Users are asked to complete tasks which 
   measure the success of the <phrase role="found">information</phrase> 
   <phrase role="found">architecture</phrase> and navigational elements of the 
   site.&lt;/p&gt;
   &lt;p&gt;Then changes are made to improve service to 
   users.&lt;/p&gt;
&lt;/chapter&gt;
</eg></div3></div2></div1><div1 id="Ignore"><head>Use Case "IGNORE": Queries Ignoring Descendant Element Content</head><div2 id="ignore-description"><head>Description</head><p>These phrase and proximity queries cross element boundaries ignoring the
content of descendant elements. One query ignores the content of a
complete sub-tree. Other queries ignore only the content of specified
descendant elements. The last query performs a level-by-level ignore. It ignores the content of descendant elements when querying the content of the parent element. Its descendant elements are promoted and then their content is queried.</p></div2><div2 id="ignore-queries-results"><head>Queries and Results</head><div3 id="ignore-queries-results-q1"><head>Q1 Distance Query Ignoring Content of All Descendant Elements</head><p>Find advice on whether the observer should "correct" or provide "guidance" to the user during usability "testing".</p><p>This query ignores the content of all descendant elements.</p><ulist><item><p>Operands: "testing" "correct" "guidance"</p></item><item><p>Functionality: phrase query, word queries, <code>or</code> query, ordered distance query (0 to 60 intervening words), ignore content of descendant elements</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: .//p</p></item><item><p>Return: .</p></item><item><p>Comments: This query ignores the content of all the descendant elements of the <code>p</code> element, so it ignores the <code>footnote</code> and <code>testingProcedure</code> elements. If the descendant elements were not ignored, the words searched would be too distant from each other to have been returned.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
        /books/book
     where $book//p[. contains text "testing" ftand "guidance" ftor
        "correct" distance at most 60 words without content *]
     return $book</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[.//p contains text "testing" 
ftand "guidance" ftor "correct" distance at 
most 60 words without content *]</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      ...   					
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            ...
            &lt;p&gt;Give the user the script, then assure them 
            that you are <phrase role="found">testing</phrase> the Web site, not them. 
            Users are asked to verbalize their thoughts as 
            they complete the tasks. The event is recorded 
            or someone takes notes. It is often preferable 
            to have two testers, &lt;footnote&gt;Usability 
            testing can be done at great expense or on a 
            shoe string, using &lt;testingProcedure&gt;in-house 
            expertise&lt;/testingProcedure&gt; or 
            &lt;testingProcedure&gt;contracting with human 
            computer interaction professionals
            &lt;/testingProcedure&gt;.&lt;/footnote&gt; one to ask the 
            questions, another to take notes. Testers should 
            offer no <phrase role="found">guidance</phrase> or comments to the user. Mouse 
            movements, typing, expressions, and the user's 
            words should be recorded.&lt;/p&gt;
         &lt;/chapter&gt;
         ...
      &lt;/part&gt;
   &lt;/content&gt;
&lt;/book&gt;</eg></div3><div3 id="ignore-queries-results-q2"><head>Q2 Phrase Query Ignoring Content of Descendant Element Specified by XPath Expression</head><p>Find all book chapters containing "users can be tested at any computer
workstation or in a lab" ignoring footnotes.</p><p>This query finds book chapters containing the phrase "users can be
tested at any computer workstation or in a lab" ignoring the content of a descendant element explicitly specified by an XPath expression.</p><ulist><item><p>Operands: "users can be tested at any computer workstation or in a lab"</p></item><item><p>Functionality: phrase query, ignore content of <code>footnote</code> element</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./content/part/chapter</p></item><item><p>Return: ./metadata/title, ./content/part/chapter</p></item><item><p>Comments: This query ignores the content of a descendant element, the <code>footnote</code> element.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $chap := $book//chapter[. contains text "users 
   can be tested at any computer workstation 
   or in a lab" without content .//footnote]
where $chap
return ($book/metadata/title, $chap)</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book//chapter[. contains text
"users can be tested at any computer workstation or in a lab"
without content .//footnote
]/(ancestor::book/metadata/title, .)/.</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;title shortTitle="Usability Basics"&gt;Usability 
Basics: How to Plan for and Conduct Usability Tests 
on Web Site Thereby Improving the Usability of Your 
Web Site&lt;/title&gt;
&lt;chapter&gt;
   ...
   &lt;p&gt;<phrase role="found">Users can be tested at any computer</phrase>  
   <phrase role="found">workstation</phrase> &lt;footnote&gt;They may be more 
   comfortable at their own workstation than in 
   a lab.&lt;/footnote&gt;<phrase role="found">or in a lab</phrase>.&lt;/p&gt; 
   ...
&lt;/chapter&gt;</eg></div3><div3 id="ignore-queries-results-q3"><head>Q3 Phrase Query Ignoring Content of Descendant Element Specified by Full-Text Query</head><p>Find all book chapters containing the phrase "at any computer workstation or in a lab" ignoring footnotes on workstations.</p><p>This query ignores the content of a descendant element specified by a full-text query.</p><ulist><item><p>Operands: "at any computer workstation or in a lab", "workstations"</p></item><item><p>Functionality: phrase query, character wildcard (suffix) (1), ignore content of a descendant element found by a full-text query</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./content/part/chapter</p></item><item><p>Return: ./metadata/title, ./content/part/chapter</p></item><item><p>Comments: This query ignores the content of a descendant element identified dynamically by a full-text query.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $chapter in doc("http://bstore1.example.com/full-text.xml")
   /books/book//chapter
where $chapter contains text "at any computer 
   workstation or in a lab" without content 
   $chapter//footnote[. contains text "workstation.*" 
   using wildcards]
return ($chapter/ancestor::book/metadata/title, $chapter)</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book//chapter[. contains text "at any computer 
workstation or in a lab" without content 
.//footnote[. contains text "workstation.*" 
using wildcards]]/(ancestor::book/metadata/title, .)</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;title shortTitle="Usability Basics"&gt;Usability 
Basics: How to Plan for and Conduct Usability Tests 
on Web Site Thereby Improving the Usability of Your Web 
Site&lt;/title&gt;
&lt;chapter&gt;
   ...
   &lt;p&gt;Users can be tested <phrase role="found">at any computer</phrase>
   <phrase role="found">workstation</phrase>&lt;footnote&gt;They may be more
   comfortable at their own workstation than in 
   a lab.&lt;/footnote&gt;<phrase role="found">or in a lab</phrase>.&lt;/p&gt;   
   ...
&lt;/chapter&gt;</eg></div3><div3 id="ignore-queries-results-q4"><head>Q4 Distance Query Ignoring Content of Descendant Elements Level by Level</head><p>Find all books with the word "workstation" near the word "lab".</p><p>This query performs a level-by-level ignore. It ignores the content of descendant elements when querying the content of the parent element. Its descendant elements are promoted and then their content is queried. It differs from the ignore queries above because it queries the content of parent elements skipping over the descendant elements, then instead of stopping there it queries the content of descendent elements in isolation.</p><ulist><item><p>Operands: "workstation" "lab"</p></item><item><p>Functionality: word queries, unordered distance (0 to 6 intervening words), level by level ignore (ignore the content of descendant element when searching the parent element and promote the descendant element and query it in isolation)</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./content/part/chapter/p, /content/part/chapter/p/footnote</p></item><item><p>Return: ./metadata/title, .//chapter/(p|p/footnote)</p></item><item><p>Comments: This query ignores the content of the descendant element <code>footnote</code> when querying its parent element <code>p</code> returning "workstation" and "lab" from "Users can be tested at any computer workstation or in a lab". Then the descendant element <code>footnote</code> is promoted and queried separately returning "workstation" and "lab" from "They may be more comfortable at their own workstation than in a lab". This query is written using the standard ignore syntax ORing together parent and descendant elements to be queried separately.</p></item></ulist><p>
						<emph>Solution in XQuery:</emph>
					</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $matches := $book//chapter/(p|p/footnote)[
   . contains text
   "workstation" ftand "lab" distance at most 6 words
   without content ./footnote]
where $matches
return ($book/metadata/title, $matches)</eg><p>
						<emph>Solution in XPath:</emph>
					</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book//chapter/(p|p/footnote)[. contains text 
"workstation" ftand "lab" distance at most 6 words 
without content //footnote[. 
contains text "workstation." using wildcards]]   
/(ancestor::book/metadata/title, .)/.</eg><p>
						<emph>Expected Result:</emph>
					</p><eg xml:space="preserve">&lt;title shortTitle="Usability Basics"&gt;Usability 
   Basics: How to Plan for and Conduct Usability Tests 
   on Web Site Thereby Improving the Usability of Your 
   Web Site&lt;/title&gt;
&lt;p&gt;Users can be tested at any computer 
   <phrase role="found">workstation</phrase> &lt;footnote&gt;They may be more 
   comfortable at their own workstation than in 
   a lab.&lt;/footnote&gt; or in a <phrase role="found">lab</phrase>.&lt;/p&gt;
&lt;footnote&gt;They may be more comfortable at their own 
   <phrase role="found">workstation</phrase> than in a <phrase role="found">lab</phrase>.&lt;/footnote&gt;
</eg></div3></div2></div1><div1 id="Full-Text-Composability"><head>Use Case "FULL-TEXT-COMPOSABILITY": Queries Illustrating Composability of Full-Text with Itself</head><div2 id="full-text-composability-description"><head>Description</head><p>The use cases illustrate a multi-lingual query and queries which use multiple full-text functionalities in conjunction with other XQuery and XPath functionalities.</p></div2><div2 id="full-text-composability-queries-results"><head>Queries and Results</head><div3 id="full-text-composability-queries-results-q1"><head>Q1 Query on Words and Phrases in Two Languages</head><p>Find all books with the subject "网站可用性", with an introduction written by "Elina Rose", 
which mention the name of the usability expert "Millicent Marigold".</p><p>This query finds words and a phrase in more than one language.</p><ulist><item><p>Operands: "网站可用性" "Elina" "Rose" "Millicent" "Marigold"</p></item><item><p>Functionality: phrase query, word queries, <code>and</code> query, unordered distance (0 to 3 intervening words), capacity to enter, query, and return multiple languages</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./metadata/subjects/subject, ./content/introduction/author, ./content</p></item><item><p>Return: ./@number, ./metadata/title, ./metadata/subjects/subject, ./content/introduction/author, ./content</p></item><item><p>Comments: This query accepts multiple languages as input and returns multiple languages as output.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
where $book//subject[. contains text "网站可用性" using language "zh"]
   and $book/content/introduction/author[. contains text 
   "Elina" ftand "Rose" distance at most 3 words]
   and $book/content[. contains text "Millicent" ftand "Marigold" 
   distance at most 3 words]
return &lt;book number="{$book/@number}"&gt; 
          {$book/metadata/title, $book//subject, 
          $book/content/introduction/author, $book/content} 
       &lt;/book&gt;</eg><p>
<emph>Solution in XPath: None</emph>
</p><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="1"&gt;
   &lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
   the Usability of a Web Site Through Expert Reviews 
   and Usability Testing&lt;/title&gt;
   &lt;subject&gt;<phrase role="found">网站可用性</phrase>&lt;/subject&gt;
   &lt;author&gt;<phrase role="found">Elina</phrase> <phrase role="found">Rose</phrase>&lt;/author&gt;
   &lt;content&gt;
      &lt;introduction&gt;
         ...   
         &lt;p&gt;The most successful projects employ multiple methods 
         in multiple iterations. As <phrase role="found">Millicent</phrase> <phrase role="found">Marigold</phrase> remarked 
         during a recent conference, "Don't stop. Iterate, iterate, 
         then iterate again."&lt;/p&gt;
         ...
      &lt;/introduction&gt;   
      ...      
   &lt;/content&gt;
&lt;/book&gt;</eg></div3><div3 id="full-text-composability-queries-results-q2"><head>Q2 Phrase and Distance Query in an Instance of an Element With Stemming</head><p>Find all paragraphs in books which discuss the role of "task performing" in "expert reviewer" methods.</p><p>This query finds multiple words close to each other and a phrase in one instance of an element. </p><ulist><item><p>Operands: "task" "performing" "expert reviewer"</p></item><item><p>Functionality: word queries, stemming, phrase query, unordered distance (0 to 3 intervening words 
						between "task" and "performing")</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./content//p</p></item><item><p>Return: ./metadata/title, ./content</p></item><item><p>Comments: This query combines functionalities introduced in previous sections.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $para := $book/content//p
where $para contains text (("task" ftand "performing" 
   distance at most 3 words) ftand 
   "expert reviewer") using stemming
return ($book/metadata/title, $book/content)</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[content//p contains text (("task" 
ftand "performing" distance at most 3 words) 
ftand "expert reviewer") using stemming]/
(metadata/title, content)</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
   the Usability of a Web Site Through Expert Reviews and 
   Usability Testing&lt;/title&gt;
&lt;content&gt;
   ...   
   &lt;part number="1"&gt;
      &lt;title&gt;Expert Reviews&lt;/title&gt;
      ...
      &lt;chapter&gt;
         &lt;title&gt;Cognitive Walk-Through&lt;/title&gt;
         &lt;p&gt;<phrase role="found">Expert reviewers</phrase> evaluate Web site 
         understandability and ease of learning while 
         <phrase role="found">performing</phrase> specified <phrase role="found">tasks</phrase>. They walk through 
         the site answering questions such as "Would a 
         user know by looking at the screen how to 
         complete the first step of the task?" and "If 
         the user completed the first step, would the 
         user know what to do next?," with the goal of 
         identifying any obstacles to completing the 
         task and assessing whether the user would 
         cognitively be aware that he was successful in 
         completing a step in the process.&lt;/p&gt;
      &lt;/chapter&gt;
   &lt;/part&gt;
   ...   
&lt;/content&gt;</eg></div3><div3 id="full-text-composability-queries-results-q3"><head>Q3 Nested Distance Query with Wildcards, Stemming, and Thesaurus Support</head><p>Find all books on "usability testing" which "quote" "Millicent Marigold" on the value of "iterating" multiple times.</p><p>This query finds multiple words in three nested levels of distance queries. It uses wildcards, stemming, and thesaurus support.</p><ulist><item><p>Operands: "usability testing" "quote" "millicent" "marigold" "iterating"</p></item><item><p>Functionality: phrase query, character wildcard (suffix) (0-5), word queries, thesaurus support, stemming, ordered distance 
						(0 to 3 intervening words between "millicent" and "marigold"), unordered distance (0 to 3 intervening words 
						between ("millicent ... marigold" and (one of the following from stemming: "quote", "quoted", "quotes", "quotation", "quotations" or one of the following from thesaurus support: "said", "says", "stated", "states", "statement", "spoke", "speaks", "replied", "replies", "reply", "remarks", "remarked", "responded", "response", 
						"reports ", "reported", "quotes", "quoted", "according", "commented", "discussed", "expressed", "told"), unordered distance (0 to 50 intervening words between ("millicent ... marigold" ... ("quote" or any of its wildcard- or thesaurus-derived substitutes) and ("usability testing" and "iterating")).</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./content</p></item><item><p>Return: .</p></item><item><p>Comments: This query combines functionalities introduced in previous sections. This query will return the result shown or no results depending on whether the wildcard or thesaurus match option was processed first. The processing order of these two match options is implementation-defined.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $quote := $book/content
where $quote contains text (("millicent" 
   ftand "marigold" ordered distance at most 3 words)
   ftand "quote.{0,5}" using wildcards using thesaurus at  
   "http://bstore1.example.com/UsabilityThesaurus.xml"
   relationship "synonyms" distance at most 3 words)
   ftand "usability testing" ftand "iterating" using stemming 
   distance at most 50 words
return $book</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text (("millicent" 
ftand "marigold" ordered distance at most 3 words)
ftand "quote.{0,5}" using wildcards using thesaurus at 
"http://bstore1.example.com/UsabilityThesaurus.xml"
relationship "synonyms" distance at most 3 words)
ftand "usability testing" ftand "iterating" using stemming 
distance at most 50 words]</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt; 
   &lt;content&gt;
      &lt;introduction&gt;
         ...   
         &lt;p&gt;Expert reviews and <phrase role="found">usability testing</phrase> are 
         methods of identifying problems in layout, 
         terminology, and navigation before they frustrate 
         users and drive them away from your site.&lt;/p&gt;      
         &lt;p&gt;The most successful projects employ multiple 
         methods in multiple iterations. As <phrase role="found">Millicent</phrase>
         <phrase role="found">Marigold</phrase> <phrase role="found">remarked</phrase> during a recent conference, 
         "Don't stop. <phrase role="found">Iterate</phrase>, <phrase role="found">iterate</phrase>, then <phrase role="found">iterate</phrase>          
         again."&lt;/p&gt;
      &lt;/introduction&gt;
   &lt;/content&gt;
&lt;/book&gt;</eg></div3><div3 id="full-text-composability-queries-results-q4"><head>Q4 Window Query with Wildcards and Stemming Ignoring Content of a Descendant Element</head><p>Find advice on whether an observer in a "usability test" should "correct" or provide "guidance" to the user in 
a book not authored by Montana Marigold.</p><p>This query uses synonyms supplied by the user, uses the unary <code>not</code>, nests a Boolean query and a phrase query within a window query, and ignores the tags and content of a descendant element.</p><ulist><item><p>Operands: "usability testing" "correct" "comment" "guidance" "help" "assistance" "montana" "marigold"</p></item><item><p>Functionality: phrase query, word queries, character wildcard (suffix) (0 or more), synonyms for "correct" and "guidance" provided by the user ("comment" or "assistance" or "help"), stemming, <code>or</code> query ("correct" or "comment" or "guidance" or "assistance" or "help"), <code>and</code> query ("montana" and "marigold"), unary <code>not</code> query (not "montana" and "marigold"),
unordered window (0 to 70 words within a window of "usability testing" and ("correct" or "comment" or "guidance" or "assistance" or "help"). Ignores content of descendant elements.</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./metadata/author, ./content</p></item><item><p>Return: ./@number, ./metadata/title, ./content</p></item><item><p>Comments: This query combines functionalities introduced in previous sections.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $au := $book/metadata/author
let $co := $book/content
where not( $au contains text ("montana" ftand "marigold"))
   and $co contains text ("correct" ftor "comment" 
   using stemming ftor "guidance" ftor "assistance" 
   ftor "help") ftand "usability test.*" using wildcards 
   window 80 words without content $co//footnote
return &lt;book number="{$book/@number}"&gt; 
          {$book/metadata/title, $co}
          &lt;/book&gt;</eg><p>
<emph>Solution in XPath: None</emph>
</p><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="2"&gt;
   &lt;title shortTitle="Usability Basics"&gt;Usability 
   Basics: How to Plan for and Conduct Usability Tests 
   on Web Site Thereby Improving the Usability of Your 
   Web Site&lt;/title&gt;
   &lt;content&gt;
      ...                                       
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Conducting <phrase role="found">Usability Tests</phrase>&lt;/title&gt; 
            &lt;p&gt;Users can be tested at any computer 
            workstation &lt;footnote&gt;They may be more 
            comfortable at their own workstation than in 
            a lab.&lt;/footnote&gt; or in a lab.&lt;/p&gt;
            &lt;p&gt;Give the user the script, then assure them 
            that you are testing the Web site, not them. 
            Users are asked to verbalize their thoughts as 
            they complete the tasks. The event is recorded 
            or someone takes notes. It is often preferable 
            to have two testers, &lt;footnote&gt;Usability 
            testing can be done at great expense or on a 
            shoe string, using &lt;testingProcedure&gt;in-house 
            expertise&lt;/testingProcedure&gt; or 
            &lt;testingProcedure&gt;contracting with human 
            computer interaction professionals
            &lt;/testingProcedure&gt;.&lt;/footnote&gt; one to ask the 
            questions, another to take notes. Testers should 
            offer no <phrase role="found">guidance</phrase> or <phrase role="found">comments</phrase> to the user. Mouse 
            movements, typing, expressions, and the user's 
            words should be recorded.&lt;/p&gt;
         &lt;/chapter&gt;
         ...
      &lt;/part&gt;
   &lt;/content&gt;
&lt;/book&gt;
</eg></div3><div3 id="full-text-composability-queries-results-q5"><head>Q5 Query on Different Elements in Different Sub-Trees with Conditional Return</head><p>For each book with a title containing the word "usability", a book introduction 
containing the word "satisfaction", and a part introduction containing the phrase "identify problems", return the book title and the authors if it has authors. Return the book title and publisher, if it has no authors.</p><p>This query finds words and a phrase in different elements in different sub-trees. It also contains a conditional return.</p><ulist><item><p>Operands: "usability" "satisfaction" "identify problems"</p></item><item><p>Functionality: word queries, phrase query, conditional query</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./metadata/title, ./content/introduction, ./content/part/introduction</p></item><item><p>Return: ./@number, ./metadata/title, ./metadata/author, ./metadata/publicationInfo/publisher, ./content/introduction, 
./content/part/introduction</p></item><item><p>Comments: This query combines functionalities introduced in previous sections.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $title := $book/metadata/title
let $in := $book/content/introduction
let $pin := $book/content/part/introduction
where $title contains text "usability" and $in contains text 
   "satisfaction" and $pin contains text "identify 
   problems"
return &lt;book number="{$book/@number}"&gt;{ 
    ($title, 
         if (count($book/metadata/author) &gt; 0)
         then ($book/metadata/author, $in, $pin)
         else ($book/metadata/publicationInfo/publisher, $in, $pin))
     }
       &lt;/book&gt; </eg><p>
<emph>Solution in XPath: None</emph>
</p><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="1"&gt;
   &lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
   the <phrase role="found">Usability</phrase> of a Web Site Through Expert Reviews 
   and <phrase role="found">Usability</phrase> Testing&lt;/title&gt;     
   &lt;author&gt;Millicent Marigold&lt;/author&gt;  
   &lt;author&gt;Montana Marigold&lt;/author&gt;     
   &lt;introduction&gt;
      ...
      &lt;p&gt;The usability of a Web site is how well the 
      site supports the user in achieving specified 
      goals. A Web site should facilitate learning, 
      and enable efficient and effective task 
      completion, while propagating few 
      errors. <phrase role="found">Satisfaction</phrase> with the site is also important. 
      The user must not only be well-served, but must 
      feel well-served.&lt;/p&gt;
      ...
  &lt;/introduction&gt;
  &lt;introduction&gt;
      &lt;p&gt;Expert reviewers <phrase role="found">identify problems</phrase> and recommend changes 
      to web sites based on research in human computer interaction 
      and their experience in the field.&lt;/p&gt;
      ...
  &lt;/introduction&gt; 
&lt;/book&gt;</eg></div3></div2></div1><div1 id="XQuery-XPath-Composability"><head>Use Case "XQUERY-XPATH-COMPOSABILITY": Queries Illustrating Composability of Full-Text with Other XQuery and XPath Functionalities</head><div2 id="xquery-xpath-composability-description"><head>Description</head><p>These queries combine full-text queries with other XQuery and XPath functionalities.</p></div2><div2 id="xquery-xpath-composability-queries-results"><head>Queries and Results</head><div3 id="xquery-xpath-composability-queries-results-q1"><head>Q1 Full-Text Query Constructing New Element</head><p>For books with "usability" in the title create a flat list of all title-author pairs, with each pair enclosed in a newly constructed element.</p><p>This query finds a word in an element and returns the element and another wrapped in a new element.</p><ulist><item><p>Operands: "usability"</p></item><item><p>Functionality: word query, construction of new element</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./metadata/title</p></item><item><p>Return: result (constructed element), ./metadata/title, ./metadata/author</p></item><item><p>Comments: This query finds the word "usability" in the title of a book and building title-author pairs 
for those books returning them wrapped in a newly constructed result element.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $var := $book/metadata/title
where $var contains text "usability"
return &lt;result&gt; 
          {$book/metadata/title, $book/metadata/author} 
           &lt;/result&gt;</eg><p>
<emph>Solution in XPath: None</emph>
</p><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;result&gt;
   &lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
   the <phrase role="found">Usability</phrase> of a Web Site Through Expert Reviews 
   and <phrase role="found">Usability</phrase> Testing&lt;/title&gt;
   &lt;author&gt;Millicent Marigold&lt;/author&gt;
   &lt;author&gt;Montana Marigold&lt;/author&gt;
&lt;/result&gt;
   
&lt;result&gt;
   &lt;title shortTitle="Usability Basics"&gt;<phrase role="found">Usability</phrase> 
   Basics: How to Plan for and Conduct <phrase role="found">Usability</phrase> Tests 
   on Web Site Thereby Improving the <phrase role="found">Usability</phrase> of Your 
   Web Site&lt;/title&gt;
&lt;/result&gt;</eg></div3><div3 id="xquery-xpath-composability-queries-results-q2"><head>Q2 Full-Text Query Returning Count of Descendant Element Occurrences</head><p>Find all books with a chapter title on "usability tests". Return book title, chapter title, and the number of steps in chapters.</p><p>This query finds words then returns among other elements a constructed element reporting the number of occurrences of a descendant element.</p><ulist><item><p>Operands: "usability" "test"</p></item><item><p>Functionality: word queries, <code>and</code> query, stemming, count, construction of new element, conditional expression</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./content/part/chapter/title, ./content/part/chapter/p/step</p></item><item><p>Return: ./@number, ./metadata/title, ./content/part/chapter/title, number-of-steps (constructed element)</p></item><item><p>Comments: This query finds the word "usability" and stemmed forms of the word "test" in the titles of 
book chapters. It returns chapter titles along with an occurrence count of descendant <code>step</code> elements. The query returns a number of steps equal to 
0 if the chapter is on usability testing but does not specify any steps (e.g., there are not descendant <code>step</code> elements).</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $ct := $book/content/part/chapter/title
where $ct contains text "usability" ftand "test" 
   using stemming
return &lt;book number="{$book/@number}"&gt; 
          {$book/metadata/title,
          for $title in $ct
          return 
             ($title, 
             &lt;number-of-steps&gt; 
                {count($title/..//step)}
             &lt;/number-of-steps&gt;)}
       &lt;/book&gt;</eg><p>
<emph>Solution in XPath: None</emph>
</p><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="1"&gt;
   &lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
   the Usability of a Web Site Through Expert Reviews and 
   Usability Testing&lt;/title&gt;
   &lt;title&gt;<phrase role="found">Usability Testing</phrase>&lt;/title&gt;
   &lt;number-of-steps&gt;0&lt;/number-of-steps&gt;
 &lt;/book&gt;

&lt;book number="2"&gt;
   &lt;title shortTitle="Usability Basics"&gt;Usability 
   Basics: How to Plan for and Conduct Usability Tests 
   on Web Site Thereby Improving the Usability of Your 
   Web Site&lt;/title&gt;
   &lt;title&gt;Planning then Conducting <phrase role="found">Usability</phrase>
   <phrase role="found">Tests</phrase>&lt;/title&gt;
   &lt;number-of-steps&gt;7&lt;/number-of-steps&gt;
   &lt;title&gt;Conducting <phrase role="found">Usability Tests</phrase>&lt;/title&gt;
   &lt;number-of-steps&gt;0&lt;/number-of-steps&gt;
&lt;/book&gt;</eg></div3><div3 id="xquery-xpath-composability-queries-results-q3"><head>Q3 Full-Text Query with Conditional Return</head><p>For each book with "usability" in the book title, return the book title and a second element. Return the book 
title and a third element if the second element does not exist.</p><p>This query finds a word and contains a conditional return.</p><ulist><item><p>Operands: "usability"</p></item><item><p>Functionality: word query, count, conditional expression</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./metadata/title</p></item><item><p>Return: ./@number, ./metadata/title, ./metadata/author, ./metadata/publicationInfo/publisher</p></item><item><p>Comments: This query finds the word "usability" in the title of a book, then returns title-author pairs 
for those books when there are <code>author</code> elements. If there are no <code>author</code> elements, it returns <code>publisher</code> elements.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book[./metadata/title contains text 
   "usability"]
return &lt;book number="{$book/@number}"&gt;
          {$book/metadata/title,
             if (count($book/metadata//author) &gt; 0) 
             then $book/metadata//author 
             else $book/metadata//publisher}
       &lt;/book&gt;</eg><p>
<emph>Solution in XPath: None</emph>
</p><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="1"&gt;
   &lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
   the <phrase role="found">Usability</phrase> of a Web Site Through Expert Reviews 
   and <phrase role="found">Usability</phrase> Testing&lt;/title&gt;
   &lt;author&gt;Millicent Marigold&lt;/author&gt;
   &lt;author&gt;Montana Marigold&lt;/author&gt;
&lt;/book&gt;

&lt;book number="2"&gt;
   &lt;title shortTitle="Usability Basics"&gt;<phrase role="found">Usability</phrase> 
   Basics: How to Plan for and Conduct <phrase role="found">Usability</phrase> Tests 
   on Web Site Thereby Improving the <phrase role="found">Usability</phrase> of Your 
   Web Site&lt;/title&gt;
   &lt;publisher&gt;Ersatz Publications&lt;/publisher&gt;
   &lt;publisher&gt;Electronic BookWorks&lt;/publisher&gt;
&lt;/book&gt;</eg></div3><div3 id="xquery-xpath-composability-queries-results-q4"><head>Q4 Full-Text Query with Numeric Value Comparison</head><p>For each book with "usability" in the book title, return its book title and the round number of its suggested price if the price exceeds $25.</p><p>This query finds a word and contains a conditional return based on a function on a numeric value.</p><ulist><item><p>Operands: "usability"</p></item><item><p>Functionality: word query, round(), numeric value comparison, conditional expression</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./metadata/title, ./metadata/price</p></item><item><p>Return: ./@number, ./metadata/title, ./metadata/price</p></item><item><p>Comments: This query finds the word "usability" in the title of a book, then returns the round 
number of its price if the price exceeds a specified value.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book[metadata/title contains text "usability"]
return &lt;book number="{$book/@number}"&gt;
           {$book/metadata/title,  
             if ($book/metadata/price &gt; 25)
             then &lt;price&gt;{concat("$", round($book/metadata/price))}&lt;/price&gt;
             else ()
           }   
       &lt;/book&gt;</eg><p>
<emph>Solution in XPath: None</emph>
</p><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="1"&gt;
   &lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
   the <phrase role="found">Usability</phrase> of a Web Site Through Expert Reviews 
   and <phrase role="found">Usability</phrase> Testing&lt;/title&gt;
   &lt;price&gt;$26&lt;/price&gt;
&lt;/book&gt;

&lt;book number="2"&gt;
   &lt;title shortTitle="Usability Basics"&gt;<phrase role="found">Usability</phrase> 
   Basics: How to Plan for and Conduct <phrase role="found">Usability</phrase> Tests 
   on Web Site Thereby Improving the <phrase role="found">Usability</phrase> of Your 
   Web Site&lt;/title&gt;
   &lt;price&gt;$174&lt;/price&gt;
&lt;/book&gt;</eg></div3><div3 id="xquery-xpath-composability-queries-results-q5"><head>Q5 Full-Text Query with Character String Query</head><p>Find all introductions in books, published in "Washington, D.C.", which include listings for 
"résumés", "drafts", and "correspondence".</p><p>This query finds words and a character string.</p><ulist><item><p>Operands: "résumés" "drafts" "correspondence" character string "Washington, D.C."</p></item><item><p>Functionality: word query, with diacritics as written in the query, <code>and</code> query, character string query</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./content/introduction, ./metadata/publicationInfo/place</p></item><item><p>Return: ./@number, ./metadata/title, ./content//introduction</p></item><item><p>Comments: This query performs a full-text query when it needs to find word variants in full text and performs a character string query when word variants are not possible.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book[.//publicationInfo/place/text() 
   = "Washington, D.C."]
let $intro := $book/content/introduction
where $intro contains text "résumés" using diacritics sensitive
   ftand "drafts" ftand "correspondence"
return &lt;book number="{$book/@number}"&gt; 
           {$book/metadata/title, $intro}
           &lt;/book&gt;</eg><p>
<emph>Solution in XPath: None</emph>
</p><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="3"&gt;
   &lt;title shortTitle="Usabilityguy Manuscript 
   Guide"&gt;John Wesley Usabilityguy: A Register of 
   His Papers&lt;/title&gt; 
   &lt;introduction&gt;
      &lt;p&gt;The papers of John Wesley Usabilityguy span the 
      years 1946-1999, with the bulk of the items
      concentrated in the period from 1985 to 1999. The 
      papers feature his career as a developer of software 
      applications and usability specialist. The collection 
      consists of <phrase role="found">correspondence</phrase>, memoranda, journals, 
      speeches, article <phrase role="found">drafts</phrase>, book drafts, notes, charts, 
      graphs, family papers, clippings, printed matter, 
      photographs, <phrase role="found">résumés</phrase> and other materials.&lt;/p&gt;
   &lt;/introduction&gt;
&lt;/book&gt;</eg></div3><div3 id="xquery-xpath-composability-queries-results-q6"><head>Q6 Full-Text Query with Conditional Return of Boolean Values</head><p>For each book on "usability" return the book title and a new <code>has-publishers</code> element with value <code>true</code> if the book has more than 1 publisher. Return the title and a new <code>has-publishers</code> element with value <code>false</code> if the book does not have more than one publisher.</p><p>This query finds a word, then returns Boolean values based on the number of occurrences of an element.</p><ulist><item><p>Operands: "usability"</p></item><item><p>Functionality: word query, construction of new Boolean values, construction of new element, count, &gt;, conditional expression</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./metadata/title</p></item><item><p>Return: ./@number, ./metadata/title, has-publishers (constructed element)</p></item><item><p>Comments: This query finds "usability" in the title of a book, then returns the title and Boolean values 
showing whether the book has more than one publisher or not.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book[metadata/title contains text 
   "usability"]
return &lt;book number="{$book/@number}"&gt;
          {$book/metadata/title} 
          &lt;has-publishers&gt; 
             {if (count($book//publisher) &gt; 1) 
             then "true" else "false"}
          &lt;/has-publishers&gt;
       &lt;/book&gt;</eg><p>
<emph>Solution in XPath: None</emph>
</p><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="1"&gt;
   &lt;title&gt;Improving the <phrase role="found">Usability</phrase> of a Web Site Through 
   Expert Reviews and <phrase role="found">Usability</phrase> Testing&lt;/title&gt; 
   &lt;has-publishers&gt;false&lt;/has-publishers&gt;
&lt;/book&gt;

&lt;book number="2"&gt;
   &lt;title shortTitle="Improving Web Site Usability"&gt;<phrase role="found">Usability</phrase> 
   Basics: How to Plan for and Conduct <phrase role="found">Usability</phrase> Tests 
   on Web Site Thereby Improving the <phrase role="found">Usability</phrase> of Your 
   Web Site&lt;/title&gt;
   &lt;has-publishers&gt;true&lt;/has-publishers&gt;
&lt;/book&gt;</eg></div3><div3 id="xquery-xpath-composability-queries-results-q7"><head>Q7 Full-Text Query with Date Comparison and Element Occurrence Count</head><p>Find all books about conducting "usability tests" which have more than one author and 
are published after "2000".</p><p>This query finds a phrase, counts the number of occurrences of an
element, runs a greater than comparison on dates, and combines the results.</p><ulist><item><p>Operands: "usability testing", "2000"</p></item><item><p>Functionality: phrase query,  character wildcard (suffix) (0 or more), count, &gt;</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./metadata/subjects/subject, ./metadata/author, ./metadata/publicationInfo/(dateIssued|dateRevised)</p></item><item><p>Return: ./@number, ./metadata/title, ./metadata/author, ./metadata/subjects/subject</p></item><item><p>Comments: This is a full-text query on the phrase "usability testing" using a wildcard on the word "test", restricted to the <code>subject</code> element. The query 
counts the number of <code>author</code> elements, and runs a greater than comparison on dates.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book[./metadata/publicationInfo/
   (dateIssued|dateRevised) &gt; "2000-12-31" 
   and count(metadata/author) &gt; 1]
let $subj := $book//subject[
             . contains text "usability test.*" using wildcards]
where $subj
return &lt;book number="{$book/@number}"&gt; 
          {$book/metadata/title, $book/metadata/author, $subj}
           &lt;/book&gt;</eg><p>
<emph>Solution in XPath: None</emph>
</p><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="1"&gt;
   &lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
   the Usability of a Web Site Through Expert Reviews and 
   Usability Testing&lt;/title&gt;
   &lt;author&gt;Millicent Marigold&lt;/author&gt;
   &lt;author&gt;Montana Marigold&lt;/author&gt;
   &lt;subject&gt;<phrase role="found">Usability testing</phrase>&lt;/subject&gt;
&lt;/book&gt;

&lt;book number="3"&gt;
   &lt;title shortTitle="Usabilityguy Manuscript 
      Guide"&gt;John Wesley Usabilityguy: A Register of His 
      Papers&lt;/title&gt;
   &lt;author&gt;Millicent Marigold&lt;/author&gt;
   &lt;author&gt;Morty Marigold&lt;/author&gt;
   &lt;subject&gt;<phrase role="found">Usability testing</phrase>&lt;/subject&gt;
&lt;/book&gt;</eg></div3><div3 id="xquery-xpath-composability-queries-results-q8"><head>Q8 Query with XPath Expression Within Full-Text Expression</head><p>Find all books published after "2001" which share a subject with the book with the short title "Usability Basics".</p><p>This query finds words using an XPath expression to identify the words queried and looks for a publication date after the one specified.</p><ulist><item><p>Operands: "Usability Basics", "2001"</p></item><item><p>Functionality: phrase query, <code>and</code> query, date comparisons, XPath expression to identify the words queried.</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./metadata/title/@shortTitle, ./metadata/subjects/subject, ./metadata/publicationInfo/dateIssued|dateRevised</p></item><item><p>Return: ./@number, ./metadata/title, ./metadata/author</p></item><item><p>Comments: This query returns a book if its last date of
publication is after 2001 and one of its subjects is
the same as a subject of the book with the short title "Usability
Basics". This query uses an XPath expression to dynamically find the
subjects of books.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">let $books := doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $bookSubject := 
   $books/metadata[./title/@shortTitle 
   contains text "Usability Basics"]/subjects/subject
for $book in $books   
where $book/metadata/publicationInfo/
(dateIssued|dateRevised) &gt; 2001 and 
$book/metadata/subjects/subject contains text 
     {$bookSubject} any
return
        &lt;book number="{$book/@number}"&gt;
           {$book/metadata/title,
           $book/metadata/author}
        &lt;/book&gt;</eg><p>
<emph>Solution in XPath: None</emph>
</p><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="1"&gt;
   &lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
   the Usability of a Web Site Through Expert Reviews and 
   Usability Testing&lt;/title&gt;
   &lt;author&gt;Millicent Marigold&lt;/author&gt;
   &lt;author&gt;Morley Marigold&lt;/author&gt;
&lt;/book&gt;

&lt;book number="3"&gt;
   &lt;title shortTitle="Usabilityguy Manuscript 
   Guide"&gt;John Wesley Usabilityguy: A Register of His 
   Papers&lt;/title&gt;     
   &lt;author&gt;Millicent Marigold&lt;/author&gt;
   &lt;author&gt;Morty Marigold&lt;/author&gt; 
&lt;book&gt;</eg></div3><div3 id="xquery-xpath-composability-queries-results-q9"><head>Q9 Query Using an XQuery Expression to Determine the Number of Words Allowed in a Window</head><p>Find all books which discuss "successfully completing tasks".</p><p>This query finds words within a window, allowing more words within the window depending on the number of chapters in the book.</p><ulist><item><p>Operands: "successfully" "completing" "tasks"</p></item><item><p>Functionality: word query, stemming, unordered window of at most (number of chapters in the book times 3) words</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./content</p></item><item><p>Return: ./metadata/title, ./content</p></item><item><p>Comments:  This query uses an XQuery expression  to determine the number of words in an unordered window. It allows more words in the window when there are more chapters in the book. The query returns "tasks which are critical for users to be able to complete successfully" from Book 2, because there are three chapters in Book 2 which multiplied by four allows up to twelve  words within the window.</p></item></ulist><p>
						<emph>Solution in XQuery:</emph>
					</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $cont := $book/content
where $cont contains text ("successfully" 
   ftand "completing" ftand "tasks"
   window (count($cont/part/chapter) * 4) 
   words) using stemming
return ($book/metadata/title, $cont)</eg><p>
						<emph>Solution in XPath</emph>
					</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[content contains text ("successfully" 
ftand "completing" ftand "tasks"
window (count(content/part/chapter) * 4) 
words) using stemming]/(metadata/title, content)</eg><p>
						<emph>Expected Result:</emph>
					</p><eg xml:space="preserve">&lt;title shortTitle="Usability Basics"&gt;Usability 
Basics: How to Plan for and Conduct Usability Tests 
on Web Site Thereby Improving the Usability of Your 
Web Site&lt;/title&gt;
&lt;content&gt;
   ...
   &lt;part number="1"&gt;
      &lt;chapter&gt;
         &lt;title&gt;Planning then Conducting Usability
         Tests&lt;/title&gt; 
         &lt;p&gt;Take the following steps to plan usability 
         testing. &lt;step number="1"&gt;Clarify and 
         articulate the goal of the usability testing.
         &lt;/step&gt; &lt;step number="2"&gt;Identify <phrase role="found">tasks</phrase> which 
         are critical for users to be able to 
         <phrase role="found">complete</phrase><phrase role="found"> successfully</phrase>.&lt;/step&gt; 
         &lt;step number="3"&gt;Compile a script of questions or
         instructions which will prompt the user to attempt those 
         tasks.&lt;/step&gt; &lt;step number="4"&gt;Identify your 
         users and begin recruiting them.&lt;/step&gt; &lt;step 
         number="5"&gt;Conduct a pretest on a few users.
         &lt;/step&gt; &lt;step number="6"&gt;Edit the script based 
         on insights gleaned from the pretest.&lt;/step&gt; 
         &lt;step number="7"&gt;Resume testing.&lt;/step&gt;&lt;/p&gt;
      &lt;/chapter&gt;
   &lt;/part&gt;
   ...
&lt;/content&gt;</eg></div3></div2></div1><div1 id="Score"><head>Use Case "SCORE": All Queries May Be Written with Score, Queries in this Section Must Be Written with Score</head><div2 id="score-description"><head>Description</head><p>All the queries in these Use Cases may be written with or without score. The Use Cases in this section are merely a small subset that focuses on score.</p><p>These queries exploit score and can not be written as queries with pure Boolean full-text predicates. Among these queries are a query that computes and returns only scores, a query which returns only results over a specified threshold, a query which filters by score, a query which returns all the documents ordered, and a query which uses weighting to impact scoring and sorting. </p><p>Scoring methodologies are not defined in this recommendation. Scoring is implementation-defined. </p></div2><div2 id="score-queries-results"><head>Queries and Results</head><div3 id="score-queries-results-q1"><head>Q1 Query Returning Scores</head><p>Find all books which mention "usability" in the title or the text. Return book titles and scores.</p><p>This query performs a word query and returns scores, highest scores first.</p><ulist><item><p>Operands: "usability"</p></item><item><p>Functionality: word query, implementation-defined scoring, returns score, construction of new element</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./metadata/title, ./content</p></item><item><p>Return: ./@number, ./metadata/title, score (constructed element)</p></item><item><p>Comments: This query is only possible as a scored query. Scores are included between 0 and 1. The scoring methodology in this use case is for illustrative purposes only. Scoring methodologies will be implementation-defined. This query returns the same results as a query with a pure Boolean full-text predicate. The difference is that the results are scored and the results are returned displaying the score and ranked by score.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
  /books/book
let score $s := ($book/metadata/title contains text 
   "usability" or $book/content contains text "usability") 
where $s &gt; 0  
order by $s descending 
return &lt;book number="{$book/@number}"&gt; 
          {$book/metadata/title}
          &lt;score&gt;{$s}&lt;/score&gt; 
       &lt;/book&gt;</eg><p>
<emph>Solution in XPath: None</emph>
</p><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="2"&gt;
   &lt;title shortTitle="Usability Basics"&gt;<phrase role="found">Usability</phrase> 
   Basics: How to Plan for and Conduct <phrase role="found">Usability</phrase> Tests 
   on Web Site Thereby Improving the <phrase role="found">Usability</phrase> of Your 
   Web Site&lt;/title&gt;
   &lt;score&gt;0.9&lt;/score&gt;
&lt;/book&gt;

&lt;book number="1"&gt;
   &lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
   the <phrase role="found">Usability</phrase> of a Web Site Through Expert Reviews 
   and <phrase role="found">Usability</phrase> Testing&lt;/title&gt;
   &lt;score&gt;0.8&lt;/score&gt;
&lt;/book&gt;
   
&lt;book number="3"&gt;
   &lt;title shortTitle="Usabilityguy Manuscript 
   Guide"&gt;John Wesley Usabilityguy: A Register of His 
   Papers&lt;/title&gt;    
   &lt;score&gt;0.12&lt;/score&gt;
&lt;/book&gt;</eg></div3><div3 id="score-queries-results-q2"><head>Q2 Query Returning Results with Top Scores</head><p>Find the best two books on "usability".</p><p>This query performs a word query and returns only the results with the two top scores.</p><ulist><item><p>Operands: "usability"</p></item><item><p>Functionality: word query, implementation-defined scoring, returns books with the top two scores, conditional expression</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: .</p></item><item><p>Return: ./@number, ./metadata/title</p></item><item><p>Comments: This query returns results only for the two books with the highest scores. This query is only possible as a scored query. The scoring methodology in this use case is for illustrative purposes only. Scoring methodologies will be implementation-defined. This query returns the same results as a query with a pure Boolean full-text predicate. The difference is that the results are scored and through the introduction of a third variable only the two results with the highest scores are returned.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $result at $i in
     for $book score $s in 
        doc("http://bstore1.example.com/full-text.xml")
        /books/book[. contains text "usability"]
      order by $s ascending
      return $book
   where $i &lt;= 2
   return &lt;book number="{$result/@number}"&gt; 
      {$result/metadata/title}&lt;/book&gt;</eg><p>
<emph>Solution in XPath: None</emph>
</p><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="1"&gt;
   &lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
   the <phrase role="found">Usability</phrase> of a Web Site Through Expert Reviews 
   and <phrase role="found">Usability</phrase> Testing&lt;/title&gt;
&lt;/book&gt;
   
&lt;book number="2"&gt;
   &lt;title shortTitle="Usability Basics"&gt;<phrase role="found">Usability</phrase> 
   Basics: How to Plan for and Conduct <phrase role="found">Usability</phrase> Tests 
   on Web Site Thereby Improving the <phrase role="found">Usability</phrase> of Your 
   Web Site&lt;/title&gt; 
&lt;/book&gt;</eg></div3><div3 id="score-queries-results-q3"><head>Q3 Query Filtering on Scores</head><p>Find all books that focus on "usability".</p><p>This query performs a word query and filters on scores.</p><ulist><item><p>Operands: "usability"</p></item><item><p>Functionality: word query, implementation-defined scoring, filters on scores (accepts only those with score over 0.1)</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: .</p></item><item><p>Return: ./@number, ./metadata/title</p></item><item><p>Comments: This query is only possible as a scored query. The scoring methodology in this use case is for illustrative purposes only. Scoring methodologies will be implementation-defined. This query returns the same results as a query with a pure Boolean full-text predicate. The difference is that the results are scored and then filtered on the scores.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book score $s in 
   doc("http://bstore1.example.com/full-text.xml")
   /books/book[. contains text "usability"]
where $s &gt; 0.1
return $book/metadata/title</eg><p>
<emph>Solution in XPath:</emph>
</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[(for $i score $s in .[. contains text "usability"]
return $s) &gt; 0.1]/metadata/title</eg><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
the <phrase role="found">Usability</phrase> of a Web Site Through Expert Reviews 
and <phrase role="found">Usability</phrase> Testing&lt;/title&gt;

&lt;title shortTitle="Usability Basics"&gt;<phrase role="found">Usability</phrase> 
Basics: How to Plan for and Conduct <phrase role="found">Usability</phrase> Tests 
on Web Site Thereby Improving the <phrase role="found">Usability</phrase> of Your 
Web Site&lt;/title&gt;</eg></div3><div3 id="score-queries-results-q4"><head>Q4 Query Combining Score and XML Structure with a Conditional Return</head><p>Find all books with parts about "usability testing".</p><p>This query finds books which contain parts about usability testing, returning entire books, but without <code>part</code> elements identified as irrelevant via score.</p><ulist><item><p>Operands: "usability testing"</p></item><item><p>Functionality: phrase query, character wildcard (suffix) (0 or more), implementation-defined scoring, filters on scores (under .05), conditional return</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: .//part</p></item><item><p>Return: . without irrelevant .//part</p></item><item><p>Comments: This query is only meaningful as a scored query. The scoring methodology in this use case is for illustrative purposes only. Scoring methodologies will be implementation-defined. This query returns the same results as a query with a pure Boolean full-text predicate. The difference is that this query filters the <code>part</code> elements. They are included or excluded from the results depending on their score.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">declare function local:filter ( $nodes 
   as node()*, $exclude as element()* ) as node()*
   {
      for $node in $nodes except $exclude
      return
         typeswitch ($node)
            case $e as element()
               return 
                 element {node-name($e)}
                   {
                       $e/@*,
                      local:filter( $e/node() except $exclude, 
                      $exclude )
                   }
            default 
               return $node
   };

for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $irrelevantParts := 
   for $part in $book//part
   let score $score := $part contains text "usability test.*" 
      using wildcards
   where $score &lt; 0.5
   return $part
where count($irrelevantParts) &lt; count($book//part)
return local:filter($book, $irrelevantParts)</eg><p>
<emph>Solution in XPath: None</emph>
</p><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      &lt;introduction&gt;
         &lt;author&gt;Elina Rose&lt;/author&gt;
         &lt;p&gt;The usability of a Web site is how well the 
         site supports the user in achieving specified 
         goals. A Web site should facilitate learning, 
         and enable efficient and effective task 
         completion, while propagating few errors. 
         Satisfaction with the site is also important. 
         The user must not only be well-served, but must 
         feel well-served.&lt;/p&gt; 
         &lt;p&gt;Expert reviews and <phrase role="found">usability testing</phrase> are 
         methods of identifying problems in layout, 
         terminology, and navigation before they frustrate
         users and drive them away from your site.&lt;/p&gt;
         &lt;p&gt;The most successful projects employ multiple 
         methods in multiple iterations. As Millicent 
         Marigold remarked during a recent conference, 
         "Don't stop. Iterate, iterate, then iterate 
         again."&lt;/p&gt;
         &lt;p&gt;This book has been approved by the Web Site 
         Users Association.&lt;/p&gt;
      &lt;/introduction&gt;
      ...
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;<phrase role="found">Usability Testing</phrase>&lt;/title&gt;
            &lt;p&gt;Once the problems identified by expert 
            reviews have been corrected, it is time to 
            conduct some tests of the site with your unique 
            audience or audiences by conducting <phrase role="found">usability</phrase> 
            <phrase role="found">testing</phrase>.&lt;/p&gt;
            &lt;p&gt;Users are asked to complete tasks which 
            measure the success of the information 
            architecture and navigational elements of the 
            site.&lt;/p&gt;
            &lt;p&gt;Then changes are made to improve service to 
            users.&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt; 
   &lt;/content&gt;
&lt;/book&gt;

&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      &lt;introduction&gt;
         &lt;p&gt;This is a basic handbook for planning and 
         conducting usability tests on Web sites. Usability 
         testing should be used in conjunction with other 
         expert review methods.&lt;/p&gt;
         &lt;p&gt;This book has not been approved by the Web Site 
         Users Association.&lt;/p&gt;
      &lt;/introduction&gt;
      &lt;part number="1"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Planning then Conducting <phrase role="found">Usability</phrase> 
            <phrase role="found">Tests</phrase>&lt;/title&gt; 
            &lt;p&gt;Take the following steps to plan <phrase role="found">usability</phrase>
            <phrase role="found">testing</phrase>. &lt;step number="1"&gt;Clarify and 
            articulate the goal of the <phrase role="found">usability testing</phrase>.
            &lt;/step&gt; &lt;step number="2"&gt;Identify tasks which 
            are critical for users to be able to complete 
            successfully.&lt;/step&gt; &lt;step number="3"&gt;Compile 
            a script of questions or instructions which 
            will prompt the user to attempt those 
            tasks.&lt;/step&gt; &lt;step number="4"&gt;Identify your 
            users and begin recruiting them.&lt;/step&gt; &lt;step 
            number="5"&gt;Conduct a pretest on a few users.
            &lt;/step&gt; &lt;step number="6"&gt;Edit the script based 
            on insights gleaned from the pretest.&lt;/step&gt; 
            &lt;step number="7"&gt;Resume testing.&lt;/step&gt;&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;
      &lt;part number="2"&gt;
         &lt;chapter&gt;
            &lt;title&gt;Conducting <phrase role="found">Usability Tests</phrase>&lt;/title&gt; 
            &lt;p&gt;Users can be tested at any computer 
            workstation &lt;footnote&gt;They may be more 
            comfortable at their own workstation than in 
            a lab.&lt;/footnote&gt; or in a lab.&lt;/p&gt;
            &lt;p&gt;Give the user the script, then assure them 
            that you are testing the Web site, not them. 
            Users are asked to verbalize their thoughts as 
            they complete the tasks. The event is recorded 
            or someone takes notes. It is often preferable 
            to have two testers, &lt;footnote&gt;<phrase role="found">Usability</phrase> 
            <phrase role="found">testing</phrase> can be done at great expense or on a 
            shoe string, using &lt;testingProcedure&gt;in-house 
            expertise&lt;/testingProcedure&gt; or 
            &lt;testingProcedure&gt;contracting with human 
            computer interaction professionals
            &lt;/testingProcedure&gt;.&lt;/footnote&gt; one to ask the 
            questions, another to take notes. Testers should 
            offer no guidance or comments to the user. Mouse 
            movements, typing, expressions, and the user's 
            words should be recorded.&lt;/p&gt;
         &lt;/chapter&gt;
         &lt;chapter&gt;
            &lt;title&gt;Evaluating and Implementing Results&lt;/title&gt; 
            &lt;p&gt;Compile the results and review collectively. 
            Make changes to the site to alleviate the problems 
            found in Web site components which were propagating 
            the largest number of or the most devastating errors. 
            Begin new iterations of testing and changes, until 
            users are successful in the accomplishing the 
            tasks.&lt;/p&gt;
         &lt;/chapter&gt;
      &lt;/part&gt;
   &lt;/content&gt;
&lt;/book&gt;</eg></div3><div3 id="score-queries-results-q5"><head>Q5 Query Returning All Books Ordered by Score</head><p>Return all books, listing books with text on "software" first.</p><p>This query performs a word query, returns all the documents in the database, and orders them returning those with found word first, those without last.</p><ulist><item><p>Operands: "software"</p></item><item><p>Functionality: word query, implementation-defined scoring</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: .</p></item><item><p>Return: .</p></item><item><p>Comments: This query is only meaningful as a scored query. The scoring methodology in this use case is for illustrative purposes only. Scoring methodologies will be implementation-defined. This query returns the more results than a parallel query with a pure Boolean full-text predicate. In a parallel query with a pure Boolean full-text predicate, the last result would have a Boolean value of false and would not be returned. In this scored query the last result receives a score and is returned.</p></item></ulist><p>
<emph>Solution in XQuery:</emph>
</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let score $s := $book/content contains text "software"
order by $s descending
return $book</eg><p>
<emph>Solution in XPath: None</emph>
</p><p>
<emph>Expected Result:</emph>
</p><eg xml:space="preserve">&lt;book number="1"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;  	
      &lt;part number="1"&gt;
         &lt;title&gt;Expert Reviews&lt;/title&gt;
         &lt;introduction&gt;
            ...   								
            &lt;p&gt;Expert review methods should be
            initiated early in the development process, 
            as soon as paper &lt;b&gt;p&lt;/b&gt;rototypes
            (hand-drawn pictures of Web pages) or
            &lt;b&gt;w&lt;/b&gt;ireframes (electronic mockups) are
            available. They should be conducted using
            the hardware and <phrase role="found">software</phrase> similar to that 
            employed by users.&lt;/p&gt;
         &lt;/introduction&gt;
      &lt;/part&gt; 
      ...
   &lt;/content&gt;
&lt;/book&gt;

&lt;book number="3"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;
      &lt;introduction&gt;   
         &lt;p&gt;The papers of John Wesley Usabilityguy span the 
         years 1946-2001, with the bulk of the items 
         concentrated in the period from 1985 to 2001. The 
         papers feature his career as a developer of <phrase role="found">software</phrase> 
         applications and usability specialist. The collection 
         consists of correspondence, memoranda, journals, 
         speeches, article drafts, book drafts, notes, charts, 
         graphs, family papers, clippings, printed matter, 
         photographs, résumés and other materials.&lt;/p&gt;
      &lt;/introduction&gt;
      ...
   &lt;/content&gt;
&lt;/book&gt;

&lt;book number="2"&gt;
   &lt;metadata&gt;
      ...
   &lt;/metadata&gt;
   &lt;content&gt;	
      ...
   &lt;content&gt;	
&lt;/book&gt;</eg></div3><div3 id="score-queries-results-q6"><head>Q6 Query with Weight Declaration</head><p>Finds books which discuss "conducting usability tests" returning those which mention "measuring success" first.</p><p>This query finds words using weighting on optional words to impact the scoring and sorting.</p><ulist><item><p>Operands: "conduct" "usability" "tests" "measuring" "success"</p></item><item><p>Functionality: word queries, stemming, unordered distance (0 to 10 intervening words between "conduct" and "usability" and between "usability" and "tests"), unordered distance (0 to 4 intervening words between "measuring" and "success"), weight declaration</p></item><item><p>Data context: doc("http://bstore1.example.com/full-text.xml")/books/book</p></item><item><p>Query context: ./content</p></item><item><p>Return: ./metadata/title, ./content</p></item><item><p>Comments: This query returns books on "conducting usability tests", using a weight declaration to return books with mentions of "measuring success" higher in the sort.</p></item></ulist><p>
						<emph>Solution in XQuery:</emph>
					</p><eg role="xquery" xml:space="preserve">for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $booktext := $book/content [. contains text ("conduct"
   ftand "usability" ftand "tests" distance at most
   10 words) using stemming]
let score $s := $booktext contains text
   (("measuring" ftand "success" distance
   at most 4 words) weight {1.8}) using stemming  
where $booktext
order by $s descending
return ($book/metadata/title, $booktext)</eg><p>
						<emph>Solution in XPath: None</emph>
					</p><p>
						<emph>Expected Result:</emph>
					</p><eg xml:space="preserve">&lt;title shortTitle="Improving Web Site Usability"&gt;Improving 
the Usability of a Web Site Through Expert Reviews 
and Usability Testing&lt;/title&gt;
&lt;content&gt;
   ...
   &lt;part number="2"&gt;
      &lt;chapter&gt;
         &lt;title&gt;Usability Testing&lt;/title&gt;
         &lt;p&gt;Once the problems identified by expert 
         reviews have been corrected, it is time to 
         conduct some tests of the site with your unique 
         audience or audiences by <phrase role="found">conducting usability</phrase> 
         <phrase role="found">testing</phrase>.&lt;/p&gt;
         &lt;p&gt;Users are asked to complete tasks which 
         <phrase role="found">measure</phrase> the <phrase role="found">success</phrase> of the information 
         architecture and navigational elements of the 
         site.&lt;/p&gt;
         &lt;p&gt;Then changes are made to improve service to 
         users.&lt;/p&gt;
      &lt;/chapter&gt;
   &lt;/part&gt; 
&lt;/content&gt;

&lt;title shortTitle="Usability Basics"&gt;Usability 
Basics: How to Plan for and Conduct Usability Tests 
on Web Site Thereby Improving the Usability of Your 
Web Site&lt;/title&gt;
&lt;content&gt;
   &lt;introduction&gt;
      &lt;p&gt;This is a basic handbook for planning and 
      <phrase role="found">conducting usability tests</phrase> on Web sites. Usability 
      testing should be used in conjunction with other 
      expert review methods.&lt;/p&gt;
      &lt;p&gt;This book has not been approved by the Web Site 
      Users Association.&lt;/p&gt;
      &lt;/introduction&gt;
   &lt;part number="1"&gt;
      &lt;chapter&gt;
         &lt;title&gt;Planning then <phrase role="found">Conducting Usability</phrase> 
         <phrase role="found">Tests</phrase>&lt;/title&gt; 
         &lt;p&gt;Take the following steps to plan usability 
         testing. &lt;step number="1"&gt;Clarify and 
         articulate the goal of the usability testing.
         &lt;/step&gt; &lt;step number="2"&gt;Identify tasks which 
         are critical for users to be able to complete 
         successfully.&lt;/step&gt; &lt;step number="3"&gt;Compile 
         a script of questions or instructions which 
         will prompt the user to attempt those 
         tasks.&lt;/step&gt; &lt;step number="4"&gt;Identify your 
         users and begin recruiting them.&lt;/step&gt; &lt;step 
         number="5"&gt;Conduct a pretest on a few users.
         &lt;/step&gt; &lt;step number="6"&gt;Edit the script based 
         on insights gleaned from the pretest.&lt;/step&gt; 
         &lt;step number="7"&gt;Resume testing.&lt;/step&gt;&lt;/p&gt;
      &lt;/chapter&gt;
   &lt;/part&gt;
   &lt;part number="2"&gt;
      &lt;chapter&gt;
         &lt;title&gt;<phrase role="found">Conducting Usability Tests</phrase>&lt;/title&gt; 
         &lt;p&gt;Users can be tested at any computer 
         workstation &lt;footnote&gt;They may be more 
         comfortable at their own workstation than in 
         a lab.&lt;/footnote&gt; or in a lab.&lt;/p&gt;
         &lt;p&gt;Give the user the script, then assure them 
         that you are testing the Web site, not them. 
         Users are asked to verbalize their thoughts as 
         they complete the tasks. The event is recorded 
         or someone takes notes. It is often preferable 
         to have two testers, &lt;footnote&gt;Usability 
         testing can be done at great expense or on a 
         shoe string, using &lt;testingProcedure&gt;in-house 
         expertise&lt;/testingProcedure&gt; or 
         &lt;testingProcedure&gt;contracting with human 
         computer interaction professionals
         &lt;/testingProcedure&gt;.&lt;/footnote&gt; one to ask the 
         questions, another to take notes. Testers should 
         offer no guidance or comments to the user. Mouse 
         movements, typing, expressions, and the user's 
         words should be recorded.&lt;/p&gt;
      &lt;/chapter&gt;
      ...
   &lt;/part&gt;
&lt;/content&gt;</eg></div3></div2></div1></body><back><div1 id="Acknowledgements"><head>Acknowledgements</head><p>The editors thank the members of the Full Text Task Force of the XML Query and XSL Working Groups, which produced
the material in this document. Special thanks to Stephen Buxton for contributing the first version of the schema.</p><p>The editors thank the following staff at the Library of Congress for providing and improving
			sample data and queries: Ardith Bausenbach, Caroline Arms, Marla Banks, Susan David, Ray Denenberg,  
			Louis Drummond, Bohdan Kantor, Mary A. Lacy, Joe Pagano, Betsy Reifsnyder, Belinda D. Urquiza,
			and Anne Washington.</p><p>Thanks also to Bohdan Kantor, Foster Zhang, François Yergeau, and Michel Biezunski for assistance in translating the subjects in the sample data into Chinese and French.</p><p>The editors also wish to thank the members of the W3C Internationalization Working Group for their assistance.</p></div1><inform-div1 id="References"><head>References</head><div2 id="primary"><head>References (Primary)</head><p>The following references are some of the works considered by the
Working Groups in deriving its use cases. </p><blist><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xpath-functions" key="XQuery 1.0 and XPath 2.0 Functions and Operators (Second Edition)" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xml-infoset" key="XML Information Set (Second Edition)" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="Maier98" key="Maier98" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
<emph>
<loc href="http://www.w3.org/TandS/QL/QL98/pp/maier.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Database Desiderata for an XML Query Language</loc>, </emph>David Maier, 1998. In Query Languages 98 (QL'98). This paper is at http://www.w3.org/TandS/QL/QL98/pp/maier.html.</bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xml" key="Extensible Markup Language (XML) 1.0 (Fifth Edition)" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xmlschema-0" key="XML Schema Part 0: Primer Second Edition" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xmlschema-1" key="XML Schema Part 1: Structures Second Edition" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xmlschema-2" key="XML Schema Part 2: Datatypes Second Edition" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xquery" key="XQuery 1.0: An XML Query Language (Second Edition)" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xquery-use-cases" key="XML Query Use Cases" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xpath-full-text-10-requirements" key="XQuery and XPath Full Text 1.0 Requirements" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xpath-full-text-10" key="XQuery and XPath Full Text 1.0" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><!-- <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xpath-full-text-10" key="XQuery and XPath Full Text 1.0" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xpath-full-text-10-requirements" key="XQuery and XPath Full Text 1.0 Requirements" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/> --><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xpath20" key="XML Path Language (XPath) 2.0 (Second Edition)" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xslt20" key="XSL Transformations (XSLT) Version 2.0" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/></blist></div2><div2 id="background"><head>References (Background)</head><blist><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="BYR99" key="BYR99" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
<emph>Modern Information Retrieval, </emph>R.Baeza-Yates, B. Ribeiro-Neto. Addison Wesley, 1999.</bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="FGR01" key="FGR01" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
<emph>XIRQL: An Extension of XQL for Information Retrieval, </emph>N. Fuhr, K. Grossjohann.  Proceedings of SIGIR, 2001.</bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="HTK00" key="HTK00" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
<emph>Searching Text-Rich XML Documents with Relevance Ranking, </emph>Y. Hayashi, J. Tomita, G. Kikui. Proceedings of SIGIR Workshop on XML and Information Retrieval, 2000.</bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="MJK98" key="MJK98" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
<emph>A Flexible Model for Retrieval of SGML Documents, </emph>S. Myaeng, D.-H. Jang, M.-S. Kim, Z.-C. Zhoo.  Proceedings of SIGIR, 1998.</bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="SCH01" key="SCH01" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
<emph>Similarity Search in XML Data Using Cost-Based Query Transformations, </emph>T. Schlieder. Proceedings of SIGMOD WebDB Workshop, 2001.</bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="TWE00" key="TWE00" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
<emph>Adding Relevance to XML, </emph>A. Theobald and G. Weikum. Proceedings of SIGMOD WebDB Workshop, 2000.</bibl></blist></div2></inform-div1><inform-div1 id="ChangeLog"><head>Change Log</head><table border="0" summary="Change Log Table"><tbody><!-- Comment out rows documenting changes prior to first CR publication

<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2003-06-18</td>
<td rowspan="1" colspan="1">Added a Change Log</td>
<td rowspan="1" colspan="1"/>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2003-06-18</td>
<td rowspan="1" colspan="1">Statements of Functionality Illustrated by Query Modified</td>
<td rowspan="1" colspan="1">Added a Data Context to the Statement of Functionality Illustrated by Query for each query. Made XPath expressions in Query Context and Return relative to the XPath expression in Data Context.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Sihem Amer-Yahia</td>
<td rowspan="1" colspan="1">2003-06-18</td>
<td rowspan="1" colspan="1">Schema Modified</td>
<td rowspan="1" colspan="1">Replaced schema with a shorter one which defines more shared types.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Sihem Amer-Yahia</td>
<td rowspan="1" colspan="1">2003-06-18</td>
<td rowspan="1" colspan="1">New Use Cases Added</td>
<td rowspan="1" colspan="1">Added the following Use Cases: 3.2.11 Q11 Query on Entire Document, 14.2.11 Q11 Phrase Query Ignoring Explicit List of Tags and Content of Descendant Elements.              						</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2003-06-23</td>
<td rowspan="1" colspan="1">New Use Case Added</td>
<td rowspan="1" colspan="1">Added the following Use Case: 16.2.7 Q7 Query on Full Text Combined with Conditional on Date and Full Text.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2004-02-24</td>
<td rowspan="1" colspan="1">Solutions in XQuery Added</td>
<td rowspan="1" colspan="1">Added Solutions in XQuery authored by Full Text Task Force Members.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2004-02-24</td>
<td rowspan="1" colspan="1">Use Case Removed</td>
<td rowspan="1" colspan="1">Removed the following Use Case: 2.2.3 Q3 Single Phrase Query on Long Text Excerpt.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2004-02-24</td>
<td rowspan="1" colspan="1">Switched Use of Proximity and Distance</td>
<td rowspan="1" colspan="1">Proximity is now the broader term, distance (proximity counting intervening words) and window are the narrower terms.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2004-02-24</td>
<td rowspan="1" colspan="1">Added Definition of the Word "Tag"</td>
<td rowspan="1" colspan="1">Added definition of the word "tag" to the introduction to the Ignore Section (subsequently moved to the Across Element Boundaries Section).</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2004-03-15</td>
<td rowspan="1" colspan="1">Edited Solutions in XQuery</td>
<td rowspan="1" colspan="1">Made changes such as removing operators and unnecessary parentheses, made stopwords stop words, etc.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2004-03-15</td>
<td rowspan="1" colspan="1">Query Statements and Expected Results Changed</td>
<td rowspan="1" colspan="1">Made extensive changes to statements of query functionality and expected results to correlate with the new solutions.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2004-04-26</td>
<td rowspan="1" colspan="1">Use Cases Removed</td>
<td rowspan="1" colspan="1">Removed the following use cases: 3.2.1 Q1 Query on Element, 4.2.1 Q1 Query on Word Ignoring Single Stop Word, 4.2.3 Q3 Query on Phrase Word, 4.2.4 Q4 Query on Phrase Ignoring Multiple Stop Words, 4.2.5 Q5 Query on Phrase Overriding Multiple Stop Words, 6.2.3 Q3 Single Infix Character Wildcard Query, 6.2.5 Q5 0 or More Suffix Character Wildcard Query, 6.2.9 Q9 Word Wildcard Query, 6.2.10 Q10 Specified Range Word Wildcard Query, 9.2.2 Q2 Or Query on More Than Two Words, 9.2.3 Q3 Or Query on Phrases, 9.2.5 Q5 And Query on More Than Two Words, 9.2.6 Q6 And Query on Phrases, 10.2.3 Q3 Unordered Window Query, 10.2.5 Q5 Unordered Within a Sentence Query, 10.2.7 Q7 Unordered Within a Paragraph Query, 12.2.1 Q1 Multiple Word Query, 12.2.2 Q2 Phrase Word Query, 13.2.3 Q3 Query on Element and Its Descendants, 13.2.4 Q4 Query on Element and Its Parent, 13.2.7 Q7 Query on Element and Its Siblings, 13.2.8 Q8 Query on Same Element in Different Sub-Trees, 14.2.2 Q2 Query Ignoring !
 Tags Within Multiple Words, 14.2.4 Q4 Phrase Query Ignoring Explicit List of Tags of Descendant Elements, 14.2.8 Q8 Phrase Query Ignoring Tags and Content of Descendant Elements Identified by an XPath Query, 14.2.10 Q10 Distance Query Ignoring All Tags and Content of Descendant  Elements, 14.2.11 Q11 Phrase Query Ignoring Explicit List of Tags and Content of Descendant Elements.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2004-04-26</td>
<td rowspan="1" colspan="1">Reorganized sections, moved and reworked numerous use cases.</td>
<td rowspan="1" colspan="1">Removed the Querying Words and Phrases Section and the Advanced Word and Phrase Query Section. Added sections for Querying Across XML Element Boundaries, Querying on Attribute Values, and Querying Instances of Elements. Reorganized the sections so functionality is introduced before it is used. Revised titles of sections and titles of queries.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2004-04-26</td>
<td rowspan="1" colspan="1">Use Cases Added</td>
<td rowspan="1" colspan="1">Added the following Use Cases:13.2.6 Q6 Query Combining Score and XML Structure with a Conditional Return, 16.2.8 Q8 Query with an XQuery Expression Within the Full-Text Expression.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2004-04-26</td>
<td rowspan="1" colspan="1">&lt;authors&gt; Elements Removed</td>
<td rowspan="1" colspan="1">Removed the unnecessary &lt;authors&gt; elements from the sample data, schema, and use cases.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2004-04-26</td>
<td rowspan="1" colspan="1">Solutions in XPath Added</td>
<td rowspan="1" colspan="1">Added Solutions in XPath authored by Full Text Task Force Members.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2004-04-26</td>
<td rowspan="1" colspan="1">Query Statements and Expected Results Changed</td>
<td rowspan="1" colspan="1">Made extensive changes to statements of query functionality and expected results to correlate with the new solutions.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2004-05-19</td>
<td rowspan="1" colspan="1">Renamed and Reversed Order of Sections</td>
<td rowspan="1" colspan="1">The INSTANCE Section was renamed CARDINALITY. The COMPOSABILITY Section was renamed XQUERY-XPATH-COMPOSABILITY and the COMPLEX Section was renamed FULL-TEXT-COMPOSABILITY, and their order in the document was reversed.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2004-09-17</td>
<td rowspan="1" colspan="1">Removed Version Statements</td>
<td rowspan="1" colspan="1">Removed the "For consideration in v.1" and "For consideration after v.1 version" statements from the Statements of functionality illustrated by query.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2004-09-17</td>
<td rowspan="1" colspan="1">Changed queries</td>
<td rowspan="1" colspan="1">Changed query statements, solutions, and results based on implementer feedback and Task Force decisions in the following use cases: Use case 14.2.1. Q1 Distance Query Ignoring Content of All Descendant Elements (changed the element whose descendants are ignored to one with content; without content keywords must be followed by an Exp so to ignore all of the descendants added *), Use Case 16.2.8 Q8 Query with XQuery Expression Within Full-Text Expression (changed all to any), Use Case 10.2.5  Q5 And Not Query (added Book 3 as a result), Use Case 15.2.5 Q5 Query on Different Elements in Different Sub-Trees with Conditional Return (added an "s" to problems in a let statement, corrected the $i(s) to $in(s), corrected the book number on the result to 1), Use Case 16.2.4 Q4 Full-Text Query with Numeric Value Comparison (added missing curly brace in element constructor), Use Case 16.2.5 Q5 Full-Text Query with Character String Query (changed metadata for Book 3 and the query to look for Washington, D.C. to make the result valid), Use Case 16.2.8 Q8 Query with XQuery Expression Within Full-Text Expression (Changed the query statement to search the book short title, improved the query and the comment statement), Use Case 13.2.4 Q4 Query on Element and Its Right Siblings (improved query).</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2004-09-18</td>
<td rowspan="1" colspan="1">Added FTUnit to window function</td>
<td rowspan="1" colspan="1">Added the FTUnit "word" to query solutions using the window function.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2004-09-22</td>
<td rowspan="1" colspan="1">Changed query in XQUERY-XPATH-COMPOSABILITY Section</td>
<td rowspan="1" colspan="1">Changed query statements, solutions, and results based on implementer feedback and Task Force decisions in Use Case 16.2.8 Q8 Query with XQuery Expression Within Full-Text Expression. (made it search any document not only $book, collapsed where clauses).</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2005-01-17</td>
<td rowspan="1" colspan="1">Changed score functionality</td>
<td rowspan="1" colspan="1">Changed the score functions (ft:score) to score clauses in the SCORE Section.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2005-01-17</td>
<td rowspan="1" colspan="1">Removed use cases from CHARACTER Section</td>
<td rowspan="1" colspan="1">Removed 9.2.5 Query on Word with Special Character and 9.2.6 Query on Word with Special Character or Phrase with Space from the CHARACTER Section.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2005-01-17</td>
<td rowspan="1" colspan="1">Updated syntax</td>
<td rowspan="1" colspan="1">Updated the syntax for wildcards, stop words, starts-with, entire content, and thesauri.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2005-02-01</td>
<td rowspan="1" colspan="1">Added XPath example of score functionality</td>
<td rowspan="1" colspan="1">Added XPath example of score clauses in the SCORE Section Q3 Filtering on Scores.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2005-02-02</td>
<td rowspan="1" colspan="1">Removed explicit unordered</td>
<td rowspan="1" colspan="1">Removed the "unordered" keyword from unordered queries. The default is unordered; the presence of the "ordered" keyword overrides the default.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2005-02-10</td>
<td rowspan="1" colspan="1">Updated distance and window syntax</td>
<td rowspan="1" colspan="1">Updated distance queries removing the no longer acceptable "with" keyword. Updated window queries removing the no longer acceptable "within" keyword.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2005-03-09</td>
<td rowspan="1" colspan="1">Updated FTTimes syntax</td>
<td rowspan="1" colspan="1">Updated the FTTimes syntax from "at least 2 occurrences" to "occurs at least 2 times".</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2005-03-09</td>
<td rowspan="1" colspan="1">Added syntax for embedded XQuery</td>
<td rowspan="1" colspan="1">Added syntax (curly braces "{}") around XQuery expressions embedded in XQuery full-text expressions.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2005-03-09</td>
<td rowspan="1" colspan="1">Reformatted URLs in solutions</td>
<td rowspan="1" colspan="1">Reformatted URLs in solutions to enable automatic parsing.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2005-03-09</td>
<td rowspan="1" colspan="1">Updated thesaurus and stop words syntax</td>
<td rowspan="1" colspan="1">Updated thesaurus and stop words syntax to include the keyword "at" before URLs.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2005-08-08</td>
<td rowspan="1" colspan="1">Changed FTMildNegation syntax</td>
<td rowspan="1" colspan="1">Changed "mild not" to "not in" in 10.27 Q7 Mild Not Query Where Second Operand Is a Subset of the First Operand.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2005-08-25</td>
<td rowspan="1" colspan="1">Changed score syntax</td>
<td rowspan="1" colspan="1">Changed to new scoring syntaxes in Section 17. Use cases 1-4 illustrate scored queries returning the same results as a parallel pure Boolean full-text predicate query. 17.2.5 Q5 Query Returning All Books Ordered by Score illustrates a scored query returning more results than a parallel pure Boolean full-text predicate query.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2005-08-25</td>
<td rowspan="1" colspan="1">Corrected 15.2.4 Q4</td>
<td rowspan="1" colspan="1">Changed the title of 15.2.4 Q4 Distance and Boolean Queries Ignoring Content of a Descendant Element with Wildcards and Stemming to 15.2.4 Q4 Window Query with Wildcards and Stemming Ignoring Content of a Descendant Element. Rewrote the query.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2005-08-25</td>
<td rowspan="1" colspan="1">Changed window syntax</td>
<td rowspan="1" colspan="1">Changed to new window syntax, removing FTRange. Changed the syntax in 12.2.3 Q3 Ordered Window Query and 15.2.4 Q4 Window Query with Wildcards and Stemming Ignoring Content of a Descendant Element.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2006-01-06</td>
<td rowspan="1" colspan="1">Corrected operands</td>
<td rowspan="1" colspan="1">Corrected the operands in XQuery and XPath solutions to 3.2.6. Q6 Query on Entire Document.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2006-01-06</td>
<td rowspan="1" colspan="1">Added 3 new use cases</td>
<td rowspan="1" colspan="1">Added 8.2.3. Q3 Query Excluding a Stop Word on a Stop Word List, 6.2.9 Q9 Query Using an XQuery Expression to Determine the Number of Words Allowed in a Window, and 17.2.6. Query with Weight Declaration.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2006-01-06</td>
<td rowspan="1" colspan="1">Revised level by level ignore query</td>
<td rowspan="1" colspan="1">Revised 14.2.4. Q4 Distance Query Ignoring Content of Descendant Elements Level by Level.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2006-02-02</td>
<td rowspan="1" colspan="1">Changed use of curly braces</td>
<td rowspan="1" colspan="1">Changed the use of curly braces in 16.2.8. Q8 Query with XPath Expression Within Full-Text Expression to reflect Task Force decision that curly braces surround  XQuery expressions when they are within an FTContainsExpr where an FTSelection may occur (they are optional for literals).</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2006-11-17</td>
<td rowspan="1" colspan="1">Corrected operator</td>
<td rowspan="1" colspan="1">Corrected operator in Use Case 2.2.4 Q4 Query in Different Elements from an or to a union because it is operating on nodes.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2007-02-24</td>
<td rowspan="1" colspan="1">Changed syntax for and, or, not</td>
<td rowspan="1" colspan="1">Changed syntax for the full-text and, or, not operators from &amp;&amp;, ||, ! to ftand, ftor, ftnot.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2007-02-24</td>
<td rowspan="1" colspan="1">Moved ordered keywords</td>
<td rowspan="1" colspan="1">Moved ordered keywords before distance and window operators so ordered is processed before distance and window.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2007-09-24</td>
<td rowspan="1" colspan="1">Updated use cases with diacritics match options</td>
<td rowspan="1" colspan="1">Updated use cases with diacritics match options to use the 2 remaining diacritics options: diacritics sensitive and diacritics insensitive.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2007-09-24</td>
<td rowspan="1" colspan="1">Updated 16.2.9 Q9 Query Using an XQuery Expression to Determine the Number of Words Allowed in a Window</td>
<td rowspan="1" colspan="1">In 16.2.9 Q9 Query Using an XQuery Expression to Determine the Number of Words Allowed in a Window removed the FTRange that is no longer available in a window query.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2007-09-24</td>
<td rowspan="1" colspan="1">Updated sounds-like and spelled-like queries</td>
<td rowspan="1" colspan="1">Updated sounds-like and spelled-like queries to remove unnecessary "where count($cont)&gt;0" statements.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2007-09-24</td>
<td rowspan="1" colspan="1">Updated return statements</td>
<td rowspan="1" colspan="1">Updated return statements through the document, placing parentheses around return statements containing commas.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2007-09-24</td>
<td rowspan="1" colspan="1">Updated 16.2.7 Q7 Full-Text Query with Date Comparison and Element Occurrence Count</td>
<td rowspan="1" colspan="1">In 16.2.7 Q7 Full-Text Query with Date Comparison and Element Occurrence Count replaced $book with . where $book appeared in predicates.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2007-09-24</td>
<td rowspan="1" colspan="1">Updated 14.2.4 Q4 Distance Query Ignoring Content of Descendant Elements Level by Level</td>
<td rowspan="1" colspan="1">In 14.2.4 Q4 Distance Query Ignoring Content of Descendant Elements Level by Level corrected variable name.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2007-09-24</td>
<td rowspan="1" colspan="1">Updated 16.2.2 Q2 Full-Text Query Returning Count of Descendant Element Occurrences</td>
<td rowspan="1" colspan="1">In 16.2.2 Q2 Full-Text Query Returning Count of Descendant Element Occurrences corrected parentheses and brackets in the return statement.</td>
</tr>

<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2007-12-04</td>
<td rowspan="1" colspan="1">Title</td>
<td rowspan="1" colspan="1">Updated title and title references to remove 1.0, 2.0, and the hyphen.</td>
</tr>

<tr>
<td rowspan="1" colspan="1">Pat Case</td>
<td rowspan="1" colspan="1">2007-12-04</td>
<td rowspan="1" colspan="1">Removed Appendix C: Issues.</td>
<td rowspan="1" colspan="1">Removed Appendix C: Issues, transferring the only issue (testing the use cases for static errors) to Bugzilla.</td>
</tr>

--><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2008-07-10</td><td rowspan="1" colspan="1">Corrected 2.2.7 Q7 Entire Element Content Query</td><td rowspan="1" colspan="1">Added "with wildcards" to the XQuery and XPath solutions.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2008-07-10</td><td rowspan="1" colspan="1">Corrected 4.2.1 Q1 Query on Attribute</td><td rowspan="1" colspan="1">Moved "with stemming" to after "improve" and added parentheses around ("improve" with stemming ftand "web" ftand "usability") to make the distance operator applicable to all 3 operands in the XQuery and XPath solutions.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2008-07-10</td><td rowspan="1" colspan="1">Corrected 5.2.1 Q1 One Character Suffix Wildcard Query</td><td rowspan="1" colspan="1">Capitalized the "S" in "Solution in XQuery".</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2008-07-10</td><td rowspan="1" colspan="1">Corrected 16.2.9 Q9 Query Using an XQuery Expression to Determine the Number of Words Allowed in a Window</td><td rowspan="1" colspan="1">Changed the 2nd "for" to "let" in the XQuery solution.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2008-07-10</td><td rowspan="1" colspan="1">Corrected 17.2.4 Q4 Query Combining Score and XML Structure with a Conditional Return</td><td rowspan="1" colspan="1">Added the "local" prefix to 2 filter functional calls in the XQuery solution.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2008-07-14</td><td rowspan="1" colspan="1">Corrected 13.2.2 Q2 Query on Element Returning Its First Two Children</td><td rowspan="1" colspan="1">Corrected the let statement to read: let $para := $book//chapter/p[. ftcontains "usability" ftand "test" with stemming] in the XQuery solution.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2008-07-14</td><td rowspan="1" colspan="1">Corrected 13.2.4 Q4 Query on Element and Its Right Siblings</td><td rowspan="1" colspan="1">Changed the expected results to title and chapters.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2008-07-14</td><td rowspan="1" colspan="1">Corrected 16.2.4 Q4 Full-Text Query with Numeric Value Comparison</td><td rowspan="1" colspan="1">Removed duplicate books/book from the for clause in the XQuery solution.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2008-07-14</td><td rowspan="1" colspan="1">Corrected 15.2.4 Q4 Window Query with Wildcards and Stemming Ignoring Content of a Descendant Element</td><td rowspan="1" colspan="1">Removed count($au) &gt; 0 from and corrected window size to 0 in XQuery solution.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2008-07-14</td><td rowspan="1" colspan="1">Corrected 16.2.9 Q9 Query Using an XQuery Expression to Determine the Number of Words Allowed in a Window</td><td rowspan="1" colspan="1">Changed the for statement to a let statement in the XQuery solution. Also changed the ./contents/part/chapter paths in both the XQuery and XPath solutions to eliminate the incorrect contents (should be content) element.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2008-07-16</td><td rowspan="1" colspan="1">Corrected 11.2.2 Q2 Query in Any Instance of an Element (Existential Quantification)</td><td rowspan="1" colspan="1">Corrected use of $s1 and $s2 variables in the XQuery and XPath solutions.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2008-07-16</td><td rowspan="1" colspan="1">Corrected 13.2.3 Q3 Query on Element and Its Ancestors</td><td rowspan="1" colspan="1">Camel-cased element names and corrected the paths defining the variables in the XQuery and XPath solutions. Added a 2nd count clause in the XQuery solution. Corrected the Query Context.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2008-07-16</td><td rowspan="1" colspan="1">Corrected 16.2.7 Q7 Full-Text Query with Date Comparison and Element Occurrence Count</td><td rowspan="1" colspan="1">Added Book 3 to the expected results. Corrected the 2nd author's first name in Book 1 expected results.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2008-07-17</td><td rowspan="1" colspan="1">Corrected 5.2.5 Q5 Specified Range of Characters Suffix Wildcard Query</td><td rowspan="1" colspan="1">Removed a stray angle bracket from expected results.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2008-08-5</td><td rowspan="1" colspan="1">Corrected 5.2.3, 5.2.4, 5.2.5, and 6.2.2.</td><td rowspan="1" colspan="1">Corrected return statements and expected results in 5.2.3, 5.2.4, 5.2.5, and 6.2.2.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2008-08-11</td><td rowspan="1" colspan="1">Recorrected 4.2.1 Q1 Query on Attribute</td><td rowspan="1" colspan="1">Removed newly added parentheses around ("improve" with stemming ftand "web" ftand "usability"), trying to use only significant parentheses in the solutions.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2008-08-11</td><td rowspan="1" colspan="1">Corrected 3.2.6 Q6 Query on Entire Document</td><td rowspan="1" colspan="1">Corrected XQuery and XPath solutions to return all the book elements if the word was found in any one of them.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2008-08-19</td><td rowspan="1" colspan="1">Removed count &gt; 0 from most use cases.</td><td rowspan="1" colspan="1">Removed count &gt; 0 from XQuery and XPath (if any) solutions for use cases where it is no longer needed.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2008-08-19</td><td rowspan="1" colspan="1">Corrected 5.2.3, 5.2.4, 5.2.5, and 6.2.2 again.</td><td rowspan="1" colspan="1">Removed the fn: prefix from return statements in XQuery and XPath solutions for use cases 5.2.3, 5.2.4, 5.2.5, and 6.2.2.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2008-08-19</td><td rowspan="1" colspan="1">Removed or moved parentheses.</td><td rowspan="1" colspan="1">Removed or moved parentheses.to reflect changes in processing order for operators and match options in XQuery and XPath (if any) solutions for use cases 4.2.1, 10.2.6, 10.2.7, 11.2.3, 12.2.3, 12.2.4, 14.2.1, 14.2.3, 15.2.2, 15.2.4, 16.2.2, 16.2.5, 16.2.7, 17.2.6</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2008-08-19</td><td rowspan="1" colspan="1">Simplified queries by using a union in XPath statements.</td><td rowspan="1" colspan="1">Used union in XPath statements in XQuery and XPath solutions for use cases 2.2.4, 3.2.5, and 14.2.4.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2008-08-19</td><td rowspan="1" colspan="1">Changed text in Comments.</td><td rowspan="1" colspan="1">Changed the word "returns" to "finds" when it was more appropriate in Comments.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2008-08-20</td><td rowspan="1" colspan="1">Removed / in $book//content.</td><td rowspan="1" colspan="1">In XQuery solutions replaced $book//content with the simpler and more direct $book/content.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2008-08-20</td><td rowspan="1" colspan="1">Removed .// when unnecessary.</td><td rowspan="1" colspan="1">In XQuery and XPath solutions, replaced /books/book[.//content ... ] with /books/book[content ... ].</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2008-10-31</td><td rowspan="1" colspan="1">Corrected 3.2.5 Q5 Query in Different Sub-Trees.</td><td rowspan="1" colspan="1">Removed a stray "i" in 3.2.5 Q5 Query in Different Sub-Trees.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2008-11-05</td><td rowspan="1" colspan="1">Corrected 9.2.1 Q1 Diacritics Sensitive Query and 9.2.2 Q2 Diacritics Insensitive Query</td><td rowspan="1" colspan="1">Added ? wildcard indicators after the period indicator in the XQuery and XPath queries.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2008-11-10</td><td rowspan="1" colspan="1">5.2.3 Q3 Zero or More Character Infix Wildcard Query and 5.2.4 Q4 One or More Character Suffix Wildcard Query on Part of a Word</td><td rowspan="1" colspan="1">Added second parentheses at the end of the XQuery return statements for these queries.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2008-11-29</td><td rowspan="1" colspan="1">14.2.2 Q2 Phrase Query Ignoring Content of Descendant Element Specified by XPath Expression</td><td rowspan="1" colspan="1">Removed extraneous ] from XQuery solution.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2008-11-29</td><td rowspan="1" colspan="1">14.2.4 Q4 Distance Query Ignoring Content of Descendant Elements Level by Level</td><td rowspan="1" colspan="1">Added missing ) in XPath solution.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2008-11-29</td><td rowspan="1" colspan="1">16.2.9 Q9 Query Using an XQuery Expression to Determine the Number of Words Allowed in a Window</td><td rowspan="1" colspan="1">Removed extraneous ) after with stemming in XPath solution.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2008-11-29</td><td rowspan="1" colspan="1">12.2.5 Q5 Unordered Within a Paragraph Query</td><td rowspan="1" colspan="1">Added comment allowing no expected results.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2008-11-29</td><td rowspan="1" colspan="1">13.2.1 Q1 Query on Element and Its Children</td><td rowspan="1" colspan="1">Corrected expected results to include all p elements in Book 2.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2008-11-29</td><td rowspan="1" colspan="1">16.2.7 Q7 Full-Text Query with Date Comparison and Element Occurrence Count</td><td rowspan="1" colspan="1">Corrected query to return existing results.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2008-11-29</td><td rowspan="1" colspan="1">15.2.2 Q2 Phrase and Distance Query in an Instance of an Element with Stemming</td><td rowspan="1" colspan="1">Added parentheses before ftand.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2008-11-29</td><td rowspan="1" colspan="1">15.2.4 Q4 Window Query with Wildcards and Stemming Ignoring Content of a Descendant Element</td><td rowspan="1" colspan="1">Highlighted "comments"in expected results.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2009-01-15</td><td rowspan="1" colspan="1">17.2.2 Q2 Query Returning Results with Top Scores</td><td rowspan="1" colspan="1">Corrected syntax in query return statement adding {}s.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2009-01-15</td><td rowspan="1" colspan="1">13.2.4 Q4 Query on Element and Its Right Siblings</td><td rowspan="1" colspan="1">Corrected expected results to include all paragraphs.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2009-01-15</td><td rowspan="1" colspan="1">17.2.2 Q2 Query Returning Results with Top Scores</td><td rowspan="1" colspan="1">Corrected sort order to ascending.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2009-03-28</td><td rowspan="1" colspan="1">6.2.1 Q1 Query Stemming on Word Root</td><td rowspan="1" colspan="1">Removed highlighting on testers.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2009-03-28</td><td rowspan="1" colspan="1">6.2.2 Q2 Query Stemming on Multiple Word Roots</td><td rowspan="1" colspan="1">Changed the operand usable to usability and the operand use to users.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2009-03-28</td><td rowspan="1" colspan="1">15.2.2 Q2 Phrase and Distance Query in an Instance of an Element with Stemming</td><td rowspan="1" colspan="1">Changed the operand performance to performing and the operand review to reviewer.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2009-03-28</td><td rowspan="1" colspan="1">15.2.3 Q3 Nested Distance Query with Wildcards, Stemming, and Thesaurus Support</td><td rowspan="1" colspan="1">Changed the operand iterations to iterating.</td></tr><tr><td rowspan="1" colspan="1">Michael Dyck</td><td rowspan="1" colspan="1">2009-04-15</td><td rowspan="1" colspan="1">15.2.2 Q2 Phrase and Distance Query in an Instance of an Element with Stemming</td><td rowspan="1" colspan="1">Fix typo: missing right-bracket</td></tr><tr><td rowspan="1" colspan="1">Michael Dyck</td><td rowspan="1" colspan="1">2009-04-15</td><td rowspan="1" colspan="1">15.2.3 Q3 Nested Distance Query with Wildcards, Stemming, and Thesaurus Support</td><td rowspan="1" colspan="1">Fix syntax error: missing parens. Also, malformed wildcard syntax.</td></tr><tr><td rowspan="1" colspan="1">Michael Dyck</td><td rowspan="1" colspan="1">2009-04-15</td><td rowspan="1" colspan="1">16.2.7 Q7 Full-Text Query with Date Comparison and Element Occurrence Count</td><td rowspan="1" colspan="1">Fix syntax error: malformed WhereClause.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2009-04-16</td><td rowspan="1" colspan="1">15.2.5 Q5 Query on Different Elements in Different Sub-Trees with Conditional Return</td><td rowspan="1" colspan="1">Corrected the return statement.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2009-04-16</td><td rowspan="1" colspan="1">16.2.9 Q9 Query Using an XQuery Expression to Determine the Number of Words Allowed in a Window</td><td rowspan="1" colspan="1">Corrected query to return the desired result. Updated the Comments to address the revised query.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2009-05-20</td><td rowspan="1" colspan="1">17.2.6 Q6 Query with Weight Declaration</td><td rowspan="1" colspan="1">Moved a closing paren from after to before the weight expression. Added 2nd set of parens.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2009-06-09</td><td rowspan="1" colspan="1">15.2.3 Q3 Nested Distance Query with Wildcards, Stemming, and Thesaurus Support</td><td rowspan="1" colspan="1">Inserted comment noting that results depended on whether the wildcard or thesaurus match option was processed first.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2009-09-11</td><td rowspan="1" colspan="1">Changed syntax for Match Options</td><td rowspan="1" colspan="1">Changed "language" to "using language", changed "with wildcards" to "using wildcards", changed "with thesaurus at" to "using thesaurus at", changed "with stemming" to "using stemming",  changed "with stop words" to "using stop words", changed "without stop words" to "using no stop words", changed "case insensitive" to "using case insensitive", changed "uppercase" to "using uppercase", changed "diacritics sensitive" to "using diacritics sensitive", changed "diacritics insensitive" to "using diacritics insensitive".</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2009-09-22</td><td rowspan="1" colspan="1">Changed ftcontains to contains text</td><td rowspan="1" colspan="1">Changed ftcontains to contains text throughout the document.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2009-10-13</td><td rowspan="1" colspan="1">9.2.4 Q4 Query on Word with Upper Case and Lower Case Characters</td><td rowspan="1" colspan="1">Changed "case insensitive" to "using case insensitive" in the XPath query.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2009-10-13</td><td rowspan="1" colspan="1">14.2.3 Q3 Phrase Query Ignoring Content of Descendant Element Specified by Full-Text Query</td><td rowspan="1" colspan="1">Corrected the XQuery query to match the test suite.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2009-11-10</td><td rowspan="1" colspan="1">Introduction Item 3</td><td rowspan="1" colspan="1">Corrected the the spelling of wildcard.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2009-11-22</td><td rowspan="1" colspan="1">17.2.6 Query with weight declaration</td><td rowspan="1" colspan="1">Added curly braces around the weight.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">12-09-2009</td><td rowspan="1" colspan="1">14.2.3 Q3 Phrase Query Ignoring Content of Descendant Element Specified by Full-Text Query</td><td rowspan="1" colspan="1">Changed the path in the for clause in the XQuery and XPath solutions to provide context for the ignore paths.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">01-12-2010</td><td rowspan="1" colspan="1">14.2.1 Q1 Distance Query Ignoring Content of All Descendant Elements</td><td rowspan="1" colspan="1">Added a predicate to the let clause and got rid of unused variable in the XQuery solution.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">01-12-2010</td><td rowspan="1" colspan="1">14.2.4 Q4 Distance Query Ignoring Content of Descendant Elements Level by Level</td><td rowspan="1" colspan="1">Replaced the XQuery solution and added /. to the XPath solution.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">01-12-2010</td><td rowspan="1" colspan="1">15.2.4 Q4 Window Query with Wildcards and Stemming Ignoring Content of a Descendant Element</td><td rowspan="1" colspan="1">Replaced the "." in the ignore path with the $co variable to provide context, added parens around the ftor expressions, changed the ftnot expression to use the XQuery not, restored the expected result to Book 2.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">01-12-2010</td><td rowspan="1" colspan="1">17.2.6 Q6 Query with Weight Declaration</td><td rowspan="1" colspan="1">Added predicate to first let clause to return elements instead of a Boolean, specified descending, made weight greater than 1, added where $booktext clause.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">01-20-2010</td><td rowspan="1" colspan="1">17.2.1 Q1 Query Returning Scores</td><td rowspan="1" colspan="1">Removed comma in the return statement..</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">01-20-2010</td><td rowspan="1" colspan="1">14.2.2 Q2 Phrase Query Ignoring Content of Descendant Element Specified by XPath Expression</td><td rowspan="1" colspan="1">Added a predicate to the let clause and a where clause in the XQuery solution. Replaced the XPath solution.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">03-18-2010</td><td rowspan="1" colspan="1">14.2.3 Q3 Phrase Query Ignoring Content of Descendant Element Specified by Full-Text Query</td><td rowspan="1" colspan="1">Added an asterisk to the wildcard match options in the XQuery and XPath solutions. Specified the variable in the ignore option in the XQuery solution.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">12-29-2010</td><td rowspan="1" colspan="1">7.2.2 Q2 Query on Narrower Terms Identified by a Thesaurus</td><td rowspan="1" colspan="1">Changed the thesaurus relationship from "narrower terms" to "narrower term" in both solutions.</td></tr></tbody></table></inform-div1></back></spec>
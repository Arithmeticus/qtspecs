<!--XSLT Processor: SAXON 9.3.0.5 from Saxonica SAXON EE 9.3.0.5--><!--

1. Get rid of the "might add or delete use cases" stuff from status
2. DONE: Use an updated Meltonesque status section
3. Static typing

--><spec id="spec-top" w3c-doctype="wgnote"><header id="spec-header"><title>XQuery 3.0 Use Cases</title><w3c-designation>NOTE-xquery-30-use-cases</w3c-designation><w3c-doctype>W3C Working Group Note</w3c-doctype><pubdate><day>08</day><month>April</month><year>2014</year></pubdate><publoc>
			<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2014/NOTE-xquery-30-use-cases-20140408/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2014/NOTE-xquery-30-use-cases-20140408/</loc>
		</publoc><altlocs><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="xquery-30-use-cases.xml" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML</loc></altlocs><latestloc>
			<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/xquery-30-use-cases/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xquery-30-use-cases/</loc>
		</latestloc><prevlocs>
			<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2013/WD-xquery-30-use-cases-20130108/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2013/WD-xquery-30-use-cases-20130108/</loc>,
			<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2012/WD-xquery-30-use-cases-20120327/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2012/WD-xquery-30-use-cases-20120327/</loc>,
      <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2010/WD-xquery-30-use-cases-20101214/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2010/WD-xquery-30-use-cases-20101214/</loc>,
      <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2008/WD-xquery-11-use-cases-20081203/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2008/WD-xquery-11-use-cases-20081203/</loc>,
      <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2008/WD-xquery-11-use-cases-20080711/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2008/WD-xquery-11-use-cases-20080711/</loc>
		</prevlocs><authlist><author><name>Jonathan Robie</name><affiliation>EMC Corporation</affiliation><email xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:jonathan.robie@emc.com" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">jonathan.robie@emc.com</email></author><author><name>Tim Kraska</name><affiliation>FLWOR Foundation</affiliation><email xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:tim@flworfound.org" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">tim@flworfound.org</email></author></authlist><!--* Common status section for QT specs.
    * Use is currently not required, but it simplifies things.
    * 
    * Revisions:
    * 2007-01-15 : CMSMcQ : made file, to simplify publication of Rec.
    * 2008-02-15 : JimMelton : cloned from MSM's REC-only material
                     to generalize for all stages
    *--><status id="status"><!-- ************************************************************************** --><!-- * All Status sections must start with the standard boilerplate paragraph * --><!-- *   This entity is defined in status-entities.dtd                        * --><!-- ************************************************************************** --><p><emph>This section describes the status of this
         document at the time of its publication.
         Other documents may supersede this document.
         A list of current W3C publications and the latest
         revision of this technical report can be found in the
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">W3C technical reports index</loc>
         at http://www.w3.org/TR/.</emph></p><!-- ************************************************************************** --><!-- * QT publishes suites of documents, which must be described in the       * --><!--     Status section of each document within such a suite.                 * --><!-- *   This entity is defined in the host document.                         * --><!-- ************************************************************************** --><!-- ************************************************************************** --><!-- * There is a lot of detailed customization based on the document stage   * --><!-- *   This entity is defined in the host document.                         * --><!-- ************************************************************************** --><p>This is a <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2005/10/Process-20051014/tr.html#tr-end" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Working Group Note</loc> as described in the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2005/10/Process-20051014/tr.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Process Document</loc>. 
It was developed by the W3C <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/Query/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML Query Working Group</loc>,
which is part of the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/Activity" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML Activity</loc>.
</p><!-- ************************************************************************** --><!-- * CR documents must cite features at risk                                * --><!-- *   This entity is defined in the host document.                         * --><!-- ************************************************************************** --><!-- ************************************************************************** --><!-- * Every Status section must have a customized paragraph                  * --><!-- *   This entity is defined completely in the host document.              * --><!-- ************************************************************************** --><p>This document provides
a number of use cases designed to evaluate XQuery 3.0, the requirements for which
are specified in <bibref ref="xquery-30-requirements"/>.</p><!-- ************************************************************************** --><!-- * CR docs should, and PR docs must, have a pointer to an implementation  * --><!-- *   report.  We also want to point to the test suite.                    * --><!-- *   This entity is defined in the host document.                         * --><!-- ************************************************************************** --><!-- ************************************************************************** --><!-- * The Status section should point to a changelog                         * --><!-- *   This entity is defined in the host document.                         * --><!-- ************************************************************************** --><p>This document incorporates changes made against the previous publication
  of the Working Draft.
  Changes to this document since the previous publication of the Working Draft
  are detailed in <specref ref="ChangeLog"/>.</p><!-- ************************************************************************** --><!-- * The Status section must tell readers where to send comments            * --><!-- *   This entity is defined in status-entities.dtd                        * --><!-- ************************************************************************** --><p>Please report errors in this document using W3C's
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public Bugzilla system</loc>
         (instructions can be found at
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/2005/04/qt-bugzilla" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/XML/2005/04/qt-bugzilla</loc>).
         If access to that system is not feasible, you may send your comments
         to the W3C XSLT/XPath/XQuery public comments mailing list,
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:public-qt-comments@w3.org" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public-qt-comments@w3.org</loc>.
         It will be very helpful if you include the string 
         “[XQuery30UC]”
         in the subject line of your report, whether made in Bugzilla or in email.
         Please use multiple Bugzilla entries (or, if necessary, multiple email messages)
         if you have more than one comment to make.
         Archives of the comments and responses are available at
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://lists.w3.org/Archives/Public/public-qt-comments/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://lists.w3.org/Archives/Public/public-qt-comments/</loc>. </p><!-- ************************************************************************** --><!-- Status sections must state the stability (not stable, or REC) of the document --><!-- *   This entity is defined in the host document.                         * --><!-- ************************************************************************** --><p>Publication as a <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2005/10/Process-20051014/tr.html#tr-end" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Working Group Note</loc>
does not imply endorsement by the W3C Membership. 
This is a draft document and may be updated, replaced or obsoleted
by other documents at any time. 
It is inappropriate to cite this document as other than work in progress.</p><!-- ************************************************************************** --><!-- * Finally, all Status sections must end with the appropriate IPR para    * --><!-- *   This entity is defined in status-entities.dtd                        * --><!-- ************************************************************************** --><p>This document was produced by a group operating under the
  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Consortium/Patent-Policy-20040205/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">5 February 2004
  W3C Patent Policy</loc>.
<!--
  The group does not expect this document to become a W3C Recommendation.
-->
  W3C maintains a 
  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2004/01/pp-impl/18797/status#disclosures" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public list of any patent disclosures</loc>
  made in connection with the deliverables of the group; 
  that page also includes instructions for disclosing a patent.
  An individual who has actual knowledge of a patent 
  which the individual believes contains
  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Essential Claim(s)</loc>
  must disclose the information in accordance with
  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
  section 6 of the W3C Patent Policy</loc>. </p></status><abstract><p>This document specifies usage scenarios for XML Query (XQuery) 3.0.</p></abstract><langusage><language id="EN">English</language></langusage><revisiondesc><p>TK, 30 January 2008: Addes first group-by and windowing UC.</p></revisiondesc></header><body><div1 id="ucforxq30"><head>Use Cases for XML Query 3.0</head><p>The use cases listed below were created by the XML Query Working Group to illustrate
                important applications for the new features in XQuery 3.0. Each use case is focused on a
                specific application area, and contains a XML Schema and example
                input data. Each use case specifies a set of queries that might be applied to the
                input data, and the expected results for each query. Since the English description
                of each query is concise, the expected results form an important part of the
                definition of each query, specifying the expected output format. </p><p>Most of the listed use cases are based on a simple shopping scenario described in section
			    <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#data" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Schema and Data</loc>.
          Use cases which require special data have a seperate subsection describing
			    the XML Schema and input data.
                All use cases assume that input is provided in the form of
                one or more documents with specific names. For instance, the products in a document
                may be accessed with expressions like this:</p><eg xml:space="preserve">doc("products.xml")//product</eg><p>Several implementors have asked us to make the queries from these use cases
                available in a separate file in order to make it easier for them to test their parsers. These
                queries may be found in <bibref ref="UseCaseQueries"/>
			</p><!--                Also, the queries from the XQuery specification itself have been made available in <bibref ref="XQueryQueries"/>. --><p>To make output more readable, the output of queries has been formatted using
                whitespace which may not be returned by a query processor. This whitespace should
                not be considered normative for the correctness of results.</p><p>These queries were tested with a dynamic implementation of XQuery. Some queries may
                require additional type declarations to be used with an implementation that
                implements the Static Typing feature. </p></div1><div1 id="data"><head>Shopping Scenario: Schema and Data</head><p>If not stated otherwise all use cases in this document are based on a simplified shopping scenario containing three documents. The first document, products.xml, contains a list of products, whereas stores.xml includes a list of stores, and sales-records.xml contains the list of sales.</p><div2 id="dtdproducts"><head>Schema</head><p>The document product.xml uses the following XML Schema:</p><eg role="schema" xml:space="preserve">&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
    &lt;xs:element name="products"&gt;
        &lt;xs:complexType&gt;
            &lt;xs:sequence&gt;
                &lt;xs:element name="product" maxOccurs="unbounded"&gt;
                    &lt;xs:complexType&gt;
                        &lt;xs:sequence&gt;
                            &lt;xs:element name="name" type="xs:string"/&gt;
                            &lt;xs:element name="category" type="xs:string"/&gt;
                            &lt;xs:element name="price" type="xs:double"/&gt;
                            &lt;xs:element name="cost" type="xs:double"/&gt;
                        &lt;/xs:sequence&gt;
                    &lt;/xs:complexType&gt;
                &lt;/xs:element&gt;
            &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
    &lt;/xs:element&gt;
&lt;/xs:schema&gt;
</eg><p>The sales-records.xml document follows this XML Schema:</p><eg role="schema" xml:space="preserve">&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
    &lt;xs:element name="sales"&gt;
        &lt;xs:complexType&gt;
            &lt;xs:sequence&gt;
                &lt;xs:element name="record" maxOccurs="unbounded"&gt;
                    &lt;xs:complexType&gt;
                        &lt;xs:sequence&gt;
                            &lt;xs:element name="product-name" type="xs:string"/&gt;
                            &lt;xs:element name="store-number" type="xs:integer"/&gt;
                            &lt;xs:element name="qty" type="xs:integer"/&gt;
                        &lt;/xs:sequence&gt;
                    &lt;/xs:complexType&gt;
                &lt;/xs:element&gt;
            &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
    &lt;/xs:element&gt;
&lt;/xs:schema&gt;
</eg><p>The stores.xml document is valid to this XML Schema:</p><eg role="schema" xml:space="preserve">&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
    &lt;xs:element name="stores"&gt;
        &lt;xs:complexType&gt;
            &lt;xs:sequence&gt;
                &lt;xs:element name="store" maxOccurs="unbounded"&gt;
                    &lt;xs:complexType&gt;
                        &lt;xs:sequence&gt;
                            &lt;xs:element name="store-number" type="xs:byte"/&gt;
                            &lt;xs:element name="state" type="xs:string"/&gt;
                        &lt;/xs:sequence&gt;
                    &lt;/xs:complexType&gt;
                &lt;/xs:element&gt;
            &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
    &lt;/xs:element&gt;
&lt;/xs:schema&gt;
</eg></div2><div2 id="dataproducts"><head>Sample Data</head><p>The content of the document products.xml is:</p><eg role="data" xml:space="preserve">&lt;products&gt;
  &lt;product&gt;
    &lt;name&gt;broiler&lt;/name&gt;
    &lt;category&gt;kitchen&lt;/category&gt;
    &lt;price&gt;100&lt;/price&gt;
    &lt;cost&gt;70&lt;/cost&gt;
  &lt;/product&gt;
  &lt;product&gt;
    &lt;name&gt;toaster&lt;/name&gt;
    &lt;category&gt;kitchen&lt;/category&gt;
    &lt;price&gt;30&lt;/price&gt;
    &lt;cost&gt;10&lt;/cost&gt;
  &lt;/product&gt;
  &lt;product&gt;
    &lt;name&gt;blender&lt;/name&gt;
    &lt;category&gt;kitchen&lt;/category&gt;
    &lt;price&gt;50&lt;/price&gt;
    &lt;cost&gt;25&lt;/cost&gt;
  &lt;/product&gt;
  &lt;product&gt;
    &lt;name&gt;socks&lt;/name&gt;
    &lt;category&gt;clothes&lt;/category&gt;
    &lt;price&gt;5&lt;/price&gt;
    &lt;cost&gt;2&lt;/cost&gt;
  &lt;/product&gt;
  &lt;product&gt;
    &lt;name&gt;shirt&lt;/name&gt;
    &lt;category&gt;clothes&lt;/category&gt;
    &lt;price&gt;10&lt;/price&gt;
    &lt;cost&gt;3&lt;/cost&gt;
  &lt;/product&gt;
&lt;/products&gt;
</eg><p>The content of sales-records.xml is:</p><eg role="data" xml:space="preserve">&lt;sales&gt;
  &lt;record&gt;
    &lt;product-name&gt;broiler&lt;/product-name&gt;
    &lt;store-number&gt;1&lt;/store-number&gt;
    &lt;qty&gt;20&lt;/qty&gt;
  &lt;/record&gt;
  &lt;record&gt;
    &lt;product-name&gt;toaster&lt;/product-name&gt;
    &lt;store-number&gt;2&lt;/store-number&gt;
    &lt;qty&gt;100&lt;/qty&gt;
  &lt;/record&gt;
  &lt;record&gt;
    &lt;product-name&gt;toaster&lt;/product-name&gt;
    &lt;store-number&gt;2&lt;/store-number&gt;
    &lt;qty&gt;50&lt;/qty&gt;
  &lt;/record&gt;
  &lt;record&gt;
    &lt;product-name&gt;toaster&lt;/product-name&gt;
    &lt;store-number&gt;3&lt;/store-number&gt;
    &lt;qty&gt;50&lt;/qty&gt;
  &lt;/record&gt;
  &lt;record&gt;
    &lt;product-name&gt;blender&lt;/product-name&gt;
    &lt;store-number&gt;3&lt;/store-number&gt;
    &lt;qty&gt;100&lt;/qty&gt;
  &lt;/record&gt;
  &lt;record&gt;
    &lt;product-name&gt;blender&lt;/product-name&gt;
    &lt;store-number&gt;3&lt;/store-number&gt;
    &lt;qty&gt;150&lt;/qty&gt;
  &lt;/record&gt;
  &lt;record&gt;
    &lt;product-name&gt;socks&lt;/product-name&gt;
    &lt;store-number&gt;1&lt;/store-number&gt;
    &lt;qty&gt;500&lt;/qty&gt;
  &lt;/record&gt;
  &lt;record&gt;
    &lt;product-name&gt;socks&lt;/product-name&gt;
    &lt;store-number&gt;2&lt;/store-number&gt;
    &lt;qty&gt;10&lt;/qty&gt;
  &lt;/record&gt;
  &lt;record&gt;
    &lt;product-name&gt;shirt&lt;/product-name&gt;
    &lt;store-number&gt;3&lt;/store-number&gt;
    &lt;qty&gt;10&lt;/qty&gt;
  &lt;/record&gt;
&lt;/sales&gt;
</eg><p>The content of stores.xml is:</p><eg role="data" xml:space="preserve">&lt;stores&gt;
  &lt;store&gt;
    &lt;store-number&gt;1&lt;/store-number&gt;
    &lt;state&gt;CA&lt;/state&gt;
  &lt;/store&gt;
  &lt;store&gt;
    &lt;store-number&gt;2&lt;/store-number&gt;
    &lt;state&gt;CA&lt;/state&gt;
  &lt;/store&gt;
  &lt;store&gt;
    &lt;store-number&gt;3&lt;/store-number&gt;
    &lt;state&gt;MA&lt;/state&gt;
  &lt;/store&gt;
  &lt;store&gt;
    &lt;store-number&gt;4&lt;/store-number&gt;
    &lt;state&gt;WA&lt;/state&gt;
  &lt;/store&gt;
&lt;/stores&gt;
</eg></div2></div1><!-- QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ --><!--######################################    Simplified FLWOR       ################################ --><!-- QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ --><!-- ############################ UC windowing_Q3_transaction_time ################################## --><!-- Do we really want to have the Simplified FLWOR UC???
		<div1 id="simplified-flwor-queries-results">
				<head>Use Case "Simplified FLWOR"</head>
				<p>This use cases demonstrate how the simplified FLWOR grammar can help to simplify queries and easier to write according to the requirements. </p>

								<div2 id="simplified-flwor-2">
					<head>Q1</head>
					<p>Order all books according to their title and return only those which have more than one author. </p>
					<p>
						<emph>Solution in XQuery:</emph>
					</p>
					<eg role="xquery"><![CDATA[<result>{
    for $book in doc("mydoc.xml")/bib/book
    order by $book/title
    let $number-authors := count($book/author)
    where $number-authors > 1
    return
       <book name="{$book/title}" number-authors="{$number-authors}"/>
}</result>]]></eg>
					<p>
						<emph>Expected Result:</emph>
					</p>
					<eg role="result"><![CDATA[<result>
    <book name="Querying XML" number-authors="2"/>
    <book name="SQL:1999" number-authors="2"/>
    <book name="Understanding SQL and Java Together" number-authors="2"/>
</result>
					]]></eg>
				</div2>
			<div2 id="simplified-flwor-1">
					<head>Q2</head>
					<p>Show the turnover for every store and product. The solution demonstrates how the FLWOR syntax got simplified in regard to the clause order. </p>
					<p>
						<emph>Solution in XQuery:</emph>
					</p>
					<eg role="xquery"><![CDATA[<sales>{
    for $sales in doc("sales-records.xml")/*/record
    for $product in doc("products.xml")/*/product
    where $product/name eq $sales/product-name
    for $store in doc("stores.xml")/*/store
    where $store/store-number eq $sales/store-number
    let $sum := $product/price * $sales/qty
    order by $product/name,$sum
    return
        <sale product="{$product/name}" store="{$store/state}" price="{$product/price}" qty="{$sales/qty}" turnover="{$sum}"/>
}</sales>]]></eg>
					<p>
						<emph>Expected Result:</emph>
					</p>
					<eg role="result"><![CDATA[<sales>
    <sale product="blender" store="MA" price="50" qty="100" turnover="5000"/>
    <sale product="blender" store="MA" price="50" qty="150" turnover="7500"/>
    <sale product="broiler" store="CA" price="100" qty="20" turnover="2000"/>
    <sale product="shirt" store="MA" price="10" qty="10" turnover="100"/>
    <sale product="socks" store="CA" price="5" qty="10" turnover="50"/>
    <sale product="socks" store="CA" price="5" qty="500" turnover="2500"/>
    <sale product="toaster" store="CA" price="30" qty="50" turnover="1500"/>
    <sale product="toaster" store="MA" price="30" qty="50" turnover="1500"/>
    <sale product="toaster" store="CA" price="30" qty="100" turnover="3000"/>
</sales>]]></eg>
				</div2>
		</div1>
--><!-- EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE --><!--######################################     Generalized FLWOR     ##################### --><!-- EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE --><div1 id="groupby"><head>Use Case "Group By" - Queries which require value-based grouping</head><p>This use case contains several sample queries in which value based grouping is needed. </p><!--###################################### DATA books ############################ --><div2 id="update30-groupby-schema-and-sample-data"><head>Schema and Sample Data</head><p>Queries 1-6 are based on a simplified shop scenario with products, sales records and different shop locations. The schema and data can be found in section <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#data" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Schema and Data</loc>. Queries 7 and 8 are based on a bibliography document shown below:</p><div3 id="dtdbooks"><head>Schema Q7-Q8</head><p>Q7 and Q8 use an input document named "books.xml", with the following XML Schema:</p><eg role="schema" xml:space="preserve">&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
    &lt;xs:element name="bib"&gt;
        &lt;xs:complexType&gt;
            &lt;xs:sequence&gt;
                &lt;xs:element name="book" maxOccurs="unbounded"&gt;
                    &lt;xs:complexType&gt;
                        &lt;xs:sequence&gt;
                            &lt;xs:element name="author" type="xs:string" maxOccurs="unbounded"/&gt;
                            &lt;xs:element name="title" type="xs:string"/&gt;
                        &lt;/xs:sequence&gt;
                    &lt;/xs:complexType&gt;
                &lt;/xs:element&gt;
            &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
    &lt;/xs:element&gt;
&lt;/xs:schema&gt;
</eg></div3><div3 id="databooks"><head>Sample Data Q7-Q8</head><p>Here are the contents of books.xml:</p><eg role="data" xml:space="preserve">&lt;bib&gt;
  &lt;book&gt;
    &lt;author&gt;Jim Melton&lt;/author&gt;
    &lt;author&gt;Alan Simon&lt;/author&gt;
    &lt;title&gt;SQL:1999&lt;/title&gt;
  &lt;/book&gt;
  &lt;book&gt;
    &lt;author&gt;Jim Melton&lt;/author&gt;
    &lt;title&gt;Advanced SQL:1999&lt;/title&gt;
  &lt;/book&gt;
  &lt;book&gt;
    &lt;author&gt;Alan Simon&lt;/author&gt;
    &lt;title&gt;Strategic Database Technology&lt;/title&gt;
  &lt;/book&gt;
  &lt;book&gt;
    &lt;author&gt;Jim Melton&lt;/author&gt;
    &lt;author&gt;Andrew Eisenberg&lt;/author&gt;
    &lt;title&gt;Understanding SQL and Java Together&lt;/title&gt;
  &lt;/book&gt;
  &lt;book&gt;
    &lt;author&gt;Jim Melton&lt;/author&gt;
    &lt;author&gt;Stephen Buxton&lt;/author&gt;
    &lt;title&gt;Querying XML&lt;/title&gt;
  &lt;/book&gt;
&lt;/bib&gt;
</eg></div3></div2><!-- QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ --><!--######################################    DATA groupby     ################################ --><!-- QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ --><div2 id="groupby-queries-results"><head>Queries and Results</head><!-- ############################ UC groupby_q1 ################################## --><div3 id="groupby_q1"><head>Q1</head><p>Group sales by product, list name and total quantity of each product. </p><p>
						<emph>Solution in XQuery:</emph>
					</p><eg role="xquery" xml:space="preserve">&lt;sales-qty-by-product&gt;{
  for $sales in doc("sales-records.xml")/*/record
  let $pname := $sales/product-name
  group by $pname
  order by $pname
  return
    &lt;product name="{$pname}"&gt;{
      sum($sales/qty)
    }&lt;/product&gt;
}&lt;/sales-qty-by-product&gt; </eg><p>
						<emph>Expected Result:</emph>
					</p><eg role="result" xml:space="preserve">&lt;sales-qty-by-product&gt;
  &lt;product name="blender"&gt;250&lt;/product&gt;
  &lt;product name="broiler"&gt;20&lt;/product&gt;
  &lt;product name="shirt"&gt;10&lt;/product&gt;
  &lt;product name="socks"&gt;510&lt;/product&gt;
  &lt;product name="toaster"&gt;200&lt;/product&gt;
&lt;/sales-qty-by-product&gt;
</eg></div3><!-- ############################ UC groupby_q2 ################################## --><div3 id="groupby_q2"><head>Q2</head><p>Group sales by state (a property of the store) and category (a property
of the product). Order groups by the grouping keys. For each group,
show the total quantity sold. </p><p>
						<emph>Solution in XQuery:</emph>
					</p><eg role="xquery" xml:space="preserve">&lt;result&gt;{
  for $sales in doc("sales-records.xml")/*/record
  let $state := doc("stores.xml")/*/store[store-number = $sales/store-number]/state
  let $category := doc("products.xml")/*/product[name = $sales/product-name]/category
  group by $state, $category
  order by $state, $category
  return
    &lt;group&gt;
      &lt;state&gt;{$state}&lt;/state&gt;
      &lt;category&gt;{$category}&lt;/category&gt;
      &lt;total-qty&gt;{sum($sales/qty)}&lt;/total-qty&gt;
    &lt;/group&gt;
}&lt;/result&gt;</eg><p>
						<emph>Expected Result:</emph>
					</p><eg role="result" xml:space="preserve">&lt;result&gt;
  &lt;group&gt;
    &lt;state&gt;CA&lt;/state&gt;
    &lt;category&gt;clothes&lt;/category&gt;
    &lt;total-qty&gt;510&lt;/total-qty&gt;
  &lt;/group&gt;
  &lt;group&gt;
    &lt;state&gt;CA&lt;/state&gt;
    &lt;category&gt;kitchen&lt;/category&gt;
    &lt;total-qty&gt;170&lt;/total-qty&gt;
  &lt;/group&gt;
  &lt;group&gt;
    &lt;state&gt;MA&lt;/state&gt;
    &lt;category&gt;clothes&lt;/category&gt;
    &lt;total-qty&gt;10&lt;/total-qty&gt;
  &lt;/group&gt;
  &lt;group&gt;
    &lt;state&gt;MA&lt;/state&gt;
    &lt;category&gt;kitchen&lt;/category&gt;
    &lt;total-qty&gt;300&lt;/total-qty&gt;
  &lt;/group&gt;
&lt;/result&gt;
</eg></div3><!-- ############################ UC groupby_q3 ################################## --><div3 id="groupby_q3"><head>Q3</head><p>Group sales by state (a property of the store) and category (a property
of the product). Order groups by the grouping keys. For each group,
show the total revenue (defined as sales/qty * product/price). </p><p>
						<emph>Solution in XQuery:</emph>
					</p><eg role="xquery" xml:space="preserve">&lt;result&gt;{
  for $sales in doc("sales-records.xml")/*/record
  let $state := doc("stores.xml")/*/store[store-number = $sales/store-number]/state,
    $product := doc("products.xml")/*/product[name = $sales/product-name],
    $category := $product/category,
    $revenue := $sales/qty * $product/price
  group by $state, $category
  order by $state, $category
  return
    &lt;group&gt;
      &lt;state&gt;{$state}&lt;/state&gt;
      &lt;category&gt;{$category}&lt;/category&gt;
      &lt;total-revenue&gt;{sum($revenue)}&lt;/total-revenue&gt;
    &lt;/group&gt;
}&lt;/result&gt;</eg><p>
						<emph>Expected Result:</emph>
					</p><eg role="result" xml:space="preserve">&lt;result&gt;
  &lt;group&gt;
    &lt;state&gt;CA&lt;/state&gt;
    &lt;category&gt;clothes&lt;/category&gt;
    &lt;total-revenue&gt;2550&lt;/total-revenue&gt;
  &lt;/group&gt;
  &lt;group&gt;
    &lt;state&gt;CA&lt;/state&gt;
    &lt;category&gt;kitchen&lt;/category&gt;
    &lt;total-revenue&gt;6500&lt;/total-revenue&gt;
  &lt;/group&gt;
  &lt;group&gt;
    &lt;state&gt;MA&lt;/state&gt;
    &lt;category&gt;clothes&lt;/category&gt;
    &lt;total-revenue&gt;100&lt;/total-revenue&gt;
  &lt;/group&gt;
  &lt;group&gt;
    &lt;state&gt;MA&lt;/state&gt;
    &lt;category&gt;kitchen&lt;/category&gt;
    &lt;total-revenue&gt;14000&lt;/total-revenue&gt;
  &lt;/group&gt;
&lt;/result&gt;
</eg></div3><!-- ############################ UC groupby_q4 ################################## --><div3 id="groupby_q4"><head>Q4</head><p>Combine the input documents into a three-level hierarchy based on
state, category, and product. At the product level, show the total
quantity sold of each product. List items alphabetically at each
level of the hierarchy. </p><p>
						<emph>Solution in XQuery:</emph>
					</p><eg role="xquery" xml:space="preserve">&lt;result&gt;{
  for $store in doc("stores.xml")/*/store
  let $state := $store/state
  group by $state
  order by $state
  return
    &lt;state name="{$state}"&gt;{
      for $product in doc("products.xml")/*/product
      let $category := $product/category
      group by $category
      order by $category
      return
        &lt;category name="{$category}"&gt;{
          for $sales in doc("sales-records.xml")/*/record[store-number = $store/store-number
            and product-name = $product/name]
          let $pname := $sales/product-name
          group by $pname
          order by $pname
          return
            &lt;product name="{$pname}" total-qty="{sum($sales/qty)}" /&gt;
          }&lt;/category&gt;
    }&lt;/state&gt;
}&lt;/result&gt;</eg><p>
						<emph>Expected Result:</emph>
					</p><eg role="result" xml:space="preserve">&lt;result&gt;
  &lt;state name="CA"&gt;
    &lt;category name="clothes"&gt;
      &lt;product name="socks" total-qty="510"/&gt;
    &lt;/category&gt;
    &lt;category name="kitchen"&gt;
      &lt;product name="broiler" total-qty="20"/&gt;
      &lt;product name="toaster" total-qty="150"/&gt;
    &lt;/category&gt;
  &lt;/state&gt;
  &lt;state name="MA"&gt;
    &lt;category name="clothes"&gt;
      &lt;product name="shirt" total-qty="10"/&gt;
    &lt;/category&gt;
    &lt;category name="kitchen"&gt;
      &lt;product name="blender" total-qty="250"/&gt;
      &lt;product name="toaster" total-qty="50"/&gt;
    &lt;/category&gt;
  &lt;/state&gt;
&lt;/result&gt;
</eg></div3><!-- ############################ UC groupby_q5 ################################## --><div3 id="groupby_q5"><head>Q5</head><p>List all stores in ascending order by store number. For each store, list
the products sold in that store, in descending order by quantity sold.

Illustrates ordering among and within groups. </p><p>
						<emph>Solution in XQuery:</emph>
					</p><eg role="xquery" xml:space="preserve">&lt;result&gt;{
  for $sales in doc("sales-records.xml")/*/record
  let $storeno := $sales/store-number
  group by $storeno
  order by $storeno
  return
    &lt;store number = "{$storeno}"&gt;{
      for $s in $sales
      order by xs:int($s/qty) descending
      return
        &lt;product name = "{$s/product-name}" qty = "{$s/qty}"/&gt;
    }&lt;/store&gt;
}&lt;/result&gt;
</eg><p>
						<emph>Expected Result:</emph>
					</p><eg role="result" xml:space="preserve">&lt;result&gt;
  &lt;store number="1"&gt;
    &lt;product name="socks" qty="500"/&gt;
    &lt;product name="broiler" qty="20"/&gt;
  &lt;/store&gt;
  &lt;store number="2"&gt;
    &lt;product name="toaster" qty="100"/&gt;
    &lt;product name="toaster" qty="50"/&gt;
    &lt;product name="socks" qty="10"/&gt;
  &lt;/store&gt;
  &lt;store number="3"&gt;
    &lt;product name="blender" qty="150"/&gt;
    &lt;product name="blender" qty="100"/&gt;
    &lt;product name="toaster" qty="50"/&gt;
    &lt;product name="shirt" qty="10"/&gt;
  &lt;/store&gt;
&lt;/result&gt;
</eg></div3><!-- ############################ UC groupby_q6 ################################## --><div3 id="groupby_q6"><head>Q6</head><p>List all stores whose total profit is greater than 100,
in descending order by total profit.
Note: total profit for a store is the sum over all sales
in that store, of the quantity sold times the difference
between price and cost for the item sold.

Illustrates cross-document computation, filtering of groups,
ordering by a non-grouping key. </p><p>
						<emph>Solution in XQuery:</emph>
					</p><eg role="xquery" xml:space="preserve">&lt;result&gt;{
  for $sales in doc("sales-records.xml")/*/record
  let $storeno := $sales/store-number,
    $product := doc("products.xml")/*/product[name = $sales/product-name],
    $prd := $product,
    $profit := $sales/qty * ($prd/price - $prd/cost)
  group by $storeno
  let $total-store-profit := sum($profit)
  where $total-store-profit &gt; 100
  order by $total-store-profit descending
  return
    &lt;store number = "{$storeno}" total-profit = "{$total-store-profit}"/&gt;
 }&lt;/result&gt;</eg><p>
						<emph>Expected Result:</emph>
					</p><eg role="result" xml:space="preserve">&lt;result&gt;
  &lt;store number="3" total-profit="7320"/&gt;
  &lt;store number="2" total-profit="3030"/&gt;
  &lt;store number="1" total-profit="2100"/&gt;
&lt;/result&gt;
</eg></div3><!-- ############################ UC groupby_b1 ################################## --><div3 id="groupby_b1"><head>Q7</head><p>Group books by author. Create a group for each individual author. A book with multiple authors should appear in the groups for each of its authors. Alphabetize the authors and the book titles within each author group. </p><p>
						<emph>Solution in XQuery:</emph>
					</p><eg role="xquery" xml:space="preserve">&lt;result&gt;{
  for $book in doc("books.xml")/*/book
  for $author in $book/author
  group by $author
  order by $author
  return
  &lt;author name="{$author}"&gt;{
    for $b in $book
    order by $b/title
    return
      &lt;title&gt; {fn:data($b/title)} &lt;/title&gt;
  }&lt;/author&gt;
}&lt;/result&gt;</eg><p>
						<emph>Expected Result:</emph>
					</p><eg role="result" xml:space="preserve">&lt;result&gt;
  &lt;author name="Alan Simon"&gt;
    &lt;title&gt;SQL:1999&lt;/title&gt;
    &lt;title&gt;Strategic Database Technology&lt;/title&gt;
  &lt;/author&gt;
  &lt;author name="Andrew Eisenberg"&gt;
    &lt;title&gt;Understanding SQL and Java Together&lt;/title&gt;
  &lt;/author&gt;
  &lt;author name="Jim Melton"&gt;
    &lt;title&gt;Advanced SQL:1999&lt;/title&gt;
    &lt;title&gt;Querying XML&lt;/title&gt;
    &lt;title&gt;SQL:1999&lt;/title&gt;
    &lt;title&gt;Understanding SQL and Java Together&lt;/title&gt;
  &lt;/author&gt;
  &lt;author name="Stephen Buxton"&gt;
    &lt;title&gt;Querying XML&lt;/title&gt;
  &lt;/author&gt;
&lt;/result&gt;
</eg></div3><!-- ############################ UC groupby_b2 ################################## --><div3 id="groupby_b2"><head>Q8</head><p>Group books by author. Create a group for each distinct ordered list of authors. Each book should be grouped with other books that have the same ordered list of authors. Alphabetize the book titles within each group. </p><p>
						<emph>Solution in XQuery:</emph>
					</p><eg role="xquery" xml:space="preserve">&lt;result&gt;{
  for $book in doc("books.xml")/*/book
  let $author-list := fn:string-join($book/author, ', ')
  group by $author-list
  order by $author-list
  return
    &lt;author-list names="{$author-list}"&gt;{
      for $b in $book
      order by $b/title
      return
        &lt;title&gt; {fn:data($b/title)} &lt;/title&gt;
    }&lt;/author-list&gt;
}&lt;/result&gt;</eg><p>
						<emph>Expected Result:</emph>
					</p><eg role="result" xml:space="preserve">&lt;result&gt;
  &lt;author-list names="Alan Simon"&gt;
    &lt;title&gt;Strategic Database Technology&lt;/title&gt;
  &lt;/author-list&gt;
  &lt;author-list names="Jim Melton"&gt;
    &lt;title&gt;Advanced SQL:1999&lt;/title&gt;
  &lt;/author-list&gt;
  &lt;author-list names="Jim Melton, Alan Simon"&gt;
    &lt;title&gt;SQL:1999&lt;/title&gt;
  &lt;/author-list&gt;
  &lt;author-list names="Jim Melton, Andrew Eisenberg"&gt;
    &lt;title&gt;Understanding SQL and Java Together&lt;/title&gt;
  &lt;/author-list&gt;
  &lt;author-list names="Jim Melton, Stephen Buxton"&gt;
    &lt;title&gt;Querying XML&lt;/title&gt;
  &lt;/author-list&gt;
&lt;/result&gt;
</eg></div3></div2></div1><!-- EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE --><!--######################################    groupby     ################################ --><!-- EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE --><!--################################################################################### --><!--######################################    Windowing     ################################ --><!--################################################################################### --><div1 id="windowing"><head>Use Case "Windowing" - Queries which require windowing</head><p>This use case covers queries that require windowing or positional grouping, which can be seen as a special form of windowing. Windowing means that the queries require selecting subsequences based on certain characterisics of an underlying sequence.
</p><!--###################################### DATA arrange_rows ############################ --><div2 id="update30-windowing-schema-and-sample-data"><head>Schema and Sample Data</head><p>Windowing is required in various scenarios from formatting up to streaming applications.  The listed queries try to cover different scenarios and require therefore also various types of input data. The following sections describe for every query the used data and the according schema.</p><div3 id="dtdarrange_rows"><head>XML Schema for Q1</head><p>Q1 uses an input document named arrange_rows.xml, with the following XML Schema arrange_rows.xsd:</p><eg role="schema" xml:space="preserve">&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
    &lt;xs:element name="doc"&gt;
        &lt;xs:complexType&gt;
            &lt;xs:sequence&gt;
                &lt;xs:element name="data" type="xs:string" maxOccurs="unbounded"/&gt;
            &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
    &lt;/xs:element&gt;
&lt;/xs:schema&gt;
</eg></div3><div3 id="dataarrange_rows"><head>Sample Data for Q1</head><p>The content of arrange_rows.xml is:</p><eg role="data" xml:space="preserve">&lt;doc&gt;
  &lt;data&gt;Green&lt;/data&gt;
  &lt;data&gt;Pink&lt;/data&gt;
  &lt;data&gt;Lilac&lt;/data&gt;
  &lt;data&gt;Turquoise&lt;/data&gt;
  &lt;data&gt;Peach&lt;/data&gt;
  &lt;data&gt;Opal&lt;/data&gt;
  &lt;data&gt;Champagne&lt;/data&gt;
&lt;/doc&gt;
</eg></div3><!--###################################### DATA head_para ############################ --><div3 id="dtdhead_para"><head>XML Schema for Q2</head><p>Q2 uses an input document named head_para.xml, with the following XML Schema named head_para.xsd:</p><eg role="schema" xml:space="preserve">&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
    &lt;xs:element name="body"&gt;
        &lt;xs:complexType&gt;
            &lt;xs:sequence&gt;
                &lt;xs:sequence maxOccurs="unbounded"&gt;
                    &lt;xs:element name="h2" type="xs:string"/&gt;
                    &lt;xs:element name="p" type="xs:string" maxOccurs="unbounded"/&gt;
                &lt;/xs:sequence&gt;
            &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
    &lt;/xs:element&gt;
&lt;/xs:schema&gt;
</eg></div3><div3 id="datahead_para"><head>Sample Data for Q2</head><p>The content of head_para.xml is:</p><eg role="data" xml:space="preserve">&lt;body&gt;
  &lt;h2&gt;heading1&lt;/h2&gt;
  &lt;p&gt;para1&lt;/p&gt;
  &lt;p&gt;para2&lt;/p&gt;
  &lt;h2&gt;heading2&lt;/h2&gt;
  &lt;p&gt;para3&lt;/p&gt;
  &lt;p&gt;para4&lt;/p&gt;
  &lt;p&gt;para5&lt;/p&gt;
&lt;/body&gt;
</eg></div3><!--###################################### DATA term_def_list ############################ --><div3 id="dtdterm_def_list"><head>XML Schema for Q3</head><p>Q3 uses an input document named term_def_list.xml, with the following XML Schema named term_def_list.xsd:</p><eg role="schema" xml:space="preserve">&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
    &lt;xs:element name="doc"&gt;
        &lt;xs:complexType&gt;
            &lt;xs:sequence&gt;
                &lt;xs:sequence maxOccurs="unbounded"&gt;
                    &lt;xs:element name="dt" type="xs:string" maxOccurs="unbounded"/&gt;
                    &lt;xs:element name="dd" type="xs:string" maxOccurs="unbounded"/&gt;
                &lt;/xs:sequence&gt;
            &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
    &lt;/xs:element&gt;
&lt;/xs:schema&gt;
</eg></div3><div3 id="dataterm_def_list"><head>Sample Data for Q3</head><p>The content of term_def_list.xml is:</p><eg role="data" xml:space="preserve">&lt;doc&gt;
  &lt;dt&gt;XML&lt;/dt&gt;
  &lt;dd&gt;Extensible Markup Language&lt;/dd&gt;
  &lt;dt&gt;XSLT&lt;/dt&gt;
  &lt;dt&gt;XSL Transformations&lt;/dt&gt;
  &lt;dd&gt;A language for transforming XML&lt;/dd&gt;
  &lt;dd&gt;A specification produced by W3C&lt;/dd&gt;
&lt;/doc&gt;
</eg></div3><!--###################################### DATA delayed_events_day1 ############################ --><div3 id="dtddelayed_events_day1"><head>XML Schema for Q4-Q6</head><p>Q4 - Q6 use an input document named temp_events.xml, with the following XML Schema named temp_events.xsd:</p><eg role="schema" xml:space="preserve">&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
    &lt;xs:element name="stream"&gt;
        &lt;xs:complexType&gt;
            &lt;xs:sequence&gt;
                &lt;xs:element name="event" maxOccurs="unbounded"&gt;
                    &lt;xs:complexType&gt;
                        &lt;xs:attribute name="time" type="xs:integer" use="required"/&gt;
                        &lt;xs:attribute name="temp" type="xs:double" use="required"/&gt;
                    &lt;/xs:complexType&gt;
                &lt;/xs:element&gt;
            &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
    &lt;/xs:element&gt;
&lt;/xs:schema&gt;
</eg></div3><div3 id="datadelayed_events_day1"><head>Sample Data for Q4-Q6</head><p>The content of temp_events.xml is:</p><eg role="data" xml:space="preserve">&lt;stream&gt;
  &lt;event temp="10" time="1"/&gt;
  &lt;event temp="8" time="2"/&gt;
  &lt;event temp="6" time="3"/&gt;
  &lt;event temp="13" time="4"/&gt;
  &lt;event temp="32" time="5"/&gt;
  &lt;event temp="9" time="6"/&gt;
  &lt;event temp="10" time="7"/&gt;
&lt;/stream&gt;</eg></div3><!--###################################### DATA day1 ############################ --><div3 id="dtdday1"><head>XML Schema for Q7-Q13</head><p>Q7 - Q13 use an input document named person_events.xml, with the following XML Schema named person_events.xsd:</p><eg role="schema" xml:space="preserve">&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
    &lt;xs:element name="stream"&gt;
        &lt;xs:complexType&gt;
            &lt;xs:sequence&gt;
                &lt;xs:element name="event" maxOccurs="unbounded"&gt;
                    &lt;xs:complexType&gt;
                        &lt;xs:sequence minOccurs="0"&gt;
                            &lt;xs:element name="person" type="xs:string"/&gt;
                            &lt;xs:element name="direction" type="xs:string"/&gt;
                        &lt;/xs:sequence&gt;
                        &lt;xs:attribute name="time" type="xs:dateTime" use="required"/&gt;
                    &lt;/xs:complexType&gt;
                &lt;/xs:element&gt;
            &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
    &lt;/xs:element&gt;
&lt;/xs:schema&gt;
</eg></div3><div3 id="dataday1"><head>Sample Data for Q7-Q13</head><p>The content of person_events.xml is:</p><eg role="data" xml:space="preserve">&lt;stream&gt;
  &lt;event time="2006-01-01T01:00:00-00:00"/&gt;
  &lt;event time="2006-01-01T10:30:00-00:00"&gt;
    &lt;person&gt;Anton&lt;/person&gt;
    &lt;direction&gt;in&lt;/direction&gt;
  &lt;/event&gt;
  &lt;event time="2006-01-01T11:00:00-00:00"&gt;
    &lt;person&gt;Barbara&lt;/person&gt;
    &lt;direction&gt;in&lt;/direction&gt;
  &lt;/event&gt;
  &lt;event time="2006-01-01T11:15:00-00:00"&gt;
    &lt;person&gt;Clara&lt;/person&gt;
    &lt;direction&gt;in&lt;/direction&gt;
  &lt;/event&gt;
  &lt;event time="2006-01-01T12:15:00-00:00"&gt;
    &lt;person&gt;Clara&lt;/person&gt;
    &lt;direction&gt;out&lt;/direction&gt;
  &lt;/event&gt;
  &lt;event time="2006-01-01T14:00:00-00:00"&gt;
    &lt;person&gt;Barbara&lt;/person&gt;
    &lt;direction&gt;out&lt;/direction&gt;
  &lt;/event&gt;
  &lt;event time="2006-01-01T15:00:00-00:00"&gt;
    &lt;person&gt;Anton&lt;/person&gt;
    &lt;direction&gt;out&lt;/direction&gt;
  &lt;/event&gt;
  &lt;event time="2006-01-01T23:00:00-00:00"/&gt;
  &lt;event time="2006-01-02T01:00:00-00:00"/&gt;
  &lt;event time="2006-01-02T11:00:00-00:00"&gt;
    &lt;person&gt;Anton&lt;/person&gt;
    &lt;direction&gt;in&lt;/direction&gt;
  &lt;/event&gt;
  &lt;event time="2006-01-02T12:00:00-00:00"&gt;
    &lt;person&gt;Clara&lt;/person&gt;
    &lt;direction&gt;in&lt;/direction&gt;
  &lt;/event&gt;
  &lt;event time="2006-01-02T12:10:00-00:00"&gt;
    &lt;person&gt;Clara&lt;/person&gt;
    &lt;direction&gt;out&lt;/direction&gt;
  &lt;/event&gt;
  &lt;event time="2006-01-02T12:15:00-00:00"&gt;
    &lt;person&gt;Clara&lt;/person&gt;
    &lt;direction&gt;in&lt;/direction&gt;
  &lt;/event&gt;
  &lt;event time="2006-01-02T12:20:00-00:00"&gt;
    &lt;person&gt;Clara&lt;/person&gt;
    &lt;direction&gt;out&lt;/direction&gt;
  &lt;/event&gt;
    &lt;event time="2006-01-02T12:25:00-00:00"&gt;
    &lt;person&gt;Clara&lt;/person&gt;
    &lt;direction&gt;in&lt;/direction&gt;
  &lt;/event&gt;
  &lt;event time="2006-01-02T12:40:00-00:00"&gt;
    &lt;person&gt;Clara&lt;/person&gt;
    &lt;direction&gt;out&lt;/direction&gt;
  &lt;/event&gt;
  &lt;event time="2006-01-02T14:00:00-00:00"&gt;
    &lt;person&gt;Clara&lt;/person&gt;
    &lt;direction&gt;in&lt;/direction&gt;
  &lt;/event&gt;
  &lt;event time="2006-01-02T16:00:00-00:00"&gt;
    &lt;person&gt;Anton&lt;/person&gt;
    &lt;direction&gt;out&lt;/direction&gt;
  &lt;/event&gt;
  &lt;event time="2006-01-02T16:15:00-00:00"&gt;
    &lt;person&gt;Clara&lt;/person&gt;
    &lt;direction&gt;out&lt;/direction&gt;
  &lt;/event&gt;
  &lt;event time="2006-01-02T23:00:00-00:00"/&gt;
&lt;/stream&gt;
</eg></div3><!--###################################### DATA rss ############################ --><div3 id="dtdrss"><head>XML Schema for Q14-Q16</head><p>Q14 - Q16 use as input document a slightly modified RSS document named rss.xml. It mainly differs from RSS 2.0 in the way dates are expressed in the data.  The XML Schema, rss.xsd, is as follows:</p><eg role="schema" xml:space="preserve">&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
    &lt;xs:element name="rss"&gt;
        &lt;xs:complexType&gt;
            &lt;xs:sequence&gt;
                &lt;xs:element name="channel"&gt;
                    &lt;xs:complexType&gt;
                        &lt;xs:sequence&gt;
                            &lt;xs:element name="title" type="xs:string"/&gt;
                            &lt;xs:element name="link" type="xs:anyURI"/&gt;
                            &lt;xs:element name="description" type="xs:string"/&gt;
                            &lt;xs:element name="language" type="xs:string"/&gt;
                            &lt;xs:element ref="item" maxOccurs="unbounded"/&gt;
                        &lt;/xs:sequence&gt;
                    &lt;/xs:complexType&gt;
                &lt;/xs:element&gt;
            &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
    &lt;/xs:element&gt;
    &lt;xs:element name="item"&gt;
        &lt;xs:complexType&gt;
            &lt;xs:sequence&gt;
                &lt;xs:element name="title" type="xs:string"/&gt;
                &lt;xs:element name="category" type="xs:string"/&gt;
                &lt;xs:element name="author" type="xs:string"/&gt;
                &lt;xs:element name="pubDate" type="xs:dateTime"/&gt;
            &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
    &lt;/xs:element&gt;
&lt;/xs:schema&gt;
</eg></div3><div3 id="datarss"><head>Sample Data for Q14-Q16</head><p>The content of rss.xml is:</p><eg role="data" xml:space="preserve">&lt;rss&gt;
  &lt;channel&gt;
    &lt;title&gt;DBIS RSS&lt;/title&gt;
    &lt;link&gt;http://www.dbis.ethz.ch&lt;/link&gt;
    &lt;description&gt;The windowing dummy RSS.&lt;/description&gt;
    &lt;language&gt;en-us&lt;/language&gt;
    &lt;item&gt;
      &lt;title&gt;Why use cases are important Part 1.&lt;/title&gt;
      &lt;category&gt;Workshop&lt;/category&gt;
      &lt;author&gt;rokas@e-mail.de&lt;/author&gt;
      &lt;pubDate&gt;2003-06-03T09:00:00&lt;/pubDate&gt;
    &lt;/item&gt;
    &lt;item&gt;
      &lt;title&gt;Why use cases are important Part 2.&lt;/title&gt;
      &lt;category&gt;Workshop&lt;/category&gt;
      &lt;author&gt;rokas@e-mail.de&lt;/author&gt;
      &lt;pubDate&gt;2003-06-03T09:00:00&lt;/pubDate&gt;
    &lt;/item&gt;
    &lt;item&gt;
      &lt;title&gt;Why use cases are important Part 3.&lt;/title&gt;
      &lt;category&gt;Workshop&lt;/category&gt;
      &lt;author&gt;rokas@e-mail.de&lt;/author&gt;
      &lt;pubDate&gt;2003-06-03T10:00:00&lt;/pubDate&gt;
    &lt;/item&gt;
    &lt;item&gt;
      &lt;title&gt;Extending XQuery with Window Functions&lt;/title&gt;
      &lt;category&gt;Talk&lt;/category&gt;
      &lt;author&gt;tim@e-mail.de&lt;/author&gt;
      &lt;pubDate&gt;2003-06-03T11:00:00&lt;/pubDate&gt;
    &lt;/item&gt;
    &lt;item&gt;
      &lt;title&gt;XQueryP: A new programming language is born&lt;/title&gt;
      &lt;category&gt;Talk&lt;/category&gt;
      &lt;author&gt;david@e-mail.de&lt;/author&gt;
      &lt;pubDate&gt;2003-06-03T12:00:00&lt;/pubDate&gt;
    &lt;/item&gt;
    &lt;item&gt;
      &lt;title&gt;Why use cases are annoying to write.&lt;/title&gt;
      &lt;category&gt;Talk&lt;/category&gt;
      &lt;author&gt;rokas@e-mail.de&lt;/author&gt;
      &lt;pubDate&gt;2003-06-04T10:00:00&lt;/pubDate&gt;
    &lt;/item&gt;
  &lt;/channel&gt;
&lt;/rss&gt;
</eg></div3><!--###################################### DATA cXML ############################ --><div3 id="dtdcXML"><head>XML Schema for Q17-Q19</head><p>Q17-Q19 use an input document named cxml.xml. The structure of this document is inspired by the Commerce XML Resource standard (cXML). The document contains a sequence of events, where an event corresponds to a simplified message of the cXML standard or an timeclock event. The XML Schema with the file-name cxml.xsd is as follows:</p><eg role="schema" xml:space="preserve">&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
    &lt;xs:element name="sequence"&gt;
        &lt;xs:complexType&gt;
            &lt;xs:sequence&gt;
                &lt;xs:choice maxOccurs="unbounded"&gt;
                    &lt;xs:element name="time" type="TimeEvent"/&gt;
                    &lt;xs:element name="OrderRequest" type="OrderRequest" maxOccurs="unbounded"/&gt;
                    &lt;xs:element name="ConfirmationRequest" type="ConfirmationRequest"/&gt;
                    &lt;xs:element name="ShipNotice" type="ShipNotice" maxOccurs="unbounded"/&gt;
                &lt;/xs:choice&gt;
            &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
    &lt;/xs:element&gt;
    &lt;xs:complexType name="TimeEvent"&gt;
        &lt;xs:attribute name="date" type="xs:dateTime" use="required"/&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="OrderRequest"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element name="Item" maxOccurs="unbounded"&gt;
                &lt;xs:complexType&gt;
                    &lt;xs:attribute name="unitPrice" type="xs:byte" use="required"/&gt;
                    &lt;xs:attribute name="quantity" type="xs:byte" use="required"/&gt;
                    &lt;xs:attribute name="partID" type="xs:string" use="required"/&gt;
                &lt;/xs:complexType&gt;
            &lt;/xs:element&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute name="type" type="xs:string" use="required"/&gt;
        &lt;xs:attribute name="total" type="xs:short" use="required"/&gt;
        &lt;xs:attribute name="shipTo" type="xs:string"/&gt;
        &lt;xs:attribute name="orderID" type="xs:string" use="required"/&gt;
        &lt;xs:attribute name="date" type="xs:dateTime" use="required"/&gt;
        &lt;xs:attribute name="billTo" type="xs:string" use="required"/&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="ConfirmationRequest"&gt;
        &lt;xs:attribute name="status" type="xs:string" use="required"/&gt;
        &lt;xs:attribute name="orderID" type="xs:string" use="required"/&gt;
        &lt;xs:attribute name="date" type="xs:dateTime" use="required"/&gt;
        &lt;xs:attribute name="confirmID" type="xs:string" use="required"/&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="ShipNotice"&gt;
        &lt;xs:attribute name="orderID" type="xs:string" use="required"/&gt;
        &lt;xs:attribute name="date" type="xs:dateTime" use="required"/&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:schema&gt;

</eg></div3><div3 id="datacXML"><head>Sample Data for Q17-Q19</head><p>The content of cxml.xml is:</p><eg role="data" xml:space="preserve">&lt;sequence&gt;
  &lt;time date="2006-01-01T00:00:00-00:00"/&gt;
  &lt;OrderRequest billTo="ACME1" date="2006-01-01T10:00:00-00:00"
    orderID="OID01" shipTo="ACME1" total="1100" type="new"&gt;
    &lt;Item partID="ID1" quantity="10" unitPrice="100"/&gt;
    &lt;Item partID="ID2" quantity="10" unitPrice="10"/&gt;
  &lt;/OrderRequest&gt;
  &lt;OrderRequest billTo="ACME2" date="2006-01-01T11:00:00-00:00"
    orderID="OID02" total="100" type="new"&gt;
    &lt;Item partID="ID2" quantity="10" unitPrice="10"/&gt;
  &lt;/OrderRequest&gt;
  &lt;ConfirmationRequest confirmID="C1" date="2006-01-01T18:00:00-00:00"
    orderID="OID02" status="reject"/&gt;
  &lt;time date="2006-01-02T00:00:00-00:00"/&gt;
  &lt;ConfirmationRequest confirmID="C1" date="2006-01-02T08:00:00-00:00"
    orderID="OID01" status="accept"/&gt;
  &lt;OrderRequest billTo="ACME1" date="2006-01-02T14:00:00-00:00"
    orderID="OID03" shipTo="ACME1" total="10000" type="new"&gt;
    &lt;Item partID="ID3" quantity="100" unitPrice="100"/&gt;
  &lt;/OrderRequest&gt;
  &lt;ConfirmationRequest confirmID="C1" date="2006-01-02T16:00:00-00:00"
    orderID="OID03" status="accept"/&gt;
  &lt;time date="2006-01-03T00:00:00-00:00"/&gt;
  &lt;time date="2006-01-04T00:00:00-00:00"/&gt;
  &lt;time date="2006-01-05T00:00:00-00:00"/&gt;
  &lt;ShipNotice date="2006-01-05T08:00:00-00:00" orderID="OID01"/&gt;
  &lt;ShipNotice date="2006-01-05T09:00:00-00:00" orderID="OID03"/&gt;
  &lt;time date="2006-01-06T00:00:00-00:00"/&gt;
  &lt;OrderRequest billTo="ACME2" date="2006-01-06T08:00:00-00:00"
    orderID="OID04" total="100" type="new"&gt;
    &lt;Item partID="ID2" quantity="10" unitPrice="10"/&gt;
  &lt;/OrderRequest&gt;
  &lt;time date="2006-01-07T00:00:00-00:00"/&gt;
&lt;/sequence&gt;
</eg></div3></div2><!-- QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ --><!--######################################    DATA Windowing     ################################ --><!-- QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ --><div2 id="windowing-queries-results"><head>Queries and Results</head><!-- ############################ UC windowing_arrange_rows ################################## --><div3 id="windowing_arrange_rows"><head>Q1</head><p>Arrange a sequence of items as a table with three columns (using as many rows as necessary). </p><p>
						<emph>Solution in XQuery:</emph>
					</p><eg role="xquery" xml:space="preserve">declare variable $seq := fn:doc("arrange_rows.xml");

&lt;table&gt;{
  for tumbling window $w in $seq/doc/*
    start at $x when fn:true()
    end at $y when $y - $x = 2
  return
    &lt;tr&gt;{
      for $i in $w
      return
        &lt;td&gt;{data($i)}&lt;/td&gt;
    }&lt;/tr&gt;
}&lt;/table&gt;
</eg><p>
						<emph>Expected Result:</emph>
					</p><eg role="result" xml:space="preserve">&lt;table&gt;
  &lt;tr&gt;
    &lt;td&gt;Green&lt;/td&gt;
    &lt;td&gt;Pink&lt;/td&gt;
    &lt;td&gt;Lilac&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Turquoise&lt;/td&gt;
    &lt;td&gt;Peach&lt;/td&gt;
    &lt;td&gt;Opal&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Champagne&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
</eg></div3><!-- ############################ UC windowing_head_para ################################## --><div3 id="windowing_head_para"><head>Q2</head><p>Convert a structure with implicit sections to a structure with explicit sections.</p><p>
						<emph>Solution in XQuery:</emph>
					</p><eg role="xquery" xml:space="preserve">declare variable $seq := fn:doc("head_para.xml");

&lt;chapter&gt;{
  for tumbling window $w in $seq/body/*
    start previous $s when $s[self::h2]
    end next $e when $e[self::h2]
  return
    &lt;section title="{data($s)}"&gt;{
       for $x in $w
       return
         &lt;para&gt;{data($x)}&lt;/para&gt;
  }&lt;/section&gt;
}&lt;/chapter&gt;</eg><p>
						<emph>Expected Result:</emph>
					</p><eg role="result" xml:space="preserve">&lt;chapter&gt;
  &lt;section title="heading1"&gt;
    &lt;para&gt;para1&lt;/para&gt;
    &lt;para&gt;para2&lt;/para&gt;
  &lt;/section&gt;
  &lt;section title="heading2"&gt;
    &lt;para&gt;para3&lt;/para&gt;
    &lt;para&gt;para4&lt;/para&gt;
    &lt;para&gt;para5&lt;/para&gt;
  &lt;/section&gt;
&lt;/chapter&gt;
</eg></div3><!-- ############################ UC windowing_term_def_list ################################## --><div3 id="windowing_term_def_list"><head>Q3</head><p>Within a glossary in HTML, a defined term &lt;dt&gt; can be followed by a definition &lt;dd&gt;. The task is to group these together within a &lt;term&gt; element, where a group can
consist of one or more &lt;dt&gt; elements followed by one or more &lt;dd&gt; elements.</p><p>
						<emph>Solution in XQuery:</emph>
					</p><eg role="xquery" xml:space="preserve">declare variable $seq := fn:doc("term_def_list.xml");

&lt;doc&gt;{
for tumbling window $w in $seq/doc/*
  start $x when $x[self::dt]
  end $y next $z when $y[self::dd] and $z[self::dt]
return
  &lt;term&gt;{
    $w
  }&lt;/term&gt;
}&lt;/doc&gt;
</eg><p>
						<emph>Expected Result:</emph>
					</p><eg role="result" xml:space="preserve">&lt;doc&gt;
  &lt;term&gt;
    &lt;dt&gt;XML&lt;/dt&gt;
    &lt;dd&gt;Extensible Markup Language&lt;/dd&gt;
  &lt;/term&gt;
  &lt;term&gt;
    &lt;dt&gt;XSLT&lt;/dt&gt;
    &lt;dt&gt;XSL Transformations&lt;/dt&gt;
    &lt;dd&gt;A language for transforming XML&lt;/dd&gt;
    &lt;dd&gt;A specification produced by W3C&lt;/dd&gt;
  &lt;/term&gt;
&lt;/doc&gt;
</eg></div3><!-- ############################ UC windowing_1moving_avarage_time ################################## --><!--
 fn:doc("temp_events.xml");

let $MAX_DIFF := 2
for sliding window $w in $timesequence/stream/event
  start  $s_curr at $s_pos previous $s_prev at $s_pos
    when ($s_curr/@time ne $s_prev/@time) or (empty($s_prev))
  force end next $e_next
    when $e_next/@time - $s_curr/@time gt $MAX_DIFF
return
  avg( $w/@temp )
--><div3 id="windowing_1moving_avarage_time"><head>Q4</head><p>Calculate the moving average of temperature values for the 3 last seconds.</p><p>
						<emph>Solution in XQuery:</emph>
					</p><eg role="xquery" xml:space="preserve">declare variable $timesequence := fn:doc("temp_events.xml");

let $MAX_DIFF := 2

for sliding window $w in $timesequence/stream/event
  start  $s_curr at $s_pos previous $s_prev
    when ($s_curr/@time ne $s_prev/@time) or (empty($s_prev))
  only end next $e_next
    when $e_next/@time - $s_curr/@time gt $MAX_DIFF
return
  avg( $w/@temp )

</eg><p>
						<emph>Expected Result:</emph>
					</p><eg role="result" xml:space="preserve">8 9 17 18</eg></div3><!-- ############################ UC windowing_2exponential_smoothing_1 ################################## --><div3 id="windowing_2exponential_smoothing_1"><head>Q5</head><p>Single exponential smoothing (3 last values and smoothing factor 0.2) </p><p>
						<emph>Solution in XQuery:</emph>
					</p><eg role="xquery" xml:space="preserve">declare variable $timesequence := fn:doc("temp_events.xml");
let $SMOOTH_CONST := 0.2

for sliding window $w in $timesequence/stream/event
  start at $s_pos when true()
  only end at $e_pos when $e_pos - $s_pos eq 2
return
  round-half-to-even($SMOOTH_CONST * data($w[3]/@temp) + (1 - $SMOOTH_CONST) *
    ( $SMOOTH_CONST * data($w[2]/@temp) +
      (1 - $SMOOTH_CONST) * data($w[1]/@temp) ), 2)
</eg><p>
						<emph>Expected Result:</emph>
					</p><eg role="result" xml:space="preserve">8.88 8.68 12.32 15.24 23.92</eg></div3><!-- ############################ UC windowing_3outlier_detection ################################## --><div3 id="windowing_3outlier_detection"><head>Q6</head><p>Detect outliers (current value is two times higher (lower) than the average of the previous three values) in a sequence of temp values. </p><p>
						<emph>Solution in XQuery:</emph>
					</p><eg role="xquery" xml:space="preserve">declare variable $seq := fn:doc("temp_events.xml");

for sliding window $w in $seq/stream/event
  start  $s_curr when fn:true()
  only end next $next when $next/@time &gt; $s_curr/@time + 3
return
  let $avg := fn:avg($w/@temp)
  where $avg * 2 lt xs:double($next/@temp) or $avg div 2 gt xs:double($next/@temp)
  return &lt;alarm&gt;Outlier detected. Event id:{data($next/@time)}&lt;/alarm&gt;

</eg><p>
						<emph>Expected Result:</emph>
					</p><eg role="result" xml:space="preserve">&lt;alarm&gt;Outlier detected. Event id:5&lt;/alarm&gt;
</eg></div3><!-- ############################ UC windowing_1SEQ_A1h ################################## --><div3 id="windowing_1SEQ_A1h"><head>Q7</head><p>Notify when Barbara enters the building within 1 hour after Anton </p><p>
						<emph>Solution in XQuery:</emph>
					</p><eg role="xquery" xml:space="preserve">declare variable $seq := fn:doc("person_events.xml");

&lt;result&gt;{
  for tumbling window $w in $seq/stream/event
    start  $s when $s/person eq "Anton" and $s/direction eq "in"
    only end $e next $n when  xs:dateTime($n/@time) - xs:dateTime($s/@time) gt
      xs:dayTimeDuration("PT1H")
      or  ($e/person eq "Barbara" and $e/direction eq "in")
      or ($e/person eq "Anton" and $e/direction eq "out")
  where $e/person eq "Barbara" and $e/direction eq "in"
  return
    &lt;warning time="{ $e/@time }"&gt;Barbara: Anton arrived 1h ago&lt;/warning&gt;
}&lt;/result&gt;
</eg><p>
						<emph>Expected Result:</emph>
					</p><eg role="result" xml:space="preserve">&lt;result&gt;
  &lt;warning time="2006-01-01T11:00:00-00:00"&gt;Barbara: Anton arrived 1h ago&lt;/warning&gt;
&lt;/result&gt;
</eg></div3><!-- ############################ UC windowing_2SEQ_TimePerPerson ################################## --><div3 id="windowing_2SEQ_TimePerPerson"><head>Q8</head><p>Measure the working time of each person</p><p>
						<emph>Solution in XQuery:</emph>
					</p><eg role="xquery" xml:space="preserve">declare variable $seq := fn:doc("person_events.xml");

&lt;result&gt;{
for sliding window $w in $seq/stream/event
  start  $s when $s/direction eq "in"
  only end  $e when $s/person eq $e/person and
    $e/direction eq "out"
return
  &lt;working-time&gt;
      {$s/person}
      &lt;time&gt;{ xs:dateTime($e/@time) - xs:dateTime($s/@time)}&lt;/time&gt;
  &lt;/working-time&gt;
}&lt;/result&gt;</eg><p>
						<emph>Expected Result:</emph>
					</p><eg role="result" xml:space="preserve">&lt;result&gt;
	&lt;working-time&gt;
		&lt;person&gt;Anton&lt;/person&gt;
		&lt;time&gt;PT4H30M&lt;/time&gt;
	&lt;/working-time&gt;
	&lt;working-time&gt;
		&lt;person&gt;Barbara&lt;/person&gt;
		&lt;time&gt;PT3H&lt;/time&gt;
	&lt;/working-time&gt;
	&lt;working-time&gt;
		&lt;person&gt;Clara&lt;/person&gt;
		&lt;time&gt;PT1H&lt;/time&gt;
	&lt;/working-time&gt;
	&lt;working-time&gt;
		&lt;person&gt;Anton&lt;/person&gt;
		&lt;time&gt;PT5H&lt;/time&gt;
	&lt;/working-time&gt;
	&lt;working-time&gt;
		&lt;person&gt;Clara&lt;/person&gt;
		&lt;time&gt;PT10M&lt;/time&gt;
	&lt;/working-time&gt;
	&lt;working-time&gt;
		&lt;person&gt;Clara&lt;/person&gt;
		&lt;time&gt;PT5M&lt;/time&gt;
	&lt;/working-time&gt;
	&lt;working-time&gt;
		&lt;person&gt;Clara&lt;/person&gt;
		&lt;time&gt;PT15M&lt;/time&gt;
	&lt;/working-time&gt;
	&lt;working-time&gt;
		&lt;person&gt;Clara&lt;/person&gt;
		&lt;time&gt;PT2H15M&lt;/time&gt;
	&lt;/working-time&gt;
&lt;/result&gt;
</eg></div3><!-- ############################ UC windowing_2SEQ_TimePerPerson_overall ################################## --><div3 id="windowing_2SEQ_TimePerPerson_overall"><head>Q9</head><p>Measure the overall working time for each person.</p><p>
						<emph>Solution in XQuery:</emph>
					</p><eg role="xquery" xml:space="preserve">declare variable $seq := fn:doc("person_events.xml");

&lt;result&gt;{
for sliding window $w in $seq/stream/event
  start  $s when $s/direction eq "in"
  only end  $e when $s/person eq $e/person and
    $e/direction eq "out"
let $person := $s/person
let $workingTime := xs:dateTime($e/@time) - xs:dateTime($s/@time)
group by $person
order by $person
return
  &lt;working-time&gt;
    &lt;person&gt;{ $person }&lt;/person&gt;
    &lt;time&gt;{ sum($workingTime) }&lt;/time&gt;
  &lt;/working-time&gt;
}&lt;/result&gt;</eg><p>
						<emph>Expected Result:</emph>
					</p><eg role="result" xml:space="preserve">&lt;result&gt;
  &lt;working-time&gt;
    &lt;person&gt;Anton&lt;/person&gt;
    &lt;time&gt;PT9H30M&lt;/time&gt;
  &lt;/working-time&gt;
  &lt;working-time&gt;
    &lt;person&gt;Barbara&lt;/person&gt;
    &lt;time&gt;PT3H&lt;/time&gt;
  &lt;/working-time&gt;
  &lt;working-time&gt;
    &lt;person&gt;Clara&lt;/person&gt;
    &lt;time&gt;PT3H45M&lt;/time&gt;
  &lt;/working-time&gt;
&lt;/result&gt;</eg></div3><!-- ############################ UC windowing_3Seq_Not_A ################################## --><div3 id="windowing_3Seq_Not_A"><head>Q10</head><p>Display a warning if Barbara does not come to work.</p><p>
						<emph>Solution in XQuery:</emph>
					</p><eg role="xquery" xml:space="preserve">declare variable $seq := fn:doc("person_events.xml");

&lt;result&gt;{
  for tumbling window $w in $seq/stream/event[direction eq "in"]
    start  $s when fn:true()
    end next $e when xs:date( xs:dateTime($s/@time) ) ne xs:date( xs:dateTime($e/@time) )
  let $date := xs:date(xs:dateTime($s/@time))
  where not($w[person eq "Barbara"])
  return &lt;alert date="{ $date }"&gt;Barbara did not come to work&lt;/alert&gt;
}&lt;/result&gt;
</eg><p>
						<emph>Expected Result:</emph>
					</p><eg role="result" xml:space="preserve">&lt;result&gt;
  &lt;alert date="2006-01-02Z"&gt;Barbara did not come to work&lt;/alert&gt;
&lt;/result&gt;
</eg></div3><!-- ############################ UC windowing_4SEQ_yA ################################## --><div3 id="windowing_4SEQ_yA"><head>Q11</head><p>Identify every person who enters the building before Clara withing a 15 minute timeframe (Clara's arrival time - 15 minutes).
</p><p>
						<emph>Solution in XQuery:</emph>
					</p><eg role="xquery" xml:space="preserve">declare variable $seq := fn:doc("person_events.xml");

&lt;results&gt;{
  for tumbling window $w in $seq/stream/event[direction eq "in"]
    start when true()
    only end next $x when  $x/person eq "Clara"
  return
    &lt;result time="{ $x/@time }"&gt;{
      distinct-values(for $y in $w
        where (xs:dateTime($y/@time) + xs:dayTimeDuration("PT15M") ) ge xs:dateTime($x/@time)
        return $y/person)
    }&lt;/result&gt;
}&lt;/results&gt;
</eg><p>
						<emph>Expected Result:</emph>
					</p><eg role="result" xml:space="preserve">&lt;results&gt;
	&lt;result time="2006-01-01T11:15:00-00:00"&gt;Barbara&lt;/result&gt;
	&lt;result time="2006-01-02T12:00:00-00:00"/&gt;
	&lt;result time="2006-01-02T12:15:00-00:00"&gt;Clara&lt;/result&gt;
	&lt;result time="2006-01-02T12:25:00-00:00"&gt;Clara&lt;/result&gt;
	&lt;result time="2006-01-02T14:00:00-00:00"/&gt;
&lt;/results&gt;

</eg></div3><!-- ############################ UC windowing_5NOSEQ_BothIn ################################## --><div3 id="windowing_5NOSEQ_BothIn"><head>Q12</head><p>Notify when both Anton and Barbara enter the office within 30 minutes
of one another.</p><p>
						<emph>Solution in XQuery:</emph>
					</p><eg role="xquery" xml:space="preserve">declare variable $seq := fn:doc("person_events.xml");

&lt;result&gt;{
	for tumbling window $w in $seq/stream/event[direction eq "in"]
		start  $x when $x/person = ("Barbara", "Anton")
		end next $y when xs:dateTime($y/@time) - xs:dateTime($x/@time) gt xs:dayTimeDuration("PT30M")
	where $w[person eq "Anton"] and $w[person eq "Barbara"]
	return
		&lt;alert time="{ xs:dateTime($y/@time) }"&gt;Anton and Barbara just arrived&lt;/alert&gt;
}&lt;/result&gt;</eg><p>
						<emph>Expected Result:</emph>
					</p><eg role="result" xml:space="preserve">&lt;result&gt;
        &lt;alert time="2006-01-01T11:15:00Z"&gt;Anton and Barbara just arrived&lt;/alert&gt;
&lt;/result&gt;</eg></div3><!-- ############################ UC windowing_6AGG_Enter_3X_1 ################################## --><div3 id="windowing_6AGG_Enter_3X_1"><head>Q13</head><p>Inform when a person enters the building at least 3 times within 1 hour</p><p>
						<emph>Solution in XQuery:</emph>
					</p><eg role="xquery" xml:space="preserve">declare variable $seq := fn:doc("person_events.xml");

&lt;result&gt;{
  for sliding window $w in $seq/stream/event
    start  $s when true()
    end next $e when xs:dateTime($e/@time) - xs:dateTime($s/@time) gt
      xs:dayTimeDuration("PT1H")
  where count($w[person eq $s/person and direction eq "in"]) ge 3
  return
    &lt;alert time="{ $e/@time }"&gt;{fn:data($s/person)} is suspicious&lt;/alert&gt;
}&lt;/result&gt;</eg><p>
						<emph>Expected Result:</emph>
					</p><eg role="result" xml:space="preserve">&lt;result&gt;
  &lt;alert time="2006-01-02T14:00:00-00:00"&gt;Clara is suspicious&lt;/alert&gt;
&lt;/result&gt;
</eg></div3><!-- ############################ UC windowing_annoying_authors ################################## --><div3 id="windowing_annoying_authors"><head>Q14</head><p>Find all annoying authors who have posted three consecutive items in the RSS feed.</p><p>
						<emph>Solution in XQuery:</emph>
					</p><eg role="xquery" xml:space="preserve">declare variable $rssfeed := fn:doc("rss.xml");

&lt;result&gt;{
  for tumbling window $w in $rssfeed/rss/channel/item
    start  $first when fn:true()
    end next $lookAhead when $first/author ne $lookAhead/author
  where count($w) ge 3
  return &lt;annoying-author&gt;{
      $w[1]/author
    }&lt;/annoying-author&gt;
}&lt;/result&gt;</eg><p>
						<emph>Expected Result:</emph>
					</p><eg role="result" xml:space="preserve">&lt;result&gt;
  &lt;annoying-author&gt;
    &lt;author&gt;rokas@e-mail.de&lt;/author&gt;
  &lt;/annoying-author&gt;
&lt;/result&gt;
</eg></div3><!-- ############################ UC windowing_interesting_topics ################################## --><div3 id="windowing_interesting_topics"><head>Q15</head><p>Every day, provide a list of interesting topics in the RSS feed. In our example, interesting means that the title of the item contains the specific word XQuery.</p><p>
						<emph>Solution in XQuery:</emph>
					</p><eg role="xquery" xml:space="preserve">declare variable $rssfeed := fn:doc("rss.xml");

&lt;result&gt;{
  for tumbling window $w in $rssfeed/rss/channel/item
    start  $s_curr when true()
    end next $e_next when
      fn:day-from-dateTime(xs:dateTime($e_next/pubDate)) ne
      fn:day-from-dateTime(xs:dateTime($s_curr/pubDate))
  return
    &lt;item&gt;
        &lt;date&gt;{xs:date(xs:dateTime($s_curr/pubDate))}&lt;/date&gt;
        {  for $item in $w
		   where fn:contains( xs:string($item/title), 'XQuery')
		   return $item/title	}
      &lt;/item&gt;
}&lt;/result&gt;
</eg><p>
						<emph>Expected Result:</emph>
					</p><eg role="result" xml:space="preserve">&lt;result&gt;
  &lt;item&gt;
    &lt;date&gt;2003-06-03&lt;/date&gt;
    &lt;title&gt;Extending XQuery with Window Functions&lt;/title&gt;
    &lt;title&gt;XQueryP: A new programming language is born&lt;/title&gt;
  &lt;/item&gt;
  &lt;item&gt;
    &lt;date&gt;2003-06-04&lt;/date&gt;
  &lt;/item&gt;
&lt;/result&gt;
</eg></div3><!-- ############################ UC windowing_summary_by_authors ################################## --><div3 id="windowing_summary_by_authors"><head>Q16</head><p>Every day, provide a summary of the RSS feed grouped by author.</p><p>
						<emph>Solution in XQuery:</emph>
					</p><eg role="xquery" xml:space="preserve">declare variable $rssfeed := fn:doc("rss.xml");

&lt;result&gt;{
  for tumbling window $w in $rssfeed/rss/channel/item
    start  $s_curr when true()
    end next $e_next when
      fn:day-from-dateTime(xs:dateTime($e_next/pubDate)) ne
      fn:day-from-dateTime(xs:dateTime($s_curr/pubDate))
  return
    &lt;item&gt;
      &lt;date&gt;{xs:date(xs:dateTime($s_curr/pubDate))}&lt;/date&gt;
       {  for $a in fn:distinct-values($w/author)
           return
             &lt;author name="{$a}"&gt;
               &lt;titles&gt;
                 { $w[author eq $a]/title }
               &lt;/titles&gt;
			&lt;/author&gt;
	    }
	  &lt;/item&gt;
}&lt;/result&gt;</eg><p>
						<emph>Expected Result:</emph>
					</p><eg role="result" xml:space="preserve">&lt;result&gt;
  &lt;item&gt;
    &lt;date&gt;2003-06-03&lt;/date&gt;
    &lt;author name="rokas@e-mail.de"&gt;
      &lt;titles&gt;
        &lt;title&gt;Why use cases are important Part 1.&lt;/title&gt;
        &lt;title&gt;Why use cases are important Part 2.&lt;/title&gt;
        &lt;title&gt;Why use cases are important Part 3.&lt;/title&gt;
      &lt;/titles&gt;
    &lt;/author&gt;
    &lt;author name="tim@e-mail.de"&gt;
      &lt;titles&gt;
        &lt;title&gt;Extending XQuery with Window Functions&lt;/title&gt;
      &lt;/titles&gt;
    &lt;/author&gt;
    &lt;author name="david@e-mail.de"&gt;
      &lt;titles&gt;
        &lt;title&gt;XQueryP: A new programming language is born&lt;/title&gt;
      &lt;/titles&gt;
    &lt;/author&gt;
  &lt;/item&gt;
  &lt;item&gt;
    &lt;date&gt;2003-06-04&lt;/date&gt;
    &lt;author name="rokas@e-mail.de"&gt;
      &lt;titles&gt;
        &lt;title&gt;Why use cases are annoying to write.&lt;/title&gt;
      &lt;/titles&gt;
    &lt;/author&gt;
  &lt;/item&gt;
&lt;/result&gt;
</eg></div3><!-- ############################ UC windowing_Q2_most_valuable_customer ################################## --><div3 id="windowing_Q2_most_valuable_customer"><head>Q17</head><p>At the end of a day,
list the most valuable customers.</p><p>
						<emph>Solution in XQuery:</emph>
					</p><eg role="xquery" xml:space="preserve">declare variable $seq := fn:doc("cxml.xml");

&lt;result&gt;{
for sliding window $w in $seq/sequence/*
  start  $cur previous $prev
   when day-from-dateTime($cur/@date) ne day-from-dateTime($prev/@date) or empty($prev)
  end $end next $next
   when day-from-dateTime(xs:dateTime($end/@date)) ne
day-from-dateTime(xs:dateTime($next/@date))
return
  &lt;mostValuableCustomer endOfDay="{xs:dateTime($cur/@date)}"&gt;{
    let $companies :=	for $x in distinct-values($w/@billTo )
                        return &lt;amount company="{$x}"&gt;{sum($w[@billTo eq $x]/@total)}&lt;/amount&gt;
    let $max := max($companies)
    for $company in $companies
    where $company eq xs:untypedAtomic($max)
    return $company
  }&lt;/mostValuableCustomer&gt;
}&lt;/result&gt;</eg><p>
						<emph>Expected Result:</emph>
					</p><eg role="result" xml:space="preserve">&lt;result&gt;
  &lt;mostValuableCustomer endOfDay="2006-01-01T00:00:00Z"&gt;
    &lt;amount company="ACME1"&gt;1100&lt;/amount&gt;
  &lt;/mostValuableCustomer&gt;
  &lt;mostValuableCustomer endOfDay="2006-01-02T00:00:00Z"&gt;
    &lt;amount company="ACME1"&gt;10000&lt;/amount&gt;
  &lt;/mostValuableCustomer&gt;
  &lt;mostValuableCustomer endOfDay="2006-01-03T00:00:00Z"/&gt;
  &lt;mostValuableCustomer endOfDay="2006-01-04T00:00:00Z"/&gt;
  &lt;mostValuableCustomer endOfDay="2006-01-05T00:00:00Z"/&gt;
  &lt;mostValuableCustomer endOfDay="2006-01-06T00:00:00Z"&gt;
    &lt;amount company="ACME2"&gt;100&lt;/amount&gt;
  &lt;/mostValuableCustomer&gt;
  &lt;mostValuableCustomer endOfDay="2006-01-07T00:00:00Z"/&gt;
&lt;/result&gt;
</eg></div3><!-- ############################ UC windowing_Q3_transaction_time ################################## --><div3 id="windowing_Q3_transaction_time"><head>Q18</head><p>Calculate the time needed to process an order from the request up to the shipping. </p><p>
						<emph>Solution in XQuery:</emph>
					</p><eg role="xquery" xml:space="preserve">declare variable $seq := fn:doc("cxml.xml");

&lt;result&gt;{
  for sliding window $w in $seq/sequence/*
    start $s when $s[self::OrderRequest]
    end   $e when $e/@orderID eq  $s/@orderID
             and ($e[self::ConfirmationRequest] and $e/@status eq "reject"
                  or $e[self::ShipNotice])
  where $e[self::ShipNotice]
  return
    &lt;timeToShip orderID="{ $s/@orderID}"&gt;{xs:dateTime($e/@date) - xs:dateTime($s/@date) }&lt;/timeToShip&gt;
}&lt;/result&gt;</eg><p>
						<emph>Expected Result:</emph>
					</p><eg role="result" xml:space="preserve">&lt;result&gt;
  &lt;timeToShip orderID="OID01"&gt;P3DT22H&lt;/timeToShip&gt;
  &lt;timeToShip orderID="OID03"&gt;P2DT19H&lt;/timeToShip&gt;
&lt;/result&gt;
</eg></div3><!-- ############################ UC windowing_Q4_ship_together ################################## --><div3 id="windowing_Q4_ship_together"><head>Q19</head><p>At the moment of the shipping notification, calculate if an open request exists that can be shipped to the same address. </p><p>
						<emph>Solution in XQuery:</emph>
					</p><eg role="xquery" xml:space="preserve">declare variable $seq := fn:doc("cxml.xml");

&lt;result&gt;{
  for sliding window $w in $seq/sequence/*
    start previous $wSPrev when $wSPrev[self::OrderRequest]
    end next $wENext when $wENext/@orderID eq  $wSPrev/@orderID
        and ($wENext[self::ConfirmationRequest] and $wENext/@status eq "reject"
	         or $wENext[self::ShipNotice])
  where $wENext[self::ShipNotice]
  return
    &lt;bundleWith orderId="{$wSPrev/@orderID}"&gt;{
        for sliding window $bundle in $w
          start  $bSCur
            when $bSCur[self::OrderRequest] and $bSCur/@shipTo eq $wSPrev/@shipTo
          end  $bECur next $bENext
            when $bECur/@orderID eq  $bSCur/@orderID
             and ($bECur[self::ConfirmationRequest] and $bECur/@status eq "reject"
              or $bECur[self::ShipNotice])
          where empty($bENext)
          return $bSCur
    }&lt;/bundleWith&gt;
}&lt;/result&gt;</eg><p>
						<emph>Expected Result:</emph>
					</p><eg role="result" xml:space="preserve">&lt;result&gt;
  &lt;bundleWith orderId="OID01"&gt;
    &lt;OrderRequest billTo="ACME1" date="2006-01-02T14:00:00-00:00"
      orderID="OID03" shipTo="ACME1" total="10000" type="new"&gt;
      &lt;Item partID="ID3" quantity="100" unitPrice="100"/&gt;
    &lt;/OrderRequest&gt;
  &lt;/bundleWith&gt;
  &lt;bundleWith orderId="OID03"/&gt;
&lt;/result&gt;
</eg></div3></div2></div1><!-- EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE --><!--######################################    windowing     ################################ --><!-- EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE --><!-- QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ --><!--######################################    Count                             ################################ --><!-- QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ --><div1 id="count-use-cases"><head>Use Case "Count" - Queries which require output numbering </head><p>The described queries in this section all require tuple numbering. The numbering is either required in the final result or might also be required at some point in the middle when the tuple stream gets generated. </p><div2 id="update30-count-schema-and-sample-data"><head>Schema and Sample Data</head><p>The "Count" use cases are all based on the shopping scenario which can be found in the section <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#data" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Shopping Scenario Schema and Data</loc>.</p></div2><div2 id="update30-count-queries-and-results"><head>Queries and Results</head><div3 id="count-numbering"><head>Q1</head><p>List all products in alphabatical order with a continously increasing number. </p><p>
					<emph>Solution in XQuery:</emph>
				</p><eg role="xquery" xml:space="preserve">&lt;products&gt;{
    for $product in doc("products.xml")/*/product
    order by $product/name
    count $number
    return
        &lt;product number="{$number}"&gt;{$product/*}&lt;/product&gt;
}&lt;/products&gt;</eg><p>
					<emph>Expected Result:</emph>
				</p><eg role="result" xml:space="preserve">&lt;products&gt;
    &lt;product number="1"&gt;
        &lt;name&gt;blender&lt;/name&gt;
        &lt;category&gt;kitchen&lt;/category&gt;
        &lt;price&gt;50&lt;/price&gt;
        &lt;cost&gt;25&lt;/cost&gt;
    &lt;/product&gt;
    &lt;product number="2"&gt;
        &lt;name&gt;broiler&lt;/name&gt;
        &lt;category&gt;kitchen&lt;/category&gt;
        &lt;price&gt;100&lt;/price&gt;
        &lt;cost&gt;70&lt;/cost&gt;
    &lt;/product&gt;
    &lt;product number="3"&gt;
        &lt;name&gt;shirt&lt;/name&gt;
        &lt;category&gt;clothes&lt;/category&gt;
        &lt;price&gt;10&lt;/price&gt;
        &lt;cost&gt;3&lt;/cost&gt;
    &lt;/product&gt;
    &lt;product number="4"&gt;
        &lt;name&gt;socks&lt;/name&gt;
        &lt;category&gt;clothes&lt;/category&gt;
        &lt;price&gt;5&lt;/price&gt;
        &lt;cost&gt;2&lt;/cost&gt;
    &lt;/product&gt;
    &lt;product number="5"&gt;
        &lt;name&gt;toaster&lt;/name&gt;
        &lt;category&gt;kitchen&lt;/category&gt;
        &lt;price&gt;30&lt;/price&gt;
        &lt;cost&gt;10&lt;/cost&gt;
    &lt;/product&gt;
&lt;/products&gt;</eg></div3><div3 id="count-windowing"><head>Q2</head><p>Arrange a sequence of items as a table with three columns (using as many rows as necessary) like in <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#windowing_arrange_rows" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Q1</loc> from the windowing use cases.Additionally, number every row continuously.</p><p>
					<emph>Solution in XQuery:</emph>
				</p><eg role="xquery" xml:space="preserve">declare variable $seq := fn:doc("arrange_rows.xml");

&lt;table&gt;{
  for tumbling  window $w in $seq/doc/*
    start at $x when fn:true()
    end at $y when $y - $x = 2
  count $rowNumber
  return
    &lt;tr&gt;
      &lt;td&gt;{$rowNumber}&lt;/td&gt;{
      for $i in $w
      return
        &lt;td&gt;{data($i)}&lt;/td&gt;
    }&lt;/tr&gt;
}&lt;/table&gt;
</eg><p>
					<emph>Expected Result:</emph>
				</p><eg role="result" xml:space="preserve">&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;1&lt;/td&gt;
        &lt;td&gt;Green&lt;/td&gt;
        &lt;td&gt;Pink&lt;/td&gt;
        &lt;td&gt;Lilac&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;2&lt;/td&gt;
        &lt;td&gt;Turquoise&lt;/td&gt;
        &lt;td&gt;Peach&lt;/td&gt;
        &lt;td&gt;Opal&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;3&lt;/td&gt;
        &lt;td&gt;Champagne&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
</eg></div3><div3 id="count-top-k"><head>Q3</head><p>Top-K query: Return the three best-selling products (by quantity). </p><p>
					<emph>Solution in XQuery:</emph>
				</p><eg role="xquery" xml:space="preserve">&lt;result&gt;{
    for $sales in doc("sales-records.xml")/*/record
    let $name := $sales/product-name
    group by $name
    let $qty := sum($sales/qty)
    order by $qty descending
    count $count
    where $count &lt;= 3
    return
        &lt;sale product="{$name}" qty="{$qty }"/&gt;
}&lt;/result&gt;</eg><p>
					<emph>Expected Result:</emph>
				</p><eg role="result" xml:space="preserve">&lt;result&gt;
    &lt;sale product="socks" qty="510"/&gt;
    &lt;sale product="blender" qty="250"/&gt;
    &lt;sale product="toaster" qty="200"/&gt;
&lt;/result&gt;
</eg></div3></div2></div1><!-- EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE --><!--######################################    Count        ################################ --><!-- EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE --><!--######################################    Outer Join       ################################ --><!-- QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ --><!-- ############################ UC windowing_Q3_transaction_time ################################## --><div1 id="outer-join-uc"><head>Use Case "Outer For" - Queries which require outer joins</head><p>This use case demonstrate how the new "outer for" clause can help to express outer joins in XQuery.</p><div2 id="update30-outer-join-uc-schema-and-sample-data"><head>Schema and Sample Data</head><p>The "Outer For" use case is based on the shopping scenario which can be found in the section <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#data" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Shopping Scenario Schema and Data</loc>.</p></div2><div2 id="update30-outer-join-uc-queries-and-results"><head>Queries and Results</head><div3 id="outer-join-1"><head>Q1</head><p>Report all the store sales including stores which have not sold anything. </p><p>
					<emph>Solution in XQuery:</emph>
				</p><eg role="xquery" xml:space="preserve">&lt;result&gt;{
    for $store in doc("stores.xml")/*/store
    for $sale allowing empty in doc("sales-records.xml")/*/record[
         store-number eq $store/store-number]
    return
      &lt;store number="{$store/store-number}"
         product="{$sale/product-name}"
         state="{$store/state}"
         sold="{$sale/qty}" /&gt;
}&lt;/result&gt;</eg><p>
					<emph>Expected Result:</emph>
				</p><eg role="result" xml:space="preserve">&lt;result&gt;
    &lt;store number="1" state="CA" product="broiler" sold="20"/&gt;
    &lt;store number="1" state="CA" product="socks" sold="500"/&gt;
    &lt;store number="2" state="CA" product="toaster" sold="100"/&gt;
    &lt;store number="2" state="CA" product="toaster" sold="50"/&gt;
    &lt;store number="2" state="CA" product="socks" sold="10"/&gt;
    &lt;store number="3" state="MA" product="toaster" sold="50"/&gt;
    &lt;store number="3" state="MA" product="blender" sold="100"/&gt;
    &lt;store number="3" state="MA" product="blender" sold="150"/&gt;
    &lt;store number="3" state="MA" product="shirt" sold="10"/&gt;
    &lt;store number="4" state="WA" product="" sold=""/&gt;
&lt;/result&gt;
</eg></div3><div3 id="simplified-flwor-2"><head>Q2</head><p>List all the sales records. Include also all the items which were not sold in a store.</p><p>
					<emph>Solution in XQuery:</emph>
				</p><eg role="xquery" xml:space="preserve">&lt;result&gt;{
for $store in doc("stores.xml")/*/store
for $product in doc("products.xml")/*/product
for $sale allowing empty in doc("sales-records.xml")/*/record[
     store-number eq $store/store-number and
     product-name eq $product/name]
return
  &lt;store number="{$store/store-number}"
      state="{$store/state}"
      product="{$sale/product-name}"
      sold="{$sale/qty}" /&gt;
}&lt;/result&gt;</eg><p>
					<emph>Expected Result:</emph>
				</p><eg role="result" xml:space="preserve">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;result&gt;
    &lt;store number="1" state="CA" product="broiler" sold="20"/&gt;
    &lt;store number="1" state="CA" product="toaster" sold=""/&gt;
    &lt;store number="1" state="CA" product="blender" sold=""/&gt;
    &lt;store number="1" state="CA" product="socks" sold="500"/&gt;
    &lt;store number="1" state="CA" product="shirt" sold=""/&gt;
    &lt;store number="2" state="CA" product="broiler" sold=""/&gt;
    &lt;store number="2" state="CA" product="toaster" sold="100"/&gt;
    &lt;store number="2" state="CA" product="toaster" sold="50"/&gt;
    &lt;store number="2" state="CA" product="blender" sold=""/&gt;
    &lt;store number="2" state="CA" product="socks" sold="10"/&gt;
    &lt;store number="2" state="CA" product="shirt" sold=""/&gt;
    &lt;store number="3" state="CA" product="broiler" sold=""/&gt;
    &lt;store number="3" state="MA" product="toaster" sold="50"/&gt;
    &lt;store number="3" state="MA" product="blender" sold="100"/&gt;
    &lt;store number="3" state="MA" product="blender" sold="150"/&gt;
    &lt;store number="3" state="MA" product="socks" sold=""/&gt;
    &lt;store number="3" state="MA" product="shirt" sold="10"/&gt;
    &lt;store number="4" state="MA" product="broiler" sold=""/&gt;
    &lt;store number="4" state="MA" product="toaster" sold=""/&gt;
    &lt;store number="4" state="MA" product="blender" sold=""/&gt;
    &lt;store number="4" state="MA" product="socks" sold=""/&gt;
    &lt;store number="4" state="MA" product="shirt" sold=""/&gt;
&lt;/result&gt;

</eg></div3></div2></div1><!-- EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE --><!--######################################     Outer Join    ##################### --><!-- EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE --><!-- QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ --><!--######################################    Try/Catch                       ################################ --><!-- QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ --><div1 id="try-catch-use-cases"><head>Use Case "Try-Catch" - Queries which require to recover from errors</head><p>This use case covers queries that require to recover from errors.</p><!--###################################### DATA products ############################ --><div2 id="dataerrorproducts"><head>Sample Data</head><p>Q1 and Q2 are based on a errornous version of product.xml from <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#data" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Shopping Scenario Schema and Data</loc>, whereas Q3 does not require any input data.  Sample data for Q1 and Q2 named product-err.xml are shown below:</p><eg role="data" xml:space="preserve">&lt;products&gt;
  &lt;product&gt;
    &lt;name&gt;broiler&lt;/name&gt;
    &lt;category&gt;kitchen&lt;/category&gt;
    &lt;price&gt;100&lt;/price&gt;
    &lt;cost&gt;"70"&lt;/cost&gt;
  &lt;/product&gt;
  &lt;product&gt;
    &lt;name&gt;toaster&lt;/name&gt;
    &lt;category&gt;kitchen&lt;/category&gt;
    &lt;price&gt;30&lt;/price&gt;
    &lt;cost&gt;10&lt;/cost&gt;
  &lt;/product&gt;
  &lt;product&gt;
    &lt;name&gt;blender&lt;/name&gt;
    &lt;category&gt;kitchen&lt;/category&gt;
    &lt;price&gt;50&lt;/price&gt;
    &lt;cost&gt;25&lt;/cost&gt;
  &lt;/product&gt;
  &lt;product&gt;
    &lt;name&gt;socks&lt;/name&gt;
    &lt;category&gt;clothes&lt;/category&gt;
    &lt;price&gt;5&lt;/price&gt;
    &lt;cost&gt;2&lt;/cost&gt;
  &lt;/product&gt;
  &lt;product&gt;
    &lt;name&gt;shirt&lt;/name&gt;
    &lt;category&gt;clothes&lt;/category&gt;
    &lt;price&gt;10&lt;/price&gt;
    &lt;cost&gt;3&lt;/cost&gt;
  &lt;/product&gt;
&lt;/products&gt;
</eg></div2><div2 id="update30-trycatch-use-cases-queries-and-results"><head>Queries and Results</head><div3 id="try-catch-1"><head>Q1</head><p>Calculate the margin of every product. If an error occurs, report a user-friendly message.</p><p>
						<emph>Solution in XQuery:</emph>
					</p><eg role="xquery" xml:space="preserve">try {
    &lt;result&gt;{
        for $product in fn:doc("product-err.xml")//product
        return
            &lt;product&gt;{$product/name}
            &lt;margin&gt;{$product/price - $product/cost}&lt;/margin&gt;
            &lt;/product&gt;
    }&lt;/result&gt;
} catch * {
     "An error occured, please ask your consultant for help."
}
</eg><p>
						<emph>Expected Result:</emph>
					</p><eg role="result" xml:space="preserve">An error occured, please ask your consultant for help.
</eg></div3><div3 id="try-catch-2"><head>Q2</head><p>Report the margin in procent of every product. If an error occurs the failure should be listed, but the query should still continue to report the other values. </p><p>
						<emph>Solution in XQuery:</emph>
					</p><eg role="xquery" xml:space="preserve">&lt;result&gt;{
    for $product in fn:doc("product-err.xml")//product
    return
         try {
            &lt;product&gt;{$product/name}
              &lt;margin&gt;{$product/price div $product/cost}&lt;/margin&gt;
            &lt;/product&gt;
        } catch * {
            &lt;product&gt;{
                ($product/name, "Error:", $err:code)
            }&lt;/product&gt;
        }
}&lt;/result&gt;
</eg><p>
						<emph>Expected Result:</emph>
					</p><eg role="result" xml:space="preserve">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;result&gt;
    &lt;product&gt;
        &lt;name&gt;broiler&lt;/name&gt;
        Error: FORG0001
    &lt;/product&gt;
    &lt;product&gt;
        &lt;name&gt;toaster&lt;/name&gt;
        &lt;margin&gt;3&lt;/margin&gt;
    &lt;/product&gt;
    &lt;product&gt;
        &lt;name&gt;blender&lt;/name&gt;
        &lt;margin&gt;2&lt;/margin&gt;
    &lt;/product&gt;
    &lt;product&gt;
        &lt;name&gt;socks&lt;/name&gt;
        &lt;margin&gt;2.5&lt;/margin&gt;
    &lt;/product&gt;
    &lt;product&gt;
        &lt;name&gt;shirt&lt;/name&gt;
        &lt;margin&gt;3.3333333333333333&lt;/margin&gt;
    &lt;/product&gt;
&lt;/result&gt;
</eg></div3><div3 id="try-catch-3"><head>Q3</head><p>For a sequence of inputs the n-th fibonacci number has to be calculated using a pre-defined function. The function is built to avoid long running times and therefore rejects high values by throwing a user-defined error. If such an error occurs during calculation, a warning should be displayed, but the processing should continue.  </p><p>
						<emph>Solution in XQuery:</emph>
					</p><eg role="xquery" xml:space="preserve">declare namespace foo='http://foo.com';
declare function local:fib-recur($n as xs:integer) as xs:integer? {
    if ($n &lt;0) then ()
    else if ($n &gt; 100) then
        fn:error(fn:QName('http://foo.com', 'ValueToBig'), 'Value too big')
    else if ($n = 0)  then 0
    else if ($n=1)   then 1
    else local:fib-recur($n - 1)  + local:fib-recur($n - 2)
};

&lt;result&gt;{
    for $x in (3,1,1030,5)
    return
        try{
        &lt;fib input="{$x}"&gt;{local:fib-recur($x)}&lt;/fib&gt;
        }catch foo:ValueToBig {
          &lt;fib input="{$x}"&gt;Number to big&lt;/fib&gt;
        }
}&lt;/result&gt;</eg><p>
						<emph>Expected Result:</emph>
					</p><eg role="result" xml:space="preserve">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;result&gt;
    &lt;fib input="3"&gt;2&lt;/fib&gt;
    &lt;fib input="1"&gt;1&lt;/fib&gt;
    &lt;fib input="1030"&gt;Number to big&lt;/fib&gt;
    &lt;fib input="5"&gt;5&lt;/fib&gt;
&lt;/result&gt;
</eg></div3></div2></div1><!-- EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE --><!--######################################    Try/Catch   ################################ --><!-- EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE --></body><back><inform-div1 id="acknowledgements"><head>Acknowledgements</head><p>The Working Group thanks the following individuals for their contributions:</p><table border="1"><tbody><tr><td rowspan="1" colspan="1">Peter M. Fischer, Donald Kossmann, Rokas Tamosevicius</td><td rowspan="1" colspan="1">Use Case "windowing"</td></tr></tbody></table><!--
			<p>Use case "windowing" has been previously published in <bibref ref="Fischer2006"/>.</p>
--></inform-div1><inform-div1 id="ChangeLog"><head>Change Log</head><div2 id="id-2011-03-30"><head>30 Mar 2011</head><ulist><item><p>Removed <code>xsi</code> declaration and <code>xsi:noNamespaceSchemaLocation</code> attributes in input documents. Resolves <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Bugs/Public/show_bug.cgi?id=11757" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">BZ 11757</loc>.</p></item><item><p>Corrected input file name in Windowing Q7. Resolves <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Bugs/Public/show_bug.cgi?id=11756" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">BZ 11756</loc>.</p></item><item><p>Corrected Clara's working time in Windowing Q8. Resolves <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Bugs/Public/show_bug.cgi?id=11758" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">BZ 11758</loc>.</p></item><item><p>Added <code>order by $person</code> to Windowing Q9. Resolves <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Bugs/Public/show_bug.cgi?id=11759" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">BZ 11759</loc>.</p></item><item><p>Corrected Clara's working time in Windowing Q9. Resolves <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Bugs/Public/show_bug.cgi?id=11853" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">BZ 11853</loc>.</p></item><item><p>Corrected result of Windowing Q12. Resolves <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Bugs/Public/show_bug.cgi?id=11761" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">BZ 11761</loc>.</p></item><item><p>Added parentheses to correct solutions in Windowing Q18 and Q19. Resolves <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Bugs/Public/show_bug.cgi?id=11762" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">BZ 11762</loc>.</p></item></ulist></div2><div2 id="id-2008-01-30"><head>30 January 2008</head><ulist><item><p>Added group-by UC.</p></item><item><p>Added windowing UC.</p></item></ulist></div2><div2 id="id-2008-11-17"><head>17 November 2008</head><ulist><item><p>Added try-catch UC.</p></item><item><p>Added outer-join UC.</p></item><item><p>Added output-numbering UC.</p></item><item><p>Changed all DTDs to XML Schema.</p></item></ulist></div2></inform-div1><inform-div1 id="references"><head>References</head><p>The following references are some of the works considered by the WG in deriving its
                use cases. </p><blist><!--
				<bibl id="Fischer2006" key="Windowing UC">
					<titleref href="http://www.dbis.ethz.ch/research/publications/XQWindowsUseCases.pdf">Windows for XQuery - Use Cases</titleref>, Peter M. Fischer, Donald
                    Kossmann, Tim Kraska and Rokas Tamosevicius, 2006, Technical Report, ETH Zurich</bibl>
--><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xmlschema-0" key="XMLSchema0" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xmlschema-1" key="XMLSchema1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xmlschema-2" key="XMLSchema2" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xquery-30" key="XQuery 3.0" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xquery-30-requirements" key="XQuery 3.0 Requirements" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xslt-30" key="XSL Transformations (XSLT) Version 3.0" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="UseCaseQueries" key="Use Case Sample Queries" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
					<titleref href="http://www.w3.org/2013/01/xquery-30-use-cases/xquery-30-use-case-queries.txt" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Queries from this document</titleref>, presented in a single file</bibl></blist></inform-div1></back></spec>
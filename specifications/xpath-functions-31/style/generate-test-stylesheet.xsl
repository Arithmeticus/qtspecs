<?xml version='1.0'?>
<xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:x="http://www.w3.org/1999/XSL/TransformAlias"
  xmlns:s="http://saxon.sf.net/alias"
  xmlns:saxon="http://saxon.sf.net/"
  xmlns:fos="http://www.w3.org/xpath-functions/spec/namespace">

<!-- 
  This stylesheet takes the function catalog as input, and accesses the fos:test elements
  to produce an executable stylesheet which runs the tests and thereby tests that all the
  examples are correct
-->

<xsl:namespace-alias result-prefix="xsl" stylesheet-prefix="x"/>
<xsl:namespace-alias result-prefix="saxon" stylesheet-prefix="s"/>

<xsl:output method="xml" indent="yes"/>

<xsl:template match="/">
  <xsl:for-each select="1 to 20">
	<xsl:comment>DO NOT EDIT: GENERATED BY generate-test-stylesheet.xsl</xsl:comment>
	<xsl:text>&#xa;</xsl:text>
  </xsl:for-each>	
  <x:stylesheet version="3.0"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
	xmlns:fn="http://www.w3.org/2005/xpath-functions"
	xmlns:err="http://www.w3.org/2005/xqt-errors"
	xmlns:math="http://www.w3.org/2005/xpath-functions/math"
	xmlns:map="http://www.w3.org/2005/xpath-functions/map"
	xmlns:op="http://www.w3.org/2005/xpath-operators/local"
	xmlns:output="http://www.w3.org/2010/xslt-xquery-serialization"	
	s:allow-all-built-in-types="yes">
  	<x:output method="xml" indent="yes"/>
  	<xsl:comment> Hard-coded collation definitions that work for Saxon only </xsl:comment>
  	<xsl:text>&#xa;   </xsl:text>
  	<s:collation name="http://example.com/CollationA" rules=" ='-'='*'&lt; a &lt; b &lt; c &lt; d &lt; e &lt; f &lt; g &lt; h &lt; i &lt; j &lt; k &lt; l &lt; m &lt; n &lt; o &lt; p &lt; q &lt; r &lt; s &lt; t &lt; u &lt; v &lt; w &lt; x &lt; y &lt; z"/>
  	<s:collation name="http://example.com/deutsch" lang="de" ignore-modifiers="yes" decomposition="full"/>
    <s:collation name="http://collation.example.com/caseblind" lang="en" ignore-case="yes" decomposition="full"/>
	<xsl:apply-templates select="fos:global-variables/fos:variable"/>
    <x:template name="main" match="/">
    	<errors>
    		<xsl:apply-templates select="//fos:test|//fos:variable"/>
    	</errors>
	</x:template>
	<xsl:apply-templates select="//fos:function[fos:opermap]"/>
  </x:stylesheet>
</xsl:template>

<xsl:template match="fos:function//fos:test[not(@xslt-version and number(@xslt-version) gt number(system-property('xsl:version')))]">
  <xsl:variable name="tztest" select="if (@implicit-timezone) then concat('implicit-timezone() eq xs:duration(''', @implicit-timezone, ''') and ') else ''"/>
  <xsl:choose>
    <xsl:when test="fos:error-result">
      <x:try select="{fos:expression}">
        <x:catch errors="{if (contains(fos:error-result/@error-code), ':') then '' else 'err:'}{fos:error-result/@error-code}"/>
      </x:try>
    </xsl:when>
    <xsl:when test="fos:result[2]">
      <x:if test="{$tztest}not(some $r in ({string-join(fos:result/concat('(',normalize-space(.),')'), ',')}) satisfies deep-equal({normalize-space(fos:expression)}, $r))">
        <xsl:copy-of select="@default-collation"/>
        <err>Failure running <xsl:value-of select="normalize-space(fos:expression)"
        />: actual result is <x:try><x:copy-of select="({fos:expression})[not(. instance of function(*))]"/><x:catch errors="*">error (<x:value-of select="$err:description"/>)</x:catch></x:try></err>
      </x:if>
    </xsl:when>
    <xsl:when test="fos:result/@approx='true'">
      <x:if test="{$tztest}abs(number({normalize-space(fos:expression)}) - number({normalize-space(fos:result)})) gt 1e-5">
        <xsl:copy-of select="@default-collation"/>
        <err>Failure running <xsl:value-of select="normalize-space(fos:expression)"
        />: actual result is <x:try><x:copy-of select="({fos:expression})[not(. instance of function(*))]"/><x:catch errors="*">error (<x:value-of select="$err:description"/>)</x:catch></x:try></err>
      </x:if>
    </xsl:when>
    <xsl:when test="fos:result/@allow-permutation='true'">
      <x:if test="not({$tztest}count({normalize-space(fos:expression)}) eq count({normalize-space(fos:result)}) and (every $v in ({normalize-space(fos:expression)}) satisfies $v = ({normalize-space(fos:result)})))">
        <xsl:copy-of select="@default-collation"/>
        <err>Failure running <xsl:value-of select="normalize-space(fos:expression)"
        />: actual result is <x:try><x:copy-of select="({fos:expression})[not(. instance of function(*))]"/><x:catch errors="*">error (<x:value-of select="$err:description"/>)</x:catch></x:try></err>
      </x:if>
    </xsl:when>
    <xsl:when test="fos:result/@as">
      <x:variable name="var.{generate-id()}" as="{fos:result/@as}">
        <xsl:value-of select="fos:result" disable-output-escaping="yes"/>
      </x:variable>
      <x:if test="{$tztest}not(saxon:deep-equal({normalize-space(fos:expression)}, $var.{generate-id()}, (), 'w'))">
        <xsl:copy-of select="@default-collation"/>
        <err>Failure running <xsl:value-of select="normalize-space(fos:expression)"
        />: actual result is <x:try><x:copy-of select="({fos:expression})[exists(data(.))]"/><x:catch errors="*">error (<x:value-of select="$err:description"/>)</x:catch></x:try></err>
      </x:if>
    </xsl:when>
    <xsl:otherwise>
      <x:if test="{$tztest}not(deep-equal({normalize-space(fos:expression)}, {normalize-space(fos:result)}))">
      	<xsl:copy-of select="@default-collation"/>
        <err>Failure running <xsl:value-of select="normalize-space(fos:expression)"
        />: actual result is <x:try><x:copy-of select="({fos:expression})[exists(data(.))]"/><x:catch errors="*">error (<x:value-of select="$err:description"/>)</x:catch></x:try></err>
      </x:if>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template match="fos:test"/>

<xsl:template match="fos:variable">
  <x:variable name="{@name}">
    <xsl:copy-of select="@select, @as"/>
	<xsl:value-of select="child::node()" disable-output-escaping="yes"/>
  </x:variable>
</xsl:template>


<xsl:template match="fos:function[fos:opermap]">
  <xsl:variable name="return-type" select="fos:signatures/fos:proto/@return-type"/>
  <x:function name="op:{@name}" as="{if ($return-type='numeric') then 'xs:anyAtomicType' else $return-type}">
    <xsl:for-each select="fos:signatures/fos:proto/fos:arg">
	  <x:param name="{@name}" as="{if (@type='numeric') then 'xs:anyAtomicType' else @type}"/>
	</xsl:for-each>
	<x:sequence select="{if (count(fos:signatures/fos:proto/fos:arg)=2)
	                     then concat('$', fos:signatures/fos:proto/fos:arg[1]/@name,
						             ' ', tokenize(fos:opermap/@operator, ' ')[1], ' ',
									 '$', fos:signatures/fos:proto/fos:arg[2]/@name)
						 else concat(tokenize(fos:opermap/@operator, ' ')[1], ' ',
									 '$', fos:signatures/fos:proto/fos:arg[1]/@name)}"/>
  </x:function>
</xsl:template>               


</xsl:stylesheet>
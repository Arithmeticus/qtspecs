<!--XSLT Processor: SAXON 8.9.0.4 from Saxonica SAXON SA 8.9.0.4--><!-- Current changes labelled at="F" (2010-06-19) --><!--
<head><?xml-stylesheet type="text/xsl" href="E:\XMLdocs\XML Query Language (XQuery)\Functions and Operators\Current Functions and Operators Build Files\xquery-operators.xsl"?></head> --><spec xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax" id="spec-top" w3c-doctype="wd" status="int-review"><header><title>XPath and XQuery Functions and Operators 1.1</title><version>("Internal Last Call")</version><w3c-designation>WD-xpath-functions-11</w3c-designation><w3c-doctype>W3C Working Draft</w3c-doctype><pubdate><day>28</day><month>June</month><year>2010</year></pubdate><publoc>
            <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2010/WD-xpath-functions-11-20100628/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2010/WD-xpath-functions-11-20100628/</loc>
        </publoc><!-- These altlocs URIs are computed from the concatenation of doc.public, doc.shortname, and either '.xml' or
     '-diff-from-yyyymmdd.html', where 'yyyymmdd' is the earlier version of the spec from which a diff has been produced --><altlocs><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2010/WD-xpath-functions-11-20100628/xpath-functions-11.xml" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML</loc><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2010/WD-xpath-functions-11-20100628/xpath-functions-11-diff-from-20070123.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Change markings relative to first edition</loc></altlocs><!-- The latestloc URI is computed from doc.latestloc --><latestloc>
            <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/xpath-functions-11/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xpath-functions-11/</loc>
        </latestloc><!-- These prevlocs URIs are always hard-coded and are never computed from entities --><!-- Pubrules doesn't like FPWD to have a prevloc, not even a previous Recommendation
        <prevlocs>
            <loc href="http://www.w3.org/TR/2007/REC-xpath-functions-20070123/">http://www.w3.org/TR/2007/REC-xpath-functions-20070123/</loc>    
        </prevlocs>
--><authlist><author role="1.1"><name>Michael Kay (XSL WG)</name><affiliation>Saxonica</affiliation><email xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.saxonica.com/" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.saxonica.com/</email></author></authlist><!-- No errata for a document until it reaches Recommendation status
  <errataloc href="http://www.w3.org/XML/2009/qt-errata/xpath-functions-errata.html"/>
--><translationloc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2003/03/Translations/byTechnology?technology=xpath-functions" xlink:type="simple"/><abstract><p>This is a draft for internal review. Change markings are relative to the Recommendation of 23 January 2007.</p><p>This document defines constructor functions, operators, and functions on the datatypes defined in
                    <bibref ref="xmlschema-2"/> and the datatypes defined in <bibref ref="xpath-datamodel-11"/>.  It also defines
                functions and operators on nodes and node sequences as defined in the <bibref ref="xpath-datamodel-11"/>.  These functions and operators are defined for use in <bibref ref="xpath-21"/>, <bibref ref="xquery-11"/> and
                    <bibref ref="xslt-21"/> and other related XML standards.  The signatures and summaries of functions defined in this document are available at:
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2005/xpath-functions" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/2005/xpath-functions</loc>.</p><p diff="add" at="A">This is the third version of the specification of this function library. The first version was included as an intrinsic part of the
<bibref ref="xpath"/> specification published on 16 November 1999. The second version was published under the title
<emph>XQuery 1.0 and XPath 2.0 Functions and Operators</emph> on 23 January 2007. This third version is the first to carry its own version
number, which has been arbitrarily set at 1.1 to align with version numbering for XQuery.</p></abstract><!--* Common status section for QT specs.
    * Use is currently not required, but it simplifies things.
    * 
    * Revisions:
    * 2007-01-15 : CMSMcQ : made file, to simplify publication of Rec.
    * 2008-02-15 : JimMelton : cloned from MSM's REC-only material
                     to generalize for all stages
    *--><status id="status"><!-- ************************************************************************** --><!-- * All Status sections must start with the standard boilerplate paragraph * --><!-- *   This entity is defined in status-entities.dtd                        * --><!-- ************************************************************************** --><p><emph>This section describes the status of this
         document at the time of its publication.
         Other documents may supersede this document.
         A list of current W3C publications and the latest
         revision of this technical report can be found in the
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">W3C technical reports index</loc>
         at http://www.w3.org/TR/.</emph></p><!-- ************************************************************************** --><!-- * QT publishes suites of documents, which must be described in the       * --><!--     Status section of each document within such a suite.                 * --><!-- *   This entity is defined in the host document.                         * --><!-- ************************************************************************** --><p>This is one document
in a set of eight documents that have progressed to
Recommendation together (XQuery 1.1, XQueryX 1.1, XSLT 2.1,
Data Model 1.1, Functions and Operators 1.1, Formal Semantics 1.1,
Serialization 1.1, XPath 2.1). </p><!-- ************************************************************************** --><!-- * There is a lot of detailed customization based on the document stage   * --><!-- *   This entity is defined in the host document.                         * --><!-- ************************************************************************** --><p>This is a <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2005/10/Process-20051014/tr.html#maturity-levels" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Working Draft</loc> as described in the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2005/10/Process-20051014/tr.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Process Document</loc>.
It has been jointly developed by the W3C 
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/Query/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML Query Working Group</loc> and the W3C <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Style/XSL/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XSL Working Group</loc>, each of which is part of the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/Activity" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML Activity</loc>.
The Working Groups expect to advance this specification to <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2005/10/Process-20051014/tr.html#RecsW3C" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Recommendation</loc> Status.</p><!-- ************************************************************************** --><!-- * CR documents must cite features at risk                                * --><!-- *   This entity is defined in the host document.                         * --><!-- ************************************************************************** --><!-- ************************************************************************** --><!-- * Every Status section must have a customized paragraph                  * --><!-- *   This entity is defined completely in the host document.              * --><!-- ************************************************************************** --><p>This is an "internal last call working draft" of XQuery and XPath Functions and Operators 1.1 (XDM).
                               The purpose of this publication is for members of the XML Query and XSL WGs to review
                               the content and identify all issues that they believe would inhibit progression of
                               the document to Proposed Recommendation status. 
                               Ideally, WG members will identify all such issues in the document before it is progressed
                               to Last Call Working Draft status and will not submit large numbers of issues during the
                               (public) Last Call review period.
                               WG members' comments on this document should be submitted, using the ordinary Bugzilla
                               reporting mechanism, no later than Friday, 2010-07-09, so they may be considered by the
                               Joint face-to-face meeting scheduled to begin on 2010-07-12. </p><!-- ************************************************************************** --><!-- * CR docs should, and PR docs must, have a pointer to an implementation  * --><!-- *   report.  We also want to point to the test suite.                    * --><!-- *   This entity is defined in the host document.                         * --><!-- ************************************************************************** --><p>A Test Suite has been created for this document.
Implementors are encouraged to run this test suite and report their results.
The Test Suite can be found at <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://dev.w3.org/cvsweb/2006/xquery-test-suite/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://dev.w3.org/cvsweb/2006/xquery-test-suite/</loc>. 
An implementation report is available at
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/Query/test-suite/XQTSReport.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/XML/Query/test-suite/XQTSReport.html</loc>.</p><!-- ************************************************************************** --><!-- * The Status section should point to a changelog                         * --><!-- *   This entity is defined in the host document.                         * --><!-- ************************************************************************** --><p>This document incorporates changes made against the previous publication
  of the Working Draft of 4 December 2009.
  Changes to this document since the previous publication of the Working Draft
  are detailed in <specref ref="changelog"/>.</p><!-- ************************************************************************** --><!-- * The Status section must tell readers where to send comments            * --><!-- *   This entity is defined in status-entities.dtd                        * --><!-- ************************************************************************** --><p>Please report errors in this document using W3C's
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Bugs/Public/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public Bugzilla system</loc>
         (instructions can be found at
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/2005/04/qt-bugzilla" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/XML/2005/04/qt-bugzilla</loc>).
         If access to that system is not feasible, you may send your comments
         to the W3C XSLT/XPath/XQuery public comments mailing list,
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:public-qt-comments@w3.org" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public-qt-comments@w3.org</loc>.
         It will be very helpful if you include the string 
         “[FO11]”
         in the subject line of your report, whether made in Bugzilla or in email.
         Please use multiple Bugzilla entries (or, if necessary, multiple email messages)
         if you have more than one comment to make.
         Archives of the comments and responses are available at
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://lists.w3.org/Archives/Public/public-qt-comments/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://lists.w3.org/Archives/Public/public-qt-comments/</loc>. </p><!-- ************************************************************************** --><!-- Status sections must state the stability (not stable, or REC) of the document --><!-- *   This entity is defined in the host document.                         * --><!-- ************************************************************************** --><p>Publication as a Working Draft
does not imply endorsement by the W3C Membership. 
This is a draft document and may be updated, replaced or obsoleted
by other documents at any time. 
It is inappropriate to cite this document as other than work in progress.</p><!-- ************************************************************************** --><!-- * Finally, all Status sections must end with the appropriate IPR para    * --><!-- *   This entity is defined in status-entities.dtd                        * --><!-- ************************************************************************** --><p>This document was produced by groups operating under the
   <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Consortium/Patent-Policy-20040205/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">5 February 2004
   W3C Patent Policy</loc>.
   W3C maintains a <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2004/01/pp-impl/18797/status#disclosures" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public list of any 
   patent disclosures</loc> made in connection with the deliverables of the 
   XML Query Working Group and also maintains a <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2004/01/pp-impl/19552/status#disclosures" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public list of any patent 
   disclosures</loc> made in connection with the deliverables of the XSL 
   Working Group; those pages also include instructions for
   disclosing a patent.
   An individual who has actual knowledge of a patent which the individual believes
   contains
   <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Essential Claim(s)</loc>
   must disclose the information in accordance with
   <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">section 6 of the W3C Patent Policy</loc>. </p></status><langusage><language id="EN">English</language></langusage><revisiondesc><p/></revisiondesc></header><body><div1 id="intro"><head>Introduction</head><p>The purpose of this document is to catalog the functions and operators required for
                XPath 2.0, XML Query 1.0 and XSLT 2.0. The exact syntax used to call these
                functions and operators is specified in <bibref ref="xpath20"/>, <bibref ref="xquery"/> and <bibref ref="xslt20"/>. </p><p>This document defines constructor functions and functions that take typed values as
                arguments. Some of the functions define the semantics of operators discussed in
                    <bibref ref="xquery"/>.</p><p>
                <bibref ref="xmlschema-2"/> defines a number of primitive and derived datatypes,
                collectively known as built-in datatypes. This document defines functions and
                operations on these datatypes as well as the datatypes defined in <xspecref spec="DM" ref="types"/> of the <bibref ref="xpath-datamodel-11"/>.
                These functions and operations are defined for use in <bibref ref="xpath20"/>,
                    <bibref ref="xquery"/> and <bibref ref="xslt20"/> and related XML standards. This
                document also defines functions and operators on nodes and node sequences as
                defined in the <bibref ref="xpath-datamodel-11"/> for use in <bibref ref="xpath20"/>, <bibref ref="xquery"/> and <bibref ref="xslt20"/> and other related XML standards. </p><p>References to specific sections of some of the above documents are indicated by
                cross-document links in this document. Each such link consists of a pointer to a
                specific section followed a superscript specifying the linked document. The
                superscripts have the following meanings: 'XQ' <bibref ref="xquery"/>, 'XT' <bibref ref="xslt20"/>, 'XP' <bibref ref="xpath20"/>, 'DM' <bibref ref="xpath-datamodel-11"/> and 'FS'
                    <bibref ref="xquery-semantics"/>.</p><div2 id="conformance"><head>Conformance</head><p>
The Functions and Operators specification is intended primarily as a
component that can be used by other specifications. Therefore, Functions
and Operators relies on specifications that use it (such as 
<bibref ref="xpath20"/>, <bibref ref="xslt20"/> and <bibref ref="xquery"/>)
to specify conformance criteria for their respective environments.</p><p>
Authors of conformance criteria for the use of the Functions and
Operators should pay particular attention to the following features:</p><ulist><item><p>It is <termref def="implementation-defined"/> which version of Unicode is supported, 
                     but it is recommended that the most recent version of Unicode be used.  </p></item><item><p diff="add" at="A">It is <termref def="implementation-defined"/> whether the type system is based
                     on XML Schema 1.0 or XML Schema 1.1.  </p></item><item><p>Support for XML 1.0 and XML 1.1 by the datatypes used in Functions and Operators.</p></item></ulist><note diff="chg" at="A"><p>At the time of writing there is a Candidate Recommendation of XML Schema 1.1
                  that introduces some new data types including <code>xs:precisionDecimal</code>
                  and <code>xs:dateTimeStamp</code>. This specification provides some limited support
                  for the latter, but does not yet include support for <code>xs:precisionDecimal</code>.
                  This is likely to come in a later draft of this specification. Furthermore, XSD 1.1
                  includes the option of supporting revised definitions of types such as <code>xs:NCName</code>
                  based on the rules in XML 1.1 rather than 1.0. The rules affecting
                  support for XSD 1.0 versus XSD 1.1 and XML 1.0 versus XML 1.1 are likely to be refined
                  in later drafts of this specification.</p></note><p diff="add" at="A-E43">In this document, text labeled as an example or as a Note is
            provided for explanatory purposes and is not normative.</p></div2><div2 id="namespace-prefixes" diff="chg" at="B"><head>Namespaces and prefixes</head><p>The functions and operators discussed in this document are contained in one of
                    several namespaces (see <bibref ref="REC-xml-names"/>) and referenced using an
                    <code>xs:QName</code>.</p><p>This document uses conventional prefixes to refer to these namespaces. User-written
               applications can choose a different prefix to refer to the namespace, so long as it is
               bound to the correct URI. The host language may also define a default namespace for
               function calls, in which case function names in that namespace need not be prefixed
               at all. In many cases the default namespace will be 
               <code>http://www.w3.org/2005/xpath-functions</code>, allowing a call on the <code>fn:name</code>
               function (for example) to be written as <code>name()</code> rather than <code>fn:name()</code>; 
               in this document, however, all example function calls are explicitly prefixed.</p><p>The URIs of the namespaces and the conventional prefixes associated with them are:</p><ulist><item><p><code>http://www.w3.org/2001/XMLSchema</code> for constructors --
                            associated with <code>xs</code>.
                  </p><p>The datatypes and constructor functions for the built-in datatypes defined
                     in <bibref ref="xmlschema-2"/> and in <xspecref spec="DM" ref="types"/>
                     of <bibref ref="xpath-datamodel-11"/> and discussed in <specref ref="constructor-functions"/>  are in the XML Schema namespace, <code>http://www.w3.org/2001/XMLSchema</code>,
                     and named in this document using the <code>xs</code> prefix. </p></item><item><p><code>http://www.w3.org/2005/xpath-functions</code>
                     for functions — associated with <code>fn</code>. </p><p>The namespace
                     prefix used in this document for most functions that are available to users is
                     <code>fn</code>.</p></item><item><p><code>http://www.w3.org/2005/xpath-functions/math</code>
                     for functions — associated with <code>math</code>. </p><p>This namespace is used for some mathematical functions. The namespace
                     prefix used in this document for these functions is <code>math</code>.
                     These functions are available to users in exactly the same way as those in the
                     <code>fn</code> namespace.</p></item><item><p><code>http://www.w3.org/2005/xqt-errors</code> — associated with
                            <code>err</code>. </p><p>There are no functions in this namespace; it is used for error codes.</p><p>This document uses the prefix <code>err</code> to represent the namespace URI 
                     <code>http://www.w3.org/2005/xqt-errors</code>, which is the namespace for all XPath 
                     and XQuery error codes and messages. This namespace prefix is not predeclared and 
                     its use in this document is not normative.</p><note><p>The namespace URI associated with the <code>err</code> prefix is not
                        expected to change from one version of this document to another. The
                        contents of this namespace may be extended to allow additional errors to be returned.</p></note></item><item><p>
                     Functions defined with the <code>op</code> prefix are described here to
                     underpin the definitions of the operators in <bibref ref="xpath20"/>, <bibref ref="xquery"/> and <bibref ref="xslt20"/>. These functions are not available
                     directly to users, and there is no requirement that implementations should
                     actually provide these functions. For this reason, no namespace is associated
                     with the <code>op</code> prefix. For example, multiplication is generally
                     associated with the <code>*</code> operator, but it is described as a function
                     in this document:</p><example role="signature"><proto role="example" name="numeric-multiply" return-type="numeric" isOp="yes" returnEmptyOk="no" returnSeq="no" prefix="fn" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no"><arg name="arg1" type="numeric"/><arg name="arg2" type="numeric"/></proto></example></item></ulist></div2><div2 id="func-overloading"><head>Function overloading</head><p> In general, the specifications named above do not support function overloading
                    in the sense that functions that have multiple signatures with the same name and
                    the same number of parameters are not supported. Consequently, there are no such
                    overloaded functions in this document except for legacy <bibref ref="xpath"/>
                    functions such as <code>fn:string</code>, which accepts a single parameter of
                    a variety of types. In addition, it should be noted that the functions defined
                    in <specref ref="numeric-functions"/> that accept <code>numeric</code>
                    parameters accept arguments of type <code>xs:integer</code>,
                    <code>xs:decimal</code>, <code>xs:float</code> or <code>xs:double</code>. See
                        <specref ref="func-signatures"/>. Operators such as "+" may be overloaded.
                    This document does define some functions with more than one signature with the
                    same name and different number of parameters. User-defined functions with more
                    than one signature with the same name and different number of parameters are
                    also supported. </p></div2><div2 id="func-signatures"><head>Function signatures and descriptions</head><p>Each function is defined by specifying its signature, a description of the return
                    type and each of the parameters and its semantics. For many functions, examples
                    are included to illustrate their use. </p><p>Each function's signature is presented in a form like this:</p><example role="signature"><proto role="example" name="function-name" return-type="return-type" returnEmptyOk="no" returnSeq="no" prefix="fn" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="parameter-name" type="parameter-type"/><arg name="..." type=""/></proto></example><p>In this notation, <term>function-name</term>, in bold-face, is the name of the
                    function whose signature is being specified. If the function takes no
                    parameters, then the name is followed by an empty parameter list:
                    "<code>()</code>"; otherwise, the name is followed by a parenthesized list of
                    parameter declarations, each declaration specifies the static type of the
                    parameter, in italics, and a descriptive, but non-normative, name. If there are
                    two or more parameter declarations, they are separated by a comma. The <emph>
                        <code>return-type</code>
                    </emph>, also in italics, specifies the static type of the value returned by the
                    function. The dynamic type of the value returned by the function is the same as its static
                    type or derived from the static type. All parameter types and return types are
                    specified using the SequenceType notation defined in <xspecref spec="XP" ref="id-sequencetype-syntax"/>.</p><p diff="add" at="B">One function, <code>fn:concat</code>, has a variable number of arguments (two or more).
            More strictly, there is an infinite set of functions having the name <code>fn:concat</code>, with arity
            ranging from 2 to infinity. For this special case, a single function signature is given, with an ellipsis
            indicating an indefinite number of arguments.</p><p>In some cases the word <quote>
                        <code>numeric</code>
                    </quote> is used in function signatures as a shorthand to indicate the four
                    numeric types: <code>xs:integer</code>, <code>xs:decimal</code>,
                    <code>xs:float</code> and <code>xs:double</code>. For example, a function with
                    the signature:</p><example role="signature"><proto role="example" name="numeric-function" return-type="..." returnEmptyOk="no" returnSeq="no" prefix="fn" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="numeric"/></proto></example><p>represents the following four function signatures:</p><example role="signature"><proto role="example" name="numeric-function" return-type="..." returnEmptyOk="no" returnSeq="no" prefix="fn" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:integer"/></proto></example><example role="signature"><proto role="example" name="numeric-function" return-type="..." returnEmptyOk="no" returnSeq="no" prefix="fn" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:decimal"/></proto></example><example role="signature"><proto role="example" name="numeric-function" return-type="..." returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" prefix="fn"><arg name="arg" type="xs:float"/></proto></example><example role="signature"><proto role="example" name="numeric-function" return-type="..." returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" prefix="fn"><arg name="arg" type="xs:double"/></proto></example><p>For most functions there is an initial paragraph describing what the function
                   does followed by semantic rules. These rules are meant to be followed in the
                   order that they appear in this document.</p><p diff="del" at="F">In some cases, the static type returned by a function depends on the type(s) of
                    its argument(s). These special functions are indicated by using <emph>
                        <term>bold italics</term>
                    </emph> for the return type. The semantic rules specifying the type of the value
                    returned are documented in the function definition. The rules are described more
                    formally in [the Formal Semantics].</p><p>The function name is a <code>QName</code> as defined in <bibref ref="xmlschema-2"/>
                    and must adhere to its syntactic conventions. Following <bibref ref="xpath"/>,
                    function names are composed of English words separated by hyphens,"-". If a
                    function name contains a <bibref ref="xmlschema-2"/> datatype name, it may have
                    intercapitalized spelling and is used in the function name as such. For example, <code>fn:timezone-from-dateTime</code>.</p><p>Rules for passing parameters to operators are described in the relevant sections
                    of <bibref ref="xquery"/> and <bibref ref="xpath20"/>. For example, the rules for
                    passing parameters to arithmetic operators are described in <xspecref spec="XP" ref="id-arithmetic"/>. Specifically, rules for parameters of
                    type <code>xs:untypedAtomic</code> and the empty sequence are specified in this section.</p><p>As is customary, the parameter type name indicates that the function or operator
                    accepts arguments of that type, or types derived from it, in that position. This
                    is called <emph>subtype substitution</emph> (See <xspecref spec="XP" ref="id-sequencetype-matching"/>). In addition, numeric type instances and
                    instances of type <code>xs:anyURI</code> can be promoted to produce an argument
                    of the required type. (See <xspecref spec="XP" ref="promotion"/>).</p><olist><item><p><emph>Subtype Substitution</emph>: A derived type may substitute for
                                its base type. In particular, <code>xs:integer</code> may be used
                                where <code>xs:decimal</code> is expected.</p></item><item><p><emph>Numeric Type Promotion</emph>: <code>xs:decimal</code> may be
                                promoted to <code>xs:float</code> or <code>xs:double</code>. 
								Promotion to <code>xs:double</code> should be done directly, not via
								 <code>xs:float</code>, to avoid loss of precision.</p></item><item><p><emph>anyURI Type Promotion</emph>: A value of
                                type <code>xs:anyURI</code> can be promoted to the
                                type <code>xs:string</code>. </p></item></olist><p>Some functions accept a single value or the empty sequence as an argument and
                    some may return a single value or the empty sequence. This is indicated in the
                    function signature by following the parameter or return type name with a
                    question mark: "<code>?</code>", indicating that either a single value or the
                    empty sequence must appear. See below.</p><example role="signature"><proto role="example" name="function-name" return-type="return-type" returnEmptyOk="yes" returnSeq="no" prefix="fn" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="parameter-name" type="parameter-type" emptyOk="yes"/></proto></example><p>Note that this function signature is different from a signature in which the
                    parameter is omitted. See, for example, the two signatures
                    for <code>fn:string</code>. In the first signature, the parameter is omitted
                    and the argument defaults to the context item, referred to as <quote>.</quote>.
                    In the second signature, the argument must be present but may be the empty
                    sequence, referred to as <quote>().</quote>
                </p><p>Some functions accept a sequence of zero or more values as an argument. This is
                    indicated by following the name of type of the items in the sequence with
                    <code>*</code>. The sequence may contain zero or more items of the named type.
                    For example, the function below accepts a sequence of <code>xs:double</code> and
                    returns a <code>xs:double</code> or the empty sequence.</p><example role="signature"><proto role="example" name="median" return-type="xs:double" returnEmptyOk="yes" returnSeq="no" prefix="fn" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:double*" emptyOk="no"/></proto></example></div2><!-- Jim: New text to correspond to new graphics, analogous to new material in XDM 1.1, 2009-10-24 --><div2 id="datatypes"><head>Type system</head><p>The diagrams below show how nodes, function items,
primitive simple types, and user defined types fit together into a type system.
This type system comprises two distinct hierarchies that both include
the primitive simple types. 
In the diagrams, connecting lines represent relationships between derived types
and the types from which they are derived;
the arrowheads point toward the type from which they are derived. 
The dashed line represents relationships not present in this diagram,
but that appear in one of the other diagrams. 
Dotted lines represent additional relationships that follow an evident pattern.
The information that appears in each diagram is recapitulated in tabular form.
</p><p>The <code>xs:IDREFS</code>, <code>xs:NMTOKENS</code>, and
<code>xs:ENTITIES</code> types and the <code>user-defined list and union types</code>
are special types in that these types are lists or unions
rather than types derived by extension or restriction.</p><p>The first diagram and its corresponding table illustrate
the <quote>item</quote> type hierarchy. 
In XDM, items include node types, function types, and built-in atomic types. </p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="XPathTypeHierarchy-1-items.png" alt="Type hierarchy graphic, item hierarchy" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p>In the table, each type whose name is indented is derived from the type
whose name appears nearest above it with one less level of indentation.</p><table border="0" summary="Type summary" role="hierarchy"><tbody><tr><td rowspan="1" colspan="1">item</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">xs:anyAtomicType</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">node</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">attribute</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">user-defined attribute types</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">comment</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">document</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">user-defined document types</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">element</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">user-defined element types</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">processing-instruction</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">text</td></tr></tbody></table><p>The next diagram and table illustrate the <quote>any type</quote> type hierarchy, in which
all types are derived from distinguished type <code>xs:anyType</code>. </p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="XPathTypeHierarchy-2-anyTypes.png" alt="Type hierarchy graphic, anyType hierarchy" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p>In the table, each type whose name is indented is derived from the type
whose name appears nearest above it with one less level of indentation.</p><table border="0" summary="Type summary" role="hierarchy"><tbody><tr><td rowspan="1" colspan="1">xs:anyType</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">user-defined complex types</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">xs:untyped</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">xs:anySimpleType</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">user-defined list and union types</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">xs:IDREFS</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">xs:NMTOKENS</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">xs:ENTITIES</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">xs:anyAtomicType</td></tr></tbody></table><p>The final diagram and table show all of the atomic types, including the primitive simple types and the
built-in types derived from the primitive simple types. 
This includes all the built-in datatypes defined in <bibref ref="xmlschema-2"/>
as well as the two totally ordered subtypes of duration defined in <specref ref="duration-subtypes"/>.</p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="XPathTypeHierarchy-3-anyAtomicTypes.png" alt="Type hierarchy graphic, anyAtomicType hierarchy" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p>In the table, each type whose name is indented is derived from the type
whose name appears nearest above it with one less level of indentation.</p><table border="0" summary="Type summary" role="hierarchy"><tbody><tr><td rowspan="1" colspan="1">xs:untypedAtomic</td></tr><tr><td rowspan="1" colspan="1">xs:dateTime</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">xs:dateTimeStamp</td></tr><tr><td rowspan="1" colspan="1">xs:date</td></tr><tr><td rowspan="1" colspan="1">xs:time</td></tr><tr><td rowspan="1" colspan="1">xs:duration</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">xs:yearMonthDuration</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">xs:dayTimeDuration</td></tr><tr><td rowspan="1" colspan="1">xs:float</td></tr><tr><td rowspan="1" colspan="1">xs:double</td></tr><tr><td rowspan="1" colspan="1">xs:precisionDecimal</td></tr><tr><td rowspan="1" colspan="1">xs:decimal</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">xs:integer</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">xs:nonPositiveInteger</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">xs:negativeInteger</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">xs:long</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">xs:int</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">xs:short</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">xs:byte</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">xs:nonNegativeInteger</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">xs:unsignedLong</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">xs:unsignedInt</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">xs:unsignedShort</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">xs:unsignedByte</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">xs:positiveInteger</td></tr><tr><td rowspan="1" colspan="1">xs:gYearMonth</td></tr><tr><td rowspan="1" colspan="1">xs:gYear</td></tr><tr><td rowspan="1" colspan="1">xs:gMonthDay</td></tr><tr><td rowspan="1" colspan="1">xs:gDay</td></tr><tr><td rowspan="1" colspan="1">xs:gMonth</td></tr><tr><td rowspan="1" colspan="1">xs:string</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">xs:normalizedString</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">xs:token</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">xs:language</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">xs:NMTOKEN</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">xs:Name</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">xs:NCName</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">xs:ID</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">xs:IDREF</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">xs:ENTITY</td></tr><tr><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">xs:base64Binary</td></tr><tr><td rowspan="1" colspan="1">xs:hexBinary</td></tr><tr><td rowspan="1" colspan="1">xs:anyURI</td></tr><tr><td rowspan="1" colspan="1">xs:QName</td></tr><tr><td rowspan="1" colspan="1">xs:NOTATION</td></tr></tbody></table></div2><div2 id="terminology"><head>Terminology</head><p>The terminology used to describe the functions and operators on <bibref ref="xmlschema-2"/> is defined in the body of this specification. The terms defined
            in this section are used in building those definitions</p><div3 id="namespace-terminology"><head>Namespaces and URIs</head><p>This document uses the phrase "namespace URI" to identify the concept identified
                  in <bibref ref="REC-xml-names"/> as "namespace name", and the phrase "local name"
                  to identify the concept identified in <bibref ref="REC-xml-names"/> as "local part".</p><p>It also uses the term <quote>expanded-QName</quote> defined below.</p><p><termdef id="expanded-name" term="expanded-QName"> An <term>expanded-QName</term> is a pair of values consisting of a namespace URI
                  and a local name. They belong to the value space of the <bibref ref="xmlschema-2"/> datatype <code>xs:QName</code>. When this document
                  refers to <code>xs:QName</code> we always mean the value space, i.e.
                  a namespace URI, local name pair (and not the lexical space
                  referring to constructs of the form prefix:local-name).</termdef></p><p>The term URI is used as follows:</p><p><termdef id="dt-uri" term="URI">Within this specification, the term <term>URI</term> refers to Universal Resource Identifiers as
                  defined in <bibref ref="rfc3986"/> and extended in <bibref ref="rfc3987"/> with a new name <term>IRI</term>.  The term <term>URI   
                     Reference</term>, unless otherwise stated, refers to a string in the lexical space of the <code>xs:anyURI</code> datatype 
                  as defined in <bibref ref="xmlschema-2"/>.</termdef></p><note><p>
                     Note that this means, in practice, that where this 
                     specification requires a "URI Reference", an IRI as defined in <bibref ref="rfc3987"/> will be 
                     accepted, provided that other relevant specifications also permit an IRI. The term URI has been 
                     retained in preference to IRI to avoid introducing new names for concepts such as "Base URI" that 
                     are defined or referenced across the whole family of XML specifications.  Note also that the 
                     definition of <code>xs:anyURI</code> is a wider definition than the definition in <bibref ref="rfc3987"/>; 
                     for example it does not require non-ASCII characters to be escaped.
                  </p></note></div3><div3 id="conformance-terminology"><head>Conformance terminology</head><glist><gitem><label>
                            <termdef id="compatibility" term="for compatibility">
                                <term>for compatibility</term>
                            </termdef>
                        </label><def><p>A feature of this specification included to ensure that
                                implementations that use this feature remain compatible with <bibref ref="xpath"/>
                            </p></def></gitem><gitem><label>
                            <termdef id="may" term="may">
                                <term>may</term>
                            </termdef>
                        </label><def><p>Conforming documents and processors are permitted to, but need not,
                                behave as described. </p></def></gitem><gitem><label>
                            <termdef id="must" term="must">
                                <term>must</term>
                            </termdef>
                        </label><def><p>Conforming documents and processors are required to behave as
                                described; otherwise, they are either non-conformant or else in error.</p></def></gitem><gitem><label>
                            <termdef id="implementation-defined" term="implementation-defined">
                                <term>implementation-defined</term>
                            </termdef>
                        </label><def><p>Possibly differing between implementations, but specified and
                                documented by the implementor for each particular implementation.</p></def></gitem><gitem><label>
                            <termdef id="implementation-dependent" term="implementation dependent">
                                <term>implementation-dependent</term>
                            </termdef>
                        </label><def><p>Possibly differing between implementations, but not specified by this
                                or other W3C specification, and not required to be specified by the
                                implementor for any particular implementation. </p></def></gitem></glist></div3><div3 id="properties-of-functions" diff="chg" at="B"><head>Properties of functions</head><p>This section is concerned with the question of whether two calls on a function, with the same arguments, may
               produce different results.</p><p><termdef id="execution-scope" term="execution scope">Two function calls are said to be within the same
                  <term>execution scope</term> if the host environment defines them as such. 
                  In XSLT, any two calls executed during
                  the same transformation are in the same execution scope. In XQuery, any two calls
                  executed during the evaluation of a top-level expression are in the same execution scope. In other contexts,
                  the execution scope is specified by the host environment that invokes the
                  function library.</termdef></p><p>The following definition explains more precisely what it means for two function calls to return the same result:</p><p><termdef id="dt-identical" term="identical"/>Two values are
                  defined to be <term>identical</term> if they
                  contain the same number of items and the items are pairwise identical. Two items are identical
                  if and only if one of the following conditions applies:</p><ulist><item><p>Both items are atomic values, of precisely the same type, and the values are equal as defined using the <code>eq</code> operator,
                     using the Unicode codepoint collation when comparing strings</p></item><item><p>Both items are nodes, and represent the same node</p></item><item><p>Both items are function items, and have the same name (or absence of a name), arity, function signature, and closure</p></item></ulist><p>Some functions produce results that depend not only on their explicit arguments, but also on the static and dynamic context.</p><p><termdef id="dt-contextual" term="contextual">A function may have 
                  the property of being <term>contextual</term>: the result of such a
               function depends on the values of properties in the static and dynamic
               evaluation context as well as on the actual supplied arguments (if any).</termdef></p><p>Contextual functions fall into a number of categories:</p><olist><item><p>The functions <code>fn:current-date</code>, <code>fn:current-dateTime</code>, <code>fn:current-time</code>, <code>fn:implicit-timezone</code>,
               <code>fn:adjust-date-to-timezone</code>, <code>fn:adjust-dateTime-to-timezone</code>, and
               <code>fn:adjust-time-to-timezone</code> depend on properties of the dynamic context that are
               fixed within the <termref def="execution-scope">execution scope</termref>. The same applies to a
               number of functions in the <code>op:</code> namespace that manipulate dates and times and
               that make use of the implicit timezone. These functions will return the same
               result if called repeatedly during a single <termref def="execution-scope">execution scope</termref>.</p></item><item><p>The functions <code>fn:position</code>, <code>fn:last</code>, <code>fn:id</code>, 
                     <code>fn:idref</code>, <code>fn:element-with-id</code>, <code>fn:lang</code>, <code>fn:local-name</code>,
               <code>fn:name</code>, <code>fn:namespace-uri</code>, <code>fn:normalize-space</code>, <code>fn:number</code>, <code>fn:root</code>, <code>fn:string</code>, and
               <code>fn:string-length</code> depend on the focus. These functions will in general return
               different results on different calls if the focus is different.</p></item><item><p>The function <code>fn:default-collation</code> and many string-handling operators and functions depend
               on the default collation and the in-scope collations, which are both properties
               of the static context. If a particular call of one of these functions is
               evaluated twice with the same arguments then it will return the same result
               each time (because the static context, by definition, does not change at run
               time). However, two distinct calls (that is, two calls on the function
               appearing in different places in the source code) may produce different results
               even if the explicit arguments are the same.</p></item><item><p>Functions such as <code>fn:static-base-uri</code>, <code>fn:doc</code>, and <code>fn:collection</code> depend on
               other aspects of the static context. As with functions that depend on
               collations, a single call will produce the same results on each call if the
               explicit arguments are the same, but two calls appearing in different places in
               the source code may produce different results.</p></item></olist><p><termdef id="dt-implicit-arguments" term="implicit argument">For a <termref def="dt-contextual">contextual</termref> function, 
                  the parts of the context on which it depends are
               referred to as <term>implicit arguments</term>.</termdef></p><p><termdef id="stable" term="stable">A function that is guaranteed to produce <termref def="dt-identical">identical</termref> results from repeated calls
               if the explicit and implicit arguments are identical is referred to as
               <term>stable</term>.</termdef></p><p>All functions defined in this specification are <termref def="stable">stable</termref> unless otherwise stated.
               Exceptions include the following:</p><ulist><item><p>Some functions (such as <code>fn:distinct-values</code> and <code>fn:unordered</code>) produce results in an
                  <termref def="implementation-defined">implementation-defined</termref> or 
                  <termref def="implementation-dependent">implementation-dependent</termref>order. In such cases there is no guarantee that the
               order of results from different calls will be the same. These functions are
               said to be <term>ordering-unstable</term>.</p></item><item><p>The function <code>fn:analyze-string</code> constructs an element node to
               represent its results. There is no guarantee that repeated calls with the same
               arguments will return the same identical node (in the sense of the <code>is</code>
               operator). Such a function is said to be <term>identity-unstable</term>.</p></item><item><p>Some functions (such as <code>fn:doc</code> and <code>fn:collection</code>) create new nodes by reading external
               documents. Such functions are guaranteed to be <termref def="stable">stable</termref> with the exception that
               an implementation is allowed to make them unstable as a user option.</p></item></ulist><p>Where the results of a function are described as being (to a greater or lesser
                  extent) <termref def="implementation-defined">implementation-defined</termref> or 
                  <termref def="implementation-dependent">implementation-dependent</termref>, this does not by
               itself remove the requirement that the results should be stable: that is, that
               repeated calls with the same explicit and implicit arguments <rfc2119>must</rfc2119> return
               identical results.</p></div3></div2></div1><div1 id="accessors"><head>Accessors</head><p>Accessors and their semantics are described in <bibref ref="xpath-datamodel-11"/>. Some of
                these accessors are exposed to the user through the functions described below.</p><table border="1" width="80%" summary="Function summary"><col width="25%" span="1"/><col width="25%" span="1"/><col width="25%" span="1"/><col width="25%" span="1"/><thead><tr><th rowspan="1" colspan="1">Function</th><th rowspan="1" colspan="1">Accessor</th><th rowspan="1" colspan="1">Accepts</th><th rowspan="1" colspan="1">Returns</th></tr></thead><tbody><tr><td rowspan="1" colspan="1">
                            <code>fn:node-name</code>
                        </td><td rowspan="1" colspan="1">
                            <code>node-name</code>
                        </td><td rowspan="1" colspan="1">an optional node</td><td rowspan="1" colspan="1">zero or one <code>xs:QName</code>
                        </td></tr><tr><td rowspan="1" colspan="1">
                            <code>fn:nilled</code>
                        </td><td rowspan="1" colspan="1">
                            <code>nilled</code>
                        </td><td rowspan="1" colspan="1">a node</td><td rowspan="1" colspan="1">an optional <code>xs:boolean</code>
                        </td></tr><tr><td rowspan="1" colspan="1">
                            <code>fn:string</code>
                        </td><td rowspan="1" colspan="1">
                            <code>string-value</code>
                        </td><td rowspan="1" colspan="1">an optional item or no argument</td><td rowspan="1" colspan="1">
                            <code>xs:string</code>
                        </td></tr><tr><td rowspan="1" colspan="1">
                            <code>fn:data</code>
                        </td><td rowspan="1" colspan="1">
                            <code>typed-value</code>
                        </td><td rowspan="1" colspan="1">zero or more items</td><!-- Don Chamberlin email, 2002-07-27 --><td rowspan="1" colspan="1">a sequence of atomic values</td></tr><tr><td rowspan="1" colspan="1">
                            <code>fn:base-uri</code>
                        </td><td rowspan="1" colspan="1">
                            <code>base-uri</code>
                        </td><td rowspan="1" colspan="1">an optional node or no argument</td><td rowspan="1" colspan="1">zero or one <code>xs:anyURI</code>
                        </td></tr><tr><td rowspan="1" colspan="1">
                            <code>fn:document-uri</code>
                        </td><td rowspan="1" colspan="1">
                            <code>document-uri</code>
                        </td><td rowspan="1" colspan="1">an optional node</td><td rowspan="1" colspan="1">zero or one <code>xs:anyURI</code>
                        </td></tr></tbody></table><div2 id="func-node-name"><head><?function fn:node-name?></head></div2><div2 id="func-nilled"><head><?function fn:nilled?></head></div2><div2 id="func-string"><head><?function fn:string?></head></div2><div2 id="func-data"><head><?function fn:data?></head></div2><div2 id="func-base-uri"><head><?function fn:base-uri?></head></div2><div2 id="func-document-uri"><head><?function fn:document-uri?></head></div2></div1><div1 id="errors-and-diagnostics"><head>Errors and diagnostics</head><div2 id="errors"><head>Raising errors</head><p>In this document, as well as in <bibref ref="xquery"/>, <bibref ref="xpath20"/>, and
	                    <bibref ref="xquery-semantics"/>, the phrase <quote>an error is raised</quote>
	                is used. Raising an error is equivalent to calling the <code>fn:error</code>
	                function defined in this section with the provided error code.</p><p> The above phrase is normally accompanied by specification of a specific error, to
	                wit: <quote>an error is raised [<emph>error code</emph>]</quote>. Each error defined
	                in this document is identified by an <code>xs:QName</code> that is in the
	                <code>http://www.w3.org/2005/xqt-errors</code> namespace, represented in this document by the <code>err</code> prefix. It is this
	                <code>xs:QName</code> that is actually passed as an argument to the
	                <code>fn:error</code> function. Calling this function raises an error.  For a
	                more detailed treatment of error handing, see <xspecref spec="XP" ref="id-handling-dynamic"/><phrase diff="del" at="F"> and [Formal Semantics]</phrase>.</p><p>The <code>fn:error</code> function is a general function that may be called as above
	                but may also be called from <bibref ref="xquery"/> or <bibref ref="xpath20"/>
	                applications with, for example, an <code>xs:QName</code> argument. </p><div3 id="func-error"><head><?function fn:error?></head></div3></div2><div2 id="diagnostics"><head>Diagnostic tracing</head><div3 id="func-trace"><head><?function fn:trace?></head></div3></div2></div1><div1 id="numeric-functions"><head>Functions and operators on numerics</head><p>This section specifies arithmetic operators on the numeric datatypes defined in
                    <bibref ref="xmlschema-2"/>. It uses an approach that permits lightweight
                implementation whenever possible. </p><div2 id="numeric-types"><head>Numeric types</head><p>The operators described in this section are defined on the following numeric
                    types. Each type whose name is indented is derived from the type whose name
                    appears nearest above with one less level of indentation.</p><table border="0" width="288" summary="Numeric types" role="hierarchy"><tbody><tr><td rowspan="1" colspan="1">xs:decimal</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">xs:integer</td></tr><tr><td rowspan="1" colspan="1">xs:float</td></tr><tr><td rowspan="1" colspan="1">xs:double</td></tr></tbody></table><p>They also apply to types derived by restriction from the above types. </p><note><p>
This specification uses  <bibref ref="ieee754"/> arithmetic for <code>xs:float</code> and <code>xs:double</code> values.
<phrase diff="add" at="F">One consequence of this is that some operations result in the value <code>NaN</code> (not-a number), which
has the unusual property that it is not equal to itself. Another consequence is that some operations return the value negative zero.</phrase>                  
This differs from <bibref ref="xmlschema-2"/> which defines
<code>NaN</code> as being equal to itself and defines only a single zero in the value space.
 The text accompanying several functions defines behavior for both positive and negative zero inputs and outputs 
 in the interest of alignment with <bibref ref="ieee754"/>. <phrase diff="add" at="F">A conformant implementation must
 respect these semantics. In consequence, the expression <code>-0.0e0</code> (which is actually a unary minus operator 
    applied to an <code>xs:double</code> value) will always return negative zero: see <specref ref="func-numeric-unary-minus"/>. 
    As a concession to implementations that rely on implementations of XSD 1.0, however, when casting from string to double
 the lexical form <code>-0</code> <rfc2119>may</rfc2119> be converted to positive zero, though negative zero
 is <rfc2119>recommended</rfc2119>.</phrase>
</p><p diff="chg" at="F">XML Schema 1.1 introduces support for positive and negative zero as distinct values, and also uses the <bibref ref="ieee754"/>
               semantics for comparisons involving <code>NaN</code>.</p></note></div2><div2 id="op.numeric"><head>Arithmetic operators on numeric values</head><p>The following functions define the semantics of arithmetic operators defined in 
			<bibref ref="xquery"/> and <bibref ref="xpath20"/> on these numeric types. </p><table border="1" summary="Operator summary"><thead><tr><th rowspan="1" colspan="1">Operators</th><th rowspan="1" colspan="1">Meaning</th></tr></thead><tbody><tr><td rowspan="1" colspan="1">
                                <code>op:numeric-add</code>
                            </td><td rowspan="1" colspan="1">Addition</td></tr><tr><td rowspan="1" colspan="1">
                                <code>op:numeric-subtract</code>
                            </td><td rowspan="1" colspan="1">Subtraction</td></tr><tr><td rowspan="1" colspan="1">
                                <code>op:numeric-multiply</code>
                            </td><td rowspan="1" colspan="1">Multiplication</td></tr><tr><td rowspan="1" colspan="1">
                                <code>op:numeric-divide</code>
                            </td><td rowspan="1" colspan="1">Division</td></tr><tr><td rowspan="1" colspan="1">
                                <code>op:numeric-integer-divide</code>
                            </td><td rowspan="1" colspan="1">Integer division</td></tr><tr><td rowspan="1" colspan="1">
                                <code>op:numeric-mod</code>
                            </td><td rowspan="1" colspan="1">Modulus</td></tr><tr><td rowspan="1" colspan="1">
                                <code>op:numeric-unary-plus</code>
                            </td><td rowspan="1" colspan="1">Unary plus</td></tr><tr><td rowspan="1" colspan="1">
                                <code>op:numeric-unary-minus</code>
                            </td><td rowspan="1" colspan="1">Unary minus (negation)</td></tr></tbody></table><p>The parameters and return types for the above operators are the basic numeric
                    types: <code>xs:integer</code>, <code>xs:decimal</code>, <code>xs:float</code>
                    and <code>xs:double</code>, and types derived from them. The word <quote>
                  <code>numeric</code>
               </quote> in function signatures signifies these four types. For simplicity, each
                    operator is defined to operate on operands of the same type and return the same
                    type. The exceptions are <code>op:numeric-divide</code>, which returns
                    an <code>xs:decimal</code> if called with two <code>xs:integer</code> operands
                    and <code>op:numeric-integer-divide</code> which always returns an <code>xs:integer</code>.</p><p>If the two operands are not of the same type, <emph>subtype substitution</emph>
                    and <emph>numeric type promotion</emph> are used to obtain two operands of the
                    same type. <xspecref spec="XP" ref="promotion"/> and <xspecref spec="XP" ref="mapping"/> describe the semantics of these operations in
                    detail. </p><p>The result type of operations depends on their argument datatypes and is defined
                    in the following table:</p><table border="1" summary="Function/operator summary"><col width="50%" span="1"/><col width="50%" span="1"/><thead><tr><th rowspan="1" colspan="1">Operator</th><th rowspan="1" colspan="1">Returns</th></tr></thead><tbody><tr><td rowspan="1" colspan="1">
                                <code>op:operation(xs:integer, xs:integer)</code>
                            </td><td rowspan="1" colspan="1">
                                <code>xs:integer</code> (except for <code>op:numeric-divide(integer,
                                integer)</code>, which returns <code>xs:decimal</code>)</td></tr><tr><td rowspan="1" colspan="1">
                                <code>op:operation(xs:decimal, xs:decimal)</code>
                            </td><td rowspan="1" colspan="1">
                                <code>xs:decimal</code>
                            </td></tr><tr><td rowspan="1" colspan="1">
                                <code>op:operation(xs:float, xs:float)</code>
                            </td><td rowspan="1" colspan="1">
                                <code>xs:float</code>
                            </td></tr><tr><td rowspan="1" colspan="1">
                                <code>op:operation(xs:double, xs:double)</code>
                            </td><td rowspan="1" colspan="1">
                                <code>xs:double</code>
                            </td></tr><tr><td rowspan="1" colspan="1">
                                <code>op:operation(xs:integer)</code>
                            </td><td rowspan="1" colspan="1">
                                <code>xs:integer</code>
                            </td></tr><tr><td rowspan="1" colspan="1">
                                <code>op:operation(xs:decimal)</code>
                            </td><td rowspan="1" colspan="1">
                                <code>xs:decimal</code>
                            </td></tr><tr><td rowspan="1" colspan="1">
                                <code>op:operation(xs:float)</code>
                            </td><td rowspan="1" colspan="1">
                                <code>xs:float</code>
                            </td></tr><tr><td rowspan="1" colspan="1">
                                <code>op:operation(xs:double)</code>
                            </td><td rowspan="1" colspan="1">
                                <code>xs:double</code>
                            </td></tr></tbody></table><p>These rules define any operation on any pair of arithmetic types. Consider the
                    following example:</p><eg xml:space="preserve">op:operation(xs:int, xs:double) =&gt; op:operation(xs:double, xs:double)</eg><p>For this operation, <code>xs:int</code> must be converted to
                    <code>xs:double</code>. This can be done, since by the rules above:
                    <code>xs:int</code> can be substituted for <code>xs:integer</code>,
                    <code>xs:integer</code> can be substituted for <code>xs:decimal</code>,
                    <code>xs:decimal</code> can be promoted to <code>xs:double</code>. As far as possible, the promotions should be done in a
                    single step. Specifically, when an <code>xs:decimal</code> is promoted to an
                    <code>xs:double</code>, it should not be converted to an <code>xs:float</code>
                    and then to <code>xs:double</code>, as this risks loss of precision.</p><p>As another example, a user may define <code>height</code> as a derived type of
                    <code>xs:integer</code> with a minimum value of 20 and a maximum value of 100.
                    He may then derive <code>fenceHeight</code> using an enumeration to restrict the
                    permitted set of values to, say, 36, 48 and 60.</p><eg xml:space="preserve">op:operation(fenceHeight, xs:integer) =&gt; op:operation(xs:integer, xs:integer)</eg><p>
                    <code>fenceHeight</code> can be substituted for its base type
                    <code>height</code> and <code>height</code> can be substituted for its base type
                    <code>xs:integer</code>. </p><p diff="add" at="B">The basic rules for addition, subtraction, and multiplication
			of ordinary numbers are not set out in this specification; they are taken as given. In the case of <code>xs:double</code>
			and <code>xs:float</code> the rules are as defined in <bibref ref="ieee754"/>. The rules for handling
			division and modulus operations, as well as the rules for handling special values such as infinity and <code>NaN</code>,
			and exception conditions such as overflow and underflow, are described more explicitly since they are not necessarily obvious.</p><p>On overflow and underflow situations during arithmetic operations conforming
                    implementations <termref def="must"/> behave as follows:</p><ulist><item><p>For <code>xs:float</code> and <code>xs:double</code> operations, overflow
                            behavior <termref def="must"/> be conformant with <bibref ref="ieee754"/>. This specification allows the following options:</p><ulist><item><p>Raising an error <errorref class="AR" code="0002"/> via an
                                    overflow trap.</p></item><item><p>Returning <code>INF</code> or <code>-INF</code>.</p></item><item><p>Returning the largest (positive or negative) non-infinite number.</p></item></ulist></item><item><p>For <code>xs:float</code> and <code>xs:double</code> operations,
                            underflow behavior <termref def="must"/> be conformant with <bibref ref="ieee754"/>. This specification allows the following options:</p><ulist><item><p>Raising an error <errorref class="AR" code="0002"/> via an
                                    underflow trap.</p></item><item><p>Returning <code>0.0E0</code> or <code>+/- 2**Emin</code> or a
                                    denormalized value; where <code>Emin</code> is the smallest
                                    possible <code>xs:float</code> or <code>xs:double</code> exponent.</p></item></ulist></item><item><p>For <code>xs:decimal</code> operations, overflow behavior <termref def="must"/> raise an error <errorref class="AR" code="0002"/>. On
                            underflow, <code>0.0</code> must be returned.</p></item><item><p>For <code>xs:integer</code> operations, implementations that support
                            limited-precision integer operations <termref def="must"/> select from
                            the following options:</p><ulist><item><p> They <termref def="may"/> choose to always raise an
                                        error <errorref class="AR" code="0002"/>.</p></item><item><p> They <termref def="may"/> provide an <termref def="implementation-defined"/> mechanism that allows users to
                                    choose between raising an error and returning a result that is
                                    modulo the largest representable integer value. See <bibref ref="ISO10967"/>.</p></item></ulist></item></ulist><p>The functions <code>op:numeric-add</code>, <code>op:numeric-subtract</code>,
                    <code>op:numeric-multiply</code>, <code>op:numeric-divide</code>,
                    <code>op:numeric-integer-divide</code> and <code>op:numeric-mod</code> are each
                    defined for pairs of numeric operands, each of which has the same
                    type:<code>xs:integer</code>, <code>xs:decimal</code>, <code>xs:float</code>, or
                    <code>xs:double</code>. The functions <code>op:numeric-unary-plus</code> and
                    <code>op:numeric-unary-minus</code> are defined for a single operand whose type
                    is one of those same numeric types.</p><p> For <code>xs:float</code> and <code>xs:double</code> arguments, if either
                    argument is <code>NaN</code>, the result is <code>NaN</code>.</p><p>For <code>xs:decimal</code> values the number of digits of precision returned by
                    the numeric operators is <termref def="implementation-defined"/>. If the number
                    of digits in the result exceeds the number of digits that the implementation
                    supports, the result is truncated or rounded in an <termref def="implementation-defined"/> manner.</p><div3 id="func-numeric-add"><head><?function op:numeric-add?></head></div3><div3 id="func-numeric-subtract"><head><?function op:numeric-subtract?></head></div3><div3 id="func-numeric-multiply"><head><?function op:numeric-multiply?></head></div3><div3 id="func-numeric-divide"><head><?function op:numeric-divide?></head></div3><div3 id="func-numeric-integer-divide"><head><?function op:numeric-integer-divide?></head></div3><div3 id="func-numeric-mod"><head><?function op:numeric-mod?></head></div3><div3 id="func-numeric-unary-plus"><head><?function op:numeric-unary-plus?></head></div3><div3 id="func-numeric-unary-minus"><head><?function op:numeric-unary-minus?></head></div3></div2><div2 id="comp.numeric"><head>Comparison operators on numeric values</head><p>This specification defines the following comparison operators on numeric values.
                    Comparisons take two arguments of the same type. If the arguments are of
                    different types, one argument is promoted to the type of the other as described
                    above in <specref ref="op.numeric"/>. Each comparison operator returns a boolean
                    value. If either, or both, operands are <code>NaN</code>, <code>false</code> is
                    returned. </p><?local-function-index?><div3 id="func-numeric-equal"><head><?function op:numeric-equal?></head></div3><div3 id="func-numeric-less-than"><head><?function op:numeric-less-than?></head></div3><div3 id="func-numeric-greater-than"><head><?function op:numeric-greater-than?></head></div3></div2><div2 id="numeric-value-functions"><head>Functions on numeric values</head><p>The following functions are defined on numeric types. Each function returns a
                    value of the same type as the type of its argument.</p><ulist><item><p>If the argument is the empty sequence, the empty sequence is returned.</p></item><item><p>For <code>xs:float</code> and <code>xs:double</code> arguments, if the
                            argument is "NaN", "NaN" is returned.</p></item><item><p>Except for <code>fn:abs</code>, for <code>xs:float</code> and
                            <code>xs:double</code> arguments, if the argument is positive or
                            negative infinity, positive or negative infinity is returned.</p></item></ulist><?local-function-index?><note diff="add" at="A"><p><code>fn:round</code> and <code>fn:round-half-to-even</code> produce the same result in all cases
except when the argument is exactly midway between two values with the required precision.</p><p>Other ways of rounding midway values can be achieved as follows:</p><ulist><item><p>Towards negative infinity: <code>-fn:round(-$x)</code></p></item><item><p>Away from zero: <code>fn:round(fn:abs($x))*fn:compare($x,0)</code></p></item><item><p>Towards zero: <code>fn:abs(fn:round(-$x))*-fn:compare($x,0)</code></p></item></ulist></note><div3 id="func-abs"><head><?function fn:abs?></head></div3><div3 id="func-ceiling"><head><?function fn:ceiling?></head></div3><div3 id="func-floor"><head><?function fn:floor?></head></div3><div3 id="func-round" diff="chg" at="A"><head><?function fn:round?></head></div3><div3 id="func-round-half-to-even"><head><?function fn:round-half-to-even?></head></div3></div2><div2 id="formatting-integers" diff="add" at="A"><head>Formatting integers</head><div3 id="func-format-integer"><head><?function fn:format-integer?></head></div3></div2><div2 id="formatting-numbers" diff="add" at="A"><head>Formatting numbers</head><p>This section defines a function for formatting decimal and floating point numbers.</p><?local-function-index?><note><p>This function can be used to format any numeric quantity, including an integer. For integers, however,
		         the <code>fn:format-integer</code> function offers additional possibilities. Note also that the picture
		         strings used by the two functions are not 100% compatible, though they share some options in common.</p></note><div3 id="defining-decimal-format"><head>Defining a decimal format</head><p>Decimal formats are defined in the static context, and the way they are defined is therefore outside the scope
of this specification. XSLT and XQuery both provide custom syntax for creating a decimal format.</p><p>The static context provides a set of decimal formats. One of the decimal formats is unnamed, the others (if any)
are identified by a QName. There is always an unnamed decimal format available, but its contents are implementation-defined.</p><p>Each decimal format provides a set of named variables, described in the following table:</p><table border="1"><thead><tr><th rowspan="1" colspan="1">Name</th><th rowspan="1" colspan="1">Type</th><th rowspan="1" colspan="1">Usage (non-normative)</th></tr></thead><tbody><tr><td valign="top" rowspan="1" colspan="1">decimal-separator-sign</td><td valign="top" rowspan="1" colspan="1">A single character</td><td valign="top" rowspan="1" colspan="1">Defines the character used to represent the decimal point (typically ".") both in the picture string and in the formatted number</td></tr><tr><td valign="top" rowspan="1" colspan="1">grouping-separator-sign</td><td valign="top" rowspan="1" colspan="1">A single character</td><td valign="top" rowspan="1" colspan="1">Defines the character used to separate groups of digits (typically ",") both in the picture string and in the formatted number</td></tr><tr><td valign="top" rowspan="1" colspan="1">infinity</td><td valign="top" rowspan="1" colspan="1">A string</td><td valign="top" rowspan="1" colspan="1">Defines the string used to represent the value positive or negative infinity in the formatted number (typically "Infinity")</td></tr><tr><td valign="top" rowspan="1" colspan="1">minus-sign</td><td valign="top" rowspan="1" colspan="1">A single character</td><td valign="top" rowspan="1" colspan="1">Defines the character used as a minus sign in the formatted number if there is no subpicture for formatting negative numbers (typically "-", x2D)</td></tr><tr><td valign="top" rowspan="1" colspan="1">NaN</td><td rowspan="1" colspan="1"> valign="top"A string</td><td valign="top" rowspan="1" colspan="1">Defines the string used to represent the value <code>NaN</code> in the formatted number</td></tr><tr><td valign="top" rowspan="1" colspan="1">percent-sign</td><td valign="top" rowspan="1" colspan="1">A single character</td><td valign="top" rowspan="1" colspan="1">Defines the character used as a percent sign (typically "%") both in the picture string and in the formatted number</td></tr><tr><td valign="top" rowspan="1" colspan="1">per-mille-sign</td><td valign="top" rowspan="1" colspan="1">Defines the character used as a per-mille sign (typically "‰", x2030) both in the picture string and in the formatted number</td><td valign="top" rowspan="1" colspan="1"/></tr><tr><td valign="top" rowspan="1" colspan="1">mandatory-digit-sign</td><td valign="top" rowspan="1" colspan="1">A single character, which must be defined in Unicode as a digit<phrase diff="del" at="D"> with the value zero</phrase></td><td valign="top" rowspan="1" colspan="1">Defines the character (typically "0") used in the picture string to represent a mandatory digit, and in the formatted number to represent the digit zero; by
implication, this also defines the characters used to represent the digits one to nine.</td></tr><tr><td valign="top" rowspan="1" colspan="1">optional-digit-sign</td><td valign="top" rowspan="1" colspan="1">A single character</td><td valign="top" rowspan="1" colspan="1">Defines the character used in the picture string to represent an optional digit (typically "#")</td></tr><tr><td valign="top" rowspan="1" colspan="1">pattern-separator-sign</td><td rowspan="1" colspan="1"> valign="top"A single character</td><td valign="top" rowspan="1" colspan="1">Defines the character used in the picture string to separate the positive and negative subpictures (typically ";")</td></tr></tbody></table><p><termdef id="dt-decimal-digit-family" term="digit family">The <term>decimal digit family</term> of a decimal format 
is the sequence of ten digits with
consecutive Unicode codepoints starting with the <var>mandatory-digit-sign</var>.</termdef></p><p>It is a constraint that,
for any named or unnamed decimal format, the variables
representing characters used in a <termref def="dt-picture-string">picture string</termref>
must have distinct values. These variables are <var>decimal-separator-sign</var>,
<var>grouping-separator-sign</var>, <var>percent-sign</var>, <var>per-mille-sign</var>,
<var>optional-digit-sign</var>, and <var>pattern-separator-sign</var>.
Furthermore, none of these variables may be equal to any character in the 
<termref def="dt-decimal-digit-family">decimal digit family</termref>.

</p></div3><div3 id="func-format-number"><head><?function fn:format-number?></head></div3><div3 id="syntax-of-picture-string"><head>Syntax of the picture string</head><note><p>This differs from the <code>format-number</code> function previously defined in XSLT 2.0 in that
			   any digit can be used in the picture string to represent a mandatory digit: for example the picture
			   strings '000', '001', and '999' are equivalent. This is to align <code>format-number</code> 
			   (which previously used '000') with <code>format-dateTime</code> (which used '001').</p></note><p>
                  <termdef id="dt-picture-string" term="picture string">The formatting of a 
number is controlled by a <term>picture string</term>. The
picture string is a sequence of characters, in which the characters
assigned to the variables <var>decimal-separator-sign</var>, <var>grouping-sign</var>,
<var>decimal-digit-family</var>,
<var>optional-digit-sign</var> and <var>pattern-separator-sign</var> are classified as
active characters, and all other characters (including the <var>percent-sign</var> and 
<var>per-mille-sign</var>) are classified as passive characters.</termdef>
               </p><p>The <var>integer part</var> of the sub-picture is defined as the part that
appears to the left of the <var>decimal-separator-sign</var> if there is one, or the entire
sub-picture otherwise. The <var>fractional part</var> of the sub-picture is defined as the part that
appears to the right of the <var>decimal-separator-sign</var> if there is one; it is a zero-length
string otherwise.</p><p>An error is raised <errorref class="DF" code="1310"/> if the
 <termref def="dt-picture-string">picture string</termref> does not conform to the following rules. 
               Note that in these
rules the words "preceded" and "followed" refer to characters anywhere in the string, they
are not to be read as "immediately preceded" and "immediately followed".</p><ulist><item><p>A picture-string consists either of a sub-picture, or of
        two sub-pictures separated by a <var>pattern-separator-sign</var>. A picture-string
        <rfc2119>must not</rfc2119> contain more than one <var>pattern-separator-sign</var>. If the picture-string contains two
        sub-pictures, the first is used for positive values and the second for negative values.</p></item><item><p>A sub-picture <rfc2119>must not</rfc2119> contain more than one <var>decimal-separator-sign</var>.</p></item><item><p>A sub-picture <rfc2119>must not</rfc2119> contain more than one <var>percent-sign</var> or
        <var>per-mille-sign</var>, and it <rfc2119>must not</rfc2119> contain one of each.</p></item><item><p>A sub-picture <rfc2119>must</rfc2119> contain at least one character that is an 
					 <var>optional-digit-sign</var> or a member of the <var>decimal-digit-family</var>.</p></item><item><p>A sub-picture <rfc2119>must not</rfc2119> contain a passive character that is preceded by
        an active character and that is followed by another active character.</p></item><item><p>A sub-picture <rfc2119>must not</rfc2119> contain a <var>grouping-separator-sign</var> adjacent to a
        <var>decimal-separator-sign</var>.</p></item><item><p>The integer part of a sub-picture <rfc2119>must not</rfc2119> contain a member of the <var>decimal-digit-family</var> 
					 that is followed by
        an <var>optional-digit-sign</var>. The fractional part of a sub-picture <rfc2119>must not</rfc2119> contain an <var>optional-digit-sign</var>
        that is followed by a member of the <var>decimal-digit-family</var>.</p></item></ulist></div3><div3 id="analysing-picture-string"><head>Analysing the picture string</head><p>This phase of the algorithm analyses 
the <termref def="dt-picture-string">picture string</termref> and the variables from the selected
decimal format in the static context, and it has the effect
of setting the values of various variables, which are used in the
subsequent formatting phase. These variables are listed below.
Each is shown with its initial setting and its data type.
					</p><p>Several variables are associated with each sub-picture. If there are
two sub-pictures, then these rules are applied to one sub-picture to obtain the values
that apply to positive numbers, and to the other to obtain the values that apply
to negative numbers. If there is only one sub-picture, then the values for both cases
are derived from this sub-picture.</p><p>The variables are as follows:</p><ulist><item><p>The <var>integer-part-grouping-positions</var> is a sequence of integers
representing the positions of grouping separators within the integer part of the
sub-picture. For each <var>grouping-separator-sign</var> that appears within the
integer part of the sub-picture, this sequence contains an integer that is equal
to the total number of <var>optional-digit-sign</var> and <var>decimal-digit-family</var>
characters that appear within the integer part of the sub-picture and to the right of the 
<var>grouping-separator-sign</var>. In addition, if these
<var>integer-part-grouping-positions</var> are at regular intervals (that is, if they 
form a sequence <var>N</var>, <var>2N</var>, <var>3N</var>, ... 
for some integer value <var>N</var>, 
including the case where there is only one
number in the list), then the sequence contains all
integer multiples of <var>N</var> as far as necessary to accommodate the largest 
possible number.</p></item><item><p>The <var>minimum-integer-part-size</var> is an integer indicating the minimum number of digits that will
 appear to the left of the <var>decimal-separator-sign</var>. It is normally set to 
 the number of <var>decimal-digit-family</var> characters found in the integer part of the sub-picture.
 But if the sub-picture contains no <var>decimal-digit-family</var> character and no <var>decimal-separator-sign</var>,
 it is set to one.</p><note><p>There is no maximum integer part size. All significant digits in the integer part of the
 number will be displayed, even if this exceeds the number of <var>optional-digit-sign</var> and
 <var>decimal-digit-family</var> characters in the subpicture.</p></note></item><item><p>The <var>prefix</var> is set to contain all passive characters
in the sub-picture to the left of the leftmost active character.
If the picture string contains only one sub-picture, 
the <var>prefix</var> 
for the negative sub-picture is set by concatenating the <var>minus-sign</var> 
character and the <var>prefix</var> for the positive sub-picture (if any),
in that order.</p></item><item><p>The <var>fractional-part-grouping-positions</var> is a sequence of integers
representing the positions of grouping separators within the fractional part of the
sub-picture. For each <var>grouping-separator-sign</var> that appears within the
fractional part of the sub-picture, this sequence contains an integer that is equal
to the total number of <var>optional-digit-sign</var> and <var>decimal-digit-family</var> 
characters that appear within the fractional part of the sub-picture and to the left of the 
<var>grouping-separator-sign</var>.</p></item><item><p>The <var>minimum-fractional-part-size</var> is set to the number of 
<var>decimal-digit-family</var> characters found in the fractional part of the sub-picture.</p></item><item><p>The <var>maximum-fractional-part-size</var> is set to the total number of 
<var>optional-digit-sign</var> and <var>decimal-digit-family</var> characters found 
in the fractional part of the sub-picture.</p></item><item><p>The <var>suffix</var> is set to contain all passive characters to the right of the rightmost
active character in the fractional part of the sub-picture.</p></item></ulist><note><p>If there is only one sub-picture, then all variables
for positive numbers and negative numbers will be the same, except for  
<var>prefix</var>: the prefix for negative numbers will 
be preceded by the <var>minus-sign</var> character.</p></note></div3><div3 id="formatting-the-number"><head>Formatting the number</head><p>This section describes the second phase of processing of the
<function>format-number</function> function. This phase takes as input a number to be formatted
(referred to as the <emph>input number</emph>), and the variables set up by
analysing the decimal format in the static context and the
<termref def="dt-picture-string">picture string</termref>, as described above.
 The result of this phase is a string, which forms the return value of 
the <function>format-number</function> function.</p><p>The algorithm for this second stage of processing is as follows:</p><olist><item><p>If the input number is NaN (not a number), the result is the 
							 specified <var>NaN-symbol</var> (with no
<var>prefix</var> or <var>suffix</var>).</p></item><item><p>In the rules below, the positive sub-picture and its associated variables are used 
							 if the input number is positive, and the negative sub-picture and its associated
variables are used otherwise. Negative zero is taken as negative, positive zero as positive.</p></item><item><p>If the input number is positive or negative infinity, the result is the 
concatenation of the appropriate <var>prefix</var>, the <var>infinity-symbol</var>,
 and the appropriate <var>suffix</var>.</p></item><item><p>If the sub-picture contains a <var>percent-sign</var>, the number is multiplied 
by 100. If the sub-picture contains a <var>per-mille-sign</var>, the number is multiplied by 1000.
The resulting number is referred to below as the <var>adjusted number</var>.</p></item><item><p>The <var>adjusted number</var> is converted (if necessary) to
 an <code>xs:decimal</code> value,
using an implementation of <code>xs:decimal</code> that imposes no limits on the
<code>totalDigits</code> or <code>fractionDigits</code> facets. If there are several 
such values that
are numerically equal to the <var>adjusted number</var> (bearing in mind that if the
<var>adjusted number</var> is an <code>xs:double</code> or <code>xs:float</code>, the comparison will be done by
converting the decimal value back to an <code>xs:double</code> or <code>xs:float</code>), the one that
is chosen <rfc2119>should</rfc2119> be one with the smallest possible number of digits
not counting leading or trailing zeroes (whether significant or insignificant). 
For example, 1.0 is preferred to
0.9999999999, and 100000000 is preferred to 100000001. This value is then
rounded so that it uses no more than <code>maximum-fractional-part-size</code> digits in
its fractional part. The <var>rounded number</var> is defined to be the result of
converting the <var>adjusted number</var> to an <code>xs:decimal</code> value, as described above,
and then calling the function <function>fn:round-half-to-even</function> with this converted number
as the first argument and the <code>maximum-fractional-part-size</code> as the second
argument, again with no limits on the <code>totalDigits</code> or <code>fractionDigits</code> in the
result.</p></item><item><p>The absolute value of the <var>rounded number</var> is converted to a string in decimal notation, 
with no insignificant leading or trailing zeroes, using the
digits in the <var>decimal-digit-family</var> to represent the ten decimal digits,
and the <var>decimal-separator-sign</var> to separate the integer part and the fractional part.
(The value zero will at this stage be represented by a <var>decimal-separator-sign</var> on its own.)</p></item><item><p>If the number of digits to the left of the <var>decimal-separator-sign</var> is less than
<var>minimum-integer-part-size</var>, leading <var>zero-digit-sign</var> 
characters are added to pad out to that size.</p></item><item><p>If the number of digits to the right of the <var>decimal-separator-sign</var> is less than
<var>minimum-fractional-part-size</var>, trailing <var>zero-digit-sign</var> 
characters are added to pad out to that size.</p></item><item><p>For each integer <var>N</var> in the <var>integer-part-grouping-positions</var> list,  
a <var>grouping-separator-sign</var> character is inserted into the string immediately
after that digit that appears in the integer part of the number and has <var>N</var> digits
between it and the <var>decimal-separator-sign</var>, if there is such a digit.</p></item><item><p>For each integer <var>N</var> in the <var>fractional-part-grouping-positions</var> list,  
a <var>grouping-separator-sign</var> character is inserted into the string immediately
before that digit that appears in the fractional part of the number and has <var>N</var> digits
between it and the <var>decimal-separator-sign</var>, if there is such a digit.</p></item><item><p>If there is no <var>decimal-separator-sign</var> in the sub-picture, 
or if there are no digits to the right of the 
<var>decimal-separator-sign</var> character in the string, then the
<var>decimal-separator-sign</var> character is removed from the string (it will be the rightmost 
character in the string).</p></item><item><p>The result of the function is the concatenation of the appropriate <var>prefix</var>, the 
string conversion of the number as obtained above, and the appropriate <var>suffix</var>.</p></item></olist></div3></div2><div2 diff="add" at="A" id="trigonometry"><head>Trigonometric and other mathematical functions</head><p>The functions in this section perform trigonometric and other mathematical calculations on <code>xs:double</code> values. They
			are designed for use in applications performing geometrical computation, for example when generating SVG graphics.</p><p>Functions are provided to support the six most commonly used trigonometric calculations: sine, cosine and tangent, 
			and their inverses arc sine, arc cosine, and arc tangent. Other functions such as secant, cosecant, and cotangent are
			not provided because they are easily computed in terms of these six.</p><?local-function-index?><p><termdef id="either-side-of" term="either side of">In this section, when the rules for a function say that the returned
			value must be the <code>xs:double</code> <term>either side of</term> some
			mathematical quantity, then if the mathematical quantity is precisely representable in the value space of <code>xs:double</code> the
			exact result must be returned; otherwise
			it is acceptable to return either the nearest higher <code>xs:double</code> or the nearest lower <code>xs:double</code>, and
			it is <termref def="implementation-dependent">implementation-dependent</termref> which of the two is returned.</termdef></p><div3 id="func-pi"><head><?function math:pi?></head></div3><div3 id="func-sqrt"><head><?function math:sqrt?></head></div3><div3 id="func-sin"><head><?function math:sin?></head></div3><div3 id="func-cos"><head><?function math:cos?></head></div3><div3 id="func-tan"><head><?function math:tan?></head></div3><div3 id="func-asin"><head><?function math:asin?></head></div3><div3 id="func-acos"><head><?function math:acos?></head></div3><div3 id="func-atan"><head><?function math:atan?></head></div3></div2></div1><div1 id="string-functions"><head>Functions on strings</head><p>This section specifies functions and operators on the <bibref ref="xmlschema-2"/>
                <code>xs:string</code> datatype and the datatypes derived from it.</p><div2 id="string-types"><head>String types</head><p>The operators described in this section are defined on the following types. Each
                    type whose name is indented is derived from the type whose name appears nearest
                    above with one less level of indentation.</p><table border="0" summary="Type summary" role="hierarchy"><tbody><tr><td rowspan="1" colspan="1">xs:string</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">xs:normalizedString</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">xs:token</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">xs:language</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">xs:NMTOKEN</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">xs:Name</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">xs:NCName</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">xs:ID</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">xs:IDREF</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">xs:ENTITY</td></tr></tbody></table><p>They also apply to user-defined types derived by restriction from the above types. </p><p>It is <termref def="implementation-defined"/> which version of <bibref ref="Unicode4"/> is supported, but it is recommended that the most recent version of Unicode be used.</p><p>Unless explicitly stated, the <code>xs:string</code> values returned by the
                    functions in this document are not normalized in the sense of <bibref ref="charmod"/>.</p><notes><p> This document uses the term "codepoint" to mean the non-negative 
                  integer assigned to a character by the Unicode consortium. Equivalent terms found in other specifications are
                  "code point", "character number", or "code position". See <bibref ref="charmod"/>. 
                  The use of the word "character" in this document is in the sense of production [2] of <bibref ref="REC-xml"/>.  
                  <bibref ref="Unicode4"/>, defines codepoints that range from #x0000 to #x10FFFF inclusive and may include codepoints
                        that have not yet been assigned to characters.</p><p>In functions that involve character counting such
                        as <code>fn:substring</code>, <code>fn:string-length</code> and
                        <code>fn:translate</code>, what is counted is the number of XML characters
                        in the string (or equivalently, the number of Unicode codepoints). Some
                        implementations may represent a codepoint above xFFFF using two 16-bit
                        values known as a surrogate pair. A surrogate pair counts as one character, not two.</p></notes></div2><div2 id="func-assemble-disassemble-string"><head>Functions to assemble and disassemble strings</head><?local-function-index?><div3 id="func-codepoints-to-string"><head><?function fn:codepoints-to-string?></head></div3><div3 id="func-string-to-codepoints"><head><?function fn:string-to-codepoints?></head></div3></div2><div2 id="string-compare"><head>Comparison of strings</head><?local-function-index?><div3 id="collations"><head>Collations</head><p> A collation is a specification of the manner in which character strings are
                        compared and, by extension, ordered. When values whose type is
                        <code>xs:string</code> or a type derived from <code>xs:string</code> are
                        compared (or, equivalently, sorted), the comparisons are inherently
                        performed according to some collation (even if that collation is defined
                        entirely on codepoint values). The <bibref ref="charmod"/> observes that
                        some applications may require different comparison and ordering behaviors
                        than other applications. Similarly, some users having particular linguistic
                        expectations may require different behaviors than other users. Consequently,
                        the collation must be taken into account when comparing strings in any
                        context. Several functions in this and the following section make use of a
                        collation. </p><p>Collations can indicate that two different codepoints are, in fact, equal
                        for comparison purposes (e.g., "v" and "w" are considered equivalent in
                        some Swedish collations). Strings can be compared codepoint-by-codepoint or in a
                        linguistically appropriate manner, as defined by the collation. </p><p>Some collations, especially those based on the <bibref ref="Unicode-Collations"/> can be "tailored" for various purposes. This
                        document does not discuss such tailoring, nor does it provide a mechanism to
                        perform tailoring. Instead, it assumes that the collation argument to the
                        various functions below is a tailored and named collation.</p><p>The <termref def="dt-codepoint-collation">Unicode codepoint collation</termref> is a collation
                  available in every implementation, which sorts based on codepoint values. For further details
                  see <specref ref="codepoint-collation"/></p><p>In the ideal case, a collation should treat two strings as equal if the two strings are identical after Unicode normalization.  Thus, the <bibref ref="charmod-normalization"/> recommends that all strings be subjected to early Unicode normalization and some collations will raise runtime errors if they encounter strings that are not properly normalized.  However, it is not possible to guarantee that all
                        strings in all XML documents are, in fact, normalized, or that they are
                        normalized in the same manner. In order to maximize interoperability of 
                        operations on XML documents in general, there may be collations that operate
                        on unnormalized strings and other collations that
                        implicitly normalize strings before comparing them. Applications may choose the kind of collation best suited for their needs.  Note that collations based
                        on the Unicode collation algorithm implicitly normalize strings before comparison and produce equivalent results regardless of
                        a string's normalization.</p><p>This specification assumes that collations are named and that the collation
                        name may be provided as an argument to string functions. Functions that
                        allow specification of a collation do so with an argument whose type is
                        <code>xs:string</code> but whose lexical form must conform to an
                        <code>xs:anyURI</code>. If the collation is specified using a relative URI,
                        it is assumed to be relative to the value of the base-uri property in the
                        static context. This specification also defines the manner in which a
                        default collation is determined if the collation argument is not specified
                        in calls of functions that use a collation but allow it to be omitted. </p><p>This specification does not define whether or not the collation URI is
					dereferenced. The collation URI may be an abstract identifier, or it may
					refer to an actual resource describing the collation. If it refers to a
					resource, this specification does not define the nature of that resource.
					One possible candidate is that the resource is a locale description
					expressed using the Locale Data Markup Language: see <bibref ref="LDML"/>.
					</p><p>Functions such as <code>fn:compare</code> and <code>fn:max</code> that
                        compare <code>xs:string</code> values use a single collation URI to identify
                        all aspects of the collation rules. This means that any parameters such as
                        the strength of the collation must be specified as part of the collation
                        URI. For example, suppose there is a collation <quote>
                            <code>http://www.example.com/collations/French</code>
                        </quote> that refers to a French collation that compares on the basis of
                        base characters. Collations that use the same basic rules, but with higher
                        strengths, for example, base characters and accents, or base characters,
                        accents and case, would need to be given different names, say <quote>
                            <code>http://www.example.com/collations/French1</code>
                        </quote> and <quote>
                            <code>http://www.example.com/collations/French2</code>
                        </quote>. Note that some specifications use the term collation to refer to
                        an algorithm that can be parameterized, but in this specification, each
                        possible parameterization is considered to be a distinct collation.</p><p>The XQuery/XPath static context includes a provision for a default collation
                        that can be used for string comparisons and ordering operations. See the
                        description of the static context in <xspecref spec="XP" ref="static_context"/>. 
						If the default collation is not specified by the
                        user or the system, the default collation is the <termref def="dt-codepoint-collation">Unicode codepoint collation</termref>.</p><note><p>XML allows elements to specify the <code>xml:lang</code> attribute to
                     indicate the language associated with the content of such an element.
                     This specification does not use <code>xml:lang</code> to identify the
                     default collation because using
                     <code>xml:lang</code> does not produce desired effects when the two
                     strings to be compared have different <code>xml:lang</code> values or
                     when a string is multilingual. </p></note></div3><div3 id="codepoint-collation" diff="add" at="B"><head>The Unicode Codepoint Collation</head><p><termdef id="dt-codepoint-collation" term="Unicode codepoint collation">The collation URI
                  <code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code> identifies
               a collation which must be recognized by every implementation: it is referred to as
               the <term>Unicode codepoint collation</term> (not to be confused with the Unicode collation algorithm).</termdef></p><p>The Unicode codepoint collation does not perform any normalization on the
               supplied strings.</p><p>The collation is defined as follows. Each of the two strings is
               converted to a sequence of integers using the <function>fn:string-to-codepoints</function>
               function. These two sequences <code>$A</code> and <code>$B</code> are then compared as follows: </p><ulist><item><p>If both sequences are empty, the strings are equal</p></item><item><p>If one sequence is empty and the other is not, then the string
                     corresponding to the empty sequence is less than the other string.</p></item><item><p>If the first integer in <code>$A</code> is less than the first integer in <code>$B</code>, then
                     the string corresponding to <code>$A</code> is less than the string corresponding to
                     <code>$B</code>.
                  </p></item><item><p>If the first integer in <code>$A</code> is greater than the first integer in <code>$B</code>, then
                     the string corresponding to <code>$A</code> is greater than the string corresponding to
                     <code>$B</code>.</p></item><item><p>Otherwise (the first pair of integers are equal), the result is obtained
                    by applying the same rules recursively to <code>fn:subsequence($A, 2)</code> and
                    <code>fn:subsequence($B, 2)</code></p></item></ulist><note><p>While the Unicode codepoint collation does not produce results suitable for quality publishing of
               printed indexes or directories, it is adequate for many purposes where a restricted alphabet
               is used, such as sorting of vehicle registrations.</p></note></div3><div3 id="choosing-a-collation"><head>Choosing a collation</head><p>Many functions have two signatures, where one signature includes a <code>$collation</code>
			   argument and the other omits this argument.</p><p>The collation to use for these functions is determined by the following rules:</p><olist><item><p>If the function specifies an explicit collation, CollationA (e.g., if
                                the optional collation argument is specified in a call of the
                                <code>fn:compare</code> function), then:</p><ulist><item><p>If CollationA is supported by the implementation, then
                                        CollationA is used. </p></item><item><p>Otherwise, an error is raised <errorref class="CH" code="0002"/>. </p></item></ulist></item><item><p>If no collation is explicitly specified for the function and the
                                default collation in the XQuery/XPath static context is CollationB, then:</p><ulist><item><p>If CollationB is supported by the implementation, then
                                        CollationB is used. </p></item><item><p>Otherwise, an error is raised <errorref class="CH" code="0002"/>. </p></item></ulist></item></olist><note diff="add" at="B"><p>Because the set of collations that are supported is <termref def="implementation-defined">implementation-defined</termref>,
			   an implementation has the option to support all collation URIs, in which case it will never raise this error.</p></note></div3><div3 id="func-compare"><head><?function fn:compare?></head></div3><div3 id="func-codepoint-equal"><head><?function fn:codepoint-equal?></head></div3></div2><div2 id="string-value-functions"><head>Functions on string values</head><p>The following functions are defined on values of type <code>xs:string</code> and
                    types derived from it.</p><?local-function-index?><notes><p>When the above operators and functions are applied to datatypes derived from
                        <code>xs:string</code>, they are guaranteed to return legal
                        <code>xs:string</code>s, but they might not return a legal value for the
                        particular subtype to which they were applied. </p><p>The strings returned by <code>fn:concat</code> and <code>fn:string-join</code> are not guaranteed to be normalized.  
			   But see note in <code>fn:concat</code>.
                </p></notes><div3 id="func-concat"><head><?function fn:concat?></head></div3><div3 id="func-string-join"><head><?function fn:string-join?></head></div3><div3 id="func-substring"><head><?function fn:substring?></head></div3><div3 id="func-string-length"><head><?function fn:string-length?></head></div3><div3 id="func-normalize-space"><head><?function fn:normalize-space?></head></div3><div3 id="func-normalize-unicode"><head><?function fn:normalize-unicode?></head></div3><div3 id="func-upper-case"><head><?function fn:upper-case?></head></div3><div3 id="func-lower-case"><head><?function fn:lower-case?></head></div3><div3 id="func-translate"><head><?function fn:translate?></head></div3></div2><div2 id="substring.functions"><head>Functions based on substring matching</head><p>The functions described in the section examine a string <code>$arg1</code> to see
                    whether it contains another string <code>$arg2</code> as a substring. The result
                    depends on whether <code>$arg2</code> is a substring of <code>$arg1</code>, and
                    if so, on the range of characters in <code>$arg1</code> which <code>$arg2</code> matches.</p><p>When the <termref def="dt-codepoint-collation">Unicode codepoint collation</termref>
                    is used, this simply involves determining whether <code>$arg1</code> contains a
                    contiguous sequence of characters whose codepoints are the same, one for one,
                    with the codepoints of the characters in <code>$arg2</code>.</p><p>When a collation is specified, the rules are more complex.</p><p>All collations support the capability of deciding whether two strings are
                    considered equal, and if not, which of the strings should be regarded as
                    preceding the other. For functions such as <code>fn:compare</code>, this is
                    all that is required. For other functions, such as <code>fn:contains</code>,
                    the collation needs to support an additional property: it must be able to
                    decompose the string into a sequence of collation units, each unit consisting of
                    one or more characters, such that two strings can be compared by pairwise
                    comparison of these units. ("collation unit" is equivalent to "collation
                    element" as defined in <bibref ref="Unicode-Collations"/>.) The string
                    <code>$arg1</code> is then considered to contain <code>$arg2</code> as a
                    substring if the sequence of collation units corresponding to <code>$arg2</code>
                    is a subsequence of the sequence of the collation units corresponding to
                    <code>$arg1</code>. The characters in <code>$arg1</code> that match are the
                    characters corresponding to these collation units.</p><p>This rule may occasionally lead to surprises. For example, consider a collation
                    that treats "Jaeger" and "Jäger" as equal. It might do this by
                    treating "ä" as representing two collation units, in which case the
                        expression <code>fn:contains("Jäger", "eg")</code> will return
                    <code>true</code>. Alternatively, a collation might treat "ae" as a single
                    collation unit, in which case the expression <code>fn:contains("Jaeger",
                    "eg")</code> will return <code>false</code>. The results of these functions thus
                    depend strongly on the properties of the collation that is used.</p><p>In addition,
                    collations may specify that some collation units should be ignored during matching. If hyphen is an ignored
					collation unit, then <code>fn:contains("code-point", "codepoint")</code> will be true, 
					and <code>fn:contains("codepoint", "-")</code> will also be true.</p><p diff="chg" at="A-E17"> In the definitions below, we refer to the terms <term>match</term> and
                    <term>minimal match</term> as defined in definitions DS2 and DS4 of 
                    <bibref ref="Unicode-Collations"/>. In applying these definitions:</p><ulist diff="chg" at="A-E17"><item><p>
                     <var>C</var> is the collation; that is, the value of the <code>$collation</code>
                    argument if specified, otherwise the default collation.</p></item><item><p>
                     <var>P</var> is the (candidate) substring <code>$arg2</code>
                  </p></item><item><p>
                     <var>Q</var> is the (candidate) containing string <code>$arg1</code>
                  </p></item><item><p>The boundary condition <var>B</var> is satisfied at the start and end of a
                    string, and between any two characters that belong to different collation units
                    ("collation elements" in the language of <bibref ref="Unicode-Collations"/>). It
                    is not satisfied between two characters that belong to the same collation unit.</p></item></ulist><p>It is possible to define collations that do not have the ability to decompose a
                    string into units suitable for substring matching. An argument to a function
                    defined in this section may be a URI that identifies a collation that is able to
                    compare two strings, but that does not have the capability to split the string
                    into collation units. Such a collation may cause the function to fail, or to
                    give unexpected results or it may be rejected as an unsuitable argument. The
                    ability to decompose strings into collation units is an <termref def="implementation-defined"/> property of the collation.</p><?local-function-index?><div3 id="func-contains"><head><?function fn:contains?></head></div3><div3 id="func-starts-with"><head><?function fn:starts-with?></head></div3><div3 id="func-ends-with"><head><?function fn:ends-with?></head></div3><div3 id="func-substring-before"><head><?function fn:substring-before?></head></div3><div3 id="func-substring-after"><head><?function fn:substring-after?></head></div3></div2><div2 id="string.match"><head>String functions that use regular expressions</head><p>The three functions described in this section make use of a regular expression
                    syntax for pattern matching. This is described below.</p><?local-function-index?><div3 id="regex-syntax"><head>Regular expression syntax</head><p>The regular expression syntax used by these functions is defined in terms of
                        the regular expression syntax specified in XML Schema (see <bibref ref="xmlschema-2"/>), which in turn is based on the established conventions of
                        languages such as Perl. However, because XML Schema uses regular expressions
                        only for validity checking, it omits some facilities that are widely-used
                        with languages such as Perl. This section, therefore, describes extensions
                        to the XML Schema regular expressions syntax that reinstate these capabilities.</p><note><p>
It is recommended that implementers consult <bibref ref="Unicode-Regex"/> for information on using regular expression processing on Unicode characters.</p></note><p>The regular expression syntax and semantics are identical to those
                            defined in <bibref ref="xmlschema-2"/> with the following additions:</p><ulist><item><p> Two meta-characters, <code>^</code> and <code>$</code> are
                                    added. By default, the meta-character <code>^</code> matches the
                                    start of the entire string, while <code>$</code> matches the end
                                    of the entire string. In multi-line mode, <code>^</code> matches
                                    the start of any line (that is, the start of the entire string,
                                    and the position immediately after a newline character), while
                                    <code>$</code> matches the end of any line (that is, the end of
                                    the entire string, and the position immediately before a newline
                                    character). Newline here means the character <code>#x0A</code> only.</p><p>This means that the production in <bibref ref="xmlschema-2"/>:</p><p><code>[10] Char ::= [^.\?*+()|#x5B#x5D]</code>
                                </p><p>is modified to read:</p><p><code>[10] Char ::= [^.\?*+{}()|^$#x5B#x5D]</code>
                                </p><p>The characters <code>#x5B</code> and <code>#x5D</code> correspond
                                    to "<code>[</code>" and "<code>]</code>" respectively.</p><note><p>The definition of Char (production [10]) in <bibref ref="xmlschema-2"/> has a known error in which it omits the left brace ("{") and right brace ("}").  That error is corrected here.</p></note><p>The following production:</p><p><code>[11] charClass ::= charClassEsc | charClassExpr | WildCardEsc</code>
                                </p><p>is modified to read:</p><p><code>[11] charClass ::= charClassEsc | charClassExpr |
                                        WildCardEsc | "^" | "$"</code>
                                </p></item><item><p><emph>Reluctant quantifiers</emph> are supported. They are
                                    indicated by a <quote>
                                        <code>?</code>
                                    </quote> following a quantifier. Specifically:</p><ulist><item><p><code>X??</code> matches X, once or not at all</p></item><item><p><code>X*?</code> matches X, zero or more times</p></item><item><p><code>X+?</code> matches X, one or more times</p></item><item><p><code>X{n}?</code> matches X, exactly n times</p></item><item><p><code>X{n,}?</code> matches X, at least n times</p></item><item><p><code>X{n,m}?</code> matches X, at least n times, but
                                            not more than m times</p></item></ulist><p>The effect of these quantifiers is that the regular expression
                                    matches the <emph>shortest</emph> possible substring consistent
                                    with the match as a whole succeeding. Without the <quote>
                                        <code>?</code>
                                    </quote>, the regular expression matches the
                                    <emph>longest</emph> possible substring.</p><p>To achieve this, the production in <bibref ref="xmlschema-2"/>:</p><p><code>[4] quantifier ::= [?*+] | ( '{' quantity '}' )</code>
                                </p><p>is changed to:</p><p><code>[4] quantifier ::= ( [?*+] | ( '{' quantity '}' ) ) '?'?</code>
                                </p><note><p>Reluctant quantifiers have no effect on the results of the
                                        boolean <code>fn:matches</code> function, since this
                                        function is only interested in discovering whether a match
                                        exists, and not where it exists.</p></note></item><item><p>Sub-expressions (groups) within the regular expression are
                        recognized. The regular expression syntax defined by <bibref ref="xmlschema-2"/> 
						allows a regular expression to contain
                        parenthesized sub-expressions, but attaches no special
                        significance to them. The <code>fn:replace</code> function
                        described below allows access to the parts of the input string
                        that matched a sub-expression (called captured substrings). The
                        sub-expressions are numbered according to the position of the
                        opening parenthesis in left-to-right order within the top-level
                        regular expression: the first opening parenthesis identifies
                        captured substring 1, the second identifies captured substring
                        2, and so on. 0 identifies the substring captured by the entire
                        regular expression. If a sub-expression matches more than one
                        substring (because it is within a construct that allows
                        repetition), then only the <emph>last</emph> substring that it
                        matched will be captured.</p><p diff="add" at="B">Non-capturing groups are also recognized. These are indicated
                     by the syntax <code>(?:xxxx)</code>. Specifically, the production rule for <code>atom</code>
                        in <bibref ref="xmlschema-2"/> is changed from:</p><p diff="add" at="B"><code>[9] atom ::= Char | charClass | ( '(' regExp ')' )</code>
                     </p><p diff="add" at="B">to:</p><p diff="add" at="B"><code>[9] atom ::= Char | charClass | ( '(' '?:'? regExp ')' )</code>
                     </p><p diff="add" at="B">The presence of the optional <code>?:</code> has no effect on the set of strings
                     that match the regular expression, but causes the left parenthesis not to be counted
                     by operations that number the groups within a regular expression, for example the
                     <code>fn:replace</code> function.</p></item><item><!--Text replaced by erratum E24 change 1"--><p> Back-references are allowed 
			    <phrase diff="add" at="A-E24">outside a character class expression. 
				A back-reference is an additional kind of atom.</phrase>
				The construct <code>\N</code> where
                <code>N</code> is a single digit is always recognized as a
                back-reference; if this is followed by further digits, these
                digits are taken to be part of the back-reference if and only if
                <phrase diff="chg" at="A-E24">the resulting number <code>NN</code> is such that
				the back-reference is preceded by <code>NN</code> or more unescaped opening
				parentheses.
				The regular expression is invalid if a back-reference refers to a
				subexpression that does not exist or whose
                closing right parenthesis occurs after the back-reference.</phrase>
                     </p><p diff="chg" at="A-E24">A back-reference matches the string that was
                matched by the <code>N</code>th capturing subexpression within the regular
                expression, that is, the parenthesized subexpression whose
                opening left parenthesis is the <code>N</code>th unescaped left
                parenthesis within the regular expression. 
				 
                For example, the regular expression
                <code>('|").*\1</code> matches a sequence of characters
                delimited either by an apostrophe at the start and end, or by a
                quotation mark at the start and end. </p><p diff="chg" at="A-E24">If no string is matched by the <code>N</code>th capturing 
               subexpression, the back-reference is interpreted as matching 
               a zero-length string.</p><p diff="chg" at="A-E24">Back-references change the following production:</p><p>
                        <phrase diff="chg" at="A-E24">
                           <code>[9] atom ::= Char | charClass | ( '(' regExp ')' )</code>
                        </phrase>
                     </p><p diff="chg" at="A-E24">to</p><p>
                        <phrase diff="chg" at="A-E24">
                           <code>[9] atom ::= Char | charClass | ( '(' regExp ')' ) | backReference</code>
                        </phrase>
                     </p><p>
                        <phrase diff="chg" at="A-E24">
                           <code>[9a] backReference ::= "\" [1-9][0-9]*</code>
                        </phrase>
                     </p><note><p>
                           <phrase diff="add" at="A-E24">Within a character class expression, <code>\</code> followed by a digit is invalid.
			 Some other regular expression languages interpret this as an octal character reference.
			 </phrase>
                        </p></note><!--End of text replaced by erratum E24--></item><item><p> Single character escapes are extended to allow the
                                    <code>$</code> character to be escaped. The following production
                                    is changed:</p><p>
                                    <code>[24]SingleCharEsc ::= '\' [nrt\|.?*+(){}#x2D#x5B#x5D#x5E]</code>
                                </p><p>to</p><p>
                                    <code>[24]SingleCharEsc ::= '\' [nrt\|.?*+(){}$#x2D#x5B#x5D#x5E]</code>
                                </p></item></ulist><div4 id="flags"><head>Flags</head><p>All these functions provide an optional parameter, <code>$flags</code>,
                    to set options for the interpretation of the regular expression. The
                    parameter accepts a <code>xs:string</code>, in which individual letters
                    are used to set options. The presence of a letter within the string
                    indicates that the option is on; its absence indicates that the option
                    is off. Letters may appear in any order and may be repeated. If there
                    are characters present that are not defined here as flags, then an error
                    is raised <errorref class="RX" code="0001"/>.</p><p>The following options are defined:</p><ulist><item><p><code>s</code>: If present, the match operates in "dot-all"
                        mode. (Perl calls this the single-line mode.) If the
                        <code>s</code> flag is not specified, the meta-character
                        <code>.</code> matches any character except a newline
                        (<code>#x0A</code>) character. In dot-all mode, the
                        meta-character <code>.</code> matches any character whatsoever.
                        Suppose the input contains "hello" and "world" on two lines.
                        This will not be matched by the regular expression
                        "hello.*world" unless dot-all mode is enabled.</p></item><item><!--Text replaced by erratum E7 change 1"--><p>
                           <code>m</code>: If present, the match operates in multi-line
			            mode. By default, the meta-character <code>^</code> matches the
			            start of the entire string, while $ matches the end of the
			            entire string. In multi-line mode, <code>^</code> matches the
			            start of any line (that is, the start of the entire string, and
			            the position immediately after a newline character
						<phrase diff="add" at="A-E7">other than a newline
			            that appears as the last character in the string</phrase>), while
			            <code>$</code> matches the end of any line 
						<phrase diff="chg" at="A-E7">(that is, the position immediately
			            before a newline character, and the end of the entire string if there is no
			            newline character at the end of the string).</phrase> 
			            Newline here means the character <code>#x0A</code> only.</p><!--End of text replaced by erratum E7--></item><item><p><code>i</code>: If present, the match operates in
                        case-insensitive mode. The detailed rules are as follows. 
                        In these
                        rules, a character C2 is considered to be a <emph>case-variant</emph> of 
                        another character C1 if the following XPath expression returns 
                        <code>true</code> when the two characters
                           are considered as strings of length one, and the <termref def="dt-codepoint-collation">Unicode codepoint collation</termref> is used:</p><p>
                           <code>fn:lower-case(C1) eq fn:lower-case(C2)</code>
                        </p><p>  or </p><p>
                           <code>fn:upper-case(C1) eq fn:upper-case(C2)</code>
                        </p><p>
                                     Note that the case-variants of a character under this definition 
                                     are always single characters.</p><olist><item><p>
                                    When a normal character (<code>Char</code>) is used as an atom, 
                                    it represents 
                                    the set containing that character and all its case-variants. 
                                    For example, the regular expression "z" will match both "z" and 
                                    "Z".</p></item><item><p>
                                    A character range (<code>charRange</code>) represents the set 
                                    containing all the characters that it would match in the absence 
                                    of the "<code>i</code>" flag, together with their case-variants. 
                                    For example, 
                                    the regular expression "[A-Z]" will match all
                                    the letters A-Z and all the letters a-z. It will also match 
                                    certain other characters such as <code>#x212A</code> (KELVIN SIGN), since 
                                    <code>fn:lower-case("#x212A")</code> is "k".</p><p>
                                    This rule applies also to a character range used in a character 
                                    class subtraction (<code>charClassSub</code>): thus [A-Z-[IO]] will match 
                                    characters such as "A", "B", "a", and "b", but will not match 
                                    "I", "O", "i", or "o".</p><p>
                                    The rule also applies to a character range used as part of a 
                                    negative character group: thus [^Q] will match every character 
                                    except "Q" and "q" (these being the only case-variants of "Q" in 
                                    Unicode).</p></item><item><p>
                                    A back-reference is compared using case-blind comparison: 
                                    that is, each character must either be the same as the 
                                    corresponding character of the previously matched string, or must 
                                    be a case-variant of that character. For example, the strings 
                                    "Mum", "mom", "Dad", and "DUD" all match the regular
                                    expression "([md])[aeiou]\1" when the "<code>i</code>" flag is used.</p></item><item><p>
                                    All other constructs are unaffected by the "<code>i</code>" flag. 
                                    For example, 
                                    "\p{Lu}" continues to match upper-case letters only.</p></item></olist></item><item><p><code>x</code>: If present, whitespace characters 
                                    (#x9, #xA, #xD and #x20) in the regular 
                                    expression are removed prior to matching with one exception:  
                                    whitespace characters within character class expressions 
                                    (<code>charClassExpr</code>) are not removed. This flag can be used, 
                                    for example, to break up long regular expressions into readable lines.</p><p> Examples:</p><p> 
                           <code>fn:matches("helloworld", "hello world", "x")</code> returns <code>true()</code>
                        </p><p> 
                           <code>fn:matches("helloworld", "hello[ ]world", "x")</code> returns <code>false()</code>
                        </p><p> 
                           <code>fn:matches("hello world", "hello\ sworld", "x")</code> returns <code>true()</code>
                        </p><p> 
                           <code>fn:matches("hello world", "hello world", "x")</code> returns <code>false()</code>
                        </p></item><item diff="add" at="B"><p><code>q</code>: if present, all characters in the regular expression
                     are treated as representing themselves, not as metacharacters. In effect, every
                     character that would normally have a special meaning in a regular expression is implicitly escaped
                     by preceding it with a backslash.</p><p>Furthermore, when this flag is present, the characters <code>$</code> and
                         <code>\</code> have no special significance when used in the replacement string
                         supplied to the <code>fn:replace</code> function.</p><p>This flag can be used in conjunction with the <code>i</code> flag. If it is used
                           together with the <code>m</code>, <code>s</code>, or <code>x</code> flag, that flag
                           has no effect.</p><p>Examples:</p><p><code>fn:tokenize("12.3.5.6", ".", "q")</code> returns <code>("12", "3", "5", "6")</code></p><p><code>fn:replace("a\b\c", "\", "\\", "q")</code> returns <code>"a\\b\\c"</code></p><p><code>fn:replace("a/b/c", "/", "$", "q")</code> returns <code>"a$b$c"</code></p><p><code>fn:matches("abcd", ".*", "q")</code> returns <code>false()</code></p><p><code>fn:matches("Mr. B. Obama", "B. OBAMA", "iq")</code> returns <code>true()</code></p></item></ulist></div4></div3><div3 id="func-matches"><head><?function fn:matches?></head></div3><div3 id="func-replace"><head><?function fn:replace?></head></div3><div3 id="func-tokenize"><head><?function fn:tokenize?></head></div3><div3 id="func-analyze-string" diff="add" at="A"><head><?function fn:analyze-string?></head></div3></div2></div1><div1 id="anyURI-functions"><head>Functions that manipulate URIs</head><p>This section specifies functions that manipulate URI values, either as instances
            of <code>xs:anyURI</code> or as strings.</p><?local-function-index?><div2 id="func-resolve-uri" diff="chg" at="F"><head><?function fn:resolve-uri?></head></div2><div2 id="func-encode-for-uri"><head><?function fn:encode-for-uri?></head></div2><div2 id="func-iri-to-uri"><head><?function fn:iri-to-uri?></head></div2><div2 id="func-escape-html-uri"><head><?function fn:escape-html-uri?></head></div2></div1><div1 id="boolean-functions"><head>Functions and operators on Boolean values</head><p>This section defines functions and operators on the <code>xs:boolean</code> datatype.</p><div2 id="boolean-constructors"><head>Boolean constant functions</head><p>Since no literals are defined in XPath to reference the constant boolean values true and false,
			two functions are provided for the purpose.</p><?local-function-index?><div3 id="func-true"><head><?function fn:true?></head></div3><div3 id="func-false"><head><?function fn:false?></head></div3></div2><div2 id="op.boolean"><head>Operators on Boolean values</head><p>The following functions define the semantics of operators on boolean values in
                        <bibref ref="xquery"/> and <bibref ref="xpath20"/>:</p><?local-function-index?><p>The ordering operators <code>op:boolean-less-than</code>
                    and <code>op:boolean-greater-than</code> are provided for application purposes
                    and for compatibility with <bibref ref="xpath"/>. The <bibref ref="xmlschema-2"/>
                    datatype <code>xs:boolean</code> is not ordered.</p><div3 id="func-boolean-equal"><head><?function op:boolean-equal?></head></div3><div3 id="func-boolean-less-than"><head><?function op:boolean-less-than?></head></div3><div3 id="func-boolean-greater-than"><head><?function op:boolean-greater-than?></head></div3></div2><div2 id="boolean-value-functions"><head>Functions on Boolean values</head><p>The following functions are defined on boolean values:</p><?local-function-index?><div3 id="func-boolean"><head><?function fn:boolean?></head></div3><div3 id="func-not"><head><?function fn:not?></head></div3></div2></div1><div1 id="durations"><head>Functions and operators on durations</head><p>Operators are defined on the following type:</p><ulist><item><p>xs:duration</p></item></ulist><p>and on the two defined subtypes (see <specref ref="duration-subtypes"/>):</p><ulist><item><p>xs:yearMonthDuration</p></item><item><p>xs:dayTimeDuration</p></item></ulist><p>No ordering relation is defined on <code>xs:duration</code> values.
			Two <code>xs:duration</code> values may however be compared for equality.</p><p>Operations on durations (including equality comparison, casting to string, and extraction of components) 
			all treat the duration as normalized. This means that the seconds and minutes components 
			will always be less than 60, the hours component less than 24, and the months component 
			less than 12.  Thus, for example, a duration of 120 seconds always gives the same result 
			as a duration of two minutes.</p><note><p>This means that in practice, the information content of an <code>xs:duration</code>
			value can be reduced to an <code>xs:integer</code> number of months, and an <code>xs:decimal</code>
			number of seconds. For the two defined subtypes this is further simplified so that one of these two
			components is fixed at zero. Operations such as comparison of durations and arithmetic on durations
			can be expressed in terms of numeric operations applied to these two components.</p></note><div2 id="duration-limits"><head>Limits and precision</head><ednote><edtext>This section needs revision - it comes from the old text describing
			   both duration and date/time operations, but it's not clear exactly what it should say
			   for durations.</edtext></ednote><p>A processor that limits the number of digits in date and time datatype
                        representations may encounter overflow and underflow conditions when it
                        tries to execute the functions in <specref ref="dateTime-arithmetic"/>. In
                        these situations, the processor <termref def="must"/> return P0M or PT0S in
                        case of duration underflow and 00:00:00 in case of time underflow.
                            It <termref def="must"/> raise an error <errorref class="DT" code="0001"/> in case of overflow.</p><p>The value spaces of the two totally ordered subtypes of
                        <code>xs:duration</code> described in <specref ref="duration-subtypes"/> are
                        <code>xs:integer</code> months for <code>xs:yearMonthDuration</code>
                        and <code>xs:decimal</code> seconds for <code>xs:dayTimeDuration</code>. If
                        a processor limits the number of digits allowed in the representation of
                        <code>xs:integer</code> and <code>xs:decimal</code> then overflow and
                        underflow situations can arise when it tries to execute the functions in
                            <specref ref="duration-arithmetic"/>. In these situations the processor
                            <termref def="must"/> return zero in case of numeric underflow and P0M
                        or PT0S in case of duration underflow. It <termref def="must"/> raise an
                        error <errorref class="DT" code="0002"/> in case of overflow.</p></div2><div2 id="duration-subtypes"><head>Two totally ordered subtypes of duration</head><p>Two totally ordered subtypes of <code>xs:duration</code> are defined in <xspecref spec="DM" ref="types"/>
                    specification using the mechanisms described in <bibref ref="xmlschema-2"/> for
                    defining user-defined types. Additional details about these types is given below.</p><note><p>These types were not defined in XSD 1.0, but they are defined in the current draft of XSD 1.1. The description given
			here is believed to be equivalent to that in XSD 1.1, and will become non-normative when XSD 1.1 reaches
			Recommendation status.</p></note><div3 id="dt-yearMonthDuration"><head>xs:yearMonthDuration</head><p> [Definition] <code>xs:yearMonthDuration</code> is derived from
                        <code>xs:duration</code> by restricting its lexical representation to
                        contain only the year and month components. The value space of
                        <code>xs:yearMonthDuration</code> is the set of <code>xs:integer</code>
                        month values. The year and month components of
                        <code>xs:yearMonthDuration</code> correspond to the Gregorian year and
                        month components defined in section 5.5.3.2 of <bibref ref="ISO8601"/>, respectively.</p><div4 id="lexical-yearMonthDuration"><head>Lexical representation</head><p>The lexical representation for <code>xs:yearMonthDuration</code> is the
                                <bibref ref="ISO8601"/> reduced format PnYnM, where nY represents
                            the number of years and nM the number of months. The values of the years
                            and months components are not restricted but allow an arbitrary unsigned <code>xs:integer</code>.</p><p>An optional preceding minus sign ('-') is allowed to indicate a negative
                            duration. If the sign is omitted a positive duration is indicated. To
                            indicate a <code>xs:yearMonthDuration</code> of 1 year, 2 months, one
                            would write: P1Y2M. One could also indicate a
                            <code>xs:yearMonthDuration</code> of minus 13 months as: -P13M. </p><p>Reduced precision and truncated representations of this format are
                            allowed provided they conform to the following: </p><p>If the number of years or months in any expression equals zero (0), the
                            number and its corresponding designator <termref def="may"/> be omitted.
                            However, at least one number and its designator <termref def="must"/> be
                            present. For example, P1347Y and P1347M are allowed; P-1347M is not
                            allowed, although -P1347M is allowed. P1Y2MT is not allowed. Also, P24YM
                            is not allowed, nor is PY43M since Y must have at least one preceding
                            digit and M must have one preceding digit.</p></div4><div4 id="calculating-value-yearMonthDuration"><head>Calculating the value from the lexical representation</head><p>The value of a <code>xs:yearMonthDuration</code> lexical form is
                            obtained by multiplying the value of the years component by 12 and
                            adding the value of the months component. The value is positive or
                            negative depending on the preceding sign.</p></div4><div4 id="canonical-yearMonthDuration"><head>Canonical representation</head><p>The canonical representation of <code>xs:yearMonthDuration</code>
                            restricts the value of the months component to <code>xs:integer</code>
                            values between 0 and 11, both inclusive. To convert from a non-canonical
                            representation to the canonical representation, the lexical
                            representation is first converted to a value in <code>xs:integer</code>
                            months as defined above. This value is then divided by 12 to obtain the
                            value of the years component of the canonical representation. The
                            remaining number of months is the value of the months component of the
                            canonical representation. For negative durations, the canonical form is
                            calculated using the absolute value of the duration and a negative sign
                            is prepended to it. If a component has the value zero (0), then the
                            number and the designator for that component <termref def="must"/> be
                            omitted. However, if the value is zero (0) months, the canonical form is "P0M".</p></div4><div4 id="order-yearMonthDuration"><head>Order relation on xs:yearMonthDuration</head><p>Let the function that calculates the value of an
                            <code>xs:yearMonthDuration</code> in the manner described above be
                            called V(d). Then for two <code>xs:yearMonthDuration</code> values x
                            and y, x &gt; y if and only if V(x) &gt; V(y). The order relation on
                            <code>yearMonthDuration</code> is a total order.</p></div4></div3><div3 id="dt-dayTimeDuration"><head>xs:dayTimeDuration</head><p>[Definition] <code>xs:dayTimeDuration</code> is derived from
                        <code>xs:duration</code> by restricting its lexical representation to
                        contain only the days, hours, minutes and seconds components. The value
                        space of <code>xs:dayTimeDuration</code> is the set of fractional second
                        values. The components of <code>xs:dayTimeDuration</code> correspond to the
                        day, hour, minute and second components defined in Section 5.5.3.2 of
                            <bibref ref="ISO8601"/>, respectively.</p><div4 id="lexical-dayTimeDuration"><head>Lexical representation</head><p>The lexical representation for <code>xs:dayTimeDuration</code> is the
                                <bibref ref="ISO8601"/> truncated format PnDTnHnMnS, where nD
                            represents the number of days, T is the date/time separator, nH the
                            number of hours, nM the number of minutes and nS the number of seconds.</p><p>The values of the days, hours and minutes components are not restricted,
                            but allow an arbitrary unsigned <code>xs:integer</code>. Similarly, the
                            value of the seconds component allows an arbitrary unsigned
                            <code>xs:decimal</code>. An optional minus sign ('-') is allowed to
                            precede the 'P', indicating a negative duration. If the sign is omitted,
                            the duration is positive. See also <bibref ref="ISO8601"/> Date and Time Formats.</p><p>For example, to indicate a duration of 3 days, 10 hours and 30 minutes,
                            one would write: P3DT10H30M. One could also indicate a duration of minus
                            120 days as: -P120D. Reduced precision and truncated representations of
                            this format are allowed, provided they conform to the following:</p><ulist><item><p>If the number of days, hours, minutes, or seconds in any
                                    expression equals zero (0), the number and its corresponding
                                    designator <termref def="may"/> be omitted. However, at least
                                    one number and its designator <termref def="must"/> be present.</p></item><item><p>The seconds part <termref def="may"/> have a decimal fraction.</p></item><item><p>The designator 'T' <termref def="must"/> be absent if and only if
                                    all of the time items are absent. The designator 'P' <termref def="must"/> always be present.</p></item></ulist><p>For example, P13D, PT47H, P3DT2H, -PT35.89S and P4DT251M are all allowed.
                            P-134D is not allowed (invalid location of minus sign), although -P134D
                            is allowed. </p></div4><div4 id="calculating-value-dayTimeDuration"><head>Calculating the value of a xs:dayTimeDuration from the lexical representation</head><p>The value of a <code>xs:dayTimeDuration</code> lexical form in
                            fractional seconds is obtained by converting the days, hours, minutes
                            and seconds value to fractional seconds using the conversion rules: 24
                            hours = 1 day, 60 minutes = 1 hour and 60 seconds = 1 minute.</p></div4><div4 id="canonical-dayTimeDuration"><head>Canonical representation</head><p>The canonical representation of <code>xs:dayTimeDuration</code>
                            restricts the value of the hours component to <code>xs:integer</code>
                            values between 0 and 23, both inclusive; the value of the minutes
                            component to <code>xs:integer</code> values between 0 and 59; both
                            inclusive; and the value of the seconds component to
                            <code>xs:decimal</code> valued from 0.0 to 59.999... (see <bibref ref="xmlschema-2"/>, Appendix D).</p><p>To convert from a non-canonical representation to the canonical
                            representation, the value of the lexical form in fractional seconds is
                            first calculated in the manner described above. The value of the days
                            component in the canonical form is then calculated by dividing the value
                            by 86,400 (24*60*60). The remainder is in fractional seconds. The value
                            of the hours component in the canonical form is calculated by dividing
                            this remainder by 3,600 (60*60). The remainder is again in fractional
                            seconds. The value of the minutes component in the canonical form is
                            calculated by dividing this remainder by 60. The remainder in fractional
                            seconds is the value of the seconds component in the canonical form. For
                            negative durations, the canonical form is calculated using the absolute
                            value of the duration and a negative sign is prepended to it. If a
                            component has the value zero (0) then the number and the designator for
                            that component must be omitted. However, if all the components of the
                            lexical form are zero (0), the canonical form is <quote>PT0S</quote>.</p></div4><div4 id="order-dayTimeDuration"><head>Order relation on xs:dayTimeDuration</head><p>Let the function that calculates the value of a
                            <code>xs:dayTimeDuration</code> in the manner described above be called
                            <emph>V(d)</emph>. Then for two <code>xs:dayTimeDuration</code> values
                            <emph>x</emph> and <emph>y, x &gt; y</emph> if and only if <emph>V(x)
                                &gt; V(y)</emph>. The order relation on
                            <code>xs:dayTimeDuration</code> is a total order. </p></div4></div3></div2><div2 id="comp.duration"><head>Comparison operators on durations</head><?local-function-index?><p>The following comparison operators are defined on the <bibref ref="xmlschema-2"/>
                    duration datatypes. Each operator takes two operands of the same
                    type and returns an <code>xs:boolean</code> result. As discussed in <bibref ref="xmlschema-2"/>, the
                    order relation on <code>xs:duration</code> is
                    not a total order but, rather, a partial order. For this reason, only equality is defined on <code>xs:duration</code>. 
					A full complement of comparison and
                    arithmetic functions are defined on the two subtypes of duration described in
                        <specref ref="duration-subtypes"/> which do have a total order.</p><div3 id="func-yearMonthDuration-less-than"><head><?function op:yearMonthDuration-less-than?></head></div3><div3 id="func-yearMonthDuration-greater-than"><head><?function op:yearMonthDuration-greater-than?></head></div3><div3 id="func-dayTimeDuration-less-than"><head><?function op:dayTimeDuration-less-than?></head></div3><div3 id="func-dayTimeDuration-greater-than"><head><?function op:dayTimeDuration-greater-than?></head></div3><div3 id="func-duration-equal"><head><?function op:duration-equal?></head></div3></div2><div2 id="component-extraction-durations"><head>Component extraction functions on durations</head><p>The duration datatype may be considered to be a composite datatypes
                    in that it contains distinct properties or components. The extraction functions specified
                    below extract a single component from a duration value. 
For <code>xs:duration</code> and its subtypes, including the two subtypes <code>xs:yearMonthDuration</code> and
 <code>xs:dayTimeDuration</code>, the components are normalized: this means that the seconds and minutes 
 components will always be less than 60, the hours component less than 24, and the months component less than 12.
</p><?local-function-index?><div3 id="func-years-from-duration"><head><?function fn:years-from-duration?></head></div3><div3 id="func-months-from-duration"><head><?function fn:months-from-duration?></head></div3><div3 id="func-days-from-duration"><head><?function fn:days-from-duration?></head></div3><div3 id="func-hours-from-duration"><head><?function fn:hours-from-duration?></head></div3><div3 id="func-minutes-from-duration"><head><?function fn:minutes-from-duration?></head></div3><div3 id="func-seconds-from-duration"><head><?function fn:seconds-from-duration?></head></div3></div2><div2 id="duration-arithmetic"><head>Arithmetic operators on durations</head><?local-function-index?><p>For operators that combine a duration and a date/time value, see <specref ref="dateTime-arithmetic"/>.</p><div3 id="func-add-yearMonthDurations"><head><?function op:add-yearMonthDurations?></head></div3><div3 id="func-subtract-yearMonthDurations"><head><?function op:subtract-yearMonthDurations?></head></div3><div3 id="func-multiply-yearMonthDuration"><head><?function op:multiply-yearMonthDuration?></head></div3><div3 id="func-divide-yearMonthDuration"><head><?function op:divide-yearMonthDuration?></head></div3><div3 id="func-divide-yearMonthDuration-by-yearMonthDuration"><head><?function op:divide-yearMonthDuration-by-yearMonthDuration?></head></div3><div3 id="func-add-dayTimeDurations"><head><?function op:add-dayTimeDurations?></head></div3><div3 id="func-subtract-dayTimeDurations"><head><?function op:subtract-dayTimeDurations?></head></div3><div3 id="func-multiply-dayTimeDuration"><head><?function op:multiply-dayTimeDuration?></head></div3><div3 id="func-divide-dayTimeDuration"><head><?function op:divide-dayTimeDuration?></head></div3><div3 id="func-divide-dayTimeDuration-by-dayTimeDuration"><head><?function op:divide-dayTimeDuration-by-dayTimeDuration?></head></div3></div2></div1><div1 id="dates-times"><head>Functions and operators on dates and times</head><p>This section defines operations on the <bibref ref="xmlschema-2"/> date and time types.</p><p>
See <bibref ref="Working-With-Timezones"/> for a disquisition on working with date and time values with and without timezones.
</p><div2 id="date-time-types"><head>Date and time types</head><p>The operators described in this section are defined on the following date and
                    time types: </p><ulist><item><p>xs:dateTime</p></item><item><p>xs:date</p></item><item><p>xs:time</p></item><item><p>xs:gYearMonth</p></item><item><p>xs:gYear</p></item><item><p>xs:gMonthDay</p></item><item><p>xs:gMonth</p></item><item><p>xs:gDay</p></item></ulist><p>The only operations defined on					
                    <code>xs:gYearMonth</code>, <code>xs:gYear</code>,
                    <code>xs:gMonthDay</code>, <code>xs:gMonth</code> and <code>xs:gDay</code> values are equality comparison and component extraction.
					For other types, further operations are provided, including order comparisons, arithmetic, formatted display, and timezone
					adjustment.</p><div3 id="date-time-duration-conformance"><head>Limits and precision</head><p>For a number of the above datatypes <bibref ref="xmlschema-2"/> extends the basic
                            <bibref ref="ISO8601"/> lexical representations, such as
                        YYYY-MM-DDThh:mm:ss.s for dateTime, by allowing a preceding minus sign, more
                        than four digits to represent the year field — no maximum is
                        specified — and an unlimited number of digits for fractional
                        seconds. Leap seconds are not supported.</p><p>All <emph>minimally conforming</emph> processors
                        <termref def="must"/>  support positive year values with a minimum of 4 digits (i.e.,
                        YYYY) and a minimum fractional second precision of 1 millisecond or three
                        digits (i.e., s.sss). However, <emph>conforming</emph> processors
                        <termref def="may"/>  set larger <termref def="implementation-defined"/> limits
                        on the maximum number of digits they support in these two situations.  Processors <termref def="may"/> also choose to support the year 0000 and 
                        years with negative values.  The results of operations on dates that cross the year 
                        0000 are <termref def="implementation-defined"/>.</p><p>A processor that limits the number of digits in date and time datatype
                        representations may encounter overflow and underflow conditions when it
                        tries to execute the functions in <specref ref="dateTime-arithmetic"/>. In
                        these situations, the processor <termref def="must"/> return 00:00:00 in case of time underflow.
                        It <termref def="must"/> raise an error <errorref class="DT" code="0001"/> in case of overflow.</p><ednote><edtext>Can time underflow occur, and if so when?</edtext></ednote></div3></div2><div2 id="date-time-values"><head>Date/time datatype values</head><p>As defined in <xspecref spec="DM" ref="dates-and-times"/>, <code>xs:dateTime</code>, 
			<code>xs:date</code>, <code>xs:time</code>,  <code>xs:gYearMonth</code>, <code>xs:gYear</code>, 
			<code>xs:gMonthDay</code>, <code>xs:gMonth</code>, <code>xs:gDay</code> values, 
			referred to collectively as date/time values, are represented as seven components or properties: 
			<code>year</code>, <code>month</code>, <code>day</code>, <code>hour</code>, <code>minute</code>, 
			<code>second</code> and <code>timezone</code>.  The value of the first five components are 
			<code>xs:integer</code>s.  The value of the <code>second</code> component is an <code>xs:decimal</code> 
			and the value of the <code>timezone</code> component is an <code>xs:dayTimeDuration</code>.  
			For all the primitive date/time datatypes, the <code>timezone</code> property is optional and may or may not 
			be present. Depending on the datatype, some of the remaining six properties must be present and 
			some must be absent.   Absent, or missing, properties are represented by the empty sequence.  
			This value is referred to as the <emph>local</emph> value in that the value retains its original timezone.  
			Before comparing or subtracting <code>xs:dateTime</code> values, this local value <termref def="must"/>  
			be translated or <emph>normalized</emph> to UTC.</p><p>For <code>xs:time</code>, <code>00:00:00</code> and <code>24:00:00</code> are alternate lexical forms 
			for the same value, whose canonical representation is <code>00:00:00</code>.  For <code>xs:dateTime</code>,
		    a time component <code>24:00:00</code> translates to <code>00:00:00"</code> of the following day.</p><div3 id="date-time-lexical-mapping"><head>Examples</head><ulist><item><p>An <code>xs:dateTime</code> with lexical
                        representation <code>1999-05-31T05:00:00</code>
						is represented in the datamodel by <code>{1999, 5, 31, 5, 0, 0.0, ()}</code>.</p></item><item><p>An <code>xs:dateTime</code> with lexical
                        representation <code>1999-05-31T13:20:00-05:00</code> 
						is represented by <code>{1999, 5, 31, 13, 20, 0.0, -PT5H}</code>.</p></item><item><p>An <code>xs:dateTime</code> with lexical
                        representation <code>1999-12-31T24:00:00</code> 
						is represented by <code>{2000, 1, 1, 0, 0, 0.0, ()}</code>.</p></item><item><p>An <code>xs:date</code> with lexical
                        representation <code>2005-02-28+8:00</code> 
						is represented by <code>{2005, 2, 28, (), (), (), PT8H}</code>.</p></item><item><p>An <code>xs:time</code> with lexical
                        representation <code>24:00:00</code> 
						is represented by <code>{(), (), (), 0, 0, 0, ()}</code>.</p></item></ulist></div3></div2><div2 id="constructing-dateTime"><head>Constructing a dateTime</head><p>A function is provided for constructing a
                    <code>xs:dateTime</code> value from a <code>xs:date</code> value and a
                    <code>xs:time</code> value.</p><div3 id="func-dateTime"><head><?function fn:dateTime?></head></div3></div2><div2 id="comp.datetime"><head>Comparison operators on duration, date and time values</head><?local-function-index?><p>The following comparison operators are defined on the <bibref ref="xmlschema-2"/>
                    date/time datatypes. Each operator takes two operands of the same
                    type and returns an <code>xs:boolean</code> result.</p><p>
               <bibref ref="xmlschema-2"/> also states that the
                    order relation on date and time datatypes is
                    not a total order but a partial order because these
datatypes may or may not have a timezone.  This is handled as follows.
If either operand to a comparison function on date or time values does not have
                    an (explicit) timezone then, for the purpose of the operation, an implicit
                    timezone, provided by the dynamic context <xspecref spec="XP" ref="id-xp-evaluation-context-components"/>, is assumed to be present as part of
                    the value. This creates a total order for all date and time values.</p><ednote><edtext>The following paragraph seems to duplicate material that has already been covered.</edtext></ednote><p>An <code>xs:dateTime</code> can be considered to consist of seven components:
<code>year</code>, <code>month</code>, <code>day</code>, <code>hour</code>, <code>minute</code>, 
<code>second</code> and <code>timezone</code>.  For <code>xs:dateTime</code> six components: <code>year</code>, 
<code>month</code>, <code>day</code>, <code>hour</code>, <code>minute</code> and <code>second</code> are required  
and  <code>timezone</code> is optional.   For other date/time values, of the first six components, some are required 
and others must be absent or missing.  <code>Timezone</code> is always optional.  For example, for <code>xs:date</code>, 
the <code>year</code>, <code>month</code> and <code>day</code> components are required and <code>hour</code>, 
<code>minute</code> and <code>second</code> components must be absent;  for <code>xs:time</code> the <code>hour</code>, 
<code>minute</code> and <code>second</code> components are required and <code>year</code>, <code>month</code> and 
<code>day</code> are missing;  for <code>xs:gDay</code>, <code>day</code> is required and <code>year</code>, 
<code>month</code>, <code>hour</code>, <code>minute</code> and <code>second</code> are missing.</p><p>Values of the date/time datatypes <code>xs:time</code>, <code>xs:gMonthDay</code>, <code>xs:gMonth</code>, 
			and <code>xs:gDay</code>, can be considered to represent a sequence of recurring time instants or time periods.  
			An <code>xs:time</code> occurs every day.  An <code>xs:gMonth</code> occurs every year.  Comparison operators 
			on these datatypes compare the starting instants of equivalent occurrences in the recurring series.  
			These <code>xs:dateTime</code> values are calculated  as described below.</p><p>Comparison operators on <code>xs:date</code>, <code>xs:gYearMonth</code> and <code>xs:gYear</code> compare 
			their starting instants. These <code>xs:dateTime</code> values are calculated  as described below.</p><p diff="chg" at="B">The starting instant of an occurrence of a date/time value is an <code>xs:dateTime</code> 
             calculated by filling 
			in the missing components of the local value from a reference <code>xs:dateTime</code>.  An example of a suitable
         reference <code>xs:dateTime</code> is <code>1972-01-01T00:00:00</code>. Then, for example, the starting
             instant corresponding to the <code>xs:date</code> value <code>2009-03-12</code> is 
             <code>2009-03-12T00:00:00</code>; the starting instant corresponding to the <code>xs:time</code> value
             <code>13:30:02</code> is <code>1972-01-01T13:30:02</code>; and the starting instant corresponding to the
             <code>gMonthDay</code> value <code>--02-29</code> is <code>1972-02-29T00:00:00</code> (which explains
             why a leap year was chosen for the reference).</p><note diff="chg" at="B"><p>In the previous version of this specification, the reference date/time chosen was
         <code>1972-12-31T00:00:00</code>. While this gives the same results, it produces a "starting instant" for 
         a <code>gMonth</code> or <code>gMonthDay</code> that bears no
         relation to the English meaning of the term, and it also required special handling of short months. 
         The original choice was made to allow for leap seconds; but since leap seconds are not recognized 
         in date/time arithmetic, this is not actually necessary.</p></note><!--If the value filled 
			in for a missing day component exceeds the maximum day value for the month, the last day of the month is used. 
			Suppose, for example, that the reference <code>xs:dateTime</code> is <code>1972-01-01T00:00:00</code> and the 
			<code>xs:date</code> value to be compared is <code>1993-03-31</code>.  Filling in the time components from the 
			reference <code>xs:dateTime</code> we get <code>1993-03-31T00:00:00</code> which is the starting instant of that 
			day.  Similarly, if the <code>xs:time</code> value <code>12:30:00</code> is to be compared, we fill in the 
			missing components from the reference <code>xs:dateTime</code> and we get <code>1972-12-31T12:30:00</code> 
			which is the time on that day.  For an <code>xs:gYearMonth</code> value of <code>1976-02</code> we fill in 
			the missing components, adjust for the last day in the month and get <code>1976-02-29T00:00:00</code>.</p>--><p>If the <code>xs:time</code> value written as
			<code>24:00:00</code> is to be compared, filling in the missing components gives <code>1972-01-01T00:00:00</code>, 
			because <code>24:00:00</code> is an alternative representation of <code>00:00:00</code> (the lexical value 
			<code>"24:00:00"</code> is
			converted to the time components {0,0,0} before the missing components are filled
			in). This has the consequence that when ordering <code>xs:time</code> values, 
			<code>24:00:00</code> is
			considered to be earlier than <code>23:59:59</code>. However, when ordering 
			<code>xs:dateTime</code>
			values, a time component of <code>24:00:00</code> is considered equivalent to <code>00:00:00</code> on the
			following day.</p><p>Note that the reference <code>xs:dateTime</code> does not have a timezone.  The <code>timezone</code> component 
			is never filled in from the reference <code>xs:dateTime</code>.  In some cases, if the date/time value does not 
			have a timezone, the implicit timezone from the dynamic context is used as the timezone.</p><note><p>This specification uses the reference <code>xs:dateTime 1972-01-01T00:00:00</code> in the description of the 
			   comparison operators.  Implementations may use other reference <code>xs:dateTime</code> values 
			   as long as they yield the same results.  The reference <code>xs:dateTime</code> used must meet the following 
			   constraints:  when it is used to supply components into <code>xs:gMonthDay</code> values, the year must allow 
			   for February 29 and so must be a leap year; when it is used to supply missing components into <code>xs:gDay</code> 
			   values, the month must allow for 31 days.  Different reference <code>xs:dateTime</code> values may be used for 
			   different operators.</p><!--<p>Historically, the choice of <code>1972-12-31</code> was made because the year was a leap year, the month had 31 days,
			   and the day contained a leap second. Subsequently, the decision was made not to support leap seconds in date/time comparisons
			   or arithmetic, which makes the choice of reference date less critical.--></note><div3 id="func-dateTime-equal"><head><?function op:dateTime-equal?></head></div3><div3 id="func-dateTime-less-than"><head><?function op:dateTime-less-than?></head></div3><div3 id="func-dateTime-greater-than"><head><?function op:dateTime-greater-than?></head></div3><div3 id="func-date-equal"><head><?function op:date-equal?></head></div3><div3 id="func-date-less-than"><head><?function op:date-less-than?></head></div3><div3 id="func-date-greater-than"><head><?function op:date-greater-than?></head></div3><div3 id="func-time-equal"><head><?function op:time-equal?></head></div3><div3 id="func-time-less-than"><head><?function op:time-less-than?></head></div3><div3 id="func-time-greater-than"><head><?function op:time-greater-than?></head></div3><div3 id="func-gYearMonth-equal"><head><?function op:gYearMonth-equal?></head></div3><div3 id="func-gYear-equal"><head><?function op:gYear-equal?></head></div3><div3 id="func-gMonthDay-equal"><head><?function op:gMonthDay-equal?></head></div3><div3 id="func-gMonth-equal"><head><?function op:gMonth-equal?></head></div3><div3 id="func-gDay-equal"><head><?function op:gDay-equal?></head></div3></div2><div2 id="component-extraction-dateTime"><head>Component extraction functions on dates and times</head><p>The date and time datatypes may be considered to be composite datatypes
                    in that they contain distinct properties or components. The extraction functions specified
                    below extract a single component from a date or time value. In all cases 
					the local value (that is, the original value as written, 
					without any timezone adjustment) is used. </p><note><p>A time written as <code>24:00:00</code> is treated as <code>00:00:00</code> on the
			following day.</p></note><?local-function-index?><div3 id="func-year-from-dateTime"><head><?function fn:year-from-dateTime?></head></div3><div3 id="func-month-from-dateTime"><head><?function fn:month-from-dateTime?></head></div3><div3 id="func-day-from-dateTime"><head><?function fn:day-from-dateTime?></head></div3><div3 id="func-hours-from-dateTime"><head><?function fn:hours-from-dateTime?></head></div3><div3 id="func-minutes-from-dateTime"><head><?function fn:minutes-from-dateTime?></head></div3><div3 id="func-seconds-from-dateTime"><head><?function fn:seconds-from-dateTime?></head></div3><div3 id="func-timezone-from-dateTime"><head><?function fn:timezone-from-dateTime?></head></div3><div3 id="func-year-from-date"><head><?function fn:year-from-date?></head></div3><div3 id="func-month-from-date"><head><?function fn:month-from-date?></head></div3><div3 id="func-day-from-date"><head><?function fn:day-from-date?></head></div3><div3 id="func-timezone-from-date"><head><?function fn:timezone-from-date?></head></div3><div3 id="func-hours-from-time"><head><?function fn:hours-from-time?></head></div3><div3 id="func-minutes-from-time"><head><?function fn:minutes-from-time?></head></div3><div3 id="func-seconds-from-time"><head><?function fn:seconds-from-time?></head></div3><div3 id="func-timezone-from-time"><head><?function fn:timezone-from-time?></head></div3></div2><div2 id="timezone.functions"><head>Timezone adjustment functions on dates and time values</head><?local-function-index?><p>These functions adjust the timezone component of an <code>xs:dateTime</code>, <code>xs:date</code> or
                    <code>xs:time</code> value.  The <code>$timezone</code> argument to these functions is defined as an 
					<code>xs:dayTimeDuration</code> but must be a valid timezone value.</p><div3 id="func-adjust-dateTime-to-timezone"><head><?function fn:adjust-dateTime-to-timezone?></head></div3><div3 id="func-adjust-date-to-timezone"><head><?function fn:adjust-date-to-timezone?></head></div3><div3 id="func-adjust-time-to-timezone"><head><?function fn:adjust-time-to-timezone?></head></div3></div2><div2 id="dateTime-arithmetic"><head>Arithmetic operators on durations, dates and times</head><p>These functions support adding or subtracting a duration value to or from an
                    <code>xs:dateTime</code>, an <code>xs:date</code> or an <code>xs:time</code>
                    value. Appendix E of <bibref ref="xmlschema-2"/> describes an algorithm for
                    performing such operations.</p><?local-function-index?><div3 id="func-subtract-dateTimes"><head><?function op:subtract-dateTimes?></head></div3><div3 id="func-subtract-dates"><head><?function op:subtract-dates?></head></div3><div3 id="func-subtract-times"><head><?function op:subtract-times?></head></div3><div3 id="func-add-yearMonthDuration-to-dateTime"><head><?function op:add-yearMonthDuration-to-dateTime?></head></div3><div3 id="func-add-dayTimeDuration-to-dateTime"><head><?function op:add-dayTimeDuration-to-dateTime?></head></div3><div3 id="func-subtract-yearMonthDuration-from-dateTime"><head><?function op:subtract-yearMonthDuration-from-dateTime?></head></div3><div3 id="func-subtract-dayTimeDuration-from-dateTime"><head><?function op:subtract-dayTimeDuration-from-dateTime?></head></div3><div3 id="func-add-yearMonthDuration-to-date"><head><?function op:add-yearMonthDuration-to-date?></head></div3><div3 id="func-add-dayTimeDuration-to-date"><head><?function op:add-dayTimeDuration-to-date?></head></div3><div3 id="func-subtract-yearMonthDuration-from-date"><head><?function op:subtract-yearMonthDuration-from-date?></head></div3><div3 id="func-subtract-dayTimeDuration-from-date"><head><?function op:subtract-dayTimeDuration-from-date?></head></div3><div3 id="func-add-dayTimeDuration-to-time"><head><?function op:add-dayTimeDuration-to-time?></head></div3><div3 id="func-subtract-dayTimeDuration-from-time"><head><?function op:subtract-dayTimeDuration-from-time?></head></div3></div2><div2 id="formatting-dates-and-times" diff="add" at="A"><head>Formatting dates and times</head><?local-function-index?><p>Three functions are provided to represent dates and times as a string, using the conventions of a selected calendar,
 language, and country. The signatures are presented first, followed by the rules which apply to each of the functions.</p><div3 id="func-format-dateTime"><head><?function fn:format-dateTime?></head></div3><div3 id="func-format-date"><head><?function fn:format-date?></head></div3><div3 id="func-format-time"><head><?function fn:format-time?></head></div3><div3 id="rules-for-datetime-formatting"><head>The date/time formatting functions</head><p>The <code>fn:format-dateTime</code>, <code>fn:format-date</code>, 
and <code>fn:format-time</code> 
functions format <code>$value</code> as a string using 
the picture string specified by the <code>$picture</code> argument,
the calendar specified by the <code>$calendar</code> argument,
the language specified by the <code>$language</code> argument, 
and the country <phrase diff="add" at="D">or other place name</phrase> specified by the <code>$place</code> argument.
The result of the function is the formatted string representation of the supplied
  <code>xs:dateTime</code>, <code>xs:date</code>, or <code>xs:time</code> value.</p><p>
               <termdef id="dt-date-formatting-function" term="date formatting function">The three 
                  functions <code>fn:format-dateTime</code>, <code>fn:format-date</code>, 
                  and <code>fn:format-time</code> are referred to collectively as the
                   <term>date formatting functions</term>.</termdef>
            </p><p>If <code>$value</code> is the empty sequence, the function returns the empty sequence.</p><p>Calling the two-argument form of each of the three functions is equivalent
to calling the five-argument form with each of the last three arguments set to an empty sequence.</p><p>For details of the <code>$language</code>, <code>$calendar</code>, and
<code>$place</code> arguments, see <specref ref="lang-cal-place"/>.</p><p>In general, the use of an invalid <code>$picture</code>, 
<code>$language</code>, <code>$calendar</code>, or
<code>$place</code> argument results in a dynamic error. By contrast,
use of an option in any of these arguments that is valid but not supported by the implementation is
not an error, and in these cases the implementation is required to output the value in a fallback
representation.</p><div4 id="date-picture-string"><head>The picture string</head><p>The picture consists of a sequence of variable markers and literal substrings.
A substring enclosed in square brackets is interpreted as a variable marker; substrings
not enclosed in square brackets are taken as literal substrings. 
The literal substrings are optional and if present are rendered unchanged, including any whitespace. 
If an opening or closing square bracket 
is required within a literal substring, it <rfc2119>must</rfc2119> be doubled.
The variable markers are replaced in the result by strings representing 
aspects of the date and/or time to be formatted. These are described in detail below.</p><p>A variable marker consists of a component specifier followed optionally 
by one or two presentation modifiers and/or optionally by a width modifier.
Whitespace within a variable marker is ignored.</p><p>The <emph>component specifier</emph> indicates the component of the date or
time that is required, and takes the following values:</p><table border="1" cellpadding="5"><thead><tr><th align="left" rowspan="1" colspan="1">Specifier</th><th align="left" rowspan="1" colspan="1">Meaning</th><th align="left" rowspan="1" colspan="1">Default Presentation Modifier</th></tr></thead><tbody><tr><td valign="top" rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">year (absolute value)</td><td valign="top" rowspan="1" colspan="1">1</td></tr><tr><td valign="top" rowspan="1" colspan="1">M</td><td rowspan="1" colspan="1">month in year</td><td valign="top" rowspan="1" colspan="1">1</td></tr><tr><td valign="top" rowspan="1" colspan="1">D</td><td rowspan="1" colspan="1">day in month</td><td valign="top" rowspan="1" colspan="1">1</td></tr><tr><td valign="top" rowspan="1" colspan="1">d</td><td rowspan="1" colspan="1">day in year</td><td valign="top" rowspan="1" colspan="1">1</td></tr><tr><td valign="top" rowspan="1" colspan="1">F</td><td rowspan="1" colspan="1">day of week</td><td valign="top" rowspan="1" colspan="1">n</td></tr><tr><td valign="top" rowspan="1" colspan="1">W</td><td rowspan="1" colspan="1">week in year</td><td valign="top" rowspan="1" colspan="1">1</td></tr><tr><td valign="top" rowspan="1" colspan="1">w</td><td rowspan="1" colspan="1">week in month</td><td valign="top" rowspan="1" colspan="1">1</td></tr><tr><td valign="top" rowspan="1" colspan="1">H</td><td rowspan="1" colspan="1">hour in day (24 hours)</td><td valign="top" rowspan="1" colspan="1">1</td></tr><tr><td valign="top" rowspan="1" colspan="1">h</td><td rowspan="1" colspan="1">hour in half-day (12 hours)</td><td valign="top" rowspan="1" colspan="1">1</td></tr><tr><td valign="top" rowspan="1" colspan="1">P</td><td rowspan="1" colspan="1">am/pm marker</td><td valign="top" rowspan="1" colspan="1">n</td></tr><tr><td valign="top" rowspan="1" colspan="1">m</td><td rowspan="1" colspan="1">minute in hour</td><td valign="top" rowspan="1" colspan="1">01</td></tr><tr><td valign="top" rowspan="1" colspan="1">s</td><td rowspan="1" colspan="1">second in minute</td><td valign="top" rowspan="1" colspan="1">01</td></tr><tr><td valign="top" rowspan="1" colspan="1">f</td><td rowspan="1" colspan="1">fractional seconds</td><td valign="top" rowspan="1" colspan="1">1</td></tr><tr diff="chg" at="D"><td valign="top" rowspan="1" colspan="1">Z</td><td rowspan="1" colspan="1">timezone</td><td valign="top" rowspan="1" colspan="1">01:01</td></tr><tr diff="chg" at="D"><td valign="top" rowspan="1" colspan="1">z</td><td rowspan="1" colspan="1">timezone (same as Z, but modified where appropriate to include a prefix
                           as a time offset using GMT, for example GMT+1 or GMT-05:00. For this component there is a fixed
prefix of <code>GMT</code>, or a localized
variation thereof for the chosen language, and the remainder of the value is formatted as for specifier <code>Z</code>.
                        </td><td valign="top" rowspan="1" colspan="1">01:01</td></tr><tr><td valign="top" rowspan="1" colspan="1">C</td><td rowspan="1" colspan="1">calendar: the name or abbreviation of a calendar name</td><td valign="top" rowspan="1" colspan="1">n</td></tr><tr><td valign="top" rowspan="1" colspan="1">E</td><td rowspan="1" colspan="1">era: the name of a baseline for the numbering of years, for example
                  the reign of a monarch</td><td valign="top" rowspan="1" colspan="1">n</td></tr></tbody></table><p>An error is reported <errorref class="FD" code="1340"/>
 if the syntax of the picture is incorrect.</p><p>An error is reported <errorref class="FD" code="1350"/>
 if a component specifier within the picture 
 refers to components that are not available in the given type of <code>$value</code>,
 for example if the picture supplied to the <function>format-time</function> refers
 to the year, month, or day component.</p><p>It is not an error to include a timezone component when the supplied
 value has no timezone. In these circumstances the timezone component will be ignored.</p><p>The first <emph>presentation modifier</emph> indicates the style in which the
value of a component is to be represented. Its value may be
either:</p><ulist><item><p>any format token permitted as a primary format token in the second argument 
of the <function>format-integer</function> function, indicating
that the value of the component is to be output numerically using the specified number format (for example,
<code>1</code>, <code>01</code>, <code>i</code>, <code>I</code>, <code>w</code>, <code>W</code>,
or <code>Ww</code>) or </p></item><item><p>the format token <code>n</code>, <code>N</code>,
or <code>Nn</code>, indicating that the value of the component is to be output by name,
in lower-case, upper-case, or title-case respectively. Components that can be output by name
include (but are not limited to) months, days of the week, timezones, and eras. 
If the processor cannot output these components by name for the chosen calendar and language 
then it must use an implementation-defined fallback representation.</p></item></ulist><p>If a comma is to be used as a grouping separator within the format token, then there must be a width
			   specifier. More specifically: if a variable marker
			   contains one or more commas, then the last comma is treated as introducing the width modifier, and all others
			   are treated as grouping separators. So <code>[Y9,999,*]</code> will output the year as <code>2,008</code>.</p><p>If the implementation does not support the use of the requested format token, it <rfc2119>must</rfc2119>
use the default presentation modifier for that component.</p><p>If the first presentation modifier is present, then it may optionally be followed by
a second presentation modifier as follows:</p><table border="1" cellpadding="5"><thead><tr><th align="left" rowspan="1" colspan="1">Modifier</th><th align="left" rowspan="1" colspan="1">Meaning</th></tr></thead><tbody><tr><td valign="top" rowspan="1" colspan="1">t</td><td valign="top" rowspan="1" colspan="1">traditional numbering. This has the same meaning as
in the second argument of <function>fn:format-integer</function>.</td></tr><tr><td valign="top" rowspan="1" colspan="1">o</td><td valign="top" rowspan="1" colspan="1">ordinal form of a number, for example <code>8th</code> or <code>8º</code>.
						This has the same meaning as
in the second argument of <function>fn:format-integer</function>. 
The actual representation of the ordinal form of a number
may depend not only on the language, but also on the grammatical context (for example,
in some languages it must agree in gender).</td></tr></tbody></table><note><p>Although the formatting rules are expressed in terms of the rules
for format tokens in <function>fn:format-integer</function>, the formats actually used may be specialized
to the numbering of date components where appropriate. For example, in Italian, it is conventional to
use an ordinal number (<code>primo</code>) for the first day of the month, and cardinal numbers
(<code>due, tre, quattro ...</code>) for the remaining days. A processor may therefore use
this convention to number days of the month, ignoring the presence or absence of the ordinal
presentation modifier.</p></note><p>Whether or not a presentation modifier is included, a width modifier may be supplied. This
indicates the number of characters or digits to be included in the representation of the value.</p><p>The width modifier, if present, is introduced by a comma or semicolon. It takes the form:</p><p>
                  <code>   ","  min-width ("-" max-width)?</code>
               </p><p>where <code>min-width</code> is either an unsigned integer indicating the minimum number of characters to
be output, or <code>*</code> indicating that there is no explicit minimum, and 
<code>max-width</code> is either an unsigned integer indicating the maximum number of characters to
be output, or <code>*</code> indicating that there is no explicit maximum; if <code>max-width</code>
is omitted then <code>*</code> is assumed. Both integers, if present, <rfc2119>must</rfc2119> be greater than zero.</p><p>A format token containing more than one digit, such as <code>001</code> or <code>9999</code>, sets the
minimum and maximum width to the number of digits appearing in the format token; if a width
modifier is also present, then the width modifier takes precedence.</p><p diff="add" at="D">A numeric format token may contain <var>optional-digit-signs</var>
               and <var>grouping-separators</var> as described for <code>fn:format-integer</code>. However, the
               grouping separator cannot be a closing square bracket (<code>"]"</code>).</p><note><p>A format token consisting of a single digit,
 such as <code>1</code>, does not constrain the number of digits in the output. 
 In the case of fractional seconds in particular, <code>[f001]</code> requests three decimal digits,
  <code>[f01]</code> requests two digits, but <code>[f1]</code> will produce an 
  implementation-defined number of digits. 
If exactly one digit is required, this can be achieved using the component specifier 
<code>[f1,1-1]</code>.</p></note><!--Text replaced by erratum XT.E24 change 2"--><p>If the minimum and maximum width are unspecified, then the output uses as 
many characters as are required to
represent the value of the component without truncation and without padding: this is referred to below
as the <emph>full representation</emph> of the value. 
For a timezone offset (component
specifier <code>z</code>), the full representation consists of a sign for the offset, the
number of hours of the offset, and if the offset is not an integral number of hours,
a colon (<code>:</code>) followed by the two digits of the minutes of the offset..
               </p><!--End of text replaced by erratum XT.E24--><p>If the full representation of the value exceeds the specified maximum width, then the processor
<rfc2119>should</rfc2119> attempt to use an alternative shorter representation that fits within 
the maximum width. Where the
presentation modifier is <code>N</code>, <code>n</code>, or <code>Nn</code>, 
this is done by abbreviating the name,
using either conventional abbreviations if available, or crude right-truncation if not. For example,
setting <code>max-width</code> to <code>4</code> indicates that four-letter abbreviations
 <rfc2119>should</rfc2119> be
used, though it would be acceptable to use a three-letter abbreviation if this is in conventional use.
(For example, "Tuesday" might be abbreviated to "Tues", and "Friday" to "Fri".) 
In the case of the year component, setting <code>max-width</code> requests omission of high-order
digits from the year, for example, if <code>max-width</code> is set to <code>2</code> then the year 2003
will be output as <code>03</code>. In the case of the fractional seconds 
component, the value is rounded to the specified size as if by applying the function
<code>round-half-to-even(fractional-seconds, max-width)</code>.
If no mechanism is available for fitting the value within the specified
maximum width (for example, when roman numerals are used), then the value <rfc2119>should</rfc2119> be 
output in its full representation.</p><!--Text replaced by erratum XT.E24 change 3"--><p>If the full representation of the value is shorter than the specified minimum width, then the processor
<rfc2119>should</rfc2119> pad the value to the specified width.</p><ulist><item><p>For decimal representations of 
numbers, this <rfc2119>should</rfc2119> be done by
prepending zero digits from the appropriate set of digit characters,
or appending zero digits in the case of the fractional
seconds component.</p></item><item><p>For timezone offsets this should be done by first appending 
a colon (<code>:</code>) followed by two
zero digits from the appropriate set of digit characters if the full
representation does not already include a minutes component and if
the specified minimum width permits adding three characters,
and then if necessary prepending zero digits from the
appropriate set of digit characters to the hour component.</p></item><item><p>In other cases, 
it <rfc2119>should</rfc2119> be done by appending spaces.</p></item></ulist></div4><div4 id="formatting-timezones" diff="add" at="D"><head>Formatting timezones</head><p>Special rules apply to the formatting of timezones. When the component specifiers <code>Z</code>
		      or <code>z</code> are used, the rules in this section override any rules given elsewhere in the case of
		      discrepancies.</p><p>If the date/time value to be formatted does not include a timezone offset, then the timezone component
		      specifier is generally ignored (results in no output). The exception is where military timezones are used
		      (format ZZ) in which case the string "J" is output, indicating local time.</p><ulist><item><p>When the component specifier is <code>z</code>, the output is the same as for component specifier
		      <code>Z</code>, except that it is prefixed by the characters <code>GMT</code> or some localized
		      equivalent. The prefix is omitted, however, in cases where the timezone is identified by name rather than by
		      a numeric offset from UTC.</p></item><item><p>If the first <var>presentation modifier</var> is numeric and comprises one or two digits 
		         with no <var>grouping-separator</var> (for example <code>1</code>
		      or <code>01</code>), then the timezone is formatted as a displacement from UTC in hours, preceded by a plus or minus
		      sign: for example <code>-5</code> or <code>+03</code>. If the actual timezone offset is not an integral number of hours,
		      then the minutes part of the offset is appended, separated by a colon: for example <code>+10:30</code> or 
		         <code>-1:15</code>.</p></item><item><p>If the first <var>presentation modifier</var> is numeric with a <var>grouping-separator</var> (for example <code>1:01</code>
		         or <code>01.01</code>), then the timezone offset is output in hours and minutes, separated by the grouping separator,
		      even if the number of minutes is zero: for example <code>+5:00</code> or <code>+10.30</code>.</p><p>If the first <var>presentation modifier</var> is numeric and comprises three or four digits with no
		      <var>grouping-separator</var>, for example <code>001</code> or <code>0001</code>, then the timezone offset
		      is shown in hours and minutes with no separator, for example <code>-0500</code> or <code>+1030</code>,
		      </p></item><item><p>If the first <var>presentation modifier</var> is numeric, in any of the above formats, and the second
		      <var>presentation modifier</var> is <code>t</code>, then a zero timezone offset (that is, UTC) is output as <code>Z</code> instead
		      of a signed numeric value. In this presentation modifier is absent or if the timezone offset is non-zero, 
		      then the displayed timezone offset is preceded by a "-" sign for negative offsets
		      or a "+" sign for non-negative offsets.</p></item><item><p>If the first <var>presentation modifier</var> is <code>Z</code>, then the timezone is formatted
		         as a military timezone letter, using the convention Z = +00:00, A = +01:00, B = +02:00, ..., M = +12:00, 
		         N = -01:00, O = -02:00, ... Y = -12:00. The letter J (meaning local time) is used in the case of a 
		         value that does not specify a timezone offset. Timezone offsets that have no representation in this system
		         (for example Indian Standard Time, +05:30) are output as if the format <code>01:01</code> had been requested.</p></item><item><p>If the first <var>presentation modifier</var> is <code>N</code>, then the timezone is output
		      (where possible) as a timezone name, for example <code>EST</code> or <code>CET</code>. The same timezone
		      offset has different names in different places; it is therefore <rfc2119>recommended</rfc2119> that this option
		      should be used only if a country code or Olson timezone name is supplied in the <code>$place</code> argument.
		      In the absence of this information, the implementation may apply a default, for example by using the timezone
		      names that are conventional in North America. If no timezone name can be identified, the timezone offset is
		      output using the fallback format <code>+01:01</code>.</p></item></ulist><p>The following examples illustrate options for timezone formatting.</p><table border="1" cellpadding="5"><thead><tr><th rowspan="1" colspan="1">Variable marker</th><th rowspan="1" colspan="1"><code>$place</code></th><th colspan="5" rowspan="1">Timezone offsets (with time = 12:00:00)</th></tr><tr><th rowspan="1" colspan="1"> </th><th rowspan="1" colspan="1"> </th><th rowspan="1" colspan="1">-10:00</th><th rowspan="1" colspan="1">-05:00</th><th rowspan="1" colspan="1">+00:00</th><th rowspan="1" colspan="1">+05:30</th><th rowspan="1" colspan="1">+13:00</th></tr></thead><tbody><tr><td rowspan="1" colspan="1">[Z]</td><td rowspan="1" colspan="1">()</td><td rowspan="1" colspan="1">-10:00</td><td rowspan="1" colspan="1">-05:00</td><td rowspan="1" colspan="1">+00:00</td><td rowspan="1" colspan="1">+05:30</td><td rowspan="1" colspan="1">+13:00</td></tr><tr><td rowspan="1" colspan="1">[Z0]</td><td rowspan="1" colspan="1">()</td><td rowspan="1" colspan="1">-10</td><td rowspan="1" colspan="1">-5</td><td rowspan="1" colspan="1">+0</td><td rowspan="1" colspan="1">+5:30</td><td rowspan="1" colspan="1">+13:00</td></tr><tr><td rowspan="1" colspan="1">[Z0:00]</td><td rowspan="1" colspan="1">()</td><td rowspan="1" colspan="1">-10:00</td><td rowspan="1" colspan="1">-5:00</td><td rowspan="1" colspan="1">+0:00</td><td rowspan="1" colspan="1">+5:30</td><td rowspan="1" colspan="1">+13:00</td></tr><tr><td rowspan="1" colspan="1">[Z00:00]</td><td rowspan="1" colspan="1">()</td><td rowspan="1" colspan="1">-10:00</td><td rowspan="1" colspan="1">-05:00</td><td rowspan="1" colspan="1">+00:00</td><td rowspan="1" colspan="1">+05:30</td><td rowspan="1" colspan="1">+13:00</td></tr><tr><td rowspan="1" colspan="1">[Z0000]</td><td rowspan="1" colspan="1">()</td><td rowspan="1" colspan="1">-1000</td><td rowspan="1" colspan="1">-0500</td><td rowspan="1" colspan="1">+0000</td><td rowspan="1" colspan="1">+0530</td><td rowspan="1" colspan="1">+1300</td></tr><tr><td rowspan="1" colspan="1">[Z00:00t]</td><td rowspan="1" colspan="1">()</td><td rowspan="1" colspan="1">-10:00</td><td rowspan="1" colspan="1">-05:00</td><td rowspan="1" colspan="1">Z</td><td rowspan="1" colspan="1">+05:30</td><td rowspan="1" colspan="1">+13:00</td></tr><tr><td rowspan="1" colspan="1">[z]</td><td rowspan="1" colspan="1">()</td><td rowspan="1" colspan="1">GMT-10:00</td><td rowspan="1" colspan="1">GMT-05:00</td><td rowspan="1" colspan="1">GMT+00:00</td><td rowspan="1" colspan="1">GMT+05:30</td><td rowspan="1" colspan="1">GMT+13:00</td></tr><tr><td rowspan="1" colspan="1">[ZZ]</td><td rowspan="1" colspan="1">()</td><td rowspan="1" colspan="1">W</td><td rowspan="1" colspan="1">R</td><td rowspan="1" colspan="1">Z</td><td rowspan="1" colspan="1">+05:30</td><td rowspan="1" colspan="1">+13:00</td></tr><tr><td rowspan="1" colspan="1">[ZN]</td><td rowspan="1" colspan="1">"us"</td><td rowspan="1" colspan="1">HST</td><td rowspan="1" colspan="1">EST</td><td rowspan="1" colspan="1">GMT</td><td rowspan="1" colspan="1">IST</td><td rowspan="1" colspan="1">+13:00</td></tr><tr><td rowspan="1" colspan="1">[H00]:[M00] [ZN]</td><td rowspan="1" colspan="1">"America/New_York"</td><td rowspan="1" colspan="1">06:00 EST</td><td rowspan="1" colspan="1">12:00 EST</td><td rowspan="1" colspan="1">07:00 EST</td><td rowspan="1" colspan="1">01:30 EST</td><td rowspan="1" colspan="1">18:00 EST</td></tr></tbody></table></div4><div4 id="lang-cal-place"><head>The language, calendar, and <phrase diff="chg" at="D">place</phrase> arguments</head><p>The set of languages, calendars, and <phrase diff="chg" at="D">places</phrase> that are supported in the 
<termref def="dt-date-formatting-function">date formatting functions</termref> is
<termref def="implementation-defined">implementation-defined</termref>. When
any of these arguments is omitted or is an empty sequence, an <termref def="implementation-defined">implementation-defined</termref>
default value is used.</p><imp-def-feature>The set of languages, calendars, and places that are supported in the 
<termref def="dt-date-formatting-function">date formatting functions</termref> is
implementation-defined. If any of these arguments is omitted or set to an empty sequence, 
the default is implementation-defined.</imp-def-feature><p>If the fallback representation uses a different calendar from that requested,
the output string <rfc2119>must</rfc2119> identify the calendar actually used, for example by
prefixing the string with <code>[Calendar: X]</code> (where X is the calendar actually used),
localized as appropriate to the
requested language. If the fallback representation uses a different language
from that requested, the output string <rfc2119>must</rfc2119> identify the language actually
used, for example by prefixing the string with <code>[Language: Y]</code> (where Y is the language
actually used) localized in an
implementation-dependent way. If a particular component of the value cannot be output in
the requested format, it <rfc2119>should</rfc2119> be output in the default format for
that component.</p><p>The <code>$language</code> argument specifies the language to be used for the result string 
of the function. The value of the argument <rfc2119>must</rfc2119> be either the empty sequence
or a value that would be valid for the <code>xml:lang</code> attribute (see [XML]).
Note that this permits the identification of sublanguages
based on country codes (from <bibref ref="ISO3166"/>) as well as identification of dialects
and of regions within a country.</p><p>If the <code>$language</code> 
argument is omitted or is set to an empty sequence, or if it is set to an invalid value or a
value that the implementation does not recognize, 
then the processor uses an <termref def="implementation-defined">implementation-defined</termref>
language.</p><p>The language is used to select the appropriate language-dependent forms of:</p><slist><sitem>names (for example, of months)</sitem><sitem>numbers expressed as words or as ordinals (<code>twenty, 20th, twentieth</code>)</sitem><sitem>hour convention (0-23 vs 1-24, 0-11 vs 1-12)</sitem><sitem>first day of week, first week of year</sitem></slist><p>Where appropriate this choice may also take into account the value of the
<code diff="chg" at="D">$place</code> argument, though this <rfc2119>should</rfc2119> not be used to override the
language or any sublanguage that is specified as part of the <code>language</code>
argument.</p><p>The choice of the names and abbreviations used in any given language is 
<termref def="implementation-defined">implementation-defined</termref>. For example,
one implementation might abbreviate July as <code>Jul</code> while another uses <code>Jly</code>. In German,
one implementation might represent Saturday as <code>Samstag</code> while another
uses <code>Sonnabend</code>. Implementations <rfc2119>may</rfc2119> provide mechanisms allowing users to
control such choices.</p><imp-def-feature>The choice of the names and abbreviations used in any given language for
calendar units such as days of the week and months of the year is 
<termref def="implementation-defined">implementation-defined</termref>.</imp-def-feature><p>Where ordinal numbers are used, the selection of the correct representation of the 
ordinal (for example, the linguistic gender) <rfc2119>may</rfc2119> depend on the component being formatted and on its
textual context in the picture string.</p><p>The <code>calendar</code> attribute specifies that the <code>dateTime</code>, <code>date</code>,
or <code>time</code> supplied in the <code>$value</code> argument <rfc2119>must</rfc2119> be 
converted to a value in the specified calendar and then converted to a string using the 
conventions of that calendar.</p><p>A calendar value <rfc2119>must</rfc2119> be a valid lexical QName. 
If the QName does not have a prefix, 
then it identifies a calendar with the designator specified below. 
If the QName has a prefix, then the QName is expanded into an expanded-QName 
using the in-scope namespaces from the static context; the expanded-QName identifies the calendar; 
the behavior in this case is <termref def="implementation-defined">implementation-defined</termref>.</p><p>If the calendar attribute is omitted an
 <termref def="implementation-defined">implementation-defined</termref> value is used.</p><note><p>The calendars listed below were known to be in use during the 
last hundred years. Many other calendars have been used in the past.</p><p>This specification does not define any of these calendars, nor the way that they
map to the value space of the <code>xs:date</code> data type in <bibref ref="xmlschema-2"/>.
There may be ambiguities when dates are recorded using different calendars. 
For example, the start of a new day is not simultaneous in different calendars, 
and may also vary geographically (for example, based on the time of sunrise or sunset).
Translation of dates is therefore more reliable when the time of day is also known, and
when the geographic location is known. 
When translating dates between
one calendar and another, the processor may take account of the values
of the <code diff="chg" at="D">$place</code> and/or <code>$language</code> arguments, with the 
                     <code diff="chg" at="D">$place</code>
argument taking precedence.</p><p>Information about some of these calendars, and algorithms for converting between them, may
be found in <bibref ref="CALCALC"/>.</p></note><table border="1" cellpadding="5"><thead><tr><th valign="top" align="left" rowspan="1" colspan="1">Designator</th><th valign="top" align="left" rowspan="1" colspan="1">Calendar</th></tr></thead><tbody><tr><td rowspan="1" colspan="1">AD</td><td rowspan="1" colspan="1">Anno Domini (Christian Era)</td></tr><tr><td rowspan="1" colspan="1">AH</td><td rowspan="1" colspan="1">Anno Hegirae (Muhammedan Era)</td></tr><tr><td rowspan="1" colspan="1">AME</td><td rowspan="1" colspan="1">Mauludi Era (solar years since Mohammed's birth)</td></tr><tr><td rowspan="1" colspan="1">AM</td><td rowspan="1" colspan="1">Anno Mundi (Jewish Calendar)</td></tr><tr><td rowspan="1" colspan="1">AP</td><td rowspan="1" colspan="1">Anno Persici</td></tr><tr><td rowspan="1" colspan="1">AS</td><td rowspan="1" colspan="1">Aji Saka Era (Java)</td></tr><tr><td rowspan="1" colspan="1">BE</td><td rowspan="1" colspan="1">Buddhist Era</td></tr><tr><td rowspan="1" colspan="1">CB</td><td rowspan="1" colspan="1">Cooch Behar Era</td></tr><tr><td rowspan="1" colspan="1">CE</td><td rowspan="1" colspan="1">Common Era</td></tr><tr><td rowspan="1" colspan="1">CL</td><td rowspan="1" colspan="1">Chinese Lunar Era</td></tr><tr><td rowspan="1" colspan="1">CS</td><td rowspan="1" colspan="1">Chula Sakarat Era</td></tr><tr><td rowspan="1" colspan="1">EE</td><td rowspan="1" colspan="1">Ethiopian Era</td></tr><tr><td rowspan="1" colspan="1">FE</td><td rowspan="1" colspan="1">Fasli Era</td></tr><tr><td rowspan="1" colspan="1">ISO</td><td rowspan="1" colspan="1">ISO 8601 calendar</td></tr><tr><td rowspan="1" colspan="1">JE</td><td rowspan="1" colspan="1">Japanese Calendar</td></tr><tr><td rowspan="1" colspan="1">KE</td><td rowspan="1" colspan="1">Khalsa Era (Sikh calendar)</td></tr><tr><td rowspan="1" colspan="1">KY</td><td rowspan="1" colspan="1">Kali Yuga</td></tr><tr><td rowspan="1" colspan="1">ME</td><td rowspan="1" colspan="1">Malabar Era</td></tr><tr><td rowspan="1" colspan="1">MS</td><td rowspan="1" colspan="1">Monarchic Solar Era</td></tr><tr><td rowspan="1" colspan="1">NS</td><td rowspan="1" colspan="1">Nepal Samwat Era</td></tr><tr><td rowspan="1" colspan="1">OS</td><td rowspan="1" colspan="1">Old Style (Julian Calendar)</td></tr><tr><td rowspan="1" colspan="1">RS</td><td rowspan="1" colspan="1">Rattanakosin (Bangkok) Era</td></tr><tr><td rowspan="1" colspan="1">SE</td><td rowspan="1" colspan="1">Saka Era</td></tr><tr><td rowspan="1" colspan="1">SH</td><td rowspan="1" colspan="1">Mohammedan Solar Era (Iran)</td></tr><tr><td rowspan="1" colspan="1">SS</td><td rowspan="1" colspan="1">Saka Samvat</td></tr><tr><td rowspan="1" colspan="1">TE</td><td rowspan="1" colspan="1">Tripurabda Era</td></tr><tr><td rowspan="1" colspan="1">VE</td><td rowspan="1" colspan="1">Vikrama Era</td></tr><tr><td rowspan="1" colspan="1">VS</td><td rowspan="1" colspan="1">Vikrama Samvat Era</td></tr></tbody></table><p>At least one of the above calendars <rfc2119>must</rfc2119> be supported. It is 
<termref def="implementation-defined">implementation-defined</termref> which
calendars are supported.</p><p>The ISO 8601 calendar (<bibref ref="ISO8601"/>), 
which is included in the above list and designated <code>ISO</code>, 
is very similar to the Gregorian calendar designated <code>AD</code>, but it
differs in several ways. The ISO calendar
    is intended to ensure that date and time formats can be read
    easily by other software, as well as being legible for human
    users. The ISO calendar
prescribes the use of particular numbering conventions as defined in
ISO 8601, rather than allowing these to be localized on a per-language basis. 
In particular it
    provides a numeric 'week date' format which identifies dates by
    year, week of the year, and day in the week; 
in the ISO calendar the days of the week are numbered from 1 (Monday) to 7 (Sunday), and
week 1 in any calendar year is the week (from Monday to Sunday) that includes the first Thursday
of that year. The numeric values of the components year, month, day, hour, minute, and second
are the same in the ISO calendar as the values used in the lexical representation of the date and
time as defined in <bibref ref="xmlschema-2"/>. The era ("E" component)
with this calendar is either a minus sign (for negative years) or a zero-length string (for positive years).
For dates before 1 January, AD 1, year numbers in
    the ISO and AD calendars are off by one from each other: ISO year
    0000 is 1 BC, -0001 is 2 BC, etc.</p><note><p>The value space of the date and time data types, as defined in XML Schema, is based on
absolute points in time. The lexical space of these data types defines a 
representation of these absolute points in time using the proleptic Gregorian calendar,
that is, the modern Western calendar extrapolated into the past and the future; but the value space
is calendar-neutral. The
<termref def="dt-date-formatting-function">date formatting functions</termref> produce a representation
of this absolute point in time, but denoted in a possibly different calendar. So,
for example, the date whose lexical representation in XML Schema is <code>1502-01-11</code> 
(the day on which Pope Gregory XIII was born) might be
formatted using the Old Style (Julian) calendar as <code>1 January 1502</code>. This reflects the fact
that there was at that time a ten-day difference between the two calendars. It would be
incorrect, and would produce incorrect results, to represent this date in an element or attribute 
of type <code>xs:date</code> as <code>1502-01-01</code>, even though this might reflect the way 
the date was recorded in contemporary documents.</p><p>When referring to years occurring in antiquity, modern historians generally
use a numbering system in which there is no year zero (the year before 1 CE
is thus 1 BCE). This is the convention that <rfc2119>should</rfc2119> be used when the
requested calendar is OS (Julian) or AD (Gregorian). When the requested
calendar is ISO, however, the conventions of ISO 8601 <rfc2119>should</rfc2119> be followed:
here the year before +0001 is numbered zero. In <bibref ref="xmlschema-2"/> (version 1.0), 
the value space for <code>xs:date</code> and <code>xs:dateTime</code>
does not include a year zero: however, a future edition is
expected to endorse the ISO 8601 convention. This means that the date on
which Julius Caesar was assassinated has the ISO 8601 lexical representation
-0043-03-13, but will be formatted as 15 March 44 BCE in the Julian calendar
or 13 March 44 BCE in the Gregorian calendar (dependant on the chosen
localization of the names of months and eras).</p></note><p>The intended use of the <code diff="chg" at="D">$place</code> argument is to identify
 the place where an event
represented by the <code>dateTime</code>, <code>date</code>,
or <code>time</code> supplied in the <code>$value</code> argument took place or will take place.
If the value is supplied, and is not the empty sequence, then it <rfc2119>should</rfc2119> 
                  <phrase diff="chg" at="D"> either be a country code or an Olson timezone name.</phrase></p><ulist diff="chg" at="D"><item><p>Country codes are defined in <bibref ref="ISO3166"/>. Examples are "de" for Germany
      and "jp" for Japan. Implementations <rfc2119>may</rfc2119> also allow the use
of codes representing subdivisions of a country from ISO 3166-2, or codes representing formerly used names of
countries from ISO 3166-3</p></item><item><p>Olson timezone names are defined in the public-domain <term>tz</term> timezone database <bibref ref="olson"/>.
   Examples are "America/New_York" and "Europe/Rome".</p></item></ulist><p>This argument is not intended to identify the location of the user 
for whom the date or time is being formatted;
that should be done by means of the <code>$language</code> attribute. 
This information 
<rfc2119>may</rfc2119> be used to provide additional information when converting dates between
calendars or when deciding how individual components of the date and time are to be formatted. 
For example, different countries using the Old Style (Julian) calendar started the new year on different
days, and some countries used variants of the calendar that were out of synchronization as a result of
differences in calculating leap years.</p><p>The geographical area identified by a country code is defined by the
  boundaries as they existed at the time of the date to be formatted,
  or the present-day boundaries for dates in the future.</p><p diff="add" at="D">If the <code>$place</code> argument is supplied in the form
               of an Olson timezone name that is recognized by the implementation, then the date or
               time being formatted is adjusted to the timezone offset applicable in that timezone.
               For example, if the <code>xs:dateTime</code> value <code>2010-02-15T12:00:00Z</code>
                  is formatted with the <code>$place</code> argument set to
                  <code>America/New_York</code>, then the output will be as if the value
                  <code>2010-02-15T07:00:00-05:00</code> had been supplied. This adjustment takes daylight
                  savings time into account where possible; if the date in question falls during
                  daylight savings time in New York, then it is adjusted to timezone offset <code>-PT4H</code>
                  rather than <code>-PT5H</code>. Adjustment using daylight savings time is only possible
                  where the value includes a date, and where the date is within the range covered
                  by the timezone database.</p></div4></div3><div3 id="date-time-examples"><head>Examples of date and time formatting</head><example><head>Gregorian calendar</head><p>The following examples show a selection of dates and times and the way they might
be formatted. These examples assume the use of the Gregorian calendar as the default calendar.</p><table border="1" cellpadding="5"><thead><tr><th align="left" rowspan="1" colspan="1">Required Output</th><th align="left" rowspan="1" colspan="1">Expression</th></tr></thead><tbody><tr><td rowspan="1" colspan="1">
                              <code>2002-12-31</code>
                           </td><td rowspan="1" colspan="1">
                              <code>format-date($d, "[Y0001]-[M01]-[D01]")</code>
                           </td></tr><tr><td rowspan="1" colspan="1">
                              <code>12-31-2002</code>
                           </td><td rowspan="1" colspan="1">
                              <code>format-date($d, "[M]-[D]-[Y]")</code>
                           </td></tr><tr><td rowspan="1" colspan="1"> 
                              <code>31-12-2002</code>
                           </td><td rowspan="1" colspan="1">
                              <code>format-date($d, "[D]-[M]-[Y]")</code>
                           </td></tr><tr><td rowspan="1" colspan="1">
                              <code>31 XII 2002</code>
                           </td><td rowspan="1" colspan="1">
                              <code>format-date($d, "[D1] [MI] [Y]")</code>
                           </td></tr><tr><td rowspan="1" colspan="1">
                              <code>31st December, 2002</code>
                           </td><td rowspan="1" colspan="1">
                              <code>format-date($d, "[D1o] [MNn], [Y]", "en", (), ())</code>
                           </td></tr><tr><td rowspan="1" colspan="1">
                              <code>31 DEC 2002</code>
                           </td><td rowspan="1" colspan="1">
                              <code>format-date($d, "[D01] [MN,*-3] [Y0001]", "en", (), ())</code>
                           </td></tr><tr><td rowspan="1" colspan="1">
                              <code>December 31, 2002</code>
                           </td><td rowspan="1" colspan="1">
                              <code>format-date($d, "[MNn] [D], [Y]", "en", (), ())</code>
                           </td></tr><tr><td rowspan="1" colspan="1">
                              <code>31 Dezember, 2002</code>
                           </td><td rowspan="1" colspan="1">
                              <code>format-date($d, "[D] [MNn], [Y]", "de", (), ())</code>
                           </td></tr><tr><td rowspan="1" colspan="1">
                              <code>Tisdag 31 December 2002</code>
                           </td><td rowspan="1" colspan="1">
                              <code>format-date($d, "[FNn] [D] [MNn] [Y]", "sv", (), ())</code>
                           </td></tr><tr><td rowspan="1" colspan="1">
                              <code>[2002-12-31]</code>
                           </td><td rowspan="1" colspan="1">
                              <code>format-date($d, "[[[Y0001]-[M01]-[D01]]]")</code>
                           </td></tr><tr><td rowspan="1" colspan="1">
                              <code>Two Thousand and Three</code>
                           </td><td rowspan="1" colspan="1">
                              <code>format-date($d, "[YWw]", "en", (), ())</code>
                           </td></tr><tr><td rowspan="1" colspan="1">
                              <code>einunddreißigste Dezember</code>
                           </td><td rowspan="1" colspan="1">
                              <code>format-date($d, "[Dwo] [MNn]", "de", (), ())</code>
                           </td></tr><tr><td rowspan="1" colspan="1">
                              <code>3:58 PM</code>
                           </td><td rowspan="1" colspan="1">
                              <code>format-time($t, "[h]:[m01] [PN]", "en", (), ())</code>
                           </td></tr><tr><td rowspan="1" colspan="1">
                              <code>3:58:45 pm</code>
                           </td><td rowspan="1" colspan="1">
                              <code>format-time($t, "[h]:[m01]:[s01] [Pn]", "en", (), ())</code>
                           </td></tr><tr><td rowspan="1" colspan="1">
                              <code>3:58:45 PM PDT</code>
                           </td><td rowspan="1" colspan="1">
                              <code>format-time($t, "[h]:[m01]:[s01] [PN] [ZN,*-3]", "en", (), ())</code>
                           </td></tr><tr><td rowspan="1" colspan="1">
                              <code>3:58:45 o'clock PM PDT</code>
                           </td><!--Text replaced by erratum E22 change 1"--><td rowspan="1" colspan="1">
                              <code>format-time($t, "[h]:[m01]:[s01] o'clock [PN] [ZN,*-3]", "en", (), ())</code>
                           </td><!--End of text replaced by erratum E22--></tr><tr><td rowspan="1" colspan="1">
                              <code>15:58</code>
                           </td><td rowspan="1" colspan="1">
                              <code>format-time($t,"[H01]:[m01]")</code>
                           </td></tr><tr><td rowspan="1" colspan="1">
                              <code>15:58:45.762</code>
                           </td><td rowspan="1" colspan="1">
                              <code>format-time($t,"[H01]:[m01]:[s01].[f001]")</code>
                           </td></tr><tr><td rowspan="1" colspan="1">
                              <code>15:58:45 GMT+02:00</code>
                           </td><!--Text replaced by erratum E24 change 4"--><td rowspan="1" colspan="1">
                              <code>format-time($t,"[H01]:[m01]:[s01] [z,6-6]", "en", (), ())</code>
                           </td><!--End of text replaced by erratum E24--></tr><tr><!--Text replaced by erratum E24 change 5"--><td rowspan="1" colspan="1">
                              <code>15.58 Uhr GMT+2</code>
                           </td><!--End of text replaced by erratum E24--><td rowspan="1" colspan="1">
                              <code>format-time($t,"[H01]:[m01] Uhr [z]", "de", (), ())</code>
                           </td></tr><tr><td rowspan="1" colspan="1">
                              <code>3.58pm on Tuesday, 31st December</code>
                           </td><td rowspan="1" colspan="1">
                              <code>format-dateTime($dt, "[h].[m01][Pn] on [FNn], [D1o] [MNn]")</code>
                           </td></tr><tr><td rowspan="1" colspan="1">
                              <code>12/31/2002 at 15:58:45</code>
                           </td><td rowspan="1" colspan="1">
                              <code>format-dateTime($dt, "[M01]/[D01]/[Y0001] at [H01]:[m01]:[s01]")</code>
                           </td></tr></tbody></table></example><example><head>Non-Gregorian calendars</head><p>The following examples use calendars other than the Gregorian calendar.</p><p>These examples use non-Latin characters which might not display
correctly in all browsers, depending on the system configuration.</p><table border="1" cellpadding="5"><thead><tr><th align="left" rowspan="1" colspan="1">Description</th><th align="left" rowspan="1" colspan="1">Request</th><th align="left" rowspan="1" colspan="1">Result</th></tr></thead><tbody><tr><td valign="top" rowspan="1" colspan="1">Islamic</td><!--Text replaced by erratum E23 change 1"--><td valign="top" rowspan="1" colspan="1">
                              <code>format-date($d, "[D&amp;#x0661;] [Mn] [Y&amp;#x0661;]", "ar", "AH", ())</code>
                           </td><!--End of text replaced by erratum E23--><td valign="top" rowspan="1" colspan="1">٢٦ ﺸﻭّﺍﻝ ١٤٢٣</td></tr><tr><td valign="top" rowspan="1" colspan="1">Jewish (with Western numbering)</td><td valign="top" rowspan="1" colspan="1">
                              <code>format-date($d, "[D] [Mn] [Y]", "he", "AM", ())</code>
                           </td><td valign="top" rowspan="1" colspan="1">‏26 טבת 5763</td></tr><tr><td valign="top" rowspan="1" colspan="1">Jewish (with traditional numbering)</td><td valign="top" rowspan="1" colspan="1">
                              <code>format-date($d, "[D&amp;#x05D0;t] [Mn] [Y&amp;#x05D0;t]", "he", "AM", ())</code>
                           </td><td valign="top" rowspan="1" colspan="1">כ״ו טבת תשס״ג</td></tr><tr><td valign="top" rowspan="1" colspan="1">Julian (Old Style)</td><td valign="top" rowspan="1" colspan="1">
                              <code>format-date($d, "[D] [MNn] [Y]", "en", "OS", ())</code>
                           </td><td valign="top" rowspan="1" colspan="1">18 December 2002</td></tr><tr><td valign="top" rowspan="1" colspan="1">Thai</td><td valign="top" rowspan="1" colspan="1">
                              <code>format-date($d, "[D&amp;#x0E51;] [Mn] [Y&amp;#x0E51;]", "th", "BE", ())</code>
                           </td><td valign="top" rowspan="1" colspan="1">๓๑ ธันวาคม 
๒๕๔๕</td></tr></tbody></table></example></div3></div2></div1><div1 id="QName-funcs"><head>Functions related to QNames</head><div2 id="QName-constructors"><head>Functions to create a QName</head><p>In addition to the <code>xs:QName</code> constructor function, QName values can
               be constructed by combining a namespace URI, prefix, and local name, or by resolving
               a lexical QName against the in-scope namespaces of an element node. This section
                    defines these functions. 
					Leading and trailing whitespace, if present, is stripped from
                    string arguments before the result is constructed.</p><?local-function-index?><div3 id="func-resolve-QName"><head><?function fn:resolve-QName?></head></div3><div3 id="func-QName"><head><?function fn:QName?></head></div3></div2><div2 id="QName-functions"><head>Functions and operators related to QNames</head><p>This section specifies functions on QNames as defined in <bibref ref="xmlschema-2"/>.</p><?local-function-index?><div3 id="func-QName-equal"><head><?function op:QName-equal?></head></div3><div3 id="func-prefix-from-QName"><head><?function fn:prefix-from-QName?></head></div3><div3 id="func-local-name-from-QName"><head><?function fn:local-name-from-QName?></head></div3><div3 id="func-namespace-uri-from-QName"><head><?function fn:namespace-uri-from-QName?></head></div3><div3 id="func-namespace-uri-for-prefix"><head><?function fn:namespace-uri-for-prefix?></head></div3><div3 id="func-in-scope-prefixes"><head><?function fn:in-scope-prefixes?></head></div3></div2></div1><div1 id="binary-functions"><head>Operators on base64Binary and hexBinary</head><div2 id="binary-value-comparisons"><head>Comparisons of base64Binary and hexBinary values</head><p>The following comparison operators on <code>xs:base64Binary</code> and
                    <code>xs:hexBinary</code> values are defined. Comparisons take two operands of
                    the same type; that is, both operands must be <code>xs:base64Binary</code> or
                    both operands may be <code>xs:hexBinary</code>. Each returns a boolean value.</p><p>A value of type <code>xs:hexBinary</code> can be compared with a value of type
                    <code>xs:base64Binary</code> by casting one value to the other type. See
                        <specref ref="casting-to-binary"/>.</p><?local-function-index?><div3 id="func-hexBinary-equal"><head><?function op:hexBinary-equal?></head></div3><div3 id="func-base64Binary-equal"><head><?function op:base64Binary-equal?></head></div3></div2></div1><div1 id="NOTATION-functions"><head>Operators on NOTATION</head><p>This section specifies operators that take <code>xs:NOTATION</code> values as arguments.</p><?local-function-index?><div2 id="func-NOTATION-equal"><head><?function op:NOTATION-equal?></head></div2></div1><div1 id="node-functions"><head>Functions and operators on nodes</head><p>This section specifies functions and operators on nodes. Nodes are formally defined
                in <xspecref spec="DM" ref="Node"/>.</p><?local-function-index?><p>For the illustrative examples below assume an XQuery or transformation operating on a
                PurchaseOrder document containing a number of line-item elements. Each line-item has
                child elements called description, price, quantity, etc. whose content is different
                for each line-item. Quantity has simple content of type <code>xs:decimal</code>.
                Further assume that variables <code>$item1</code>, <code>$item2</code>, etc. are
                each bound to single line-item element nodes in the document in sequence and that
                the value of the quantity child of the first line-item is <code>5.0</code>.</p><p role="global-variable-binding">let <code>$po</code> :=
<eg xml:space="preserve">&lt;PurchaseOrder&gt;
  &lt;line-item&gt;
    &lt;description&gt;Large widget&lt;/description&gt;
    &lt;price&gt;8.95&lt;/price&gt;
    &lt;quantity&gt;5.0&lt;/quantity&gt;
  &lt;/line-item&gt;
  &lt;line-item&gt;
    &lt;description&gt;Small widget&lt;/description&gt;
    &lt;price&gt;3.99&lt;/price&gt;
    &lt;quantity&gt;2.0&lt;/quantity&gt;
  &lt;/line-item&gt;
  &lt;line-item&gt;
    &lt;description&gt;Tiny widget&lt;/description&gt;
    &lt;price&gt;1.49&lt;/price&gt;
    &lt;quantity&gt;805&lt;/quantity&gt;
  &lt;/line-item&gt;
&lt;/PurchaseOrder&gt;</eg></p><p role="global-variable-binding">let <code>$item1</code> := <code>$po/line-item[1]</code></p><p role="global-variable-binding">let <code>$item2</code> := <code>$po/line-item[2]</code></p><p role="global-variable-binding">let <code>$item3</code> := <code>$po/line-item[3]</code></p><div2 id="func-name"><head><?function fn:name?></head></div2><div2 id="func-local-name"><head><?function fn:local-name?></head></div2><div2 id="func-namespace-uri"><head><?function fn:namespace-uri?></head></div2><div2 id="func-number"><head><?function fn:number?></head></div2><div2 id="func-lang"><head><?function fn:lang?></head></div2><div2 id="func-is-same-node"><head><?function op:is-same-node?></head></div2><div2 id="func-node-before"><head><?function op:node-before?></head></div2><div2 id="func-node-after"><head><?function op:node-after?></head></div2><div2 id="func-root"><head><?function fn:root?></head></div2></div1><div1 id="sequence-functions"><head>Functions and operators on sequences</head><p>A <code>sequence</code> is an ordered collection of zero or more <code>items</code>.
                An <code>item</code> is either a node or an atomic value. The terms
                <code>sequence</code> and <code>item</code> are defined formally in <bibref ref="xquery"/> and <bibref ref="xpath20"/>. </p><div2 id="general-seq-funcs"><head>General functions and operators on sequences</head><p>The following functions are defined on sequences. These functions work on any sequence, without performing
            any operations that are sensitive to the individual items in the sequence.</p><?local-function-index?><p>As in the previous section, for the illustrative examples below, assume an XQuery
                    or transformation operating on a non-empty Purchase Order document containing a
                    number of line-item elements. The variable <code>$seq</code> is bound to the
                    sequence of line-item nodes in document order. The variables
                    <code>$item1</code>, <code>$item2</code>, etc. are bound to separate, individual
                    line-item nodes in the sequence.</p><div3 id="func-concatenate"><head><?function op:concatenate?></head></div3><div3 id="func-empty"><head><?function fn:empty?></head></div3><div3 id="func-exists"><head><?function fn:exists?></head></div3><div3 id="func-head" diff="add" at="E"><head><?function fn:head?></head></div3><div3 id="func-tail" diff="add" at="E"><head><?function fn:tail?></head></div3><div3 id="func-insert-before"><head><?function fn:insert-before?></head></div3><div3 id="func-remove"><head><?function fn:remove?></head></div3><div3 id="func-reverse"><head><?function fn:reverse?></head></div3><div3 id="func-subsequence"><head><?function fn:subsequence?></head></div3><div3 id="func-unordered"><head><?function fn:unordered?></head></div3></div2><div2 id="comparing-sequences"><head>Functions that compare values in sequences</head><p>The functions in this section rely on comparisons between the items in one or more
            sequences.</p><?local-function-index?><div3 id="func-distinct-values"><head><?function fn:distinct-values?></head></div3><div3 id="func-index-of"><head><?function fn:index-of?></head></div3><div3 id="func-deep-equal"><head><?function fn:deep-equal?></head></div3></div2><div2 id="cardinality-functions"><head>Functions that test the cardinality of sequences</head><p>The following functions test the cardinality of their sequence arguments.</p><?local-function-index?><p>The functions <code>fn:zero-or-one</code>, <code>fn:one-or-more</code>, and
                    <code>fn:exactly-one</code> defined in this section, check that the cardinality
                    of a sequence is in the expected range. They are particularly useful with regard
                    to static typing. For example, the function call <code>fn:remove($seq, fn:index-of($seq2, 'abc'))</code>
                    requires the result of the call on <code>fn:index-of</code> to be a singleton integer, 
                    but the static type system cannot infer this; writing the expression as 
                    <code>fn:remove($seq, fn:exactly-one(fn:index-of($seq2, 'abc')))</code> 
                    will provide a suitable static type at query analysis time, and ensures that the length of the sequence is
                    correct with a dynamic check at query execution time.</p><p>The type signatures for these functions deliberately declare the argument type as
                    <code>item()*</code>, permitting a sequence of any length. A more restrictive
                    signature would defeat the purpose of the function, which is to defer
                    cardinality checking until query execution time.</p><div3 id="func-zero-or-one"><head><?function fn:zero-or-one?></head></div3><div3 id="func-one-or-more"><head><?function fn:one-or-more?></head></div3><div3 id="func-exactly-one"><head><?function fn:exactly-one?></head></div3></div2><div2 id="union-intersection-except"><head>Union, intersection and difference</head><?local-function-index?><p>As in the previous sections, for the illustrative examples below, assume an
                    XQuery or transformation operating on a Purchase Order document containing a
                    number of line-item elements. The variables <code>$item1</code>,
                    <code>$item2</code>, etc. are bound to individual line-item nodes in the
                    sequence. We use sequences of these nodes in some of the examples below.</p><div3 id="func-union"><head><?function op:union?></head></div3><div3 id="func-intersect"><head><?function op:intersect?></head></div3><div3 id="func-except"><head><?function op:except?></head></div3></div2><div2 id="aggregate-functions"><head>Aggregate functions</head><p>Aggregate functions take a sequence as argument and return a single value
                    computed from values in the sequence. Except for <code>fn:count</code>, the
                    sequence must consist of values of a single type or one if its subtypes, or they
                    must be numeric. <code>xs:untypedAtomic</code> values are permitted in the
                    input sequence and handled by special conversion rules. The type of the items in
                    the sequence must also support certain operations.</p><?local-function-index?><div3 id="func-count"><head><?function fn:count?></head></div3><div3 id="func-avg"><head><?function fn:avg?></head></div3><div3 id="func-max"><head><?function fn:max?></head></div3><div3 id="func-min"><head><?function fn:min?></head></div3><div3 id="func-sum"><head><?function fn:sum?></head></div3></div2><div2 id="fns-that-generate-sequences"><head>Functions and operators that generate sequences</head><?local-function-index?><div3 id="func-to"><head><?function op:to?></head></div3></div2><div2 id="fns-on-identifiers"><head>Functions on node identifiers</head><div3 id="func-id"><head><?function fn:id?></head></div3><div3 id="func-element-with-id" diff="add" at="A"><head><?function fn:element-with-id?></head></div3><div3 id="func-idref"><head><?function fn:idref?></head></div3><div3 id="func-generate-id" diff="add" at="A"><head><?function fn:generate-id?></head></div3></div2><div2 id="fns-on-docs"><head>Functions giving access to external information</head><div3 id="func-doc"><head><?function fn:doc?></head></div3><div3 id="func-doc-available"><head><?function fn:doc-available?></head></div3><div3 id="func-collection"><head><?function fn:collection?></head></div3><div3 id="func-uri-collection" diff="add" at="C"><head><?function fn:uri-collection?></head></div3><div3 id="func-unparsed-text" diff="add" at="F"><head><?function fn:unparsed-text?></head></div3><div3 id="func-unparsed-text-available" diff="add" at="F"><head><?function fn:unparsed-text-available?></head></div3><div3 id="func-get-environment-variable" diff="add" at="F"><head><?function fn:get-environment-variable?></head></div3><div3 id="func-available-environment-variables" diff="add" at="F"><head><?function fn:available-environment-variables?></head></div3></div2><div2 id="parsing-and-serializing"><head>Parsing and serializing</head><div3 id="func-parse-xml" diff="add" at="A"><head><?function fn:parse-xml?></head></div3><div3 id="func-serialize" diff="add" at="A"><head><?function fn:serialize?></head></div3></div2></div1><div1 id="context"><head>Context functions</head><p>The following functions are defined to obtain information from the dynamic context.</p><?local-function-index?><div2 id="func-position"><head><?function fn:position?></head></div2><div2 id="func-last"><head><?function fn:last?></head></div2><div2 id="func-current-dateTime"><head><?function fn:current-dateTime?></head></div2><div2 id="func-current-date"><head><?function fn:current-date?></head></div2><div2 id="func-current-time"><head><?function fn:current-time?></head></div2><div2 id="func-implicit-timezone"><head><?function fn:implicit-timezone?></head></div2><div2 id="func-default-collation"><head><?function fn:default-collation?></head></div2><div2 id="func-static-base-uri"><head><?function fn:static-base-uri?></head></div2></div1><div1 id="higher-order-functions" diff="add" at="B"><head>Higher-order functions</head><div2 id="functions-on-functions"><head>Functions on functions</head><p>The following functions operate on function items, that is, values referring to a function.</p><?local-function-index?><div3 id="func-function-name"><head><?function fn:function-name?></head></div3><div3 id="func-function-arity"><head><?function fn:function-arity?></head></div3></div2><div2 id="basic-hofs" diff="add" at="D"><head>Basic higher-order functions</head><p>The following functions take function items as an argument.</p><?local-function-index?><div3 id="func-map"><head><?function fn:map?></head></div3><div3 id="func-filter"><head><?function fn:filter?></head></div3><div3 id="func-fold-left"><head><?function fn:fold-left?></head></div3><div3 id="func-fold-right"><head><?function fn:fold-right?></head></div3><div3 id="func-map-pairs"><head><?function fn:map-pairs?></head></div3></div2></div1><div1 id="constructor-functions"><head>Constructor functions</head><div2 id="constructor-functions-for-xsd-types"><head>Constructor functions for XML Schema built-in types</head><ednote><edtext>The following reference needs to be rephrased so it refers to "whichever
                version of XSD the implementation chooses to support".</edtext></ednote><p>Every built-in atomic type that is defined in <bibref ref="xmlschema-2"/>, except <code>xs:anyAtomicType</code> and <code>xs:NOTATION</code>, has an
                    associated constructor function. <code>xs:untypedAtomic</code>, defined
                    in <xspecref spec="DM" ref="types"/> and the two derived types
                    <code>xs:yearMonthDuration</code> and <code>xs:dayTimeDuration</code> defined
                    in <xspecref spec="DM" ref="types"/> also have associated constructor functions.</p><p>
A constructor function is not defined for <code>xs:anyAtomicType</code> as there are no atomic values with type annotation <code>xs:anyAtomicType</code> at runtime, although this can be a statically inferred type.
A constructor function is not defined for <code>xs:NOTATION</code> since it is defined as an abstract type in <bibref ref="xmlschema-2"/>.  If the static context (See <xspecref spec="XP" ref="static_context"/>) contains a type derived from
<code>xs:NOTATION</code> then a constructor function is defined for it.
See <specref ref="constructor-functions-for-user-defined-types"/>.
</p><p> 
The form of the constructor function for a type
                    <emph>prefix:TYPE</emph> is:</p><example role="signature"><proto name="prefix:TYPE" return-type="prefix:TYPE" role="example" returnEmptyOk="yes" isSpecial="yes" returnSeq="no" prefix="fn" returnVaries="no" isSchema="no" isDatatype="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto></example><p>If <code>$arg</code> is the empty sequence, the empty sequence is returned. For
                    example, the signature of the constructor function corresponding to the
                    <code>xs:unsignedInt</code> type defined in <bibref ref="xmlschema-2"/> is:</p><example role="signature"><proto name="unsignedInt" return-type="xs:unsignedInt" isSchema="yes" returnEmptyOk="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto></example><p>Invoking the constructor function <code>xs:unsignedInt(12)</code> returns
                    the <code> xs:unsignedInt</code> value 12. Another invocation of that constructor
                    function that returns the same <code>xs:unsignedInt</code> value is
                    <code>xs:unsignedInt("12")</code>. The same result would also be returned if the
                    constructor function were to be invoked with a node that had a typed value equal
                    to the <code>xs:unsignedInt</code> 12. The standard features described in
                        <xspecref spec="XP" ref="id-atomization"/> would 'atomize' the node to
                    extract its typed value and then call the constructor with that value. If the
                    value passed to a constructor is illegal for the datatype to be constructed, an
                    error is raised <errorref class="RG" code="0001"/>.</p><p>The semantics of the constructor function <quote>
                        <code>xs:TYPE(arg)</code>
                    </quote> are identical to the semantics of <quote>
                        <code>arg</code> cast as <code>xs:TYPE?</code>
                    </quote>. See <specref ref="casting"/>.</p><p>If the argument to a constructor function is a literal, the result of the
                    function may be evaluated statically; if an error is found during such
                    evaluation, it may be reported as a static error. </p><p>Special rules apply to constructor functions for <code>xs:QName</code> and types derived from <code>xs:QName</code> and <code>xs:NOTATION</code>. See 
<specref ref="constructor-qname-notation"/>.
</p><p>The following constructor functions for the built-in types are supported:</p><ulist><item><proto name="string" return-type="xs:string" returnEmptyOk="yes" isSchema="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto></item><item><proto name="boolean" return-type="xs:boolean" returnEmptyOk="yes" isSchema="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto></item><item><proto name="decimal" return-type="xs:decimal" returnEmptyOk="yes" isSchema="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto></item><item><proto name="float" return-type="xs:float" returnEmptyOk="yes" isSchema="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto><p diff="chg" at="F">Implementations <rfc2119>should</rfc2119> return negative zero for <code>xs:float("-0.0E0")</code>.  
                           But because <bibref ref="xmlschema-2"/> does not distinguish between the values positive zero and negative zero.
                           implementations <termref def="may"/> return positive zero in this case.</p></item><item><proto name="double" return-type="xs:double" returnEmptyOk="yes" isSchema="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto><p diff="chg" at="F">Implementations <rfc2119>should</rfc2119> return negative zero for <code>xs:double("-0.0E0")</code>.  
                          But because <bibref ref="xmlschema-2"/> does not distinguish between the values positive zero and negative zero.
                          implementations <termref def="may"/> return positive zero in this case.</p></item><item><proto name="duration" return-type="xs:duration" returnEmptyOk="yes" isSchema="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto></item><item><proto name="dateTime" return-type="xs:dateTime" returnEmptyOk="yes" isSchema="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto></item><item><proto name="time" return-type="xs:time" returnEmptyOk="yes" isSchema="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto></item><item><proto name="date" return-type="xs:date" returnEmptyOk="yes" isSchema="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto></item><item><proto name="gYearMonth" return-type="xs:gYearMonth" returnEmptyOk="yes" isSchema="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto></item><item><proto name="gYear" return-type="xs:gYear" returnEmptyOk="yes" isSchema="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto></item><item><proto name="gMonthDay" return-type="xs:gMonthDay" returnEmptyOk="yes" isSchema="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto></item><item><proto name="gDay" return-type="xs:gDay" returnEmptyOk="yes" isSchema="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto></item><item><proto name="gMonth" return-type="xs:gMonth" returnEmptyOk="yes" isSchema="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto></item><item><proto name="hexBinary" return-type="xs:hexBinary" returnEmptyOk="yes" isSchema="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto></item><item><proto name="base64Binary" return-type="xs:base64Binary" returnEmptyOk="yes" isSchema="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto></item><item><proto name="anyURI" return-type="xs:anyURI" returnEmptyOk="yes" isSchema="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto></item><item><proto name="QName" return-type="xs:QName" returnEmptyOk="yes" isSchema="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="no"/></proto><p>
                            See <specref ref="constructor-qname-notation"/> for special rules.</p></item></ulist><ulist><item><proto name="normalizedString" return-type="xs:normalizedString" returnEmptyOk="yes" isSchema="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto></item><item><proto name="token" return-type="xs:token" returnEmptyOk="yes" isSchema="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto></item><item><proto name="language" return-type="xs:language" returnEmptyOk="yes" isSchema="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto></item><item><proto name="NMTOKEN" return-type="xs:NMTOKEN" returnEmptyOk="yes" isSchema="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto></item><item><proto name="Name" return-type="xs:Name" returnEmptyOk="yes" isSchema="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto></item><item><proto name="NCName" return-type="xs:NCName" returnEmptyOk="yes" isSchema="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto></item><item><proto name="ID" return-type="xs:ID" returnEmptyOk="yes" isSchema="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto></item><item><proto name="IDREF" return-type="xs:IDREF" returnEmptyOk="yes" isSchema="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto></item><item><proto name="ENTITY" return-type="xs:ENTITY" returnEmptyOk="yes" isSchema="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto><p>See <specref ref="casting-to-ENTITY"/> for rules related to constructing values of type <code>xs:ENTITY</code> and types derived from it.</p></item><item><proto name="integer" return-type="xs:integer" returnEmptyOk="yes" isSchema="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto></item><item><proto name="nonPositiveInteger" return-type="xs:nonPositiveInteger" returnEmptyOk="yes" isSchema="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto></item><item><proto name="negativeInteger" return-type="xs:negativeInteger" returnEmptyOk="yes" isSchema="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto></item><item><proto name="long" return-type="xs:long" returnEmptyOk="yes" isSchema="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto></item><item><proto name="int" return-type="xs:int" returnEmptyOk="yes" isSchema="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto></item><item><proto name="short" return-type="xs:short" returnEmptyOk="yes" isSchema="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto></item><item><proto name="byte" return-type="xs:byte" returnEmptyOk="yes" isSchema="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto></item><item><proto name="nonNegativeInteger" return-type="xs:nonNegativeInteger" returnEmptyOk="yes" isSchema="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto></item><item><proto name="unsignedLong" return-type="xs:unsignedLong" returnEmptyOk="yes" isSchema="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto></item><item><proto name="unsignedInt" return-type="xs:unsignedInt" returnEmptyOk="yes" isSchema="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto></item><item><proto name="unsignedShort" return-type="xs:unsignedShort" returnEmptyOk="yes" isSchema="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto></item><item><proto name="unsignedByte" return-type="xs:unsignedByte" returnEmptyOk="yes" isSchema="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto></item><item><proto name="positiveInteger" return-type="xs:positiveInteger" returnEmptyOk="yes" isSchema="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto></item></ulist><ulist><item><proto name="yearMonthDuration" return-type="xs:yearMonthDuration" returnEmptyOk="yes" isSchema="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto></item><item><proto name="dayTimeDuration" return-type="xs:dayTimeDuration" returnEmptyOk="yes" isSchema="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto></item><item><proto name="untypedAtomic" return-type="xs:untypedAtomic" returnEmptyOk="yes" isSchema="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto></item></ulist><ulist><item><proto name="dateTimeStamp" return-type="xs:dateTimeStamp" returnEmptyOk="yes" isSchema="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto></item></ulist></div2><div2 id="constructor-qname-notation"><head>Constructor functions for xs:QName and xs:NOTATION</head><p>Special rules apply to constructor functions for the types <code>xs:QName</code> and <code>xs:NOTATION</code>, for two reasons:</p><ulist><item><p>
Values cannot belong directly to the type <code>xs:NOTATION</code>, only to its subtypes.
</p></item><item><p>
The lexical representation of these types uses namespace prefixes, whose
meaning is context-dependent.</p></item></ulist><p>
These constraints result in the following rules:</p><olist><item><p>
There is no constructor function for <code>xs:NOTATION</code>. Constructors are defined, however, for <code>xs:QName</code>, 
   for types derived from <code>xs:QName</code>, and for types derived from <code>xs:NOTATION</code>.
</p></item><item><p>When converting from an <code>xs:string</code>, the prefix within the lexical 
      <code>xs:QName</code> supplied
      as the argument is resolved to a namespace URI using the statically known
      namespaces from the static context. If the lexical <code>xs:QName</code>
      has no prefix, the
      namespace URI of the resulting expanded-QName is the default element/type
      namespace from the static context. Components of the static context are
      discussed in <xspecref spec="XP" ref="static_context"/>. A static error is raised <errorref class="NS" code="0004"/>
      if the prefix is not bound in the static context. As described in
      <xspecref spec="DM" ref="terminology"/>, the supplied prefix is retained as part of the
      expanded-QName value.</p></item><item><p diff="del" at="F">
      Conversion from an <code>xs:string</code> to a value of type <code>xs:QName</code>, a type derived from  <code>xs:QName</code> 
      or a type derived from <code>xs:NOTATION</code> is permitted only if the <code>xs:string</code> is written as a string literal. 
      This applies whether the conversion is expressed using a constructor function or using the "cast as" syntax. Such a conversion can be regarded as a pseudo-function, which is always evaluated statically. It is also permitted for these constructors and casts to take a dynamically-supplied argument in the normal manner, but as the casting table (see <specref ref="casting-from-primitive-to-primitive"/>) indicates, the only
      arguments that are supported in this case are values of type <code>xs:QName</code> or <code>xs:NOTATION</code> respectively.</p></item></olist></div2><div2 id="constructor-functions-for-user-defined-types"><head>Constructor functions for user-defined types</head><p> For every atomic type in the static context (See <xspecref spec="XP" ref="static_context"/>) that is derived from a primitive type, there is a
                    constructor function (whose name is the same as the name of the type) whose
                    effect is to create a value of that type from the supplied argument. The rules
                    for constructing user-defined types are defined in the same way as the rules for
                    constructing built-in derived types discussed in <specref ref="constructor-functions-for-xsd-types"/>. </p><p>
                            Special rules apply to constructor functions for types derived from <code>xs:QName</code> and <code>xs:NOTATION</code>. See <specref ref="constructor-qname-notation"/>.</p><p>Consider a situation where the static context contains a type
                    called <code>hatSize</code> defined in a schema whose target namespace is bound
                    to the prefix <code>my</code>. In such a case the constructor function:</p><example role="signature"><proto name="my:hatSize" return-type="my:hatSize" isSpecial="yes" returnEmptyOk="yes" role="example" returnSeq="no" prefix="fn" returnVaries="no" isSchema="no" isDatatype="no" isOp="no"><arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/></proto></example><p>is available to users.</p><p> To construct an instance of an atomic type that is not in a namespace, it is
                    necessary to use a cast expression or undeclare the default function namespace. For example, if the user-defined type <code>apple</code> is derived
                    from <code>xs:integer</code> but is not in a namespace, an instance of this type
                    can be constructed as follows using a cast expression (this requires that the
                    default element/type namespace is no namespace):</p><eg xml:space="preserve">17 cast as apple</eg><p> The following shows the use of the constructor function:</p><eg xml:space="preserve">declare default function namespace ""; apple(17)</eg></div2></div1><div1 id="casting"><head>Casting</head><p> Constructor functions and cast expressions accept an expression and return a value
                of a given type. They both convert a source value, <emph>SV</emph>, of a source type,
                <emph>ST</emph>, to a target value, <emph>TV</emph>, of the given target type,
                <emph>TT</emph>, with identical semantics and different syntax. The name of the
                constructor function is the same as the name of the built-in <bibref ref="xmlschema-2"/> 
                datatype or the datatype defined in <xspecref spec="DM" ref="types"/>
                   of <bibref ref="xpath-datamodel-11"/> (see <specref ref="constructor-functions-for-xsd-types"/>) or the user-derived datatype
                (see <specref ref="constructor-functions-for-user-defined-types"/>) that is the
                target for the conversion, and the semantics are exactly the same as for a cast
                expression; for example,<quote>
                    <code>xs:date("2003-01-01")</code>
                </quote> means exactly the same as <quote>
                    <code>"2003-01-01"</code> cast as 
<code>xs:date?</code>
                </quote>.</p><p>The cast expression takes a type name to indicate the target type of the conversion.
                See <xspecref spec="XP" ref="id-cast"/>. If the type name allows the empty sequence
                and the expression to be cast is the empty sequence, the empty sequence is returned.
                If the type name does not allow the empty sequence and the expression to be cast is
                the empty sequence, a type error is raised <xerrorref spec="XP" class="TY" code="0004" type="type"/>.</p><p>Where the argument to a cast is a literal, the result of the function <rfc2119>may</rfc2119> be
                evaluated statically; if an error is encountered during such evaluation, it <rfc2119>may</rfc2119> be
                reported as a static error. </p><p>Casting from primitive type to primitive type is discussed in
<specref ref="casting-from-primitive-to-primitive"/>.  Casting to derived types is discussed in <specref ref="casting-to-derived-types"/>.  Casting from derived types is discussed in <specref ref="casting-from-derived-to-parent"/>, <specref ref="casting-within-branch"/> and <specref ref="casting-across-hierarchy"/>.</p><p>When casting from <code>xs:string</code> the semantics in <specref ref="casting-from-strings"/> apply, regardless of target type.</p><div2 id="casting-from-primitive-to-primitive"><head>Casting from primitive types to primitive types</head><p>This section defines casting between the 19 primitive types defined in <bibref ref="xmlschema-2"/> as well as <code>xs:untypedAtomic</code>,
                    <code>xs:integer</code> and the two derived types of
                    <code>xs:duration</code> (<code>xs:yearMonthDuration</code>
                    and <code>xs:dayTimeDuration</code>). These four types are not primitive types
                    but they are treated as primitive types in this section. The type conversions
                    that are supported are indicated in the table below. In this table, there is a
                    row for each primitive type with that type as the source of the conversion and
                    there is a column for each primitive type as the target of the conversion. The
                    intersections of rows and columns contain one of three characters:
                    <quote>Y</quote> indicates that a conversion from values of the type to which
                    the row applies to the type to which the column applies is supported;
                    <quote>N</quote> indicates that there are no supported conversions from values
                    of the type to which the row applies to the type to which the column applies;
                    and <quote>M</quote> indicates that a conversion from values of the type to
                    which the row applies to the type to which the column applies may succeed for
                    some values in the value space and fails for others.</p><p>
               <bibref ref="xmlschema-2"/> defines <code>xs:NOTATION</code> as an abstract type. Thus, casting to <code>xs:NOTATION</code> from any other type including <code>xs:NOTATION</code> is not permitted and raises <xerrorref spec="XP" class="ST" code="0080" type="type"/>.  However, casting from one subtype of <code>xs:NOTATION</code> to another subtype of <code>xs:NOTATION</code> is permitted.</p><p>
Casting is not supported to or from <code>xs:anySimpleType</code>. Thus, there is no row or column for this type in the table below. For any node that has not been validated or has been validated as <code>xs:anySimpleType</code>, the typed value of the node is an atomic value of type <code>xs:untypedAtomic</code>. There are no atomic values with the type annotation <code>xs:anySimpleType</code> at runtime. Casting to a type that is not atomic raises <xerrorref spec="XP" class="ST" code="0051" type="type"/>.</p><p>
Similarly, casting is not supported to or from <code>xs:anyAtomicType</code> and will raise error <xerrorref spec="XP" class="ST" code="0080" type="type"/>. There are no atomic values with the type annotation <code>xs:anyAtomicType</code> at runtime, although this can be a statically inferred type.
</p><!--      <p>
                    <bibref ref="xmlschema-2"/> defines <code>xs:NOTATION</code> as an abstract type.
                    Thus, casting to <code>xs:NOTATION</code> from any other type including <code>xs:NOTATION</code> is not permitted.  However, casting from one subtype of <code>xs:NOTATION</code> to another subtype of <code>xs:NOTATION</code> is permitted.
</p>
                <p>Casting is not supported to or from <code>xs:anySimpleType</code>. Thus, there is
                    no row or column for this type in the table below. For any node that has not
                    been validated or has been validated as <code>xs:anySimpleType</code>, the typed
                    value of the node is an atomic value of type <code>xs:untypedAtomic</code>.
                    There are no atomic values with the type annotation <code>xs:anySimpleType</code> at runtime.</p>
<p>Similarly, casting is not supported to or from <code>xs:anyAtomicType</code>.  There are no atomic values with the type annotation <code>xs:anyAtomicType</code> at runtime, although this can be a statically inferred type.</p>
<p>An attempt to cast to any of the above three type raises a static error
<xerrorref spec="XP" class="ST" code="0080" type="type"/></p> --><p>If casting is attempted from an <emph>ST</emph> to a <emph>TT</emph> for which
                    casting is not supported, as defined in the table below, a type error is raised <xerrorref spec="XP" class="TY" code="0004" type="type"/>.</p><p>In the following table, the columns and rows are identified by short codes that
                    identify simple types as follows:</p><slist><sitem>uA = xs:untypedAtomic</sitem><sitem>aURI = xs:anyURI</sitem><sitem>b64 = xs:base64Binary</sitem><sitem>bool = xs:boolean</sitem><sitem>dat = xs:date</sitem><sitem>gDay = xs:gDay</sitem><sitem>dbl = xs:double</sitem><sitem>dec = xs:decimal</sitem><sitem>dT = xs:dateTime</sitem><sitem>dTD = xs:dayTimeDuration</sitem><sitem>dur = xs:duration</sitem><sitem>flt = xs:float</sitem><sitem>hxB = xs:hexBinary</sitem><sitem>gMD = xs:gMonthDay</sitem><sitem>gMon = xs:gMonth</sitem><sitem>int = xs:integer</sitem><sitem>NOT = xs:NOTATION</sitem><sitem>QN = xs:QName</sitem><sitem>str = xs:string</sitem><sitem>tim = xs:time</sitem><sitem>gYM = xs:gYearMonth</sitem><sitem>yMD = xs:yearMonthDuration</sitem><sitem>gYr = xs:gYear</sitem></slist><p>In the following table, the notation <quote>S\T</quote> indicates that the source
                    (<quote>S</quote>) of the conversion is indicated in the column below the
                    notation and that the target (<quote>T</quote>) is indicated in the row to the
                    right of the notation.</p><!-- The markup in the following table is perhaps a bit surprising, but it serves an important purpose: 
               to allow the resulting HTML to display "tool tips" and cell colors that make it much easier to 
               interpret the contents of the table.  The "special" aspects of the markup include: setting the 
               column widths so that all columns are the same width and marking up the first column in each 
               row as "th" instead of "td".  Editors should be careful not to change these conventions without 
               changing the associated stylesheets. --><table border="1" cellpadding="1" role="casting" summary="Casting table" id="casting-to-primitives-table"><col width="5%" span="1"/><col width="3%" span="1"/><col width="3%" span="1"/><col width="3%" span="1"/><col width="3%" span="1"/><col width="3%" span="1"/><col width="3%" span="1"/><col width="3%" span="1"/><col width="3%" span="1"/><col width="3%" span="1"/><col width="3%" span="1"/><col width="3%" span="1"/><col width="3%" span="1"/><col width="3%" span="1"/><col width="3%" span="1"/><col width="3%" span="1"/><col width="3%" span="1"/><col width="3%" span="1"/><col width="3%" span="1"/><col width="3%" span="1"/><col width="3%" span="1"/><col width="3%" span="1"/><col width="3%" span="1"/><col width="3%" span="1"/><thead><tr><th rowspan="1" colspan="1">S\T</th><th rowspan="1" colspan="1">uA</th><th rowspan="1" colspan="1">str</th><th rowspan="1" colspan="1">flt</th><th rowspan="1" colspan="1">dbl</th><th rowspan="1" colspan="1">dec</th><th rowspan="1" colspan="1">int</th><th rowspan="1" colspan="1">dur</th><th rowspan="1" colspan="1">yMD</th><th rowspan="1" colspan="1">dTD</th><th rowspan="1" colspan="1">dT</th><th rowspan="1" colspan="1">tim</th><th rowspan="1" colspan="1">dat</th><th rowspan="1" colspan="1">gYM</th><th rowspan="1" colspan="1">gYr</th><th rowspan="1" colspan="1">gMD</th><th rowspan="1" colspan="1">gDay</th><th rowspan="1" colspan="1">gMon</th><th rowspan="1" colspan="1">bool</th><th rowspan="1" colspan="1">b64</th><th rowspan="1" colspan="1">hxB</th><th rowspan="1" colspan="1">aURI</th><th rowspan="1" colspan="1">QN</th><th rowspan="1" colspan="1">NOT</th></tr></thead><tbody><tr><th rowspan="1" colspan="1">uA</th><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">M</td><td rowspan="1" colspan="1">M</td><td rowspan="1" colspan="1">M</td><td rowspan="1" colspan="1">M</td><td rowspan="1" colspan="1">M</td><td rowspan="1" colspan="1">M</td><td rowspan="1" colspan="1">M</td><td rowspan="1" colspan="1">M</td><td rowspan="1" colspan="1">M</td><td rowspan="1" colspan="1">M</td><td rowspan="1" colspan="1">M</td><td rowspan="1" colspan="1">M</td><td rowspan="1" colspan="1">M</td><td rowspan="1" colspan="1">M</td><td rowspan="1" colspan="1">M</td><td rowspan="1" colspan="1">M</td><td rowspan="1" colspan="1">M</td><td rowspan="1" colspan="1">M</td><td rowspan="1" colspan="1">M</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td></tr><tr><th rowspan="1" colspan="1">str</th><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">M</td><td rowspan="1" colspan="1">M</td><td rowspan="1" colspan="1">M</td><td rowspan="1" colspan="1">M</td><td rowspan="1" colspan="1">M</td><td rowspan="1" colspan="1">M</td><td rowspan="1" colspan="1">M</td><td rowspan="1" colspan="1">M</td><td rowspan="1" colspan="1">M</td><td rowspan="1" colspan="1">M</td><td rowspan="1" colspan="1">M</td><td rowspan="1" colspan="1">M</td><td rowspan="1" colspan="1">M</td><td rowspan="1" colspan="1">M</td><td rowspan="1" colspan="1">M</td><td rowspan="1" colspan="1">M</td><td rowspan="1" colspan="1">M</td><td rowspan="1" colspan="1">M</td><td rowspan="1" colspan="1">M</td><td rowspan="1" colspan="1">M</td><td rowspan="1" colspan="1">M</td></tr><tr><th rowspan="1" colspan="1">flt</th><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">M</td><td rowspan="1" colspan="1">M</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td></tr><tr><th rowspan="1" colspan="1">dbl</th><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">M</td><td rowspan="1" colspan="1">M</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td></tr><tr><th rowspan="1" colspan="1">dec</th><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td></tr><tr><th rowspan="1" colspan="1">int</th><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td></tr><tr><th rowspan="1" colspan="1">dur</th><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td></tr><tr><th rowspan="1" colspan="1">yMD</th><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td></tr><tr><th rowspan="1" colspan="1">dTD</th><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td></tr><tr><th rowspan="1" colspan="1">dT</th><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td></tr><tr><th rowspan="1" colspan="1">tim</th><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td></tr><tr><th rowspan="1" colspan="1">dat</th><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td></tr><tr><th rowspan="1" colspan="1">gYM</th><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td></tr><tr><th rowspan="1" colspan="1">gYr</th><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td></tr><tr><th rowspan="1" colspan="1">gMD</th><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td></tr><tr><th rowspan="1" colspan="1">gDay</th><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td></tr><tr><th rowspan="1" colspan="1">gMon</th><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td></tr><tr><th rowspan="1" colspan="1">bool</th><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td></tr><tr><th rowspan="1" colspan="1">b64</th><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td></tr><tr><th rowspan="1" colspan="1">hxB</th><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td></tr><tr><th rowspan="1" colspan="1">aURI</th><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td></tr><tr><th rowspan="1" colspan="1">QN</th><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">M</td></tr><tr><th rowspan="1" colspan="1">NOT</th><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">M</td></tr></tbody></table><p>The following sub-sections define the semantics of casting from a primitive type
                    to a primitive type. Semantics of casting to and from a derived type are defined
                    in sections <specref ref="casting-to-derived-types"/>, <specref ref="casting-from-derived-to-parent"/>, <specref ref="casting-within-branch"/>
                        and <specref ref="casting-across-hierarchy"/>.</p><div3 id="casting-from-strings"><head>Casting from xs:string and xs:untypedAtomic</head><p>When the supplied value is an instance of <code>xs:string</code> or an
                        instance of <code>xs:untypedAtomic</code>, it is treated as being a string
                        value and mapped to a typed value of the target type as defined in <bibref ref="xmlschema-2"/>. Whitespace normalization is applied as indicated by the
                        whiteSpace facet for the datatype. The resulting whitespace-normalized string must be a valid lexical form for the datatype.  The semantics of casting are identical to
                        XML Schema validation.  For example, <code>"13" cast as xs:unsignedInt</code> returns the <code>xs:unsignedInt</code> typed 
value <code>13</code>. This could also be written <code>xs:unsignedInt("13")</code>.</p><p>When casting from <code>xs:string</code> or <code>xs:untypedAtomic</code> to a derived type where the derived type is restricted by a pattern facet, the
lexical form is first checked against the pattern before further casting is attempted (See <specref ref="casting-to-derived-types"/>).  If the lexical form does not conform to the pattern, error <errorref class="RG" code="0001" type="dynamic"/> is raised. 
</p><p>Consider a user-defined Schema whose target namespace is bound to the prefix <code>mySchema</code> which defines a restriction of <code>xs:boolean</code> called <code>trueBool</code> which allows only the lexical forms <quote>
                     <code>1</code>
                  </quote> and <quote>
                     <code>0</code>
                  </quote>.  <code>"true" cast as mySchema:trueBool</code> would fail with <errorref class="RG" code="0001" type="dynamic"/>.  If the Schema also defines a datatype called <code>height</code> as a restriction of <code>xs:integer</code> with a maximum value of <code>84</code> then <code>"100" cast as mySchema:height</code> would also fail with <errorref class="RG" code="0001" type="dynamic"/>.</p><p>Casting is permitted from <code>xs:string</code> and
                        <code>xs:untypedAtomic</code> to any primitive atomic type or any atomic
                        type derived by restriction, except <phrase diff="del" at="F"><code>xs:QName</code> or</phrase> <code>xs:NOTATION</code>. 
                  Casting to <code>xs:NOTATION</code> is not permitted because it is an abstract type.
</p><p diff="chg" at="B">Casting is permitted from <code>xs:string</code> literals to
                  <code>xs:QName</code> and types derived from <code>xs:NOTATION</code>. 
	 <phrase diff="del" at="F">If the argument to such a cast is
computed dynamically, <xerrorref spec="XP" class="TY" code="0004" type="type"/>  is raised if the value is of any type other
than <code>xs:QName</code> or <code>xs:NOTATION</code> (including the case where it is an
<code>xs:string</code>).</phrase> The process is described in more detail in
<specref ref="constructor-qname-notation"/>.
                  <note diff="add" at="F"><p>This version of the specification allows casting between <code>xs:QName</code>
                  and <code>xs:NOTATION</code> in either direction; this was not permitted in the previous Recommendation. This version also removes
                  the rule that only a string literal (rather than a dynamic string) may be cast to an <code>xs:QName</code></p></note>
               </p><!--End of text replaced by erratum E11--><p>When casting to a numeric type:</p><ulist><item><p>If the value is too large or too small to be accurately represented by the implementation, 
                     it is handled as an overflow or underflow as defined in <specref ref="op.numeric"/>.</p></item><item><p diff="add" at="F">If the target type is <code>xs:float</code> or <code>xs:double</code>, the string <code>-0</code> (and equivalents
                     such as <code>-0.0</code> or <code>-000</code>) <rfc2119>should</rfc2119> be converted to the value negative zero.
                     However, if the implementation is reliant on an implementation of XML Schema 1.0 in which negative zero
                     is not part of the value space for these types, these lexical forms <rfc2119>may</rfc2119> be converted to positive zero.</p></item></ulist><p>
In casting to <code>xs:decimal</code> or to a type derived from <code>xs:decimal</code>, if the value is not too large or too small but nevertheless cannot be represented accurately with the number of decimal digits available to the implementation, the implementation may round to the nearest representable value or may raise a dynamic error <errorref class="CA" code="0006" type="dynamic"/>. The choice of rounding algorithm and the choice between rounding and error behavior and is implementation-defined.
</p><p diff="chg" at="A-E28">In casting to <code>xs:date</code>, <code>xs:dateTime</code>, <code>xs:gYear</code>, or <code>xs:gYearMonth</code> 
		(or types derived from these), if the value is too large or too 
		small to be represented by the implementation, error 
		<errorref class="DT" code="0001" type="dynamic"/> is raised.</p><p>In casting to a duration value, if the value is too large or too small to be represented by the implementation, error <errorref class="DT" code="0002" type="dynamic"/> is raised.</p><p> For <code>xs:anyURI</code>, the extent to which an implementation validates the
                                lexical form of <code>xs:anyURI</code> is <termref def="implementation-dependent"/>.</p><p>If the cast fails for any other reason, error <errorref class="RG" code="0001" type="dynamic"/> is raised.</p></div3><div3 id="casting-to-string"><head>Casting to xs:string and xs:untypedAtomic</head><p>Casting is permitted from any primitive type to the primitive types
                        <code>xs:string</code> and <code>xs:untypedAtomic</code>.</p><p>When a value of any simple type is cast as <code>xs:string</code>, the
                        derivation of the <code>xs:string</code> value <emph>TV</emph> depends on
                        the <emph>ST</emph> and on the <emph>SV</emph>, as follows.</p><ulist><item><p>If <emph>ST</emph> is <code>xs:string</code> or a type derived from
                                <code>xs:string</code>, <emph>TV</emph> is <emph>SV</emph>.</p></item><item><p>If <emph>ST</emph> is <code>xs:anyURI</code>, the type conversion is
                                performed without escaping any characters.</p></item><item><p>If <emph>ST</emph> is <code>xs:QName</code> or <code>xs:NOTATION</code>:</p><ulist><item><p diff="chg" at="A-E10">if the qualified name
          has a prefix, then <emph>TV</emph> is the concatenation of the prefix of <emph>SV</emph>, 
		  a single colon (:), and the local name of <emph>SV</emph>.</p></item><item><p>otherwise <emph>TV</emph> is the local-name.</p></item></ulist></item><item><p>If <emph>ST</emph> is a numeric type, the following rules apply:</p><ulist><item><p>If <emph>ST</emph> is <code>xs:integer</code>,
                                        <emph>TV</emph> is the canonical lexical representation of
                                        <emph>SV</emph> as defined in <bibref ref="xmlschema-2"/>. There
                                        is no decimal point.</p></item><item><p>If <emph>ST</emph> is <code>xs:decimal</code>, then:</p><ulist><item><p>If <emph>SV</emph> is in the value space of
                                                <code>xs:integer</code>, that is, if there are no
                                                significant digits after the decimal point, then the
                                                value is converted from an <code>xs:decimal</code>
                                                to an <code>xs:integer</code> and the resulting
                                                <code>xs:integer</code> is converted to an
                                                <code>xs:string</code> using the rule above.</p></item><item><p> Otherwise, the canonical lexical representation of
                                                <emph>SV</emph> is returned, as defined in <bibref ref="xmlschema-2"/>.</p></item></ulist></item><item><p> If <emph>ST</emph> is <code>xs:float</code> or
                                        <code>xs:double</code>, then:</p><ulist><item><p>
                                    <emph>TV</emph> will be an <code>xs:string</code> in the lexical space of <code>xs:double</code> or <code>xs:float</code> that when
converted to an <code>xs:double</code> or <code>xs:float</code> under the rules of <specref ref="casting-from-strings"/> produces
a value that is equal to <emph>SV</emph>, or is <quote>NaN</quote> if <emph>SV</emph> is <code>NaN</code>.
In addition, <emph>TV</emph> must satisfy the constraints in the
following sub-bullets.
											</p><ulist><item><p>If <emph>SV</emph> has an absolute value that is
                                                greater than or equal to 0.000001 (one millionth)
                                                and less than 1000000 (one million), then the value
                                                is converted to an <code>xs:decimal</code> and the
                                                resulting <code>xs:decimal</code> is converted to an
                                                <code>xs:string</code> according to the rules above, as though using an 
implementation of <code>xs:decimal</code> that imposes no limits on the
<code>totalDigits</code> or
<code>fractionDigits</code> facets.</p></item><item><p>If <emph>SV</emph> has the value positive or negative zero, <emph>TV</emph> is "0" or "-0"
respectively.
</p></item><item><p>If <emph>SV</emph> is positive or negative infinity, <emph>TV</emph> is the string "<code>INF</code>" or "<code>-INF</code>" respectively.
</p></item><item><p>In other cases, the result consists of a mantissa, which has the lexical form
of an <code>xs:decimal</code>, followed by the letter "E", followed by an exponent which has
the lexical form of an <code>xs:integer</code>. Leading zeroes and "+" signs are prohibited
in the exponent. For the mantissa, there must be a decimal point, and there must
be exactly one digit before the decimal point, which must be non-zero. The  "+"
sign is prohibited. There must be at least one digit after the decimal point.
Apart from this mandatory digit, trailing zero digits are prohibited. 
</p></item></ulist></item></ulist><note><p>The above rules allow more than one representation of the same value. 
                                 For example, the <code>xs:float</code> value whose exact decimal representation is 1.26743223E15
might be represented by any of the strings "1.26743223E15", "1.26743222E15" or
"1.26743224E15" (inter alia). It is implementation-dependent which of these
representations is chosen.
</p></note></item></ulist></item><item><p>If <emph>ST</emph> is <code>xs:dateTime</code>, <code>xs:date</code>
                                or <code>xs:time</code>, <emph>TV</emph> is the local value. 
The components of <emph>TV</emph> are individually cast to <code>xs:string</code> using the functions 
                        described in <bibref ref="casting-to-datetimes"/> 
                        and the results are concatenated together.  The <code>year</code> component is 
                        cast to <code>xs:string</code> using <code>eg:convertYearToString</code>.  
                        The <code>month</code>, <code>day</code>, <code>hour</code> and <code>minute</code> 
                        components are cast to <code>xs:string</code> using <code>eg:convertTo2CharString</code>.  
                        The <code>second</code> component is cast to <code>xs:string</code> using 
                        <code>eg:convertSecondsToString</code>. The timezone component, if present, is 
                        cast to <code>xs:string</code> using <code>eg:convertTZtoString</code>.  
</p><p> 
Note that the hours component of the resulting string
will never be <code>"24"</code>. Midnight is always represented as <code>"00:00:00"</code>.
</p></item><item><p>If <emph>ST</emph> is <code>xs:yearMonthDuration</code> or <code>xs:dayTimeDuration</code>, <emph>TV</emph> is the 
                                canonical representation of <emph>SV</emph> as defined in <specref ref="dt-yearMonthDuration"/> or <specref ref="dt-dayTimeDuration"/>, respectively.</p></item><item><p>If <emph>ST</emph> is <code>xs:duration</code>
 then let <emph>SYM</emph> be <emph>
                           <code>SV</code>
                        </emph> 
                        <code>cast as xs:yearMonthDuration</code>, and let <emph>SDT</emph> be <emph>
                           <code>SV</code>
                        </emph> 
                        <code>cast as xs:dayTimeDuration</code>;  Now, let the next intermediate value, <emph>TYM</emph>, 
be <emph>
                           <code>SYM</code>
                        </emph> 
                        <code>cast as</code> 
                        <emph>
                           <code>TT</code>
                        </emph>, and let <emph>TDT</emph> be <emph>
                           <code>SDT</code>
                        </emph> 
                        <code>cast as</code> 
                        <emph>
                           <code>TT</code>
                        </emph>.  If <emph>TYM</emph> is "P0M", then <emph>TV</emph> is 
<emph>TDT</emph>.  Otherwise, <emph>TYM</emph> and <emph>TDT</emph> are merged according to the following rules:</p><olist><item><p>If <emph>TDT</emph> is "PT0S", then <emph>TV</emph> is <emph>TYM</emph>.</p></item><item><p>Otherwise, <emph>TV</emph> is the concatenation of all the characters in <emph>TYM</emph> and all the
characters except the first "P" and the optional negative sign in <emph>TDT</emph>.</p></item></olist></item><item><p>In all other cases, <emph>TV</emph> is the <bibref ref="xmlschema-2"/>
                                canonical representation of <emph>SV</emph>. For datatypes that do
                                not have a canonical lexical representation defined an <termref def="implementation-dependent"/> canonical representation may be used.</p></item><!--							<item>
								<p>If <emph>ST</emph> is <code>string</code>, </<emph>TV</emph> is <emph>SV</emph>.</p>
							</item>
							<item>
								<p>If <emph>ST</emph> is <code>float</code>, <code>double</code>, or <code>decimal</code> then <emph>TV</emph> is the canonical representation of <emph>SV</emph>, as defined by <bibref ref="xmlschema-2"/>.</p>
							</item>
							<item>
								<p>If <emph>ST</emph> is <code>duration</code> then <emph>TV</emph> is the lexical representation of <emph>SV</emph>, as defined in <bibref ref="xmlschema-2"/> in which each integer and decimal component is expressed in its canonical representation.</p>
							</item>
<item>
								<p>If <emph>ST</emph> is <code>yearMonthDuration</code> or <code>dayTimeDuration</code> then <emph>TV</emph> is the canonical representation of <emph>SV</emph>, in which each integer and decimal component is expressed in its canonical representation.</p>
							</item>
							<item>
								<p>If <emph>ST</emph> is <code>dateTime</code> or <code>time</code>, then <emph>TV</emph> is the canonical representation of <emph>SV</emph>, as defined by <bibref ref="xmlschema-2"/>.</p>
							</item>
							<item>
								<p>If <emph>ST</emph> is <code>date</code>, <code>gYearMonth</code>, <code>gYear</code>, <code>gMonthDay</code>, <code>gDay</code>, or <code>gMonth</code>, then <emph>TV</emph> is the lexical representation of <emph>SV</emph>, as defined by <bibref ref="xmlschema-2"/>.</p>
							</item>
							<item>
								<p>If <emph>ST</emph> is <code>boolean</code>, then <emph>TV</emph> is <quote>true</quote> if <emph>SV</emph> is true and <quote>false</quote> if <emph>SV</emph> is false.</p>
							</item>
							<item>
								<p>If <emph>ST</emph> is <code>hexBinary</code>, then <emph>TV</emph> is the canonical representation of <emph>SV</emph>, as defined by <bibref ref="xmlschema-2"/>.</p>
							</item>
							<item>
								<p>If <emph>ST</emph> is <code>anyURI</code>, then <emph>TV</emph> is the lexical representation of <emph>SV</emph>, as defined in <bibref ref="xmlschema-2"/>, with each space replaced by the sequence <quote>%20</quote>.</p>
							</item>
							<item>
								<p>If <emph>ST</emph> is <code>NOTATION</code>, then <emph>TV</emph> is <emph>SV</emph>.</p>
							</item>  --></ulist><p>To cast as <code>xs:untypedAtomic</code> the value is cast as
                        <code>xs:string</code>, as described above, and the type annotation changed
                        to <code>xs:untypedAtomic</code>.</p><note><p>The string representations of numeric values are backwards compatible
                            with XPath 1.0 except for the special values positive and negative
                            infinity, negative zero and values outside the range <code>1.0e-6</code> to <code>1.0e+6</code>.</p></note></div3><div3 id="casting-to-numerics"><head>Casting to numeric types</head><div4 id="casting-to-float"><head>Casting to xs:float</head><p>When a value of any simple type is cast as <code>xs:float</code>, the <code>xs:float</code>
                            <emph>TV</emph> is derived from the <emph>ST</emph> and the
                            <emph>SV</emph> as follows:</p><ulist><item><p>If <emph>ST</emph> is <code>xs:float</code>, then <emph>TV</emph>
                                    is <emph>SV</emph> and the conversion is complete.</p></item><item><p>If <emph>ST</emph> is <code>xs:double</code>, then
                                    <emph>TV</emph> is obtained as follows: </p><ulist><item><p>if <emph>SV</emph> is the <code>xs:double</code> value
                                            <code>INF</code>, <code>-INF</code>, <code>NaN</code>,
                                            positive zero, or negative zero, then <emph>TV</emph> is
                                            the <code>xs:float</code> value <code>INF</code>,
                                            <code>-INF</code>, <code>NaN</code>, positive zero, or
                                            negative zero respectively.</p></item><item><p>otherwise, <emph>SV</emph> can be expressed in the form
                                                <code>m × 2^e</code> where the mantissa
                                            <code>m</code> and exponent <code>e</code> are signed
                                            <code>xs:integer</code>s whose value range is defined in
                                                <bibref ref="xmlschema-2"/>, and the following rules apply:</p><ulist><item><p>if <code>m</code> (the mantissa of
                                                  <emph>SV</emph>) is outside the permitted range
                                                  for the mantissa of an <code>xs:float</code>
                                                  value <code>(-2^24-1 to +2^24-1)</code>, then it
                                                  is divided by <code>2^N</code> where
                                                  <code>N</code> is the lowest positive
                                                  <code>xs:integer</code> that brings the result
                                                  of the division within the permitted range, and
                                                  the exponent <code>e</code> is increased by
                                                  <code>N</code>. This is integer division (in
                                                  effect, the binary value of the mantissa is
                                                  truncated on the right). Let <code>M</code> be
                                                  the mantissa and <code>E</code> the exponent
                                                  after this adjustment.</p></item><item><p>if <code>E</code> exceeds <code>104</code> (the
                                                  maximum exponent value in the value space of
                                                  <code>xs:float</code>) then <emph>TV</emph> is
                                                  the <code>xs:float</code> value <code>INF</code>
                                                  or <code>-INF</code> depending on the sign of <code>M</code>.</p></item><item><p>if <code>E</code> is less than <code>-149</code>
                                                  (the minimum exponent value in the value space
                                                  of <code>xs:float</code>) then <emph>TV</emph> is
                                                  the <code>xs:float</code> value positive or
                                                  negative zero depending on the sign of <code>M</code>
                                                </p></item><item><p>otherwise, <emph>TV</emph> is the
                                                  <code>xs:float</code> value <code>M × 2^E</code>.</p></item></ulist></item></ulist></item><item><p>If <emph>ST</emph> is <code>xs:decimal</code>, or
                                    <code>xs:integer</code>, then <emph>TV</emph> is <code>xs:float(</code>
                                    <emph>SV</emph>
                                    <code> cast as xs:string)</code> and the conversion is complete.</p></item><item><p>If <emph>ST</emph> is <code>xs:boolean</code>, <emph>SV</emph> is
                                    converted to <code>1.0E0</code> if <emph>SV</emph> is
                                    <code>true</code> and to <code>0.0E0</code> if <emph>SV</emph>
                                    is <code>false</code> and the conversion is complete.</p></item><item><p> If <emph>ST</emph> is <code>xs:untypedAtomic</code>
                                    or <code>xs:string</code>, see 
                                    <specref ref="casting-from-strings"/>. 
</p></item></ulist><note><p diff="chg" at="F">Implementations <rfc2119>should</rfc2119> return negative zero for <code>xs:float("-0.0E0")</code>.  
                        But because <bibref ref="xmlschema-2"/> does not distinguish between the values positive zero and negative zero.
                        implementations <termref def="may"/> return positive zero in this case.</p></note></div4><div4 id="casting-to-double"><head>Casting to xs:double</head><p>When a value of any simple type is cast as <code>xs:double</code>, the
                            <code>xs:double</code> value <emph>TV</emph> is derived from the
                            <emph>ST</emph> and the <emph>SV</emph> as follows:</p><ulist><item><p>If <emph>ST</emph> is <code>xs:double</code>, then
                                    <emph>TV</emph> is <emph>SV</emph> and the conversion is complete.</p></item><item><p>If <emph>ST</emph> is <code>xs:float</code> or a type derived
                                    from <code>xs:float</code>, then <emph>TV</emph> is obtained as follows:</p><ulist><item><p>if <emph>SV</emph> is the <code>xs:float</code> value
                                            <code>INF</code>, <code>-INF</code>, <code>NaN</code>,
                                            positive zero, or negative zero, then <emph>TV</emph> is
                                            the <code>xs:double</code> value <code>INF</code>,
                                            <code>-INF</code>, <code>NaN</code>, positive zero, or
                                            negative zero respectively. </p></item><item><p>otherwise, <emph>SV</emph> can be expressed in the form
                                                <code>m × 2^e</code> where the
                                            mantissa <code>m</code> and exponent <code>e</code> are
                                            signed <code>xs:integer</code> values whose value range
                                            is defined in <bibref ref="xmlschema-2"/>, and
                                            <emph>TV</emph> is the <code>xs:double</code> value
                                                <code>m × 2^e</code>. </p></item></ulist></item><item><p>If <emph>ST</emph> is <code>xs:decimal</code> or
                                    <code>xs:integer</code>, then <emph>TV</emph> is <code>xs:double(</code>
                                    <emph>SV</emph>
                                    <code> cast as xs:string)</code> and the conversion is complete.</p></item><item><p>If <emph>ST</emph> is <code>xs:boolean</code>, <emph>SV</emph> is
                                    converted to <code>1.0E0</code> if <emph>SV</emph> is
                                    <code>true</code> and to <code>0.0E0</code> if <emph>SV</emph>
                                    is <code>false</code> and the conversion is complete.</p></item><item><p> If <emph>ST</emph> is <code>xs:untypedAtomic</code>
                                    or <code>xs:string</code>, see 
                                    <specref ref="casting-from-strings"/>.</p></item></ulist><note><p diff="chg" at="F">Implementations <rfc2119>should</rfc2119> return negative zero for <code>xs:double("-0.0E0")</code>.  
                        But because <bibref ref="xmlschema-2"/> does not distinguish between the values positive zero and negative zero.
                        implementations <termref def="may"/> return positive zero in this case.</p></note></div4><div4 id="casting-to-decimal"><head>Casting to xs:decimal</head><p>When a value of any simple type is cast as <code>xs:decimal</code>, the
                            <code>xs:decimal</code> value <emph>TV</emph> is derived from
                            <emph>ST</emph> and <emph>SV</emph> as follows: </p><ulist><item><p>If <emph>ST</emph> is <code>xs:decimal</code>,
                                    <code>xs:integer</code> or a type derived from them, then
                                    <emph>TV</emph> is <emph>SV</emph>, converted to an
                                    <code>xs:decimal</code> value if need be, and the conversion is complete.</p></item><item><p>If <emph>ST</emph> is <code>xs:float</code> or
                                    <code>xs:double</code>, then <emph>TV</emph> is the
                                    <code>xs:decimal</code> value, within the set of
                                    <code>xs:decimal</code> values that the implementation is
                                    capable of representing, that is numerically closest to
                                    <emph>SV</emph>. If two values are equally close, then the one
                                    that is closest to zero is chosen. If <emph>SV</emph> is too
                                    large to be accommodated as an <code>xs:decimal</code>, (see
                                        <bibref ref="xmlschema-2"/> for <termref def="implementation-defined"/> limits on
                                    numeric values) an error is raised <errorref class="CA" code="0001"/>. If <emph>SV</emph> is one of the special
                                    <code>xs:float</code> or <code>xs:double</code> values
                                    <code>NaN</code>, <code>INF</code>, or <code>-INF</code>, an
                                    error is raised <errorref class="CA" code="0002"/>.</p></item><item><p>If <emph>ST</emph> is <code>xs:boolean</code>, <emph>SV</emph> is
                                    converted to <code>1.0</code> if <emph>SV</emph> is
                                    <code>1</code> or <code>true</code> and to <code>0.0</code> if
                                    <emph>SV</emph> is <code>0</code> or <code>false</code> and the
                                    conversion is complete.</p></item><item><p>If <emph>ST</emph> is <code>xs:untypedAtomic</code>
                                    or <code>xs:string</code>, see 
                                    <specref ref="casting-from-strings"/>.</p></item></ulist></div4><div4 id="casting-to-integer"><head>Casting to xs:integer</head><p>When a value of any simple type is cast as <code>xs:integer</code>, the
                            <code>xs:integer</code> value <emph>TV</emph> is derived from
                            <emph>ST</emph> and <emph>SV</emph> as follows:</p><ulist><item><p>If <emph>ST</emph> is <code>xs:integer</code>, or a type derived
                                    from <code>xs:integer</code>, then <emph>TV</emph> is
                                    <emph>SV</emph>, converted to an <code>xs:integer</code> value
                                    if need be, and the conversion is complete.</p></item><item><p>If <emph>ST</emph> is
                                    <code>xs:decimal</code>, <code>xs:float</code> or
                                    <code>xs:double</code>, then <emph>TV</emph> is <emph>SV</emph>
                                    with the fractional part discarded and the value converted to
                                    <code>xs:integer</code>. Thus, casting <code>3.1456</code>
                                    returns <code>3</code> and <code>-17.89</code> returns
                                    <code>-17</code>. Casting <code>3.124E1</code>
                                    returns <code>31</code>. If <emph>SV</emph> is too large to be
                                    accommodated as an integer, (see <bibref ref="xmlschema-2"/> for
                                    <termref def="implementation-defined"/> limits on numeric values) an error is
                                    raised <errorref class="CA" code="0003"/>. If <emph>SV</emph> is
                                    one of the special <code>xs:float</code> or
                                    <code>xs:double</code> values <code>NaN</code>,
                                    <code>INF</code>, or <code>-INF</code>, an error is raised
                                        <errorref class="CA" code="0002"/>.</p></item><item><p>If <emph>ST</emph> is <code>xs:boolean</code>, <emph>SV</emph> is
                                    converted to <code>1</code> if <emph>SV</emph> is <code>1</code>
                                    or <code>true</code> and to <code>0</code> if <emph>SV</emph> is
                                    <code>0</code> or <code>false</code> and the conversion is complete.</p></item><item><p>If <emph>ST</emph> is <code>xs:untypedAtomic</code>
                                    or <code>xs:string</code>, see 
                                    <specref ref="casting-from-strings"/>.</p></item><!--    <item>
                                <p>If <emph>TT</emph> is a subtype of <code>xs:integer</code>, then
                                    <emph>TV</emph> is calculated as described above, and is then
                                    cast to <emph>TT</emph> as described in <specref
                                    ref="casting-within-branch"/>. This involves checking the value
                                    against the facets of <emph>TT</emph>.</p>
                            </item>  --></ulist></div4></div3><div3 id="casting-to-durations"><head>Casting to duration types</head><p>When a value of type <code>xs:untypedAtomic</code>, <code>xs:string</code>,
                        a type derived from <code>xs:string</code>,
                        <code>xs:yearMonthDuration</code> or <code>xs:dayTimeDuration</code> is
                        cast as <code>xs:duration</code>, <code>xs:yearMonthDuration</code> or
                        <code>xs:dayTimeDuration</code>, <emph>TV</emph> is derived from
                        <emph>ST</emph> and <emph>SV</emph> as follows:</p><ulist><item><p>If <emph>ST</emph> is the same as <emph>TT</emph>, then
                                <emph>TV</emph> is <emph>SV</emph>. </p></item><item><p>If <emph>ST</emph> is <code>xs:duration</code>, or a type derived
                                from <code>xs:duration</code>, but not
                                <code>xs:dayTimeDuration</code> or a type derived from
                                <code>xs:dayTimeDuration</code>, and <emph>TT</emph> is
                                <code>xs:yearMonthDuration</code>, then <emph>TV</emph> is derived
                                from <emph>SV</emph> by removing the day, hour, minute and second
                                components from <emph>SV</emph>.</p></item><item><p>If <emph>ST</emph> is <code>xs:duration</code>, or a type derived
                                from <code>duration</code>, but not
                                <code>xs:yearMonthDuration</code> or a type derived from
                                <code>xs:yearMonthDuration</code>, and <emph>TT</emph> is
                                <code>xs:dayTimeDuration</code>, then <emph>TV</emph> is derived
                                from <emph>SV</emph> by removing the year and month components from <emph>SV</emph>.</p></item><item><p>If <emph>ST</emph> is <code>xs:yearMonthDuration</code>
                                or <code>xs:dayTimeDuration</code>, and <emph>TT</emph> is
                                <code>xs:duration</code>, then <emph>TV</emph> is derived from
                                <emph>SV</emph> as discussed in <specref ref="casting-from-derived-to-parent"/>.</p></item><item><p>If <emph>ST</emph> is <code>xs:yearMonthDuration</code>
                                and <emph>TT</emph> is
                                <code>xs:dayTimeDuration</code>, the cast is permitted and returns a <code>xs:dayTimeDuration</code> with value 0.0 seconds.</p></item><item><p>If <emph>ST</emph> is <code>xs:dayTimeDuration</code>
                                and <emph>TT</emph> is
                                <code>xs:yearMonthDuration</code>, the cast is permitted and returns a <code>xs:yearMonthDuration</code> with value 0 months.</p></item><item><p>If <emph>ST</emph> is <code>xs:untypedAtomic</code>
                                or <code>xs:string</code>, see 
                                    <specref ref="casting-from-strings"/>.</p></item></ulist><p>Note that casting from <code>xs:duration</code> to
                        <code>xs:yearMonthDuration</code> or <code>xs:dayTimeDuration</code> loses
                        information. To avoid this, users can cast the <code>xs:duration</code>
                        value to both an <code>xs:yearMonthDuration</code> and an
                        <code>xs:dayTimeDuration</code> and work with both values.</p></div3><div3 id="casting-to-datetimes"><head>Casting to date and time types</head><p>In several situations, casting to date and time types requires the extraction
                        of a component from <emph>SV</emph> or from the result of
                        <code>fn:current-dateTime</code> and converting it to an
                        <code>xs:string</code>. These conversions must follow certain rules. For
                        example, converting an <code>xs:integer</code> year value requires
                        converting to an <code>xs:string</code> with four or more characters, preceded
                        by a minus sign if the value is negative.</p><p>This document defines four functions to perform these conversions. These
                        functions are for illustrative purposes only and make no recommendations as
                        to style or efficiency.  References to these functions from the following text are not normative.</p><p>The arguments to these functions come from functions defined in this
                        document. Thus, the functions below assume that they are correct and do no
                        range checking on them.</p><eg xml:space="preserve">
declare function eg:convertYearToString($year as xs:integer) as xs:string
{
   let $plusMinus := if ($year &gt;= 0) then "" else "-"
   let $yearString := fn:abs($year) cast as xs:string
   let $length := fn:string-length($yearString)
   return
     if ($length = 1)  then fn:concat($plusMinus, "000", $yearString)
     else
     if ($length = 2)  then fn:concat($plusMinus, "00", $yearString)
       else
       if ($length = 3)  then fn:concat($plusMinus, "0", $yearString)
       else fn:concat($plusMinus, $yearString)
}
                    </eg><eg xml:space="preserve">
declare function eg:convertTo2CharString($value as xs:integer) as xs:string
{
   let $string := $value cast as xs:string
   return 
     if (fn:string-length($string) = 1) then fn:concat("0", $string)
     else $string
}
                    </eg><eg xml:space="preserve">
declare function eg:convertSecondsToString($seconds as xs:decimal) as xs:string
{
   let $string := $seconds cast as xs:string
   let $intLength := fn:string-length(($seconds cast as xs:integer) cast as xs:string)
   return 
     if ($intLength = 1) then fn:concat("0", $string)
     else $string
}
                    </eg><!--Text replaced by erratum E6 change 1"--><eg diff="chg" at="A-E6" xml:space="preserve">
declare function eg:convertTZtoString($tz as xs:dayTimeDuration?) as xs:string
{
   if (empty($tz)) 
     then ""
   else if ($tz eq xs:dayTimeDuration('PT0S'))
     then "Z"
   else 
     let $tzh := fn:hours-from-duration($tz)
     let $tzm := fn:minutes-from-duration($tz)
     let $plusMinus := if ($tzh &gt;= 0) then "+" else "-"
     let $tzhString := eg:convertTo2CharString(fn:abs($tzh))
     let $tzmString := eg:convertTo2CharString(fn:abs($tzm))
     return fn:concat($plusMinus, $tzhString, ":", $tzmString)
}

                    </eg><!--End of text replaced by erratum E6--><p>Conversion from primitive types to date and time types follows the rules below.</p><olist><!--    <item>
                            <p>When a value of any primitive type is cast as
                                <code>xs:dateTime</code>, <code>xs:time</code>,
                                <code>xs:date</code>, <code>xs:gYearMonth</code>,
                                <code>xs:gYear</code>, <code>xs:gMonthDay</code>,
                                <code>xs:gDay</code>, or <code>xs:gMonth</code>,</p>
                            <p> let <emph>CYR</emph> be <code>eg:convertYearToString(
                                    fn:year-from-dateTime( fn:current-dateTime() ))</code>,</p>
                            <p> let <emph>CMO</emph> be <code>eg:convertTo2CharString(
                                    fn:month-from-dateTime( fn:current-dateTime() ))</code>, </p>
                            <p> let <emph>CDA</emph> be <code>eg:convertTo2CharString(
                                    fn:day-from-dateTime( fn:current-dateTime() )) </code>.</p>
                            and </p>
<p>
let <emph>CTZ</emph> be <code>eg:convertTZtoString(
	    fn:timezone-from-dateTime( fn:current-dateTime()
	    )</code>. </p> 
                        </item> --><item><p>When a value of any primitive type is cast as
                                <code>xs:dateTime</code>, the <code>xs:dateTime</code> value
                                <emph>TV</emph> is derived from <emph>ST</emph> and <emph>SV</emph>
                                as follows:</p><ulist><item><p>If <emph>ST</emph> is <code>xs:dateTime</code>, then
                                        <emph>TV</emph> is <emph>SV</emph>. </p></item><!--		<item>
								<p>If <emph>ST</emph> is <code>xs:time</code>, then let <emph>SHR</emph> be <code>eg:convertTo2CharString( fn:hours-from-time(</code>
									<emph>SV</emph>	<code>)) </code>, let <emph>SMI</emph> be <code>eg:convertTo2CharString( fn:minutes-from-time(</code>
									<emph>SV</emph><code>))</code>, let <emph>SSE</emph> be <code>eg:convertSecondsToString( fn:seconds-from-time(</code>
									<emph>SV</emph><code>))</code> and let <emph>STZ</emph> be <code>eg:convertTZtoString( fn:timezone-from-time(</code><emph>SV</emph><code>))</code>
; <emph>TV</emph> is <code>xs:dateTime( fn:concat(</code>
									<emph>CYR</emph>
									<code>, '-', </code>
									<emph>CMO</emph>
									<code>, '-', </code>
									<emph>CDA</emph>
									<code>, 'T', </code>
									<emph>SHR</emph>
									<code>, ':', </code>
									<emph>SMI</emph>
									<code>, ':', </code>
									<emph>SSE, STZ</emph> 
									<code>) )</code>. </p>
							</item> --><item><p>If <emph>ST</emph> is <code>xs:date</code>, then let
                                        <emph>SYR</emph> be <code>eg:convertYearToString( fn:year-from-date(</code>
                                        <emph>SV</emph>
                                        <code>))</code>, let <emph>SMO</emph> be
                                            <code>eg:convertTo2CharString( fn:month-from-date(</code>
                                        <emph>SV</emph>
                                        <code>))</code>, let <emph>SDA</emph> be
                                            <code>eg:convertTo2CharString( fn:day-from-date(</code>
                                        <emph>SV</emph>
                                        <code>))</code> and let <emph>STZ</emph> be
                                            <code>eg:convertTZtoString( fn:timezone-from-date(</code>
                                        <emph>SV</emph>
                                        <code>))</code>; <emph>TV</emph> is <code>xs:dateTime( fn:concat(</code>
                                        <emph>SYR</emph>
                                        <code>, '-', </code>
                                        <emph>SMO</emph>
                                        <code>, '-', </code>
                                        <emph>SDA</emph>
                                        <code>, 'T00:00:00 '</code>, <emph>STZ</emph>
                                        <code>) )</code>. </p></item><item><p> If <emph>ST</emph> is <code>xs:untypedAtomic</code> or
                                        <code>xs:string</code>, see 
                                    <specref ref="casting-from-strings"/>.</p></item></ulist></item><item><p>When a value of any primitive type is cast as <code>xs:time</code>,
                                the <code>xs:time</code> value <emph>TV</emph> is derived from
                                <emph>ST</emph> and <emph>SV</emph> as follows:</p><ulist><item><p>If <emph>ST</emph> is <code>xs:time</code>, then
                                        <emph>TV</emph> is <emph>SV</emph>. </p></item><item><p>If <emph>ST</emph> is <code>xs:dateTime</code>, then
                                        <emph>TV</emph> is <code>xs:time( fn:concat(
                                            eg:convertTo2CharString( fn:hours-from-dateTime(</code>
                                        <emph>SV</emph>
                                        <code>)), ':', eg:convertTo2CharString( fn:minutes-from-dateTime(</code>
                                        <emph>SV</emph>
                                        <code>)), ':', eg:convertSecondsToString( fn:seconds-from-dateTime(</code>
                                        <emph>SV</emph>
                                        <code>)), eg:convertTZtoString( fn:timezone-from-dateTime(</code>
                                        <emph>SV</emph>
                                        <code>)) ))</code>. </p></item><item><p> If <emph>ST</emph> is <code>xs:untypedAtomic</code>
                                        or <code>xs:string</code>, see 
                                    <specref ref="casting-from-strings"/>. </p></item></ulist></item><item><p>When a value of any primitive type is cast as <code>xs:date</code>,
                                the <code>xs:date</code> value <emph>TV</emph> is derived from
                                <emph>ST</emph> and <emph>SV</emph> as follows:</p><ulist><item><p>If <emph>ST</emph> is <code>xs:date</code>, then
                                        <emph>TV</emph> is <emph>SV</emph>. </p></item><item><p>If <emph>ST</emph> is <code>xs:dateTime</code>, then let
                                        <emph>SYR</emph> be <code>eg:convertYearToString( fn:year-from-dateTime(</code>
                                        <emph>SV</emph>
                                        <code>))</code>, let <emph>SMO</emph> be
                                            <code>eg:convertTo2CharString( fn:month-from-dateTime(</code>
                                        <emph>SV</emph>
                                        <code>))</code>, let <emph>SDA</emph> be
                                            <code>eg:convertTo2CharString( fn:day-from-dateTime(</code>
                                        <emph>SV</emph>
                                        <code>))</code> and let <emph>STZ</emph> be <code>eg:convertTZtoString(fn:timezone-from-dateTime(</code>
                                        <emph>SV</emph>
                                        <code>))</code>; <emph>TV</emph> is <code>xs:date( fn:concat(</code>
                                        <emph>SYR</emph>
                                        <code>, '-', </code>
                                        <emph>SMO</emph>
                                        <code>, '-', </code>
                                        <emph>SDA</emph>, <emph>STZ</emph>
                                        <code>) )</code>. </p></item><item><p> If <emph>ST</emph> is <code>xs:untypedAtomic</code>
                                        or <code>xs:string</code>, see 
                                    <specref ref="casting-from-strings"/>. </p></item></ulist></item><item><p>When a value of any primitive type is cast as
                                <code>xs:gYearMonth</code>, the <code>xs:gYearMonth</code> value
                                <emph>TV</emph> is derived from <emph>ST</emph> and <emph>SV</emph>
                                as follows:</p><ulist><item><p>If <emph>ST</emph> is <code>xs:gYearMonth</code>, then
                                        <emph>TV</emph> is <emph>SV</emph>. </p></item><item><p>If <emph>ST</emph> is <code>xs:dateTime</code>, then let
                                        <emph>SYR</emph> be <code>eg:convertYearToString( fn:year-from-dateTime(</code>
                                        <emph>SV</emph>
                                        <code>))</code>, let <emph>SMO</emph> be
                                            <code>eg:convertTo2CharString( fn:month-from-dateTime(</code>
                                        <emph>SV</emph>
                                        <code>))</code> and let <emph>STZ</emph> be
                                            <code>eg:convertTZtoString( fn:timezone-from-dateTime(</code>
                                        <emph>SV</emph>
                                        <code>))</code>; <emph>TV</emph> is <code>xs:gYearMonth( fn:concat(</code>
                                        <emph>SYR</emph>
                                        <code>, '-', </code>
                                        <emph>SMO</emph>, <emph>STZ</emph>
                                        <code>) )</code>. </p></item><item><p>If <emph>ST</emph> is <code>xs:date</code>, then let
                                        <emph>SYR</emph> be <code>eg:convertYearToString( fn:year-from-date(</code>
                                        <emph>SV</emph>
                                        <code>))</code>, let <emph>SMO</emph> be
                                            <code>eg:convertTo2CharString( fn:month-from-date(</code>
                                        <emph>SV</emph>
                                        <code>))</code> and let <emph>STZ</emph> be
                                            <code>eg:convertTZtoString( fn:timezone-from-date(</code>
                                        <emph>SV</emph>
                                        <code>))</code>; <emph>TV</emph> is <code>xs:gYearMonth( fn:concat(</code>
                                        <emph>SYR</emph>
                                        <code>, '-', </code>
                                        <emph>SMO</emph>, <emph>STZ</emph>
                                        <code>) )</code>. </p></item><item><p> If <emph>ST</emph> is <code>xs:untypedAtomic</code>
                                        or <code>xs:string</code>, see 
                                    <specref ref="casting-from-strings"/>. </p></item></ulist></item><item><p>When a value of any primitive type is cast as <code>xs:gYear</code>,
                                the <code>xs:gYear</code> value <emph>TV</emph> is derived from
                                <emph>ST</emph> and <emph>SV</emph> as follows:</p><ulist><item><p>If <emph>ST</emph> is <code>xs:gYear</code>, then
                                        <emph>TV</emph> is <emph>SV</emph>. </p></item><item><p>If <emph>ST</emph> is <code>xs:dateTime</code>, let
                                        <emph>SYR</emph> be <code>eg:convertYearToString( fn:year-from-dateTime(</code>
                                        <emph>SV</emph>
                                        <code>))</code> and let <emph>STZ</emph> be
                                            <code>eg:convertTZtoString( fn:timezone-from-dateTime(</code>
                                        <emph>SV</emph>
                                        <code>))</code>; <emph>TV</emph> is <code>xs:gYear(fn:concat(</code>
                                        <emph>SYR</emph>, <emph>STZ</emph>
                                        <code>))</code>. </p></item><item><p>If <emph>ST</emph> is <code>xs:date</code>, let
                                        <emph>SYR</emph> be <code>eg:convertYearToString( fn:year-from-date(</code>
                                        <emph>SV</emph>
                                        <code>))</code>; and let <emph>STZ</emph> be
                                            <code>eg:convertTZtoString( fn:timezone-from-date(</code>
                                        <emph>SV</emph>
                                        <code>))</code>; <emph>TV</emph> is <code>xs:gYear(fn:concat(</code>
                                        <emph>SYR</emph>, <emph>STZ</emph>
                                        <code>))</code>. </p></item><item><p> If <emph>ST</emph> is <code>xs:untypedAtomic</code>
                                        or <code>xs:string</code>, see 
                                    <specref ref="casting-from-strings"/>. </p></item></ulist></item><item><p>When a value of any primitive type is cast as
                                <code>xs:gMonthDay</code>, the <code>xs:gMonthDay</code> value
                                <emph>TV</emph> is derived from <emph>ST</emph> and <emph>SV</emph>
                                as follows:</p><ulist><item><p>If <emph>ST</emph> is <code>xs:gMonthDay</code>, then
                                        <emph>TV</emph> is <emph>SV</emph>. </p></item><item><p>If <emph>ST</emph> is <code>xs:dateTime</code>, then let
                                        <emph>SMO</emph> be <code>eg:convertTo2CharString( fn:month-from-dateTime(</code>
                                        <emph>SV</emph>
                                        <code>))</code>, let <emph>SDA</emph> be
                                            <code>eg:convertTo2CharString( fn:day-from-dateTime(</code>
                                        <emph>SV</emph>
                                        <code>))</code> and let <emph>STZ</emph> be
                                            <code>eg:convertTZtoString( fn:timezone-from-dateTime(</code>
                                        <emph>SV</emph>
                                        <code>))</code>; <emph>TV</emph> is <code>xs:gYearMonth( fn:concat(</code>
                                        <code> '--', </code>
                                        <emph>SMO</emph>
                                        <code> '-', </code>
                                        <emph>SDA</emph>, <emph>STZ</emph>
                                        <code>) )</code>. </p></item><item><p>If <emph>ST</emph> is <code>xs:date</code>, then let
                                        <emph>SMO</emph> be <code>eg:convertTo2CharString( fn:month-from-date(</code>
                                        <emph>SV</emph>
                                        <code>))</code>, let <emph>SDA</emph> be
                                            <code>eg:convertTo2CharString( fn:day-from-date(</code>
                                        <emph>SV</emph>
                                        <code>))</code> and let <emph>STZ</emph> be
                                            <code>eg:convertTZtoString( fn:timezone-from-date(</code>
                                        <emph>SV</emph>
                                        <code>))</code>; <emph>TV</emph> is <code>xs:gYearMonth( fn:concat(</code>
                                        <code> '--', </code>
                                        <emph>SMO</emph>
                                        <code>, '-', </code>
                                        <emph>SDA</emph>, <emph>STZ</emph>
                                        <code>) )</code>. </p></item><item><p> If <emph>ST</emph> is <code>xs:untypedAtomic</code>
                                        or <code>xs:string</code>, see 
                                    <specref ref="casting-from-strings"/>.</p></item></ulist></item><item><p>When a value of any primitive type is cast as <code>xs:gDay</code>,
                                the <code>xs:gDay</code> value <emph>TV</emph> is derived from
                                <emph>ST</emph> and <emph>SV</emph> as follows:</p><ulist><item><p>If <emph>ST</emph> is <code>xs:gDay</code>, then
                                        <emph>TV</emph> is <emph>SV</emph>. </p></item><item><p>If <emph>ST</emph> is <code>xs:dateTime</code>, then let
                                        <emph>SDA</emph> be <code>eg:convertTo2CharString( fn:day-from-dateTime(</code>
                                        <emph>SV</emph>
                                        <code>))</code> and let <emph>STZ</emph> be
                                            <code>eg:convertTZtoString( fn:timezone-from-dateTime(</code>
                                        <emph>SV</emph>
                                        <code>))</code>; <emph>TV</emph> is <code>xs:gDay(
                                            fn:concat( '---'</code>, <emph>SDA</emph>, <emph>STZ</emph>
                                        <code>))</code>. </p></item><item><p>If <emph>ST</emph> is <code>xs:date</code>, then let
                                        <emph>SDA</emph> be <code>eg:convertTo2CharString( fn:day-from-date(</code>
                                        <emph>SV</emph>
                                        <code>))</code> and let <emph>STZ</emph> be
                                            <code>eg:convertTZtoString( fn:timezone-from-date(</code>
                                        <emph>SV</emph>
                                        <code>))</code>; <emph>TV</emph> is <code>xs:gDay(
                                            fn:concat( '---'</code>, <emph>SDA</emph>, <emph>STZ</emph>
                                        <code>))</code>. </p></item><item><p> If <emph>ST</emph> is <code>xs:untypedAtomic</code>
                                        or <code>xs:string</code>, see 
                                    <specref ref="casting-from-strings"/>. </p></item></ulist></item><item><p>When a value of any primitive type is cast as <code>xs:gMonth</code>,
                                the <code>xs:gMonth</code> value <emph>TV</emph> is derived from
                                <emph>ST</emph> and <emph>SV</emph> as follows:</p><ulist><item><p>If <emph>ST</emph> is <code>xs:gMonth</code>, then
                                        <emph>TV</emph> is <emph>SV</emph>. </p></item><item><p>If <emph>ST</emph> is <code>xs:dateTime</code>, then let
                                        <emph>SMO</emph> be <code>eg:convertTo2CharString( fn:month-from-dateTime(</code>
                                        <emph>SV</emph>
                                        <code>))</code> and let <emph>STZ</emph> be
                                            <code>eg:convertTZtoString( fn:timezone-from-dateTime(</code>
                                        <emph>SV</emph>
                                        <code>))</code>; <emph>TV</emph> is <code>xs:gMonth(
                                            fn:concat( '--' </code>, <emph>SMO</emph>, <emph>STZ</emph>
                                        <code>))</code>. </p></item><item><p>If <emph>ST</emph> is <code>xs:date</code>, then let
                                        <emph>SMO</emph> be <code>eg:convertTo2CharString( fn:month-from-date(</code>
                                        <emph>SV</emph>
                                        <code>))</code> and let <emph>STZ</emph> be
                                            <code>eg:convertTZtoString( fn:timezone-from-date(</code>
                                        <emph>SV</emph>
                                        <code>))</code>; <emph>TV</emph> is <code>xs:gMonth(
                                            fn:concat( '--'</code>, <emph>SMO</emph>, <emph>STZ</emph>
                                        <code>))</code>. </p></item><item><p> If <emph>ST</emph> is <code>xs:untypedAtomic</code>
                                        or <code>xs:string</code>, see 
                                    <specref ref="casting-from-strings"/>.</p></item></ulist></item></olist></div3><!--					<head>Casting to date and time types</head>

				<p>Conversion from primitive types to date and time types follows the rules below.</p>
                 <olist> 
					<item>
						<p>When a value of any primitive type is cast as <code>xs:dateTime</code>, <code>xs:time</code>, <code>xs:date</code>, <code>xs:gYearMonth</code>, <code>xs:gYear</code>, 
<code>xs:gMonthDay</code>, <code>xs:gDay</code>, or <code>xs:gMonth</code>, let <emph>CYR</emph> be <code>fn:year-from-dateTime( fn:current-dateTime() ) cast as xs:string</code>, let <emph>CMO</emph> be <code>fn:month-from-dateTime( fn:current-dateTime() ) cast as xs:string</code>, let <emph>CDA</emph> be <code>fn:day-from-dateTime( fn:current-dateTime() ) cast as xs:string</code> and let <emph>CTZ</emph> be <code>fn:timezone-from-dateTime( fn:current-dateTime() ) cast as xs:string</code>. </p>
					</item>
					<item>
						<p>When a value of any primitive type is cast as <code>xs:dateTime</code>, the <code>xs:dateTime</code> value <emph>TV</emph> is derived from <emph>ST</emph> and <emph>SV</emph> as follows:</p>
						<ulist>
							<item>
								<p>If <emph>ST</emph> is <code>xs:dateTime</code>, then <emph>TV</emph> is <emph>SV</emph>. </p>
							</item>
							<item>
								<p>If <emph>ST</emph> is <code>xs:time</code>, then let <emph>SHR</emph> be <code>fn:hours-from-time(</code>
									<emph>SV</emph>	<code>) cast as xs:string</code>, let <emph>SMI</emph> be <code>fn:minutes-from-time(</code>
									<emph>SV</emph><code>) cast as xs:string</code>, let <emph>SSE</emph> be <code>fn:seconds-from-time(</code>
									<emph>SV</emph><code>) cast as xs:string</code> and let <emph>STZ</emph> be <code>fn:timezone-from-time(</code><emph>SV</emph><code>) cast as xs:string</code>
; <emph>TV</emph> is <code>xs:dateTime( fn:concat(</code>
									<emph>CYR</emph>
									<code>, '-', </code>
									<emph>CMO</emph>
									<code>, '-', </code>
									<emph>CDA</emph>
									<code>, 'T', </code>
									<emph>SHR</emph>
									<code>, ':', </code>
									<emph>SMI</emph>
									<code>, ':', </code>
									<emph>SSE</emph>,
									<emph>STZ</emph>
									<code>) )</code>. </p>
							</item>
							<item>
								<p>If <emph>ST</emph> is <code>xs:date</code>, then let <emph>SYR</emph> be <code>fn:year-from-date(</code>
									<emph>SV</emph><code>) cast as xs:string</code>, let <emph>SMO</emph> be <code>fn:month-from-date(</code><emph>SV</emph><code>) cast as xs:string</code>, let <emph>SDA</emph> be <code>fn:day-from-date(</code>
									<emph>SV</emph><code>) cast as xs:string</code> and let <emph>STZ</emph> be <code>fn:timezone-from-date(</code><emph>SV</emph><code>) cast as xs:string</code>; <emph>TV</emph> is <code>xs:dateTime( fn:concat(</code>
									<emph>SYR</emph>
									<code>, '-', </code>
									<emph>SMO</emph>
									<code>, '-', </code>
									<emph>SDA</emph>
									<code>, 'T00:00:00 '</code>,
									<emph>STZ</emph>
									<code>) )</code>. </p>
							</item>
							<item>
								<p>
								If <emph>ST</emph> is 
												<code>xs:untypedAtomic</code> or <code>xs:string</code>, emph>SV</emph> is converted to an intermediate value <emph>IV</emph> of type <code>xs:string</code>.</p>
							</item>
							<item>
								<p><emph>TV</emph> is <code>xs:dateTime(</code>
									<emph>IV</emph>
									<code>)</code>. </p>
							</item>
						</ulist>
					</item>
					<item>
						<p>When a value of any primitive type is cast as <code>xs:time</code>, the <code>xs:time</code> value <emph>TV</emph> is derived from <emph>ST</emph> and <emph>SV</emph> as follows:</p>
						<ulist>
							<item>
								<p>If <emph>ST</emph> is <code>xs:time</code>, then <emph>TV</emph> is <emph>SV</emph>. </p>
							</item>
							<item>
								<p>If <emph>ST</emph> is <code>xs:dateTime</code>, then <emph>TV</emph> is <code>xs:time( fn:concat( fn:hours-from-dateTime(</code><emph>SV</emph><code>) cast as xs:string, ':', fn:minutes-from-dateTime(</code><emph>SV</emph><code>) cast as xs:string, ':', fn:seconds-from-dateTime(</code><emph>SV</emph><code>) cast as xs:string,  fn:timezone-from-dateTime(</code><emph>SV</emph><code>) cast as xs:string ) )</code>. </p>
							</item>
							<item>
								<p>
						If <emph>ST</emph> is 
<code>xs:untypedAtomic</code> or 
<code>xs:string</code>, 
<emph>SV</emph> is converted to an intermediate value <emph>IV</emph> of type <code>xs:string</code>.</p></item>
							<item>
								<p><emph>TV</emph> is <code>xs:time(</code>
									<emph>IV</emph>
									<code>)</code>. </p>
							</item>
						</ulist>
					</item>
					<item>
						<p>When a value of any primitive type is cast as <code>xs:date</code>, the <code>xs:date</code> value <emph>TV</emph> is derived from <emph>ST</emph> and <emph>SV</emph> as follows:</p>
						<ulist>
							<item>
								<p>If <emph>ST</emph> is <code>xs:date</code>, then <emph>TV</emph> is <emph>SV</emph>. </p>
							</item>
							<item>
								<p>If <emph>ST</emph> is <code>xs:dateTime</code>, then let <emph>SYR</emph> be <code>fn:year-from-dateTime(</code><emph>SV</emph><code>) cast as xs:string</code>, 
let <emph>SMO</emph> be <code>fn:month-from-dateTime(</code><emph>SV</emph><code>) cast as xs:string</code>, 
let <emph>SDA</emph> be <code>fn:day-from-dateTime(</code><emph>SV</emph><code>) cast as xs:string</code> and let <emph>STZ</emph> be <code>fn:timezone-from-dateTime(</code><emph>SV</emph><code>) cast as xs:string</code>; <emph>TV</emph> is <code>xs:date( fn:concat(</code>
									<emph>SYR</emph>
									<code>, '-', </code>
									<emph>SMO</emph>
									<code>, '-', </code>
									<emph>SDA</emph>, 
									<emph>STZ</emph>
									<code>) )</code>. </p>
							</item>
<item>
								<p>
						If <emph>ST</emph> is 
<code>xs:untypedAtomic</code> or 
<code>xs:string</code>, 
<emph>SV</emph> is converted to an intermediate value <emph>IV</emph> of type <code>xs:string</code>.</p></item>
							<item>
								<p><emph>TV</emph> is <code>xs:date(</code>
									<emph>IV</emph>
									<code>)</code>. </p>
							</item>
						</ulist>
					</item>
					<item>
						<p>When a value of any primitive type is cast as <code>xs:gYearMonth</code>, the <code>xs:gYearMonth</code> value <emph>TV</emph> is derived from <emph>ST</emph> and <emph>SV</emph> as follows:</p>
						<ulist>
						<item>
								<p>If <emph>ST</emph> is <code>xs:gYearMonth</code>, then <emph>TV</emph> is <emph>SV</emph>. </p>
							</item>
						<item>
								<p>If <emph>ST</emph> is <code>dateTime</code>, then let <emph>SYR</emph> be <code>fn:year-from-dateTime(</code>
									<emph>SV</emph>
									<code>) cast as xs:string</code>, let <emph>SMO</emph> be <code>fn:month-from-dateTime(</code>
									<emph>SV</emph>
									<code>) cast as xs:string</code> and let <emph>STZ</emph> be <code>fn:timezone-from-dateTime(</code>
									<emph>SV</emph>
									<code>) cast as xs:string</code>; <emph>TV</emph> is <code>xs:gYearMonth( fn:concat(</code>
									<emph>SYR</emph>
									<code>, '-', </code>
									<emph>SMO</emph>,
									<emph>STZ</emph>
									<code>) )</code>. </p>
							</item> 
<item>
								<p>If <emph>ST</emph> is <code>date</code>, then let <emph>SYR</emph> be <code>fn:year-from-date(</code>
									<emph>SV</emph>
									<code>) cast as xs:string</code>, let <emph>SMO</emph> be <code>fn:month-from-date(</code>
									<emph>SV</emph>
									<code>) cast as xs:string</code> and let <emph>STZ</emph> be <code>fn:timezone-from-date(</code>
									<emph>SV</emph>
									<code>) cast as xs:string</code>; <emph>TV</emph> is <code>xs:gYearMonth( fn:concat(</code>
									<emph>SYR</emph>
									<code>, '-', </code>
									<emph>SMO</emph>,
									<emph>STZ</emph>
									<code>) )</code>. </p>
							</item>
							<item>
								<p>
						If <emph>ST</emph> is 
<code>xs:untypedAtomic</code> or 
<code>xs:string</code>, 
<emph>SV</emph> is converted to an intermediate value <emph>IV</emph> of type <code>xs:string</code>.</p></item>
							<item>
								<p><emph>TV</emph> is <code>xs:gYearMonth(</code>
									<emph>IV</emph>
									<code>)</code>. </p>
							</item>
						</ulist>
					</item>
					<item>
						<p>When a value of any primitive type is cast as <code>xs:gYear</code>, the <code>xs:gYear</code> value <emph>TV</emph> is derived from <emph>ST</emph> and <emph>SV</emph> as follows:</p>
						<ulist>
						<item> 
								<p>If <emph>ST</emph> is <code>xs:gYear</code>, then <emph>TV</emph> is <emph>SV</emph>. </p>
							</item>
						<item>
								<p>If <emph>ST</emph> is <code>dateTime</code>, let <emph>SYR</emph> be <code>fn:year-from-dateTime(</code> <emph>SV</emph> <code>) cast as xs:string</code> and let <emph>STZ</emph> be <code>fn:timezone-from-dateTime(</code>
									<emph>SV</emph>
									<code>) cast as xs:string</code>; <emph>TV</emph> is <code>xs:gYear(</code>
									<emph>SYR</emph>,
									<emph>STZ</emph>
									<code>)</code>. </p>
							</item> 
							<item>
<p>If <emph>ST</emph> is <code>date</code>, let <emph>SYR</emph> be <code>fn:year-from-date(</code>
									<emph>SV</emph>
									<code>) cast as xs:string</code>; and let <emph>STZ</emph> be <code>fn:timezone-from-date(</code> 
<emph>SV</emph> <code>) cast as xs:string</code>;
									<emph>TV</emph> is <code>xs:gYear(</code>
									<emph>SYR</emph>,
									<emph>STZ</emph>
									<code>)</code>. </p>
							</item> 
							<item>
								<p>
						If <emph>ST</emph> is 
<code>xs:untypedAtomic</code> or 
<code>xs:string</code>, 
<emph>SV</emph> is converted to an intermediate value <emph>IV</emph> of type <code>xs:string</code>.</p></item>
							<item>
								<p><emph>TV</emph> is <code>xs:gYear(</code>
									<emph>IV</emph>
									<code>)</code>. </p>
							</item>
						</ulist>
					</item>
					<item>
						<p>When a value of any primitive type is cast as <code>xs:gMonthDay</code>, the <code>xs:gMonthDay</code> value <emph>TV</emph> is derived from <emph>ST</emph> <emph>SV</emph> as follows:</p>
						<ulist>
						<item>
								<p>If <emph>ST</emph> is <code>xs:gMonthDay</code>, then <emph>TV</emph> is <emph>SV</emph>. </p>
							</item>
						<item>
								<p>If <emph>ST</emph> is <code>dateTime</code>, then let <emph>SMO</emph> be <code>fn:month-from-dateTime(</code>
									<emph>SV</emph>
									<code>) cast as xs:string</code>, let <emph>SDA</emph> be <code>fn:day-from-dateTime(</code>
									<emph>SV</emph>
									<code>) cast as xs:string</code> and let <emph>STZ</emph> be <code>fn:timezone-from-dateTime(</code>
									<emph>SV</emph>
									<code>) cast as xs:string</code>; <emph>TV</emph> is <code>xs:gYearMonth( fn:concat(</code>
									<code> '&mdash;&mdash;', </code>
									<emph>SMO</emph>
									<code>, '-', </code>
									<emph>SDA</emph>, <emph>STZ</emph>
									<code>) )</code>. </p>
							</item>
<item>
								<p>If <emph>ST</emph> is <code>date</code>, then let <emph>SMO</emph> be <code>fn:month-from-date(</code>
									<emph>SV</emph>
									<code>) cast as xs:string</code>, let <emph>SDA</emph> be <code>fn:day-from-date(</code>
									<emph>SV</emph>
									<code>) cast as xs:string</code> and let <emph>STZ</emph> be <code>fn:timezone-from-date(</code>
									<emph>SV</emph>
									<code>) cast as xs:string</code>; <emph>TV</emph> is <code>xs:gYearMonth( fn:concat(</code>
									<code>, '&mdash;&mdash;', </code>
									<emph>SMO</emph>
									<code>, '-', </code>
									<emph>SDA</emph>, <emph>STZ</emph>
									<code>) )</code>. </p>
							</item>
							<item>
								<p>
						If <emph>ST</emph> is 
<code>xs:untypedAtomic</code> or 
<code>xs:string</code>, 
<emph>SV</emph> is converted to an intermediate value <emph>IV</emph> of type <code>xs:string</code>.</p></item>
							<item>
								<p><emph>TV</emph> is <code>xs:gMonthDay(</code>
									<emph>IV</emph>
									<code>)</code>. </p>
							</item>
						</ulist>
					</item>
					<item>
						<p>When a value of any primitive type is cast as <code>xs:gDay</code>, the <code>xs:gDay</code> value <emph>TV</emph> is derived from <emph>ST</emph> and <emph>SV</emph> as follows:</p>
						<ulist>
						<item>
								<p>If <emph>ST</emph> is <code>xs:gDay</code>, then <emph>TV</emph> is <emph>SV</emph>. </p>
							</item>
						<item>
								<p>If <emph>ST</emph> is <code>dateTime</code>, then let <emph>SDA</emph> be <code>fn:day-from-dateTime(</code>
									<emph>SV</emph>
									<code>) cast as xs:string</code> and let <emph>STZ</emph> be <code>fn:timezone-from-dateTime(</code>
									<emph>SV</emph>
									<code>) cast as xs:string</code>; <emph>TV</emph> is <code>xs:gDay( fn:concat( '&mdash;&mdash;&mdash;'</code>,
									<emph>SDA</emph>, <emph>STZ</emph>
									<code>))</code>. </p>
							</item> 
							<item>
								<p>If <emph>ST</emph> is <code>date</code>, then let <emph>SDA</emph> be <code>fn:day-from-date(</code>
									<emph>SV</emph>
									<code>) cast as xs:string</code> and let <emph>STZ</emph> be <code>fn:timezone-from-date(</code>
									<emph>SV</emph>
									<code>) cast as xs:string</code>; <emph>TV</emph> is <code>xs:gDay( fn:concat( '&mdash;&mdash;&mdash;'</code>,
									<emph>SDA</emph>, <emph>STZ</emph>
									<code>))</code>. </p>
							</item> 
							<item>
								<p>
						If <emph>ST</emph> is 
<code>xs:untypedAtomic</code> or 
<code>xs:string</code>, 
<emph>SV</emph> is converted to an intermediate value <emph>IV</emph> of type <code>xs:string</code>.</p></item>
							<item>
								<p><emph>TV</emph> is <code>xs:gDay(</code>
									<emph>IV</emph>
									<code>)</code>. </p>
							</item>
						</ulist>
					</item>
					<item>
						<p>When a value of any primitive type is cast as <code>xs:gMonth</code>, the <code>xs:gMonth</code> value <emph>TV</emph> is derived from <emph>ST</emph> and <emph>SV</emph> as follows:</p>
						<ulist>
						<item>
								<p>If <emph>ST</emph> is <code>xs:gMonth</code>, then <emph>TV</emph> is <emph>SV</emph>. </p>
							</item>
						<item>
								<p>If <emph>ST</emph> is <code>xs:dateTime</code>, then let <emph>SMO</emph> be <code>fn:month-from-dateTime(</code>
									<emph>SV</emph>
									<code>) cast as xs:string</code> and let <emph>STZ</emph> be <code>fn:timezone-from-dateTime(</code>
									<emph>SV</emph>
									<code>) cast as xs:string</code>; <emph>TV</emph> is <code>xs:gMonth( fn:concat( '&mdash;&mdash' </code>,
									<emph>SMO</emph>, <emph>STZ</emph>
									<code>))</code>. </p>
							</item> 
<item>
								<p>If <emph>ST</emph> is <code>xs:date</code>, then let <emph>SMO</emph> be <code>fn:month-from-date(</code>
									<emph>SV</emph>
									<code>) cast as xs:string</code> and let <emph>STZ</emph> be <code>fn:timezone-from-date(</code>
									<emph>SV</emph>
									<code>) cast as xs:string</code>; <emph>TV</emph> is <code>xs:gMonth( fn:concat( '&mdash;&mdash'</code>,
									<emph>SMO</emph>, <emph>STZ</emph>
									<code>))</code>. </p>
							</item> 
							<item>
								<p>
						If <emph>ST</emph> is 
<code>xs:untypedAtomic</code> or 
<code>xs:string</code>, 
<emph>SV</emph> is converted to an intermediate value <emph>IV</emph> of type <code>xs:string</code>.</p></item>
							<item>
								<p><emph>TV</emph> is <code>xs:gMonth(</code>
									<emph>IV</emph>
									<code>)</code>. </p>
							</item>
						</ulist>
					</item>
				</olist> 
			</div2> --><div3 id="casting-boolean"><head>Casting to xs:boolean </head><p>When a value of any primitive type is cast as <code>xs:boolean</code>, the
                        <code>xs:boolean</code> value <emph>TV</emph> is derived from
                        <emph>ST</emph> and <emph>SV</emph> as follows:</p><ulist><item><p>If <emph>ST</emph> is <code>xs:boolean</code>, then <emph>TV</emph>
                                is <emph>SV</emph>.</p></item><!--					<item>
						<p>If <emph>ST</emph> is <code>string</code> and 
<code>fn:upper-case(</code>
							<emph>SV</emph>
							<code>)</code> is <quote>
								<code>TRUE</code>
							</quote> or <quote>
								<code>1</code>
							</quote>, then <emph>TV</emph> is <code>true</code>; if <emph>ST</emph> is <code>string</code> and <code>fn:upper-case(</code>
							<emph>SV</emph>
							<code>)</code> is <quote>
								<code>FALSE</code>
							</quote> or <quote>
								<code>0</code>
							</quote>, then <emph>TV</emph> is <code>false</code>. </p>
					</item> --><item><p>If <emph>ST</emph> is <code>xs:float</code>, <code>xs:double</code>,
                                <code>xs:decimal</code> or <code>xs:integer</code> and
                                <emph>SV</emph> is <code>0</code>, <code>+0</code>, <code>-0</code>,
                                <code>0.0</code>, <code>0.0E0</code> or <code>NaN</code>, then
                                <emph>TV</emph> is <code>false</code>. </p></item><item><p>If <emph>ST</emph> is <code>xs:float</code>, <code>xs:double</code>,
                                <code>xs:decimal</code> or <code>xs:integer</code> and
                                <emph>SV</emph> is not one of the above values, then <emph>TV</emph>
                                is <code>true</code>. </p></item><!--					<item>
						<p>If <emph>ST</emph> is <code>xs:base64Binary</code> or <code>xs:hexBinary</code> and <emph>SV</emph> is <quote>
								<code>1</code>
							</quote>, then <emph>TV</emph> is <code>true</code>; if <emph>ST</emph> is <code>xs:base64Binary</code> or <code>xs:hexBinary</code> and <emph>SV</emph> is <quote>
								<code>0</code>
							</quote>, then <emph>TV</emph> is <code>false</code>. </p>
					</item> --><item><p> If <emph>ST</emph> is <code>xs:untypedAtomic</code>
                                or <code>xs:string</code>, see 
                                    <specref ref="casting-from-strings"/>. </p></item></ulist></div3><div3 id="casting-to-binary"><head>Casting to xs:base64Binary and xs:hexBinary</head><p>Values of type <code>xs:base64Binary</code> can be cast as
                        <code>xs:hexBinary</code> and vice versa, since the two types have the same
                        value space. Casting to <code>xs:base64Binary</code> and
                        <code>xs:hexBinary</code> is also supported from the same type and from
                        <code>xs:untypedAtomic</code>, <code>xs:string</code> and subtypes of
                        <code>xs:string</code> using <bibref ref="xmlschema-2"/> semantics.</p></div3><div3 id="casting-to-anyuri"><head>Casting to xs:anyURI</head><p>Casting to <code>xs:anyURI</code> is supported only from the same type,
                        <code>xs:untypedAtomic</code> or <code>xs:string</code>.</p><p>When a value of any primitive type is cast as <code>xs:anyURI</code>, the
                        <code>xs:anyURI</code> value <emph>TV</emph> is derived from the
                        <emph>ST</emph> and <emph>SV</emph> as follows:</p><ulist><item><p>If <emph>ST</emph> is <code>xs:untypedAtomic</code> or <code>xs:string</code> see 
                                    <specref ref="casting-from-strings"/>.
                             </p></item></ulist></div3><div3 id="casting-to-qname-and-notation" diff="add" at="B"><head>Casting to xs:QName and xs:NOTATION</head><p>Casting from <code>xs:string</code> or <code>xs:untypedAtomic</code> to
                  <code>xs:QName</code> or <code>xs:NOTATION</code> is described in 
                  <specref ref="casting-from-strings"/>.</p><p>It is also possible to cast from <code>xs:NOTATION</code> to <code>xs:QName</code>, 
                  or from <code>xs:QName</code> to
                  any type derived by restriction from <code>xs:NOTATION</code>. (Casting to <code>xs:NOTATION</code>
                  itself is not allowed, because <code>xs:NOTATION</code> is an abstract type.) The resulting
                  <code>xs:QName</code> or <code>xs:NOTATION</code> has the same prefix, local name, and namespace URI
                  parts as the supplied value.</p></div3></div2><div2 id="casting-to-derived-types"><head>Casting to derived types</head><p>Casting a value to a derived type can be separated into four cases. Note that
                    <code>xs:untypedAtomic</code>, <code>xs:integer</code> and the two derived
                    types of <code>xs:duration</code>:<code>xs:yearMonthDuration</code>
                    and <code>xs:dayTimeDuration</code> are treated as primitive types.</p><olist><item><p>When <emph>SV</emph> is an instance of a type that is derived by
                            restriction from <emph>TT</emph>. This is described in section <specref ref="casting-from-derived-to-parent"/>. </p></item><item><p>When <emph>SV</emph> is an instance of a type derived by restriction from
                            the same primitive type as <emph>TT</emph>. This is described in
                                <specref ref="casting-within-branch"/>. </p></item><item><p>When the derived type is derived, directly or indirectly, from a
                            different primitive type than the primitive type of <emph>ST</emph>.
                            This is described in <specref ref="casting-across-hierarchy"/>.</p></item><item><p>When <emph>SV</emph> is an instance of the <emph>TT</emph>, the cast
                            always succeeds (Identity cast).</p></item></olist></div2><div2 id="casting-from-derived-to-parent"><head>Casting from derived types to parent types</head><p>Except in the case of <code>xs:NOTATION</code>, it is always possible to cast a value of any atomic type to an atomic type from
                    which it is derived, directly or indirectly, by restriction. For example, it is
                    possible to cast an <code>xs:unsignedShort</code> to an
                    <code>xs:unsignedInt</code>, an <code>xs:integer</code>, or an
                    <code>xs:decimal</code>. Since the value space of the original type is a subset
                    of the value space of the target type, such a cast is always successful. The
                    result will have the same value as the original, but will have a new type annotation.</p></div2><div2 id="casting-within-branch"><head>Casting within a branch of the type hierarchy</head><p>It is possible to cast an <emph>SV</emph> to a <emph>TT</emph> if the type of the
                    <emph>SV</emph> and the <emph>TT</emph> type are both derived by restriction
                    (directly or indirectly) from the same primitive type, provided that the
                    supplied value conforms to the constraints implied by the facets of the target
                    type.  This includes the case where the target type is derived from the type of the supplied value,
                    as well as the case where the type of the supplied value is derived from the target type.  For example, an instance of <code>xs:byte</code> can be cast as
                    <code>xs:unsignedShort</code>, provided the value is not negative.  </p><p>If the value does not conform to the facets defined for the target type, then an
                    error is raised <errorref class="RG" code="0001"/>. See <bibref ref="xmlschema-2"/>.
                    In the case of the pattern facet (which applies to the lexical space rather than
                    the value space), the pattern is tested against the canonical lexical
                    representation of the value, as defined for the source type (or the result
                    of casting the value to an <code>xs:string</code>, in the case of types that have no canonical
                    lexical representation defined for them).</p><p>Note that this will cause casts to fail if the pattern excludes the canonical
                    lexical representation of the source type. For example, if the type
                    <code>my:distance</code> is defined as a restriction of <code>xs:decimal</code>
                    with a pattern that requires two digits after the decimal point, casting of an
                    <code>xs:integer</code> to <code>my:distance</code> will always fail, because
                    the canonical representation of an <code>xs:integer</code> does not conform to
                    this pattern.</p><p>In some cases, casting from a parent type to a derived type requires special
                    rules. See <specref ref="casting-to-durations"/> for rules regarding casting to
                    <code>xs:yearMonthDuration</code> and <code>xs:dayTimeDuration</code>.  See <specref ref="casting-to-ENTITY"/>, below, for casting to <code>xs:ENTITY</code> and types derived from it.</p><div3 id="casting-to-ENTITY"><head>Casting to xs:ENTITY</head><p>
                  <bibref ref="xmlschema-2"/> says that <quote>The
value space of ENTITY is the set of all strings that match the 
NCName production ... and have been
declared as an unparsed entity in a document type definition.</quote>
However,
<bibref ref="xslt20"/> and <bibref ref="xquery"/> do not check that constructed values of type <code>xs:ENTITY</code> match declared unparsed entities.  Thus, this rule is relaxed in this specification and, in casting to <code>xs:ENTITY</code> and types derived from it, no check is made that the values correspond to declared unparsed entities.
</p></div3></div2><div2 id="casting-across-hierarchy"><head>Casting across the type hierarchy</head><p>When the <emph>ST</emph> and the <emph>TT</emph> are derived, directly or
                    indirectly, from different primitive types, this is called casting across the
                    type hierarchy. Casting across the type hierarchy is logically equivalent to
                    three separate steps performed in order. Errors can occur in either of the
                    latter two steps.</p><olist><item><p>Cast the <emph>SV</emph>, up the hierarchy, to the primitive type of the
                            source, as described in <specref ref="casting-from-derived-to-parent"/>.</p><olist><item><p>
If <emph>SV</emph> is an instance of <code>xs:string</code> or <code>xs:untypedAtomic</code>, check its value against the pattern facet of <emph>TT</emph>, and raise an error <errorref class="RG" code="0001"/> if the check fails.</p></item></olist></item><item><p>Cast the value to the primitive type of <emph>TT</emph>, as described in
                                <specref ref="casting-from-primitive-to-primitive"/>.</p><ulist><item><p>If <emph>TT</emph> is derived from <code>xs:NOTATION</code>, assume for the
purposes of this rule that casting to <code>xs:NOTATION</code> succeeds.
</p></item></ulist></item><item><p>Cast the value down to the <emph>TT</emph>, as described in <specref ref="casting-within-branch"/>
                        </p></item></olist></div2></div1></body><back><div1 id="biblio"><head>References</head><div2 id="normative-biblio"><head>Normative references</head><blist><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="charmod" key="Character Model for the World Wide Web 1.0: Fundamentals" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Character Model for the World Wide Web 1.0:
Fundamentals. Available at:
<loc href="http://www.w3.org/TR/2005/REC-charmod-20050215/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2005/REC-charmod-20050215/</loc>
               </bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="ieee754" key="IEEE 754-1985" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">IEEE. <emph>IEEE Standard for
                  Binary Floating-Point Arithmetic.</emph>
               </bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="ISO3166" key="ISO 3166-1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ISO (International Organization for Standardization)
					<emph>Codes for the representation of names of countries
					 and their subdivisions - Part 1: Country codes</emph> ISO 3166-1:1997.
                    </bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="ISO10967" key="ISO 10967" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ISO (International Organization
for Standardization). <emph>ISO/IEC 10967-1:1994, Information
technology—Language Independent Arithmetic—Part 1:
Integer and floating point arithmetic</emph> [Geneva]: International
Organization for Standardization, 1994. Available from: <loc href="http://www.iso.ch/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.iso.ch/</loc>
               </bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="LDML" key="Locale Data Markup Language" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Unicode Technical
                  Standard #35, Locale Data Markup Language. Available at:
                  <loc href="http://www.unicode.org/unicode/reports/tr35/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.unicode.org/unicode/reports/tr35/</loc>
               </bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="LEIRI" key="Legacy extended IRIs for XML resource identification" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><emph>Legacy extended IRIs for XML resource identification</emph>.
                  Henry S. Thomson, Richard Tobin, and Norman Walsh (eds), World Wide Web Consortium. 3 November 2008. Available at
                  <loc href="http://www.w3.org/TR/leiri/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/leiri/</loc>
               </bibl><!--<bibl id="rfc2396" key="RFC 2396">IETF. <emph>RFC 2396: Uniform
                  Resource Identifiers (URI): Generic Syntax. </emph> Available at:
                  <loc href="http://www.ietf.org/rfc/rfc2396.txt">http://www.ietf.org/rfc/rfc2396.txt</loc>
                  </bibl>--><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="rfc2376" key="RFC 2376" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">IETF. <emph>RFC 2376: XML Media Types. </emph> Available at:
                  <loc href="http://www.ietf.org/rfc/rfc2376.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.ietf.org/rfc/rfc2376.txt</loc>
               </bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="rfc3023" key="RFC 3023" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">IETF. <emph>RFC 2376: XML Media Types. </emph> Available at:
                  <loc href="http://www.ietf.org/rfc/rfc3023.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.ietf.org/rfc/rfc3023.txt</loc>
               </bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="rfc3986" key="RFC 3986" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">IETF. <emph>RFC 3986: Uniform
                  Resource Identifiers (URI): Generic Syntax. </emph> Available at:
                  <loc href="http://www.ietf.org/rfc/rfc3986.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.ietf.org/rfc/rfc3986.txt</loc>
               </bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="rfc3987" key="RFC 3987" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">IETF. <emph>RFC 3987:
                  Internationalized Resource Identifiers (IRIs).</emph> Available at:
                  <loc href="http://www.ietf.org/rfc/rfc3987.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.ietf.org/rfc/rfc3987.txt</loc>
               </bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="olson" key="Olson Timezone Database" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
                  The <emph>tz</emph> timezone database, available at 
                  <loc href="http://www.twinsun.com/tz/tz-link.htm" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.twinsun.com/tz/tz-link.htm</loc>.
                  It is <termref def="implementation-defined"/> which version of the database is used.
               </bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="Unicode4" key="The Unicode Standard" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
The Unicode Consortium, Reading, MA, Addison-Wesley, 2003. <emph>The Unicode Standard</emph>
as updated from time to time by the publication of new versions. See 
<loc href="http://www.unicode.org/unicode/standard/versions" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.unicode.org/unicode/standard/versions</loc>
for the latest version and additional information on versions of the standard and of the Unicode Character Database. 
The version of Unicode to be used is <termref def="implementation-defined"/>, but implementations are recommended to use the latest Unicode version; currently, Version 4.0.00, Addison-Wesley, 2003 ISBN 0-321-18578-1
</bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="Unicode-Collations" key="Unicode Collation Algorithm" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Unicode Technical Standard #10, Unicode Collation
Algorithm. Available at:
<loc href="http://www.unicode.org/unicode/reports/tr10/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.unicode.org/unicode/reports/tr10/</loc>
               </bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="Unicode-Normalization" key="Unicode Normaliation Forms" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Unicode Standard Annex #15, Unicode Normalization
                  Forms. Available at:
                  <loc href="http://www.unicode.org/unicode/reports/tr15/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.unicode.org/unicode/reports/tr15/</loc>.
                  As with <bibref ref="Unicode4"/>, the version to be used is <termref def="implementation-defined"/>.
               </bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="Unicode-Regex" key="Unicode Regular Expressions" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Unicode
Technical Standard #18, Unicode Regular Expressions. Available at:
<loc href="http://www.unicode.org/unicode/reports/tr18/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.unicode.org/unicode/reports/tr18/</loc>
               </bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="REC-xml" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"> World Wide Web
                        Consortium. <emph>Extensible Markup Language (XML) 1.0 Third Edition.</emph>
                        Available at: <loc href="http://www.w3.org/TR/REC-xml" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/REC-xml</loc>
                    </bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xml11" key="Extensible Markup Language (XML) 1.1 Recommendation" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"> World Wide Web
                        Consortium. <emph>Extensible Markup Language (XML) 1.1.</emph>
                        Available at: 
						<loc href="http://www.w3.org/TR/2004/REC-xml11-20040204/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2004/REC-xml11-20040204/</loc>
                    </bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xpath" key="XML Path Language (XPath) Version 1.0" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xpath20" key="XML Path Language (XPath) 2.0" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xpath-21" key="XML Path Language (XPath) 2.1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xslt20" key="XSL Transformations (XSLT) Version 2.0" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xslt-21" key="XSL Transformations (XSLT) Version 2.1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xpath-datamodel-11" key="XQuery and XPath Data Model (XDM) 1.1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xslt-xquery-serialization-11" key="XSLT and XQuery Serialization 1.1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xquery-semantics" key="XQuery 1.0 and XPath 2.0 Formal Semantics" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xquery" key="XQuery 1.0: An XML Query Language" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xquery-11" key="XQuery 1.1: An XML Query Language" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><!--<bibl  id="xmlschema-1"
                     key="XML Schema Part 1: Structures Second Edition"> XML
                        Schema Part 1: Structures Second Edition, Oct 28 2004. Available at: 
						<loc href="http://www.w3.org/TR/xmlschema-1/">http://www.w3.org/TR/xmlschema-1/</loc>
						</bibl>--><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xinclude" key="XML Inclusions (XInclude) Version 1.0 (Second Edition)" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xmlschema-2" key="XML Schema Part 2: Datatypes Second Edition" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"> XML Schema
                        Part 2: Datatypes Second Edition, Oct. 28 2004. Available at: 
						<loc href="http://www.w3.org/TR/xmlschema-2/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xmlschema-2/</loc>
               </bibl><!--<bibl  id="xmlschema11-2"
                  key="XML Schema 1.1 Part 2: Datatypes"> XML Schema 1.1
                  Part 2: Datatypes, 30 January 2009. Available at: 
                  <loc href="http://www.w3.org/TR/xmlschema11-2/">http://www.w3.org/TR/xmlschema11-2/</loc>
               </bibl>--><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="REC-xml-names" key="Namespaces in XML" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"> Namespaces in XML. Available at:
                     <loc href="http://www.w3.org/TR/1999/REC-xml-names-19990114/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/1999/REC-xml-names-19990114/</loc>
                    </bibl></blist></div2><div2 id="non-normative-biblio"><head>Non-normative references</head><blist><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="CALCALC" diff="add" at="A" key="Calendrical Calculations" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Edward M. Reingold and Nachum Dershowitz.
<emph>Calendrical Calculations Millennium edition (2nd Edition)</emph>. Cambridge University Press, 
ISBN 0 521 77752 6</bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="charmod-normalization" key="Character Model for the World Wide Web 1.0: Normalization" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Character Model for the World Wide Web
                  1.0: Normalization, Last Call Working Draft. Available at:
                  <loc href="http://www.w3.org/TR/2004/WD-charmod-norm-20040225/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2004/WD-charmod-norm-20040225/</loc>
               </bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="HTML40" key="HTML 4.0" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">HTML 4.01 Recommendation, 24 December
1999. Available at:
<loc href="http://www.w3.org/TR/REC-html40/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/REC-html40/</loc>
               </bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="ISO8601" key="ISO 8601" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ISO (International Organization for
Standardization). <emph>Representations of dates and times,
2000-08-03.</emph> Available from:
<loc href="http://www.iso.ch/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.iso.ch/"</loc>
               </bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="POSIX.1-2008" key="POSIX.1-2008" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
                  <emph>The Open Group Base Specifications Isuse 7 (IEEE Std 1003.1-2008)</emph>.
                  Available at: <loc href="http://www.opengroup.org/onlinepubs/9699919799/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.opengroup.org/onlinepubs/9699919799/</loc>
               </bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="Working-With-Timezones" key="Working With Timezones" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium Working Group Note. 
					 <emph>Working With Timezones, October 13, 2005.</emph> Available at:
<loc href="http://www.w3.org/TR/2005/NOTE-timezone-20051013/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2005/NOTE-timezone-20051013/</loc>
               </bibl></blist></div2></div1><div1 id="error-summary"><head>Error summary</head><p>The error text provided with these errors is non-normative.</p><error-list><error class="ER" code="0000" label="Unidentified error." type="dynamic"><p>Unidentified error.</p></error><error class="AR" code="0001" label="Division by zero." type="dynamic"><p>This error is raised whenever an attempt is made to divide by zero.</p></error><error class="AR" code="0002" label="Numeric operation overflow/underflow." type="dynamic"><p>This error is raised whenever numeric operations result in an overflow or underflow.</p></error><error class="CA" code="0001" label="Input value too large for decimal." type="dynamic"><p/></error><error class="CA" code="0002" label="Invalid lexical value." type="dynamic"><p/></error><error class="CA" code="0003" label="Input value too large for integer." type="dynamic"><p/></error><error class="CA" code="0005" label="NaN supplied as float/double value." type="dynamic"><p/></error><error class="CA" code="0006" label="String to be cast to decimal has too many digits of precision." type="dynamic"><p/></error><error class="CH" code="0001" label="Codepoint not valid." type="dynamic"><p/></error><error class="CH" code="0002" label="Unsupported collation." type="dynamic"><p/></error><error class="CH" code="0003" label="Unsupported normalization form." type="static"><p/></error><error class="CH" code="0004" label="Collation does not support collation units." type="dynamic"><p/></error><error class="DC" code="0001" label="No context document." type="dynamic"><p/></error><error class="DC" code="0002" label="Error retrieving resource." type="dynamic"><p/></error><error class="DC" code="0003" label="Function stability not defined." type="dynamic"><p/></error><error class="DC" code="0004" label="Invalid argument to fn:collection." type="dynamic"><p/></error><error class="DC" code="0005" label="Invalid argument to fn:doc or fn:doc-available." type="dynamic"><p/></error><error class="DC" code="0006" label="String passed to fn:parse-xml is not a well-formed XML document." type="dynamic"><p/></error><error class="DC" code="0007" label="Base URI passed to fn:parse-xml is not a valid absolute URI." type="dynamic"><p/></error><error class="DF" code="1280" label="Invalid decimal format name." type="dynamic" diff="add" at="A"><p>This error is raised if the decimal format name supplied to <code>fn:format-number</code> is not a valid QName,
			   or if the prefix in the QName is undeclared, or if there is no decimal format in the static context with
			   a matching name.</p></error><error class="DF" code="1310" label="Invalid decimal format picture string." type="dynamic" diff="add" at="A"><p>This error is raised if the picture string supplied to <code>fn:format-number</code> has invalid syntax.</p></error><error class="DT" code="0001" label="Overflow/underflow in date/time operation." type="dynamic"><p/></error><error class="DT" code="0002" label="Overflow/underflow in duration operation." type="dynamic"><p/></error><error class="DT" code="0003" label="Invalid timezone value." type="dynamic"><p/></error><error class="FD" code="1340" label="Invalid date/time formatting picture string." type="dynamic" diff="add" at="A"><p>This error is raised if the picture string supplied to <code>fn:format-date</code>, <code>fn:format-time</code>, 
			   or <code>fn:format-dateTime</code> has invalid syntax.</p></error><error class="FD" code="1350" label="Invalid date/time formatting component." type="dynamic" diff="add" at="A"><p>This error is raised if the picture string supplied to <code>fn:format-date</code> 
			   selects a component that is not present in a date, or if the picture string supplied to <code>fn:format-time</code> 
			   selects a component that is not present in a time.</p></error><!--
                <error class="NC" code="0001" label="Undefined context item." type="dynamic">
                    <p></p>
                </error> --><!--
                <error class="NS" code="0003" label="No prefix defined for namespace." type="dynamic">
                    <p></p>
                    </error> --><error class="NS" code="0004" label="No namespace found for prefix." type="dynamic"><p/></error><error class="NS" code="0005" label="Base-uri not defined in the static context." type="dynamic"><p/></error><error class="RG" code="0001" label="Invalid value for cast/constructor." type="dynamic"><p/></error><error class="RG" code="0002" label="Invalid argument to fn:resolve-uri()." type="dynamic"><p/></error><error class="RG" code="0003" label="fn:zero-or-one called with a sequence containing more than one item." type="dynamic"><p/></error><error class="RG" code="0004" label="fn:one-or-more called with a sequence containing no items." type="dynamic"><p/></error><error class="RG" code="0005" label="fn:exactly-one called with a sequence containing zero or more than one item." type="dynamic"><p/></error><error class="RG" code="0006" label="Invalid argument type." type="static"><p/></error><error class="RG" code="0008" label="The two arguments to fn:dateTime have inconsistent timezones." type="dynamic" diff="chg" at="A-E18"><p/></error><error class="RG" code="0009" label="Error in resolving a relative URI against a base URI in fn:resolve-uri." type="dynamic"><p/></error><error class="RX" code="0001" label="Invalid regular expression flags." type="static" diff="chg" at="A-E25"><p/></error><!--End of text replaced by erratum E25--><error class="RX" code="0002" label="Invalid regular expression." type="dynamic"><p/></error><error class="RX" code="0003" label="Regular expression matches zero-length string." type="dynamic"><p/></error><error class="RX" code="0004" label="Invalid replacement string." type="dynamic"><p/></error><error class="TY" code="0012" label="Argument to fn:data() contains a node that does not have a typed value." type="dynamic"><p/></error><error class="TY" code="0013" label="The argument to fn:data() contains a function item." type="dynamic"><p/></error><error class="TY" code="0014" label="The argument to fn:string() is a function item." type="dynamic"><p/></error><error class="TY" code="0015" label="An argument to fn:deep-equal() contains a function item." type="dynamic"><p/></error></error-list></div1><inform-div1 id="xpath1-compatibility"><head>Compatibility with XPath 1.0</head><p>This appendix summarizes the relationship between certain functions defined in
                    <bibref ref="xpath"/> and the corresponding functions defined in this document.
                The first column of the table provides the signature of functions defined in this
                document. The second column provides the signature of the corresponding function in
                    <bibref ref="xpath"/>. The third column describes the differences in the
                semantics of the corresponding functions. The functions appear in the order they
                appear in <bibref ref="xpath"/>. </p><p>The evaluation of the arguments to the functions defined in this document depends on
                whether the XPath 1.0 compatibility mode is on or off. See <bibref ref="xpath20"/>.
                If the mode is on, the following conversions are applied, in order, before the
                argument value is passed to the function:</p><ulist><item><p> If the expected type is a single item or an optional single item, (examples:
                            <code>xs:string, xs:string?, xs:untypedAtomic, xs:untypedAtomic?,
                            node(), node()?, item(), item()?</code>), then the given value
                        <code>V</code> is effectively replaced by <code>fn:subsequence(V, 1, 1)</code>.</p></item><item><p> If the expected type is <code>xs:string</code> or <code>xs:string?</code>,
                        then the given value <code>V</code> is effectively replaced by <code>fn:string(V)</code>.</p></item><item><p> If the expected type is numeric or optional numeric, then the given value
                        <code>V</code> is effectively replaced by <code>fn:number(V)</code>.</p></item><item><p>Otherwise, the given value is unchanged.</p></item></ulist><table border="1" width="100%" summary="Issues list"><col width="33%" span="1"/><col width="33%" span="1"/><col width="33%" span="1"/><tbody><tr><th rowspan="1" colspan="1">XQuery 1.0 and XPath 2.0</th><th rowspan="1" colspan="1">XPath 1.0</th><th rowspan="1" colspan="1">Notes</th></tr><tr><td rowspan="1" colspan="1">
                            <proto name="last" role="example" return-type="xs:integer" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" prefix="fn"/>
                        </td><td rowspan="1" colspan="1">
                            <code>last() =&gt; number</code>
                        </td><td rowspan="1" colspan="1">Precision of numeric results may be different.</td></tr><tr><td rowspan="1" colspan="1">
                            <proto name="position" role="example" return-type="xs:integer" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" prefix="fn"/>
                        </td><td rowspan="1" colspan="1">
                            <code>position() =&gt; number</code>
                        </td><td rowspan="1" colspan="1">Precision of numeric results may be different.</td></tr><tr><td rowspan="1" colspan="1">
                            <proto name="count" role="example" return-type="xs:integer" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" prefix="fn"><arg name="arg" type="item*" emptyOk="no"/></proto>
                        </td><td rowspan="1" colspan="1">
                            <code>count(node-set) =&gt; number</code>
                        </td><td rowspan="1" colspan="1">Precision of numeric results may be different.</td></tr><tr><td rowspan="1" colspan="1">
                            <proto name="id" role="example" return-type="element()*" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" prefix="fn"><arg name="arg" type="xs:string*" emptyOk="no"/></proto>
                        </td><td rowspan="1" colspan="1">
                            <code>id(object) =&gt; node-set</code>
                        </td><td rowspan="1" colspan="1">XPath 2.0 behavior is different for boolean and numeric arguments. The
                            recognition of a node as an id value is sensitive to the manner in which
                            the datamodel is constructed. In XPath 1.0 the whole string is treated
                            as a unit. In XPath 2.0 each string is treated as a list.</td></tr><tr><td rowspan="1" colspan="1">
                            <proto name="local-name" role="example" return-type="xs:string" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" prefix="fn"/>
                        </td><td rowspan="2" colspan="1">
                            <code>local-name(node-set?) =&gt; string</code>
                        </td><td rowspan="2" colspan="1">If compatibility mode is off, an error will occur if
                            argument has more than one node.</td></tr><tr><td rowspan="1" colspan="1">
                            <proto name="local-name" role="example" return-type="xs:string" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" prefix="fn"><arg name="arg" type="node()?"/></proto>
                        </td></tr><tr><td rowspan="1" colspan="1">
                            <proto name="namespace-uri" role="example" return-type="xs:string" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" prefix="fn"/>
                        </td><td rowspan="2" colspan="1">
                            <code>namespace-uri(node-set?) =&gt; string</code>
                        </td><td rowspan="2" colspan="1">If compatibility mode is off, an error will occur if
                            argument has more than one node.</td></tr><tr><td rowspan="1" colspan="1">
                            <proto name="namespace-uri" role="example" return-type="xs:string" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" prefix="fn"><arg name="arg" type="node" emptyOk="yes"/></proto>
                        </td></tr><tr><td rowspan="1" colspan="1">
                            <proto name="name" role="example" return-type="xs:string" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" prefix="fn"><arg name="arg" type="node()" emptyOk="yes"/></proto>
                        </td><td rowspan="1" colspan="1">
                            <code>name(node-set?) =&gt; string</code>
                        </td><td rowspan="1" colspan="1">If compatibility mode is off, an error will occur if argument has more
                            than one node. The rules for determining the prefix are more precisely
                            defined in <bibref ref="xpath20"/>. Function is not "well-defined" for
                            parentless attribute nodes.</td></tr><tr><td rowspan="1" colspan="1">
                            <proto name="string" role="example" return-type="xs:string" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" prefix="fn"/>
                        </td><td rowspan="2" colspan="1">
                            <code>string(object) =&gt; string</code>
                        </td><td rowspan="2" colspan="1">If compatibility mode is off, an error will occur if
                            argument has more than one node. Representations of numeric values are
                            XPath 1.0 compatible except for the special values positive and negative
                            infinity, and for values outside the range 1.0e-6 to 1.0e+6.</td></tr><tr><td rowspan="1" colspan="1">
                            <proto name="string" role="example" return-type="xs:string" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" prefix="fn"><arg name="arg" type="item()" emptyOk="yes"/></proto>
                        </td></tr><tr><td rowspan="1" colspan="1">
                            <proto name="concat" role="example" return-type="xs:string" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" prefix="fn"><arg name="arg1" type="xs:anyAtomicType" emptyOk="yes"/><arg name="arg2" type="xs:anyAtomicType" emptyOk="yes"/><arg name="..." type=""/></proto>
                        </td><td rowspan="1" colspan="1">
                            <code>concat(string, string, string*) =&gt; string</code>
                        </td><td rowspan="1" colspan="1">If compatibility mode is off, an error will occur if
                            an argument has more than one node.
                            If compatibility mode on, the first node in the sequence is used.</td><!--          <td>If compatibility mode is off, an error will occur if
                            argument has more than one node or if argument is a number or a boolean.
                            If compatibility mode on, implicit conversion is performed.</td> --></tr><tr><td rowspan="1" colspan="1">
                            <proto name="starts-with" role="example" return-type="xs:boolean" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" prefix="fn"><arg name="arg1" type="xs:string" emptyOk="yes"/><arg name="arg2" type="xs:string" emptyOk="yes"/></proto>
                        </td><td rowspan="2" colspan="1">
                            <code>starts-with(string, string) =&gt; boolean</code>
                        </td><td rowspan="2" colspan="1"><!-- In 1.0, returns <code>false</code> if the first argument is
                            an empty node-set. In 2.0, returns <code>()</code>.
--> If compatibility
                            mode is off, an error will occur if either argument has more than one node or
                            is a number or a boolean. If compatibility mode is on,
                            implicit conversion is performed.</td></tr><tr><td rowspan="1" colspan="1">
                            <proto name="starts-with" role="example" return-type="xs:boolean" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" prefix="fn"><arg name="arg1" type="xs:string" emptyOk="yes"/><arg name="arg2" type="xs:string" emptyOk="yes"/><arg name="collation" type="xs:string"/></proto>
                        </td></tr><tr><td rowspan="1" colspan="1">
                            <proto name="contains" role="example" return-type="xs:boolean" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" prefix="fn"><arg name="arg1" type="xs:string" emptyOk="yes"/><arg name="arg2" type="xs:string" emptyOk="yes"/></proto>
                        </td><td rowspan="2" colspan="1">
                            <code>contains(string, string) =&gt; boolean</code>
                        </td><td rowspan="2" colspan="1">
<!-- In 1.0, returns <code>false</code> if the first argument is
                            an empty node-set. In 2.0, returns <code>()</code>.
-->If compatibility
                            mode is off, an error will occur if either argument has more than one node or
                            is a number or a boolean. If compatibility mode is on,
                            implicit conversion is performed.</td></tr><tr><td rowspan="1" colspan="1">
                            <proto name="contains" role="example" return-type="xs:boolean" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" prefix="fn"><arg name="arg1" type="xs:string" emptyOk="yes"/><arg name="arg2" type="xs:string" emptyOk="yes"/><arg name="collation" type="xs:string"/></proto>
                        </td></tr><tr><td rowspan="1" colspan="1">
                            <proto name="substring-before" role="example" return-type="xs:string" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" prefix="fn"><arg name="arg1" type="xs:string" emptyOk="yes"/><arg name="arg2" type="xs:string" emptyOk="yes"/></proto>
                        </td><td rowspan="2" colspan="1">
                            <code>substring-before(string, string) =&gt; string </code>
                        </td><td rowspan="2" colspan="1">
<!-- In 1.0, returns <code>""</code> if the first argument is an
                            empty node-set. In 2.0, returns <code>()</code>. -->
If compatibility
                            mode is off, an error will occur if either argument has more than one node or
                            is a number or a boolean. If compatibility mode is on,
                            implicit conversion is performed.</td></tr><tr><td rowspan="1" colspan="1">
                            <proto name="substring-before" role="example" return-type="xs:string" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" prefix="fn"><arg name="arg1" type="xs:string" emptyOk="yes"/><arg name="arg2" type="xs:string" emptyOk="yes"/><arg name="collation" type="xs:string"/></proto>
                        </td></tr><tr><td rowspan="1" colspan="1">
                            <proto name="substring-after" role="example" return-type="xs:string" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" prefix="fn"><arg name="arg1" type="xs:string" emptyOk="yes"/><arg name="arg2" type="xs:string" emptyOk="yes"/></proto>
                        </td><td rowspan="2" colspan="1">
                            <code>substring-after(string, string) =&gt; string </code>
                        </td><td rowspan="2" colspan="1">
<!-- In 1.0, returns <code>""</code> if the first argument is an
                            empty node-set. In 2.0, returns <code>()</code>. -->
If compatibility
                            mode is off, an error will occur if either argument has more than one node or
                            is a number or a boolean. If compatibility mode is on,
                            implicit conversion is performed.</td></tr><tr><td rowspan="1" colspan="1">
                            <proto name="substring-after" role="example" return-type="xs:string" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" prefix="fn"><arg name="arg1" type="xs:string" emptyOk="yes"/><arg name="arg2" type="xs:string" emptyOk="yes"/><arg name="collation" type="xs:string"/></proto>
                        </td></tr><tr><td rowspan="1" colspan="1">
                            <proto name="substring" role="example" return-type="xs:string" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" prefix="fn"><arg name="sourceString" type="xs:string" emptyOk="yes"/><arg name="startingLoc" type="xs:double" emptyOk="no"/></proto>
                        </td><td rowspan="2" colspan="1">
                            <code>substring(string, number, number?) =&gt; string </code>
                        </td><td rowspan="2" colspan="1">
<!-- In 1.0, returns <code>""</code> if the first argument is an
                            empty node-set. In 2.0, returns <code>()</code>. -->If compatibility
                            mode is off, an error will occur if <code>$sourceString</code> has more than one node or
                            is a number or a boolean. If compatibility mode is on,
                            implicit conversion is performed.</td></tr><tr><td rowspan="1" colspan="1">
                            <proto name="substring" role="example" return-type="xs:string" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" prefix="fn"><arg name="sourceString" type="xs:string" emptyOk="yes"/><arg name="startingLoc" type="xs:double" emptyOk="no"/><arg name="length" type="xs:double" emptyOk="no"/></proto>
                        </td></tr><tr><td rowspan="1" colspan="1">
                            <proto name="string-length" role="example" return-type="xs:integer" returnEmptyOk="yes" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" prefix="fn"><arg name="arg" type="xs:string" emptyOk="yes"/></proto>
                        </td><td rowspan="2" colspan="1">
                            <code>string-length(string?) =&gt; number </code>
                        </td><td rowspan="2" colspan="1">If compatibility mode
                            is off, numbers and booleans will give errors for first arg. Also,
                            multiple nodes will give error.</td></tr><tr><td rowspan="1" colspan="1">
                            <proto name="string-length" role="example" return-type="xs:integer" returnEmptyOk="yes" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" prefix="fn"/>
                        </td></tr><tr><td rowspan="1" colspan="1">
                            <proto name="normalize-space" role="example" return-type="xs:string" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" prefix="fn"><arg name="arg" type="xs:string" emptyOk="yes"/></proto>
                        </td><td rowspan="2" colspan="1">
                            <code>normalize-space(string?) =&gt; string </code>
                        </td><td rowspan="2" colspan="1">
<!-- In 1.0, returns <code>""</code> if the first argument is an
                            empty node-set. In 2.0, returns <code>()</code>. 
--> If compatibility
                            mode is off, an error will occur if <code>$arg</code> has more than one node or
                            is a number or a boolean. If compatibility mode is on,
                            implicit conversion is performed.</td></tr><tr><td rowspan="1" colspan="1">
                            <proto name="normalize-space" role="example" return-type="xs:string" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" prefix="fn"/>
                        </td></tr><tr><td rowspan="1" colspan="1">
                            <!--Text replaced by erratum E9 change 1"--><proto name="translate" role="example" return-type="xs:string" returnEmptyOk="no" diff="chg" at="A-E9" returnSeq="no" prefix="fn" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no"><arg name="arg" type="xs:string" emptyOk="yes"/><arg name="mapString" type="xs:string" emptyOk="no"/><arg name="transString" type="xs:string" emptyOk="no"/></proto>
                     <!--End of text replaced by erratum E9-->
                        </td><td rowspan="1" colspan="1">
                            <code>translate(string, string, string)=&gt; string </code>
                        </td><td rowspan="1" colspan="1">.</td></tr><tr><td rowspan="1" colspan="1">
                            <proto name="boolean" role="example" return-type="xs:boolean" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" prefix="fn"><arg name="arg" type="item()*" emptyOk="no"/></proto>
                        </td><td rowspan="1" colspan="1">
                            <code>boolean(object) =&gt; boolean </code>
                        </td><td rowspan="1" colspan="1"/></tr><tr><td rowspan="1" colspan="1">
                            <proto name="not" role="example" return-type="xs:boolean" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" prefix="fn"><arg name="arg" type="item()*" emptyOk="no"/></proto>
                        </td><td rowspan="1" colspan="1">
                            <code>not(boolean) =&gt; boolean </code>
                        </td><td rowspan="1" colspan="1"/></tr><tr><td rowspan="1" colspan="1">
                            <proto name="true" role="example" return-type="xs:boolean" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" prefix="fn"/>
                        </td><td rowspan="1" colspan="1">
                            <code>true() =&gt; boolean</code>
                        </td><td rowspan="1" colspan="1"/></tr><tr><td rowspan="1" colspan="1">
                            <proto name="false" role="example" return-type="xs:boolean" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" prefix="fn"/>
                        </td><td rowspan="1" colspan="1">
                            <code>false() =&gt; boolean</code>
                        </td><td rowspan="1" colspan="1"/></tr><tr><td rowspan="1" colspan="1">
                            <proto name="lang" role="example" return-type="xs:boolean" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" prefix="fn"><arg name="testlang" type="xs:string"/></proto>
                        </td><td rowspan="1" colspan="1">
                            <code>lang(string) =&gt; boolean</code>
                        </td><td rowspan="1" colspan="1">If compatibility mode is off, numbers and booleans will give errors.
                            Also, multiple nodes will give error. If compatibility mode is on,
                            implicit conversion is performed.</td></tr><tr><td rowspan="1" colspan="1">
                            <proto name="number" role="example" return-type="xs:double" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" prefix="fn"/>
                        </td><td rowspan="2" colspan="1">
                            <code>number(object?) =&gt; number</code>
                        </td><td rowspan="2" colspan="1">Error if argument has more than one node when not in
                            compatibility node.</td></tr><tr><td rowspan="1" colspan="1">
                            <proto name="number" role="example" return-type="xs:double" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" prefix="fn"><arg name="arg" type="xs:anyAtomicType?"/></proto>
                        </td></tr><tr><td rowspan="1" colspan="1">
                            <proto name="sum" role="example" return-type="xs:anyAtomicType" returnEmptyOk="no" returnVaries="yes" returnSeq="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" prefix="fn"><arg name="arg" type="xs:anyAtomicType*" emptyOk="no"/></proto>
                        </td><td rowspan="1" colspan="1">
                            <code>sum(node-set) =&gt; number</code>
                        </td><td rowspan="1" colspan="1">2.0 raises an error if sequence contains values that cannot be added
                            together such as NMTOKENS and other subtypes of string. 1.0 returns <code>NaN</code>.
                            <!-- In 2.0 <code>NaN</code> values are removed from sequences of
<code>xs:float</code> or <code>xs:double</code> before addition is
performed. -->
                        </td></tr><tr><td rowspan="1" colspan="1">
                            <proto name="floor" role="example" return-type="numeric" returnEmptyOk="yes" returnVaries="yes" returnSeq="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" prefix="fn"><arg name="arg" type="numeric" emptyOk="yes"/></proto>
                        </td><td rowspan="1" colspan="1">
                            <code>floor(number)=&gt; number</code>
                        </td><td rowspan="1" colspan="1">In 2.0, if argument is <code>()</code>, the result is <code>()</code>.
                            In 1.0, the result is <code>NaN</code>. If compatibility mode is off, an
                            error will occur with more than one node. If compatibility mode is on,
                            implicit conversion is performed.</td></tr><tr><td rowspan="1" colspan="1">
                            <proto name="ceiling" role="example" return-type="numeric" returnEmptyOk="yes" returnVaries="yes" returnSeq="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" prefix="fn"><arg name="arg" type="numeric" emptyOk="yes"/></proto>
                        </td><td rowspan="1" colspan="1">
                            <code>ceiling(number)=&gt; number</code>
                        </td><td rowspan="1" colspan="1">In 2.0, if argument is <code>()</code>, the result is <code>()</code>.
                            In 1.0, the result is <code>NaN</code>. If compatibility mode is off, an
                            error will occur with more than one node. If compatibility mode is on,
                            implicit conversion is performed.</td></tr><tr><td rowspan="1" colspan="1">
                            <proto name="round" role="example" return-type="numeric" returnEmptyOk="yes" returnVaries="yes" returnSeq="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" prefix="fn"><arg name="arg" type="numeric" emptyOk="yes"/></proto>
                        </td><td rowspan="1" colspan="1">
                            <code>round(number)=&gt; number</code>
                        </td><td rowspan="1" colspan="1">In 2.0, if argument is <code>()</code>, the result is <code>()</code>.
                            In 1.0, the result is <code>NaN</code>. If compatibility mode is off, an
                            error will occur with more than one node. If compatibility mode is on,
                            implicit conversion is performed.</td></tr></tbody></table></inform-div1><inform-div1 id="examples"><head>Illustrative user-written functions</head><p> Certain functions that were proposed for inclusion in this function library have
                been excluded on the basis that it is straightforward for users to implement these
                functions themselves using XSLT 2.0 or XQuery 1.0.</p><p>This Appendix provides sample implementations of some of these functions.</p><p> To emphasize that these functions are examples of functions that vendors may write,
                their names carry the prefix 'eg'. Vendors are free to define such functions in any
                namespace. A group of vendors may also choose to create a collection of such useful
                functions and put them in a common namespace.</p><div2 id="if-empty-if-absent"><head>eg:if-empty and eg:if-absent</head><p>In some situations, users may want to provide default values for missing
                    information that may be signaled by elements that are omitted, have no value or
                    have the empty sequence as their value. For example, a missing middle initial
                    may be indicated by omitting the element or a non-existent bonus signaled with
                    an empty sequence. This section includes examples of functions that provide such
                    defaults. These functions return <code>xs:anyAtomicType*</code>. Users may want
                    to write functions that return more specific types.</p><div3 id="if-empty"><head>eg:if-empty</head><example role="signature"><proto role="example" name="eg:if-empty" return-type="xs:anyAtomicType*" returnEmptyOk="no" isSpecial="yes" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isOp="no" prefix="fn"><arg name="node" type="node()" emptyOk="yes"/><arg name="value" type="xs:anyAtomicType"/></proto></example><p> If the first argument is the empty sequence or an element without simple or
                        complex content, <code>eg:if-empty()</code> returns the second argument; otherwise, it
                        returns the content of the first argument.</p><p>XSLT implementation</p><eg xml:space="preserve" diff="chg" at="D">
&lt;xsl:function name="eg:if-empty" as="xs:anyAtomicType*"&gt;
  &lt;xsl:param name="node" as="node()?"/&gt;
  &lt;xsl:param name="value" as="xs:anyAtomicType"/&gt;
  &lt;xsl:sequence select="($node[child::node()], $value)[1]"/&gt;
&lt;/xsl:function&gt;</eg><p>XQuery implementation</p><eg xml:space="preserve" diff="chg" at="D">
declare function eg:if-empty (
  $node as node()?,
  $value as xs:anyAtomicType) as xs:anyAtomicType* 
{
  ($node[child::node()], $value)[1]
}
                    </eg></div3><div3 id="if-absent"><head>eg:if-absent</head><example role="signature"><proto role="example" name="eg:if-absent" return-type="xs:anyAtomicType*" returnEmptyOk="no" isSpecial="yes" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isOp="no" prefix="fn"><arg name="node" type="node()" emptyOk="yes"/><arg name="value" type="xs:anyAtomicType"/></proto></example><p> If the first argument is the empty sequence, <code>eg:if-absent()</code> returns the second
                        argument; otherwise, it returns the content of the first argument.</p><p>XSLT implementation</p><eg xml:space="preserve" diff="chg" at="D">
&lt;xsl:function name="eg:if-absent" as="xs:anyAtomicType*"&gt;
  &lt;xsl:param name="node" as="node()?"/&gt;
  &lt;xsl:param name="value" as="xs:anyAtomicType"/&gt;
  &lt;xsl:sequence select="($node, $value)[1]"/&gt;
&lt;/xsl:function&gt;</eg><p>XQuery implementation</p><eg xml:space="preserve" diff="chg" at="D">
declare function eg:if-absent (
  $node as node()?,
  $value as xs:anyAtomicType) as xs:anyAtomicType* 
{
  ($node, $value)[1]
}
                    </eg></div3></div2><div2 id="union-intersect-except-on-values"><head>Union, intersection and difference on sequences of values</head><div3 id="value-union"><head>eg:value-union</head><example role="signature"><proto role="example" name="eg:value-union" return-type="xs:anyAtomicType*" returnEmptyOk="no" isSpecial="yes" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isOp="no" prefix="fn"><arg name="arg1" type="xs:anyAtomicType*"/><arg name="arg2" type="xs:anyAtomicType*"/></proto></example><p> This function returns a sequence containing all the distinct items in $arg1
                        and $arg2, in an undefined order.</p><p>XSLT implementation</p><eg xml:space="preserve">
xsl:function name="eg:value-union" as="xs:anyAtomicType*"&gt;
  &lt;xsl:param name="arg1" as="xs:anyAtomicType*"/&gt;
  &lt;xsl:param name="arg2" as="xs:anyAtomicType*"/&gt;
  &lt;xsl:sequence
     select="fn:distinct-values(($arg1, $arg2))"/&gt; 
&lt;/xsl:function&gt;</eg><p>XQuery implementation</p><eg xml:space="preserve">
declare function eg:value-union (
  $arg1 as xs:anyAtomicType*,
  $arg2 as xs:anyAtomicType*) as xs:anyAtomicType* 
{
  fn:distinct-values(($arg1, $arg2))
}
                    </eg></div3><div3 id="value-intersect"><head>eg:value-intersect</head><example role="signature"><proto role="example" name="eg:value-intersect" return-type="xs:anyAtomicType*" returnEmptyOk="no" isSpecial="yes" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isOp="no" prefix="fn"><arg name="arg1" type="xs:anyAtomicType*"/><arg name="arg2" type="xs:anyAtomicType*"/></proto></example><p> This function returns a sequence containing all the distinct items that
                        appear in both $arg1 and $arg2, in an undefined order.</p><p>XSLT implementation&gt;</p><eg xml:space="preserve">
&lt;xsl:function name="eg:value-intersect" as="xs:anyAtomicType*"&gt;
  &lt;xsl:param name="arg1" as="xs:anyAtomicType*"/&gt;
  &lt;xsl:param name="arg2" as="xs:anyAtomicType*"/&gt;
  &lt;xsl:sequence 
     select="fn:distinct-values($arg1[.=$arg2])"/&gt;
&lt;/xsl:function&gt;</eg><p>XQuery implementation</p><eg xml:space="preserve">
declare function eg:value-intersect (
  $arg1 as xs:anyAtomicType*,
  $arg2 as xs:anyAtomicType* ) as xs:anyAtomicType* 
{
  fn:distinct-values($arg1[.=$arg2])
}
                    </eg></div3><div3 id="value-except"><head>eg:value-except</head><example role="signature"><proto role="example" name="eg:value-except" return-type="xs:anyAtomicType*" returnEmptyOk="no" isSpecial="yes" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isOp="no" prefix="fn"><arg name="arg1" type="xs:anyAtomicType*"/><arg name="arg2" type="xs:anyAtomicType*"/></proto></example><p> This function returns a sequence containing all the distinct items that
                        appear in $arg1 but not in $arg2, in an undefined order.</p><p>XSLT implementation</p><eg xml:space="preserve">
&lt;xsl:function name="eg:value-except" as="xs:anyAtomicType*"&gt;
  &lt;xsl:param name="arg1" as="xs:anyAtomicType*"/&gt;
  &lt;xsl:param name="arg2" as="xs:anyAtomicType*"/&gt;
  &lt;xsl:sequence
     select="fn:distinct-values($arg1[not(.=$arg2)])"/&gt;
&lt;/xsl:function&gt;</eg><p>XQuery implementation</p><eg xml:space="preserve">
declare function eg:value-except (
  $arg1 as xs:anyAtomicType*,
  $arg2 as xs:anyAtomicType*) as xs:anyAtomicType* 
{
  fn:distinct-values($arg1[not(.=$arg2)])
}</eg></div3></div2><div2 id="index-of-node"><head>eg:index-of-node</head><example role="signature"><proto role="example" name="eg:index-of-node" return-type="xs:integer*" returnEmptyOk="no" isSpecial="yes" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isOp="no" prefix="fn"><arg name="seq" type="node()*"/><arg name="search" type="node()"/></proto></example><p>This function returns a sequence of positive integers giving the positions within
                    the sequence <code>$seq</code> of nodes that are identical to <code>$search</code>.</p><p>The nodes in the sequence <code>$seq</code> are compared with
               <code>$search</code> under the rules for the <code>is</code> operator. If a
                    node compares identical, then the position of that node in the sequence
                    <code>$seq</code> is included in the result.</p><p>If the value of <code>$seq</code> is the empty sequence, or if no node in
               <code>$seq</code> matches <code>$search</code>, then the empty sequence is returned.</p><p>The index is 1-based, not 0-based.</p><p>The result sequence is in ascending numeric order.</p><p>XSLT implementation</p><eg xml:space="preserve" diff="chg" at="D">
&lt;xsl:function name="eg:index-of-node" as="xs:integer*"&gt;
  &lt;xsl:param name="seq" as="node()*"/&gt;
  &lt;xsl:param name="search" as="node()"/&gt;
  &lt;xsl:sequence select="filter(
      function($i as xs:integer) as xs:boolean {$seq[$i] is $search}, 
      1 to count($seq)
    )
  "/&gt;
&lt;/xsl:function&gt;</eg><p>XQuery implementation</p><eg xml:space="preserve" diff="chg" at="D">
declare function eg:index-of-node($seq as node()*, $search as node()) as xs:integer* 
{
    fn:filter(
      function($i as xs:integer) as xs:boolean {$seq[$i] is $search}, 
      1 to fn:count($seq)
    )

}</eg><p diff="add" at="D">An alternative implementation, which might be faster in systems where indexing into a sequence
            is slow, is:</p><eg xml:space="preserve" diff="chg" at="D">
declare function eg:index-of-node($seq as node()*, $search as node()) as xs:integer* 
{
  fn:map-pairs(function($node, $index) {
     if($node is $search) then $index else () 
  }, $seq, 1 to fn:count($seq))
}</eg></div2><div2 id="string-pad"><head>eg:string-pad</head><example role="signature"><proto role="example" name="eg:string-pad" return-type="xs:string" returnEmptyOk="no" isSpecial="yes" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isOp="no" prefix="fn"><arg name="padString" type="xs:string" emptyOk="yes"/><arg name="padCount" type="xs:integer"/></proto></example><p>Returns a <code>xs:string</code> consisting of a given number of copies of an
                    <code>xs:string</code> argument concatenated together.</p><p>XSLT implementation</p><eg xml:space="preserve" diff="chg" at="D">
&lt;xsl:function name="eg:string-pad" as="xs:string"&gt;
  &lt;xsl:param name="padString" as="xs:string?"/&gt;
  &lt;xsl:param name="padCount" as="xs:integer"/&gt;
  &lt;xsl:sequence select="
     fn:string-join(for $i in 1 to $padCount return $padString)"/&gt;
 &lt;/xsl:function&gt;
                </eg><p>XQuery implementation</p><eg xml:space="preserve" diff="chg" at="D">
declare function eg:string-pad (
  $padString as xs:string?,
  $padCount as xs:integer) as xs:string 
{
   fn:string-join(for $i in 1 to $padCount return $padString)
}
                </eg><p>This returns the zero-length string if <code>$padString</code> is the empty
                    sequence, which is consistent with the general principle that if an
                    <code>xs:string</code> argument is the empty sequence it is treated as if it
                    were the zero-length string.</p></div2><div2 id="func-distinct-nodes-stable"><head>eg:distinct-nodes-stable</head><example role="signature"><proto role="example" name="eg:distinct-nodes-stable" return-type="node()*" returnEmptyOk="no" isSpecial="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isOp="no" prefix="fn"><arg name="arg" type="node()*"/></proto></example><p>This function illustrates one possible implementation of a distinct-nodes
                    function. It removes duplicate nodes by identity, preserving the first
                    occurrence of each node.</p><p>XPath</p><eg xml:space="preserve">$arg[empty(subsequence($arg, 1, position()-1) intersect .)]
                </eg><p>XSLT implementation</p><eg xml:space="preserve" diff="chg" at="D">
&lt;xsl:function name="eg:distinct-nodes-stable" as="node()*"&gt;
  &lt;xsl:param name="arg" as="node()*"/&gt;
  &lt;xsl:sequence select=""
    fn:fold-left(
      function($foundSoFar as node()*, $this as node()) as node()* {
        if ($foundSoFar intersect $this)
        then $foundSoFar
        else ($foundSoFar, $this)
      }, (), $seq)
  "/&gt; 
&lt;/xsl:function&gt;
                </eg><p>XQuery implementation</p><eg xml:space="preserve" diff="chg" at="D">
declare function distinct-nodes-stable ($arg as node()*) as node()* { 
  fn:fold-left(
      function($foundSoFar as node()*, $this as node()) as node()* {
        if ($foundSoFar intersect $this)
        then $foundSoFar
        else ($foundSoFar, $this)
      }, (), $seq)

};</eg></div2><div2 id="highest-lowest" diff="add" at="D"><head>Finding minima and maxima</head><p>The <code>fn:min</code> and <code>fn:max</code> functions allow one to determine the smallest and largest
            values in a set of values, but they do not directly allow one to determine the elements having the smallest
            or largest value for some property, for example the employees earning the highest or lowest salary. The
            functions in this section show how this can be achieved.</p><p>The functions take as input an arbitrary sequence of items (typically but not necessarily a sequence of elements)
            and a function that computes a property value for each of these items. This must be a value of an atomic type
            for which order comparisons are defined. The functions return those items from the input sequence that have
            a higher (or lower) value for the given property than any others in the sequence. If there are several that
            are joint highest (or lowest) then they are all returned.</p><div3 id="highest"><head>eg:highest</head><p>The function <code>eg:highest</code> returns the items having the highest value for the supplied function.</p><p>XSLT implementation</p><eg xml:space="preserve">
&lt;xsl:function name="eg:highest" as="item()*"&gt;
  &lt;xsl:param name="f" as="function(item()) as xs:anyAtomicType"/&gt;
  &lt;xsl:param name="seq" as="item()*"/&gt;
  &lt;xsl:sequence select="
     fold-left(
       function($highestSoFar as item()*, $this as item()*) as item()* {
         let $thisValue := $f($this)
         let $highestValue := $f($highestSoFar[1])
         return
           if ($thisValue gt $highestValue)
             then $this
           else if ($thisValue eq $highestValue)
             then ($highestSoFar, $this)
           else $highestSoFar
       }, head($seq), tail($seq))"/&gt;
&lt;/xsl:function&gt;</eg><p>XQuery implementation</p><eg xml:space="preserve">
declare function eg:highest(
                     $f as function(item()) as xs:anyAtomicType, 
                     $seq as item()*)
                  as item()* {
     fn:fold-left(
       function($highestSoFar as item()*, $this as item()*) as item()* {
         let $thisValue := $f($this)
         let $highestValue := $f($highestSoFar[1])
         return
           if ($thisValue gt $highestValue)
             then $this
           else if ($thisValue eq $highestValue)
             then ($highestSoFar, $this)
           else $highestSoFar
       }, fn:head($seq), fn:tail($seq))
};</eg><p>To find the employees with the highest salary, the function might be invoked as:</p><eg xml:space="preserve">
eg:highest(function($emp){$emp/salary}, //employee)</eg></div3><div3 id="lowest"><head>eg:lowest</head><p>The function <code>eg:lowest</code> returns the items having the lowest value for the supplied function.</p><p>XSLT implementation</p><eg xml:space="preserve">
&lt;xsl:function name="eg:lowest" as="item()*"&gt;
  &lt;xsl:param name="f" as="function(item()) as xs:anyAtomicType"/&gt;
  &lt;xsl:param name="seq" as="item()*"/&gt;
  &lt;xsl:sequence select="
     fold-left(
       function($lowestSoFar as item()*, $this as item()*) as item()* {
         let $thisValue := $f($this)
         let $lowestValue := $f($lowestSoFar[1])
         return
           if ($thisValue lt $lowestValue)
             then $this
           else if ($thisValue eq $lowestValue)
             then ($lowestSoFar, $this)
           else $lowestSoFar
       }, head($seq), tail($seq))"/&gt;
&lt;/xsl:function&gt;</eg><p>XQuery implementation</p><eg xml:space="preserve">
declare function eg:highest(
                     $f as function(item()) as xs:anyAtomicType, 
                     $seq as item()*)
                  as item()* {
     fn:fold-left(
       function($lowestSoFar as item()*, $this as item()*) as item()* {
         let $thisValue := $f($this)
         let $lowestValue := $f($lowestSoFar[1])
         return
           if ($thisValue gt $lowestValue)
             then $this
           else if ($thisValue eq $lowestValue)
             then ($lowestSoFar, $this)
           else $lowestSoFar
       }, fn:head($seq), fn:tail($seq))
};</eg><p>To find the employees with the lowest total number of hours worked, the function might be invoked as:</p><eg xml:space="preserve">
eg:lowest(function($emp){sum($emp/timesheet/period/hours}, //employee)</eg></div3></div2><div2 id="sorting" diff="add" at="D"><head>Sorting</head><p>Both XSLT and XQuery include constructs for sorting sequences. However, it can often be convenient
            to invoke sorting via a simple function call. The example function in this section takes two arguments,
            a sequence to be sorted, and a function to compute a sort key, and it returns the items from the input
            sequence in sorted order of this sort key.</p><p>XSLT implementation</p><eg xml:space="preserve">
&lt;xsl:function name="eg:sort" as="item()*"&gt;
  &lt;xsl:param name="f" as="function(item()) as xs:anyAtomicType"/&gt;
  &lt;xsl:param name="seq" as="item()*"/&gt;
  &lt;xsl:perform-sort select="$seq"&gt;
    &lt;xsl:sort select="$f(.)"/&gt;
  &lt;/xsl:perform-sort&gt;
&lt;/xsl:function&gt;</eg><p>XQuery implementation</p><eg xml:space="preserve">
declare function eg:sort(
                     $f as function(item()) as xs:anyAtomicType, 
                     $seq as item()*)
                  as item()* {
     for $item in $seq order by $f($item) return $item
};
</eg><p>To obtain a list of employees sorted by salary, the function might be invoked as:</p><eg xml:space="preserve">
eg:sort(function($emp){$emp/salary}, //employee)</eg></div2></inform-div1><inform-div1 id="impl-def"><head>Checklist of implementation-defined features</head><p>This appendix provides a summary of features defined in this specification whose effect is explicitly <termref def="implementation-defined"/>. The conformance rules require vendors to provide documentation that explains how these choices have been exercised.
         </p><ednote><edtext>This list is incomplete in this working draft.</edtext></ednote><olist><item><p>The destination of the trace output is <termref def="implementation-defined"/>.  See <specref ref="func-trace"/>.</p></item><item><p>For <code>xs:integer</code> operations, implementations that support limited-precision integer operations <termref def="must"/> either raise an error 
<errorref class="AR" code="0002"/> or provide an <termref def="implementation-defined"/> mechanism that allows users to choose between raising an error and returning a result that is modulo the largest representable integer value.  See <specref ref="op.numeric"/>.</p></item><item><p> For <code>xs:decimal</code> values the number of digits of precision returned by the numeric operators is <termref def="implementation-defined"/>. See <specref ref="op.numeric"/>.  See also
<specref ref="casting-to-decimal"/> and <specref ref="casting-to-integer"/>
               </p></item><item><p> If the number of digits in the result of a numeric operation exceeds the number of digits that the implementation supports, the result is truncated or rounded in an <termref def="implementation-defined"/> manner. See <specref ref="op.numeric"/>.  See also
<specref ref="casting-to-decimal"/> and <specref ref="casting-to-integer"/>
               </p></item><item><p>It is <termref def="implementation-defined"/> which version of Unicode is supported by the features defined in this specification, but it is recommended that the most recent version of Unicode be used.  See <specref ref="string-types"/>.</p></item><item><p>For <specref ref="func-normalize-unicode"/>, conforming implementations <termref def="must"/> support normalization form "NFC" and <termref def="may"/> support normalization forms "NFD", "NFKC", "NFKD", "FULLY-NORMALIZED". They <termref def="may"/> also support other normalization forms with <termref def="implementation-defined"/> semantics.</p></item><item><p>The ability to decompose strings into collation units suitable for substring matching is an <termref def="implementation-defined"/> property of a collation. See <specref ref="substring.functions"/>.</p></item><item><p>All <emph>minimally conforming</emph> processors <termref def="must"/>  support year values with a minimum of 4 digits (i.e., YYYY) and a minimum fractional second precision of 1 millisecond or three digits (i.e., s.sss). However, <emph>conforming processors</emph> 
                  <termref def="may"/> set larger <termref def="implementation-defined"/> limits on the maximum number of digits they support in these two situations. See <specref ref="date-time-duration-conformance"/>.</p></item><item><p>The result of casting a string to <code>xs:decimal</code>, when the resulting value is not too large or too small but nevertheless has too many decimal digits to be accurately represented, is implementation-defined. See <specref ref="casting-from-strings"/>.
</p></item><item><p>Various aspects of the processing provided by <specref ref="func-doc"/> are <termref def="implementation-defined"/>. Implementations may provide external configuration options that allow any aspect of the processing to be controlled by the user.</p></item><item><p>The manner in which implementations provide options to weaken the 
<termref def="stable"/> characteristic of <specref ref="func-collection"/> and <specref ref="func-doc"/> are <termref def="implementation-defined"/>.</p></item></olist></inform-div1><inform-div1 id="changelog"><head>Changes since previous Recommendation</head><div2 id="substantive-changes-2009-12-15"><head>Substantive changes (15 December 2009)</head><p>In the Working Draft of 15 December 2009, the following changes were made relative to
		    the first edition of the Functions and Operators specification for
		 XPath 2.0 and XQuery 1.0 published on 23 January 2007:</p><olist><item><p>Errata E1 through E47 were applied.</p></item><item><p>A two-argument version of the <code>fn:round</code> function was introduced. (Bugzilla 6240)</p></item><item><p>A single-argument version of the <code>fn:string-join</code> function was introduced.</p></item><item><p>Specifications for the functions <code>fn:format-date</code>, <code>fn:format-time</code>, and <code>fn:format-dateTime</code>
		 were transferred from the XSLT 2.0 specification.</p></item><item><p>The specification of <code>fn:format-number</code> was transferred from the XSLT specification.</p></item><item><p>A function <code>fn:format-integer</code> was introduced.</p></item><item><p>The function <code>fn:generate-id</code> was introduced, transferred from the XSLT specification.</p></item><item><p>A range of trigonometric functions was defined (in a new namespace).</p></item><item><p>New functions <code>fn:parse-xml</code> and <code>fn:serialize</code> were defined. (The <code>fn:parse</code> function
		 was subsequently renamed <code>fn:parse-xml</code></p></item><item><p>A new function <code>fn:analyze-string</code> was defined.</p></item><item><p>The syntax of regular expressions was extended to allow non-capturing groups.</p></item><item><p>A new flag was introduced for the <code>$flags</code> argument of functions that use regular expressions: 
		    the <code>q</code> flag causes all characters in a regular expression to be treated as ordinary characters rather than metacharacters.</p></item><item><p>Supporting the new language feature of higher-order functions, a number of functions were
		 defined that operate on function items as their arguments. (The function <code>fn:partial-apply</code>, however, which was introduced
		 in the previous version of this Working Draft, has now been dropped in favor of custom syntax for partial application using "?" as a place-holder
		 for missing arguments.)</p></item><item><p>The description of the <code>fn:error</code> function was rewritten to allow for the introduction of try/catch
		 facilities into XQuery and XSLT.</p></item><item><p>The section describing what it means for functions to be contextual and/or stable was rewritten.</p></item></olist></div2><div2 id="substantive-changes-current-draft" diff="add" at="E"><head>Substantive changes (current draft)</head><p>In this internal Working Draft, the following substantive changes are made relative to 
	        the draft of 15 December 2009:</p><olist><item><p>New functions <code>fn:filter</code>, <code>fn:map</code>, <code>fn:map-pairs</code>,
	           <code>fn:fold-left</code>, and <code>fn:fold-right</code> are introduced.</p></item><item><p>In the rules for <code>fn:format-dateTime</code> and related functions, the
	           rules for formatting of timezones have been expanded and clarified; the <code>$country</code>
	           argument is renamed <code>$place</code>, and its value may now be an Olson timezone name.</p></item><item><p>The rules for the <code>fn:normalize-unicode</code> function are now defined
	           directly by reference to the Unicode specifications rather than the W3C Working Draft on
	           the Character Model for the World Wide Web (which never progressed beyond Working Draft status). The
	           rules for the normalization form <code>FULLY_NORMALIZED</code> are now defined normatively in this
	           specification.</p></item><item><p>The syntax for the picture string used by <code>fn:format-integer</code> has been extended
	           to allow grouping positions to be associated with optional digit positions.</p></item><item><p>Two convenience functions <code>fn:head</code> and <code>fn:tail</code> are added, reflecting
	           the increased role played by head-tail recursive functions when writing code to take advantage
	           of higher-order functions.</p></item><item><p>The function <code>fn:partial-apply</code> has been removed, as this functionality is now provided
	           by custom syntax (partial function application, using "?" as a placeholder for missing arguments)</p></item><item><p>Casting from a dynamic string to an <code>xs:QName</code> or a type derived from <code>xs:NOTATION</code>
	           is now permitted (the restriction that the argument must be a string literal has been removed). (Bug 9183)</p></item><item><p>Zero-argument forms have been introduced for the functions <code>fn:data</code>, <code>fn:document-uri</code>, and
	           <code>fn:node-name</code>, with the argument defaulting to the context item in each case. (Bug 9571)</p></item><item><p>The new function <code>fn:parse</code> is renamed <code>fn:parse-xml</code>. (Bug 9751)</p></item><item><p>The rules for handling of negative zero have been clarified. Where operations return negative zero,
	              then in general implementations must respect this; the only exception is for casting from string to float or double,
	              where the lexical form <code>-0</code> <rfc2119>may</rfc2119> result in positive zero for compatibility with
	              existing XML Schema 1.0 processors. (Bug 9907)</p></item><item><p>The functions <code>fn:unparsed-text</code> and <code>fn:unparsed-text-available</code> have been
	           transferred unchanged from XSLT. (Bug 9067)</p></item><item><p>The function <code>fn:uri-collection</code> has been added. This was originally defined as an output
	              of the work on streaming in XSLT 2.1; its purpose is to give applications greater control of the processing
	              of individual documents within a large collection.</p></item><item><p>The rules for the <code>fn:resolve-uri</code> function have been rewritten to refer to more up-to-date
	           specifications, specifically the IRI and LEIRI specifications. Implementations are required to support the IRI
	           syntax as a minimum, and are permitted to support the legacy extensions defined in LEIRI.</p></item><item><p>Two new functions <code>fn:get-environment-variable</code> and <code>fn:available-environment-variables</code>
	           have been defined.</p></item><!--<item><p></p></item>
	           
	           
	           <item><p>XXXXXXXXXXXXXXXX</p></item>--></olist></div2><div2 id="incompatibilities"><head>Incompatibilities</head><p>The following is a list of known incompatibilities between this draft and 
	              the first edition of the Functions and Operators specification for
	              XPath 2.0 and XQuery 1.0 published on 23 January 2007 (that is, differences
	              in observable behaviour that may mean existing applications using these functions need to be changed
	           to continue functioning correctly)</p><olist><item><p>The handling of timezones by <code>fn:format-dateTime</code> is more prescriptive
	              than in the previous specification (in this case, the XSLT 2.0 specification). The output
	              of the function may be different, depending on the interpretation adopted by implementations of the 
	              previous specification.</p></item></olist></div2><div2 id="editorial-changes"><head>Editorial changes</head><p>The following editorial changes have been made since the first edition of the Functions and Operators specification for
		 XPath 2.0 and XQuery 1.0 published on 23 January 2007. These are not explicitly marked in the change-highlighted version
		 of the specification:</p><olist><item><p>References to the Formal Semantics (which in nearly all cases were references to detailed rules for static type
		 inferencing) have been removed, as the Formal Semantics is not being maintained. (Bug 9056)</p></item><item><p>A quick reference section containing links to the functions has been added before the full table
		 of contents.</p></item><item><p>The section on constructor functions has been moved so that it is now adjacent to the closely-related section
		 on casting.</p></item><item><p>The function <code>fn:dateTime</code> has been moved out of the section describing constructor functions, and is
		 no longer described as "a special constructor function". It is now an ordinary function described in the appropriate section
		 along with other functions on dates and times. This allows the term "constructor function" to be associated exclusively with
		 single-argument functions whose name is the same as the type name of the value that they return, and avoids any suggestion that
		 this function has special behavior. Similarly, the functions <code>fn:true</code> and <code>fn:false</code> are no
		 longer described as constructor functions.</p></item><item><p>Where a function is referred to by name, the reference is now always in the form (for example) <code>fn:base-uri</code>
		 rather than <code>fn:base-uri()</code>. The latter form is used only to indicate a call on the function in which no arguments
		 are supplied.</p></item><item><p>The specification of each function now consists of a set of standard subsections: Summary, Operator
		 Mapping, Signature, Rules, Error Conditions, Notes, and Examples.</p></item><item><p>The "Summary" of the effect of each function is now just that: it never contains any information that cannot be
		 found in the more detailed rules, and it does not attempt to list unusual or error conditions. Such rules have been
		 moved into separate paragraphs. Sometimes the language used in the summary is relatively informal. Although the summary 
		 remains normative, it must be regarded as being subservient to the rules that follow.</p></item><item><p>Functions are always <emph>called</emph>, never <emph>invoked</emph>.</p></item><item><p>The specification no longer <emph>discusses</emph> functions, it now <emph>specifies</emph>
		 or <emph>defines</emph> them.</p></item><item><p>Rules have been rewritten in a more consistent style: "If <code>$arg</code> is X, the function returns Y" (avoiding
		 alternatives such as "Returns Y if <code>$arg</code> is X", and avoiding the passive "is returned").</p></item><item><p>The section heading for a section that defines a function is now always the name of the function. Some function
		 definitions have been moved into subsections to achieve this.</p></item><item><p>Statements within the rules of a function that follow inevitably from other rules have in many
		 cases been downgraded to notes. An example is the statement that <code>fn:remove($seq, N)</code> returns
		 an empty sequence if <code>$seq</code> is an empty sequence.</p></item><item><p>The functions for durations and those for dates/times have been split into separate sections.</p></item><item><p>The <code>fn:boolean</code> function has been moved from "General Functions and Operators on Sequences" to
		 "Functions on Boolean Values".</p></item><item><p>In the interests of automating the testing of examples, the convention has been adopted that the result 
		 of an example expression is wherever
		 possible given in the form of a simple but legal XPath expression. Specifically a numeric or string literal is
		 used for numbers and strings; the expressions
		 <code>true()</code> and <code>false()</code> for booleans; constructors such as <code>xs:duration('PT0S')</code> for other
		 atomic types; expressions such as <code>(1, 2, 3, 4)</code> for sequences. The expression will always return a value of the correct
		 type; so the <code>xs:double</code> value zero is shown as <code>0.0e0</code>, not as <code>0</code>, which is the way the value
		 would be serialized on output. The value <code>NaN</code> is given as <code>xs:double('NaN')</code>. Previously results 
		 were sometimes given in this form, sometimes in the form of a serialization of the result value, and sometimes (particularly for
		 dates, times, and durations) in the form of an informal description.</p></item><item><p>In some cases where one function can be readily specified in terms of another, the opportunity has been taken to simplify
		 the specification. For example, all the operator support functions of the form <code>op:xx-greater-than</code> are now specified by reference
		 to the corresponding <code>op:xx-less-than</code> function with the arguments reversed. This reduces the risk of introducing errors
		 and inconsistencies.</p></item><item><p>In some cases, the rules for a function have been reordered. For example, the rule describing how an empty sequence is handled
		 now generally comes before any rule that works only if the argument is not an empty sequence.</p></item><item><p>Some non-normative examples and notes have been added.</p></item><item diff="add" at="D"><p>The non-normative example functions in Appendix D have been revised, and new functions
		 are supplied to illustrate use cases for higher-order functions.</p></item></olist></div2></inform-div1></back></spec>
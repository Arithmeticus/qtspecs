<?xml version="1.0" encoding="utf-8"?>
<!--XSLT Processor: SAXON 8.9.0.4 from Saxonica SAXON SA 8.9.0.4-->
<!--This document was created at (not provided)-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="EN" xml:lang="EN">
<head>
<meta name="generator" content=
"HTML Tidy for Windows (vers 14 February 2006), see www.w3.org" />
<title>XQuery and XPath Formal Semantics 1.1</title>

<style type="text/css">
/*<![CDATA[*/
code           { font-family: monospace; }

div.constraint,
div.issue,
div.note,
div.notice     { margin-left: 2em; }

div.issue
p.title        { margin-left: -2em; }

ol.enumar      { list-style-type: decimal; }
ol.enumla      { list-style-type: lower-alpha; }
ol.enumlr      { list-style-type: lower-roman; }
ol.enumua      { list-style-type: upper-alpha; }
ol.enumur      { list-style-type: upper-roman; }

li p           { margin-top: 0.3em;
                 margin-bottom: 0.3em; }

sup small      { font-style: italic;
                 color: #8F8F8F;
               }
    
div.exampleInner pre { margin-left: 1em;
                       margin-top: 0em; margin-bottom: 0em}
div.exampleOuter {border: 4px double gray;
                  margin: 0em; padding: 0em}
div.exampleInner { background-color: #d5dee3;
                   border-top-width: 4px;
                   border-top-style: double;
                   border-top-color: #d3d3d3;
                   border-bottom-width: 4px;
                   border-bottom-style: double;
                   border-bottom-color: #d3d3d3;
                   padding: 4px; margin: 0em }
div.exampleWrapper { margin: 4px }
div.exampleHeader { font-weight: bold;
                    margin: 4px}

div.issue { border-bottom-color: black;
            border-bottom-style: solid;
            border-bottom-width: 1pt;
            margin-bottom: 20pt;
}

th.issue-toc-head { border-bottom-color: black;
                    border-bottom-style: solid;
                    border-bottom-width: 1pt;
}

      
table.small    { font-size: x-small; }

a.judgment:visited, a.judgment:link { font-family: sans-serif;
                                      color: black; 
                                      text-decoration: none }
a.processing:visited, a.processing:link { color: black; 
                                          text-decoration: none }
a.env:visited, a.env:link { color: black; 
                            text-decoration: none }
/*]]>*/
</style>
<link rel="stylesheet" type="text/css" href=
"http://www.w3.org/StyleSheets/TR/W3C-WD.css" />
</head>
<body>
<div class="head">
<p><a href="http://www.w3.org/"><img src=
"http://www.w3.org/Icons/w3c_home" alt="W3C" height="48" width=
"72" /></a></p>
<h1><a name="title" id="title"></a>XQuery and XPath Formal
Semantics 1.1</h1>
<h2><a name="w3c-doctype" id="w3c-doctype"></a>W3C Working Draft 31
December 2008</h2>
<dl>
<dt>This version:</dt>
<dd><a href=
"http://www.w3.org/TR/2008/WD-xpath-semantics-11-20081231/">http://www.w3.org/TR/2008/WD-xpath-semantics-11-20081231/</a></dd>
<dt>Latest version:</dt>
<dd><a href=
"http://www.w3.org/TR/xpath-semantics-11/">http://www.w3.org/TR/xpath-semantics-11/</a></dd>
<dt>Previous version:</dt>
<dd><a href=
"http://www.w3.org/TR/2007/REC-xquery-semantics-20070123/">http://www.w3.org/TR/2007/REC-xquery-semantics-20070123/</a></dd>
<dt>Editor:</dt>
<dd>Michael Dyck (XML Query WG), (self) <a href=
"mailto:jmdyck@ibiblio.org">&lt;jmdyck@ibiblio.org&gt;</a></dd>
</dl>
<p>See also <a href=
"http://www.w3.org/2003/03/Translations/byTechnology?technology=xpath-semantics">
<strong>translations</strong></a>.</p>
<p>This document is also available in these non-normative formats:
<a href=
"http://www.w3.org/TR/2008/WD-xpath-semantics-11-20081231/xpath-semantics-11.xml">
XML</a>.</p>
<p class="copyright"><a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>&#160;©&#160;2008&#160;<a href="http://www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>®</sup>
(<a href="http://www.csail.mit.edu/"><acronym title=
"Massachusetts Institute of Technology">MIT</acronym></a>, <a href=
"http://www.ercim.eu/"><acronym title=
"European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>,
<a href="http://www.keio.ac.jp/">Keio</a>), All Rights Reserved.
W3C <a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
<a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a>
and <a href=
"http://www.w3.org/Consortium/Legal/copyright-documents">document
use</a> rules apply.</p>
</div>
<hr />
<div>
<h2><a name="abstract" id="abstract"></a>Abstract</h2>
<p>This document defines formally the semantics of <span class=
"xquery">XQuery 1.1 <a href="#xquery-11">[XQuery 1.1: An XML Query
Language]</a></span> <span class="shared">and</span> <span class=
"xpath">XPath 2.1 <a href="#xpath-21">[XML Path Language (XPath)
2.1]</a></span>.</p>
</div>
<div>
<h2><a name="status" id="status"></a>Status of this Document</h2>
<p><em>This section describes the status of this document at the
time of its publication. Other documents may supersede this
document. A list of current W3C publications and the latest
revision of this technical report can be found in the <a href=
"http://www.w3.org/TR/">W3C technical reports index</a> at
http://www.w3.org/TR/.</em></p>
<p>This is one document in a set of seven documents that are being
progressed to Recommendation together (XQuery 1.1, XQueryX 1.1,
XSLT 2.1, Data Model 1.1, Functions and Operators 1.1,
Serialization 1.1, XPath 2.1).</p>
<p>This is a <a href=
"http://www.w3.org/2005/10/Process-20051014/tr.html#first-wd">First
Public Working Draft</a> as described in the <a href=
"http://www.w3.org/2005/10/Process-20051014/tr.html">Process
Document</a>. It has been developed by the W3C <a href=
"http://www.w3.org/XML/Query/">XML Query Working Group</a>, which
is part of the <a href="http://www.w3.org/XML/Activity">XML
Activity</a>. The Working Groups expect to advance this
specification to <a href=
"http://www.w3.org/2005/10/Process-20051014/tr.html#RecsW3C">Recommendation</a>
Status.</p>
<p>This is the first public Working Draft of XQuery and XPath
Formal Semantics 1.1 (XDM). It is intended to be fully 'upwards
compatible' with <a href=
"http://www.w3.org/TR/xpath-datamodel">XQuery 1.0 and Xpath 2.0
Data Model (XDM)</a>. Failures to achieve that goal will be
corrected in future versions of the Working Drafts of this
document.</p>
<p>No implementation report currently exists. However, a Test Suite
for [XPath/XQuery] is under development.</p>
<p>This document incorporates changes made against the final
Recommendation of <a href=
"http://www.w3.org/TR/xquery-semantics">XQuery 1.0 and XPath 2.0
Formal Semantics</a> dated 23 January 2007. Changes to this
document since the publication of the Recommendation are detailed
in <a href="#id-fs-revisions-log"><b>[G Revision Log]</b></a>.</p>
<p>Please report errors in this document using W3C's <a href=
"http://www.w3.org/Bugs/Public/">public Bugzilla system</a>
(instructions can be found at <a href=
"http://www.w3.org/XML/2005/04/qt-bugzilla">http://www.w3.org/XML/2005/04/qt-bugzilla</a>).
If access to that system is not feasible, you may send your
comments to the W3C XSLT/XPath/XQuery public comments mailing list,
<a href=
"mailto:public-qt-comments@w3.org">public-qt-comments@w3.org</a>.
It will be very helpful if you include the string “[FS11]” in the
subject line of your report, whether made in Bugzilla or in email.
Please use multiple Bugzilla entries (or, if necessary, multiple
email messages) if you have more than one comment to make. Archives
of the comments and responses are available at <a href=
"http://lists.w3.org/Archives/Public/public-qt-comments/">http://lists.w3.org/Archives/Public/public-qt-comments/</a>.</p>
<p>Publication as a Working Draft does not imply endorsement by the
W3C Membership. This is a draft document and may be updated,
replaced or obsoleted by other documents at any time. It is
inappropriate to cite this document as other than work in
progress.</p>
<p>This document was produced by groups operating under the
<a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5
February 2004 W3C Patent Policy</a>. W3C maintains a <a href=
"http://www.w3.org/2004/01/pp-impl/18797/status#disclosures">public
list of any patent disclosures</a> made in connection with the
deliverables of the XML Query Working Group and also maintains a
<a href=
"http://www.w3.org/2004/01/pp-impl/19552/status#disclosures">public
list of any patent disclosures</a> made in connection with the
deliverables of the XSL Working Group; those pages also include
instructions for disclosing a patent. An individual who has actual
knowledge of a patent which the individual believes contains
<a href=
"http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">
Essential Claim(s)</a> must disclose the information in accordance
with <a href=
"http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">
section 6 of the W3C Patent Policy</a>.</p>
</div>
<div class="toc">
<h2><a name="contents" id="contents"></a>Table of Contents</h2>
<p class="toc">1 <a href="#introduction">Introduction</a><br />
&#160;&#160;&#160;&#160;1.1 <a href="#id-normativity">Normative and
Informative Sections</a><br />
2 <a href="#sec_preliminaries">Preliminaries</a><br />
&#160;&#160;&#160;&#160;2.1 <a href="#sec_intro">Introduction to
the Formal Semantics</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.1.1 <a href=
"#sec_grammar_notations">Notations from grammar
productions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.1.2 <a href=
"#sec_judgments">Notations for judgments</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.1.3 <a href=
"#sec_environments">Notations for environments</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.1.4 <a href=
"#sec_inference">Notations for inference rules</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.1.5 <a href=
"#sec_together">Putting it together</a><br />
&#160;&#160;&#160;&#160;2.2 <a href="#sec_namespaces">URIs,
Namespaces, and Prefixes</a><br />
&#160;&#160;&#160;&#160;2.3 <a href="#sec_values">XML
Values</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3.1 <a href=
"#sec_data_model_overview">Formal values</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3.2 <a href=
"#sec_example_values">Examples of values</a><br />
&#160;&#160;&#160;&#160;2.4 <a href="#sec_types">The [XPath/XQuery]
Type System</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.1 <a href=
"#sec_schema">XML Schema and the [XPath/XQuery] Type
System</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.2 <a href=
"#sec_item_types">Item types</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.3 <a href=
"#sec_content_models">Content models</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.4 <a href=
"#sec_top_level_definitions">Top level definitions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.5 <a href=
"#sec_types_example">Example of a complete Schema</a><br />
&#160;&#160;&#160;&#160;2.5 <a href="#sec_fando">Functions and
operators</a><br />
3 <a href="#id-basics">Basics</a><br />
&#160;&#160;&#160;&#160;3.1 <a href="#sec_context">Expression
Context</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.1 <a href=
"#static_context">Static Context</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.1.1
<a href="#id-expanded-qnames">Resolving QNames to Expanded
QNames</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.2 <a href=
"#eval_context">Dynamic Context</a><br />
&#160;&#160;&#160;&#160;3.2 <a href=
"#id-processing-model">Processing Model</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.1 <a href=
"#id-fs-processing-model">Processing model</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.2 <a href=
"#sec_normalization">Normalization mapping rules</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.3 <a href=
"#sec_static">Static typing judgment</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.4 <a href=
"#sec_evaluation">Dynamic evaluation judgment</a><br />
&#160;&#160;&#160;&#160;3.3 <a href="#sec_errors">Error
Handling</a><br />
&#160;&#160;&#160;&#160;3.4 <a href=
"#id-important-concepts">Concepts</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.4.1 <a href=
"#id-doc-order">Document Order</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.4.2 <a href=
"#id-atomization">Atomization</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.4.3 <a href=
"#id-ebv">Effective Boolean Value</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.4.4 <a href=
"#id-input-sources">Input Sources</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.4.5 <a href=
"#id-uri-literals">URI Literals</a><br />
&#160;&#160;&#160;&#160;3.5 <a href=
"#id-type-conversion">Types</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.5.1 <a href=
"#id-predefined-types">Predefined Schema Types</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.5.2 <a href=
"#id-typed-value">Typed Value and String Value</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.5.3 <a href=
"#id-sequencetype">SequenceType Syntax</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.5.4 <a href=
"#id-sequencetype-matching">SequenceType Matching</a><br />
&#160;&#160;&#160;&#160;3.6 <a href="#comments">Comments</a><br />
&#160;&#160;&#160;&#160;3.7 <a href="#xml-terminals">XML-defined
Terminals</a><br />
4 <a href="#id-expressions">Expressions</a><br />
&#160;&#160;&#160;&#160;4.1 <a href=
"#id-primary-expressions">Primary Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.1.1 <a href=
"#id-literals">Literals</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.1.2 <a href=
"#id-variables">Variable References</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.1.3 <a href=
"#id-paren-expressions">Parenthesized Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.1.4 <a href=
"#id-context-item-expression">Context Item Expression</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.1.5 <a href=
"#id-function-calls">Function Calls</a><br />
&#160;&#160;&#160;&#160;4.2 <a href="#id-path-expressions">Path
Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.2.1 <a href=
"#id-axis-steps">Steps</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.2.1.1
<a href="#sec_axes">Axes</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.2.1.2
<a href="#node-tests">Node Tests</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.2.2 <a href=
"#id-predicates">Predicates</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.2.3 <a href=
"#unabbrev">Unabbreviated Syntax</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.2.4 <a href=
"#abbrev">Abbreviated Syntax</a><br />
&#160;&#160;&#160;&#160;4.3 <a href=
"#id-sequence-expressions">Sequence Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.3.1 <a href=
"#sec_constructing_sequences">Constructing Sequences</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.3.2 <a href=
"#sec_filter_exprs">Filter Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.3.3 <a href=
"#sec_combining_sequences">Combining Node Sequences</a><br />
&#160;&#160;&#160;&#160;4.4 <a href="#sec_arithmetic">Arithmetic
Expressions</a><br />
&#160;&#160;&#160;&#160;4.5 <a href="#sec_comparisons">Comparison
Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.5.1 <a href=
"#sec_value_comparisons">Value Comparisons</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.5.2 <a href=
"#sec_general_comparisons">General Comparisons</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.5.3 <a href=
"#sec_node-comparisons">Node Comparisons</a><br />
&#160;&#160;&#160;&#160;4.6 <a href=
"#id-logical-expressions">Logical Expressions</a><br />
&#160;&#160;&#160;&#160;4.7 <a href=
"#sec_constructors">Constructors</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.7.1 <a href=
"#id_element_constructor">Direct Element Constructors</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.7.1.1
<a href="#sec_direct_attributes">Attributes</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.7.1.2
<a href="#sec_namespace_attrs">Namespace Declaration
Attributes</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.7.1.3
<a href="#sec_content">Content</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.7.1.4
<a href="#sec_whitespace">Boundary Whitespace</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.7.2 <a href=
"#sec_other_constructors">Other Direct Constructors</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.7.3 <a href=
"#sec_computedConstructors">Computed Constructors</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.7.3.1
<a href="#sec_comp_elem_constructor">Computed Element
Constructors</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.7.3.2
<a href="#sec_attribute_constructor">Computed Attribute
Constructors</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.7.3.3
<a href="#sec_documentConstructors">Document Node
Constructors</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.7.3.4
<a href="#sec_textConstructors">Text Node Constructors</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.7.3.5
<a href="#sec_computed-pis">Computed Processing Instruction
Constructors</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.7.3.6
<a href="#sec_computed-comments">Computed Comment
Constructors</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.7.4 <a href=
"#id-ns-nodes-on-elements">In-scope Namespaces of a Constructed
Element</a><br />
&#160;&#160;&#160;&#160;4.8 <a href=
"#sec_for-expressions">[For/FLWOR] Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.8.1 <a href=
"#sec_flwor-expressions">FLWOR expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.8.2 <a href=
"#id-for-expression">For expression</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.8.3 <a href=
"#sec_lets">Let Expression</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.8.4 <a href=
"#id_orderby_clause">Order By and Return Clauses</a><br />
&#160;&#160;&#160;&#160;4.9 <a href=
"#sec_unordered-expressions">Ordered and Unordered
Expressions</a><br />
&#160;&#160;&#160;&#160;4.10 <a href=
"#sec_conditionals">Conditional Expressions</a><br />
&#160;&#160;&#160;&#160;4.11 <a href=
"#id-quantified-expressions">Quantified Expressions</a><br />
&#160;&#160;&#160;&#160;4.12 <a href=
"#sec_sequencetype-matching">Expressions on SequenceTypes</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.12.1 <a href=
"#sec_instance-of">Instance Of</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.12.2 <a href=
"#sec_typeswitch">Typeswitch</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.12.3 <a href=
"#sec_cast">Cast</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.12.4 <a href=
"#sec_castable">Castable</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.12.5 <a href=
"#sec_constructor-functions">Constructor Functions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.12.6 <a href=
"#sec_treat">Treat</a><br />
&#160;&#160;&#160;&#160;4.13 <a href="#sec_validate_expr">Validate
Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.13.1 <a href=
"#sec_validating_element">Validating an Element Node</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.13.2 <a href=
"#sec_validating_document">Validating a Document Node</a><br />
&#160;&#160;&#160;&#160;4.14 <a href=
"#id-extension-expressions">Extension Expressions</a><br />
5 <a href="#id-query-prolog">Modules and Prologs</a><br />
&#160;&#160;&#160;&#160;5.1 <a href=
"#sec_version-declaration">Version Declaration</a><br />
&#160;&#160;&#160;&#160;5.2 <a href="#id-module-declaration">Module
Declaration</a><br />
&#160;&#160;&#160;&#160;5.3 <a href=
"#sec_boundary-space-decls">Boundary-space Declaration</a><br />
&#160;&#160;&#160;&#160;5.4 <a href=
"#sec_default-collation-declaration">Default Collation
Declaration</a><br />
&#160;&#160;&#160;&#160;5.5 <a href="#sec_base-uri-decl">Base URI
Declaration</a><br />
&#160;&#160;&#160;&#160;5.6 <a href=
"#sec_validation_decl">Construction Declaration</a><br />
&#160;&#160;&#160;&#160;5.7 <a href=
"#id-default-ordering-decl">Ordering Mode Declaration</a><br />
&#160;&#160;&#160;&#160;5.8 <a href="#id-empty-order-decl">Empty
Order Declaration</a><br />
&#160;&#160;&#160;&#160;5.9 <a href=
"#id-copy-namespaces-decl">Copy-Namespaces Declaration</a><br />
&#160;&#160;&#160;&#160;5.10 <a href="#sec_schema_imports">Schema
Import</a><br />
&#160;&#160;&#160;&#160;5.11 <a href="#id-module-imports">Module
Import</a><br />
&#160;&#160;&#160;&#160;5.12 <a href=
"#sec_namespace_decls">Namespace Declaration</a><br />
&#160;&#160;&#160;&#160;5.13 <a href=
"#sec_default_namespace_decls">Default Namespace
Declaration</a><br />
&#160;&#160;&#160;&#160;5.14 <a href=
"#sec_variable-declarations">Variable Declaration</a><br />
&#160;&#160;&#160;&#160;5.15 <a href="#sec_FunctionDeclns">Function
Declaration</a><br />
&#160;&#160;&#160;&#160;5.16 <a href=
"#id-option-declaration">Option Declaration</a><br />
6 <a href="#id-xquery-conformance">Conformance</a><br />
&#160;&#160;&#160;&#160;6.1 <a href=
"#id-static-typing-feature">Static Typing Feature</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;6.1.1 <a href=
"#id-static-extensions">Static Typing Extensions</a><br />
7 <a href="#sec_special_functions">Additional Semantics of
Functions</a><br />
&#160;&#160;&#160;&#160;7.1 <a href=
"#sec_special_fs_functions">Formal Semantics Functions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7.1.1 <a href=
"#sec_convert_operand">The fs:convert-operand function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7.1.2 <a href=
"#sec_convert_simple_operand">The fs:convert-simple-operand
function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7.1.3 <a href=
"#sec_distinct_docorder">The fs:distinct-doc-order
function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7.1.4 <a href=
"#sec_distinct_docorder_or_atomic_sequence">The
fs:distinct-doc-order-or-atomic-sequence function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7.1.5 <a href=
"#sec_items_to_nodes">The fs:item-sequence-to-node-sequence
function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7.1.6 <a href=
"#sec_items_to_nodes_doc">The fs:item-sequence-to-node-sequence-doc
function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7.1.7 <a href=
"#sec_item_seq_to_string">The fs:item-sequence-to-untypedAtomic
fs:item-sequence-to-string function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7.1.8 <a href=
"#sec_item_seq_to_untypedAtomic_PI">The
fs:item-sequence-to-untypedAtomic-PI function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7.1.9 <a href=
"#sec_item_seq_to_untypedAtomic_text">The
fs:item-sequence-to-untypedAtomic-text function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7.1.10 <a href=
"#sec_item_seq_to_untypedAtomic_comment">The
fs:item-sequence-to-untypedAtomic-comment function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7.1.11 <a href=
"#sec_apply_ordering_mode">The fs:apply-ordering-mode
function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7.1.12 <a href=
"#sec_fs_to">The fs:to function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7.1.13 <a href=
"#sec_node_sequence">The fs:node-sequence function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7.1.14 <a href=
"#sec_item_at">The fs:item-at function</a><br />
&#160;&#160;&#160;&#160;7.2 <a href="#function_rules">Standard
functions with specific static typing rules</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7.2.1 <a href=
"#sec_fn_last">The fn:last context function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7.2.2 <a href=
"#sec_fn_position">The fn:position context function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7.2.3 <a href=
"#sec_fn_abs_ceil_floor_round">The fn:abs, fn:ceiling, fn:floor,
fn:round, and fn:round-half-to-even functions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7.2.4 <a href=
"#sec_fn_boolean">The fn:boolean and fn:not functions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7.2.5 <a href=
"#sec_fn_doc_collection">The fn:collection and fn:doc
functions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7.2.6 <a href=
"#sec_fn_data">The fn:data function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7.2.7 <a href=
"#sec_fn_distinct_node_vals">The fn:distinct-values
function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7.2.8 <a href=
"#sec_fn_unordered">The fn:unordered function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7.2.9 <a href=
"#sec_fnerror">The fn:error function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7.2.10 <a href=
"#sec_fn_aggregates">The fn:min, fn:max, fn:avg, and fn:sum
functions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7.2.11 <a href=
"#sec_fn_remove">The fn:remove function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7.2.12 <a href=
"#sec_fn_reverse">The fn:reverse function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7.2.13 <a href=
"#sec_fn_subsequence">The fn:subsequence function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7.2.14 <a href=
"#sec_op_union_intersect_except">The op:union, op:intersect, and
op:except operators</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7.2.15 <a href=
"#sec_fn_insert_before">The fn:insert-before function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7.2.16 <a href=
"#sec_fn_cardinality_funcs">The fn:zero-or-one, fn:one-or-more, and
fn:exactly-one functions</a><br />
8 <a href="#sec_auxiliary_judgments">Auxiliary Judgments</a><br />
&#160;&#160;&#160;&#160;8.1 <a href=
"#sec_accessing_types">Judgments for accessing types</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.1.1 <a href=
"#jd_aux_derives_from">Derives from</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.1.2 <a href=
"#sec_substitutes">Substitutes for</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.1.3 <a href=
"#sec_element_lookup">Element and attribute name lookup
(Dynamic)</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.1.4 <a href=
"#jd_aux_static_lookup">Element and attribute type lookup
(Static)</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.1.5 <a href=
"#sec_extension">Extension</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.1.6 <a href=
"#sec_mixed">Mixed content</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.1.7 <a href=
"#sec_adjustment">Type adjustment</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.1.8 <a href=
"#sec_built_in_attributes">Builtin attributes</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.1.9 <a href=
"#sec_type_expansion">Type expansion</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.1.10 <a href=
"#sec_union_interpretation">Union interpretation of derived
types</a><br />
&#160;&#160;&#160;&#160;8.2 <a href=
"#sec_auxiliary_xpath">Judgments for step expressions and
filtering</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.2.1 <a href=
"#sec_jd_principal">Principal Node Kind</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.2.2 <a href=
"#sec_axis_judge">Auxiliary judgments for axes</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.2.2.1
<a href="#sec_static_axis_judge">Static semantics of axes</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.2.2.1.1
<a href="#sec_inference_axis">Inference rules for all
axes</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.2.2.1.2
<a href="#sec_inference_self">Inference rules for the self
axis</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.2.2.1.3
<a href="#sec_inference_child">Inference rules for the child
axis</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.2.2.1.4
<a href="#sec_inference_attribute">Inference rules for the
attribute axis</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.2.2.1.5
<a href="#sec_inference_parent">Inference rules for the parent
axis</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.2.2.1.6
<a href="#sec_inference_namespace">Inference rules for the
namespace axis</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.2.2.1.7
<a href="#sec_inference_descendant">Inference rules for the
descendant axis</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.2.2.1.8
<a href="#sec_inference_descendant_of_self">Inference rules for the
descendant-or-self axis</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.2.2.1.9
<a href="#sec_inference_ancestor">Inference rules for the ancestor
axis</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.2.2.1.10
<a href="#sec_inference_ancestor_of_self">Inference rules for the
ancestor-or-self axis</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.2.2.2
<a href="#sec_dyn_axes">Dynamic semantics of axes</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.2.3 <a href=
"#sec_test_judge">Auxiliary judgments for node tests</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.2.3.1
<a href="#sec_sem_node_tests">Static semantics of node
tests</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.2.3.1.1
<a href="#sec_sem_name_tests">Name Tests</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.2.3.1.2
<a href="#sec_sem_kind_tests">Kind Tests</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.2.3.2
<a href="#sec_dyn_node_tests">Dynamic semantics of node
tests</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.2.3.2.1
<a href="#sec_dyn_sem_name_tests">Name Tests</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.2.3.2.2
<a href="#sec_dyn_kind_tests">Kind Tests</a><br />
&#160;&#160;&#160;&#160;8.3 <a href="#sec_type_matching">Judgments
for type matching</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.3.1 <a href=
"#sec_matches">Matches</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.3.2 <a href=
"#sec_subtyping">Subtyping (&lt;:)</a><br />
&#160;&#160;&#160;&#160;8.4 <a href="#sec_factor">Judgments for
FLWOR and other expressions on sequences</a><br />
&#160;&#160;&#160;&#160;8.5 <a href=
"#sec_promotion_judgments">Judgments for function calls</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.5.1 <a href=
"#sec_promotion">Type promotion</a><br />
&#160;&#160;&#160;&#160;8.6 <a href=
"#sec_validation_mode">Judgments for validation modes and
contexts</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.6.1 <a href=
"#jd_aux_context_is">Elements in validation mode</a><br /></p>
<h3><a name="appendices" id="appendices"></a>Appendices</h3>
<p class="toc">A <a href="#sec_core">Normalized core and formal
grammars</a><br />
&#160;&#160;&#160;&#160;A.1 <a href="#sec_core_grammar">Core
BNF</a><br />
&#160;&#160;&#160;&#160;A.2 <a href="#sec_formal_grammar">Formal
BNF</a><br />
B <a href="#sec_indexes">Index of judgments</a><br />
C <a href="#sec_functions_and_operators">Functions and
Operators</a><br />
&#160;&#160;&#160;&#160;C.1 <a href="#sec_used_functions">Functions
and Operators used in the Formal Semantics</a><br />
&#160;&#160;&#160;&#160;C.2 <a href="#sec_operators">Mapping of
Overloaded Internal Functions</a><br />
D <a href="#sec_importing_schema">Importing Schemas</a><br />
&#160;&#160;&#160;&#160;D.1 <a href=
"#sec_import_intro">Introduction</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;D.1.1 <a href=
"#sec_import_features">Features</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;D.1.2 <a href=
"#sec_import_organization">Organization</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;D.1.3 <a href=
"#sec_import_mapping">Main mapping rules</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;D.1.4 <a href=
"#sec_use">Special attributes</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;D.1.4.1
<a href="#sec_import_attributes">use, default, and fixed</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;D.1.4.2
<a href="#prod-formal-OccursAttributes">minOccurs, maxOccurs,
minLength, maxLength, and length</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;D.1.4.3
<a href="#sec_import_mixed">mixed</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;D.1.4.4
<a href="#sec_import_nillable">nillable</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;D.1.4.5
<a href="#sec_import_substitution">substitutionGroup</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;D.1.5 <a href=
"#sec_import_anonymous">Anonymous type names</a><br />
&#160;&#160;&#160;&#160;D.2 <a href=
"#sec_schema_as_a_whole">Schemas as a whole</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;D.2.1 <a href=
"#sec_import_whole">Schema</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;D.2.2 <a href=
"#sec_import_include">Include</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;D.2.3 <a href=
"#sec_import_redefine">Redefine</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;D.2.4 <a href=
"#sec_import_import">Import</a><br />
&#160;&#160;&#160;&#160;D.3 <a href=
"#sec_import_attribute_decl">Attribute Declarations</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;D.3.1 <a href=
"#sec_import_global_attributes">Global attributes
declarations</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;D.3.2 <a href=
"#sec_import_local_attributes">Local attribute
declarations</a><br />
&#160;&#160;&#160;&#160;D.4 <a href="#sec_import_element">Element
Declarations</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;D.4.1 <a href=
"#sec_import_global_element">Global element declarations</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;D.4.2 <a href=
"#sec_import_local_element">Local element declarations</a><br />
&#160;&#160;&#160;&#160;D.5 <a href="#sec_complex_type">Complex
Type Definitions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;D.5.1 <a href=
"#sec_import_global_complex_type">Global complex type</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;D.5.2 <a href=
"#sec_import_local_complex_type">Local complex type</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;D.5.3 <a href=
"#sec_import_ct_simple">Complex type with simple content</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;D.5.4 <a href=
"#sec_import_ct_complex">Complex type with complex
content</a><br />
&#160;&#160;&#160;&#160;D.6 <a href="#sec_attribute_use">Attribute
Uses</a><br />
&#160;&#160;&#160;&#160;D.7 <a href=
"#sec_attribute_group">Attribute Group Definitions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;D.7.1 <a href=
"#sec_attribute_group_def">Attribute group definitions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;D.7.2 <a href=
"#sec_import_attribute_group_ref">Attribute group
reference</a><br />
&#160;&#160;&#160;&#160;D.8 <a href="#sec_import_model">Model Group
Definitions</a><br />
&#160;&#160;&#160;&#160;D.9 <a href=
"#sec_import_model_groups">Model Groups</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;D.9.1 <a href=
"#sec_import_all_groups">All groups</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;D.9.2 <a href=
"#sec_import_choice_groups">Choice groups</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;D.9.3 <a href=
"#sec_import_sequence_groups">Sequence groups</a><br />
&#160;&#160;&#160;&#160;D.10 <a href=
"#sec_import_particles">Particles</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;D.10.1 <a href=
"#sec_import_element_ref">Element reference</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;D.10.2 <a href=
"#sec_group_ref">Group reference</a><br />
&#160;&#160;&#160;&#160;D.11 <a href=
"#sec_import_wildcards">Wildcards</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;D.11.1 <a href=
"#sec_import_attribute_wildcards">Attribute wildcards</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;D.11.2 <a href=
"#sec_import_element_wildcards">Element wildcards</a><br />
&#160;&#160;&#160;&#160;D.12 <a href=
"#sec_import_identity">Identity-constraint Definitions</a><br />
&#160;&#160;&#160;&#160;D.13 <a href=
"#sec_import_notation">Notation Declarations</a><br />
&#160;&#160;&#160;&#160;D.14 <a href=
"#sec_import_annotation">Annotation</a><br />
&#160;&#160;&#160;&#160;D.15 <a href=
"#sec_import_simple_type">Simple Type Definitions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;D.15.1 <a href=
"#sec_import_global_simple_type">Global simple type
definition</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;D.15.2 <a href=
"#sec_import_local_simple_type">Local simple type
definition</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;D.15.3 <a href=
"#sec_import_simple_type_content">Simple type content</a><br />
E <a href="#appendix_references">References</a><br />
&#160;&#160;&#160;&#160;E.1 <a href=
"#id-normative-references">Normative References</a><br />
&#160;&#160;&#160;&#160;E.2 <a href=
"#id-non-normative-references">Non-normative References</a><br />
&#160;&#160;&#160;&#160;E.3 <a href=
"#id-background-references">Background References</a><br />
F <a href="#sec_validation_judgments">Auxiliary Judgments for
Validation</a> (Non-Normative)<br />
&#160;&#160;&#160;&#160;F.1 <a href="#sec_validate">Judgments for
the validate expression</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;F.1.1 <a href=
"#sec_type_resolution">Type resolution</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;F.1.2 <a href=
"#sec_interleaving">Interleaving</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;F.1.3 <a href=
"#sec_jd_filter">Attribute filtering</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;F.1.4 <a href=
"#sec_erasure">Erasure</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;F.1.4.1
<a href="#sec_simply_erases">Simply erases</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;F.1.4.2
<a href="#sec_erases">Erases</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;F.1.5 <a href=
"#sec_jd_annotate">Annotate</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;F.1.5.1
<a href="#sec_simply_annotate">Simply annotate</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;F.1.5.2
<a href="#sec_nil_annotate">Nil-annotate</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;F.1.5.3
<a href="#sec_annotate">Annotate</a><br />
G <a href="#id-fs-revisions-log">Revision Log</a>
(Non-Normative)<br /></p>
</div>
<hr />
<div class="body">
<div class="div1">
<h2><a name="introduction" id="introduction"></a>1
Introduction</h2>
<p>This document defines the formal semantics of XQuery 1.1 and
XPath 2.1. The present document is part of a set of documents that
together define the XQuery 1.1 and XPath 2.1 languages:</p>
<ul>
<li>
<p><a href="#xquery-11">[XQuery 1.1: An XML Query Language]</a>
introduces the XQuery 1.1 language, defines its capabilities from a
user-centric view, and defines the language syntax.</p>
</li>
<li>
<p><a href="#xpath-21">[XML Path Language (XPath) 2.1]</a>
introduces the XPath 2.1 language, defines its capabilities from a
user-centric view, and defines the language syntax.</p>
</li>
<li>
<p><a href="#xpath-functions-11">[Functions and Operators 1.1]</a>
lists the functions and operators defined for the [XPath/XQuery]
language and specifies the required types of their parameters and
return value.</p>
</li>
<li>
<p><a href="#xpath-datamodel-11">[Data Model]</a> formally
specifies the data model used by [XPath/XQuery] to represent the
content of XML documents. The [XPath/XQuery] language is formally
defined by operations on this data model.</p>
</li>
<li>
<p><a href="#xslt-xquery-serialization-11">[Data Model
Serialization 1.1]</a> specifies how [XPath/XQuery] data model
values are serialized into XML.</p>
</li>
</ul>
<p>The scope and goals for the [XPath/XQuery] language are
discussed in the charter of the W3C [XSL/XML Query] Working Groups
and in the [XPath/XQuery] requirements <a href=
"#xpath-21-requirements">[XPath 2.1 Requirements]</a>.</p>
<p>This document defines the semantics of [XPath/XQuery] by giving
a precise formal meaning to each of the expressions of the
[XPath/XQuery] specification in terms of the [XPath/XQuery] data
model. This document assumes that the reader is already familiar
with the [XPath/XQuery] language. This document defines the formal
semantics for XPath 2.1 only when the XPath 1.0 backward
compatibility rules are not in effect.</p>
<p>Two important design aspects of [XPath/XQuery] are that it is
<em>functional</em> and that it is <em>typed</em>. These two
aspects play an important role in the [XPath/XQuery] Formal
Semantics.</p>
<p><b>[XPath/XQuery] is a functional language</b>. [XPath/XQuery]
is built from expressions, rather than statements. Every construct
in the language (except for the XQuery query prolog) is an
expression and expressions can be composed arbitrarily. The result
of one expression can be used as the input to any other expression,
as long as the type of the result of the former expression is
compatible with the input type of the latter expression with which
it is composed. Another characteristic of a functional language is
that variables are always passed by value, and a variable's value
cannot be modified through side effects.</p>
<p><b>[XPath/XQuery] is a typed language</b>. Types can be imported
from one or more XML Schemas that describe the input documents and
the output document, and the [XPath/XQuery] language can then
perform operations based on these types. In addition,
[XPath/XQuery] supports <em>static type analysis</em>. Static type
analysis infers the output type of an expression based on the type
of its input expressions. In addition to inferring the type of an
expression for the user, static typing allows early detection of
type errors, and can be used as the basis for certain classes of
optimization. The [XPath/XQuery] type system captures most of the
features of <a href="#xmlschema-1">[Schema Part 1]</a>, including
global and local element and attribute declarations, complex and
simple type definitions, named and anonymous types, derivation by
restriction, extension, list and union, substitution groups, and
wildcard types. It does not model uniqueness constraints and facet
constraints on simple types.</p>
<p>This document is organized as follows. <a href=
"#sec_preliminaries"><b>[2 Preliminaries]</b></a> introduces the
notations used to define the [XPath/XQuery] Formal Semantics. These
include the formal notations for values in the [XPath/XQuery] data
model and for types in XML Schema. The next three sections:
<a href="#id-basics"><b>[3 Basics]</b></a>, <a href=
"#id-expressions"><b>[4 Expressions]</b></a>, and <a href=
"#id-query-prolog"><b>[5 Modules and Prologs]</b></a> have the same
structure as the corresponding sections in the <a href=
"#xquery-11">[XQuery 1.1: An XML Query Language]</a> and <a href=
"#xpath-21">[XML Path Language (XPath) 2.1]</a> documents. This
allows the reader to quickly find the formal definition of a
particular language construct. <a href="#id-basics"><b>[3
Basics]</b></a> defines the semantics for basic [XPath/XQuery]
concepts, and <a href="#id-expressions"><b>[4 Expressions]</b></a>
defines the dynamic and static semantics of each [XPath/XQuery]
expression. <a href="#id-query-prolog"><b>[5 Modules and
Prologs]</b></a> defines the semantics of the [XPath/XQuery]
prolog. <a href="#sec_special_functions"><b>[7 Additional Semantics
of Functions]</b></a> defines the static semantics of several
functions in <a href="#xpath-functions-11">[Functions and Operators
1.1]</a> and gives the dynamic and static semantics of several
supporting functions used in this document. The remaining sections,
<a href="#sec_auxiliary_judgments"><b>[8 Auxiliary
Judgments]</b></a> and <a href="#sec_importing_schema"><b>[D
Importing Schemas]</b></a>, contain material that supports the
formal semantics of [XPath/XQuery]. <a href=
"#sec_auxiliary_judgments"><b>[8 Auxiliary Judgments]</b></a>
defines formal judgments that relate data model values to types,
that relate types to types, and that support the formal definition
of validation. These judgments are used in the definition of
expressions in <a href="#id-expressions"><b>[4
Expressions]</b></a>. Lastly, <a href="#sec_importing_schema"><b>[D
Importing Schemas]</b></a>, specifies how XML Schema documents are
imported into the [XPath/XQuery] type system and relates XML Schema
types to the [XPath/XQuery] type system.</p>
<div class="div2">
<h3><a name="id-normativity" id="id-normativity"></a>1.1 Normative
and Informative Sections</h3>
<p>Certain aspects of language processing are described in this
specification as <b>implementation-defined</b> or
<b>implementation-dependent</b>.</p>
<ul>
<li>
<p>[<a name="dt-implementation-defined" id=
"dt-implementation-defined" title=
"implementation defined">Definition</a>:
<b>Implementation-defined</b> indicates an aspect that may differ
between implementations, but must be specified by the implementor
for each particular implementation.]</p>
</li>
<li>
<p>[<a name="dt-implementation-dependent" id=
"dt-implementation-dependent" title=
"implementation dependent">Definition</a>:
<b>Implementation-dependent</b> indicates an aspect that may differ
between implementations, is not specified by this or any W3C
specification, and is not required to be specified by the
implementor for any particular implementation.]</p>
</li>
</ul>
<p class="xpath">A language aspect described in this specification
as <b>implementation-defined</b> or <b>implementation dependent</b>
may be further constrained by the specifications of a host language
in which XPath or XQuery is embedded.</p>
<p>This document contains the normative static semantics of
[XPath/XQuery]. The static semantics rules in <a href=
"#id-basics"><b>[3 Basics]</b></a>, <a href="#id-expressions"><b>[4
Expressions]</b></a>, <a href="#id-query-prolog"><b>[5 Modules and
Prologs]</b></a>, and <a href="#sec_special_functions"><b>[7
Additional Semantics of Functions]</b></a> are normative. <a href=
"#static_context"><b>[3.1.1 Static Context]</b></a> is normative,
because it defines the static context used in the static typing
rules. <a href="#sec_auxiliary_judgments"><b>[8 Auxiliary
Judgments]</b></a> is normative, because it contains all the
judgments necessary for defining SequenceType Matching.</p>
<p>The dynamic semantics of [XPath/XQuery] are normatively defined
in <a href="#xquery-11">[XQuery 1.1: An XML Query Language]</a> and
<a href="#xpath-21">[XML Path Language (XPath) 2.1]</a>. In this
document, the dynamic semantic rules in <a href="#id-basics"><b>[3
Basics]</b></a>, <a href="#id-expressions"><b>[4
Expressions]</b></a>, and <a href="#id-query-prolog"><b>[5 Modules
and Prologs]</b></a>, the examples, and the material labeled as
"Note" are provided for explanatory purposes and are not
normative.</p>
<p>The mapping rules from XML Schema to the XQuery type system
provided in <a href="#sec_importing_schema"><b>[D Importing
Schemas]</b></a>, and the formal semantics of XML Schema validation
in <a href="#sec_validation_judgments"><b>[F Auxiliary Judgments
for Validation]</b></a> are informative and do not handle every
feature of XML Schema.</p>
</div>
</div>
<div class="div1">
<h2><a name="sec_preliminaries" id="sec_preliminaries"></a>2
Preliminaries</h2>
<p>This section provides the background necessary to understand the
Formal Semantics, introduces the notations that are used, and
explains its relationship to other documents.</p>
<div class="div2">
<h3><a name="sec_intro" id="sec_intro"></a>2.1 Introduction to the
Formal Semantics</h3>
<p><b>Why a Formal Semantics?</b> The goal of the formal semantics
is to complement the [XPath/XQuery] specification (<a href=
"#xquery-11">[XQuery 1.1: An XML Query Language]</a> and <a href=
"#xpath-21">[XML Path Language (XPath) 2.1]</a>), by defining the
meaning of [XPath/XQuery] expressions with mathematical rigor.</p>
<p>A rigorous formal semantics clarifies the intended meaning of
the English specification, ensures that no corner cases are left
out, and provides a reference for implementation.</p>
<p><b>Why use formal notations?</b> Rigor is achieved by the use of
formal notations to represent [XPath/XQuery] objects such as
expressions, XML values, and XML Schema types, and by the
systematic definition of the relationships between those objects to
reflect the meaning of the language. In particular, the dynamic
semantics relates [XPath/XQuery] expressions to the XML value to
which they evaluate, and the static semantics relates
[XPath/XQuery] expressions to the XML Schema type that is inferred
for that expression.</p>
<p>The Formal Semantics uses several kinds of formal notations to
define the relationships between [XPath/XQuery] expressions, XML
values, and XML Schema types. This section introduces the notations
for judgments, inference rules, and mapping rules as well as the
notation for environments, which implement the dynamic and static
contexts. The reader already familiar with these notations can skip
this section and continue with <a href="#sec_values"><b>[2.3 XML
Values]</b></a>.</p>
<div class="div3">
<h4><a name="sec_grammar_notations" id=
"sec_grammar_notations"></a>2.1.1 Notations from grammar
productions</h4>
<p>Grammar productions are used to describe "objects" (values,
types, [XPath/XQuery] expressions, etc.) manipulated by the Formal
Semantics. The Formal Semantics makes use of several kinds of
grammar productions: productions from the [XPath/XQuery] grammar
itself, productions for a subset of the [XPath/XQuery] language
called the XQuery Core which is used throughout this document, and
other productions used for formal specification only such as for
the XQuery type system.</p>
<p>XQuery grammar productions describe the XQuery language and
expressions. XQuery productions are identified by a number, which
corresponds to their number in the <a href="#xquery-11">[XQuery
1.1: An XML Query Language]</a> document, and are marked with
"(XQuery)". For instance, the following production describes FLWOR
expressions in XQuery.</p>
<h5><a name="d6e495" id="d6e495"></a>[For/FLWOR] Expressions</h5>
<table class="scrap" summary="Scrap"></table>
<p>For the purpose of this document, the differences between the
XQuery 1.0 and the XPath 2.0 grammars are mostly irrelevant. By
default, this document uses XQuery 1.0 grammar productions.
Whenever the grammar for XPath 2.0 differs from the one for XQuery
1.0, the corresponding XPath 2.0 productions are also given. XPath
productions are identified by a number, which corresponds to their
number in <a href="#xpath-21">[XML Path Language (XPath) 2.1]</a>,
and are marked with "(XPath)". For instance, the following
production describes for expressions in XPath.</p>
<h5><a name="d6e505" id="d6e505"></a>[For/FLWOR] Expressions</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e595.doc-xpath20-ForExpr" id=
"noid_d3e595.doc-xpath20-ForExpr"></a>[<small>8&#160;(XPath)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xpath20/#prod-xpath-ForExpr">ForExpr</a><sup><small>XP</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath20-SimpleForClause">SimpleForClause</a> "return"
ExprSingle</code></td>
</tr>
</tbody>
</table>
<p>XQuery Core grammar productions describe the XQuery Core. The
Core grammar is given in <a href="#sec_core"><b>[A Normalized core
and formal grammars]</b></a>. Core productions are identified by a
number, which corresponds to their number in <a href=
"#sec_core"><b>[A Normalized core and formal grammars]</b></a>, and
are marked with "(Core)". For instance, the following production
describes the simpler form of the "FLWOR" expression in the XQuery
Core.</p>
<h5><a name="d6e529" id="d6e529"></a>Core FLWOR Expressions</h5>
<table class="scrap" summary="Scrap"></table>
<p>The Formal Semantics manipulates "objects" (values, types,
expressions, etc.) for which there is no existing grammar
production in the <a href="#xquery-11">[XQuery 1.1: An XML Query
Language]</a> document. In these cases, specific grammar
productions are introduced. Notably, additional productions are
used to describe values in the <a href="#xpath-datamodel-11">[Data
Model]</a>, and to describe the [XPath/XQuery] type system. Formal
Semantics productions are identified by a number, and are marked by
"(Formal)". For instance, the following production describes global
type definitions in the [XPath/XQuery] type system.</p>
<h5><a name="d6e544" id="d6e544"></a>Type Definitions</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e632.doc-fs-Definition" id=
"noid_d3e632.doc-fs-Definition"></a>[<small>39&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code>Definition</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("define" "element" <a href=
"#doc-fs-ElementName">ElementName</a> <a href=
"#doc-fs-OptSubstitution">OptSubstitution</a> <a href=
"#doc-fs-OptNillable">OptNillable</a> <a href=
"#doc-fs-TypeReference">TypeReference</a>)<br />
| ("define" "attribute" <a href=
"#doc-fs-AttributeName">AttributeName</a> <a href=
"#doc-fs-TypeReference">TypeReference</a>)<br />
| ("define" "type" <a href="#doc-fs-TypeName">TypeName</a> <a href=
"#doc-fs-TypeDerivation">TypeDerivation</a>)</code></td>
</tr>
</tbody>
</table>
<p>Note that grammar productions that are specific to the Formal
Semantics (i.e., marked with "(Formal)") are not part of
[XPath/XQuery]. They are not accessible to the user and are only
used in the course of defining the languages' semantics.</p>
<p>Grammar non-terminals are used extensively in this document to
represent objects in judgments (see the next section). As a
convenience, non-terminals used in judgments link to the
appropriate grammar production.</p>
</div>
<div class="div3">
<h4><a name="sec_judgments" id="sec_judgments"></a>2.1.2 Notations
for judgments</h4>
<p>The basic building block of the formal specification is called a
<em>judgment</em>. A judgment expresses whether a property holds or
not.</p>
<p>For example:</p>
<p><b>Notation</b></p>
<p>The judgment</p>
<div align="center"><em>Object</em> <b>is a positive
integer</b></div>
<p>holds if the object <em>Object</em> is a positive integer.</p>
<p>A judgment may hold (if it is true) or not hold (if it is
false). For instance '1 <b>is a positive integer</b>' holds and '-1
<b>is a positive integer</b>' does not hold.</p>
<p><b>Notation</b></p>
<p>Here are two other example judgments.</p>
<p>The judgment</p>
<div align="center"><em>Expr</em> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></div>
<p>holds if the expression <em>Expr</em> yields (or evaluates to)
the value <a href="#doc-fs-Value"><em>Value</em></a>.</p>
<p>The judgment</p>
<div align="center"><em>Expr</em> <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></div>
<p>holds if the expression <em>Expr</em> has the type <a href=
"#doc-fs-Type"><em>Type</em></a>.</p>
<p>Most other judgments used in this document are short English
sentences intended to reflect their meaning. For instance, the
judgment</p>
<div align="center"><em>Axis</em> <a href="#jd_principal" class=
"judgment"><b>has principal</b></a>
<em>PrincipalNodeKind</em></div>
<p>holds if <em>PrincipalNodeKind</em> is the principal node kind
for the axis <em>Axis</em>.</p>
<p>A judgment can contain <em>symbols</em> and
<em>patterns</em>.</p>
<p>Symbols are purely syntactic and are used to write the judgment
itself. Symbols are chosen to reflect a judgment's meaning, and are
written in bold fonts. For example, '<b>is a positive integer</b>',
'<b>=&gt;</b>' and '<b>:</b>' are symbols, the second and third of
which should be read "yields", and "has type" respectively.</p>
<p>Patterns are used to represent objects, constructed from a given
grammar production. In patterns, italicized words usually
correspond to non-terminals in the grammar. The name of those
non-terminals is significant, and may be instantiated only to an
"object" (a value, a type, an expression, etc.) that can be
substituted legally for that non-terminal. For example,
'<em>Expr</em>' is a pattern that stands for every [XPath/XQuery]
expressions, '<em>Expr</em><sub><font size="2">1</font></sub> +
<em>Expr</em><sub><font size="2">2</font></sub>' is a pattern that
stands for every addition expression, 'element a { <a href=
"#doc-fs-Value"><em>Value</em></a> }' is a pattern that stands for
every value in the [XPath/XQuery] data model that is an 'a'
element.</p>
<p>Non-terminals in a pattern may appear with subscripts (e.g.
<em>Expr</em><sub><font size="2">1</font></sub>,
<em>Expr</em><sub><font size="2">2</font></sub>) to distinguish
different instances of the same sort of pattern. In some cases,
non-terminals in a pattern may have a name that is not exactly the
name of that non terminal, but is based on it. For instance, a
<a href="#doc-fs-TypeName"><em>BaseTypeName</em></a> is a pattern
that stands for a type name, as would <a href=
"#doc-fs-TypeName"><em>TypeName</em></a>, or <a href=
"#doc-fs-TypeName"><em>TypeName</em></a><sub><font size=
"2">2</font></sub>. This usage is limited, and only occurs to
improve the readability of some of the inference rules.</p>
<p>When <em>instantiating</em> the judgment, each pattern must be
instantiated to an appropriate sort of "object" (value, type,
expression, etc). For example, '3 <b>=&gt;</b> 3' and '$x+0
<b>=&gt;</b> 3' are both instances of the judgment '<em>Expr</em>
<b>=&gt;</b> <a href="#doc-fs-Value"><em>Value</em></a>'. Note that
in the first judgment, '3' corresponds to both the expression '3'
(on the left-hand side of the <b>=&gt;</b> symbol) and to the value
'3' (on the right-hand side of the <b>=&gt;</b> symbol).</p>
<p id="jd_not">In some cases, inference rules may need to use the
fact that a certain judgment <em>does not</em> hold. <a href=
"#jd_not" class="judgment"><b>not</b></a>(<em>Judgment</em>) holds
if and only if <em>Judgment</em> does not hold.</p>
<p id="jd_isin">In some cases, a pattern may be instantiated to a
value within a finite set of pre-determined values. We may write
that set of possible values using the <a href="#jd_isin" class=
"judgment"><b>in</b></a> judgment. For instance, the judgment</p>
<div align="center"><em>Color</em> <a href="#jd_isin" class=
"judgment"><b>in</b></a> { <b>blue</b>, <b>green</b> }</div>
<p>holds if the pattern <em>Color</em> has either the value
<em>blue</em> or the value <em>green</em>.</p>
<p>In some cases, a judgment may use the "=" sign to indicate that
a given value is equal to another value, or that a pattern is equal
to a given value. For instance, the judgment</p>
<div align="center"><em>Color</em> = <b>blue</b></div>
<p>holds if the pattern <em>Color</em> has the value
<em>blue</em>.</p>
<p>An index to all the judgments used in this specification is
provided in <a href="#sec_indexes"><b>[B Index of
judgments]</b></a>.</p>
</div>
<div class="div3">
<h4><a name="sec_environments" id="sec_environments"></a>2.1.3
Notations for environments</h4>
<p id="xq_environment">An environment component is a dictionary
that maps a symbol (e.g., a function name or a variable name) to an
"object" (e.g., a function body, a type, a value). One can access
information in an environment component or update it.</p>
<p>If "envComp" is an environment component, then
"envComp(<em>symbol</em>)" denotes the "object" to which
<em>symbol</em> is mapped. The notation is intentionally similar to
function application, because an environment component can be
considered a function from the argument <em>symbol</em> to the
"object" to which the <em>symbol</em> is mapped.</p>
<p>This document uses <em>environments</em> that group related
environment components. If "env" is an environment containing the
environment component "envComp", that environment component is
denoted "env.envComp". The value that <em>symbol</em> is mapped to
in that environment component is denoted
"env.envComp(<em>symbol</em>)".</p>
<p>The two main environments used in the Formal Semantics are: a
dynamic environment (<a href="#xq_dyn_env_def" class=
"env">dynEnv</a>), which models the [XPath/XQuery] dynamic context,
and a static environment (<a href="#xq_stat_env_def" class=
"env">statEnv</a>), which models the [XPath/XQuery] static context.
Both are defined in <a href="#sec_context"><b>[3.1 Expression
Context]</b></a>.</p>
<p>For example, <a href="#xq_dyn_env_def" class=
"env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a>
denotes the dynamic environment component that maps variables to
values and <a href="#xq_dyn_env_def" class=
"env">dynEnv</a>.<a href="#xq_val_env" class=
"env">varValue</a>(<em>Variable</em>) denotes the value of the
variable <em>Variable</em> in the dynamic context.</p>
<p>Environments are used in a judgment to capture some of the
context in which the judgment is computed, and most judgments are
computed assuming that some environment is given. This
<em>assumption</em> is denoted by prefixing the judgment with "env
|-". The "|-" symbol is called a "turnstile" and is used in almost
all inference rules.</p>
<p>For instance, the judgment</p>
<div align="center"><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <em>Expr</em> <b>=&gt;</b>
<a href="#doc-fs-Value"><em>Value</em></a></div>
<p>is read as: Assuming the dynamic environment <a href=
"#xq_dyn_env_def" class="env">dynEnv</a>, the expression
<em>Expr</em> yields the value <a href=
"#doc-fs-Value"><em>Value</em></a>.</p>
<p>Environments can be <em>updated</em>, using the following
notation:</p>
<ul>
<li>
<p>"env + envComp(<em>symbol</em> =&gt; <em>object</em>) " denotes
the new environment that is identical to <em>env</em> except that
the environment component <em>envComp</em> has been updated to map
<em>symbol</em> to <em>object</em>. The notation <em>symbol</em>
=&gt; <em>object</em> indicates that <em>symbol</em> is mapped to
<em>object</em> in the new environment.</p>
</li>
<li>
<p>In case the environment component contains only a constant value
(e.g., the ordering mode which can only be either ordered or
unordered), the following notation is used to set its value. "env +
envComp( <em>object</em> ) ".</p>
</li>
<li>
<p>The following shorthand is also allowed: "env + envComp(
<em>symbol</em><sub><font size="2">1</font></sub> =&gt;
<em>object</em><sub><font size="2">1</font></sub> ; ... ;
<em>symbol</em><sub><font size="2">n</font></sub> =&gt;
<em>object</em><sub><font size="2">n</font></sub> ) " in which each
symbol is mapped to a corresponding object in the new
environment.</p>
<p>This notation is equivalent to nested updates, as in " (env +
envComp( <em>symbol</em><sub><font size="2">1</font></sub> =&gt;
<em>object</em><sub><font size="2">1</font></sub>) + ... ) +
env(<em>symbol</em><sub><font size="2">n</font></sub> =&gt;
<em>object</em><sub><font size="2">n</font></sub>)".</p>
</li>
</ul>
<p>Updating an environment creates a copy of the original
environment and overrides any previous binding that might exist for
the same name and the same component in that environment. Updating
the environment is used to capture the <em>scope</em> of a symbol
(e.g., for variables, namespace prefixes, etc). For instance, in
the following expression</p>
<div class="exampleInner">
<pre>
  let $x := 1 return
  let $x := $x + 2 return
  $x - 3
</pre></div>
<p>each let expression changes the dynamic context by binding a new
variable to a new value. Each different context is represented by a
different environment. The original environment, in which the
expression <code>1</code> is evaluated, does not contain any
binding for variable <code>$x</code>. This environment is updated a
first time with a binding of variable <code>$x</code> to the value
<code>1</code>, and this new environment is used for the evaluation
of the expression <code>$x + 2</code>. Then this second environment
is updated with a binding of variable <code>$x</code> to the value
<code>3</code>, and this environment is used for the evaluation of
the expression <code>$x - 3</code>.</p>
<p>Also, note that there are no operations to remove entries from
environments. This is never necessary as updating an environment
effectively creates a new extended copy of the original
environment, leaving the original environment accessible wherever
it is in scope along with the updated copy.</p>
</div>
<div class="div3">
<h4><a name="sec_inference" id="sec_inference"></a>2.1.4 Notations
for inference rules</h4>
<p>Inference rules are used to specify how to infer whether a given
judgment holds or not. Inference rules express the logical relation
between judgments and describe how complex judgments can be
concluded from simpler premise judgments.</p>
<p>A logical inference rule is written as a collection of
<em>premise</em>s and a <em>conclusion</em>, written respectively
above and below a dividing line, as follows:</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><em>premise</em><sub><font size="2">1</font></sub> ...
<em>premise</em><sub><font size="2">n</font></sub></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><em>conclusion</em></td>
</tr>
</table>
<br /></div>
<p>All premises and the conclusion are judgments. From a logical
point of view, an inference rule is a deduction that if the
premises hold, then the conclusion holds as well. In that sense,
the previous inference rule has a similar meaning as the following
logical statement.</p>
<p>IF <em>premise</em><sub><font size="2">1</font></sub></p>
<p>AND ...</p>
<p>AND <em>premise</em><sub><font size="2">n</font></sub></p>
<p>THEN <em>conclusion</em></p>
<p>Here is a simple example of inference rule, which uses specific
instances of the example judgment '<em>Expr</em> <b>=&gt;</b>
<a href="#doc-fs-Value"><em>Value</em></a>' from above:</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>$x <b>=&gt;</b> 0 &#160;&#160;&#160;&#160; 3 <b>=&gt;</b>
3</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>$x + 3 <b>=&gt;</b> 3</td>
</tr>
</table>
<br /></div>
<p>This inference rule expresses the following property:
<em>if</em> the variable expression '$x' yields the value '0',
<em>and</em> the literal expression '3' yields the value '3',
<em>then</em> the expression '$x + 3' yields the value '3'.</p>
<p>An inference rule may have no premises above the line, which
means that the expression below the line always holds. For
instance:</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>3 <b>=&gt;</b> 3</td>
</tr>
</table>
<br /></div>
<p>This inference rule expresses the following property: evaluating
the literal expression '3' always yields the value '3'.</p>
<p>The two above rules are expressed in terms of specific
expressions and values, but usually rules are more abstract. That
is, the judgments are not fully instantiated. Here is a rule that
says that for any variable $<em>VarName</em> that yields the
integer value <em>Integer</em>, adding '0' yields the same integer
value:</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>$<em>VarName</em> <b>=&gt;</b> <em>Integer</em></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>$<em>VarName</em> + 0 <b>=&gt;</b> <em>Integer</em></td>
</tr>
</table>
<br /></div>
<p>Each occurrence of a given pattern in a particular inference
rule must be instantiated to the same "object" within the entire
rule. This means that, in the context of a particular instantiation
of a rule, one can talk about "the value of $<em>VarName</em>"
instead of "the value bound to the first (second, etc) occurrence
of $<em>VarName</em>".</p>
<p>Here is an example of a rule occurring later in this
document.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">1</font></sub> <b>:</b> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>&#160;&#160;&#160;&#160;<a href=
"#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">2</font></sub> <b>:</b> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">1</font></sub> , <em>Expr</em><sub><font size=
"2">2</font></sub> <b>:</b> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
<br /></div>
<p>This rule is read as follows: if two expressions
<em>Expr</em><sub><font size="2">1</font></sub> and
<em>Expr</em><sub><font size="2">2</font></sub> are known to have
the static types <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
and <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub> (the two premises above the line), then it is
the case that the sequence expression
"<em>Expr</em><sub><font size="2">1</font></sub> ,
<em>Expr</em><sub><font size="2">2</font></sub>" has the static
type "<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>, <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>", which is the sequence of types <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
and <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>. Note that this inference rule does not modify
the static environment.</p>
<p>The following rule defines the static semantics of a "let"
expression. The binding of the new variable is captured by an
update to the varType component of the original static
environment.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <em>VarName</em> <a href=
"#jd_var_qname_expands_to" class="judgment"><b>of var expands
to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
<em>Expr</em><sub><font size="2">1</font></sub> <b>:</b> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
&#160;&#160;&#160;&#160; <a href="#xq_stat_env_def" class=
"env">statEnv</a> + <a href="#xq_type_env" class=
"env">varType</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a> =&gt; <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
<b>&#160;|-&#160;</b> <em>Expr</em><sub><font size=
"2">2</font></sub> <b>:</b> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <code>let</code>
<code>$</code><em>VarName</em> := <em>Expr</em><sub><font size=
"2">1</font></sub> <code>return</code>
<em>Expr</em><sub><font size="2">2</font></sub> <b>:</b> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
<br /></div>
<p>This rule is read as follows: First, because the variable is a
QName, it is first expanded into an expanded QName. Second, the
type <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub> for the "let" input expression
<em>Expr</em><sub><font size="2">1</font></sub> is computed. Then
the "let" variable with expanded name, <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a> with type
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub> is added into the varType component of the
static environment <a href="#xq_stat_env_def" class=
"env">statEnv</a>. Finally, the type <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
of <em>Expr</em><sub><font size="2">2</font></sub> is computed in
that new environment.</p>
<p>In some cases, ellipses may be used in inference rules to handle
an arbitrary number of judgments. In those cases, some of the
patterns may have indices as subscript. If the same index is used
several times within the same rule, the number of judgment in each
case must be the same. For instance, the following rule holds for
any number of expressions, from <em>Expr</em><sub><font size=
"2">1</font></sub> to <em>Expr</em><sub><font size=
"2">n</font></sub>, with the same number of types <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
to <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">n</font></sub>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>QName</em> <a href=
"#jd_func_qname_expands_to" class="judgment"><b>of func expands
to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
<em>Expr</em><sub><font size="2">1</font></sub> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td>...</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
<em>Expr</em><sub><font size="2">n</font></sub> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">n</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>,...,<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>)
<a href="#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <em>QName</em> (<em>Expr</em><sub><font size=
"2">1</font></sub>,...,<em>Expr</em><sub><font size=
"2">n</font></sub>) <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>This inference rule is equivalent to having an unbounded number
of rules, the first of which has 1 judgment, the second of which
has 2 judgments, etc. For instance, the above rule holds if and
only if one of the following rules hold.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>QName</em> <a href=
"#jd_func_qname_expands_to" class="judgment"><b>of func expands
to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
<em>Expr</em><sub><font size="2">1</font></sub> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
<a href="#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <em>QName</em> (<em>Expr</em><sub><font size=
"2">1</font></sub>) <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>or</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>QName</em> <a href=
"#jd_func_qname_expands_to" class="judgment"><b>of func expands
to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
<em>Expr</em><sub><font size="2">1</font></sub> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
<em>Expr</em><sub><font size="2">2</font></sub> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>,<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>)
<a href="#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <em>QName</em> (<em>Expr</em><sub><font size=
"2">1</font></sub>,<em>Expr</em><sub><font size="2">2</font></sub>)
<a href="#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>etc.</p>
<p>When ellipses are used, the value for the index always ranges
from 1 to an arbitrary number n.</p>
</div>
<div class="div3">
<h4><a name="sec_together" id="sec_together"></a>2.1.5 Putting it
together</h4>
<p>In isolation, each inference rule describes a fragment of the
semantics for a given judgment. Put together, inference rules
describe possible inferences that can be used to decide whether a
particular judgment holds.</p>
<p>For a given judgment, if that judgment can be inferred to be
true by applying any sequence of inferences based on premises which
are known to be true, the inference succeeds. In most cases, the
inference will proceed by proving intermediate judgments, following
the consequences from one judgment to the next by applying
successive inference rules.</p>
<p>Such inference is a mechanism which can be used to describe both
static type analysis and dynamic evaluation. More specifically,
performing static typing consists in proving that the following
judgment holds for a given expression <em>Expr</em>.</p>
<div align="center"><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>Expr</em> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></div>
<p>If the judgment holds for a given type <a href=
"#doc-fs-Type"><em>Type</em></a>, this type is a possible static
type for the expression. If there exists no type for which this
judgment holds, then static typing fails and a static type error is
returned to the user.</p>
<p>Consider the following expression.</p>
<div class="exampleInner">
<pre>
  fn:count((1,2,3))
</pre></div>
<p>Using the static typing rules given for expressions in the rest
of this document, one can deduce that the expression is of type
<code>xs:integer</code> through the following inference.</p>
<div class="exampleInner">
<pre>
  statEnv |- 1 : xs:integer  (from typing of literals)
  statEnv |- 2 : xs:integer  (from typing of literals)
  --------------------------------------------------- (sequence)
    statEnv |- 1,2 : xs:integer, xs:integer
    statEnv |- 3 : xs:integer
    ----------------------------------------------------- (sequence)
    statEnv |- 1,2,3 : xs:integer, xs:integer, xs:integer

    declare function fn:count($x as item()*) as xs:integer
    statEnv |- xs:integer,xs:integer,xs:integer &lt;: item()*
    ---------------------------------------------------------- (function call)
    statEnv |- fn:count((1,2,3)) : xs:integer
</pre></div>
<p>Conversly, consider the following expression.</p>
<div class="exampleInner">
<pre>
  fn:nilled((1,2,3))
</pre></div>
<p>Using the static typing rules given for expressions in the rest
of this document, one can apply inference rules up to the following
point.</p>
<div class="exampleInner">
<pre>
    ....
    ----------------------------------------------------- (sequence)
    statEnv |- 1,2,3 : xs:integer, xs:integer, xs:integer
</pre></div>
<p>However, there is no rule that can infer the type of
<code>fn:nilled((1,2,3))</code>, because the static typing rules
for function calls will only hold if the type of the function
parameters is a subtype of the expected type. However, here
<code>(xs:integer,xs:integer,xs:integer)</code> is not a node type,
which is the expected type for the function
<code>fn:nilled</code>.</p>
<p>Note that in some cases, the inference can only proceed through
the appropriate changes to the environment. For instance, consider
the following expression.</p>
<div class="exampleInner">
<pre>
  let $x := 1 return ($x,$x)
</pre></div>
<p>Using the static typing rules given for expressions in the rest
of this document, one can deduce that the expression is of type
<code>(xs:integer,xs:integer)</code> through the following
inference.</p>
<div class="exampleInner">
<pre>
statEnv0.varType = ()

  -------------------------- (literal)
  statEnv0 |- 1 : xs:integer

statEnv1 = statEnv0 + varType($x =&gt; xs:integer)

     statEnv1.varType($x) = xs:integer
     --------------------------------- (variable reference)
     statEnv1 |- $x : xs:integer

     statEnv1.varType($x) = xs:integer
     --------------------------------- (variable reference)
     statEnv1 |- $x : xs:integer

     ------------------------------------------- (sequence)
     statEnv1 |- ($x,$x) : xs:integer,xs:integer

  -------------------------------------------------------------- (let)
  statEnv0 |- let $x := 1 return ($x,$x) : xs:integer,xs:integer
</pre></div>
<p>This example illustrates how each rule is applied to individual
sub-expressions, and how the environment is used to maintain the
relevant context information.</p>
</div>
</div>
<div class="div2">
<h3><a name="sec_namespaces" id="sec_namespaces"></a>2.2 URIs,
Namespaces, and Prefixes</h3>
<p>The Formal Semantics does not formally specify the adjustment of
relative URIs according to a base URI. All URIs used in this
document are assumed to be absolute URIs.</p>
<p>The Formal Semantics uses the following namespace prefixes.</p>
<ul>
<li>
<p><code>fn:</code> for functions and operators from the <a href=
"#xpath-functions-11">[Functions and Operators 1.1]</a>
document.</p>
</li>
<li>
<p><code>xs:</code> for XML Schema components and built-in
types.</p>
</li>
</ul>
<p>These prefixes are assumed to be bound to the appropriate
URIs.</p>
<p>In addition, the Formal Semantics uses the following special
prefixes for specification purposes.</p>
<ul>
<li>
<p><em>dm:</em> for accessors of the <a href=
"#xpath-datamodel-11">[Data Model]</a>.</p>
</li>
<li>
<p><em>op:</em> for operators in <a href=
"#xpath-functions-11">[Functions and Operators 1.1]</a>.</p>
</li>
<li>
<p><em>fs:</em> for functions and types defined in the formal
semantics.</p>
</li>
</ul>
<p>These prefixes are always italicized to emphasize that the
corresponding functions, variables, and types are abstract: they
are not and cannot be made accessible in [XPath/XQuery]. None of
these special prefixes are given an explicit URI, but they behave
as if they had one for the purposes of namespace resolution.</p>
</div>
<div class="div2">
<h3><a name="sec_values" id="sec_values"></a>2.3 XML Values</h3>
<p>The [XPath/XQuery] language is defined over values of the
[XPath/XQuery] data model. The [XPath/XQuery] data model is defined
normatively in <a href="#xpath-datamodel-11">[Data Model]</a>. We
define the formal notation that is used in this document to
describe and manipulate values in inference rules. Formal values
are used for specification purposes only and are not exposed to the
[XPath/XQuery] user.</p>
<p>This section gives the grammar for formal values, along with a
summary of the corresponding data model properties. In the context
of this document, all constraints on values that are specified in
<a href="#xpath-datamodel-11">[Data Model]</a> are assumed to
hold.</p>
<div class="div3">
<h4><a name="sec_data_model_overview" id=
"sec_data_model_overview"></a>2.3.1 Formal values</h4>
<p>A value is a sequence of zero or more items. An item is either
an atomic value or a node.</p>
<p>An atomic value is a value in the value space of an atomic type,
labeled with the name of that atomic type. An atomic type is either
a primitive or derived atomic type according to XML Schema <a href=
"#xmlschema-2">[Schema Part 2]</a>, <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>, or
<a href=
"#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>.</p>
<p>A node is either an element, an attribute, a document, a text, a
comment, or a processing-instruction node.</p>
<p>Element nodes have a <a href=
"http://www.w3.org/TR/xquery#dt-type-annotation">type
annotation</a><sup><small>XQ</small></sup> and contain a complex
value or a simple value. Attribute nodes have a <a href=
"http://www.w3.org/TR/xquery#dt-type-annotation">type
annotation</a><sup><small>XQ</small></sup> and contain a simple
value. Text nodes always contain one string value of type <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>, therefore
the corresponding type annotation is omitted in the formal notation
of a text node. Document nodes do not have a type annotation and
contain a sequence of element, text, comment, or
processing-instruction nodes.</p>
<p>A simple value is a sequence of atomic values.</p>
<p>A complex value is a sequence of attribute nodes followed by a
sequence of element, text, comment, or processing-instruction
nodes.</p>
<p>A <a href="http://www.w3.org/TR/xquery#dt-type-annotation">type
annotation</a><sup><small>XQ</small></sup> can be either the
<em>QName</em> of a declared type or an anonymous type. An
anonymous type corresponds to an XML Schema type for which the
schema writer did not provide a name. Anonymous type names are not
visible to the user, but are generated during schema validation and
used to annotate nodes in the data model. By convention, anonymous
type names are written using the <em>fs:</em> Formal Semantics
prefix: <em>fs:</em>anon<sub><font size="2">0</font></sub>,
<em>fs:</em>anon<sub><font size="2">1</font></sub>, etc.</p>
<p>Formal values are defined by the following grammar.</p>
<h5><a name="d6e2238" id="d6e2238"></a>Values</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-Value" id=
"doc-fs-Value"></a>[<small>7&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-Value">Value</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-Item">Item</a><br />
| (<a href="#doc-fs-Value">Value</a> "," <a href=
"#doc-fs-Value">Value</a>)<br />
| ("(" ")")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-Item" id=
"doc-fs-Item"></a>[<small>21&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-Item">Item</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-NodeValue">NodeValue</a><br />
| <a href="#doc-fs-AtomicValue">AtomicValue</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-AtomicValue" id=
"doc-fs-AtomicValue"></a>[<small>22&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-AtomicValue">AtomicValue</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-fs-AtomicValueContent">AtomicValueContent</a> <a href=
"#doc-fs-TypeAnnotation">TypeAnnotation</a>?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-AtomicValueContent" id=
"doc-fs-AtomicValueContent"></a>[<small>1&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-AtomicValueContent">AtomicValueContent</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>String<br />
| Boolean<br />
| Decimal<br />
| Float<br />
| Double<br />
| Duration<br />
| DateTime<br />
| Time<br />
| Date<br />
| GYearMonth<br />
| GYear<br />
| GMonthDay<br />
| GDay<br />
| GMonth<br />
| HexBinary<br />
| Base64Binary<br />
| AnyURI<br />
| expanded-QName<br />
| NOTATION</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-TypeAnnotation" id=
"doc-fs-TypeAnnotation"></a>[<small>2&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-TypeAnnotation">TypeAnnotation</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"of" "type" <a href=
"#doc-fs-TypeName">TypeName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-ElementValue" id=
"doc-fs-ElementValue"></a>[<small>9&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-ElementValue">ElementValue</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"element" <a href="#doc-fs-ElementName">ElementName</a>
"nilled"? <a href="#doc-fs-TypeAnnotation">TypeAnnotation</a>? "{"
<a href="#doc-fs-Value">Value</a> "}" ("{" <a href=
"#doc-fs-NamespaceBindings">NamespaceBindings</a> "}")?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-AttributeValue" id=
"doc-fs-AttributeValue"></a>[<small>10&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-AttributeValue">AttributeValue</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"attribute" <a href=
"#doc-fs-AttributeName">AttributeName</a> <a href=
"#doc-fs-TypeAnnotation">TypeAnnotation</a>? "{" <a href=
"#doc-fs-SimpleValue">SimpleValue</a> "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-SimpleValue" id=
"doc-fs-SimpleValue"></a>[<small>8&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-SimpleValue">SimpleValue</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-AtomicValue">AtomicValue</a><br />
| (<a href="#doc-fs-SimpleValue">SimpleValue</a> "," <a href=
"#doc-fs-SimpleValue">SimpleValue</a>)<br />
| ("(" ")")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-DocumentValue" id=
"doc-fs-DocumentValue"></a>[<small>11&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-DocumentValue">DocumentValue</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"document" "{" <a href="#doc-fs-Value">Value</a>
"}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-CommentValue" id=
"doc-fs-CommentValue"></a>[<small>13&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-CommentValue">CommentValue</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"comment" "{" String "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-ProcessingInstructionValue" id=
"doc-fs-ProcessingInstructionValue"></a>[<small>14&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-ProcessingInstructionValue">ProcessingInstructionValue</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"processing-instruction" NCName "{" String
"}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-TextValue" id=
"doc-fs-TextValue"></a>[<small>12&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-TextValue">TextValue</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"text" "{" String "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-NodeValue" id=
"doc-fs-NodeValue"></a>[<small>20&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-NodeValue">NodeValue</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-ElementValue">ElementValue</a><br />
| <a href="#doc-fs-AttributeValue">AttributeValue</a><br />
| <a href="#doc-fs-DocumentValue">DocumentValue</a><br />
| <a href="#doc-fs-TextValue">TextValue</a><br />
| <a href="#doc-fs-CommentValue">CommentValue</a><br />
| <a href=
"#doc-fs-ProcessingInstructionValue">ProcessingInstructionValue</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-ElementName" id=
"doc-fs-ElementName"></a>[<small>3&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-ElementName">ElementName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>QName</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-AttributeName" id=
"doc-fs-AttributeName"></a>[<small>6&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-AttributeName">AttributeName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>QName</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-TypeName" id=
"doc-fs-TypeName"></a>[<small>23&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-TypeName">TypeName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>QName</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-NamespaceBindings" id=
"doc-fs-NamespaceBindings"></a>[<small>15&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-NamespaceBindings">NamespaceBindings</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-NamespaceBinding">NamespaceBinding</a>
("," <a href=
"#doc-fs-NamespaceBinding">NamespaceBinding</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-NamespaceBinding" id=
"doc-fs-NamespaceBinding"></a>[<small>17&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-NamespaceBinding">NamespaceBinding</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"namespace" NCName "{" AnyURI "}"</code></td>
</tr>
</tbody>
</table>
<p><b>Notation</b></p>
<p>In the production for <a href=
"#doc-fs-AtomicValueContent"><em>AtomicValueContent</em></a>, each
symbol in the right-hand side corresponds to one of the primitive
datatypes. For example, <em>String</em> corresponds to
<code>xs:string</code>, and <em>Boolean</em> corresponds to
<code>xs:boolean</code>. (The mapping is obvious, except that
<span>"expanded-QName"</span> <span><a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></span>
corresponds to <code>xs:QName</code><span>.</span>) Although there
are no explicit productions for these symbols, we assume that each
is a non-terminal that derives a set of syntactic objects, each of
which corresponds to a value in the value space of the
corresponding datatype. For instance, the non-terminal
<em>String</em> derives a set of syntactic objects, which appear in
examples as <code>""</code>, <code>"a"</code>, <code>"John"</code>,
etc.; each one corresponds to a string value in the
<code>xs:string</code> value space. For familiarity, these objects
have been given the same appearance as <em>StringLiteral</em>s from
the XQuery and Core grammars; however, these are formal objects,
with a distinct role in the <span>FS</span> <span>Formal
Semantics</span>.</p>
<p>Element (resp. attributes) without type annotations, are assumed
to have the type annotation <code>xs:anyType</code> (resp.
<code>xs:anySimpleType</code>). Atomic values without type
annotations, are assumed to have a type annotation which is the
base type for the corresponding value. For instance, <code>"Hello,
World!"</code> is equivalent to <code>"Hello, World!" of type
xs:string</code>.</p>
<p>Untyped elements (e.g., from well-formed documents) have the
<a href="http://www.w3.org/TR/xquery#dt-type-annotation">type
annotation</a><sup><small>XQ</small></sup> <a href=
"#dt-xs_untyped"><code>xs:untyped</code></a>, untyped attributes
have the <a href=
"http://www.w3.org/TR/xquery#dt-type-annotation">type
annotation</a><sup><small>XQ</small></sup> <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>, and
untyped atomic values have the <a href=
"http://www.w3.org/TR/xquery#dt-type-annotation">type
annotation</a><sup><small>XQ</small></sup> <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>.</p>
<p>An element has an optional "nilled" marker. This marker is
present only if the element has been validated against an element
type in the schema which is "nillable", and the element has no
content and an attribute <code>xsi:nil</code> set to
<code>"true"</code>.</p>
<p>An element also has a sequence of namespace bindings, which are
the set of in-scope namespaces for that element. Each namespace
binding is a prefix, URI pair. Elements without namespace bindings
are assumed to have an empty set of in-scope namespaces.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In <a href="#">[XPath]</a>, the in-scope namespaces of an
element node are represented by a collection of <b>namespace
nodes</b> arranged on a <b>namespace axis</b>, which is optional
and deprecated in <a href="#xpath-21">[XML Path Language (XPath)
2.1]</a>. XQuery does not support the namespace axis and does not
represent namespace bindings in the form of nodes.</p>
</div>
</div>
<div class="div3">
<h4><a name="sec_example_values" id="sec_example_values"></a>2.3.2
Examples of values</h4>
<p><b>A well-formed document</b></p>
<div class="exampleInner">
<pre>
  &lt;fact&gt;The cat weighs &lt;weight units="lbs"&gt;12&lt;/weight&gt; pounds.&lt;/fact&gt;
</pre></div>
<p>In the absence of a Schema, this document is represented as</p>
<div class="exampleInner">
<pre>
  element fact of type xs:untyped {
    text { "The cat weighs " },
    element weight of type xs:untyped {
      attribute units of type xs:untypedAtomic {
        "lbs" of type xs:untypedAtomic
      }<span>,</span>
      text { "12" }
    },
    text { " pounds." }
  }
</pre></div>
<p><b>A document before and after validation.</b></p>
<div class="exampleInner">
<pre>
  &lt;weight xsi:type="xs:integer"&gt;42&lt;/weight&gt;
</pre></div>
<p>The formal model for values can represent values before and
after validation. Before validation, this element is represented
as:</p>
<div class="exampleInner">
<pre>
  element weight of type xs:untyped {
    attribute xsi:type of type xs:untypedAtomic {
      "xs:integer" of type xs:untypedAtomic
    },
    text { "42" }
  }
</pre></div>
<p>After validation, this element is represented as:</p>
<div class="exampleInner">
<pre>
  element weight of type xs:integer {
    attribute xsi:type of type xs:QName {
      "xs:integer" of type xs:QName
    },
    42 of type xs:integer
  }
</pre></div>
<p><b>An element with a list type</b></p>
<div class="exampleInner">
<pre>
  &lt;sizes&gt;1 2 3&lt;/sizes&gt;
</pre></div>
<p>Before validation, this element is represented as:</p>
<div class="exampleInner">
<pre>
  element sizes of type xs:untyped {
    text { "1 2 3" }
  }
</pre></div>
<p>Assume the following Schema.</p>
<div class="exampleInner">
<pre>
  &lt;xs:element name="sizes" type="sizesType"/&gt;
  &lt;xs:simpleType name="sizesType"&gt;
    &lt;xs:list itemType="sizeType"/&gt;
  &lt;/xs:simpleType&gt;
  &lt;xs:simpleType name="sizeType"&gt;
    &lt;xs:restriction base="xs:integer"/&gt;
  &lt;/xs:simpleType&gt;
</pre></div>
<p>After validation against this Schema, the element is represented
as:</p>
<div class="exampleInner">
<pre>
  element sizes of type sizesType {
    1 of type sizeType,
    2 of type sizeType,
    3 of type sizeType
  }
</pre></div>
<p><b>An element with an anonymous type</b></p>
<div class="exampleInner">
<pre>
  &lt;sizes&gt;1 2 3&lt;/sizes&gt;
</pre></div>
<p>Before validation, this element is represented as:</p>
<div class="exampleInner">
<pre>
  element sizes of type xs:untyped {
    text { "1 2 3" }
  }
</pre></div>
<p>Assume the following Schema.</p>
<div class="exampleInner">
<pre>
  &lt;xs:element name="sizes"&gt;
    &lt;xs:simpleType&gt;
      &lt;xs:list itemType="xs:integer"/&gt;
    &lt;/xs:simpleType&gt;
  &lt;/xs:element&gt;
</pre></div>
<p>After validation, this element is represented as:</p>
<div class="exampleInner">
<pre>
  element sizes of type fs:anon1 {
    1 of type xs:integer,
    2 of type xs:integer,
    3 of type xs:integer
  }
</pre></div>
<p>where <em>fs:</em>anon<sub><font size="2">1</font></sub> stands
for the internal anonymous name generated by the system for the
<code>sizes</code> element.</p>
<p><b>A nillable element with</b> <code>xsi:type</code> <b>set to
true</b></p>
<div class="exampleInner">
<pre>
  &lt;sizes xsi:nil="true"/&gt;
</pre></div>
<p>Before validation, this element is represented as:</p>
<div class="exampleInner">
<pre>
  element sizes of type xs:untyped {
    attribute xsi:nil of type xs:untypedAtomic { "true" of type xs:untypedAtomic }
  }
</pre></div>
<p>Assume the following Schema.</p>
<div class="exampleInner">
<pre>
  &lt;xs:element name="sizes" type="sizesType" nillable="true"/&gt;
</pre></div>
<p>After validation against this Schema, the element is represented
as:</p>
<div class="exampleInner">
<pre>
  element sizes nilled of type sizesType {
    attribute xsi:nil of type xs:boolean { true of type xs:boolean }
  }
</pre></div>
<p><b>An element with a union type</b></p>
<div class="exampleInner">
<pre>
  &lt;sizes&gt;1 two 3 four&lt;/sizes&gt;
</pre></div>
<p>Before validation, this element is represented as:</p>
<div class="exampleInner">
<pre>
  element sizes of type xs:untyped {
    text { "1 two 3 four" }
  }
</pre></div>
<p>Assume the following Schema:</p>
<div class="exampleInner">
<pre>
  &lt;xs:element name="sizes" type="sizesType"/&gt;
  &lt;xs:simpleType name="sizesType"&gt;
    &lt;xs:list itemType="sizeType"/&gt;
  &lt;/xs:simpleType&gt;
  &lt;xs:simpleType name="sizeType"&gt;
    &lt;xs:union memberType="xs:integer xs:string"/&gt;
  &lt;/xs:simpleType&gt;
</pre></div>
<p>After validation against this Schema, the element is represented
as:</p>
<div class="exampleInner">
<pre>
  element sizes of type sizesType {
    1 of type xs:integer,
    "two" of type xs:string,
    3 of type xs:integer,
    "four" of type xs:string
  }
</pre></div>
</div>
</div>
<div class="div2">
<h3><a name="sec_types" id="sec_types"></a>2.4 The [XPath/XQuery]
Type System</h3>
<p>The [XPath/XQuery] type system is used in the specification of
the dynamic and of the static semantics of [XPath/XQuery]. This
section introduces formal notations for describing types.</p>
<div class="div3">
<h4><a name="sec_schema" id="sec_schema"></a>2.4.1 XML Schema and
the [XPath/XQuery] Type System</h4>
<p>The [XPath/XQuery] type system is based on <a href=
"#xmlschema-1">[Schema Part 1]</a> and <a href=
"#xmlschema-2">[Schema Part 2]</a>. <a href="#xmlschema-1">[Schema
Part 1]</a> and <a href="#xmlschema-2">[Schema Part 2]</a> specify
normatively the type information available in [XPath/XQuery]. We
define the formal notation that is used in this document to
describe and manipulate types in inference rules. Formal types are
used for specification purposes only and are not exposed to the
[XPath/XQuery] user.</p>
<p><b>Representation of content models.</b> For the purpose of
static typing, the [XPath/XQuery] type system only describes
minOccurs, maxOccurs, and minLength, maxLength on list types for
the occurrences that correspond to the DTD operators
<code>+</code>, <code>*</code>, and <code>?</code>. Choices are
represented using the DTD operator <code>|</code>. <b>All
groups</b> are represented using the interleaving operator
(<code>&amp;</code>).</p>
<p><b>Representation of anonymous types.</b> To clarify the
semantics, the [XPath/XQuery] type system makes all anonymous types
explicit.</p>
<p><b>Representation of XML Schema simple type facets and identity
constraints.</b> For simplicity, XML Schema simple type facets and
identity constraints are not formally represented in the
[XPath/XQuery] type system. However, an [XPath/XQuery]
implementation supporting XML Schema import and validation must
take simple type facets and identity constraints into account.</p>
<p>This document <span>describe</span> <span>describes</span> types
in the [XPath/XQuery] types system, as well as the operations and
properties over those types which are used to define the
[XPath/XQuery] static typing feature. The two most important
properties are whether a data <span>instances</span>
<span>instance</span> matches a type, and whether a type is a
subtype of another. Those properties are described in <a href=
"#sec_type_matching"><b>[8.3 Judgments for type matching]</b></a>.
This document does not describe all other possible properties over
those types.</p>
<p>The mapping from XML Schema into the [XPath/XQuery] type system
is given in <a href="#sec_importing_schema"><b>[D Importing
Schemas]</b></a>. The rest of this section is organized as follows.
<a href="#sec_item_types"><b>[2.4.2 Item types]</b></a> describes
item types, <a href="#sec_content_models"><b>[2.4.3 Content
models]</b></a> describes content models, and <a href=
"#sec_top_level_definitions"><b>[2.4.4 Top level
definitions]</b></a> <span>describe</span> <span>describes</span>
top-level type declarations.</p>
</div>
<div class="div3">
<h4><a name="sec_item_types" id="sec_item_types"></a>2.4.2 Item
types</h4>
<p>An item type is either an atomic type, an element type, an
attribute type, a document node type, a text node type, a comment
node type, or a processing instruction type. We distinguish between
document nodes, attribute nodes, and nodes that can occur in
element content (elements, comments, processing instructions, and
text nodes), as we need to refer to element content types later in
the formal semantics.</p>
<h5><a name="d6e2791" id="d6e2791"></a>Item Types</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-FormalItemType" id=
"doc-fs-FormalItemType"></a>[<small>25&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-FormalItemType">FormalItemType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-AtomicTypeName">AtomicTypeName</a> |
<a href="#doc-fs-NodeType">NodeType</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-AtomicTypeName" id=
"doc-fs-AtomicTypeName"></a>[<small>28&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-AtomicTypeName">AtomicTypeName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-TypeName">TypeName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-NodeType" id=
"doc-fs-NodeType"></a>[<small>26&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-NodeType">NodeType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-DocumentType">DocumentType</a><br />
| <a href="#doc-fs-AttributeType">AttributeType</a><br />
| <a href=
"#doc-fs-ElementContentType">ElementContentType</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-ElementContentType" id=
"doc-fs-ElementContentType"></a>[<small>27&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-ElementContentType">ElementContentType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-ElementType">ElementType</a><br />
| "comment"<br />
| <a href=
"#doc-fs-ProcessingInstructionType">ProcessingInstructionType</a><br />

| "text"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-ElementType" id=
"doc-fs-ElementType"></a>[<small>29&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-ElementType">ElementType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"element" <a href=
"#doc-fs-ElementNameOrWildcard">ElementNameOrWildcard</a> <a href=
"#doc-fs-OptTypeSpecifier">OptTypeSpecifier</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-ElementNameOrWildcard" id=
"doc-fs-ElementNameOrWildcard"></a>[<small>4&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-ElementNameOrWildcard">ElementNameOrWildcard</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>QName | "*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-AttributeNameOrWildcard" id=
"doc-fs-AttributeNameOrWildcard"></a>[<small>5&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-AttributeNameOrWildcard">AttributeNameOrWildcard</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>QName | "*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-OptTypeSpecifier" id=
"doc-fs-OptTypeSpecifier"></a>[<small>77&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-OptTypeSpecifier">OptTypeSpecifier</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-fs-TypeSpecifier">TypeSpecifier</a>?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-TypeSpecifier" id=
"doc-fs-TypeSpecifier"></a>[<small>30&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-TypeSpecifier">TypeSpecifier</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-OptNillable">OptNillable</a> <a href=
"#doc-fs-TypeReference">TypeReference</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-AttributeType" id=
"doc-fs-AttributeType"></a>[<small>31&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-AttributeType">AttributeType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"attribute" <a href=
"#doc-fs-AttributeNameOrWildcard">AttributeNameOrWildcard</a>
<a href="#doc-fs-OptTypeReference">OptTypeReference</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-OptNillable" id=
"doc-fs-OptNillable"></a>[<small>75&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-OptNillable">OptNillable</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-Nillable">Nillable</a>?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-Nillable" id=
"doc-fs-Nillable"></a>[<small>32&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-Nillable">Nillable</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"nillable"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-OptTypeReference" id=
"doc-fs-OptTypeReference"></a>[<small>78&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-OptTypeReference">OptTypeReference</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-fs-TypeReference">TypeReference</a>?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-TypeReference" id=
"doc-fs-TypeReference"></a>[<small>36&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-TypeReference">TypeReference</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"of" "type" <a href=
"#doc-fs-TypeName">TypeName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-ProcessingInstructionType" id=
"doc-fs-ProcessingInstructionType"></a>[<small>93&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-ProcessingInstructionType">ProcessingInstructionType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"processing-instruction" <a href=
"#doc-fs-PITargetOrWildcard">PITargetOrWildcard</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-PITargetOrWildcard" id=
"doc-fs-PITargetOrWildcard"></a>[<small>94&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-PITargetOrWildcard">PITargetOrWildcard</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>NCName | "*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-DocumentType" id=
"doc-fs-DocumentType"></a>[<small>45&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-DocumentType">DocumentType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"document" ("{" <a href="#doc-fs-Type">Type</a>
"}")?</code></td>
</tr>
</tbody>
</table>
<p>An element or attribute type has a name or wildcard, and an
optional type reference. A name alone corresponds to a reference to
a global element or attribute declaration. A name with a type
reference corresponds to a local element or attribute declaration.
"element *" or "attribute *" alone refers to the wildcard types for
any element or any attribute. In addition, an element type has an
optional nillable flag that indicates whether the element can be
nilled or not.</p>
<p>A document type has an optional content type. If no content type
is given, then the type is treated as being the wildcard type for
documents, i.e., a sequence of text and element nodes. For
consistency with element nodes, PIs and comments are not indicated
in that wildcard type, but may occur in instances.</p>
<p><b>Note</b></p>
<p>Generic node types (e.g., <code>node()</code>) such as used in
the SequenceType production, are interpreted in the type system as
a union of the corresponding node types (e.g.,
element,attribute,text,comment and processing-instruction nodes)
and therefore do not appear in the grammar. The semantics of
sequence types is described in <a href=
"#id-sequencetype-matching"><b>[3.5.4 SequenceType
Matching]</b></a>.</p>
<p><b>Examples</b></p>
<p>The following is a text node type</p>
<div class="exampleInner">
<pre>
  text
</pre></div>
<p>The following is a type for all elements</p>
<div class="exampleInner">
<pre>
  element * of type xs:anyType
</pre></div>
<p>The following is a type for all elements of type string</p>
<div class="exampleInner">
<pre>
  element * of type xs:string
</pre></div>
<p>The following is a type for a nillable element of type string
and with name <code>size</code></p>
<div class="exampleInner">
<pre>
  element size nillable of type xs:string
</pre></div>
<p>The following is a reference to a global attribute
declaration</p>
<div class="exampleInner">
<pre>
  attribute sizes
</pre></div>
<p>The following is a type for elements with anonymous type
<em>fs:</em>anon<sub><font size="2">1</font></sub>:</p>
<div class="exampleInner">
<pre>
  element sizes of type fs:anon1
</pre></div>
</div>
<div class="div3">
<h4><a name="sec_content_models" id="sec_content_models"></a>2.4.3
Content models</h4>
<p>Following XML Schema, types in [XPath/XQuery] are composed from
item types by optional, one or more, zero or more, <b>all
group</b>, <b>sequence</b>, <b>choice</b>, empty sequence (written
<code>empty</code>), or empty choice (written
<code>none</code>).</p>
<p>The type <code>empty</code> matches the empty sequence. The type
<code>none</code> matches no values. <code>none</code> is the
identity for choice, that is (<a href=
"#doc-fs-Type"><em>Type</em></a> | <code>none</code>) = <a href=
"#doc-fs-Type"><em>Type</em></a>. The type <code>none</code> is the
static type for <a href="#sec_fnerror"><b>[7.2.9 The fn:error
function]</b></a>.</p>
<h5><a name="d6e3032" id="d6e3032"></a>Types</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-Type" id=
"doc-fs-Type"></a>[<small>24&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-Type">Type</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-FormalItemType">FormalItemType</a><br />
| (<a href="#doc-fs-Type">Type</a> OccurrenceIndicator)<br />
| (<a href="#doc-fs-Type">Type</a> "&amp;" <a href=
"#doc-fs-Type">Type</a>)<br />
| (<a href="#doc-fs-Type">Type</a> "," <a href=
"#doc-fs-Type">Type</a>)<br />
| (<a href="#doc-fs-Type">Type</a> "|" <a href=
"#doc-fs-Type">Type</a>)<br />
| "empty"<br />
| "none"<br />
| ("(" <a href="#doc-fs-Type">Type</a> ")")</code></td>
</tr>
</tbody>
</table>
<p>The [XPath/XQuery] type system includes three binary operators
on types: ",", "|" and "&amp;", corresponding respectively to
sequence, choice and <b>all groups</b> in Schema. The
[XPath/XQuery] type system includes three unary operators on types:
"*", "+", and "?", corresponding respectively to zero or more
instances of the type, one or more instances of the type, or an
optional instance of the type.</p>
<p>The "&amp;" operator builds the "interleaved product" of two
types. The type <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
&amp; <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub> matches any sequence that is an interleaving of
two sequences of items, <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> and <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub>, with <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> matching <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
and <a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub> matching <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>.
The interleaving of two sequences of items <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> and <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub> is any sequence <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">0</font></sub> such that there is an ordered partition of
<a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">0</font></sub> into the two sub-sequences <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> and <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub>. The interleaved product captures the semantics
of <b>all groups</b> in XML Schema, but is more general as it
applies to arbitrary types. <b>All groups</b> in XML Schema are
restricted to apply only on global or local element declarations
with minOccurs 0 or 1, and maxOccurs 1.</p>
<p>For example, consider the types <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
=
<code>xs:integer</code>,<code>xs:integer</code>,<code>xs:integer</code>
and <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub> = <code>xs:string</code>,<code>xs:string</code>.
<a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <code>= (1,2,3)</code> matches the type <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
and <a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub> <code>= ("a","b")</code> matches the type
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>. Any of the following <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">0</font></sub> are interleavings of <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> and <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub>, and therefore match the type (<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
&amp; <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>):</p>
<div class="exampleInner">
<pre>
Value0 = (1,2,3,"a","b")
Value0 = (1,2,"a",3,"b")
Value0 = (1,2,"a","b",3)
Value0 = (1,"a",2,3,"b")
Value0 = (1,"a",2,"b",3)
Value0 = (1,"a","b",2,3)
Value0 = ("a",1,2,3,"b")
Value0 = ("a",1,2,"b",3)
Value0 = ("a",1,"b",2,3)
Value0 = ("a","b",1,2,3)
</pre></div>
<p><b>Types precedence order</b>. To improve readability when
writing types, we assume the following precedence order between
operators on types.</p>
<table summary="" border="1">
<tbody>
<tr>
<th colspan="1">#</th>
<th colspan="1">Operator</th>
</tr>
<tr>
<td>1</td>
<td>| (choice)</td>
</tr>
<tr>
<td>2</td>
<td>&amp; (interleaving)</td>
</tr>
<tr>
<td>3</td>
<td>, (sequence)</td>
</tr>
<tr>
<td>4</td>
<td>*, +, ? (occurrence)</td>
</tr>
</tbody>
</table>
<p>Parenthesis can be used to enforce precedence. For instance</p>
<div class="exampleInner">
<pre>
  xs:string | xs:integer, xs:float*
</pre></div>
<p>is equivalent to</p>
<div class="exampleInner">
<pre>
  xs:string | (xs:integer, (xs:float*))
</pre></div>
<p>and a different precedence can be obtained by writing</p>
<div class="exampleInner">
<pre>
  ((xs:string | xs:integer), xs:float)*
</pre></div>
<p><b>Examples</b></p>
<p><b>A sequence of elements</b></p>
<p>The "," operator builds the "sequence" of two types. For
example,</p>
<div class="exampleInner">
<pre>
  element title of type xs:string, element year of type xs:integer
</pre></div>
<p>is a sequence of an element title of type string followed by an
element year of type integer.</p>
<p><b>The union of two element types</b></p>
<p>The "|" operator builds the "union" of two types. For
example,</p>
<div class="exampleInner">
<pre>
  element editor of type xs:string | element bib:author
</pre></div>
<p>means either an element editor of type string, or a reference to
the global element <code>bib:author</code>.</p>
<p><b>An all group of two elements</b></p>
<p>The "&amp;" operator builds the "interleaved product" of two
types. For example,</p>
<div class="exampleInner">
<pre>
  (element a &amp; element b) =
    element a, element b
  | element b, element a
</pre></div>
<p>which specifies that the <code>a</code> and <code>b</code>
elements can occur in any order.</p>
<p><b>An empty type</b></p>
<p>The following type matches the empty sequence.</p>
<div class="exampleInner">
<pre>
  empty
</pre></div>
<p><b>A sequence of zero or more elements</b></p>
<p>The following type matches zero or more elements each of which
can be a <code>surgeon</code> or a <code>plumber</code>.</p>
<div class="exampleInner">
<pre>
  (element surgeon | element plumber)*
</pre></div>
<p><b>Notation</b></p>
<p>The grammar for <a href="#doc-fs-Type"><em>Type</em></a>
<span>describe</span> <span>described</span> above is general
enough to capture <span>the</span> type <span>infered</span>
<span>inferred</span> for <span>an</span> arbitrary
expression<span>, as well as to represent the content of an in
<a href="#xmlschema-1">[Schema Part 1]</a></span>. In a few cases,
inference rules rely on the fact that a given type is a type
validly describing the content of an element. To capture those
cases, we introduce the following auxiliary grammar productions to
describe more precisely the attribute declarations and the content
model for an element.</p>
<h5><a name="d6e3424" id="d6e3424"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-AttributeModel" id=
"doc-fs-AttributeModel"></a>[<small>42&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-AttributeModel">AttributeModel</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-AttributeType">AttributeType</a><br />
| (<a href="#doc-fs-AttributeType">AttributeType</a> "?")<br />
| (<a href="#doc-fs-AttributeModel">AttributeModel</a> "&amp;"
<a href="#doc-fs-AttributeModel">AttributeModel</a>)<br />
| "empty"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-ElementModel" id=
"doc-fs-ElementModel"></a>[<small>43&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-ElementModel">ElementModel</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-ElementType">ElementType</a><br />
| (<a href="#doc-fs-ElementType">ElementType</a> "?")<br />
| (<a href="#doc-fs-ElementModel">ElementModel</a> "&amp;" <a href=
"#doc-fs-ElementModel">ElementModel</a>)<br />
| "empty"<br />
| "none"</code></td>
</tr>
</tbody>
</table>
</div>
<div class="div3">
<h4><a name="sec_top_level_definitions" id=
"sec_top_level_definitions"></a>2.4.4 Top level definitions</h4>
<p>Top level definitions correspond to global element declarations,
global attribute declarations and type definitions in XML
Schema.</p>
<h5><a name="d6e3477" id="d6e3477"></a>Type Definitions</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-Definitions" id=
"doc-fs-Definitions"></a>[<small>40&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-Definitions">Definitions</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#doc-fs-Definition">Definition</a> Separator
<a href="#doc-fs-Definitions">Definitions</a>)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-Definition" id=
"doc-fs-Definition"></a>[<small>39&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-Definition">Definition</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("define" "element" <a href=
"#doc-fs-ElementName">ElementName</a> <a href=
"#doc-fs-OptSubstitution">OptSubstitution</a> <a href=
"#doc-fs-OptNillable">OptNillable</a> <a href=
"#doc-fs-TypeReference">TypeReference</a>)<br />
| ("define" "attribute" <a href=
"#doc-fs-AttributeName">AttributeName</a> <a href=
"#doc-fs-TypeReference">TypeReference</a>)<br />
| ("define" "type" <a href="#doc-fs-TypeName">TypeName</a> <a href=
"#doc-fs-TypeDerivation">TypeDerivation</a>)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-OptSubstitution" id=
"doc-fs-OptSubstitution"></a>[<small>76&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-OptSubstitution">OptSubstitution</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-fs-Substitution">Substitution</a>?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-Substitution" id=
"doc-fs-Substitution"></a>[<small>41&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-Substitution">Substitution</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"substitutes" "for" <a href=
"#doc-fs-ElementName">ElementName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-TypeDerivation" id=
"doc-fs-TypeDerivation"></a>[<small>33&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-TypeDerivation">TypeDerivation</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-fs-ComplexTypeDerivation">ComplexTypeDerivation</a> |
<a href="#doc-fs-AtomicTypeDerivation">AtomicTypeDerivation</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-ComplexTypeDerivation" id=
"doc-fs-ComplexTypeDerivation"></a>[<small>34&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-ComplexTypeDerivation">ComplexTypeDerivation</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-OptDerivation">OptDerivation</a>
<a href="#doc-fs-OptMixed">OptMixed</a> "{" <a href=
"#doc-fs-Type">Type</a>? "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-AtomicTypeDerivation" id=
"doc-fs-AtomicTypeDerivation"></a>[<small>35&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-AtomicTypeDerivation">AtomicTypeDerivation</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"restricts" <a href=
"#doc-fs-AtomicTypeName">AtomicTypeName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-OptDerivation" id=
"doc-fs-OptDerivation"></a>[<small>95&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-OptDerivation">OptDerivation</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-Derivation">Derivation</a>?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-Derivation" id=
"doc-fs-Derivation"></a>[<small>37&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-Derivation">Derivation</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("restricts" <a href=
"#doc-fs-TypeName">TypeName</a>)<br />
| ("extends" <a href="#doc-fs-TypeName">TypeName</a>)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-OptMixed" id=
"doc-fs-OptMixed"></a>[<small>74&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-OptMixed">OptMixed</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-Mixed">Mixed</a>?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-Mixed" id=
"doc-fs-Mixed"></a>[<small>38&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-Mixed">Mixed</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"mixed"</code></td>
</tr>
</tbody>
</table>
<p>A type definition has a name (possibly anonymous) and a type
derivation. In the case of a complex type, the derivation indicates
whether it is derived by extension or restriction, its base type,
and its content model, with an optional flag indicating if it has
mixed content.</p>
<p>Note the type system allows recursive types, following the rules
defined in <a href="#xmlschema-1">[Schema Part 1]</a>.</p>
<p><b>Example</b></p>
<p>For instance, the following complex type</p>
<div class="exampleInner">
<pre>
 &lt;complexType name="UKAddress"&gt;
   &lt;complexContent&gt;
     &lt;extension base="ipo:Address"&gt;
       &lt;sequence&gt;
         &lt;element name="postcode" type="ipo:UKPostcode"/&gt;
       &lt;/sequence&gt;
       &lt;attribute name="exportCode" type="positiveInteger" fixed="1"/&gt;
     &lt;/extension&gt;
   &lt;/complexContent&gt;
 &lt;/complexType&gt;
</pre></div>
<p>is represented as follows</p>
<div class="exampleInner">
<pre>
  define type UKAddress extends ipo:Address {
    attribute exportCode of type positiveInteger,
    element postcode of type ipo:UKPostcode
  };
</pre></div>
<p><b>Example</b></p>
<p>In the case of simple types derived by union or list, the
derivation is always a restriction from the base type
<code>xs:anySimpleType</code>, and has a content which is a union
of the member types, or a repetition of the item type. For
instance, the two following simple type declarations</p>
<div class="exampleInner">
<pre>
&lt;xsd:simpleType name="listOfMyIntType"&gt;
  &lt;xsd:list itemType="myInteger"/&gt;
&lt;/xsd:simpleType&gt;

&lt;xsd:simpleType name="zipUnion"&gt;
  &lt;xsd:union memberTypes="USState FrenchRegion"/&gt;
&lt;/xsd:simpleType&gt;
</pre></div>
<p>are represented as follows</p>
<div class="exampleInner">
<pre>
define type listOfMyIntType restricts xs:anySimpleType {
  myInteger*
}<span>;</span>

define type zipUnion restricts xs:anySimpleType {
  USState | FrenchRegion
}<span>;</span>
</pre></div>
<p><b>Example</b></p>
<p>In the case of an atomic type, it just indicates its base type.
For instance, the following type definition</p>
<div class="exampleInner">
<pre>
&lt;xsd:simpleType name="SKU"&gt;
 &lt;xsd:restriction base="xsd:string"&gt;
  &lt;xsd:pattern value="\d{3}-[A-Z]{2}"/&gt;
 &lt;/xsd:restriction&gt;
&lt;/xsd:simpleType&gt;
</pre></div>
<p>is represented as <span>follow</span> <span>follows</span></p>
<div class="exampleInner">
<pre>
  define type SKU restrict<span>s</span> xsd:string;
</pre></div>
<p><b>Example</b></p>
<p>When the type derivation is omitted, the type derives by
restriction from <code>xs:anyType</code>. For instance<span>, the
following two type definitions are equivalent</span>:</p>
<div class="exampleInner">
<pre>
  define type Bib { element book* }<span>;</span><span> =</span>
  define type Bib restricts xs:anyType { element book* }<span>;</span>
</pre></div>
<p><b>Example</b></p>
<p>Empty content can be indicated with the explicit empty sequence,
or omitted, as in:</p>
<div class="exampleInner">
<pre>
  define type Bib { }<span>;</span><span> =</span>
  define type Bib { empty }<span>;</span>
</pre></div>
<p>Global element and attribute declarations always have a name and
a reference to a (possibly anonymous) type. A global element
declaration also may declare a substitution group for the element
and whether the element is nillable.</p>
<p><b>Example</b></p>
<p>A type declaration with one element <code>name</code> of type
<code>xs:string</code> followed by one or more elements
<code>street</code> of type <code>xs:string</code>.</p>
<div class="exampleInner">
<pre>
  define type Address {
    element name of type xs:string,
    element street of type xs:string+
  }
</pre></div>
<p><b>Example</b></p>
<p>A type declaration with complex content derived by extension</p>
<div class="exampleInner">
<pre>
  define type USAddress extends Address {
    element zip of type xs:integer
  }
</pre></div>
<p><b>Example</b></p>
<p>A type declaration with mixed content</p>
<div class="exampleInner">
<pre>
  define type Section mixed {
    (element h1 of type xs:string |
     element p of type xs:string |
     element div of type Section)*
  }
</pre></div>
<p><b>Example</b></p>
<p>A type declaration with simple content derived by
restriction</p>
<div class="exampleInner">
<pre>
  define type SKU restricts xs:string
</pre></div>
<p><b>Example</b></p>
<p>An element declaration</p>
<div class="exampleInner">
<pre>
  define element address of type Address
</pre></div>
<p><b>Example</b></p>
<p>An element declaration with a substitution group</p>
<div class="exampleInner">
<pre>
  define element usaddress substitutes for address of type USAddress
</pre></div>
<p><b>Example</b></p>
<p>An element declaration which is nillable</p>
<div class="exampleInner">
<pre>
  define element zip nillable of type xs:integer
</pre></div>
</div>
<div class="div3">
<h4><a name="sec_types_example" id="sec_types_example"></a>2.4.5
Example of a complete Schema</h4>
<p>Here is a schema describing purchase orders from <a href=
"#xmlschema-0">[XML Schema Part 0]</a>.</p>
<div class="exampleInner">
<pre>
  &lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
  
   &lt;xsd:annotation&gt;
    &lt;xsd:documentation xml:lang="en"&gt;
     Purchase order schema for Example.com.
     Copyright 2000 Example.com. All rights reserved.
    &lt;/xsd:documentation&gt;
   &lt;/xsd:annotation&gt;
  
   &lt;xsd:element name="purchaseOrder" type="PurchaseOrderType"/&gt;
  
   &lt;xsd:element name="comment" type="xsd:string"/&gt;
  
   &lt;xsd:complexType name="PurchaseOrderType"&gt;
    &lt;xsd:sequence&gt;
     &lt;xsd:element name="shipTo" type="USAddress"/&gt;
     &lt;xsd:element name="billTo" type="USAddress"/&gt;
     &lt;xsd:element ref="comment" minOccurs="0"/&gt;
     &lt;xsd:element name="items"  type="Items"/&gt;
    &lt;/xsd:sequence&gt;
    &lt;xsd:attribute name="orderDate" type="xsd:date"/&gt;
   &lt;/xsd:complexType&gt;
  
   &lt;xsd:complexType name="USAddress"&gt;
    &lt;xsd:sequence&gt;
     &lt;xsd:element name="name"   type="xsd:string"/&gt;
     &lt;xsd:element name="street" type="xsd:string"/&gt;
     &lt;xsd:element name="city"   type="xsd:string"/&gt;
     &lt;xsd:element name="state"  type="xsd:string"/&gt;
     &lt;xsd:element name="zip"    type="xsd:decimal"/&gt;
    &lt;/xsd:sequence&gt;
    &lt;xsd:attribute name="country" type="xsd:NMTOKEN" fixed="US"/&gt;
   &lt;/xsd:complexType&gt;
  
   &lt;xsd:complexType name="Items"&gt;
    &lt;xsd:sequence&gt;
     &lt;xsd:element name="item" minOccurs="0" maxOccurs="unbounded"&gt;
      &lt;xsd:complexType&gt;
        &lt;xsd:sequence&gt;
         &lt;xsd:element name="productName" type="xsd:string"/&gt;
         &lt;xsd:element name="quantity"&gt;
          &lt;xsd:simpleType&gt;
           &lt;xsd:restriction base="xsd:positiveInteger"&gt;
            &lt;xsd:maxExclusive value="100"/&gt;
           &lt;/xsd:restriction&gt;
          &lt;/xsd:simpleType&gt;
         &lt;/xsd:element&gt;
         &lt;xsd:element name="USPrice"  type="xsd:decimal"/&gt;
         &lt;xsd:element ref="comment"   minOccurs="0"/&gt;
         &lt;xsd:element name="shipDate" type="xsd:date" minOccurs="0"/&gt;
        &lt;/xsd:sequence&gt;
        &lt;xsd:attribute name="partNum" type="SKU" use="required"/&gt;
      &lt;/xsd:complexType&gt;
     &lt;/xsd:element&gt;
    &lt;/xsd:sequence&gt;
   &lt;/xsd:complexType&gt;
  
   &lt;!-- Stock Keeping Unit, a code for identifying products --&gt;
   &lt;xsd:simpleType name="SKU"&gt;
    &lt;xsd:restriction base="xsd:string"&gt;
     &lt;xsd:pattern value="\d{3}-[A-Z]{2}"/&gt;
    &lt;/xsd:restriction&gt;
   &lt;/xsd:simpleType&gt;
  
  &lt;/xsd:schema&gt;
</pre></div>
<p>Here is the mapping of the above schema into the [XPath/XQuery]
type system.</p>
<div class="exampleInner">
<pre>
  declare namespace xsd = "http://www.w3.org/2001/XMLSchema";

  define element purchaseOrder of type PurchaseOrderType;
 
  define element comment of type xsd:string;
  
  define type PurchaseOrderType {
    attribute orderDate of type xsd:date?,
    element shipTo of type USAddress,
    element billTo of type USAddress,
    element comment?,
    element items of type Items
  };

  define type USAddress {
    attribute country of type xsd:NMTOKEN,
    element name of type xsd:string,
    element street of type xsd:string,
    element city of type xsd:string,
    element state of type xsd:string,
    element zip of type xsd:decimal
  };

  define type Items {
    attribute partNum of type SKU,
    element item of type fs:anon1*
  };

  define type fs:anon1 {
    element productName of type xsd:string,
    element quantity of type fs:anon2,
    element USPrice of type xsd:decimal,
    element comment?,
    element shipDate of type xsd:date?
  };

  define type fs:anon2 restricts xsd:positiveInteger;

  define type SKU restrict xsd:string;
</pre></div>
<p>Note that the two anonymous types in the <code>item</code>
element declarations are mapping to types with names
<em>fs:</em>anon<sub><font size="2">1</font></sub> and
<em>fs:</em>anon<sub><font size="2">2</font></sub>.</p>
<p>The following additional definitions illustrate how more
advanced XML Schema features (a complex type derived by extension,
an anonymous simple type derived by restriction, and substitution
groups) are represented in the [XPath/XQuery] type system.</p>
<div class="exampleInner">
<pre>
  &lt;complexType name="NYCAddress"&gt;
    &lt;complexContent&gt;
     &lt;extension base="USAddress"&gt;
      &lt;sequence&gt;
       &lt;element ref="apt"/&gt;
      &lt;/sequence&gt;
     &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;

  &lt;element name="apt"&gt;
    &lt;xsd:simpleType&gt;
     &lt;xsd:restriction base="xsd:positiveInteger"&gt;
      &lt;xsd:maxExclusive value="10000"/&gt;
     &lt;/xsd:restriction&gt;
    &lt;/xsd:simpleType&gt;
  &lt;/element&gt;

  &lt;element name="usaddress" substitutionGroup="address" type="USAddress"/&gt;
  &lt;element name="nycaddress" substitutionGroup="usaddress" type="NYCAddress"/&gt;
</pre></div>
<p>The above definitions are mapped into the [XPath/XQuery] type
system as follows:</p>
<div class="exampleInner">
<pre>
  define type NYCAddress extends USAddress {
    element apt
  }<span>;</span>

  define element apt of type fs:anon3<span>;</span>

  define type fs:anon3 restricts xsd:positiveInteger<span>;</span>

  define element usaddress  substitutes for address of type USAddress<span>;</span>
  define element nycaddress substitutes for usaddress of type NYCAddress<span>;</span>
</pre></div>
</div>
</div>
<div class="div2">
<h3><a name="sec_fando" id="sec_fando"></a>2.5 Functions and
operators</h3>
<p>The <a href="#xpath-functions-11">[Functions and Operators
1.1]</a> document defines built-in functions available in
[XPath/XQuery]. A number of these functions are used to define the
[XPath/XQuery] semantics; those functions are listed in <a href=
"#sec_used_functions"><b>[C.1 Functions and Operators used in the
Formal Semantics]</b></a>.</p>
<p>Many functions in the <a href="#xpath-functions-11">[Functions
and Operators 1.1]</a> document are <em>generic</em>: they perform
operations on arbitrary components of the data model, e.g., any
kind of node, or any sequence of items. For instance, the
<code>fn:unordered</code> <span>function</span> returns its input
sequence in an implementation-dependent order. The signature of the
<code>fn:unordered</code> function takes arbitrary items as input
and output:</p>
<div class="exampleInner">
<pre>
  fn:unordered($sourceSeq as item()*) as item()*
</pre></div>
<p>As defined, this signature provides little useful type
information. For such functions, better type information can often
be obtained by having the output type depend on the type of input
parameters. For instance, if the function <code>fn:unordered</code>
is applied on a sequence of <code>a</code> elements, the result is
also a sequence of <code>a</code> elements.</p>
<p>In order to provide better static typing for those functions,
specific static typing rules are given in <a href=
"#sec_special_functions"><b>[7 Additional Semantics of
Functions]</b></a>.</p>
</div>
</div>
<div class="div1">
<h2><a name="id-basics" id="id-basics"></a>3 Basics</h2>
<p>The organization of this section parallels the organization of
<a href="http://www.w3.org/TR/xquery#id-basics">Section 2
Basics</a><sup><small>XQ</small></sup>.</p>
<div class="div2">
<h3><a name="sec_context" id="sec_context"></a>3.1 Expression
Context</h3>
<p><b>Introduction</b></p>
<p>The expression context for a given expression consists of all
the information that can affect the result of the expression. This
information is organized into the <em>static context</em> and the
<em>dynamic context</em>. This section specifies the environments
that represent the context information used by [XPath/XQuery]
expressions.</p>
<div class="div3">
<h4><a name="static_context" id="static_context"></a>3.1.1 Static
Context</h4>
<p><b>Notation</b></p>
<p>We introduce the following auxiliary grammar production to
describe function signatures.</p>
<h5><a name="d6e3859" id="d6e3859"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-FunctionSig" id=
"doc-fs-FunctionSig"></a>[<small>85&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-FunctionSig">FunctionSig</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "function" expanded-QName "(" <a href=
"#doc-fs-TypeList">TypeList</a>? ")" "as" <a href=
"#doc-fs-Type">Type</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-TypeList" id=
"doc-fs-TypeList"></a>[<small>86&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-TypeList">TypeList</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-Type">Type</a> ("," <a href=
"#doc-fs-Type">Type</a>)*</code></td>
</tr>
</tbody>
</table>
<p>In the static (and dynamic) context, each function is uniquely
identified by its expanded QName and its arity (number of
parameters). We introduce the auxilliary symbol
<em>FunctionKey</em> to encapsulate this combination.</p>
<h5><a name="d6e3886" id="d6e3886"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-FunctionKey" id=
"doc-fs-FunctionKey"></a>[<small>92&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-FunctionKey">FunctionKey</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>expanded-QName "," Arity</code></td>
</tr>
</tbody>
</table>
<p>(<em>Arity</em> is understood to be a non-negative integer.)</p>
<p id="xq_stat_env"><a href="#xq_stat_env_def" class=
"env">statEnv</a> denotes the environment available during static
analysis. Static analysis may extend parts of the static
environment. The static environment is also available during
dynamic evaluation.</p>
<p>If analysis of an expression relies on some component of the
static context that has not been assigned a value, a static error
is raised.</p>
<p id="xq_stat_env_def">The following environment components are
part of the static environment:</p>
<table summary="" class="figure" cellpadding="5">
<col width="10%" span="1" />
<col width="15%" span="1" />
<col width="65%" align="justify" span="1" />
<col width="10%" span="1" />
<tbody>
<tr>
<td></td>
<td valign="top"><a href="#xq_stat_env_def" class=
"env">statEnv</a>.<a href="#xq_xpath_compat_flag" class=
"env">xpath1.0_compatibility</a></td>
<td>
<table summary="">
<tbody>
<tr>
<td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_xpath_compat_flag" class="env">xpath1.0_compatibility</a>
environment component designates the <b>XPath 1.0 compatibility
flag</b> in the [XPath/XQuery] static context. It specifies whether
the semantic rules for backward compatibility with XPath 1.0 are in
effect. This document defines the formal semantics for XPath 2.0
only when the XPath 1.0 backward compatibility rules are not in
effect.</td>
</tr>
</tbody>
</table>
</td>
<td></td>
</tr>
<tr>
<td></td>
<td valign="top"><a href="#xq_stat_env_def" class=
"env">statEnv</a>.<a href="#xq_ns_env" class=
"env">namespace</a></td>
<td><a name="term_active" id="term_active"></a>
<table summary="">
<tbody>
<tr>
<td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_ns_env" class="env">namespace</a> environment component
designates the <b>statically known namespaces</b> in the
[XPath/XQuery] static context.</td>
</tr>
<tr>
<td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_ns_env" class="env">namespace</a> environment component maps a
namespace prefix (<em>NCName</em>) onto a <b>namespace kind</b> and
a namespace URI (<em>AnyURI</em>), the null namespace
(#NULL-NAMESPACE), or (#UNDECLARED). The namespace kind is either
<b>passive</b> or <b>active</b>. The namespace kind determines
whether a namespace node is created for an element during element
construction. The (#UNDECLARED) value may be used to indicate that
the prefix has been undeclared, and may occur only if the
implementation supports <a href="#XMLNAMES11">[XML Names
1.1]</a>.</td>
</tr>
</tbody>
</table>
</td>
<td></td>
</tr>
<tr>
<td></td>
<td valign="top"><a href="#xq_stat_env_def" class=
"env">statEnv</a>.<a href="#xq_default_elem_ns_env" class=
"env">default_elem_namespace</a></td>
<td>
<table summary="">
<tbody>
<tr>
<td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_default_elem_ns_env" class="env">default_elem_namespace</a>
environment component designates the <b>default element/type
namespace</b> in the [XPath/XQuery] static context.</td>
</tr>
<tr>
<td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_default_elem_ns_env" class="env">default_elem_namespace</a>
environment component contains a namespace URI (a <em>AnyURI</em>)
or the null namespace (#NULL-NAMESPACE) and is used for any
unprefixed QName appearing in a position where an element or type
name is expected.</td>
</tr>
</tbody>
</table>
</td>
<td></td>
</tr>
<tr>
<td></td>
<td valign="top"><a href="#xq_stat_env_def" class=
"env">statEnv</a>.<a href="#xq_default_fn_ns_env" class=
"env">default_function_namespace</a></td>
<td>
<table summary="">
<tbody>
<tr>
<td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_default_fn_ns_env" class="env">default_function_namespace</a>
environment component designates the <b>default function
namespace</b> in the [XPath/XQuery] static context.</td>
</tr>
<tr>
<td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_default_fn_ns_env" class="env">default_function_namespace</a>
environment component contains a namespace URI (a <em>AnyURI</em>)
or the null namespace (#NULL-NAMESPACE) and is used for any
unprefixed QName appearing as the function name in a function
call.</td>
</tr>
</tbody>
</table>
</td>
<td></td>
</tr>
<tr>
<td></td>
<td valign="top"><a href="#xq_stat_env_def" class=
"env">statEnv</a>.<a href="#xq_type_defn" class=
"env">typeDefn</a></td>
<td>
<table summary="">
<tbody>
<tr>
<td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_type_defn" class="env">typeDefn</a> environment component
designates the <b>in-scope schema types</b> in the [XPath/XQuery]
static context.</td>
</tr>
<tr>
<td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_type_defn" class="env">typeDefn</a> environment component maps
expanded type names (expanded <a href=
"#doc-fs-TypeName"><em>TypeName</em></a>s) onto their type
definition (<a href=
"#sec_top_level_definitions"><em>Definition</em></a>). A type name
may be globally declared or anonymous.</td>
</tr>
</tbody>
</table>
</td>
<td></td>
</tr>
<tr>
<td></td>
<td valign="top"><a href="#xq_stat_env_def" class=
"env">statEnv</a>.<a href="#xq_elem_decl" class=
"env">elemDecl</a></td>
<td>
<table summary="">
<tbody>
<tr>
<td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_elem_decl" class="env">elemDecl</a> environment component
designates the <b>in-scope element declarations</b> in the
[XPath/XQuery] static context.</td>
</tr>
<tr>
<td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_elem_decl" class="env">elemDecl</a> environment component maps
expanded element names (expanded <a href=
"#doc-fs-ElementName"><em>ElementName</em></a>s) onto their
declaration (<a href=
"#sec_top_level_definitions"><em>Definition</em></a>).</td>
</tr>
</tbody>
</table>
</td>
<td></td>
</tr>
<tr>
<td></td>
<td valign="top"><a href="#xq_stat_env_def" class=
"env">statEnv</a>.<a href="#xq_attr_decl" class=
"env">attrDecl</a></td>
<td>
<table summary="">
<tbody>
<tr>
<td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_attr_decl" class="env">attrDecl</a> environment component
designates the <b>in-scope attribute declarations</b> in the
[XPath/XQuery] static context.</td>
</tr>
<tr>
<td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_attr_decl" class="env">attrDecl</a> environment component maps
expanded attribute names (expanded <a href=
"#doc-fs-AttributeName"><em>AttributeName</em></a>s) onto their
declaration (<a href=
"#sec_top_level_definitions"><em>Definition</em></a>).</td>
</tr>
</tbody>
</table>
</td>
<td></td>
</tr>
<tr>
<td></td>
<td valign="top"><a href="#xq_stat_env_def" class=
"env">statEnv</a>.<a href="#xq_type_env" class=
"env">varType</a></td>
<td>
<table summary="">
<tbody>
<tr>
<td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_type_env" class="env">varType</a> environment component
designates the <b>in-scope variables</b> in the [XPath/XQuery]
static context.</td>
</tr>
<tr>
<td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_type_env" class="env">varType</a> environment component maps
expanded variable names (expanded <em>VarName</em>) to their static
type (<a href="#doc-fs-Type"><em>Type</em></a>).</td>
</tr>
<tr>
<td>The <b>context item static type</b> in the [XPath/XQuery]
static context is represented by the binding of the variable
<a href=
"#fs_builtin_vars"><code>$</code><em>fs:</em><code>dot</code></a>
to its corresponding type in <a href="#xq_stat_env_def" class=
"env">statEnv</a>.<a href="#xq_type_env" class=
"env">varType</a>.</td>
</tr>
</tbody>
</table>
</td>
<td></td>
</tr>
<tr>
<td></td>
<td valign="top"><a href="#xq_stat_env_def" class=
"env">statEnv</a>.<a href="#xq_functy_env" class=
"env">funcType</a></td>
<td>
<table summary="">
<tbody>
<tr>
<td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_functy_env" class="env">funcType</a> environment component
designates the <b>function signatures</b> in the [XPath/XQuery]
static context.</td>
</tr>
<tr>
<td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_functy_env" class="env">funcType</a> environment component
stores the static type signatures of functions. Because
[XPath/XQuery] allows multiple functions with the same name
differing in the number of parameters, this environment component
maps <span>a <em>FunctionKey</em> (an expanded <em>QName</em> and
arity)</span> to a function signature <em>FunctionSig</em>.</td>
</tr>
</tbody>
</table>
</td>
<td></td>
</tr>
<tr>
<td></td>
<td valign="top"><a href="#xq_stat_env_def" class=
"env">statEnv</a>.<a href="#xq_collations_env" class=
"env">collations</a></td>
<td>
<table summary="">
<tbody>
<tr>
<td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_collations_env" class="env">collations</a> environment
component designates the <b>statically known collations</b> in the
[XPath/XQuery] static context.</td>
</tr>
<tr>
<td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_collations_env" class="env">collations</a> environment
component maps a unique namespace URI (a <em>AnyURI</em>) to a pair
of functions: the first function takes a set of strings and returns
a sequence containing those strings in sorted order; and the second
function takes two strings, returns true if they are considered
equal, and false if not.</td>
</tr>
</tbody>
</table>
</td>
<td></td>
</tr>
<tr>
<td></td>
<td valign="top"><a href="#xq_stat_env_def" class=
"env">statEnv</a>.<a href="#xq_default_collation_env" class=
"env">defaultCollation</a></td>
<td>
<table summary="">
<tbody>
<tr>
<td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_default_collation_env" class="env">defaultCollation</a>
environment component designates the <b>default collation</b> in
the [XPath/XQuery] static context.</td>
</tr>
<tr>
<td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_default_collation_env" class="env">defaultCollation</a>
environment component is a pair of functions as described in
<a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_collations_env" class="env">collations</a> above.</td>
</tr>
</tbody>
</table>
</td>
<td></td>
</tr>
<tr>
<td></td>
<td valign="top"><a href="#xq_stat_env_def" class=
"env">statEnv</a>.<a href="#xq_construction_mode_env" class=
"env">constructionMode</a></td>
<td>
<table summary="">
<tbody>
<tr>
<td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_construction_mode_env" class="env">constructionMode</a>
environment component designates the <b>construction mode</b> in
the [XPath/XQuery] static context.</td>
</tr>
<tr>
<td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_construction_mode_env" class="env">constructionMode</a>
environment component is one of <b>preserve</b> or
<b>strip</b>.</td>
</tr>
</tbody>
</table>
</td>
<td></td>
</tr>
<tr>
<td></td>
<td valign="top"><a href="#xq_stat_env_def" class=
"env">statEnv</a>.<a href="#xq_ordering_mode_env" class=
"env">orderingMode</a></td>
<td>
<table summary="">
<tbody>
<tr>
<td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_ordering_mode_env" class="env">orderingMode</a> environment
component designates the <b>ordering mode</b> in the [XPath/XQuery]
static context.</td>
</tr>
<tr>
<td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_ordering_mode_env" class="env">orderingMode</a> environment
component is one of <b>ordered</b> or <b>unordered</b>.</td>
</tr>
</tbody>
</table>
</td>
<td></td>
</tr>
<tr>
<td></td>
<td valign="top"><a href="#xq_stat_env_def" class=
"env">statEnv</a>.<a href="#xq_default_empty_order" class=
"env">defaultEmptySequenceOrder</a></td>
<td>
<table summary="">
<tbody>
<tr>
<td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_default_empty_order" class="env">defaultEmptySequenceOrder</a>
environment component designates the <b>default order for empty
sequences</b> in the [XPath/XQuery] static context.</td>
</tr>
<tr>
<td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_default_empty_order" class="env">defaultEmptySequenceOrder</a>
environment component controls whether an empty sequence is
interpreted as the greatest value or as the least value during
processing of an <code>order by</code> clause in a FLWOR
expression. Its value may be <code>greatest</code> or
<code>least</code>.</td>
</tr>
</tbody>
</table>
</td>
<td></td>
</tr>
<tr>
<td></td>
<td valign="top"><a href="#xq_stat_env_def" class=
"env">statEnv</a>.<a href="#xq_boundary_space" class=
"env">boundarySpace</a></td>
<td>
<table summary="">
<tbody>
<tr>
<td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_boundary_space" class="env">boundarySpace</a> environment
component designates the <b>boundary-space policy</b> in the
[XPath/XQuery] static context.</td>
</tr>
<tr>
<td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_boundary_space" class="env">boundarySpace</a> environment
component controls the processing of boundary whitespace by element
constructors. Its value may be <code>preserve</code> or
<code>strip</code>.</td>
</tr>
</tbody>
</table>
</td>
<td></td>
</tr>
<tr>
<td></td>
<td valign="top"><a href="#xq_stat_env_def" class=
"env">statEnv</a>.<a href="#xq_copy_namespaces_mode" class=
"env">copyNamespacesMode</a></td>
<td>
<table summary="">
<tbody>
<tr>
<td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_copy_namespaces_mode" class="env">copyNamespacesMode</a>
environment component designates the <b>copy-namespaces mode</b> in
the [XPath/XQuery] static context.</td>
</tr>
<tr>
<td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_copy_namespaces_mode" class="env">copyNamespacesMode</a>
environment component controls the namespace bindings that are
assigned when an existing element node is copied by an element
constructor. Its value consists of two parts: <code>preserve</code>
or <code>no-preserve</code>, and <code>inherit</code> or
<code>no-inherit</code>.</td>
</tr>
</tbody>
</table>
</td>
<td></td>
</tr>
<tr>
<td></td>
<td valign="top"><a href="#xq_stat_env_def" class=
"env">statEnv</a>.<a href="#xq_base_uri_env" class=
"env">baseURI</a></td>
<td>
<table summary="">
<tbody>
<tr>
<td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_base_uri_env" class="env">baseURI</a> environment component
designates the <b>base URI</b> in the [XPath/XQuery] static
context.</td>
</tr>
<tr>
<td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_base_uri_env" class="env">baseURI</a> environment component
contains a unique namespace URI (a <em>AnyURI</em>).</td>
</tr>
</tbody>
</table>
</td>
<td></td>
</tr>
<tr>
<td></td>
<td valign="top"><a href="#xq_stat_env_def" class=
"env">statEnv</a>.<a href="#xq_doc_type_env" class=
"env">docType</a></td>
<td>
<table summary="">
<tbody>
<tr>
<td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_doc_type_env" class="env">docType</a> environment component
designates the <b>statically known documents</b> in the
[XPath/XQuery] static context. It contains the static type for the
input documents, and is used to provide the static type to the
<code>fn:doc</code> function.</td>
</tr>
<tr>
<td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_doc_type_env" class="env">docType</a> environment component
contains bindings from input URIs (a <em>AnyURI</em>) to types (a
<a href="#doc-fs-Type"><em>Type</em></a>).</td>
</tr>
</tbody>
</table>
</td>
<td></td>
</tr>
<tr>
<td></td>
<td valign="top"><a href="#xq_stat_env_def" class=
"env">statEnv</a>.<a href="#xq_collection_type_env" class=
"env">collectionType</a></td>
<td>
<table summary="">
<tbody>
<tr>
<td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_collection_type_env" class="env">collectionType</a>
environment component designates the <b>statically known
collections</b> in the [XPath/XQuery] static context. It contains
the static type for the input collections, and is used to provide
the static type to the <code>fn:collection</code> function.</td>
</tr>
<tr>
<td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_collection_type_env" class="env">collectionType</a>
environment component contains bindings from input URIs (a
<em>AnyURI</em>) to types (a <a href=
"#doc-fs-Type"><em>Type</em></a>).</td>
</tr>
</tbody>
</table>
</td>
<td></td>
</tr>
<tr>
<td></td>
<td valign="top"><a href="#xq_stat_env_def" class=
"env">statEnv</a>.<a href="#xq_default_collection_type_env" class=
"env">defaultCollectionType</a></td>
<td>
<table summary="">
<tbody>
<tr>
<td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_default_collection_type_env" class=
"env">defaultCollectionType</a> environment component designates
the <b>statically known default collection type</b> in the
[XPath/XQuery] static context. It contains the static type for the
default collection, and is used to provide the static type to the
<code>fn:collection</code> function when called with no
arguments.</td>
</tr>
<tr>
<td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_default_collection_type_env" class=
"env">defaultCollectionType</a> environment component contains type
(a <a href="#doc-fs-Type"><em>Type</em></a>).</td>
</tr>
</tbody>
</table>
</td>
<td></td>
</tr>
</tbody>
</table>
<p>Note that the boundary-space behavior is not formally specified
in this document.</p>
<p id="xq_default_stat_env">An initial environment is set up when
[expression/query] processing begins, containing, for example, the
function signatures of all built-in functions. The initial values
for the static context are defined in <a href=
"http://www.w3.org/TR/xquery#id-xq-context-components">Section C
Context Components</a><sup><small>XQ</small></sup> and <a href=
"http://www.w3.org/TR/xpath20/#id-xp-context-components">Section C
Context Components</a><sup><small>XP</small></sup> and is denoted
by <a href="#xq_default_stat_env" class="env">statEnvDefault</a> in
the Formal Semantics.</p>
<p>Here is an example that shows how the static environment is
modified in response to a namespace definition.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>URILiteral</em> <a href=
"#jd_has_atomic_value" class="judgment"><b>has atomic value</b></a>
<em>AnyURI</em></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a> + <a href=
"#xq_ns_env" class="env">namespace</a>(<em>NCName</em> =&gt;
(passive, <em>AnyURI</em>)) <b>&#160;|-&#160;</b><em>Expr</em>
<a href="#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><code>declare
namespace</code> <em>NCName</em> = <em>URILiteral</em>;
<em>Expr</em> <a href="#jd_has_type" class="judgment"><b>:</b></a>
<a href="#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
<br /></div>
<p>This rule reads as follows: "the phrase on the bottom (a
namespace declaration in the query prolog followed by an
expression) is well-typed (accepted by the static typing rules)
within an environment <a href="#xq_stat_env_def" class=
"env">statEnv</a> <em>if</em> the expression above the line is
well-typed in the environment obtained from <a href=
"#xq_stat_env_def" class="env">statEnv</a> by adding the namespace
declaration".</p>
<p id="fs_activeNS">The helper function <a href=
"#fs_activeNS">fs:<code>active_ns</code></a>(<a href=
"#xq_stat_env_def" class="env">statEnv</a>) returns all the active
in-scope namespaces in the given static environment.</p>
<p id="fs_ns_from_items">For each attribute and element node in
<a href="#doc-fs-Value"><em>Value</em></a>, such that the node has
name <a href="#id-expanded-qnames"><em>expanded-QName</em></a> in
the namespace <em>AnyURI</em>, the helper function <a href=
"#fs_ns_from_items">fs:<code>get_static_ns_from_items</code></a>(<a href="#xq_stat_env_def"
class="env">statEnv</a>, <a href=
"#doc-fs-Value"><em>Value</em></a>) returns the in-scope namespace
that corresponds to <em>AnyURI</em>. This is a reverse-lookup on
<a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_ns_env" class="env">namespace</a> by <em>AnyURI</em>.</p>
<div class="div4">
<h5><a name="id-expanded-qnames" id=
"id-expanded-qnames"></a>3.1.1.1 Resolving QNames to Expanded
QNames</h5>
<p>A common use of the static environment is to expand a
<em>QName</em> by looking up the URI that corresponds to the
QName's namespace prefix in the <a href="#xq_stat_env_def" class=
"env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a>
environment component and by constructing an <a href=
"http://www.w3.org/TR/xpath-datamodel/#dt-expanded-qname">expanded-QName</a><sup><small>DM</small></sup>,
which contains the URI and the QName's local part. Element and type
names may be in the null namespace, that is, there is no URI
associated with their namespace prefix. The null namespace is
denoted by the special value <code>#NULL-NAMESPACE</code>.</p>
<p>The auxiliary judgments below expand an element, type,
attribute, variable, or function <em>QName</em> by looking up the
namespace prefix in <a href="#xq_stat_env_def" class=
"env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a>
or, if the QName is unqualified, by using the appropriate default
namespace.</p>
<p><b>Notation</b></p>
<p id="jd_elem_qname_expands_to">The judgment</p>
<div align="center"><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>QName</em> <a href=
"#jd_elem_qname_expands_to" class="judgment"><b>of elem/type
expands to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></div>
<p>holds when the element or type QName expands to the given
expanded QName.</p>
<p id="jd_attr_qname_expands_to">The judgment</p>
<div align="center"><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>QName</em> <a href=
"#jd_attr_qname_expands_to" class="judgment"><b>of attr expands
to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></div>
<p>holds when the attribute QName expands to the given expanded
QName.</p>
<p>We use <em>Variable</em> to denote the expanded QNames of
variables.</p>
<p id="jd_var_qname_expands_to">The judgment</p>
<div align="center"><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>QName</em> <a href=
"#jd_var_qname_expands_to" class="judgment"><b>of var expands
to</b></a> <em>Variable</em></div>
<p>holds when the variable QName expands to the given expanded
QName.</p>
<p id="jd_func_qname_expands_to">The judgment</p>
<div align="center"><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>QName</em> <a href=
"#jd_func_qname_expands_to" class="judgment"><b>of func expands
to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></div>
<p>holds when the function QName expands to the given expanded
QName.</p>
<p><b>Semantics</b></p>
<p>Note that none of the inference rules can infer a resolved name
in the case a given namespace prefix is bound to the (#UNDECLARED)
value. As a result, namespace resolution will fail if the
implementation supports <a href="#XMLNAMES11">[XML Names 1.1]</a>
and a given namespace prefix has been undeclared.</p>
<p>An element or type QName consisting of a prefix NCName and a
local part NCName expands to the URI (or the null namespace)
corresponding to that prefix and the local part.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_ns_env" class=
"env">namespace</a>(<em>NCName</em><sub><font size=
"2">1</font></sub>) = (<a href=
"#xq_ns_env"><em>NamespaceKind</em></a>,<em>AnyURI-or-#NULL-NAMESPACE</em>)</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>NCName</em><sub><font size="2">1</font></sub>:<em>NCName</em><sub><font size="2">2</font></sub>
<a href="#jd_elem_qname_expands_to" class="judgment"><b>of
elem/type expands to</b></a> (<em>AnyURI-or-#NULL-NAMESPACE</em>,
<em>NCName</em><sub><font size="2">2</font></sub>)</td>
</tr>
</table>
<br /></div>
<p>An element or type QName consisting only of a local part NCName
expands to the default element/type namespace and the local
part.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_default_elem_ns_env" class="env">default_elem_namespace</a> =
<em>AnyURI-or-#NULL-NAMESPACE</em></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>NCName</em> <a href=
"#jd_elem_qname_expands_to" class="judgment"><b>of elem/type
expands to</b></a> (<em>AnyURI-or-#NULL-NAMESPACE</em>,
<em>NCName</em>)</td>
</tr>
</table>
<br /></div>
<p>An attribute QName consisting of a prefix NCName and a local
part NCName expands to the URI (or the null namespace)
corresponding to the prefix and the local part.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_ns_env" class=
"env">namespace</a>(<em>NCName</em><sub><font size=
"2">1</font></sub>) = (<a href=
"#xq_ns_env"><em>NamespaceKind</em></a>,<em>AnyURI-or-#NULL-NAMESPACE</em>)</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>NCName</em><sub><font size="2">1</font></sub>:<em>NCName</em><sub><font size="2">2</font></sub>
<a href="#jd_attr_qname_expands_to" class="judgment"><b>of attr
expands to</b></a> (<em>AnyURI-or-#NULL-NAMESPACE</em>,
<em>NCName</em><sub><font size="2">2</font></sub>)</td>
</tr>
</table>
<br /></div>
<p>An attribute QName consisting only of a local part NCName
expands to the null namespace and the local part.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>NCName</em> <a href=
"#jd_attr_qname_expands_to" class="judgment"><b>of attr expands
to</b></a> (#NULL-NAMESPACE, <em>NCName</em>)</td>
</tr>
</table>
<br /></div>
<p>A variable QName consisting of a prefix NCName and a local part
NCName expands to the URI that corresponds to the prefix and the
local part.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_ns_env" class=
"env">namespace</a>(<em>NCName</em><sub><font size=
"2">1</font></sub>) = (<a href=
"#xq_ns_env"><em>NamespaceKind</em></a>,<em>AnyURI</em>)</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>NCName</em><sub><font size="2">1</font></sub>:<em>NCName</em><sub><font size="2">2</font></sub>
<a href="#jd_var_qname_expands_to" class="judgment"><b>of var
expands to</b></a> (<em>AnyURI</em>,
<em>NCName</em><sub><font size="2">2</font></sub>)</td>
</tr>
</table>
<br /></div>
<p>A variable QName consisting only of a local part NCName expands
to the null namespace and the local part.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>NCName</em> <a href=
"#jd_var_qname_expands_to" class="judgment"><b>of var expands
to</b></a> (#NULL-NAMESPACE, <em>NCName</em>)</td>
</tr>
</table>
<br /></div>
<p>A function QName consisting of a prefix NCName and a local part
NCName expands to the URI that corresponds to the prefix and the
local part.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_ns_env" class=
"env">namespace</a>(<em>NCName</em><sub><font size=
"2">1</font></sub>) = (<a href=
"#xq_ns_env"><em>NamespaceKind</em></a>,<em>AnyURI</em>)</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>NCName</em><sub><font size="2">1</font></sub>:<em>NCName</em><sub><font size="2">2</font></sub>
<a href="#jd_func_qname_expands_to" class="judgment"><b>of func
expands to</b></a> (<em>AnyURI</em>,
<em>NCName</em><sub><font size="2">2</font></sub>)</td>
</tr>
</table>
<br /></div>
<p>A function QName consisting only of a local part NCName expands
to the default function namespace URI and the local part.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_default_fn_ns_env" class="env">default_function_namespace</a>
= <em>AnyURI</em></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>NCName</em> <a href=
"#jd_func_qname_expands_to" class="judgment"><b>of func expands
to</b></a> (<em>AnyURI</em>, <em>NCName</em>)</td>
</tr>
</table>
<br /></div>
</div>
</div>
<div class="div3">
<h4><a name="eval_context" id="eval_context"></a>3.1.2 Dynamic
Context</h4>
<p id="xq_dyn_env_def"><a href="#xq_dyn_env_def" class=
"env">dynEnv</a> denotes the environment available during dynamic
evaluation. Dynamic evaluation may extend parts of the dynamic
environment.</p>
<p>If evaluation of an expression relies on some component of the
dynamic context that has not been assigned a value, a dynamic error
is raised.</p>
<p>The following environment components are part of the dynamic
environment:</p>
<table summary="" class="figure" cellpadding="5">
<col width="10%" span="1" />
<col width="15%" span="1" />
<col width="65%" align="justify" span="1" />
<col width="10%" span="1" />
<tbody>
<tr>
<td></td>
<td valign="top"><a href="#xq_dyn_env_def" class=
"env">dynEnv</a>.<a href="#xq_val_env" class=
"env">varValue</a></td>
<td>
<table summary="">
<tbody>
<tr>
<td>The <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href=
"#xq_val_env" class="env">varValue</a> environment component
corresponds to the <b>variable values</b>, the <b>context item</b>,
the <b>context position</b> and the <b>context size</b> in the
[XPath/XQuery] evaluation context.</td>
</tr>
<tr>
<td>The dynamic value environment component maps an expanded
variable name (expanded <em>VarName</em>) to the variable's value
(<a href="#doc-fs-Value"><em>Value</em></a>) or to the value
<code>#IMPORTED</code>(<em>AnyURI</em>), if the variable is defined
in the imported module with namespace <em>AnyURI</em>.</td>
</tr>
</tbody>
</table>
</td>
<td></td>
</tr>
<tr>
<td></td>
<td valign="top"><a href="#xq_dyn_env_def" class=
"env">dynEnv</a>.<a href="#xq_func_env" class=
"env">funcDefn</a></td>
<td>
<table summary="">
<tbody>
<tr>
<td>The <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href=
"#xq_func_env" class="env">funcDefn</a> environment component
corresponds to the <b>function implementations</b> (or definition)
part of the [XPath/XQuery] dynamic context.</td>
</tr>
<tr>
<td>The <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href=
"#xq_func_env" class="env">funcDefn</a> environment component maps
<span>a <em>FunctionKey</em> (expanded function name and
arity)</span> to the remainder of the corresponding function
definition. If the function is defined in <a href=
"#xpath-functions-11">[Functions and Operators 1.1]</a>, the
function definition is the value <code>#BUILT-IN</code>. If the
function is externally defined, the function definition is the
value <code>#EXTERNAL</code>. If the function is defined in the
imported module with namespace <em>AnyURI</em>, the function
definition is the value <code>#IMPORTED</code>(<em>AnyURI</em>). If
the function is locally declared, the function definition is of the
form "(<em>Expr</em>, <em>Variable</em><sub><font size=
"2">1</font></sub>,..., <em>Variable</em><sub><font size=
"2">n</font></sub>)", where <em>Expr</em> is the function body and
<em>Variable</em><sub><font size="2">1</font></sub>, ...,
<em>Variable</em><sub><font size="2">n</font></sub> are the
function parameters.</td>
</tr>
<tr>
<td>The initial function environment component (<a href=
"#xq_default_dyn_env" class="env">dynEnvDefault</a>.funcDefn) maps
the signatures of the internal functions defined in <a href=
"#sec_operators"><b>[C.2 Mapping of Overloaded Internal
Functions]</b></a> and the signatures of the functions defined in
<a href="#xpath-functions-11">[Functions and Operators 1.1]</a> to
<code>#BUILT-IN</code>.</td>
</tr>
</tbody>
</table>
</td>
<td></td>
</tr>
<tr>
<td></td>
<td valign="top"><a href="#xq_dyn_env_def" class=
"env">dynEnv</a>.<a href="#xq_date_time_env" class=
"env">dateTime</a></td>
<td>
<table summary="">
<tbody>
<tr>
<td>The <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href=
"#xq_date_time_env" class="env">dateTime</a> environment component
corresponds to the <b>current dateTime</b> in the [XPath/XQuery]
dynamic context.</td>
</tr>
</tbody>
</table>
</td>
<td></td>
</tr>
<tr>
<td></td>
<td valign="top"><a href="#xq_dyn_env_def" class=
"env">dynEnv</a>.<a href="#xq_timezone_env" class=
"env">timezone</a></td>
<td>
<table summary="">
<tbody>
<tr>
<td>The <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href=
"#xq_timezone_env" class="env">timezone</a> environment component
corresponds to the <b>implicit timezone</b> in the [XPath/XQuery]
dynamic context and is used by the timezone related functions in
<a href="#xpath-functions-11">[Functions and Operators
1.1]</a>.</td>
</tr>
</tbody>
</table>
</td>
<td></td>
</tr>
<tr>
<td></td>
<td valign="top"><a href="#xq_dyn_env_def" class=
"env">dynEnv</a>.<a href="#xq_doc_value_env" class=
"env">docValue</a></td>
<td>
<table summary="">
<tbody>
<tr>
<td>The <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href=
"#xq_doc_value_env" class="env">docValue</a> environment component
corresponds to the <b>available documents</b> in the [XPath/XQuery]
dynamic context. It contains the document nodes corresponding to
input documents, and is used to provide the dynamic value of the
<code>fn:doc</code> function.</td>
</tr>
<tr>
<td>The <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href=
"#xq_doc_value_env" class="env">docValue</a> environment component
contains bindings from input URIs (a <em>AnyURI</em>) to documents
(a <a href=
"#doc-fs-DocumentValue"><em>DocumentValue</em></a>).</td>
</tr>
</tbody>
</table>
</td>
<td></td>
</tr>
<tr>
<td></td>
<td valign="top"><a href="#xq_dyn_env_def" class=
"env">dynEnv</a>.<a href="#xq_collection_value_env" class=
"env">collectionValue</a></td>
<td>
<table summary="">
<tbody>
<tr>
<td>The <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href=
"#xq_collection_value_env" class="env">collectionValue</a>
environment component corresponds to the <b>available
collections</b> in the [XPath/XQuery] dynamic context. It contains
the root nodes corresponding to the input collections, and is used
to provide the dynamic value of the <code>fn:collection</code>
function.</td>
</tr>
<tr>
<td>The <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href=
"#xq_collection_value_env" class="env">collectionValue</a>
environment component contains bindings from input URIs (a
<em>AnyURI</em>) to a sequence of nodes.</td>
</tr>
</tbody>
</table>
</td>
<td></td>
</tr>
<tr>
<td></td>
<td valign="top"><a href="#xq_dyn_env_def" class=
"env">dynEnv</a>.<a href="#xq_default_collection_value_env" class=
"env">defaultCollectionValue</a></td>
<td>
<table summary="">
<tbody>
<tr>
<td>The <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href=
"#xq_default_collection_value_env" class=
"env">defaultCollectionValue</a> environment component corresponds
to the <b>default collection</b> in the [XPath/XQuery] dynamic
context. It contains the sequence of nodes corresponding to the
default collection, and is used to provide the dynamic value of the
<code>fn:collection</code> function when called with no
arguments.</td>
</tr>
<tr>
<td>The <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href=
"#xq_default_collection_value_env" class=
"env">defaultCollectionValue</a> environment component contains a
sequence of nodes.</td>
</tr>
</tbody>
</table>
</td>
<td></td>
</tr>
</tbody>
</table>
<p id="xq_default_dyn_env">The initial values for the dynamic
context are defined in <a href=
"http://www.w3.org/TR/xquery#id-xq-context-components">Section C
Context Components</a><sup><small>XQ</small></sup> and <a href=
"http://www.w3.org/TR/xpath20/#id-xp-context-components">Section C
Context Components</a><sup><small>XP</small></sup>. The
corresponding initial dynamic environment is denoted by <a href=
"#xq_default_dyn_env" class="env">dynEnvDefault</a> in the Formal
Semantics.</p>
<p id="fs_builtin_vars">The following Formal Semantics variables
represent the <b>context item</b>, <b>context position</b>, and
<b>context size</b> properties of the dynamic context:</p>
<table summary="" border="1">
<tbody>
<tr>
<td>Built-in Variable&#160;&#160;</td>
<td>Represents:</td>
</tr>
<tr>
<td><a href=
"#fs_builtin_vars"><code>$</code><em>fs:</em><code>dot</code></a></td>
<td>context item</td>
</tr>
<tr>
<td><a href=
"#fs_builtin_vars"><code>$</code><em>fs:</em><code>position</code></a></td>
<td>context position</td>
</tr>
<tr>
<td><a href=
"#fs_builtin_vars"><code>$</code><em>fs:</em><code>last</code></a></td>
<td>context size</td>
</tr>
</tbody>
</table>
<p>Within this document, variables with the "fs" prefix are
reserved for use in the formal specification. Values of <a href=
"#fs_builtin_vars"><code>$</code><em>fs:</em><code>position</code></a>
and <a href=
"#fs_builtin_vars"><code>$</code><em>fs:</em><code>last</code></a>
can be obtained by invoking the <code>fn:position</code> and
<code>fn:last</code> functions, respectively. Note that the type
for those variables is obtained as for any other variables. As
expected the type of <a href=
"#fs_builtin_vars"><code>$</code><em>fs:</em><code>position</code></a>
and <a href=
"#fs_builtin_vars"><code>$</code><em>fs:</em><code>last</code></a>
is always <code>xs:integer</code> while the type of <a href=
"#fs_builtin_vars"><code>$</code><em>fs:</em><code>dot</code></a>
depends on the context in which it is being used.</p>
</div>
</div>
<div class="div2">
<h3><a name="id-processing-model" id="id-processing-model"></a>3.2
Processing Model</h3>
<p>This section reviews the processing model for [XPath/XQuery].
The [XPath/XQuery] processing model is defined normatively in
<a href="http://www.w3.org/TR/xquery#id-processing-model">Section
2.2 Processing Model</a><sup><small>XQ</small></sup>. This section
also explains how the main notations (normalization rules, static
typing rules, and dynamic evaluation rules) relate to the phases in
that processing model.</p>
<div class="div3">
<h4><a name="id-fs-processing-model" id=
"id-fs-processing-model"></a>3.2.1 Processing model</h4>
<p>The following figure depicts the [XPath/XQuery] processing
model</p>
<img src="ProcMod-XQuery.gif" alt="Processing Model Overview" />
<p>Figure 1: Processing Model Overview</p>
<p>This processing model is not intended to describe an actual
implementation, although a naive implementation might be based upon
it. It does not prescribe an implementation technique, but any
implementation should produce the same results as obtained by
following this processing model and applying the rest of the Formal
Semantics specification.</p>
<p>Query processing consists of two phases: a static analysis phase
and a dynamic evaluation phase. Static analysis is further divided
into four sub-phases. Typically, each phase consumes the result of
the previous phase and generates output for the next phase. When
processing query prologs, these phases may be mutually dependent
(See <a href="#id-query-prolog"><b>[5 Modules and
Prologs]</b></a>). For each processing phase, we point to the
relevant notations introduced later in the document.</p>
<p>[<a name="dt-static-analysis" id="dt-static-analysis" title=
"static analysis phase">Definition</a>: The <b>static analysis
phase</b> depends on the expression itself and on the static
context. The <b>static analysis phase</b> does not depend on input
data (other than schemas).]</p>
<p>The purpose of the static analysis phase is to detect errors,
e.g., syntax errors or type errors, at compile time rather than at
run-time. If no error occurs, the result of static analysis could
be some compiled form of [expression/query], suitable for execution
by a compiled-[expression/query] processor. Static analysis
consists of the following sub-phases:</p>
<ol class="enumar">
<li>
<p id="processing_parsing"><b>Parsing.</b> (Step SQ1 in Figure 1).
The grammar for the [XPath/XQuery] syntax is defined in <a href=
"#xquery-11">[XQuery 1.1: An XML Query Language]</a>. Parsing may
generate syntax errors. If no error occurs, an internal operation
tree of the parsed query is created.</p>
</li>
<li>
<p id="processing_context"><b>Static Context Processing.</b> (Steps
SQ2, SQ3, and SQ4 in Figure 1). The static semantics of
[expression/query] depends on the input static context. The input
static context needs to be generated before the [expression/query]
can be analysed. In XQuery, the input static context may be defined
by the processing environment and by declarations in the Query
Prolog (See <a href="#id-query-prolog"><b>[5 Modules and
Prologs]</b></a>). In XPath, the input static context is defined by
the processing environment. The static context is denoted by
<a href="#xq_stat_env_def" class="env">statEnv</a>.</p>
</li>
<li>
<p id="processing_normalization"><b>Normalization.</b> (Step SQ5 in
Figure 1). To simplify the semantics specification, some
normalization is performed on the [expression/query]. The
[XPath/XQuery] language provides many powerful features that make
[expression/query]s simpler to write and use, but are also
redundant. For instance, a complex <code>for</code> expression
might be rewritten as a composition of several simple
<code>for</code> expressions. The language composed of these
simpler [expression/query] is called the [XPath/XQuery] <em>Core
language</em> and is described by a grammar which is a subset of
the XQuery grammar. The grammar of the [XPath/XQuery] Core language
is given in <a href="#sec_core"><b>[A Normalized core and formal
grammars]</b></a>.</p>
<p>During the normalization phase, each [XPath/XQuery]
[expression/query] is mapped into its equivalent [expression/query]
in the Core. (Note that this has nothing to do with Unicode
Normalization, which works on character strings.) Normalization
works by recursive application of the normalization rules over a
given expression.</p>
<p>Specifically the normalization phase is defined in terms of the
static part of the context (<a href="#xq_stat_env_def" class=
"env">statEnv</a>) and a [expression/query] (<em>Expr</em>)
abstract syntax tree. Formal notations for the normalization phase
are introduced in <a href="#sec_normalization"><b>[3.2.2
Normalization mapping rules]</b></a>.</p>
<p>After normalization, the full semantics is obtained by giving a
semantics to the normalized Core [expression/query]. This is done
during the last two phases.</p>
</li>
<li>
<p id="processing_static"><b>Static type analysis.</b> (Step SQ6 in
Figure 1). Static type analysis is optional. If this phase is not
supported, then normalization is followed directly by dynamic
evaluation.</p>
<p>Static type analysis checks whether each [expression/query] is
well-typed, and if so, determines its static type. Static type
analysis is defined only for Core [expression/query]. Static type
analysis works by recursive application of the static typing rules
over a given expression.</p>
<p>If the [expression/query] is not well-typed, static type
analysis yields a <em>type error</em>. For instance, a comparison
between an integer value and a string value might be detected as an
type error during the static type analysis. If static type analysis
succeeds, it yields an abstract syntax tree where each
sub-expression is associated with its static type.</p>
<p>More precisely, the static analysis phase is defined in terms of
the static context (<a href="#xq_stat_env_def" class=
"env">statEnv</a>) and a Core [expression/query]
(<em>CoreExpr</em>). Formal notations for the static analysis phase
are introduced in <a href="#sec_static"><b>[3.2.3 Static typing
judgment]</b></a>.</p>
<p>Static typing does not imply that the content of XML documents
must be rigidly fixed or even known in advance. The [XPath/XQuery]
type system accommodates "flexible" types, such as elements that
can contain any content. Schema-less documents are handled in
[XPath/XQuery] by associating a standard type with the document,
such that it may include any legal XML content.</p>
</li>
</ol>
<p>If the static analysis phase succeeds, the dynamic evaluation
phase (sometimes also called "execution") evaluates a query on
input document(s).</p>
<ol class="enumar">
<li>
<p id="dyn_processing_context"><b>Dynamic Context Processing.</b>
(Steps DQ2 and DQ3 in Figure 1).The dynamic semantics of
[expression/query] depends on the dynamic input context. The
dynamic input context needs to be generated before the
[expression/query] can be evaluated. The dynamic input context may
be defined by the processing environment and by statements in the
Query Prolog (See <a href="#id-query-prolog"><b>[5 Modules and
Prologs]</b></a>). In XPath, the dynamic input context is defined
by the processing environment. The static input context is denoted
by <a href="#xq_dyn_env_def" class="env">dynEnv</a>.</p>
</li>
<li>
<p id="processing_dynamic"><b>Dynamic Evaluation.</b> (Steps DQ4
and DQ5 in Figure 1). This phase computes the value of an
[expression/query]. The semantics of evaluation is defined only for
Core [expression/query] terms. The formal description of evaluation
works by recursive application of the dynamic evaluation rules over
a given expression. Evaluation may result in a value OR a dynamic
error, which may be a non-type error or a type error. If static
typing of an expression does not raise a type error, then dynamic
evaluation of the same expression will not raise a type error (and
thus dynamic type checking can be avoided when static typing is
enabled). Dynamic evaluation may still raise a non-type error.</p>
<p>The dynamic evaluation phase is defined in terms of the static
context (<a href="#xq_stat_env_def" class="env">statEnv</a>) and
evaluation context (<a href="#xq_dyn_env_def" class=
"env">dynEnv</a>), and a Core [expression/query]
(<em>CoreExpr</em>). Formal notations for the dynamic evaluation
phase are introduced in <a href="#sec_evaluation"><b>[3.2.4 Dynamic
evaluation judgment]</b></a>.</p>
</li>
</ol>
<p>Static type analysis catches only certain classes of errors. For
instance, it can detect a comparison operation applied between
incompatible types (e.g., <code>xs:int</code> and
<code>xs:date</code>). Some other classes of errors cannot be
detected by the static analysis and are only detected at evaluation
time. For instance, whether an arithmetic expression on 32 bit
integers (<code>xs:int</code>) yields an out-of-bound value can
only be detected at run-time by looking at the data.</p>
<p>While implementations are free to implement different processing
models, the [XPath/XQuery] static semantics relies on the existence
of a static type analysis phase that precedes any access to the
input data.</p>
<p>The above processing phases are all internal to the
[XPath/XQuery] processor. They do not deal with how the
[XPath/XQuery] processor interacts with the outside world, notably
how it accesses actual documents and types. A typical
[expression/query] engine would support at least three other
important processing phases:</p>
<ol class="enumar">
<li>
<p><b>Schema Import Processing.</b> The [XPath/XQuery] type system
is based on XML Schema. In order to perform dynamic or static
typing, the [XPath/XQuery] processor needs to build type
descriptions that correspond to the schema(s) of the input
documents. This phase is achieved by mapping all schemas required
by the [expression/query] into the [XPath/XQuery] type system. The
XML Schema import phase is described in <a href=
"#sec_importing_schema"><b>[D Importing Schemas]</b></a>.</p>
</li>
<li>
<p><b>Data Model Generation.</b> Expressions are evaluated on
values in the <a href="#xpath-datamodel-11">[Data Model]</a>. XML
documents must be loaded into the <a href=
"#xpath-datamodel-11">[Data Model]</a> before the evaluation phase.
This is described in the <a href="#xpath-datamodel-11">[Data
Model]</a> and is not discussed further here.</p>
</li>
<li>
<p><b>Serialization.</b> Once the [expression/query] is evaluated,
processors might want to serialize the result of the
[expression/query] as actual XML documents. Serialization of data
model instances is described in <a href=
"#xslt-xquery-serialization-11">[Data Model Serialization 1.1]</a>
and is not discussed further here.</p>
</li>
</ol>
<p>The parsing phase is not specified formally; the formal
semantics does not define a formal model for the syntax trees, but
uses the [XPath/XQuery] concrete syntax directly. More details
about parsing for XQuery 1.0 can be found in the <a href=
"#xquery-11">[XQuery 1.1: An XML Query Language]</a> document and
more details about parsing for XPath 2.0 can be found in the
<a href="#xpath-21">[XML Path Language (XPath) 2.1]</a> document.
No further discussion of parsing is included here.</p>
</div>
<div class="div3">
<h4><a name="sec_normalization" id="sec_normalization"></a>3.2.2
Normalization mapping rules</h4>
<p>Normalization is specified using <em>mapping</em> rules, which
describe how a [XPath/XQuery] expression is rewritten into an
expression in the [XPath/XQuery] Core. Mapping rules are also used
in <a href="#sec_importing_schema"><b>[D Importing Schemas]</b></a>
to specify how XML Schemas are imported into the [XPath/XQuery]
type system.</p>
<p><b>Notation</b></p>
<p>Mapping rules are written using a square bracket notation, as
follows:</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>Object<font size="6">]</font><sub><font size=
"2">Subscript</font></sub>, <em>premises</em></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><em>Mapped
Object</em></td>
</tr>
</table>
</div>
<p>The original "object", and an optional list of premises, is
written above the <b>=</b> sign. The rewritten "object" is written
beneath the <b>=</b> sign. The subscript is used to indicate what
kind of "object" is mapped, and sometimes to pass some information
between mapping rules. For instance, the mapping rule <font size=
"6">[</font><em>Expr</em><font size="6">]</font><a href=
"#jd_map_function_argument" class="judgment"><sub><font size=
"2">FunctionArgument(Type)</font></sub></a> is used in the
normalization of <a href="#id-function-calls"><b>[4.1.5 Function
Calls]</b></a> and passes a sequence type as a parameter during
normalization.</p>
<p>Since normalization is always applied in the presence of a
static context, the above rule is a shorthand for:</p>
<div align="center">
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>premises</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <font size=
"6">[</font>Object<font size="6">]</font> <sub><font size=
"2">Subscript</font></sub> = Mapped Object</td>
</tr>
</table>
<br /></div>
</div>
<p>Most normalization rules have no premises, so they are omitted.
The static environment is used in certain normalization rules (e.g.
for normalization of function calls). To keep the notation simpler,
the static environment is not written in the normalization rules,
but it is assumed to be available.</p>
<p id="jd_map_expr">The normalization rule that is used to map
"top-level" expressions in the [XPath/XQuery] syntax into
expressions in the [XPath/XQuery] Core is:</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>Expr</em><font size="6">]</font><a href=
"#jd_map_expr" class="judgment"><sub><font size=
"2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><em>CoreExpr</em></td>
</tr>
</table>
</div>
<p>which indicates that the expression <em>Expr</em> is normalized
to the expression <em>CoreExpr</em> in the [XPath/XQuery] Core
(with the implied <a href="#xq_stat_env_def" class=
"env">statEnv</a>). Note that <em>Expr</em> within the square
brackets are the expression being normalized, while the
<em>Expr</em> in the subscript indicate that this is the main
normalization rule that applies to expressions. For instance, here
is the normalization rule applied to the literal integer
<code>1</code>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>1<font size="6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">1</td>
</tr>
</table>
</div>
<p>To simplify the specification in some cases, some further
normalization may be used on the right-hand side of a normalization
rule. For instance, the following normalization rules for the
<code>/</code> operator applies normalization to the expanded
expression on the right-hand side.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>/<font size="6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>(<code>fn:root</code>(self::node()) treat as
document-node())<font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
</table>
</div>
<p><b>Example</b></p>
<p>For instance, the following [expression/query]</p>
<div class="exampleInner">
<pre>
    for $i in (1, 2),
        $j in (3, 4)
    return
      element pair { ($i,$j) }
</pre></div>
<p>is normalized to the Core expression</p>
<div class="exampleInner">
<pre>
    for $i in (1, 2) return
      for $j in (3, 4) return
          element pair { ($i,$j) }<span> {}</span>
</pre></div>
<p>in which the "FWLR" expression is mapped into a composition of
two simpler "for" expressions.</p>
</div>
<div class="div3">
<h4><a name="sec_static" id="sec_static"></a>3.2.3 Static typing
judgment</h4>
<p>The static semantics is specified using <b>static typing
rules</b>, which relate [XPath/XQuery] expressions to types and
specify under what conditions an expression is well typed.</p>
<p><b>Notation</b></p>
<p id="jd_has_type">The judgment</p>
<div align="center"><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>Expr</em> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></div>
<p>holds when, in the static environment <a href="#xq_stat_env_def"
class="env">statEnv</a>, the expression <em>Expr</em> has type
<a href="#doc-fs-Type"><em>Type</em></a>.</p>
<p><b>Example</b></p>
<p>The result of static type inference is to associate a static
type with every [expression/query], such that any evaluation of
that [expression/query] is guaranteed to yield a value that belongs
to that type.</p>
<p>For instance, the following expression.</p>
<div class="exampleInner">
<pre>
   let $v := 3 return $v+5
</pre></div>
<p>has type <code>xs:integer</code>. This can be inferred as
follows: the literal '3' has type integer, so the variable $v also
has type integer. Since the sum of two integers is an integer, the
complete expression has type integer.</p>
<p><b>Note</b></p>
<p>The type of an expression is computed by inference. Static
typing rules define for each kind of expression how to compute the
type of the expression given the types of its sub-expressions. Here
is a simple example:</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
<em>Expr</em><sub><font size="2">1</font></sub> <a href=
"#jd_has_type" class="judgment"><b>:</b></a>
<code>xs:boolean</code> &#160;&#160;&#160;&#160;<a href=
"#xq_stat_env_def" class="env">statEnv</a><b>&#160;|-&#160;</b>
<em>Expr</em><sub><font size="2">2</font></sub> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
&#160;&#160;&#160;&#160;<a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
<em>Expr</em><sub><font size="2">3</font></sub> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">3</font></sub></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <code>if</code>
(<em>Expr</em><sub><font size="2">1</font></sub>) <code>then</code>
<em>Expr</em><sub><font size="2">2</font></sub> <code>else</code>
<em>Expr</em><sub><font size="2">3</font></sub> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> ( <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
| <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">3</font></sub> )</td>
</tr>
</table>
<br /></div>
<p>This rule states that if the conditional expression of an "if"
expression has type boolean, then the type of the entire expression
is one of the two types of its "then" and "else" clauses. Note that
the resulting type is represented as a union: '(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>|<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">3</font></sub>)'.</p>
<p>The part after the <b>|-</b> and before <b>:</b> in the judgment
<em>below</em> the line corresponds to some [expression/query], for
which a type is computed. If the [expression/query] has been parsed
into an internal abstract syntax tree, this usually corresponds to
some node in that tree. The judgment usually has patterns in it
(here <em>Expr</em><sub><font size="2">1</font></sub>,
<em>Expr</em><sub><font size="2">2</font></sub>, and
<em>Expr</em><sub><font size="2">3</font></sub>) that need to be
matched against the children of the node in the abstract syntax
tree. The judgments <em>above</em> the line indicate things that
need to be computed to use this rule; in this case, the types of
the condition expression and the two branches of the if-then-else
expression. Once those types are computed (by further applying
static typing rules recursively to those sub-expressions), then the
type of the expression below the line can be computed. This example
illustrates a general feature of the [XPath/XQuery] type system:
the type of an expression depends only on the type of its
sub-expressions. Static type inference is recursive, following the
abstract syntax of the [expression/query]. At each point in the
recursion, an inference rule whose conclusion has a structure that
matches that of the premise in question is sought. If all the
premises of a rule cannot be satisfied, then the static type
inference has failed for the given expression, and the
[expression/query] is not well-typed.</p>
</div>
<div class="div3">
<h4><a name="sec_evaluation" id="sec_evaluation"></a>3.2.4 Dynamic
evaluation judgment</h4>
<p>The dynamic, or operational, semantics is specified using
<b>dynamic evaluation rules</b>, which relate [XPath/XQuery]
expressions to values, and in some cases specify the order in which
an [XPath/XQuery] expression is evaluated.</p>
<p><b>Notation</b></p>
<p id="jd_yields">The judgment</p>
<div align="center"><a href="#xq_stat_env_def" class=
"env">statEnv</a>; <a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>Expr</em> <a href=
"#jd_yields" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></div>
<p>holds when, in the static environment <a href="#xq_stat_env_def"
class="env">statEnv</a> and dynamic environment <a href=
"#xq_dyn_env_def" class="env">dynEnv</a>, the expression
<em>Expr</em> yields the value <a href=
"#doc-fs-Value"><em>Value</em></a>.</p>
<p>The static environment is used in certain cases (e.g. for type
matching) during evaluation. To keep the notation simpler, the
static environment is not written in the dynamic evaluation rules,
but it is assumed to be available.</p>
<p>The inference rules used for dynamic evaluation, like those for
static typing, follow a recursive structure, computing the value of
expressions from the values of their sub-expressions.</p>
</div>
</div>
<div class="div2">
<h3><a name="sec_errors" id="sec_errors"></a>3.3 Error
Handling</h3>
<p>Expressions can raise errors during static analysis or dynamic
evaluation. The <a href="#xpath-functions-11">[Functions and
Operators 1.1]</a> <a href="#xquery-11">[XQuery 1.1: An XML Query
Language]</a>, and <a href="#xpath-21">[XML Path Language (XPath)
2.1]</a> specify the conditions under which an expression or
operator raises an error. The user may raise an error explicitly by
calling the <code>fn:error</code> function, which takes an optional
item as an argument.</p>
<p>This document does not describe formally the conditions under
which dynamic errors are raised. Notably, it does not specify the
error codes or the rules about errors and optimization, as
described in <a href="#xquery-11">[XQuery 1.1: An XML Query
Language]</a>. Instead, this document describe the rules necessary
to statically detect the subset of the [XPath/XQuery] dynamic
errors known as <a href=
"http://www.w3.org/TR/xquery#dt-type-error">type
error</a><sup><small>XQ</small></sup>.</p>
</div>
<div class="div2">
<h3><a name="id-important-concepts" id=
"id-important-concepts"></a>3.4 Concepts</h3>
<p>[XPath/XQuery] is most generally used to process
<b>documents</b>. The representation of a document is normatively
defined in <a href="#xpath-datamodel-11">[Data Model]</a>. The
functions used to access documents and collections are normatively
defined in <a href="#xpath-functions-11">[Functions and Operators
1.1]</a>.</p>
<div class="div3">
<h4><a name="id-doc-order" id="id-doc-order"></a>3.4.1 Document
Order</h4>
<p>Document order is defined in <a href="#xpath-datamodel-11">[Data
Model]</a>.</p>
</div>
<div class="div3">
<h4><a name="id-atomization" id="id-atomization"></a>3.4.2
Atomization</h4>
<p>Atomization converts an item sequence into a sequence of atomic
values and is implemented by the <code>fn:data</code> function.
Atomization is applied to a value when the value is used in a
context in which a sequence of atomic values is required.</p>
</div>
<div class="div3">
<h4><a name="id-ebv" id="id-ebv"></a>3.4.3 Effective Boolean
Value</h4>
<p>If a sequence of items is encountered where a boolean value is
expected, the item sequence's effective boolean value is used. The
<code>fn:boolean</code> function returns the effective boolean
value of an item sequence.</p>
</div>
<div class="div3">
<h4><a name="id-input-sources" id="id-input-sources"></a>3.4.4
Input Sources</h4>
<p>[XPath/XQuery] has several functions that provide access to
input data, described in <a href=
"http://www.w3.org/TR/xquery#id-input-sources">Section 2.4.4 Input
Sources</a><sup><small>XQ</small></sup>. These functions are of
particular importance because they provide a way in which an
expression can reference a document or a collection of documents.
The dynamic semantics of these input functions are described in
more detail in <a href="#xpath-functions-11">[Functions and
Operators 1.1]</a>.</p>
</div>
<div class="div3">
<h4><a name="id-uri-literals" id="id-uri-literals"></a>3.4.5 URI
Literals</h4>
<p>In certain places in the XQuery grammar, a statically known
valid absolute URI is required. These places are denoted by the
grammatical symbol <em>URILiteral</em>, and are treated as
described in <a href="#xquery-11">[XQuery 1.1: An XML Query
Language]</a>.</p>
</div>
</div>
<div class="div2">
<h3><a name="id-type-conversion" id="id-type-conversion"></a>3.5
Types</h3>
<div class="div3">
<h4><a name="id-predefined-types" id=
"id-predefined-types"></a>3.5.1 Predefined Schema Types</h4>
<p>All the built-in types of XML Schema are recognized by
[XPath/XQuery]. In addition, [XPath/XQuery] recognizes the
predefined types <a href=
"#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>, <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> and
<a href="#dt-xs_untyped"><code>xs:untyped</code></a> and the
duration subtypes <a href=
"#dt-xs_durations"><code>xs:yearMonthDuration</code></a> and
<a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a> .
The definition of those types in the [XPath/XQuery] type system is
given below.</p>
<p>[<a name="dt-xs_anyType" id="dt-xs_anyType" title=
"xs:anyType">Definition</a>: The following type definition of
<b><span><code>xs:anyType</code></span></b> reflects the semantics
of the Ur type from Schema in the [XPath/XQuery] type system.]</p>
<div class="exampleInner">
<pre>
  define type xs:anyType restricts xs:anyType {
    ( attribute * of type xs:anySimpleType )*,
    ( xs:anyAtomicType* | ( element * of type xs:anyType | text | comment | processing-instruction * )* )
  }
</pre></div>
<p>[<a name="dt-xs_anySimpleType" id="dt-xs_anySimpleType" title=
"xs:anySimpleType">Definition</a>: The following type definition of
<b><span><code>xs:anySimpleType</code></span></b> reflects the
semantics of the Ur simple type from Schema in the [XPath/XQuery]
type system.]</p>
<div class="exampleInner">
<pre>
  define type xs:anySimpleType restricts xs:anyType {
    xs:anyAtomicType*
  }
</pre></div>
<p>The name of the Ur simple type is <code>xs:anySimpleType</code>.
It is derived by restriction from <code>xs:anyType</code>, its
content is a sequence any atomic types.</p>
<p>[<a name="dt-xs_anyAtomicType" id="dt-xs_anyAtomicType" title=
"xs:anyAtomicType">Definition</a>: <span>The following type
definition of <b><span><a href=
"#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a></span></b>
reflects the semantics of <a href=
"#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a> in the
[XPath/XQuery] type system.</span>]</p>
<div class="exampleInner">
<pre>
  define type xs:anyAtomicType restricts xs:anySimpleType {
    ( xs:string
    | xs:boolean
    | xs:decimal
    | xs:float
    | xs:double
    | xs:duration
    | xs:dateTime
    | xs:time
    | xs:date
    | xs:gYearMonth
    | xs:gYear
    | xs:gMonthDay
    | xs:gDay
    | xs:gMonth
    | xs:hexBinary
    | xs:base64Binary
    | xs:anyURI
    | xs:QName
    | xs:NOTATION
    | xs:untypedAtomic )
  }
</pre></div>
<p>[<a name="dt-primitive-types" id="dt-primitive-types" title=
"primitive types">Definition</a>: The following type definitions of
<b>the XML Schema primitive types</b> reflect the semantics of the
primitive types from Schema in the [XPath/XQuery] type system.]</p>
<div class="exampleInner">
<pre>
  define type xs:string       restricts xs:anyAtomicType<span>;</span>
  define type xs:boolean      restricts xs:anyAtomicType<span>;</span>
  define type xs:decimal      restricts xs:anyAtomicType<span>;</span>
  define type xs:float        restricts xs:anyAtomicType<span>;</span>
  define type xs:double       restricts xs:anyAtomicType<span>;</span>
  define type xs:duration     restricts xs:anyAtomicType<span>;</span>
  define type xs:dateTime     restricts xs:anyAtomicType<span>;</span>
  define type xs:time         restricts xs:anyAtomicType<span>;</span>
  define type xs:date         restricts xs:anyAtomicType<span>;</span>
  define type xs:gYearMonth   restricts xs:anyAtomicType<span>;</span>
  define type xs:gYear        restricts xs:anyAtomicType<span>;</span>
  define type xs:gMonthDay    restricts xs:anyAtomicType<span>;</span>
  define type xs:gDay         restricts xs:anyAtomicType<span>;</span>
  define type xs:gMonth       restricts xs:anyAtomicType<span>;</span>
  define type xs:hexBinary    restricts xs:anyAtomicType<span>;</span>
  define type xs:base64Binary restricts xs:anyAtomicType<span>;</span>
  define type xs:anyURI       restricts xs:anyAtomicType<span>;</span>
  define type xs:QName        restricts xs:anyAtomicType<span>;</span>
  define type xs:NOTATION     restricts xs:anyAtomicType<span>;</span>
</pre></div>
<p>All of those primitive types derive from <a href=
"#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>. Note that
the value space of each atomic type (such as
<code>xs:string</code>) does not appear. The value space for each
type is built-in and is as defined in <a href=
"#xmlschema-2">[Schema Part 2]</a>.</p>
<p>[<a name="dt-xs_untypedAtomic" id="dt-xs_untypedAtomic" title=
"xs:untypedAtomic">Definition</a>: The type <b><span><a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a></span></b>
is defined as follows.]</p>
<div class="exampleInner">
<pre>
  define type xs:untypedAtomic restricts xs:anyAtomicType
</pre></div>
<p>Note that this rule does not indicate the value space of
<a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>.
By definition, <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> has the
same value space as <code>xs:string</code>.</p>
<p>The following example shows two atomic values. The first one is
a value of type string containing "Database". The second one is an
untyped atomic value containing "Database".</p>
<div class="exampleInner">
<pre>
  "Databases" of type xs:string
  "Databases" of type xs:untypedAtomic
</pre></div>
<p>[<a name="dt-xs_untyped" id="dt-xs_untyped" title=
"xs:untyped">Definition</a>: The type <b><span><a href=
"#dt-xs_untyped"><code>xs:untyped</code></a></span></b> is defined
as follows.]</p>
<div class="exampleInner">
<pre>
  define type xs:untyped restricts xs:anyType {
    attribute * of type xs:untypedAtomic*,
    ( element * of type xs:untyped | text | comment | processing-instruction * )*
  }
</pre></div>
<p>[<a name="dt-derived-types" id="dt-derived-types" title=
"derived types">Definition</a>: The following type definitions of
the <b>XML Schema derived types</b> reflect the semantics of the
XML Schema types derived by restriction from another atomic
type.]</p>
<div class="exampleInner">
<pre>
  define type xs:normalizedString   restricts xs:string<span>;</span>
  define type xs:token              restricts xs:normalizedString<span>;</span>
  define type xs:language           restricts xs:token<span>;</span>
  define type xs:NMTOKEN            restricts xs:token<span>;</span>
  define type xs:Name               restricts xs:token<span>;</span>
  define type xs:NCName             restricts xs:Name<span>;</span>
  define type xs:ID                 restricts xs:NCName<span>;</span>
  define type xs:IDREF              restricts xs:NCName<span>;</span>
  define type xs:ENTITY             restricts xs:NCName<span>;</span>
  define type xs:integer            restricts xs:decimal<span>;</span>
  define type xs:nonPositiveInteger restricts xs:integer<span>;</span>
  define type xs:negativeInteger    restricts xs:nonPositiveInteger<span>;</span>
  define type xs:long               restricts xs:integer<span>;</span>
  define type xs:int                restricts xs:long<span>;</span>
  define type xs:short              restricts xs:int<span>;</span>
  define type xs:byte               restricts xs:short<span>;</span>
  define type xs:nonNegativeInteger restricts xs:integer<span>;</span>
  define type xs:unsignedLong       restricts xs:nonNegativeInteger<span>;</span>
  define type xs:unsignedInt        restricts xs:unsignedLong<span>;</span>
  define type xs:unsignedShort      restricts xs:unsignedInt<span>;</span>
  define type xs:unsignedByte       restricts xs:unsignedShort<span>;</span>
  define type xs:positiveInteger    restricts xs:nonNegativeInteger<span>;</span>
</pre></div>
<p>Three XML Schema built-in derived types are derived by list, as
follows. Note that those derive directly from
<code>xs:anySimpleType</code>, since they are derived by list, and
that their value space is defined using a "one or more" occurrence
indicator.</p>
<div class="exampleInner">
<pre>
  define type xs:NMTOKENS restricts xs:anySimpleType { xs:NMTOKEN+ }<span>;</span>
  define type xs:IDREFS   restricts xs:anySimpleType { xs:IDREF+ }<span>;</span>
  define type xs:ENTITIES restricts xs:anySimpleType { xs:ENTITY+ }<span>;</span>
</pre></div>
<p>For example, here is an element whose content is of type
<code>xs:IDREFS</code>.</p>
<div class="exampleInner">
<pre>
  element a of type xs:IDREFS {
    "id1" of type xs:IDREF,
    "id2" of type xs:IDREF,
    "id3" of type xs:IDREF
  }
</pre></div>
<p>Note that the type name <code>xs:IDREFS</code> derives from
<code>xs:anySimpleType</code>, but not from <code>xs:IDREF</code>.
As a consequence, calling the following three XQuery functions with
the element <code>a</code> as a parameter succeeds for
<code>f1</code> and <code>f2</code>, but raises a type error for
<code>f3</code>.</p>
<div class="exampleInner">
<pre>
  declare function f1($x as element(*,xs:anySimpleType)) { $x }
  declare function f2($x as element(*,xs:IDREFS)) { $x }
  declare function f3($x as element(*,xs:IDREF)) { $x }
</pre></div>
<p>[<a name="dt-xs_durations" id="dt-xs_durations" title=
"Totally ordered duration types">Definition</a>: <span>The
<b>totally ordered duration types</b>, <a href=
"#dt-xs_durations"><code>xs:yearMonthDuration</code></a> and
<a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a> ,
are derived by restriction from
<code>xs:duration</code>.</span>]</p>
<div class="exampleInner">
<pre>
  define type xs:yearMonthDuration restricts xs:duration<span>;</span>
  define type xs:dayTimeDuration   restricts xs:duration<span>;</span>
</pre></div>
<p>[<a name="dt-fs_numeric" id="dt-fs_numeric" title=
"fs:numeric">Definition</a>: In addition, the Formal Semantics uses
the additional type <em>fs:</em><code>numeric</code>. This type is
necessary for the specification of some of XPath type conversion
rules. It is defined as follows.]</p>
<div class="exampleInner">
<pre>
  define type fs:numeric restricts xs:anyAtomicType { xs:decimal | xs:float | xs:double }
</pre></div>
</div>
<div class="div3">
<h4><a name="id-typed-value" id="id-typed-value"></a>3.5.2 Typed
Value and String Value</h4>
<p>The typed value of a node is computed by the
<code>fn:data</code> function, and the string value of a node is
computed by the <code>fn:string</code> function, defined in
<a href="#xpath-functions-11">[Functions and Operators 1.1]</a>.
The normative definitions of typed value and string value are
defined in <a href="#xpath-datamodel-11">[Data Model]</a>.</p>
</div>
<div class="div3">
<h4><a name="id-sequencetype" id="id-sequencetype"></a>3.5.3
SequenceType Syntax</h4>
<p><b>Introduction</b></p>
<p>Sequence types can be used in [XPath/XQuery] to refer to an XML
Schema type. Sequence types are used to declare the types of
function parameters and in several [XPath/XQuery] expressions.</p>
<p>The syntax of sequence types is described by the following
grammar productions.</p>
<h5><a name="d6e6948" id="d6e6948"></a>SequenceType</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-SequenceType" id=
"doc-xquery10-SequenceType"></a>[<small>171&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-SequenceType">SequenceType</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("empty-sequence" "(" ")")<br />
| (<a href="#doc-xquery10-ItemType">ItemType</a> <a href=
"#doc-xquery10-OccurrenceIndicator">OccurrenceIndicator</a>?)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-ItemType" id=
"doc-xquery10-ItemType"></a>[<small>173&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-ItemType">ItemType</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery10-KindTest">KindTest</a> | ("item"
"(" ")") | FunctionTest | <a href=
"#doc-xquery10-AtomicType">AtomicType</a> |
ParenthesizedItemType</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-OccurrenceIndicator" id=
"doc-xquery10-OccurrenceIndicator"></a>[<small>172&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-OccurrenceIndicator">OccurrenceIndicator</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"?" | "*" | "+"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-AtomicType" id=
"doc-xquery10-AtomicType"></a>[<small>174&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-AtomicType">AtomicType</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>_QName_or_EQName</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-KindTest" id=
"doc-xquery10-KindTest"></a>[<small>175&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-KindTest">KindTest</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery10-DocumentTest">DocumentTest</a><br />
| <a href="#doc-xquery10-ElementTest">ElementTest</a><br />
| <a href="#doc-xquery10-AttributeTest">AttributeTest</a><br />
| <a href=
"#doc-xquery10-SchemaElementTest">SchemaElementTest</a><br />
| <a href=
"#doc-xquery10-SchemaAttributeTest">SchemaAttributeTest</a><br />
| <a href="#doc-xquery10-PITest">PITest</a><br />
| <a href="#doc-xquery10-CommentTest">CommentTest</a><br />
| <a href="#doc-xquery10-TextTest">TextTest</a><br />
| NamespaceNodeTest<br />
| <a href="#doc-xquery10-AnyKindTest">AnyKindTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-DocumentTest" id=
"doc-xquery10-DocumentTest"></a>[<small>177&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-DocumentTest">DocumentTest</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"document-node" "(" (<a href=
"#doc-xquery10-ElementTest">ElementTest</a> | <a href=
"#doc-xquery10-SchemaElementTest">SchemaElementTest</a>)?
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-ElementTest" id=
"doc-xquery10-ElementTest"></a>[<small>186&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-ElementTest">ElementTest</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"element" "(" (<a href=
"#doc-xquery10-ElementNameOrWildcard">ElementNameOrWildcard</a>
("," <a href="#doc-xquery10-TypeName">TypeName</a> "?"?)?)?
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-SchemaElementTest" id=
"doc-xquery10-SchemaElementTest"></a>[<small>188&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-SchemaElementTest">SchemaElementTest</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"schema-element" "(" <a href=
"#doc-xquery10-ElementDeclaration">ElementDeclaration</a>
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-ElementDeclaration" id=
"doc-xquery10-ElementDeclaration"></a>[<small>189&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-ElementDeclaration">ElementDeclaration</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery10-ElementName">ElementName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-AttributeTest" id=
"doc-xquery10-AttributeTest"></a>[<small>182&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-AttributeTest">AttributeTest</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"attribute" "(" (<a href=
"#doc-xquery10-AttribNameOrWildcard">AttribNameOrWildcard</a> (","
<a href="#doc-xquery10-TypeName">TypeName</a>)?)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-SchemaAttributeTest" id=
"doc-xquery10-SchemaAttributeTest"></a>[<small>184&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-SchemaAttributeTest">SchemaAttributeTest</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"schema-attribute" "(" <a href=
"#doc-xquery10-AttributeDeclaration">AttributeDeclaration</a>
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-AttributeDeclaration" id=
"doc-xquery10-AttributeDeclaration"></a>[<small>185&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-AttributeDeclaration">AttributeDeclaration</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery10-AttributeName">AttributeName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-ElementNameOrWildcard" id=
"doc-xquery10-ElementNameOrWildcard"></a>[<small>187&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-ElementNameOrWildcard">ElementNameOrWildcard</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery10-ElementName">ElementName</a> |
"*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-ElementName" id=
"doc-xquery10-ElementName"></a>[<small>191&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-ElementName">ElementName</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>_QName_or_EQName</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-AttribNameOrWildcard" id=
"doc-xquery10-AttribNameOrWildcard"></a>[<small>183&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-AttribNameOrWildcard">AttribNameOrWildcard</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery10-AttributeName">AttributeName</a> |
"*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-AttributeName" id=
"doc-xquery10-AttributeName"></a>[<small>190&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-AttributeName">AttributeName</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>_QName_or_EQName</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-TypeName" id=
"doc-xquery10-TypeName"></a>[<small>192&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-TypeName">TypeName</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>_QName_or_EQName</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-PITest" id=
"doc-xquery10-PITest"></a>[<small>181&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-PITest">PITest</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"processing-instruction" "(" (<a href=
"#prod-xquery10-NCName">NCName</a> | <a href=
"#doc-xquery10-StringLiteral">StringLiteral</a>)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-CommentTest" id=
"doc-xquery10-CommentTest"></a>[<small>179&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-CommentTest">CommentTest</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"comment" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-TextTest" id=
"doc-xquery10-TextTest"></a>[<small>178&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-TextTest">TextTest</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"text" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-AnyKindTest" id=
"doc-xquery10-AnyKindTest"></a>[<small>176&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-AnyKindTest">AnyKindTest</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"node" "(" ")"</code></td>
</tr>
</tbody>
</table>
<p><b>Core Grammar</b></p>
<p>The Core grammar productions for sequence types are:</p>
<h5><a name="d6e7157" id="d6e7157"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-SequenceType" id=
"doc-xcore-SequenceType"></a>[<small>87&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-SequenceType"></a><a href=
"#prod-xcore-SequenceType">SequenceType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("empty-sequence" "(" ")")<br />
| (<a href="#doc-xcore-ItemType">ItemType</a> <a href=
"#doc-xcore-OccurrenceIndicator">OccurrenceIndicator</a>?)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-ItemType" id=
"doc-xcore-ItemType"></a>[<small>89&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-ItemType"></a><a href=
"#prod-xcore-ItemType">ItemType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-KindTest">KindTest</a> | ("item" "("
")") | <a href="#doc-xcore-AtomicType">AtomicType</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-OccurrenceIndicator" id=
"doc-xcore-OccurrenceIndicator"></a>[<small>88&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-OccurrenceIndicator"></a><a href=
"#prod-xcore-OccurrenceIndicator">OccurrenceIndicator</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"?" | "*" | "+"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-AtomicType" id=
"doc-xcore-AtomicType"></a>[<small>90&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-AtomicType"></a><a href=
"#prod-xcore-AtomicType">AtomicType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>_QName_or_EQName</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-KindTest" id=
"doc-xcore-KindTest"></a>[<small>91&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-KindTest"></a><a href=
"#prod-xcore-KindTest">KindTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-DocumentTest">DocumentTest</a><br />
| <a href="#doc-xcore-ElementTest">ElementTest</a><br />
| <a href="#doc-xcore-AttributeTest">AttributeTest</a><br />
| <a href=
"#doc-xcore-SchemaElementTest">SchemaElementTest</a><br />
| <a href=
"#doc-xcore-SchemaAttributeTest">SchemaAttributeTest</a><br />
| <a href="#doc-xcore-PITest">PITest</a><br />
| <a href="#doc-xcore-CommentTest">CommentTest</a><br />
| <a href="#doc-xcore-TextTest">TextTest</a><br />
| <a href="#doc-xcore-AnyKindTest">AnyKindTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-DocumentTest" id=
"doc-xcore-DocumentTest"></a>[<small>93&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-DocumentTest"></a><a href=
"#prod-xcore-DocumentTest">DocumentTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"document-node" "(" (<a href=
"#doc-xcore-ElementTest">ElementTest</a> | <a href=
"#doc-xcore-SchemaElementTest">SchemaElementTest</a>)?
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-ElementTest" id=
"doc-xcore-ElementTest"></a>[<small>101&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-ElementTest"></a><a href=
"#prod-xcore-ElementTest">ElementTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"element" "(" (<a href=
"#doc-xcore-ElementNameOrWildcard">ElementNameOrWildcard</a> (","
<a href="#doc-xcore-TypeName">TypeName</a> "?"?)?)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-SchemaElementTest" id=
"doc-xcore-SchemaElementTest"></a>[<small>103&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-SchemaElementTest"></a><a href=
"#prod-xcore-SchemaElementTest">SchemaElementTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"schema-element" "(" <a href=
"#doc-xcore-ElementDeclaration">ElementDeclaration</a>
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-ElementDeclaration" id=
"doc-xcore-ElementDeclaration"></a>[<small>104&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-ElementDeclaration"></a><a href=
"#prod-xcore-ElementDeclaration">ElementDeclaration</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xcore-ElementName">ElementName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-AttributeTest" id=
"doc-xcore-AttributeTest"></a>[<small>97&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-AttributeTest"></a><a href=
"#prod-xcore-AttributeTest">AttributeTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"attribute" "(" (<a href=
"#doc-xcore-AttribNameOrWildcard">AttribNameOrWildcard</a> (","
<a href="#doc-xcore-TypeName">TypeName</a>)?)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-SchemaAttributeTest" id=
"doc-xcore-SchemaAttributeTest"></a>[<small>99&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-SchemaAttributeTest"></a><a href=
"#prod-xcore-SchemaAttributeTest">SchemaAttributeTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"schema-attribute" "(" <a href=
"#doc-xcore-AttributeDeclaration">AttributeDeclaration</a>
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-AttributeDeclaration" id=
"doc-xcore-AttributeDeclaration"></a>[<small>100&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-AttributeDeclaration"></a><a href=
"#prod-xcore-AttributeDeclaration">AttributeDeclaration</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xcore-AttributeName">AttributeName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-ElementNameOrWildcard" id=
"doc-xcore-ElementNameOrWildcard"></a>[<small>102&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-ElementNameOrWildcard"></a><a href=
"#prod-xcore-ElementNameOrWildcard">ElementNameOrWildcard</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-ElementName">ElementName</a> |
"*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-ElementName" id=
"doc-xcore-ElementName"></a>[<small>106&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-ElementName"></a><a href=
"#prod-xcore-ElementName">ElementName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>_QName_or_EQName</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-AttribNameOrWildcard" id=
"doc-xcore-AttribNameOrWildcard"></a>[<small>98&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-AttribNameOrWildcard"></a><a href=
"#prod-xcore-AttribNameOrWildcard">AttribNameOrWildcard</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-AttributeName">AttributeName</a> |
"*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-AttributeName" id=
"doc-xcore-AttributeName"></a>[<small>105&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-AttributeName"></a><a href=
"#prod-xcore-AttributeName">AttributeName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>_QName_or_EQName</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-TypeName" id=
"doc-xcore-TypeName"></a>[<small>107&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-TypeName"></a><a href=
"#prod-xcore-TypeName">TypeName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>_QName_or_EQName</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-PITest" id=
"doc-xcore-PITest"></a>[<small>96&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-PITest"></a><a href=
"#prod-xcore-PITest">PITest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"processing-instruction" "(" (<a href=
"#prod-xcore-NCName">NCName</a> | <a href=
"#doc-xcore-StringLiteral">StringLiteral</a>)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-CommentTest" id=
"doc-xcore-CommentTest"></a>[<small>95&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-CommentTest"></a><a href=
"#prod-xcore-CommentTest">CommentTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"comment" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-TextTest" id=
"doc-xcore-TextTest"></a>[<small>94&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-TextTest"></a><a href=
"#prod-xcore-TextTest">TextTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"text" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-AnyKindTest" id=
"doc-xcore-AnyKindTest"></a>[<small>92&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-AnyKindTest"></a><a href=
"#prod-xcore-AnyKindTest">AnyKindTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"node" "(" ")"</code></td>
</tr>
</tbody>
</table>
<p>The semantics of SequenceTypes is defined by means of
normalization rules from SequenceTypes into types in the
[XPath/XQuery] type system (See <a href="#sec_types"><b>[2.4 The
[XPath/XQuery] Type System]</b></a>).</p>
<p>However, the [XPath/XQuery] type system not being part of the
[XPath/XQuery] syntax, the SequenceType syntax is still part of the
[XPath/XQuery] Core. Normalization from SequenceTypes to types is
not applied during the normalization phase but whenever a dynamic
evaluation or static typing rule requires it.</p>
</div>
<div class="div3">
<h4><a name="id-sequencetype-matching" id=
"id-sequencetype-matching"></a>3.5.4 SequenceType Matching</h4>
<p><b>Introduction</b></p>
<p>During processing of a query, it is sometimes necessary to
determine whether a given value matches a type that was declared
using the SequenceType syntax. This process is known as
SequenceType matching, and is formally specified in <a href=
"#sec_type_matching"><b>[8.3 Judgments for type
matching]</b></a>.</p>
<p><b>Notation</b></p>
<p id="jd_map_sequencetype">To define normalization of
SequenceTypes to the [XPath/XQuery] type system, the following
auxiliary mapping rule is used.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>SequenceType</em><font size="6">]</font><a href=
"#jd_map_sequencetype" class="judgment"><sub><font size=
"2">sequencetype</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
</div>
<p>specifies that <em>SequenceType</em> is mapped to a <a href=
"#doc-fs-Type"><em>Type</em></a>, in the [XPath/XQuery] type
system.</p>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>OccurenceIndicators are left unchanged when normalizing
SequenceTypes into [XPath/XQuery] types. Each kind of SequenceType
component is normalized separately into the [XPath/XQuery] type
system.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><a href="#doc-core-ItemType"><em>ItemType</em></a>
<em>OccurrenceIndicator</em><font size="6">]</font><a href=
"#jd_map_sequencetype" class="judgment"><sub><font size=
"2">sequencetype</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><a href=
"#doc-core-ItemType"><em>ItemType</em></a><font size=
"6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a>
<em>OccurrenceIndicator</em></td>
</tr>
</table>
</div>
<p>The "empty-sequence()" sequence type is mapped to the empty
type.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>empty-sequence()<font size="6">]</font><a href=
"#jd_map_sequencetype" class="judgment"><sub><font size=
"2">sequencetype</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">empty</td>
</tr>
</table>
</div>
<p>An atomic type is normalized to itself in the [XPath/XQuery]
type system.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><font size=
"6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><a href=
"#doc-core-AtomicType"><em>AtomicType</em></a></td>
</tr>
</table>
</div>
<p>An "element" SequenceType without content or with a wildcard and
no type name is normalized into a wildcard element type.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>element()<font size="6">]</font><a href=
"#jd_map_sequencetype" class="judgment"><sub><font size=
"2">sequencetype</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">element * of type
<code>xs:anyType</code></td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>element(*)<font size="6">]</font><a href=
"#jd_map_sequencetype" class="judgment"><sub><font size=
"2">sequencetype</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">element * of type
<code>xs:anyType</code></td>
</tr>
</table>
</div>
<p>An "element" SequenceType with a wildcard and a type name is
normalized into a wildcard element type with a corresponding type
name. The presence of a "?" after the type name indicates a
nillable element.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>element(*,<a href=
"#doc-fs-TypeName"><em>TypeName</em></a>)<font size=
"6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">element * of type
<a href="#doc-fs-TypeName"><em>TypeName</em></a></td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>element(*,<a href=
"#doc-fs-TypeName"><em>TypeName</em></a>?)<font size=
"6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">element * nillable of
type <a href="#doc-fs-TypeName"><em>TypeName</em></a></td>
</tr>
</table>
</div>
<p>An "element" SequenceType with a name and a type name is
normalized into an element type with a corresponding type name. The
presence of a "?" after the type name indicates a nillable
element.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>element(<a href=
"#doc-fs-ElementName"><em>ElementName</em></a>,<a href=
"#doc-fs-TypeName"><em>TypeName</em></a>)<font size=
"6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">element <a href=
"#doc-fs-ElementName"><em>ElementName</em></a> of type <a href=
"#doc-fs-TypeName"><em>TypeName</em></a></td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>element(<a href=
"#doc-fs-ElementName"><em>ElementName</em></a>,<a href=
"#doc-fs-TypeName"><em>TypeName</em></a>?)<font size=
"6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">element <a href=
"#doc-fs-ElementName"><em>ElementName</em></a> nillable of type
<a href="#doc-fs-TypeName"><em>TypeName</em></a></td>
</tr>
</table>
</div>
<p>An "element" SequenceType with only a name is normalized into a
<em>nillable</em> element type with a corresponding name. The
reason for the normalization to allow nillable elements is because
the semantics of SequenceTypes in that case allows it to match
every possible element with that names, regardless of its type or
nilled property.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>element(<a href=
"#doc-fs-ElementName"><em>ElementName</em></a>)<font size=
"6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">element <a href=
"#doc-fs-ElementName"><em>ElementName</em></a> nillable of type
<code>xs:anyType</code></td>
</tr>
</table>
</div>
<p>A "schema-element" SequenceType with an element declaration is
normalized into a reference to the corresponding global element
declaration.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>schema-element(<a href=
"#doc-fs-ElementName"><em>ElementName</em></a>)<font size=
"6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">element <a href=
"#doc-fs-ElementName"><em>ElementName</em></a></td>
</tr>
</table>
</div>
<p>An "attribute" SequenceType without content or with a wildcard
and no type name is normalized into a wildcard attribute type.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>attribute()<font size="6">]</font><a href=
"#jd_map_sequencetype" class="judgment"><sub><font size=
"2">sequencetype</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">attribute * of type
<code>xs:anySimpleType</code></td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>attribute(*)<font size="6">]</font><a href=
"#jd_map_sequencetype" class="judgment"><sub><font size=
"2">sequencetype</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">attribute * of type
<code>xs:anySimpleType</code></td>
</tr>
</table>
</div>
<p>An "attribute" SequenceType with a wildcard and a type name is
normalized into a wildcard attribute type with a corresponding type
name.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>attribute(*,<a href=
"#doc-fs-TypeName"><em>TypeName</em></a>)<font size=
"6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">attribute * of type
<a href="#doc-fs-TypeName"><em>TypeName</em></a></td>
</tr>
</table>
</div>
<p>An "attribute" SequenceType with a name and a type name is
normalized into an attribute type with a corresponding type
name.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>attribute(<a href=
"#doc-fs-AttributeName"><em>AttributeName</em></a>,<a href=
"#doc-fs-TypeName"><em>TypeName</em></a>)<font size=
"6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">attribute <a href=
"#doc-fs-AttributeName"><em>AttributeName</em></a> of type <a href=
"#doc-fs-TypeName"><em>TypeName</em></a></td>
</tr>
</table>
</div>
<p>A "schema-attribute" SequenceType with an attribute declaration
is normalized into a reference to the corresponding global
attribute declaration.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>schema-attribute(<a href=
"#doc-fs-AttributeName"><em>AttributeName</em></a>)<font size=
"6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">attribute <a href=
"#doc-fs-AttributeName"><em>AttributeName</em></a></td>
</tr>
</table>
</div>
<p>A "document-node()" sequence types is normalized into the
corresponding document type.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>document-node()<font size="6">]</font><a href=
"#jd_map_sequencetype" class="judgment"><sub><font size=
"2">sequencetype</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">document { (element *
of type <code>xs:anyType</code> | text | comment |
processing-instruction <span>*</span> )* }</td>
</tr>
</table>
</div>
<p>A "document-node" sequence type with an element test (resp. a
schema element test) is normalized into the corresponding document
type, whose content is the normalization of the element test (resp.
schema element test), interleaved with an arbitrary sequence of
processing instruction, comment, and text nodes.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>document-node(<em>ElementTest</em>)<font size=
"6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">document { <font size=
"6">[</font><em>ElementTest</em><font size="6">]</font><a href=
"#jd_map_sequencetype" class="judgment"><sub><font size=
"2">sequencetype</font></sub></a> &amp; ( processing-instruction
<span>*</span> | comment ) *}</td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>document-node(<em>SchemaElementTest</em>)<font size=
"6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">document { <font size=
"6">[</font><em>SchemaElementTest</em><font size=
"6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a> &amp;
( processing-instruction <span>*</span> | comment ) *}</td>
</tr>
</table>
</div>
<p>A "processing-instruction()" SequenceType is normalized into the
corresponding processing-instruction type.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>processing-instruction()<font size="6">]</font><a href=
"#jd_map_sequencetype" class="judgment"><sub><font size=
"2">sequencetype</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">processing-instruction
<span>*</span></td>
</tr>
</table>
</div>
<p>The [XPath/XQuery] type system does not model the target of a
processing-instruction, which is treated as a dynamic property.
Therefore a "processing-instruction" SequenceType with a string or
NCName parameter is normalized into an optional
processing-instruction type.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>processing-instruction(<em>StringLiteral</em>)<font size="6">]</font><a href="#jd_map_sequencetype"
class="judgment"><sub><font size=
"2">sequencetype</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
processing-instruction?</td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>processing-instruction(<em>NCName</em>)<font size=
"6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">processing-instruction
<em>NCName</em></td>
</tr>
</table>
</div>
<p>For backward compatibility with XPath 1.0, the PITarget of a
PITest may also be expressed as a string literal. The following
rule handles that case.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><em>StringLiteral</em> <a href="#jd_has_atomic_value" class=
"judgment"><b>has atomic value</b></a> <em>String</em></td>
</tr>
<tr align="center" valign="middle">
<td><code>xs:NCName</code>(<em>String</em>) = <em>NCName</em></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><font size=
"6">[</font>processing-instruction(<em>StringLiteral</em>)<font size="6">]</font><a href="#jd_map_sequencetype"
class="judgment"><sub><font size="2">sequencetype</font></sub></a>
= processing-instruction <em>NCName</em></td>
</tr>
</table>
<br /></div>
<p>A "comment()" SequenceType is normalized into the corresponding
comment type.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>comment()<font size="6">]</font><a href=
"#jd_map_sequencetype" class="judgment"><sub><font size=
"2">sequencetype</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">comment</td>
</tr>
</table>
</div>
<p>A "text()" SequenceType is normalized into the corresponding
text type.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>text()<font size="6">]</font><a href=
"#jd_map_sequencetype" class="judgment"><sub><font size=
"2">sequencetype</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">text</td>
</tr>
</table>
</div>
<p>The "node()" SequenceType denotes any node. It is normalized
into a choice between the corresponding wildcard types for each
kind of node.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>node()<font size="6">]</font><a href=
"#jd_map_sequencetype" class="judgment"><sub><font size=
"2">sequencetype</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">(element * of type
<code>xs:anyType</code> | attribute * of type
<code>xs:anySimpleType</code> | text | document { (element * of
type <code>xs:anyType</code> | text | comment |
processing-instruction <span>*</span>)* } | comment |
processing-instruction <span>*</span>)</td>
</tr>
</table>
</div>
<p>The "item()" SequenceType denotes any node or atomic value. It
is normalized into a choice between the corresponding wildcard
types for each kind of nodes or atomic values.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>item()<font size="6">]</font><a href=
"#jd_map_sequencetype" class="judgment"><sub><font size=
"2">sequencetype</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">(element * of type
<code>xs:anyType</code> | attribute * of type
<code>xs:anySimpleType</code> | text | document { (element * of
type <code>xs:anyType</code> | text | comment |
processing-instruction <span>*</span>)* } | comment |
processing-instruction <span>*</span> | <a href=
"#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a> )</td>
</tr>
</table>
</div>
</div>
</div>
<div class="div2">
<h3><a name="comments" id="comments"></a>3.6 Comments</h3>
<h5><a name="d6e8101" id="d6e8101"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-Comment" id=
"doc-xquery10-Comment"></a>[<small>209&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-Comment">Comment</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(:" (<a href=
"#doc-xquery10-CommentContents">CommentContents</a> | <a href=
"#doc-xquery10-Comment">Comment</a>)* ":)"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-CommentContents" id=
"doc-xquery10-CommentContents"></a>[<small>217&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-CommentContents">CommentContents</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xquery10-Char">Char</a>+ - (Char* ('(:' |
':)') Char*))</code></td>
</tr>
</tbody>
</table>
<p>Comments are lexical constructs only, and have no effect on the
meaning of the query, and therefore do not have any formal
semantics.</p>
</div>
<div class="div2">
<h3><a name="xml-terminals" id="xml-terminals"></a>3.7 XML-defined
Terminals</h3>
<p>The following terminals are defined by XML.</p>
<h5><a name="d6e8129" id="d6e8129"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery10-PITarget" id=
"prod-xquery10-PITarget"></a>[<small>210&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-PITarget">PITarget</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/REC-xml#NT-PITarget">[http://www.w3.org/TR/REC-xml#NT-PITarget]</a><sup><small>XML</small></sup></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery10-CharRef" id=
"prod-xquery10-CharRef"></a>[<small>211&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-CharRef">CharRef</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/REC-xml#NT-CharRef">[http://www.w3.org/TR/REC-xml#NT-CharRef]</a><sup><small>XML</small></sup></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery10-QName" id=
"prod-xquery10-QName"></a>[<small>212&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-QName">QName</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/REC-xml-names/#NT-QName">[http://www.w3.org/TR/REC-xml-names/#NT-QName]</a><sup><small>Names</small></sup></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery10-NCName" id=
"prod-xquery10-NCName"></a>[<small>213&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-NCName">NCName</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/REC-xml-names/#NT-NCName">[http://www.w3.org/TR/REC-xml-names/#NT-NCName]</a><sup><small>Names</small></sup></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery10-S" id=
"prod-xquery10-S"></a>[<small>214&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-S">S</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/REC-xml#NT-S">[http://www.w3.org/TR/REC-xml#NT-S]</a><sup><small>XML</small></sup></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery10-Char" id=
"prod-xquery10-Char"></a>[<small>215&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-Char">Char</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/REC-xml#NT-Char">[http://www.w3.org/TR/REC-xml#NT-Char]</a><sup><small>XML</small></sup></code></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="div1">
<h2><a name="id-expressions" id="id-expressions"></a>4
Expressions</h2>
<p>This section gives the semantics of all the [XPath/XQuery]
expressions. The organization of this section parallels the
organization of <a href=
"http://www.w3.org/TR/xquery#id-expressions">Section 3
Expressions</a><sup><small>XQ</small></sup>.</p>
<h5><a name="d6e8192" id="d6e8192"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-Expr" id=
"doc-xquery10-Expr"></a>[<small>39&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-Expr">Expr</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery10-ExprSingle">ExprSingle</a> (","
<a href="#doc-xquery10-ExprSingle">ExprSingle</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-ExprSingle" id=
"doc-xquery10-ExprSingle"></a>[<small>40&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-ExprSingle">ExprSingle</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>FLWORExpr<br />
| FLWORExpr<br />
| <a href="#doc-xquery10-QuantifiedExpr">QuantifiedExpr</a><br />
| SwitchExpr<br />
| <a href="#doc-xquery10-TypeswitchExpr">TypeswitchExpr</a><br />
| <a href="#doc-xquery10-IfExpr">IfExpr</a><br />
| TryCatchExpr<br />
| <a href="#doc-xquery10-OrExpr">OrExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath20-XPath" id=
"doc-xpath20-XPath"></a>[<small>1&#160;(XPath)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xpath20/#prod-xpath-XPath">XPath</a><sup><small>XP</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>Expr</code></td>
</tr>
</tbody>
</table>
<p>For each expression, a short description and the relevant
grammar productions are given. The semantics of an expression
includes the normalization, static analysis, and dynamic evaluation
phases. Recall that normalization rules translate [XPath/XQuery]
syntax into Core syntax. In the sections that contain normalization
rules, the Core grammar productions into which the expression is
normalized are also provided. After normalization, sections on
static type inference and dynamic evaluation define the static type
and dynamic value for the Core expression.</p>
<p><b>Core Grammar</b></p>
<p>The Core grammar productions for expressions are:</p>
<h5><a name="d6e8250" id="d6e8250"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-Expr" id=
"doc-xcore-Expr"></a>[<small>22&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-Expr"></a><a href=
"#prod-xcore-Expr">Expr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-ExprSingle">ExprSingle</a> (","
<a href="#doc-xcore-ExprSingle">ExprSingle</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-ExprSingle" id=
"doc-xcore-ExprSingle"></a>[<small>23&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-ExprSingle"></a><a href=
"#prod-xcore-ExprSingle">ExprSingle</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>FLWORExpr<br />
| <a href="#doc-xcore-QuantifiedExpr">QuantifiedExpr</a><br />
| <a href="#doc-xcore-TypeswitchExpr">TypeswitchExpr</a><br />
| <a href="#doc-xcore-IfExpr">IfExpr</a><br />
| <a href="#doc-xcore-OrExpr">OrExpr</a></code></td>
</tr>
</tbody>
</table>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>During static analysis, it is a type error for an expression to
have the empty type, except for the following expressions and
function calls:</p>
<ul>
<li>
<p>Empty parentheses <code>()</code>, which denote the empty
sequence.</p>
</li>
<li>
<p>The <code>fn:data</code> function and all functions in the
<em>fs</em> namespace applied to empty parentheses
<code>()</code>.</p>
</li>
<li>
<p>Any function which returns the empty type.</p>
</li>
</ul>
<p>The reason for these exceptions is that they are typically part
of the result of normalizing a larger user-level expression and are
used to capture the semantics of the user-level expression when
applied to the empty sequence.</p>
<p>The rule below enforces the above constraints. It is a static
type error, if the following conditions hold for a given expression
<em>Expr</em>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>Expr</em> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a> <a href="#jd_subtype_of" class=
"judgment"><b>&lt;:</b></a> <code>empty</code></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#jd_not" class="judgment"><b>not</b></a>(<em>Expr</em>
is the empty parentheses () or <code>fn:data</code> or any
<em>fs</em> function applied to empty parentheses ())</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>A static type error is raised for expression <em>Expr</em></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>In general, static type errors are raised whenever there
<span>is</span> <span>are</span> no static typing rules which can
compute the type of a given expression. This is the reason for the
absence of a formal <span>post-condition</span>
<span>conclusion</span> in this <span>rules</span>
<span>rule</span>. There is indeed a rule that infers the type for
expression <em>Expr</em>, however the inferred type is empty and
still a static type error must be raised.</p>
<p><b>Example</b></p>
<p>The above rule is useful in catching common mistakes, such as
the misspelling of an element or attribute name or referencing of
an element or attribute that does not exist. For instance, the
following path expression</p>
<div class="exampleInner">
<pre>
  $x/title
</pre></div>
<p>raises a static type error if the type of variable
<code>$x</code> does not include any <code>title</code> children
elements.</p>
<div class="div2">
<h3><a name="id-primary-expressions" id=
"id-primary-expressions"></a>4.1 Primary Expressions</h3>
<p><b>Primary expressions</b> are the basic primitives of the
language. They include literals, variables, function calls, and the
parenthesized expressions.</p>
<h5><a name="d6e8419" id="d6e8419"></a>Primary Expressions</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-PrimaryExpr" id=
"doc-xquery10-PrimaryExpr"></a>[<small>127&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-PrimaryExpr">PrimaryExpr</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery10-Literal">Literal</a><br />
| <a href="#doc-xquery10-VarRef">VarRef</a><br />
| <a href=
"#doc-xquery10-ParenthesizedExpr">ParenthesizedExpr</a><br />
| <a href="#doc-xquery10-ContextItemExpr">ContextItemExpr</a><br />
| <a href="#doc-xquery10-FunctionCall">FunctionCall</a><br />
| <a href="#doc-xquery10-OrderedExpr">OrderedExpr</a><br />
| <a href="#doc-xquery10-UnorderedExpr">UnorderedExpr</a><br />
| <a href="#doc-xquery10-Constructor">Constructor</a><br />
| FunctionItemExpr</code></td>
</tr>
</tbody>
</table>
<p><b>Core Grammar</b></p>
<p>The Core grammar production for primary expressions is:</p>
<h5><a name="d6e8465" id="d6e8465"></a>Primary Expressions</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-PrimaryExpr" id=
"doc-xcore-PrimaryExpr"></a>[<small>64&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-PrimaryExpr"></a><a href=
"#prod-xcore-PrimaryExpr">PrimaryExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-Literal">Literal</a><br />
| <a href="#doc-xcore-VarRef">VarRef</a><br />
| <a href=
"#doc-xcore-ParenthesizedExpr">ParenthesizedExpr</a><br />
| <a href="#doc-xcore-FunctionCall">FunctionCall</a><br />
| <a href="#doc-xcore-OrderedExpr">OrderedExpr</a><br />
| <a href="#doc-xcore-UnorderedExpr">UnorderedExpr</a><br />
| <a href="#doc-xcore-Constructor">Constructor</a></code></td>
</tr>
</tbody>
</table>
<div class="div3">
<h4><a name="id-literals" id="id-literals"></a>4.1.1 Literals</h4>
<p><b>Introduction</b></p>
<p>A <b>literal</b> is a direct syntactic representation of an
atomic value. [XPath/XQuery] supports two kinds of literals: string
literals and numeric literals.</p>
<h5><a name="d6e8508" id="d6e8508"></a>Literals</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-Literal" id=
"doc-xquery10-Literal"></a>[<small>128&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-Literal">Literal</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery10-NumericLiteral">NumericLiteral</a>
| <a href=
"#doc-xquery10-StringLiteral">StringLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-NumericLiteral" id=
"doc-xquery10-NumericLiteral"></a>[<small>129&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-NumericLiteral">NumericLiteral</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery10-IntegerLiteral">IntegerLiteral</a>
| <a href="#doc-xquery10-DecimalLiteral">DecimalLiteral</a> |
<a href="#doc-xquery10-DoubleLiteral">DoubleLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-IntegerLiteral" id=
"doc-xquery10-IntegerLiteral"></a>[<small>199&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-IntegerLiteral">IntegerLiteral</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery10-Digits">Digits</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-DecimalLiteral" id=
"doc-xquery10-DecimalLiteral"></a>[<small>200&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-DecimalLiteral">DecimalLiteral</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("." <a href="#doc-xquery10-Digits">Digits</a>) |
(<a href="#doc-xquery10-Digits">Digits</a> "." [0-9]*)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-DoubleLiteral" id=
"doc-xquery10-DoubleLiteral"></a>[<small>201&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-DoubleLiteral">DoubleLiteral</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(("." <a href="#doc-xquery10-Digits">Digits</a>) |
(<a href="#doc-xquery10-Digits">Digits</a> ("." [0-9]*)?)) [eE]
[+-]? <a href="#doc-xquery10-Digits">Digits</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-StringLiteral" id=
"doc-xquery10-StringLiteral"></a>[<small>202&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-StringLiteral">StringLiteral</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>('"' (<a href=
"#doc-xquery10-PredefinedEntityRef">PredefinedEntityRef</a> |
<a href="#prod-xquery10-CharRef">CharRef</a> | <a href=
"#doc-xquery10-EscapeQuot">EscapeQuot</a> | [^"&amp;])* '"') | ("'"
(<a href=
"#doc-xquery10-PredefinedEntityRef">PredefinedEntityRef</a> |
<a href="#prod-xquery10-CharRef">CharRef</a> | <a href=
"#doc-xquery10-EscapeApos">EscapeApos</a> | [^'&amp;])*
"'")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-URILiteral" id=
"doc-xquery10-URILiteral"></a>[<small>197&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-URILiteral">URILiteral</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery10-StringLiteral">StringLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-PredefinedEntityRef" id=
"doc-xquery10-PredefinedEntityRef"></a>[<small>203&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-PredefinedEntityRef">PredefinedEntityRef</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"&amp;" ("lt" | "gt" | "amp" | "quot" | "apos")
";"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-Digits" id=
"doc-xquery10-Digits"></a>[<small>216&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-Digits">Digits</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>[0-9]+</code></td>
</tr>
</tbody>
</table>
<p><b>Core Grammar</b></p>
<p>The Core grammar productions for literals are:</p>
<h5><a name="d6e8605" id="d6e8605"></a>Literals</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-Literal" id=
"doc-xcore-Literal"></a>[<small>65&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-Literal"></a><a href=
"#prod-xcore-Literal">Literal</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-NumericLiteral">NumericLiteral</a> |
<a href="#doc-xcore-StringLiteral">StringLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-NumericLiteral" id=
"doc-xcore-NumericLiteral"></a>[<small>66&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-NumericLiteral"></a><a href=
"#prod-xcore-NumericLiteral">NumericLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-IntegerLiteral">IntegerLiteral</a> |
<a href="#doc-xcore-DecimalLiteral">DecimalLiteral</a> | <a href=
"#doc-xcore-DoubleLiteral">DoubleLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-IntegerLiteral" id=
"doc-xcore-IntegerLiteral"></a>[<small>109&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-IntegerLiteral"></a><a href=
"#prod-xcore-IntegerLiteral">IntegerLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-Digits">Digits</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-DecimalLiteral" id=
"doc-xcore-DecimalLiteral"></a>[<small>110&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-DecimalLiteral"></a><a href=
"#prod-xcore-DecimalLiteral">DecimalLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("." <a href="#doc-xcore-Digits">Digits</a>) | (<a href=
"#doc-xcore-Digits">Digits</a> "." [0-9]*)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-DoubleLiteral" id=
"doc-xcore-DoubleLiteral"></a>[<small>111&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-DoubleLiteral"></a><a href=
"#prod-xcore-DoubleLiteral">DoubleLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(("." <a href="#doc-xcore-Digits">Digits</a>) | (<a href=
"#doc-xcore-Digits">Digits</a> ("." [0-9]*)?)) [eE] [+-]? <a href=
"#doc-xcore-Digits">Digits</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-StringLiteral" id=
"doc-xcore-StringLiteral"></a>[<small>112&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-StringLiteral"></a><a href=
"#prod-xcore-StringLiteral">StringLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>('"' (EscapeQuot | [^"])* '"') | ("'" (EscapeApos |
[^'])* "'")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-URILiteral" id=
"doc-xcore-URILiteral"></a>[<small>108&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-URILiteral"></a><a href=
"#prod-xcore-URILiteral">URILiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xcore-StringLiteral">StringLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-Digits" id=
"doc-xcore-Digits"></a>[<small>123&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-Digits"></a><a href=
"#prod-xcore-Digits">Digits</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>[0-9]+</code></td>
</tr>
</tbody>
</table>
<p><b>Notation</b></p>
<p>To define the dynamic semantics of literals, we introduce the
following auxiliary judgments.</p>
<p id="jd_has_atomic_value">The judgment</p>
<div align="center"><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>Literal</em> <a href=
"#jd_has_atomic_value" class="judgment"><b>has atomic value</b></a>
<a href="#doc-fs-AtomicValue"><em>AtomicValue</em></a></div>
<p>holds if the literal expression <em>Literal</em> corresponds to
the value <a href="#doc-fs-AtomicValue"><em>AtomicValue</em></a>.
This judgment yields an atomic value, according to the rules
described in <a href="#xquery-11">[XQuery 1.1: An XML Query
Language]</a>. Notably, this judgment deals with handling of
literal overflows for numeric literals, and handling of character
references, and predefined entity references for string
literals.</p>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>Literals are left unchanged through normalization.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>IntegerLiteral</em><font size="6">]</font><a href=
"#jd_map_expr" class="judgment"><sub><font size=
"2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<em>IntegerLiteral</em></td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>DecimalLiteral</em><font size="6">]</font><a href=
"#jd_map_expr" class="judgment"><sub><font size=
"2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<em>DecimalLiteral</em></td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>DoubleLiteral</em><font size="6">]</font><a href=
"#jd_map_expr" class="judgment"><sub><font size=
"2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<em>DoubleLiteral</em></td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>StringLiteral</em><font size="6">]</font><a href=
"#jd_map_expr" class="judgment"><sub><font size=
"2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<em>StringLiteral</em></td>
</tr>
</table>
</div>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>The static type of a literal expression is its corresponding
atomic type.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>IntegerLiteral</em>
<a href="#jd_has_type" class="judgment"><b>:</b></a>
xs:integer</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>DecimalLiteral</em>
<a href="#jd_has_type" class="judgment"><b>:</b></a>
xs:decimal</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>DoubleLiteral</em>
<a href="#jd_has_type" class="judgment"><b>:</b></a> xs:double</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>StringLiteral</em>
<a href="#jd_has_type" class="judgment"><b>:</b></a> xs:string</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p><b><a href="#processing_dynamic" class="processing">Dynamic
Evaluation</a></b></p>
<p>In the dynamic semantics, a literal is evaluated by constructing
an atomic value in the data model, using the <a href=
"#jd_has_atomic_value" class="judgment"><b>has atomic value</b></a>
judgment defined above.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>Literal</em> <a href=
"#jd_has_atomic_value" class="judgment"><b>has atomic value</b></a>
<a href="#doc-fs-AtomicValue"><em>AtomicValue</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>Literal</em> <a href=
"#jd_yields" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-AtomicValue"><em>AtomicValue</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
</div>
<div class="div3">
<h4><a name="id-variables" id="id-variables"></a>4.1.2 Variable
References</h4>
<p><b>Introduction</b></p>
<p>A <b>variable</b> evaluates to the value to which the variable's
QName is bound in the <b>dynamic context</b>.</p>
<h5><a name="d6e8911" id="d6e8911"></a>Variable References</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-VarRef" id=
"doc-xquery10-VarRef"></a>[<small>130&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-VarRef">VarRef</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"$" <a href=
"#doc-xquery10-VarName">VarName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-VarName" id=
"doc-xquery10-VarName"></a>[<small>131&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-VarName">VarName</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>_QName_or_EQName</code></td>
</tr>
</tbody>
</table>
<p><b>Core Grammar</b></p>
<p>The Core grammar productions for variable references are:</p>
<h5><a name="d6e8930" id="d6e8930"></a>Primary Expressions</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-VarRef" id=
"doc-xcore-VarRef"></a>[<small>67&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-VarRef"></a><a href=
"#prod-xcore-VarRef">VarRef</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"$" <a href="#doc-xcore-VarName">VarName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-VarName" id=
"doc-xcore-VarName"></a>[<small>68&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-VarName"></a><a href=
"#prod-xcore-VarName">VarName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>_QName_or_EQName</code></td>
</tr>
</tbody>
</table>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>Variable references are left unchanged through
normalization.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><a href=
"#prod-core-VarRef"><em>VarRef</em></a><font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><a href=
"#prod-core-VarRef"><em>VarRef</em></a></td>
</tr>
</table>
</div>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>In the static semantics, the type of a variable is simply its
type in the static environment <a href="#xq_stat_env_def" class=
"env">statEnv</a>.<a href="#xq_type_env" class=
"env">varType</a>:</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>VarName</em> <a href=
"#jd_var_qname_expands_to" class="judgment"><b>of var expands
to</b></a> <em>Variable</em></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_type_env" class="env">varType</a>(<em>Variable</em>) =
<a href="#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>$<em>VarName</em> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>If the variable is not bound in the static environment, a static
type error is raised.</p>
<p><b><a href="#processing_dynamic" class="processing">Dynamic
Evaluation</a></b></p>
<p>In the dynamic semantics, a locally declared variable is
evaluated by "looking up" its value in <a href="#xq_dyn_env_def"
class="env">dynEnv</a>.<a href="#xq_val_env" class=
"env">varValue</a>:</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>VarName</em> <a href=
"#jd_var_qname_expands_to" class="judgment"><b>of var expands
to</b></a> <em>Variable</em></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href=
"#xq_val_env" class="env">varValue</a>(<em>Variable</em>) =
<a href="#doc-fs-Value"><em>Value</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b>$<em>VarName</em> <a href=
"#jd_yields" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>In the dynamic semantics, a reference to a variable imported
from a module is evaluated by accessing the dynamic context of the
module in which the variable is declared.</p>
<p>The notation <em>AnyURI</em> <a href="#jd_module_dynEnv" class=
"judgment"><b>=&gt;</b><sub><font size=
"2">module_dynEnv</font></sub></a> <a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size="2">1</font></sub> is used to
access a module context and is defined in <a href=
"#id-module-declaration"><b>[5.2 Module Declaration]</b></a>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>VarName</em> <a href=
"#jd_var_qname_expands_to" class="judgment"><b>of var expands
to</b></a> <em>Variable</em></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href=
"#xq_val_env" class="env">varValue</a>(<em>Variable</em>) =
<code>#IMPORTED</code>(<em>AnyURI</em>)</td>
</tr>
<tr align="center" valign="middle">
<td><em>AnyURI</em> <a href="#jd_module_dynEnv" class=
"judgment"><b>=&gt;</b><sub><font size=
"2">module_dynEnv</font></sub></a> <a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size="2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size="2">1</font></sub>.<a href=
"#xq_val_env" class="env">varValue</a>(<em>Variable</em>) =
<a href="#doc-fs-Value"><em>Value</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b>$<em>VarName</em> <a href=
"#jd_yields" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
</div>
<div class="div3">
<h4><a name="id-paren-expressions" id=
"id-paren-expressions"></a>4.1.3 Parenthesized Expressions</h4>
<h5><a name="d6e9202" id="d6e9202"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-ParenthesizedExpr" id=
"doc-xquery10-ParenthesizedExpr"></a>[<small>132&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-ParenthesizedExpr">ParenthesizedExpr</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(" <a href="#doc-xquery10-Expr">Expr</a>?
")"</code></td>
</tr>
</tbody>
</table>
<p><b>Core Grammar</b></p>
<p>The Core grammar production for parenthesized expressions
is:</p>
<h5><a name="d6e9215" id="d6e9215"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-ParenthesizedExpr" id=
"doc-xcore-ParenthesizedExpr"></a>[<small>69&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-ParenthesizedExpr"></a><a href=
"#prod-xcore-ParenthesizedExpr">ParenthesizedExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(" <a href="#doc-xcore-Expr">Expr</a>? ")"</code></td>
</tr>
</tbody>
</table>
<p>Empty parentheses <code>()</code> always have the empty type.
Remember that it is a static type error for most expressions other
than <code>()</code> to have the empty type (see <a href=
"#id-expressions"><b>[4 Expressions]</b></a> for the complete
rule.)</p>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>() <a href="#jd_has_type"
class="judgment"><b>:</b></a> <code>empty</code></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>Expr</em> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>( <em>Expr</em> ) <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p><b><a href="#processing_dynamic" class="processing">Dynamic
Evaluation</a></b></p>
<p>Empty parentheses <code>()</code> evaluate to the empty
sequence.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b>() <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> ()</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>Expr</em> <a href=
"#jd_yields" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b>( <em>Expr</em> ) <a href=
"#jd_yields" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
</div>
<div class="div3">
<h4><a name="id-context-item-expression" id=
"id-context-item-expression"></a>4.1.4 Context Item Expression</h4>
<h5><a name="d6e9349" id="d6e9349"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-ContextItemExpr" id=
"doc-xquery10-ContextItemExpr"></a>[<small>133&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-ContextItemExpr">ContextItemExpr</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"."</code></td>
</tr>
</tbody>
</table>
<p><b>Introduction</b></p>
<p>A <b>context item expression</b> evaluates to the context item,
which may be either a node or an atomic value.</p>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>A context item expression is normalized to the built-in variable
<a href=
"#fs_builtin_vars"><code>$</code><em>fs:</em><code>dot</code></a>.
Because it can only be bound through the external context or a path
expression, there is no need for a specific static typing rule to
enforce that its value is a singleton item.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>.<font size="6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><a href=
"#fs_builtin_vars"><code>$</code><em>fs:</em><code>dot</code></a></td>
</tr>
</table>
</div>
</div>
<div class="div3">
<h4><a name="id-function-calls" id="id-function-calls"></a>4.1.5
Function Calls</h4>
<p><b>Introduction</b></p>
<p>A function call consists of a QName followed by a parenthesized
list of zero or more expressions. In [XPath/XQuery], the actual
argument to a function is called an <b>argument</b> and the formal
argument of a function is called a <b>parameter</b>. We use the
same terminology here.</p>
<h5><a name="d6e9402" id="d6e9402"></a>Function Calls</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-FunctionCall" id=
"doc-xquery10-FunctionCall"></a>[<small>136&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-FunctionCall">FunctionCall</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>_Function_QName_or_EQName (("(" (<a href=
"#doc-xquery10-ExprSingle">ExprSingle</a> ("," <a href=
"#doc-xquery10-ExprSingle">ExprSingle</a>)*)? ")") |
ArgumentList)</code></td>
</tr>
</tbody>
</table>
<p>Because [XPath/XQuery] implicitly converts the values of
function arguments, a normalization step is required.</p>
<p><b>Core Grammar</b></p>
<p>The Core grammar production for function calls is:</p>
<h5><a name="d6e9426" id="d6e9426"></a>Function Calls</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-FunctionCall" id=
"doc-xcore-FunctionCall"></a>[<small>73&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-FunctionCall"></a><a href=
"#prod-xcore-FunctionCall">FunctionCall</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>_Function_QName_or_EQName "(" (<a href=
"#doc-xcore-ExprSingle">ExprSingle</a> ("," <a href=
"#doc-xcore-ExprSingle">ExprSingle</a>)*)? ")"</code></td>
</tr>
</tbody>
</table>
<p><b>Notation</b></p>
<p id="jd_map_function_argument">Normalization of function calls
uses an auxiliary mapping <font size="6">[</font><font size=
"6">]</font><a href="#jd_map_function_argument" class=
"judgment"><sub><font size=
"2">FunctionArgument(Type)</font></sub></a> used to insert
conversions of function arguments that depend only on the expected
<a href="#doc-fs-Type"><em>Type</em></a> of the corresponding
parameters. It is defined as follows:</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>Expr</em><font size="6">]</font><a href=
"#jd_map_function_argument" class="judgment"><sub><font size=
"2">FunctionArgument(Type)</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><font size="6">[</font><font size=
"6">[</font><em>Expr</em><font size="6">]</font><a href=
"#jd_map_expr" class="judgment"><sub><font size=
"2">Expr</font></sub></a><font size="6">]</font><a href=
"#jd_map_function_argument" class="judgment"><sub><font size=
"2">AtomizeAtomic(Type)</font></sub></a><font size=
"6">]</font><a href="#jd_map_function_argument" class=
"judgment"><sub><font size="2">Convert(Type)</font></sub></a></td>
</tr>
</table>
</div>
<p>where</p>
<ul>
<li>
<p><font size="6">[</font><em>Expr</em><font size=
"6">]</font><a href="#jd_map_function_argument" class=
"judgment"><sub><font size="2">AtomizeAtomic(Type)</font></sub></a>
denotes</p>
<table summary="">
<tbody>
<tr>
<td>If</td>
<td><a href="#doc-fs-Type"><em>Type</em></a> <a href=
"#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>*</td>
</tr>
<tr>
<td>Then</td>
<td><code>fn:data</code>(<em>Expr</em>)</td>
<td>&#160;&#160;</td>
</tr>
<tr>
<td>Else</td>
<td><em>Expr</em></td>
<td>&#160;&#160;</td>
</tr>
</tbody>
</table>
<p>which specifies that if the function expects atomic parameters,
then <code>fn:data</code> is called to obtain them.</p>
</li>
<li>
<p><font size="6">[</font><em>Expr</em><font size=
"6">]</font><a href="#jd_map_function_argument" class=
"judgment"><sub><font size="2">Convert(Type)</font></sub></a>
denotes</p>
<table summary="">
<tbody>
<tr>
<td>If</td>
<td><a href="#doc-fs-Type"><em>Type</em></a> <a href=
"#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>*</td>
</tr>
<tr>
<td>Then</td>
<td><a href=
"#sec_convert_simple_operand"><em>fs:</em><code>convert-simple-operand</code></a>(<em>Expr</em>,<em>PrototypicalValue</em>)</td>
</tr>
<tr>
<td>Else</td>
<td><em>Expr</em></td>
</tr>
</tbody>
</table>
<p>where <em>PrototypicalValue</em> is a built-in atomic value used
to encode the expected atomic type (for instance the value
<code>1.0</code> if the expected type is <code>xs:decimal</code>).
A value is used here since [XPath/XQuery] expressions cannot
operate directly on types. Which value is chosen does not have any
impact on the actual semantics, only its actual atomic type
matters.</p>
</li>
</ul>
<p><b>Note</b></p>
<p>The <a href=
"#sec_convert_simple_operand"><em>fs:</em><code>convert-simple-operand</code></a>
function takes a <em>PrototypicalValue</em>, which is a value of
the target type, to ensure that conversion to base types is
possible even though types are not first class objects in
[XPath/XQuery]. Also, note that in the case of built-in functions
where the expected type is specified as numeric, the prototypical
value is a value of type <code>xs:double</code>.</p>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>Each argument expression in a function call is normalized to its
corresponding Core expression by applying <font size=
"6">[</font><font size="6">]</font><a href=
"#jd_map_function_argument" class="judgment"><sub><font size=
"2">FunctionArgument(Type)</font></sub></a> <span>for each
argument</span> <span>with the expected <em>SequenceType</em> for
the argument inserted.</span> <span>where <a href=
"#doc-fs-Type"><em>Type</em></a> is the corresponding parameter
type.</span></p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>QName</em> <a href=
"#jd_func_qname_expands_to" class="judgment"><b>of func expands
to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_not" class=
"judgment"><b>not</b></a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a> <a href=
"#jd_denotes_a_constructor_function" class="judgment"><b>denotes a
constructor function</b></a>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_functy_env" class="env">funcType</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>,n) = declare
function <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,
..., <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">n</font></sub>) as <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <font size=
"6">[</font><em>QName</em> (<em>Expr</em><sub><font size=
"2">1</font></sub>, ..., <em>Expr</em><sub><font size=
"2">n</font></sub>)<font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a> =
<em>QName</em> ( <font size=
"6">[</font><em>Expr</em><sub><font size=
"2">1</font></sub><font size="6">]</font><a href=
"#jd_map_function_argument" class="judgment"><sub><font size=
"2">FunctionArgument(Type1)</font></sub></a>, ..., <font size=
"6">[</font><em>Expr</em><sub><font size=
"2">n</font></sub><font size="6">]</font><a href=
"#jd_map_function_argument" class="judgment"><sub><font size=
"2">FunctionArgument(Typen)</font></sub></a> )</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><em>QName</em> (
<font size="6">[</font><em>Expr</em><sub><font size=
"2">1</font></sub><font size="6">]</font><a href=
"#jd_map_function_argument" class="judgment"><sub><font size=
"2">FunctionArgument(Type1)</font></sub></a>, ..., <font size=
"6">[</font><em>Expr</em><sub><font size=
"2">n</font></sub><font size="6">]</font><a href=
"#jd_map_function_argument" class="judgment"><sub><font size=
"2">FunctionArgument(Typen)</font></sub></a> )</td>
</tr>
</table>
</div>
<p>Note that this normalization rule depends on the function
<span>signatures,</span> <span>signature (found in <a href=
"#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_functy_env"
class="env">funcType</a>),</span> which is used to get the types of
the function parameters
<span>(<em>SequenceType</em><sub><font size="2">1</font></sub>,...,<em>SequenceType</em><sub><font size="2">n</font></sub>)</span>
<span>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>, ..., <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">n</font></sub>)</span>. <span>For user-defined functions, the
function signature can be obtained from the XQuery prolog where the
function is declared. For built-in functions, the signature is
given in the <a href="#xpath-functions-11">[Functions and Operators
1.1]</a> document. For overloaded built-in functions, several
signatures may exists, however, because they all correspond to
sequences of atomic values, they all result in the same
normalization.</span></p>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>Different sets of static typing rules are used to type check
function calls depending on which of the following categories
<span>the</span> <span>they</span> belong to: overloaded internal
functions, built-in functions with a specific static typing rule,
and other built-in and user-defined functions.</p>
<p>The following two rules <span>are common to all those
categories, and are used to bootstrap type inference, by first
looking-up the expanded QName for the function, then applying the
appropriate set of static typing rules depending on the category in
which the function is.</span> <span>factor out the step (common to
all those categories) of translating a type-inference judgment on
syntactic objects (<em>QName</em> and <em>Expr</em><sub><font size=
"2">i</font></sub>) into a type-inference judgment on semantic
objects (<a href="#id-expanded-qnames"><em>expanded-QName</em></a>
and <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">i</font></sub>).</span></p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>QName</em> <a href=
"#jd_func_qname_expands_to" class="judgment"><b>of func expands
to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>() <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <em>QName</em>() <a href="#jd_has_type"
class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>QName</em> <a href=
"#jd_func_qname_expands_to" class="judgment"><b>of func expands
to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
<em>Expr</em><sub><font size="2">1</font></sub> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td>...</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
<em>Expr</em><sub><font size="2">n</font></sub> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">n</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>,...,<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>)
<a href="#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <em>QName</em> (<em>Expr</em><sub><font size=
"2">1</font></sub>,...,<em>Expr</em><sub><font size=
"2">n</font></sub>) <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>The following depends on the kind of function call.</p>
<ol class="enumar">
<li>
<p>If the expanded QName for the function corresponds to one of the
overloaded internal <em>fs:</em> functions listed in <a href=
"#sec_operators"><b>[C.2 Mapping of Overloaded Internal
Functions]</b></a>, the static typing rules in <a href=
"#sec_operators"><b>[C.2 Mapping of Overloaded Internal
Functions]</b></a> are applied.</p>
</li>
<li>
<p>If the expanded QName for the function corresponds to one of the
built-in functions with a specialized static typing rule, listed in
<a href="#sec_special_functions"><b>[7 Additional Semantics of
Functions]</b></a>, the static typing rules in <a href=
"#sec_special_functions"><b>[7 Additional Semantics of
Functions]</b></a> are applied.</p>
</li>
<li>
<p>Otherwise, the following general static typing rules are
applied.</p>
</li>
</ol>
<p><span>Recall that <a href="#xq_stat_env_def" class=
"env">statEnv</a>.<a href="#xq_functy_env" class="env">funcType</a>
contains at most one function signature for any given (function
name, arity) pair.</span> The two following rules look up the
function in the static environment and check that <span>some
signature for the function satisfies the following constraint: the
type of each actual argument is a subtype of some type that</span>
<span>the type of each actual argument</span> can be promoted to
the type of the corresponding function parameter. In this case, the
function call is well typed and the result type is the return type
specified in the function's signature.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_functy_env" class="env">funcType</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>,0) = declare
function <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>() as <a href=
"#doc-fs-Type"><em>Type</em></a>'</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>() <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a>'</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_functy_env" class="env">funcType</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>,n) = declare
function <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>', ..., <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">n</font></sub>') as <a href=
"#doc-fs-Type"><em>Type</em></a>'</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_can_be_promoted_to" class="judgment"><b>can be
promoted to</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>'</td>
</tr>
<tr align="center" valign="middle">
<td>...</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>
<a href="#jd_can_be_promoted_to" class="judgment"><b>can be
promoted to</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">n</font></sub>'</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,
..., <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">n</font></sub>) <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a>'</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>The function body itself is not analyzed for each invocation:
static typing of the function definition itself guarantees that the
function body always returns a value of the declared return
type.</p>
<p>Notice that the static context contains at most one function
declaration for each function. This is possible since the treatment
of overloaded operators is done through a set of specific static
typing rules which do not require access to the environment. See
<a href="#sec_operators"><b>[C.2 Mapping of Overloaded Internal
Functions]</b></a>.</p>
<p><b>Notation</b></p>
<p id="jd_function_with_types">The following auxiliary judgment</p>
<div align="center"><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href=
"#jd_function_with_types" class="judgment"><b>function</b></a>
<a href="#id-expanded-qnames"><em>expanded-QName</em></a> <a href=
"#jd_function_with_types" class="judgment"><b>with types</b></a>
<a href="#jd_function_with_types" class="judgment"><b>on
values</b></a> <a href="#jd_function_with_types" class=
"judgment"><b>yields</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></div>
<p>holds when applying the function with expanded QName <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a> and no parameter
yields the value <a href="#doc-fs-Value"><em>Value</em></a>.</p>
<div align="center"><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href=
"#jd_function_with_types" class="judgment"><b>function</b></a>
<a href="#id-expanded-qnames"><em>expanded-QName</em></a> <a href=
"#jd_function_with_types" class="judgment"><b>with types</b></a>
(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>,...,<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>)
<a href="#jd_function_with_types" class="judgment"><b>on
values</b></a> (<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>,...,<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">n</font></sub>) <a href="#jd_function_with_types" class=
"judgment"><b>yields</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></div>
<p>holds when applying the function with expanded QName <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>, and parameters
of type (<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>,...,<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>)
on the values (<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>,...,<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">n</font></sub>) yields the value <a href=
"#doc-fs-Value"><em>Value</em></a>.</p>
<p>That judgment is defined below for each kind of function
(user-defined, built-in, external, and imported functions).</p>
<p><b><a href="#processing_dynamic" class="processing">Dynamic
Evaluation</a></b></p>
<p>The following rules apply to all the different kinds of
functions using the previously defined judgment.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>QName</em> <a href=
"#jd_func_qname_expands_to" class="judgment"><b>of func expands
to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_functy_env" class="env">funcType</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><span>,0</span>) =
<em>FunctionSig</em></td>
</tr>
<tr align="center" valign="middle">
<td><em>FunctionSig</em> = declare function <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>() as <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href=
"#jd_function_with_types" class="judgment"><b>function</b></a>
<a href="#id-expanded-qnames"><em>expanded-QName</em></a> <a href=
"#jd_function_with_types" class="judgment"><b>with types</b></a>
<a href="#jd_function_with_types" class="judgment"><b>on
values</b></a> <a href="#jd_function_with_types" class=
"judgment"><b>yields</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Value"><em>Value</em></a> <a href="#jd_promotes_to" class=
"judgment"><b>against</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a> <a href="#jd_promotes_to" class=
"judgment"><b>promotes to</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a>'</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a>
<b>&#160;|-&#160;</b> <em>QName</em>() <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a>'</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <em>Expr</em><sub><font size=
"2">1</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td>...</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <em>Expr</em><sub><font size=
"2">n</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">n</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>QName</em> <a href=
"#jd_func_qname_expands_to" class="judgment"><b>of func expands
to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_functy_env" class="env">funcType</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><span>,n</span>) =
<em>FunctionSig</em></td>
</tr>
<tr align="center" valign="middle">
<td><em>FunctionSig</em> = declare function <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,
..., <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">n</font></sub>) as <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_promotes_to" class=
"judgment"><b>against</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_promotes_to" class="judgment"><b>promotes to</b></a>
<a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>'</td>
</tr>
<tr align="center" valign="middle">
<td>...</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">n</font></sub> <a href="#jd_promotes_to" class=
"judgment"><b>against</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>
<a href="#jd_promotes_to" class="judgment"><b>promotes to</b></a>
<a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">n</font></sub>'</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href=
"#jd_function_with_types" class="judgment"><b>function</b></a>
<a href="#id-expanded-qnames"><em>expanded-QName</em></a> <a href=
"#jd_function_with_types" class="judgment"><b>with types</b></a>
(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>,...,<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>)
<a href="#jd_function_with_types" class="judgment"><b>on
values</b></a> (<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>',...,<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">n</font></sub>') <a href="#jd_function_with_types" class=
"judgment"><b>yields</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Value"><em>Value</em></a> <a href="#jd_promotes_to" class=
"judgment"><b>against</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a> <a href="#jd_promotes_to" class=
"judgment"><b>promotes to</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a>'</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a>
<b>&#160;|-&#160;</b> <em>QName</em> (
<em>Expr</em><sub><font size="2">1</font></sub>, ...,
<em>Expr</em><sub><font size="2">n</font></sub> ) <a href=
"#jd_yields" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a>'</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>First the function name is expanded, and the expanded name is
used to retrieve the function signature from the static
environment. Then, the rule evaluates each function argument
expression, and the resulting values are promoted according to the
expected type for the function. The result of evaluating the
function is obtained through the auxiliary judgment previously
defined, and the resulting value is promoted according to the
expected return type.</p>
<p>In case the function is a user defined function in a main
module, the expression body is retrieved from the dynamic
environment and used to compute the value of the function. The rule
extends <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href=
"#xq_val_env" class="env">varValue</a> by binding each formal
variable to its corresponding value, and evaluates the body of the
function in the new environment. The resulting value is the value
of the function call.</p>
<p>The notation <em>AnyURI</em> <a href="#jd_module_dynEnv" class=
"judgment"><b>=&gt;</b><sub><font size=
"2">module_dynEnv</font></sub></a> <a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size="2">1</font></sub> is used to
access a module context and is defined in <a href=
"#id-module-declaration"><b>[5.2 Module Declaration]</b></a>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href=
"#xq_func_env" class="env">funcDefn</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><span>,0</span>) =
(<em>Expr</em>)</td>
</tr>
<tr align="center" valign="middle">
<td>#MAIN <a href="#jd_module_dynEnv" class=
"judgment"><b>=&gt;</b><sub><font size=
"2">module_dynEnv</font></sub></a> <a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size="2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><span><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size="2">1</font></sub>.<a href=
"#xq_val_env" class="env">varValue</a></span> <span><a href=
"#xq_dyn_env_def" class="env">dynEnv</a><sub><font size=
"2">1</font></sub></span> <b>&#160;|-&#160;</b><em>Expr</em>
<a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href=
"#jd_function_with_types" class="judgment"><b>function</b></a>
<a href="#id-expanded-qnames"><em>expanded-QName</em></a> <a href=
"#jd_function_with_types" class="judgment"><b>with types</b></a>
<a href="#jd_function_with_types" class="judgment"><b>on
values</b></a> <a href="#jd_function_with_types" class=
"judgment"><b>yields</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href=
"#xq_func_env" class="env">funcDefn</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><span>,n</span>) =
(<em>Expr</em>, <em>Variable</em><sub><font size=
"2">1</font></sub>, ... , <em>Variable</em><sub><font size=
"2">n</font></sub>)</td>
</tr>
<tr align="center" valign="middle">
<td>#MAIN <a href="#jd_module_dynEnv" class=
"judgment"><b>=&gt;</b><sub><font size=
"2">module_dynEnv</font></sub></a> <a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size="2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size="2">1</font></sub> + <a href=
"#xq_val_env" class="env">varValue</a>(
<em>Variable</em><sub><font size="2">1</font></sub> =&gt; <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>; ...; <em>Variable</em><sub><font size=
"2">n</font></sub> =&gt; <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">n</font></sub>) <b>&#160;|-&#160;</b><em>Expr</em> <a href=
"#jd_yields" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href=
"#jd_function_with_types" class="judgment"><b>function</b></a>
<a href="#id-expanded-qnames"><em>expanded-QName</em></a> <a href=
"#jd_function_with_types" class="judgment"><b>with types</b></a>
(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>,...,<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>)
<a href="#jd_function_with_types" class="judgment"><b>on
values</b></a> (<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>,...,<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">n</font></sub>) <a href="#jd_function_with_types" class=
"judgment"><b>yields</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>Note that the function body is evaluated in the dynamic
environment containing the main module declarations.</p>
<p>The rule for evaluating <span>an</span> <span>a</span> function
imported from a module is similar to that for evaluating a
user-defined function in a main module, except that the function
call is evaluated in the dynamic context of the module in which it
is declared, and that the appropriate additional type matching must
be performed.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href=
"#xq_func_env" class="env">funcDefn</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><span>,0</span>) =
<code>#IMPORTED</code>(<em>AnyURI</em>)</td>
</tr>
<tr align="center" valign="middle">
<td><em>AnyURI</em> <a href="#jd_module_statEnv" class=
"judgment"><b>=&gt;</b><sub><font size=
"2">module_statEnv</font></sub></a> <a href="#xq_stat_env_def"
class="env">statEnv</a><sub><font size="2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><em>AnyURI</em> <a href="#jd_module_dynEnv" class=
"judgment"><b>=&gt;</b><sub><font size=
"2">module_dynEnv</font></sub></a> <a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size="2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">1</font></sub>.<a href=
"#xq_functy_env" class="env">funcType</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><span>,0</span>) =
<em>FunctionSig</em>'</td>
</tr>
<tr align="center" valign="middle">
<td><em>FunctionSig</em>' = declare function <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>() as <a href=
"#doc-fs-Type"><em>Type</em></a>'</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size="2">1</font></sub>.<a href=
"#xq_func_env" class="env">funcDefn</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><span>,0</span>) =
(<em>Expr</em>)</td>
</tr>
<tr align="center" valign="middle">
<td><span><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size="2">1</font></sub>.<a href=
"#xq_val_env" class="env">varValue</a></span> <span><a href=
"#xq_dyn_env_def" class="env">dynEnv</a><sub><font size=
"2">1</font></sub></span> <b>&#160;|-&#160;</b><em>Expr</em>
<a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-Value"><em>Value</em></a> <a href="#jd_matches" class=
"judgment"><b>matches</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a>'</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href=
"#jd_function_with_types" class="judgment"><b>function</b></a>
<a href="#id-expanded-qnames"><em>expanded-QName</em></a> <a href=
"#jd_function_with_types" class="judgment"><b>with types</b></a>
<a href="#jd_function_with_types" class="judgment"><b>on
values</b></a> <a href="#jd_function_with_types" class=
"judgment"><b>yields</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href=
"#xq_func_env" class="env">funcDefn</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><span>,n</span>) =
<code>#IMPORTED</code>(<em>AnyURI</em>)</td>
</tr>
<tr align="center" valign="middle">
<td><em>AnyURI</em> <a href="#jd_module_statEnv" class=
"judgment"><b>=&gt;</b><sub><font size=
"2">module_statEnv</font></sub></a> <a href="#xq_stat_env_def"
class="env">statEnv</a><sub><font size="2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><em>AnyURI</em> <a href="#jd_module_dynEnv" class=
"judgment"><b>=&gt;</b><sub><font size=
"2">module_dynEnv</font></sub></a> <a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size="2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">1</font></sub>.<a href=
"#xq_functy_env" class="env">funcType</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><span>,n</span>) =
<em>FunctionSig</em>'</td>
</tr>
<tr align="center" valign="middle">
<td><em>FunctionSig</em>' = declare function <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>', ..., <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">n</font></sub>') as <a href=
"#doc-fs-Type"><em>Type</em></a>'</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_matches" class=
"judgment"><b>matches</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>'</td>
</tr>
<tr align="center" valign="middle">
<td>...</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">n</font></sub> <a href="#jd_matches" class=
"judgment"><b>matches</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">n</font></sub>'</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size="2">1</font></sub>.<a href=
"#xq_func_env" class="env">funcDefn</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><span>,n</span>) =
(<em>Expr</em>, <em>Variable</em><sub><font size=
"2">1</font></sub>, ... , <em>Variable</em><sub><font size=
"2">n</font></sub>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size="2">1</font></sub> + <a href=
"#xq_val_env" class="env">varValue</a>(
<em>Variable</em><sub><font size="2">1</font></sub> =&gt; <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>; ...; <em>Variable</em><sub><font size=
"2">n</font></sub> =&gt; <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">n</font></sub>) <b>&#160;|-&#160;</b><em>Expr</em> <a href=
"#jd_yields" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-Value"><em>Value</em></a> <a href="#jd_matches" class=
"judgment"><b>matches</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a>'</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href=
"#jd_function_with_types" class="judgment"><b>function</b></a>
<a href="#id-expanded-qnames"><em>expanded-QName</em></a> <a href=
"#jd_function_with_types" class="judgment"><b>with types</b></a>
(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>,...,<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>)
<a href="#jd_function_with_types" class="judgment"><b>on
values</b></a> (<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>,...,<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">n</font></sub>) <a href="#jd_function_with_types" class=
"judgment"><b>yields</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>If the function is a built-in function (resp. special formal
semantics function), the value returned by the function is the one
specified in <a href="#xpath-functions-11">[Functions and Operators
1.1]</a> (resp. <span><a href="#sec_special_functions"><b>[7
Additional Semantics of Functions]</b></a></span> <span><a href=
"#sec_special_fs_functions"><b>[7.1 Formal Semantics
Functions]</b></a></span> <span>or <a href="#sec_operators"><b>[C.2
Mapping of Overloaded Internal Functions]</b></a></span>).</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href=
"#xq_func_env" class="env">funcDefn</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><span>,0</span>) =
<code>#BUILT-IN</code></td>
</tr>
<tr align="center" valign="middle">
<td>The built-in function <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a> (See <a href=
"#xpath-functions-11">[Functions and Operators 1.1]</a> or
<span><a href="#sec_special_functions"><b>[7 Additional Semantics
of Functions]</b></a></span> <span><a href=
"#sec_special_fs_functions"><b>[7.1 Formal Semantics
Functions]</b></a></span> <span>or <a href="#sec_operators"><b>[C.2
Mapping of Overloaded Internal Functions]</b></a></span>) yields
the value <a href="#doc-fs-Value"><em>Value</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href=
"#jd_function_with_types" class="judgment"><b>function</b></a>
<a href="#id-expanded-qnames"><em>expanded-QName</em></a> <a href=
"#jd_function_with_types" class="judgment"><b>with types</b></a>
<a href="#jd_function_with_types" class="judgment"><b>on
values</b></a> <a href="#jd_function_with_types" class=
"judgment"><b>yields</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href=
"#xq_func_env" class="env">funcDefn</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><span>,n</span>) =
<code>#BUILT-IN</code></td>
</tr>
<tr align="center" valign="middle">
<td>The built-in function <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a> (See <a href=
"#xpath-functions-11">[Functions and Operators 1.1]</a> or
<span><a href="#sec_special_functions"><b>[7 Additional Semantics
of Functions]</b></a></span> <span><a href=
"#sec_special_fs_functions"><b>[7.1 Formal Semantics
Functions]</b></a></span> <span>or <a href="#sec_operators"><b>[C.2
Mapping of Overloaded Internal Functions]</b></a></span>) applied
to values (<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>,...,<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">n</font></sub>) yields the value <a href=
"#doc-fs-Value"><em>Value</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href=
"#jd_function_with_types" class="judgment"><b>function</b></a>
<a href="#id-expanded-qnames"><em>expanded-QName</em></a> <a href=
"#jd_function_with_types" class="judgment"><b>with types</b></a>
(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>,...,<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>)
<a href="#jd_function_with_types" class="judgment"><b>on
values</b></a> (<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>,...,<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">n</font></sub>) <a href="#jd_function_with_types" class=
"judgment"><b>yields</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>If the function is an external function, the value returned by
the function is implementation-defined.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href=
"#xq_func_env" class="env">funcDefn</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><span>,0</span>) =
<code>#EXTERNAL</code></td>
</tr>
<tr align="center" valign="middle">
<td>The external function <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a> yields the value
<a href="#doc-fs-Value"><em>Value</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href=
"#jd_function_with_types" class="judgment"><b>function</b></a>
<a href="#id-expanded-qnames"><em>expanded-QName</em></a> <a href=
"#jd_function_with_types" class="judgment"><b>with types</b></a>
<a href="#jd_function_with_types" class="judgment"><b>on
values</b></a> <a href="#jd_function_with_types" class=
"judgment"><b>yields</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href=
"#xq_func_env" class="env">funcDefn</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><span>,n</span>) =
<code>#EXTERNAL</code></td>
</tr>
<tr align="center" valign="middle">
<td>The external function <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a> applied to values
(<a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>,...,<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">n</font></sub>) yields the value <a href=
"#doc-fs-Value"><em>Value</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href=
"#jd_function_with_types" class="judgment"><b>function</b></a>
<a href="#id-expanded-qnames"><em>expanded-QName</em></a> <a href=
"#jd_function_with_types" class="judgment"><b>with types</b></a>
(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>,...,<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>)
<a href="#jd_function_with_types" class="judgment"><b>on
values</b></a> (<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>,...,<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">n</font></sub>) <a href="#jd_function_with_types" class=
"judgment"><b>yields</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
</div>
</div>
<div class="div2">
<h3><a name="id-path-expressions" id="id-path-expressions"></a>4.2
Path Expressions</h3>
<p><b>Introduction</b></p>
<p>Path expressions are used to locate nodes within a tree. There
are two kinds of path expressions, absolute path expressions and
relative path expressions. An absolute path expression is a rooted
relative path expression. A relative path expression is composed of
a sequence of steps.</p>
<h5><a name="d6e12074" id="d6e12074"></a>Path Expressions</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-PathExpr" id=
"doc-xquery10-PathExpr"></a>[<small>109&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-PathExpr">PathExpr</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("/" <a href=
"#doc-xquery10-RelativePathExpr">RelativePathExpr</a>?)<br />
| ("//" <a href=
"#doc-xquery10-RelativePathExpr">RelativePathExpr</a>)<br />
| <a href=
"#doc-xquery10-RelativePathExpr">RelativePathExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-RelativePathExpr" id=
"doc-xquery10-RelativePathExpr"></a>[<small>110&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-RelativePathExpr">RelativePathExpr</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery10-StepExpr">StepExpr</a> (("/" |
"//") <a href="#doc-xquery10-StepExpr">StepExpr</a>)*</code></td>
</tr>
</tbody>
</table>
<p><b>Core Grammar</b></p>
<p>PathExpr and RelativePathExpr are fully normalized, therefore
they have no corresponding productions in the Core. The grammar for
path expressions in the Core starts with the StepExpr
production.</p>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>Absolute path expressions are path expressions starting with the
<code>/</code> or <code>//</code> symbols, indicating that the
expression must be applied on the root node in the current context.
The root node in the current context is the greatest ancestor of
the context node. The following two rules normalize absolute path
expressions to relative ones. They use the <code>fn:root</code>
function, which returns the greatest ancestor of its argument node.
The treat expressions guarantee that the value bound to the context
variable <a href=
"#fs_builtin_vars"><code>$</code><em>fs:</em><code>dot</code></a>
is a document node.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>/<font size="6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>(<code>fn:root</code>(self::node()) treat as
document-node())<font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>/ <em>RelativePathExpr</em><font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>((<code>fn:root</code>(self::node())) treat as
document-node()) / <em>RelativePathExpr</em><font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>// <em>RelativePathExpr</em><font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>((<code>fn:root</code>(self::node())) treat as
document-node()) / <code>descendant-or-self::node()</code> /
<em>RelativePathExpr</em><font size="6">]</font><a href=
"#jd_map_expr" class="judgment"><sub><font size=
"2">Expr</font></sub></a></td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>RelativePathExpr</em> // <em>StepExpr</em>
<font size="6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>RelativePathExpr</em> / descendant-or-self::node()
/ <em>StepExpr</em><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
</table>
</div>
<p>A composite relative path expression (using <code>/</code>) is
normalized into a <code>for</code> expression by concatenating the
sequences obtained by mapping each node of the left-hand side in
document order to the sequence it generates on the right-hand side.
The call to the <a href=
"#sec_distinct_docorder"><em>fs:</em><code>distinct-doc-order</code></a>
function ensures that the result is in document order without
duplicates. The dynamic context is defined by binding the
<code>$</code><em>fs:</em><code>dot</code>,
<code>$</code><em>fs:</em><code>sequence</code>,
<code>$</code><em>fs:</em><code>position</code> and
<code>$</code><em>fs:</em><code>last</code> variables.</p>
<p>Note that sorting by document order enforces the restriction
that input and output sequences contains only nodes, and that the
last step in a path expression may actually return atomic
values.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>RelativePathExpr</em> /
<em>StepExpr</em><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<table summary="">
<tbody>
<tr>
<td><a href=
"#sec_apply_ordering_mode"><em>fs:</em><code>apply-ordering-mode</code></a>
(</td>
</tr>
<tr>
<td><a href=
"#sec_distinct_docorder_or_atomic_sequence"><em>fs:</em><code>distinct-doc-order-or-atomic-sequence</code></a>
(</td>
</tr>
<tr>
<td>&#160;&#160;let <code>$</code><em>fs:</em><code>sequence</code>
:= <a href=
"#sec_node_sequence"><em>fs:</em><code>node-sequence</code></a>(
<font size="6">[</font><em>RelativePathExpr</em><font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a> ) return</td>
</tr>
<tr>
<td>&#160;&#160;let <a href=
"#fs_builtin_vars"><code>$</code><em>fs:</em><code>last</code></a>
:= fn:count(<code>$</code><em>fs:</em><code>sequence</code>)
return</td>
</tr>
<tr>
<td>&#160;&#160;for <a href=
"#fs_builtin_vars"><code>$</code><em>fs:</em><code>dot</code></a>
at <a href=
"#fs_builtin_vars"><code>$</code><em>fs:</em><code>position</code></a>
in <code>$</code><em>fs:</em><code>sequence</code> return</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;<font size=
"6">[</font><em>StepExpr</em><font size="6">]</font><a href=
"#jd_map_expr" class="judgment"><sub><font size=
"2">Expr</font></sub></a></td>
</tr>
<tr>
<td>))</td>
</tr>
</tbody>
</table>
</td>
</tr>
</table>
</div>
<div class="div3">
<h4><a name="id-axis-steps" id="id-axis-steps"></a>4.2.1 Steps</h4>
<p>Note that this section uses some auxiliary judgments which are
defined in <a href="#sec_auxiliary_xpath"><b>[8.2 Judgments for
step expressions and filtering]</b></a>.</p>
<p><b>Introduction</b></p>
<h5><a name="d6e12383" id="d6e12383"></a>Steps</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-StepExpr" id=
"doc-xquery10-StepExpr"></a>[<small>111&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-StepExpr">StepExpr</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery10-FilterExpr">FilterExpr</a> |
PostfixExpr | <a href=
"#doc-xquery10-AxisStep">AxisStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-AxisStep" id=
"doc-xquery10-AxisStep"></a>[<small>112&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-AxisStep">AxisStep</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#doc-xquery10-ReverseStep">ReverseStep</a> |
<a href="#doc-xquery10-ForwardStep">ForwardStep</a>) <a href=
"#doc-xquery10-PredicateList">PredicateList</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-ForwardStep" id=
"doc-xquery10-ForwardStep"></a>[<small>113&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-ForwardStep">ForwardStep</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#doc-xquery10-ForwardAxis">ForwardAxis</a>
<a href="#doc-xquery10-NodeTest">NodeTest</a>) | <a href=
"#doc-xquery10-AbbrevForwardStep">AbbrevForwardStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-ReverseStep" id=
"doc-xquery10-ReverseStep"></a>[<small>116&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-ReverseStep">ReverseStep</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#doc-xquery10-ReverseAxis">ReverseAxis</a>
<a href="#doc-xquery10-NodeTest">NodeTest</a>) | <a href=
"#doc-xquery10-AbbrevReverseStep">AbbrevReverseStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-PredicateList" id=
"doc-xquery10-PredicateList"></a>[<small>125&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-PredicateList">PredicateList</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery10-Predicate">Predicate</a>*</code></td>
</tr>
</tbody>
</table>
<p><b>Core Grammar</b></p>
<p>The Core grammar productions for XPath steps are:</p>
<h5><a name="d6e12447" id="d6e12447"></a>Steps</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-StepExpr" id=
"doc-xcore-StepExpr"></a>[<small>51&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-StepExpr"></a><a href=
"#prod-xcore-StepExpr">StepExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-PrimaryExpr">PrimaryExpr</a> |
<a href="#doc-xcore-AxisStep">AxisStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-AxisStep" id=
"doc-xcore-AxisStep"></a>[<small>52&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-AxisStep"></a><a href=
"#prod-xcore-AxisStep">AxisStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#doc-xcore-ReverseStep">ReverseStep</a> |
<a href="#doc-xcore-ForwardStep">ForwardStep</a>)
PredicateList</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-ForwardStep" id=
"doc-xcore-ForwardStep"></a>[<small>53&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-ForwardStep"></a><a href=
"#prod-xcore-ForwardStep">ForwardStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#doc-xcore-ForwardAxis">ForwardAxis</a>
<a href="#doc-xcore-NodeTest">NodeTest</a>) |
AbbrevForwardStep</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-ReverseStep" id=
"doc-xcore-ReverseStep"></a>[<small>56&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-ReverseStep"></a><a href=
"#prod-xcore-ReverseStep">ReverseStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-ReverseAxis">ReverseAxis</a> <a href=
"#doc-xcore-NodeTest">NodeTest</a></code></td>
</tr>
</tbody>
</table>
<p><b>Note</b></p>
<p>Step expressions can be followed by predicates. Normalization of
predicates uses the following auxiliary mapping rule: <font size=
"6">[</font><font size="6">]</font><a href="#jd_map_predicates"
class="judgment"><sub><font size="2">Predicates</font></sub></a>,
which is specified in <a href="#id-predicates"><b>[4.2.2
Predicates]</b></a>. Normalization for step expressions also uses
the following auxiliary mapping rule: <font size=
"6">[</font><font size="6">]</font><a href="#jd_map_axis" class=
"judgment"><sub><font size="2">Axis</font></sub></a>, which is
specified in <a href="#sec_axes"><b>[4.2.1.1 Axes]</b></a>.</p>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>Normalization of predicates need to distinguish between forward
steps, reverse steps, and primary expressions.</p>
<p>As explained in the [XPath/XQuery] document, applying a step in
XPath changes the focus (or context). The change of focus is made
explicit by the normalization rule below, which binds the variable
<a href=
"#fs_builtin_vars"><code>$</code><em>fs:</em><code>dot</code></a>
to the node currently being processed, and the variable <a href=
"#fs_builtin_vars"><code>$</code><em>fs:</em><code>position</code></a>
to the position (i.e., the position within the input sequence) of
that node.</p>
<p>There are two sets of normalization rules for Predicates. The
first set of rules apply when the predicate is a numeric literal or
the expression <code>last()</code>. The second set of rules apply
to all predicate expressions other than numeric literals and the
expression <code>last()</code>. In the first case, the
normalization rules provides a more precise static type than if the
general rules were applied.</p>
<p>When the predicate expression is a numeric literal or the
<code>fn:last</code> function, the following normalization rules
apply.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>ForwardStep</em> <em>PredicateList</em> [
<em>NumericLiteral</em> ]<font size="6">]</font><a href=
"#jd_map_expr" class="judgment"><sub><font size=
"2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<table summary="">
<tbody>
<tr>
<td>let <code>$</code><em>fs:</em><code>sequence</code> := <a href=
"#sec_apply_ordering_mode"><em>fs:</em><code>apply-ordering-mode</code></a>(<a href="#sec_distinct_docorder"><em>fs:</em><code>distinct-doc-order</code></a>(
<font size="6">[</font><em>ForwardStep</em>
<em>PredicateList</em><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a> ))
return</td>
</tr>
<tr>
<td><span><a href=
"#sec_item_at"><em>fs:</em><code>item-at</code></a></span>(<code>$</code><em>fs:</em><code>sequence</code>,<em>NumericLiteral</em><span>,1</span>)</td>
</tr>
</tbody>
</table>
</td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>ForwardStep</em> <em>PredicateList</em> [
<code>fn:last</code>() ]<font size="6">]</font><a href=
"#jd_map_expr" class="judgment"><sub><font size=
"2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<table summary="">
<tbody>
<tr>
<td>let <code>$</code><em>fs:</em><code>sequence</code> := <a href=
"#sec_apply_ordering_mode"><em>fs:</em><code>apply-ordering-mode</code></a>(<a href="#sec_distinct_docorder"><em>fs:</em><code>distinct-doc-order</code></a>(
<font size="6">[</font><em>ForwardStep</em>
<em>PredicateList</em><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a> ))
return</td>
</tr>
<tr>
<td>let <a href=
"#fs_builtin_vars"><code>$</code><em>fs:</em><code>last</code></a>
:=
<code>fn:count</code>(<code>$</code><em>fs:</em><code>sequence</code>)
return</td>
</tr>
<tr>
<td><span><a href=
"#sec_item_at"><em>fs:</em><code>item-at</code></a></span>(<code>$</code><em>fs:</em><code>sequence</code>,<a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>last</code></a><span>,1</span>)</td>
</tr>
</tbody>
</table>
</td>
</tr>
</table>
</div>
<p>When predicates are applied on a reverse step, the position
variable is bound in reverse document order.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>ReverseStep</em> <em>PredicateList</em> [
<em>NumericLiteral</em> ]<font size="6">]</font><a href=
"#jd_map_expr" class="judgment"><sub><font size=
"2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<table summary="">
<tbody>
<tr>
<td>let <code>$</code><em>fs:</em><code>sequence</code> := <a href=
"#sec_apply_ordering_mode"><em>fs:</em><code>apply-ordering-mode</code></a>(<a href="#sec_distinct_docorder"><em>fs:</em><code>distinct-doc-order</code></a>(
<font size="6">[</font><em>ReverseStep</em>
<em>PredicateList</em><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a> ))
return</td>
</tr>
<tr>
<td>let <a href=
"#fs_builtin_vars"><code>$</code><em>fs:</em><code>last</code></a>
:= fn:count(<code>$</code><em>fs:</em><code>sequence</code>)
return</td>
</tr>
<tr>
<td>let <a href=
"#fs_builtin_vars"><code>$</code><em>fs:</em><code>position</code></a>
:= <em>fs:</em><code>plus</code>(1,
<em>fs:</em><code>minus</code>(<a href=
"#fs_builtin_vars"><code>$</code><em>fs:</em><code>last</code></a>,<em>NumericLiteral</em>))
return</td>
</tr>
<tr>
<td>&#160;&#160;<span><a href=
"#sec_item_at"><em>fs:</em><code>item-at</code></a></span>(<code>$</code><em>fs:</em><code>sequence</code>,<a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>position</code></a><span>,1</span>)</td>
</tr>
</tbody>
</table>
</td>
</tr>
</table>
</div>
<p>When the step is a reverse axis, then the last item in the
context sequence is the first in document order.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>ReverseStep</em> <em>PredicateList</em> [
<code>fn:last</code>() ]<font size="6">]</font><a href=
"#jd_map_expr" class="judgment"><sub><font size=
"2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<table summary="">
<tbody>
<tr>
<td>let <code>$</code><em>fs:</em><code>sequence</code> := <a href=
"#sec_apply_ordering_mode"><em>fs:</em><code>apply-ordering-mode</code></a>(<a href="#sec_distinct_docorder"><em>fs:</em><code>distinct-doc-order</code></a>(
<font size="6">[</font><em>ReverseStep</em>
<em>PredicateList</em><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a> ))
return</td>
</tr>
<tr>
<td>&#160;&#160;<span><a href=
"#sec_item_at"><em>fs:</em><code>item-at</code></a></span>(<code>$</code><em>fs:</em><code>sequence</code>,1<span>,1</span>)</td>
</tr>
</tbody>
</table>
</td>
</tr>
</table>
</div>
<p>The normalization rules above all use the function
<span><a href="#sec_item_at"><em>fs:</em><code>item-at</code></a></span>
to select a particular item. The static typing rules for this
function are defined in <span><a href="#sec_item_at"><b>[7.1.14 The
fs:item-at function]</b></a></span>.</p>
<p>When predicates are applied on a forward step, the input
sequence is first sorted in document order and duplicates are
removed. The context is changed by binding the <a href=
"#fs_builtin_vars"><code>$</code><em>fs:</em><code>dot</code></a>
variable to each node in document order.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>ForwardStep</em> <em>PredicateList</em> [
<em>Expr</em> ]<font size="6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<table summary="">
<tbody>
<tr>
<td>let <code>$</code><em>fs:</em><code>sequence</code> := <a href=
"#sec_apply_ordering_mode"><em>fs:</em><code>apply-ordering-mode</code></a>(<a href="#sec_distinct_docorder"><em>fs:</em><code>distinct-doc-order</code></a>(
<font size="6">[</font><em>ForwardStep</em>
<em>PredicateList</em><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a> ))
return</td>
</tr>
<tr>
<td>let <a href=
"#fs_builtin_vars"><code>$</code><em>fs:</em><code>last</code></a>
:= fn:count(<code>$</code><em>fs:</em><code>sequence</code>)
return</td>
</tr>
<tr>
<td>for <a href=
"#fs_builtin_vars"><code>$</code><em>fs:</em><code>dot</code></a>
at <a href=
"#fs_builtin_vars"><code>$</code><em>fs:</em><code>position</code></a>
in <code>$</code><em>fs:</em><code>sequence</code> return</td>
</tr>
<tr>
<td>&#160;&#160; if (<font size=
"6">[</font><em>Expr</em><font size="6">]</font><a href=
"#jd_map_predicates" class="judgment"><sub><font size=
"2">Predicates</font></sub></a>) then <a href=
"#fs_builtin_vars"><code>$</code><em>fs:</em><code>dot</code></a>
else ()</td>
</tr>
</tbody>
</table>
</td>
</tr>
</table>
</div>
<p>When predicates are applied on a reverse step, the input
sequence is first sorted in document order and duplicates are
removed. The context is changed by binding the <a href=
"#fs_builtin_vars"><code>$</code><em>fs:</em><code>dot</code></a>
variable to each node in document order.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>ReverseStep</em> <em>PredicateList</em> [
<em>Expr</em> ]<font size="6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<table summary="">
<tbody>
<tr>
<td>let <code>$</code><em>fs:</em><code>sequence</code> := <a href=
"#sec_apply_ordering_mode"><em>fs:</em><code>apply-ordering-mode</code></a>(<a href="#sec_distinct_docorder"><em>fs:</em><code>distinct-doc-order</code></a>(
<font size="6">[</font><em>ReverseStep</em>
<em>PredicateList</em><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a> ))
return</td>
</tr>
<tr>
<td>let <a href=
"#fs_builtin_vars"><code>$</code><em>fs:</em><code>last</code></a>
:= fn:count(<code>$</code><em>fs:</em><code>sequence</code>)
return</td>
</tr>
<tr>
<td>for <a href=
"#fs_builtin_vars"><code>$</code><em>fs:</em><code>dot</code></a>
at $<em>fs:</em>new in
<code>$</code><em>fs:</em><code>sequence</code> return</td>
</tr>
<tr>
<td>let <a href=
"#fs_builtin_vars"><code>$</code><em>fs:</em><code>position</code></a>
:=
<em>fs:</em><code>plus</code>(1,<em>fs:</em><code>minus</code>(<a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>last</code></a>,$<em>fs:</em>new))
return</td>
</tr>
<tr>
<td>&#160;&#160;if (<font size="6">[</font><em>Expr</em><font size=
"6">]</font><a href="#jd_map_predicates" class=
"judgment"><sub><font size="2">Predicates</font></sub></a>) then
<a href=
"#fs_builtin_vars"><code>$</code><em>fs:</em><code>dot</code></a>
else ()</td>
</tr>
</tbody>
</table>
</td>
</tr>
</table>
</div>
<p>Finally, a stand-alone forward or reverse step is normalized by
the auxiliary normalization rule for <em>Axis</em>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>ForwardStep</em><font size="6">]</font><a href=
"#jd_map_expr" class="judgment"><sub><font size=
"2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><a href=
"#sec_apply_ordering_mode"><em>fs:</em><code>apply-ordering-mode</code></a>(<font size="6">[</font><em>ForwardStep</em><font size="6">]</font><a href="#jd_map_axis"
class="judgment"><sub><font size="2">Axis</font></sub></a>)</td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>ReverseStep</em><font size="6">]</font><a href=
"#jd_map_expr" class="judgment"><sub><font size=
"2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><a href=
"#sec_apply_ordering_mode"><em>fs:</em><code>apply-ordering-mode</code></a>(<font size="6">[</font><em>ReverseStep</em><font size="6">]</font><a href="#jd_map_axis"
class="judgment"><sub><font size="2">Axis</font></sub></a>)</td>
</tr>
</table>
</div>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>The static semantics of an <em>Axis</em> <em>NodeTest</em> pair
is obtained by retrieving the type of the context node, and
applying the two filters (the <em>Axis</em>, and then the
<em>NodeTest</em> with a <em>PrincipalNodeKind</em>) on the
result.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_type_env" class=
"env">varType</a>((<code>FS-URI</code>,"<code>dot</code>")) =
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
<font size="6">[</font>node()<font size="6">]</font><a href=
"#jd_map_sequencetype" class="judgment"><sub><font size=
"2">sequencetype</font></sub></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <em>Axis</em> <a href="#jd_axis"
class="judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_axis_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><em>Axis</em> <a href="#jd_principal" class="judgment"><b>has
principal</b></a> <em>PrincipalNodeKind</em></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>NodeTest</em> <a href=
"#jd_test_type" class="judgment"><b>with</b></a>
<em>PrincipalNodeKind</em> <a href="#jd_test_type" class=
"judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_test_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">3</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <em>Axis</em>
<em>NodeTest</em> <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">3</font></sub></td>
</tr>
</table>
<br /></div>
<p><b>Note</b></p>
<p>Note that the second judgment in the rule requires that the
context item be a node, guaranteeing that a type error is raised
when the context item is an atomic value.</p>
<p><b><a href="#processing_dynamic" class="processing">Dynamic
Evaluation</a></b></p>
<p>The dynamic semantics of an <em>Axis</em> <em>NodeTest</em> pair
is obtained by retrieving the context node, and applying the two
filters (<em>Axis</em>, then <em>NodeTest</em>) on the result. The
application of each filter is expressed through several auxiliary
judgments (<a href="#jd_axis" class="judgment"><b>of</b></a>,
<a href="#jd_principal" class="judgment"><b>has principal</b></a>,
and <a href="#jd_test" class="judgment"><b>test</b></a>), as
follows.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href=
"#xq_val_env" class="env">varValue</a>( <span><a href=
"#fs_builtin_vars"><code>$</code><em>fs:</em><code>dot</code></a></span>
<span>(<code>FS-URI</code>,"<code>dot</code>")</span> ) = <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_matches" class=
"judgment"><b>matches</b></a> <font size=
"6">[</font>node()<font size="6">]</font><a href=
"#jd_map_sequencetype" class="judgment"><sub><font size=
"2">sequencetype</font></sub></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis" class=
"judgment"><b>axis</b></a> <em>Axis</em> <a href="#jd_axis" class=
"judgment"><b>of</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_axis" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><em>Axis</em> <a href="#jd_principal" class="judgment"><b>has
principal</b></a> <em>PrincipalNodeKind</em></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test" class=
"judgment"><b>test</b></a> <em>NodeTest</em> <a href="#jd_test"
class="judgment"><b>with</b></a> <em>PrincipalNodeKind</em>
<a href="#jd_test" class="judgment"><b>of</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_test" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">3</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <em>Axis</em>
<em>NodeTest</em> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#sec_distinct_docorder"><em>fs:</em><code>distinct-doc-order</code></a>(<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">3</font></sub>)</td>
</tr>
</table>
<br /></div>
<p><b>Note</b></p>
<p>Note that the second judgment in the rule guarantees that the
context item is bound to a node.</p>
<div class="div4">
<h5><a name="sec_axes" id="sec_axes"></a>4.2.1.1 Axes</h5>
<p><b>Introduction</b></p>
<p>The XQuery grammar for forward and reverse axis is as
follows.</p>
<h5><a name="d6e13670" id="d6e13670"></a>Axes</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-ForwardAxis" id=
"doc-xquery10-ForwardAxis"></a>[<small>114&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-ForwardAxis">ForwardAxis</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("child" "::")<br />
| ("descendant" "::")<br />
| ("attribute" "::")<br />
| ("self" "::")<br />
| ("descendant-or-self" "::")<br />
| ("following-sibling" "::")<br />
| ("following" "::")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-ReverseAxis" id=
"doc-xquery10-ReverseAxis"></a>[<small>117&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-ReverseAxis">ReverseAxis</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("parent" "::")<br />
| ("ancestor" "::")<br />
| ("preceding-sibling" "::")<br />
| ("preceding" "::")<br />
| ("ancestor-or-self" "::")</code></td>
</tr>
</tbody>
</table>
<p>In the case of XPath, forward axis also contain the
<code>namespace::</code> axis.</p>
<h5><a name="d6e13709" id="d6e13709"></a>Axes</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e12583.doc-xpath20-ForwardAxis" id=
"noid_d3e12583.doc-xpath20-ForwardAxis"></a>[<small>41&#160;(XPath)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xpath20/#prod-xpath-ForwardAxis">ForwardAxis</a><sup><small>XP</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("child" "::")<br />
| ("descendant" "::")<br />
| ("attribute" "::")<br />
| ("self" "::")<br />
| ("descendant-or-self" "::")<br />
| ("following-sibling" "::")<br />
| ("following" "::")<br />
| ("namespace" "::")</code></td>
</tr>
</tbody>
</table>
<p><b>Core Grammar</b></p>
<p>The Core grammar productions for XPath axis are:</p>
<h5><a name="d6e13735" id="d6e13735"></a>Axes</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-ForwardAxis" id=
"doc-xcore-ForwardAxis"></a>[<small>54&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-ForwardAxis"></a><a href=
"#prod-xcore-ForwardAxis">ForwardAxis</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("child" "::")<br />
| ("descendant" "::")<br />
| ("attribute" "::")<br />
| ("self" "::")<br />
| ("descendant-or-self" "::")<br />
| ("following-sibling" "::")<br />
| ("following" "::")<br />
| ("namespace" "::")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-ReverseAxis" id=
"doc-xcore-ReverseAxis"></a>[<small>57&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-ReverseAxis"></a><a href=
"#prod-xcore-ReverseAxis">ReverseAxis</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("parent" "::")<br />
| ("ancestor" "::")<br />
| ("preceding-sibling" "::")<br />
| ("preceding" "::")<br />
| ("ancestor-or-self" "::")</code></td>
</tr>
</tbody>
</table>
<p><b>Notation</b></p>
<p>We introduce the following auxiliary grammar production to
describe all axis.</p>
<h5><a name="d6e13774" id="d6e13774"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-Axis" id=
"doc-fs-Axis"></a>[<small>90&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-Axis">Axis</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>ForwardAxis | ReverseAxis</code></td>
</tr>
</tbody>
</table>
<p><b>Notation</b></p>
<p id="jd_map_axis">The normalization of axes uses the following
auxiliary mapping rule: <font size="6">[</font><font size=
"6">]</font><a href="#jd_map_axis" class=
"judgment"><sub><font size="2">Axis</font></sub></a>.</p>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>The normalization for all axes is specified as follows.</p>
<p>The semantics of the following(-sibling) and preceding(-sibling)
axes are expressed by mapping them to Core expressions. All other
axes are part of the Core and therefore are left unchanged through
normalization.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><code>following-sibling::</code>
<em>NodeTest</em><font size="6">]</font><a href="#jd_map_axis"
class="judgment"><sub><font size="2">Axis</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>let $e := . return $e/parent::node()/child::
<em>NodeTest</em> [.&gt;&gt;$e]<font size="6">]</font><a href=
"#jd_map_expr" class="judgment"><sub><font size=
"2">Expr</font></sub></a></td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><code>following::</code> <em>NodeTest</em><font size=
"6">]</font><a href="#jd_map_axis" class=
"judgment"><sub><font size="2">Axis</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><code>ancestor-or-self::node()/following-sibling::node()/descendant-or-self::</code><em>NodeTest</em><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
</table>
</div>
<p>All other forward axes are part of the Core [XPath/XQuery] and
handled by the normalization rules below:</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><code>child::</code> <em>NodeTest</em><font size=
"6">]</font><a href="#jd_map_axis" class=
"judgment"><sub><font size="2">Axis</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><code>child::</code>
<em>NodeTest</em></td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><code>attribute::</code> <em>NodeTest</em><font size=
"6">]</font><a href="#jd_map_axis" class=
"judgment"><sub><font size="2">Axis</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<code>attribute::</code> <em>NodeTest</em></td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><code>self::</code> <em>NodeTest</em><font size=
"6">]</font><a href="#jd_map_axis" class=
"judgment"><sub><font size="2">Axis</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><code>self::</code>
<em>NodeTest</em></td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><code>descendant::</code> <em>NodeTest</em><font size=
"6">]</font><a href="#jd_map_axis" class=
"judgment"><sub><font size="2">Axis</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<code>descendant::</code> <em>NodeTest</em></td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><code>descendant-or-self::</code>
<em>NodeTest</em><font size="6">]</font><a href="#jd_map_axis"
class="judgment"><sub><font size="2">Axis</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<code>descendant-or-self::</code> <em>NodeTest</em></td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><code>namespace::</code> <em>NodeTest</em><font size=
"6">]</font><a href="#jd_map_axis" class=
"judgment"><sub><font size="2">Axis</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<code>namespace::</code> <em>NodeTest</em></td>
</tr>
</table>
</div>
<p>Reverse axes:</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><code>preceding-sibling::</code>
<em>NodeTest</em><font size="6">]</font><a href="#jd_map_axis"
class="judgment"><sub><font size="2">Axis</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>let $e := . return $e/parent::node()/child::
<em>NodeTest</em> [.&lt;&lt;$e]<font size="6">]</font><a href=
"#jd_map_expr" class="judgment"><sub><font size=
"2">Expr</font></sub></a></td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><code>preceding::</code> <em>NodeTest</em><font size=
"6">]</font><a href="#jd_map_axis" class=
"judgment"><sub><font size="2">Axis</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><code>ancestor-or-self::node()/preceding-sibling::node()/descendant-or-self::</code><em>NodeTest</em><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
</table>
</div>
<p>All other reverse axes are part of the Core [XPath/XQuery] and
handled by the normalization rules below:</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><code>parent::</code> <em>NodeTest</em><font size=
"6">]</font><a href="#jd_map_axis" class=
"judgment"><sub><font size="2">Axis</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><code>parent::</code>
<em>NodeTest</em></td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><code>ancestor::</code> <em>NodeTest</em><font size=
"6">]</font><a href="#jd_map_axis" class=
"judgment"><sub><font size="2">Axis</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<code>ancestor::</code> <em>NodeTest</em></td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><code>ancestor-or-self::</code>
<em>NodeTest</em><font size="6">]</font><a href="#jd_map_axis"
class="judgment"><sub><font size="2">Axis</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<code>ancestor-or-self::</code> <em>NodeTest</em></td>
</tr>
</table>
</div>
</div>
<div class="div4">
<h5><a name="node-tests" id="node-tests"></a>4.2.1.2 Node
Tests</h5>
<p><b>Introduction</b></p>
<p>A node test is a condition applied on the nodes selected by an
axis step. Node tests are described by the following grammar
productions.</p>
<h5><a name="d6e14070" id="d6e14070"></a>Node Tests</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-NodeTest" id=
"doc-xquery10-NodeTest"></a>[<small>119&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-NodeTest">NodeTest</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery10-KindTest">KindTest</a> | <a href=
"#doc-xquery10-NameTest">NameTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-NameTest" id=
"doc-xquery10-NameTest"></a>[<small>120&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-NameTest">NameTest</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>_QName_or_EQName | <a href=
"#doc-xquery10-Wildcard">Wildcard</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-Wildcard" id=
"doc-xquery10-Wildcard"></a>[<small>121&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-Wildcard">Wildcard</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"*"<br />
| (<a href="#prod-xquery10-NCName">NCName</a> ":" "*")<br />
| ("*" ":" <a href="#prod-xquery10-NCName">NCName</a>)</code></td>
</tr>
</tbody>
</table>
<p><b>Core Grammar</b></p>
<p>The Core grammar productions for node tests are:</p>
<h5><a name="d6e14109" id="d6e14109"></a>Node Tests</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-NodeTest" id=
"doc-xcore-NodeTest"></a>[<small>59&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-NodeTest"></a><a href=
"#prod-xcore-NodeTest">NodeTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-KindTest">KindTest</a> | <a href=
"#doc-xcore-NameTest">NameTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-NameTest" id=
"doc-xcore-NameTest"></a>[<small>60&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-NameTest"></a><a href=
"#prod-xcore-NameTest">NameTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>_QName_or_EQName | <a href=
"#doc-xcore-Wildcard">Wildcard</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-Wildcard" id=
"doc-xcore-Wildcard"></a>[<small>61&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-Wildcard"></a><a href=
"#prod-xcore-Wildcard">Wildcard</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"*"<br />
| (<a href="#prod-xcore-NCName">NCName</a> ":" "*")<br />
| ("*" ":" <a href="#prod-xcore-NCName">NCName</a>)</code></td>
</tr>
</tbody>
</table>
<p><b>Notation</b></p>
<p>For convenience, we will use the grammar non-terminals
<em>Prefix</em>, and <em>LocalPart</em>, both of which are
<em>NCName</em>s, in some of the inference rules. They are defined
by the following grammar productions.</p>
<h5><a name="d6e14157" id="d6e14157"></a>Prefix and LocalPart</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-Prefix" id=
"doc-fs-Prefix"></a>[<small>18&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-Prefix">Prefix</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>NCName</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-LocalPart" id=
"doc-fs-LocalPart"></a>[<small>19&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-LocalPart">LocalPart</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>NCName</code></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="div3">
<h4><a name="id-predicates" id="id-predicates"></a>4.2.2
Predicates</h4>
<p><b>Introduction</b></p>
<p>A predicate consists of an expression, called a <b>predicate
expression</b>, enclosed in square brackets.</p>
<h5><a name="d6e14181" id="d6e14181"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-Predicate" id=
"doc-xquery10-Predicate"></a>[<small>126&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-Predicate">Predicate</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"[" <a href="#doc-xquery10-Expr">Expr</a> "]"</code></td>
</tr>
</tbody>
</table>
<p><b>Notation</b></p>
<p id="jd_map_predicates">Normalization of predicates uses the
following auxiliary mapping rule: <font size=
"6">[</font><font size="6">]</font><a href="#jd_map_predicates"
class="judgment"><sub><font size=
"2">Predicates</font></sub></a>.</p>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>Predicates in path expressions are normalized with a special
mapping rule:</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>Expr</em><font size="6">]</font><a href=
"#jd_map_predicates" class="judgment"><sub><font size=
"2">Predicates</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<table summary="">
<tbody>
<tr>
<td>typeswitch (<font size="6">[</font><em>Expr</em><font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a>)</td>
</tr>
<tr>
<td>&#160;&#160;case $v as <em>fs:</em><code>numeric</code> return
<em>op:</em>numeric-equal($v, <a href=
"#fs_builtin_vars"><code>$</code><em>fs:</em><code>position</code></a>)</td>
</tr>
<tr>
<td>&#160;&#160;default $v return <code>fn:boolean</code>($v)</td>
</tr>
</tbody>
</table>
</td>
</tr>
</table>
</div>
<p>Note that the semantics of predicates whose input expression
returns a numeric value also work if that value is not an integer.
In those cases the <code>op:numeric-equal</code> returns false when
compared to a position. For example, the expression
<code>//a[3.4]</code> always returns the empty sequence.</p>
</div>
<div class="div3">
<h4><a name="unabbrev" id="unabbrev"></a>4.2.3 Unabbreviated
Syntax</h4>
<p>The corresponding Section in the [XPath/XQuery] document just
contains examples.</p>
</div>
<div class="div3">
<h4><a name="abbrev" id="abbrev"></a>4.2.4 Abbreviated Syntax</h4>
<h5><a name="d6e14268" id="d6e14268"></a>Abbreviated Syntax</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-AbbrevForwardStep" id=
"doc-xquery10-AbbrevForwardStep"></a>[<small>115&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-AbbrevForwardStep">AbbrevForwardStep</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"@"? <a href=
"#doc-xquery10-NodeTest">NodeTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-AbbrevReverseStep" id=
"doc-xquery10-AbbrevReverseStep"></a>[<small>118&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-AbbrevReverseStep">AbbrevReverseStep</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>".."</code></td>
</tr>
</tbody>
</table>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>Here are normalization rules for the abbreviated syntax.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>..<font size="6">]</font><a href="#jd_map_axis" class=
"judgment"><sub><font size="2">Axis</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">parent::node()</td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>@<em>NodeTest</em><font size="6">]</font><a href=
"#jd_map_axis" class="judgment"><sub><font size=
"2">Axis</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
attribute::<em>NodeTest</em></td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>NodeTest</em><font size="6">]</font><a href=
"#jd_map_axis" class="judgment"><sub><font size=
"2">Axis</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
child::<em>NodeTest</em></td>
</tr>
</table>
</div>
</div>
</div>
<div class="div2">
<h3><a name="id-sequence-expressions" id=
"id-sequence-expressions"></a>4.3 Sequence Expressions</h3>
<p><b>Introduction</b></p>
<p>[XPath/XQuery] supports operators to construct and combine
sequences. A <b>sequence</b> is an ordered collection of zero or
more items. An <b>item</b> is either an atomic value or a node.</p>
<div class="div3">
<h4><a name="sec_constructing_sequences" id=
"sec_constructing_sequences"></a>4.3.1 Constructing Sequences</h4>
<h5><a name="d6e14341" id="d6e14341"></a>Constructing
Sequences</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e13077.doc-xquery10-Expr" id=
"noid_d3e13077.doc-xquery10-Expr"></a>[<small>39&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-Expr">Expr</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery10-ExprSingle">ExprSingle</a> (","
<a href="#doc-xquery10-ExprSingle">ExprSingle</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-RangeExpr" id=
"doc-xquery10-RangeExpr"></a>[<small>90&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-RangeExpr">RangeExpr</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery10-AdditiveExpr">AdditiveExpr</a> (
"to" <a href="#doc-xquery10-AdditiveExpr">AdditiveExpr</a>
)?</code></td>
</tr>
</tbody>
</table>
<p><b>Core Grammar</b></p>
<p>The Core grammar production for sequence expressions is:</p>
<h5><a name="d6e14367" id="d6e14367"></a>Core Sequence
Expressions</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e13085.doc-xcore-Expr" id=
"noid_d3e13085.doc-xcore-Expr"></a>[<small>22&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-Expr">Expr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-ExprSingle">ExprSingle</a> (","
<a href="#doc-xcore-ExprSingle">ExprSingle</a>)*</code></td>
</tr>
</tbody>
</table>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>A sequence expression is normalized into a sequence of
normalized single expressions:</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>Expr</em><sub><font size="2">1</font></sub> ,
<em>Expr</em><sub><font size="2">2</font></sub><font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>Expr</em><sub><font size=
"2">1</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>,
<font size="6">[</font><em>Expr</em><sub><font size=
"2">2</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
</table>
</div>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>The type of the sequence expression is the sequence over the
types of the individual expressions.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">1</font></sub> <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>&#160;&#160;&#160;&#160;<a href=
"#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">1</font></sub> , <em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p><b><a href="#processing_dynamic" class="processing">Dynamic
Evaluation</a></b></p>
<p>Each expression in the sequence is evaluated and the resulting
values are concatenated into one sequence.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">1</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>&#160;&#160;&#160;&#160;<a href="#xq_dyn_env_def"
class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">1</font></sub>, <em>Expr</em><sub><font size="2">2</font></sub>
<a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>, <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>The range operator is normalized to the
<em>fs:</em><code>to</code> function.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>Expr</em><sub><font size="2">1</font></sub>
<code>to</code> <em>Expr</em><sub><font size=
"2">2</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<em>fs:</em><code>to</code>((<font size=
"6">[</font><em>Expr</em><sub><font size=
"2">1</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size=
"2">Expr</font></sub></a>),(<font size=
"6">[</font><em>Expr</em><sub><font size=
"2">2</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>))</td>
</tr>
</table>
</div>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>The static semantics of the <em>fs:</em><code>to</code> function
is defined in <a href="#sec_fs_to"><b>[7.1.12 The fs:to
function]</b></a>.</p>
<p><b><a href="#processing_dynamic" class="processing">Dynamic
Evaluation</a></b></p>
<p>The dynamic semantics of the <em>fs:</em><code>to</code>
function is defined in <a href="#sec_fs_to"><b>[7.1.12 The fs:to
function]</b></a>.</p>
</div>
<div class="div3">
<h4><a name="sec_filter_exprs" id="sec_filter_exprs"></a>4.3.2
Filter Expressions</h4>
<p><b>Introduction</b></p>
<h5><a name="d6e14662" id="d6e14662"></a>Filter Expression</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-FilterExpr" id=
"doc-xquery10-FilterExpr"></a>[<small>122&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-FilterExpr">FilterExpr</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery10-PrimaryExpr">PrimaryExpr</a>
<a href="#doc-xquery10-PredicateList">PredicateList</a></code></td>
</tr>
</tbody>
</table>
<p><b>Core Grammar</b></p>
<p>There are no Core grammar productions for filter expressions as
they are normalized to other Core expressions.</p>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>When a predicate with a numeric literal or the
<code>last()</code> expression is applied on a primary expression,
it is normalized using the <span><a href=
"#sec_item_at"><em>fs:</em><code>item-at</code></a></span>
function. This results in a more precise static type for those
cases.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>PrimaryExpr</em> <em>PredicateList</em> [
<em>NumericLiteral</em> ]<font size="6">]</font><a href=
"#jd_map_expr" class="judgment"><sub><font size=
"2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<table summary="">
<tbody>
<tr>
<td>let <code>$</code><em>fs:</em><code>sequence</code> :=
<font size="6">[</font><em>PrimaryExpr</em>
<em>PredicateList</em><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>
return</td>
</tr>
<tr>
<td><span><a href=
"#sec_item_at"><em>fs:</em><code>item-at</code></a></span>(<code>$</code><em>fs:</em><code>sequence</code>,<em>NumericLiteral</em><span>,1</span>)</td>
</tr>
</tbody>
</table>
</td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>PrimaryExpr</em> <em>PredicateList</em> [ fn:last()
]<font size="6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<table summary="">
<tbody>
<tr>
<td>let <code>$</code><em>fs:</em><code>sequence</code> :=
<font size="6">[</font><em>PrimaryExpr</em>
<em>PredicateList</em><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>
return</td>
</tr>
<tr>
<td>let <a href=
"#fs_builtin_vars"><code>$</code><em>fs:</em><code>last</code></a>
:= fn:count(<code>$</code><em>fs:</em><code>sequence</code>)
return</td>
</tr>
<tr>
<td><span><a href=
"#sec_item_at"><em>fs:</em><code>item-at</code></a></span>(<code>$</code><em>fs:</em><code>sequence</code>,<a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>last</code></a><span>,1</span>)</td>
</tr>
</tbody>
</table>
</td>
</tr>
</table>
</div>
<p>In the general case, when a predicate is applied on a primary
expression, it is normalized to a FLWOR expression as follows. The
input sequence is processed in sequence order and the context item
is bound to each item in the input sequence.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>PrimaryExpr</em> <em>PredicateList</em> [
<em>Expr</em> ]<font size="6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<table summary="">
<tbody>
<tr>
<td>let <code>$</code><em>fs:</em><code>sequence</code> :=
<font size="6">[</font><em>PrimaryExpr</em>
<em>PredicateList</em><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>
return</td>
</tr>
<tr>
<td>let <a href=
"#fs_builtin_vars"><code>$</code><em>fs:</em><code>last</code></a>
:= fn:count(<code>$</code><em>fs:</em><code>sequence</code>)
return</td>
</tr>
<tr>
<td>for <a href=
"#fs_builtin_vars"><code>$</code><em>fs:</em><code>dot</code></a>
at <a href=
"#fs_builtin_vars"><code>$</code><em>fs:</em><code>position</code></a>
in <code>$</code><em>fs:</em><code>sequence</code> return</td>
</tr>
<tr>
<td>&#160;&#160; if (<font size=
"6">[</font><em>Expr</em><font size="6">]</font><a href=
"#jd_map_predicates" class="judgment"><sub><font size=
"2">Predicates</font></sub></a>) then <a href=
"#fs_builtin_vars"><code>$</code><em>fs:</em><code>dot</code></a>
else ()</td>
</tr>
</tbody>
</table>
</td>
</tr>
</table>
</div>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>There are no additional static typing rules for filter
expressions.</p>
<p><b><a href="#processing_dynamic" class="processing">Dynamic
Evaluation</a></b></p>
<p>There are no additional dynamic evaluation rules for filter
expressions.</p>
</div>
<div class="div3">
<h4><a name="sec_combining_sequences" id=
"sec_combining_sequences"></a>4.3.3 Combining Node Sequences</h4>
<p>[XPath/XQuery] provides several operators for combining
sequences of nodes.</p>
<h5><a name="d6e14953" id="d6e14953"></a>Combining Sequences</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-UnionExpr" id=
"doc-xquery10-UnionExpr"></a>[<small>93&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-UnionExpr">UnionExpr</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery10-IntersectExceptExpr">IntersectExceptExpr</a> (
("union" | "|") <a href=
"#doc-xquery10-IntersectExceptExpr">IntersectExceptExpr</a>
)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-IntersectExceptExpr" id=
"doc-xquery10-IntersectExceptExpr"></a>[<small>94&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-IntersectExceptExpr">IntersectExceptExpr</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery10-InstanceofExpr">InstanceofExpr</a>
( ("intersect" | "except") <a href=
"#doc-xquery10-InstanceofExpr">InstanceofExpr</a> )*</code></td>
</tr>
</tbody>
</table>
<p><b>Notation</b></p>
<p id="jd_map_sequenceop">The union, intersect, and except
expressions are normalized into function calls to the appropriate
functions. The mapping function <font size="6">[</font><font size=
"6">]</font><a href="#jd_map_sequenceop" class=
"judgment"><sub><font size="2">SequenceOp</font></sub></a> is
defined by the following table:</p>
<table summary="" border="1">
<tbody>
<tr>
<td>SequenceOp</td>
<td><font size="6">[</font><em>SequenceOp</em><font size=
"6">]</font><a href="#jd_map_sequenceop" class=
"judgment"><sub><font size="2">SequenceOp</font></sub></a></td>
</tr>
<tr>
<td>"union"</td>
<td><em>op:</em>union</td>
</tr>
<tr>
<td>"|"</td>
<td><em>op:</em>union</td>
</tr>
<tr>
<td>"intersect"</td>
<td><em>op:</em>intersect</td>
</tr>
<tr>
<td>"except"</td>
<td><em>op:</em>except</td>
</tr>
</tbody>
</table>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>Operators for combining node sequences are normalized as
follows.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>Expr</em><sub><font size="2">1</font></sub>
<em>SequenceOp</em> <em>Expr</em><sub><font size=
"2">2</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><a href=
"#sec_apply_ordering_mode"><em>fs:</em><code>apply-ordering-mode</code></a>
(<font size="6">[</font><em>SequenceOp</em><font size=
"6">]</font><a href="#jd_map_sequenceop" class=
"judgment"><sub><font size="2">SequenceOp</font></sub></a> (
<font size="6">[</font><em>Expr</em><sub><font size=
"2">1</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>,
<font size="6">[</font><em>Expr</em><sub><font size=
"2">2</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a> ))</td>
</tr>
</table>
</div>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>The static semantics of the operators that combine sequences are
defined in <a href="#sec_op_union_intersect_except"><b>[7.2.14 The
op:union, op:intersect, and op:except operators]</b></a>.</p>
<p><b><a href="#processing_dynamic" class="processing">Dynamic
Evaluation</a></b></p>
<p>The dynamic semantics for function calls is given in <a href=
"#id-function-calls"><b>[4.1.5 Function Calls]</b></a>.</p>
</div>
</div>
<div class="div2">
<h3><a name="sec_arithmetic" id="sec_arithmetic"></a>4.4 Arithmetic
Expressions</h3>
<p>[XPath/XQuery] provides arithmetic operators for addition,
subtraction, multiplication, division, and modulus, in their usual
binary and unary forms.</p>
<h5><a name="d6e15097" id="d6e15097"></a>Arithmetic
Expressions</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-AdditiveExpr" id=
"doc-xquery10-AdditiveExpr"></a>[<small>91&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-AdditiveExpr">AdditiveExpr</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery10-MultiplicativeExpr">MultiplicativeExpr</a> ( ("+" |
"-") <a href=
"#doc-xquery10-MultiplicativeExpr">MultiplicativeExpr</a>
)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-MultiplicativeExpr" id=
"doc-xquery10-MultiplicativeExpr"></a>[<small>92&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-MultiplicativeExpr">MultiplicativeExpr</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery10-UnionExpr">UnionExpr</a> ( ("*" |
"div" | "idiv" | "mod") <a href=
"#doc-xquery10-UnionExpr">UnionExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-UnaryExpr" id=
"doc-xquery10-UnaryExpr"></a>[<small>99&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-UnaryExpr">UnaryExpr</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("-" | "+")* <a href=
"#doc-xquery10-ValueExpr">ValueExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-ValueExpr" id=
"doc-xquery10-ValueExpr"></a>[<small>100&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-ValueExpr">ValueExpr</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery10-ValidateExpr">ValidateExpr</a> |
<a href="#doc-xquery10-PathExpr">PathExpr</a> | <a href=
"#doc-xquery10-ExtensionExpr">ExtensionExpr</a></code></td>
</tr>
</tbody>
</table>
<p><b>Core Grammar</b></p>
<p>The Core grammar production for arithmetic expressions is:</p>
<h5><a name="d6e15142" id="d6e15142"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-ValueExpr" id=
"doc-xcore-ValueExpr"></a>[<small>43&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-ValueExpr"></a><a href=
"#prod-xcore-ValueExpr">ValueExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-ValidateExpr">ValidateExpr</a> |
PathExpr | <a href="#doc-xcore-StepExpr">StepExpr</a> | <a href=
"#doc-xcore-ExtensionExpr">ExtensionExpr</a></code></td>
</tr>
</tbody>
</table>
<p><b>Notation</b></p>
<p id="jd_map_arithop">The mapping function <font size=
"6">[</font><font size="6">]</font><a href="#jd_map_arithop" class=
"judgment"><sub><font size="2">ArithOp</font></sub></a> is defined
by the following table:</p>
<table summary="" border="1">
<tbody>
<tr>
<td><em>ArithOp</em></td>
<td><font size="6">[</font><em>ArithOp</em><font size=
"6">]</font><a href="#jd_map_arithop" class=
"judgment"><sub><font size="2">ArithOp</font></sub></a></td>
</tr>
<tr>
<td>"+"</td>
<td><em>fs:</em><code>plus</code></td>
</tr>
<tr>
<td>"-"</td>
<td><em>fs:</em><code>minus</code></td>
</tr>
<tr>
<td>"*"</td>
<td><em>fs:</em><code>times</code></td>
</tr>
<tr>
<td>"div"</td>
<td><em>fs:</em><code>div</code></td>
</tr>
<tr>
<td>"mod"</td>
<td><em>fs:</em><code>mod</code></td>
</tr>
</tbody>
</table>
<p><b>Core Grammar</b></p>
<p>There are no Core grammar productions for arithmetic expressions
as they are normalized to other Core expressions.</p>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>The normalization rules for all the arithmetic operators except
<code>idiv</code> first atomize each argument by applying
<code>fn:data</code> and then apply the internal function <a href=
"#sec_convert_operand"><em>fs:</em><code>convert-operand</code></a>
to each argument. If the first argument to this function has type
<a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>,
then the first argument is cast to a double, otherwise it is
returned unchanged. The overloaded internal function corresponding
to the arithmetic operator is then applied to the two converted
arguments. The table above maps the operators to the corresponding
internal function. The mapping from the overloaded internal
functions to the corresponding non-overloaded function is given in
<a href="#sec_operators"><b>[C.2 Mapping of Overloaded Internal
Functions]</b></a>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>Expr</em><sub><font size="2">1</font></sub>
<em>ArithOp</em> <em>Expr</em><sub><font size=
"2">2</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<table summary="">
<tbody>
<tr>
<td><font size="6">[</font><em>ArithOp</em><font size=
"6">]</font><a href="#jd_map_arithop" class=
"judgment"><sub><font size="2">ArithOp</font></sub></a> (</td>
<td><a href=
"#sec_convert_operand"><em>fs:</em><code>convert-operand</code></a>(<code>fn:data</code>((<font size="6">[</font><em>Expr</em><sub><font size="2">1</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>)),
1.0E0),</td>
</tr>
<tr>
<td></td>
<td><a href=
"#sec_convert_operand"><em>fs:</em><code>convert-operand</code></a>(<code>fn:data</code>((<font size="6">[</font><em>Expr</em><sub><font size="2">2</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>)),
1.0E0))</td>
</tr>
</tbody>
</table>
</td>
</tr>
</table>
</div>
<p>The normalization rules for the <code>idiv</code> operator are
similar, but instead of casting arguments with type <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> to
<code>xs:double</code>, they are cast to
<code>xs:integer</code>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>Expr</em><sub><font size="2">1</font></sub>
<code>idiv</code> <em>Expr</em><sub><font size=
"2">2</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<table summary="">
<tbody>
<tr valign="baseline">
<td><em>fs:</em><code>idiv</code> (</td>
<td><a href=
"#sec_convert_operand"><em>fs:</em><code>convert-operand</code></a>(<code>fn:data</code>((<font size="6">[</font><em>Expr</em><sub><font size="2">1</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>)),
1),</td>
</tr>
<tr>
<td></td>
<td><a href=
"#sec_convert_operand"><em>fs:</em><code>convert-operand</code></a>(<code>fn:data</code>((<font size="6">[</font><em>Expr</em><sub><font size="2">2</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>)),
1))</td>
</tr>
</tbody>
</table>
</td>
</tr>
</table>
</div>
<p>The unary operators are mapped similarly.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><code>+</code> <em>Expr</em><font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<em>fs:</em><code>unary-plus</code>(<a href=
"#sec_convert_operand"><em>fs:</em><code>convert-operand</code></a>(<code>fn:data</code>((<font size="6">[</font><em>Expr</em><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>)),
1.0E0))</td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><code>-</code> <em>Expr</em><font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<em>fs:</em><code>unary-minus</code>(<a href=
"#sec_convert_operand"><em>fs:</em><code>convert-operand</code></a>(<code>fn:data</code>((<font size="6">[</font><em>Expr</em><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>)),
1.0E0))</td>
</tr>
</table>
</div>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>The static semantics for function calls is given in <a href=
"#id-function-calls"><b>[4.1.5 Function Calls]</b></a>. The mapping
from the overloaded internal functions to the corresponding
non-overloaded function is given in <a href=
"#sec_operators"><b>[C.2 Mapping of Overloaded Internal
Functions]</b></a>.</p>
<p><b><a href="#processing_dynamic" class="processing">Dynamic
Evaluation</a></b></p>
<p>The dynamic semantics for function calls is given in <a href=
"#id-function-calls"><b>[4.1.5 Function Calls]</b></a>. The mapping
from the overloaded internal functions to the corresponding
non-overloaded function is given in <a href=
"#sec_operators"><b>[C.2 Mapping of Overloaded Internal
Functions]</b></a>.</p>
</div>
<div class="div2">
<h3><a name="sec_comparisons" id="sec_comparisons"></a>4.5
Comparison Expressions</h3>
<p><b>Introduction</b></p>
<p>Comparison expressions allow two values to be compared.
[XPath/XQuery] provides three kinds of comparison expressions,
called value comparisons, general comparisons, and node
comparisons.</p>
<h5><a name="d6e15508" id="d6e15508"></a>Comparison
Expressions</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-ComparisonExpr" id=
"doc-xquery10-ComparisonExpr"></a>[<small>89&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-ComparisonExpr">ComparisonExpr</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery10-RangeExpr">RangeExpr</a> (
(<a href="#doc-xquery10-ValueComp">ValueComp</a><br />
| <a href="#doc-xquery10-GeneralComp">GeneralComp</a><br />
| <a href="#doc-xquery10-NodeComp">NodeComp</a>) <a href=
"#doc-xquery10-RangeExpr">RangeExpr</a> )?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-ValueComp" id=
"doc-xquery10-ValueComp"></a>[<small>102&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-ValueComp">ValueComp</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"eq" | "ne" | "lt" | "le" | "gt" | "ge"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-GeneralComp" id=
"doc-xquery10-GeneralComp"></a>[<small>101&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-GeneralComp">GeneralComp</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"=" | "!=" | "&lt;" | "&lt;=" | "&gt;" |
"&gt;="</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-NodeComp" id=
"doc-xquery10-NodeComp"></a>[<small>103&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-NodeComp">NodeComp</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"is" | "&lt;&lt;" | "&gt;&gt;"</code></td>
</tr>
</tbody>
</table>
<div class="div3">
<h4><a name="sec_value_comparisons" id=
"sec_value_comparisons"></a>4.5.1 Value Comparisons</h4>
<p><b>Notation</b></p>
<p id="jd_map_valuecomp">The mapping function <font size=
"6">[</font><font size="6">]</font><a href="#jd_map_valuecomp"
class="judgment"><sub><font size="2">ValueComp</font></sub></a> is
defined by the following table:</p>
<table summary="" border="1">
<tbody>
<tr>
<td>ValueComp</td>
<td><font size="6">[</font>ValueComp<font size="6">]</font><a href=
"#jd_map_valuecomp" class="judgment"><sub><font size=
"2">ValueComp</font></sub></a></td>
</tr>
<tr>
<td>"<code>eq</code>"</td>
<td><em>fs:</em>eq</td>
</tr>
<tr>
<td>"<code>ne</code>"</td>
<td><em>fs:</em>ne</td>
</tr>
<tr>
<td>"<code>lt</code>"</td>
<td><em>fs:</em>lt</td>
</tr>
<tr>
<td>"<code>le</code>"</td>
<td><em>fs:</em>le</td>
</tr>
<tr>
<td>"<code>gt</code>"</td>
<td><em>fs:</em>gt</td>
</tr>
<tr>
<td>"<code>ge</code>"</td>
<td><em>fs:</em>ge</td>
</tr>
</tbody>
</table>
<p><b>Core Grammar</b></p>
<p>There are no Core grammar productions for value comparisons as
they are normalized to other Core expressions.</p>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>The normalization rules for the value comparison operators first
atomize each argument by applying <code>fn:data</code> and then
apply the internal function <a href=
"#sec_convert_operand"><em>fs:</em><code>convert-operand</code></a>
defined in <a href="#sec_convert_operand"><b>[7.1.1 The
fs:convert-operand function]</b></a>. If the first argument to this
function has type <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>, then the
first argument is cast to a string, otherwise it is returned
unchanged. The overloaded internal function corresponding to the
value comparison operator is then applied to the two converted
arguments. The table above maps the value operators to the
corresponding internal function. The mapping from the overloaded
internal functions to the corresponding non-overloaded function is
given in <a href="#sec_operators"><b>[C.2 Mapping of Overloaded
Internal Functions]</b></a>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>Expr</em><sub><font size="2">1</font></sub>
<em>ValueComp</em> <em>Expr</em><sub><font size=
"2">2</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<table summary="">
<tbody>
<tr>
<td><font size="6">[</font><em>ValueComp</em><font size=
"6">]</font><a href="#jd_map_valuecomp" class=
"judgment"><sub><font size="2">ValueComp</font></sub></a> (</td>
<td><a href=
"#sec_convert_operand"><em>fs:</em><code>convert-operand</code></a>(<code>fn:data</code>((<font size="6">[</font><em>Expr</em><sub><font size="2">1</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>)),
"string"),</td>
</tr>
<tr>
<td></td>
<td><a href=
"#sec_convert_operand"><em>fs:</em><code>convert-operand</code></a>(<code>fn:data</code>((<font size="6">[</font><em>Expr</em><sub><font size="2">2</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>)),
"string") )</td>
</tr>
</tbody>
</table>
</td>
</tr>
</table>
</div>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>The static semantics for function calls is given in <a href=
"#id-function-calls"><b>[4.1.5 Function Calls]</b></a>. The
comparison functions all have return type <code>xs:boolean</code>,
as specified in <a href="#xpath-functions-11">[Functions and
Operators 1.1]</a>.</p>
<p><b><a href="#processing_dynamic" class="processing">Dynamic
Evaluation</a></b></p>
<p>The dynamic semantics for function calls is given in <a href=
"#id-function-calls"><b>[4.1.5 Function Calls]</b></a>.</p>
</div>
<div class="div3">
<h4><a name="sec_general_comparisons" id=
"sec_general_comparisons"></a>4.5.2 General Comparisons</h4>
<p><b>Introduction</b></p>
<p>General comparisons are defined by adding existential semantics
to value comparisons. The operands of a general comparison may be
sequences of any length. The result of a general comparison is
always <code>true</code> or <code>false</code>.</p>
<p><b>Notation</b></p>
<p id="jd_map_generalcomp">The function <font size=
"6">[</font><font size="6">]</font><a href="#jd_map_generalcomp"
class="judgment"><sub><font size="2">GeneralComp</font></sub></a>
is defined by the following table:</p>
<table summary="" border="1">
<tbody>
<tr>
<td><em>GeneralComp</em></td>
<td><font size="6">[</font><em>GeneralComp</em><font size=
"6">]</font><a href="#jd_map_generalcomp" class=
"judgment"><sub><font size="2">GeneralComp</font></sub></a></td>
</tr>
<tr>
<td>"<code>=</code>"</td>
<td><em>fs:</em>eq</td>
</tr>
<tr>
<td>"<code>!=</code>"</td>
<td><em>fs:</em>ne</td>
</tr>
<tr>
<td>"<code>&lt;</code>"</td>
<td><em>fs:</em>lt</td>
</tr>
<tr>
<td>"<code>&lt;=</code>"</td>
<td><em>fs:</em>le</td>
</tr>
<tr>
<td>"<code>&gt;</code>"</td>
<td><em>fs:</em>gt</td>
</tr>
<tr>
<td>"<code>&gt;=</code>"</td>
<td><em>fs:</em>ge</td>
</tr>
</tbody>
</table>
<p><b>Core Grammar</b></p>
<p>There are no Core grammar productions for general comparisons as
they are normalized to existentially quantified Core
expressions.</p>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>The normalization rule for a general comparison expression first
atomizes each argument by applying <code>fn:data</code>, <span>and
then applies the existentially quantified <em>SomeExpr</em>
expression to each sequence. The internal function <a href=
"#sec_convert_operand"><em>fs:</em><code>convert-operand</code></a>
is applied to each pair of atomic values. If the first argument to
this function has type <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>, then the
first argument is cast to type of the second argument. If the
second argument has type <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>, the first
argument is cast to a string.</span> <span>resulting in two
sequences of atomic values. Two nested <code>some</code>
expressions then examine (potentially) every pair of values (one
value from each sequence). For each pair, the internal function
<a href=
"#sec_convert_operand"><em>fs:</em><code>convert-operand</code></a>
is called twice; if either of the two values is of type <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>, one of
the calls will cast it to a type determined by the other
value.</span> The overloaded internal function corresponding to the
general comparison operator is then applied to the two converted
values.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>Expr</em><sub><font size="2">1</font></sub>
<em>GeneralComp</em> <em>Expr</em><sub><font size=
"2">2</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<table summary="">
<tbody>
<tr>
<td>some $v1 in <code>fn:data</code>((<font size=
"6">[</font><em>Expr</em><sub><font size=
"2">1</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>))
satisfies</td>
</tr>
<tr>
<td>some $v2 in <code>fn:data</code>((<font size=
"6">[</font><em>Expr</em><sub><font size=
"2">2</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>))
satisfies</td>
</tr>
<tr>
<td>let $u1 := <a href=
"#sec_convert_operand"><em>fs:</em><code>convert-operand</code></a>($v1,
$v2) return</td>
</tr>
<tr>
<td>let $u2 := <a href=
"#sec_convert_operand"><em>fs:</em><code>convert-operand</code></a>($v2,
$v1) return</td>
</tr>
<tr>
<td><font size="6">[</font><em>GeneralComp</em><font size=
"6">]</font><a href="#jd_map_generalcomp" class=
"judgment"><sub><font size="2">GeneralComp</font></sub></a> ($u1,
$u2)</td>
</tr>
</tbody>
</table>
</td>
</tr>
</table>
</div>
</div>
<div class="div3">
<h4><a name="sec_node-comparisons" id=
"sec_node-comparisons"></a>4.5.3 Node Comparisons</h4>
<p><b>Core Grammar</b></p>
<p>There are no Core grammar productions for node comparisons as
they are normalized to other Core expressions.</p>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>The normalization rules for node comparisons map each argument
expression and then apply the internal function corresponding to
the node comparison operator. The internal function are defined in
<a href="#sec_operators"><b>[C.2 Mapping of Overloaded Internal
Functions]</b></a>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>Expr</em><sub><font size="2">1</font></sub>
<code>is</code> <em>Expr</em><sub><font size=
"2">2</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<table summary="">
<tbody>
<tr>
<td>&#160;&#160; <em>fs:</em><code>is-same-node</code>((<font size=
"6">[</font><em>Expr</em><sub><font size=
"2">1</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>),
(<font size="6">[</font><em>Expr</em><sub><font size=
"2">2</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>))</td>
</tr>
</tbody>
</table>
</td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>Expr</em><sub><font size="2">1</font></sub>
&lt;&lt; <em>Expr</em><sub><font size="2">2</font></sub><font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<table summary="">
<tbody>
<tr>
<td><em>fs:</em><code>node-before</code>((<font size=
"6">[</font><em>Expr</em><sub><font size=
"2">1</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>),
(<font size="6">[</font><em>Expr</em><sub><font size=
"2">2</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>))</td>
</tr>
</tbody>
</table>
</td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>Expr</em><sub><font size="2">1</font></sub>
&gt;&gt; <em>Expr</em><sub><font size="2">2</font></sub><font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<table summary="">
<tbody>
<tr>
<td><em>fs:</em><code>node-after</code>((<font size=
"6">[</font><em>Expr</em><sub><font size=
"2">1</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>),
(<font size="6">[</font><em>Expr</em><sub><font size=
"2">2</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>))</td>
</tr>
</tbody>
</table>
</td>
</tr>
</table>
</div>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>The static semantics for the internal functions are defined in
<a href="#sec_operators"><b>[C.2 Mapping of Overloaded Internal
Functions]</b></a>.</p>
<p><b><a href="#processing_dynamic" class="processing">Dynamic
Evaluation</a></b></p>
<p>The dynamic semantics for internal function is defined in
<a href="#sec_operators"><b>[C.2 Mapping of Overloaded Internal
Functions]</b></a>.</p>
</div>
</div>
<div class="div2">
<h3><a name="id-logical-expressions" id=
"id-logical-expressions"></a>4.6 Logical Expressions</h3>
<p><b>Introduction</b></p>
<p>A <b>logical expression</b> is either an <b>and-expression</b>
or an <b>or-expression</b>. The value of a logical expression is
always one of the boolean values: <code>true</code> or
<code>false</code>.</p>
<h5><a name="d6e16158" id="d6e16158"></a>Logical Expressions</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-OrExpr" id=
"doc-xquery10-OrExpr"></a>[<small>87&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-OrExpr">OrExpr</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery10-AndExpr">AndExpr</a> ( "or"
<a href="#doc-xquery10-AndExpr">AndExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-AndExpr" id=
"doc-xquery10-AndExpr"></a>[<small>88&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-AndExpr">AndExpr</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery10-ComparisonExpr">ComparisonExpr</a>
( "and" <a href="#doc-xquery10-ComparisonExpr">ComparisonExpr</a>
)*</code></td>
</tr>
</tbody>
</table>
<p><b>Core Grammar</b></p>
<p>The Core grammar productions for logical expressions are:</p>
<h5><a name="d6e16184" id="d6e16184"></a>Core Logical
Expressions</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-OrExpr" id=
"doc-xcore-OrExpr"></a>[<small>36&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-OrExpr"></a><a href=
"#prod-xcore-OrExpr">OrExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-AndExpr">AndExpr</a> ( "or" <a href=
"#doc-xcore-AndExpr">AndExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-AndExpr" id=
"doc-xcore-AndExpr"></a>[<small>37&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-AndExpr"></a><a href=
"#prod-xcore-AndExpr">AndExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>AdditiveExpr ( "and" AdditiveExpr )*</code></td>
</tr>
</tbody>
</table>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>The normalization rules for "<code>and</code>" and
"<code>or</code>" first get the effective boolean value of each
argument, then apply the appropriate Core operator.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>Expr</em><sub><font size="2">1</font></sub>
<code>and</code> <em>Expr</em><sub><font size=
"2">2</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<code>fn:boolean</code>((<font size=
"6">[</font><em>Expr</em><sub><font size=
"2">1</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>))
<code>and</code> <code>fn:boolean</code>((<font size=
"6">[</font><em>Expr</em><sub><font size=
"2">2</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>))</td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>Expr</em><sub><font size="2">1</font></sub>
<code>or</code> <em>Expr</em><sub><font size=
"2">2</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<code>fn:boolean</code>((<font size=
"6">[</font><em>Expr</em><sub><font size=
"2">1</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>))
<code>or</code> <code>fn:boolean</code>((<font size=
"6">[</font><em>Expr</em><sub><font size=
"2">2</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>))</td>
</tr>
</table>
</div>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>The logical expressions require that each subexpression have
type <code>xs:boolean</code>. The result type is also
<code>xs:boolean</code>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">1</font></sub> <a href="#jd_has_type" class=
"judgment"><b>:</b></a>
<code>xs:boolean</code>&#160;&#160;&#160;&#160;<a href=
"#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">n</font></sub> <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <code>xs:boolean</code></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">1</font></sub> <code>and</code> <em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <code>xs:boolean</code></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">1</font></sub> <a href="#jd_has_type" class=
"judgment"><b>:</b></a>
<code>xs:boolean</code>&#160;&#160;&#160;&#160;<a href=
"#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">n</font></sub> <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <code>xs:boolean</code></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">1</font></sub> <code>or</code> <em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <code>xs:boolean</code></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p><b><a href="#processing_dynamic" class="processing">Dynamic
Evaluation</a></b></p>
<p>The dynamic semantics of logical expressions is
non-deterministic. This non-determinism permits implementations to
use short-circuit evaluation strategies when evaluating logical
expressions. In the expression, <em>Expr</em><sub><font size=
"2">1</font></sub> <code>and</code> <em>Expr</em><sub><font size=
"2">2</font></sub>, if either expression raises an error or
evaluates to false, the entire expression may raise an error or
evaluate to false. In the expression, <em>Expr</em><sub><font size=
"2">1</font></sub> <code>or</code> <em>Expr</em><sub><font size=
"2">2</font></sub>, if either expression raises an error or
evaluates to true, the entire expression may raise an error or
evaluate to true.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a>
<b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">i</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> false</td>
</tr>
<tr align="center" valign="middle">
<td>i <a href="#jd_isin" class="judgment"><b>in</b></a> { 1,2
}</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a>
<b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">1</font></sub> <code>and</code> <em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> false</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a>
<b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">1</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> true&#160;&#160;&#160;&#160;<a href=
"#xq_dyn_env_def" class="env">dynEnv</a>
<b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> true</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a>
<b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">1</font></sub> <code>and</code> <em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> true</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a>
<b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">i</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> true</td>
</tr>
<tr align="center" valign="middle">
<td>i <a href="#jd_isin" class="judgment"><b>in</b></a> { 1,2
}</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a>
<b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">1</font></sub> <code>or</code> <em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> true</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a>
<b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">1</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> false&#160;&#160;&#160;&#160;<a href=
"#xq_dyn_env_def" class="env">dynEnv</a>
<b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> false</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a>
<b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">1</font></sub> <code>or</code> <em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> false</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
</div>
<div class="div2">
<h3><a name="sec_constructors" id="sec_constructors"></a>4.7
Constructors</h3>
<p>[XPath/XQuery] supports two forms of constructors. <b>Direct
constructors</b> support literal XML syntax for elements,
attributes, text nodes, processing-instructions and comments.
<b>Computed constructors</b> can be used to construct elements,
attributes, text nodes, processing-instructions, comments, and
document nodes. All direct constructors are normalized into
computed constructors, i.e., there are no direct-constructor
expressions in the Core.</p>
<h5><a name="d6e16722" id="d6e16722"></a>Constructors</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-Constructor" id=
"doc-xquery10-Constructor"></a>[<small>139&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-Constructor">Constructor</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery10-DirectConstructor">DirectConstructor</a><br />
| <a href=
"#doc-xquery10-ComputedConstructor">ComputedConstructor</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-DirectConstructor" id=
"doc-xquery10-DirectConstructor"></a>[<small>140&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-DirectConstructor">DirectConstructor</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery10-DirElemConstructor">DirElemConstructor</a><br />
| <a href=
"#doc-xquery10-DirCommentConstructor">DirCommentConstructor</a><br />

| <a href=
"#doc-xquery10-DirPIConstructor">DirPIConstructor</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-DirElemConstructor" id=
"doc-xquery10-DirElemConstructor"></a>[<small>141&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-DirElemConstructor">DirElemConstructor</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"&lt;" <a href="#prod-xquery10-QName">QName</a> <a href=
"#doc-xquery10-DirAttributeList">DirAttributeList</a> ("/&gt;" |
("&gt;" <a href="#doc-xquery10-DirElemContent">DirElemContent</a>*
"&lt;/" <a href="#prod-xquery10-QName">QName</a> <a href=
"#prod-xquery10-S">S</a>? "&gt;"))</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-DirElemContent" id=
"doc-xquery10-DirElemContent"></a>[<small>146&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-DirElemContent">DirElemContent</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery10-DirectConstructor">DirectConstructor</a><br />
| <a href="#doc-xquery10-CDataSection">CDataSection</a><br />
| <a href="#doc-xquery10-CommonContent">CommonContent</a><br />
| <a href=
"#doc-xquery10-ElementContentChar">ElementContentChar</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-ElementContentChar" id=
"doc-xquery10-ElementContentChar"></a>[<small>206&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-ElementContentChar">ElementContentChar</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery10-Char">Char</a> -
[{}&lt;&amp;]</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-CommonContent" id=
"doc-xquery10-CommonContent"></a>[<small>147&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-CommonContent">CommonContent</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery10-PredefinedEntityRef">PredefinedEntityRef</a> |
<a href="#prod-xquery10-CharRef">CharRef</a> | "{{" | "}}" |
<a href="#doc-xquery10-EnclosedExpr">EnclosedExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-CDataSection" id=
"doc-xquery10-CDataSection"></a>[<small>152&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-CDataSection">CDataSection</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"&lt;![CDATA[" <a href=
"#doc-xquery10-CDataSectionContents">CDataSectionContents</a>
"]]&gt;"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-CDataSectionContents" id=
"doc-xquery10-CDataSectionContents"></a>[<small>153&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-CDataSectionContents">CDataSectionContents</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xquery10-Char">Char</a>* - (Char*
']]&gt;' Char*))</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-DirAttributeList" id=
"doc-xquery10-DirAttributeList"></a>[<small>142&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-DirAttributeList">DirAttributeList</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xquery10-S">S</a> (<a href=
"#prod-xquery10-QName">QName</a> <a href="#prod-xquery10-S">S</a>?
"=" <a href="#prod-xquery10-S">S</a>? <a href=
"#doc-xquery10-DirAttributeValue">DirAttributeValue</a>)?)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-DirAttributeValue" id=
"doc-xquery10-DirAttributeValue"></a>[<small>143&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-DirAttributeValue">DirAttributeValue</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>('"' (<a href="#doc-xquery10-EscapeQuot">EscapeQuot</a> |
<a href=
"#doc-xquery10-QuotAttrValueContent">QuotAttrValueContent</a>)*
'"')<br />
| ("'" (<a href="#doc-xquery10-EscapeApos">EscapeApos</a> |
<a href="#doc-xquery10-AposAttrValueContent">AposAttrValueContent</a>)*
"'")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-QuotAttrValueContent" id=
"doc-xquery10-QuotAttrValueContent"></a>[<small>144&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-QuotAttrValueContent">QuotAttrValueContent</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery10-QuotAttrContentChar">QuotAttrContentChar</a><br />
| <a href=
"#doc-xquery10-CommonContent">CommonContent</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-AposAttrValueContent" id=
"doc-xquery10-AposAttrValueContent"></a>[<small>145&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-AposAttrValueContent">AposAttrValueContent</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery10-AposAttrContentChar">AposAttrContentChar</a><br />
| <a href=
"#doc-xquery10-CommonContent">CommonContent</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-QuotAttrContentChar" id=
"doc-xquery10-QuotAttrContentChar"></a>[<small>207&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-QuotAttrContentChar">QuotAttrContentChar</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery10-Char">Char</a> -
["{}&lt;&amp;]</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-AposAttrContentChar" id=
"doc-xquery10-AposAttrContentChar"></a>[<small>208&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-AposAttrContentChar">AposAttrContentChar</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xquery10-Char">Char</a> -
['{}&lt;&amp;]</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-EscapeQuot" id=
"doc-xquery10-EscapeQuot"></a>[<small>204&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-EscapeQuot">EscapeQuot</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>'""'</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-EscapeApos" id=
"doc-xquery10-EscapeApos"></a>[<small>205&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-EscapeApos">EscapeApos</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"''"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-EnclosedExpr" id=
"doc-xquery10-EnclosedExpr"></a>[<small>36&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-EnclosedExpr">EnclosedExpr</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"{" <a href="#doc-xquery10-Expr">Expr</a> "}"</code></td>
</tr>
</tbody>
</table>
<p><b>Core Grammar</b></p>
<p>The Core grammar productions for constructors are:</p>
<h5><a name="d6e16917" id="d6e16917"></a>Constructors</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-Constructor" id=
"doc-xcore-Constructor"></a>[<small>74&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-Constructor"></a><a href=
"#prod-xcore-Constructor">Constructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xcore-ComputedConstructor">ComputedConstructor</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-ComputedConstructor" id=
"doc-xcore-ComputedConstructor"></a>[<small>75&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-ComputedConstructor"></a><a href=
"#prod-xcore-ComputedConstructor">ComputedConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xcore-CompDocConstructor">CompDocConstructor</a><br />
| <a href=
"#doc-xcore-CompElemConstructor">CompElemConstructor</a><br />
| <a href=
"#doc-xcore-CompAttrConstructor">CompAttrConstructor</a><br />
| <a href=
"#doc-xcore-CompTextConstructor">CompTextConstructor</a><br />
| <a href=
"#doc-xcore-CompCommentConstructor">CompCommentConstructor</a><br />

| <a href=
"#doc-xcore-CompPIConstructor">CompPIConstructor</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-EnclosedExpr" id=
"doc-xcore-EnclosedExpr"></a>[<small>20&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-EnclosedExpr"></a><a href=
"#prod-xcore-EnclosedExpr">EnclosedExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"{" <a href="#doc-xcore-Expr">Expr</a> "}"</code></td>
</tr>
</tbody>
</table>
<p>There are no Core grammar productions for direct XML element or
attribute constructors as they are normalized to computed
constructors.</p>
<div class="div3">
<h4><a name="id_element_constructor" id=
"id_element_constructor"></a>4.7.1 Direct Element Constructors</h4>
<p><b>Introduction</b></p>
<p>The static and dynamic semantics of the direct forms of element
and attribute constructors are specified <span>on</span> <span>in
terms of</span> the equivalent computed element and attribute
constructors.</p>
<p><b>Notation</b></p>
<p id="jd_map_element_content">The auxiliary mapping rules
<font size="6">[</font><font size="6">]</font><a href=
"#jd_map_element_content" class="judgment"><sub><font size=
"2">ElementContent</font></sub></a>, <font size=
"6">[</font><font size="6">]</font><a href=
"#jd_map_element_content" class="judgment"><sub><font size=
"2">ElementContentUnit</font></sub></a>, <font size=
"6">[</font><font size="6">]</font><a href=
"#jd_map_element_content" class="judgment"><sub><font size=
"2">PartitionIntoUnits</font></sub></a>, and <font size=
"6">[</font><font size="6">]</font><a href=
"#jd_map_element_content" class="judgment"><sub><font size=
"2">DirCharsUnits</font></sub></a> are defined in this section and
are used for the normalization of the content of direct element
constructors.</p>
<p><b>Notation</b></p>
<p>An element-content unit is either <span>a <a href=
"#doc-fs-DirCharsUnit"><em>DirCharsUnit</em></a> (</span> a maximal
contiguous sequence of literal characters <span>(including</span>
<span>, CDataSections,</span> character references, escaped braces,
and predefined entity references), an enclosed expression, a direct
element constructor, an XML comment, or an XML processing
instruction. We use the following auxiliary grammar productions to
describe element-content units.</p>
<h5><a name="d6e17017" id="d6e17017"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-ElementContentUnit" id=
"doc-fs-ElementContentUnit"></a>[<small>83&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-ElementContentUnit">ElementContentUnit</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>DirectConstructor | EnclosedExpr | <a href=
"#doc-fs-DirCharsUnit">DirCharsUnit</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-DirCharsUnit" id=
"doc-fs-DirCharsUnit"></a>[<small>84&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-DirCharsUnit">DirCharsUnit</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(CDataSection | PredefinedEntityRef | CharRef | "{{" |
"}}" | ElementContentChar)+</code></td>
</tr>
</tbody>
</table>
<p>We use the auxiliary normalization rule <font size="6">[</font>
<em>DirElemContent</em>* <font size="6">]</font><a href=
"#jd_map_element_content" class="judgment"><sub><font size=
"2">PartitionIntoUnits</font></sub></a> to restructure the original
element content, <em>DirElemContent</em>*, into the appropriate
sequence of element-content units. This normalization rule is not
specified formally.</p>
<p>Here are three direct element constructors, each of which
contains one element-content unit:</p>
<div class="exampleInner">
<pre>
&lt;date&gt;{ xs:date("2003-03-18") }&lt;/date&gt;

&lt;name&gt;Dizzy Gillespie&lt;/name&gt;

&lt;comment&gt;&lt;!-- Just a comment --&gt;&lt;/comment&gt;
</pre></div>
<p>The first contains one enclosed expression, the second contains
one contiguous sequence of characters, and the third contains one
XML comment.</p>
<p>After boundary whitespace is stripped, the next example contains
six element-content units:</p>
<div class="exampleInner">
<pre>
&lt;address&gt;
  &lt;!-- Dizzy's address --&gt;
  { 123 }-0A &lt;street&gt;Roosevelt Ave.&lt;/street&gt; Flushing, NY { 11368 }
&lt;/address&gt;
</pre></div>
<p>It contains an XML comment, followed by an enclosed expression
that contains the integer 123, a contiguous sequence of characters
("-0A "), a direct XML element constructor, a contiguous sequence
of characters (" Flushing, NY "), and an enclosed expression that
contains the integer 11368. Evaluation of that constructor will
result in the following element.</p>
<div class="exampleInner">
<pre>
&lt;address&gt;&lt;!-- Dizzy's address --&gt;123-0A &lt;street&gt;Roosevelt Ave.&lt;/street&gt; Flushing, NY 11368&lt;/address&gt;
</pre></div>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>We start by giving the rules for the two forms of direct XML
element constructors. Note that the direct attribute constructors
are normalized twice: the <font size="6">[</font><font size=
"6">]</font><a href="#jd_map_namespace_attr" class=
"judgment"><sub><font size="2">NamespaceAttrs</font></sub></a>
normalizes the namespace-declaration attributes and <font size=
"6">[</font><font size="6">]</font><a href="#jd_map_attribute"
class="judgment"><sub><font size="2">Attribute</font></sub></a>
normalizes all other attributes that are not namespace-declaration
attributes.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font> &lt; <em>QName</em> <em>DirAttributeList</em> &gt;
<em>DirElemContent</em>* &lt;/ <em>QName</em> S? &gt; <font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">element <em>QName</em>
{ <font size="6">[</font> <em>DirAttributeList</em> <font size=
"6">]</font><a href="#jd_map_attribute" class=
"judgment"><sub><font size="2">Attribute</font></sub></a> ,
<font size="6">[</font> <font size="6">[</font>
<em>DirElemContent</em>* <font size="6">]</font><a href=
"#jd_map_element_content" class="judgment"><sub><font size=
"2">PartitionIntoUnits</font></sub></a> <font size=
"6">]</font><a href="#jd_map_element_content" class=
"judgment"><sub><font size="2">ElementContent</font></sub></a> } {
<font size="6">[</font> <em>DirAttributeList</em> <font size=
"6">]</font><a href="#jd_map_namespace_attr" class=
"judgment"><sub><font size="2">NamespaceAttrs</font></sub></a>
}</td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font> &lt; <em>QName</em> <em>DirAttributeList</em> /&gt;
<font size="6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">element <em>QName</em>
{ <font size="6">[</font> <em>DirAttributeList</em> <font size=
"6">]</font><a href="#jd_map_attribute" class=
"judgment"><sub><font size="2">Attribute</font></sub></a> } {
<font size="6">[</font> <em>DirAttributeList</em> <font size=
"6">]</font><a href="#jd_map_namespace_attr" class=
"judgment"><sub><font size="2">NamespaceAttrs</font></sub></a>
}</td>
</tr>
</table>
</div>
<p>We can now give the rules for normalizing a direct element
constructor's content. <span>We distinguish between direct element
constructors that contain only one element-content unit and those
that contain more than one element-content unit.</span></p>
<p>Adjacent element-content units <span>are convenient because
they</span> permit arbitrary interleaving of text and atomic data.
During evaluation, atomic values are converted to text nodes
containing the string representations of the atomic values, and
then adjacent text nodes are concatenated together. In the example
at the beginning of this section, the integer 123 is converted to a
string and concatenated with "-0A" and the result is a single text
node containing "123-0A".</p>
<p>Below are two examples of normalization for element
constructors.</p>
<div class="exampleInner">
<pre>
&lt;date&gt;{ xs:date("2003-03-18") }&lt;/date&gt;
 =
element date { 
  fs:item-sequence-to-node-sequence(
    xs:date("2003-03-18")
  )
}<span> {}</span>

&lt;address&gt;
  &lt;!-- Dizzy's address --&gt;
  { 123 }-0A &lt;street&gt;Roosevelt Ave.&lt;/street&gt; Flushing, NY { 11368 }
&lt;/address&gt;
 =
element address {
  fs:item-sequence-to-node-sequence(
    comment { " Dizzy's address "},
    123, 
    text { "-0A "}, 
    element street {"Roosevelt Ave."}<span> {}</span>,
    text { " Flushing, NY "  },
    11368
  )
}<span> {}</span>
</pre></div>
<p>We normalize each unit individually and construct a sequence of
the normalized results <span>interleaved with empty text nodes. The
empty text nodes guarantee that the results of evaluating
consecutive element-content units can be distinguished. Then we
apply the function <a href=
"#sec_items_to_nodes"><em>fs:</em><code>item-sequence-to-node-sequence</code></a>.
<a href=
"http://www.w3.org/TR/xquery#id-element-constructor">Section 3.7.1
Direct Element Constructors</a><sup><small>XQ</small></sup>
specifies the rules for converting a sequence of atomic values and
nodes into a sequence of nodes before element construction. The
Formal Semantics function <a href=
"#sec_items_to_nodes"><em>fs:</em><code>item-sequence-to-node-sequence</code></a>
implements these conversion rules</span>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><a href=
"#doc-fs-ElementContentUnit"><em>ElementContentUnit</em></a><sub><font size="2">1</font></sub><font size="6">]</font><a href="#jd_map_element_content"
class="judgment"><sub><font size=
"2">ElementContent</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><a href=
"#sec_items_to_nodes"><em>fs:</em><code>item-sequence-to-node-sequence</code></a>((<font size="6">[</font>
<a href=
"#doc-fs-ElementContentUnit"><em>ElementContentUnit</em></a><sub><font size="2">1</font></sub><font size="6">]</font><a href="#jd_map_element_content"
class="judgment"><sub><font size=
"2">ElementContentUnit</font></sub></a>))</td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><a href=
"#doc-fs-ElementContentUnit"><em>ElementContentUnit</em></a><sub><font size="2">1</font></sub>,
..., <a href=
"#doc-fs-ElementContentUnit"><em>ElementContentUnit</em></a><sub><font size="2">n</font></sub><font size="6">]</font><a href="#jd_map_element_content"
class="judgment"><sub><font size=
"2">ElementContent</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><span><a href=
"#sec_items_to_nodes"><em>fs:</em><code>item-sequence-to-node-sequence</code></a>((</span>
<font size="6">[</font> <a href=
"#doc-fs-ElementContentUnit"><em>ElementContentUnit</em></a><sub><font size="2">1</font></sub>
<font size="6">]</font><a href="#jd_map_element_content" class=
"judgment"><sub><font size="2">ElementContentUnit</font></sub></a>
, <span>text { "" },</span> ..., <span>text { "" },</span>
<font size="6">[</font> <a href=
"#doc-fs-ElementContentUnit"><em>ElementContentUnit</em></a><sub><font size="2">n</font></sub><font size="6">]</font><a href="#jd_map_element_content"
class="judgment"><sub><font size=
"2">ElementContentUnit</font></sub></a> <span>))</span></td>
</tr>
</table>
</div>
<p>(Note that this rule should be understood to cover the
degenerate cases of n=0 and n=1, where the element constructor's
content consists of zero or one element-content units.)</p>
<p>We must distinguish between the results of consecutive
element-content units, because the rule for converting sequences of
atomic values into strings applies to sequences within distinct
enclosed expressions. The empty text nodes are eliminated during
evaluation of <a href=
"#sec_items_to_nodes"><em>fs:</em><code>item-sequence-to-node-sequence</code></a>
when consecutive text nodes are coalesced into a single text node.
The text node guarantees that a whitespace character will not be
inserted between atomic values computed by distinct enclosed
expressions. For example, here is an expression, its normalization,
and the resulting XML value:</p>
<div class="exampleInner">
<pre>
&lt;example&gt;{ 1 }{ 2 }&lt;/example&gt;
 =
element example { fs:item-sequence-to-node-sequence ((1, text {""}, 2)) }
 ==&gt;
&lt;example&gt;12&lt;/example&gt;
</pre></div>
<p>In the absence of the empty text node, the expression would
evaluate to the following incorrect value:</p>
<div class="exampleInner">
<pre>
&lt;example&gt;{ 1 }{ 2 }&lt;/example&gt;
 (incorrect normalization) =
element example { fs:item-sequence-to-node-sequence ((1, 2)) }
 (incorrect value) ==&gt;
&lt;example&gt;1 2&lt;/example&gt;
</pre></div>
<p>Next, we give the normalization rules for each element-content
unit. The normalization rule for a contiguous sequence of
characters assumes that the significant whitespace characters in
element constructors have been preserved, as described in <a href=
"#sec_whitespace"><b>[4.7.1.4 Boundary Whitespace]</b></a>.</p>
<p>The following normalization rule takes <span>the longest
consecutive sequence</span> <span>a maximal contiguous
sequence</span> of individual characters that include literal
characters, <span>CDataSections,</span> escaped curly braces,
character references, and predefined entity references and
normalizes the character sequence as a text node containing the
string of characters.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><a href=
"#doc-fs-DirCharsUnit"><em>DirCharsUnit</em></a><font size=
"6">]</font><a href="#jd_map_element_content" class=
"judgment"><sub><font size=
"2">ElementContentUnit</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">text { <font size=
"6">[</font> <a href=
"#doc-fs-DirCharsUnit"><em>DirCharsUnit</em></a> <font size=
"6">]</font><a href="#jd_map_element_content" class=
"judgment"><sub><font size="2">DirCharsUnits</font></sub></a>
}</td>
</tr>
</table>
</div>
<p>The application of <font size="6">[</font><font size=
"6">]</font><a href="#jd_map_element_content" class=
"judgment"><sub><font size="2">DirCharsUnits</font></sub></a> to
<a href="#doc-fs-DirCharsUnit"><em>DirCharsUnit</em></a> is defined
informally. It produces a string literal corresponding to the
content of the <a href=
"#doc-fs-DirCharsUnit"><em>DirCharsUnit</em></a>, in
<span>which</span> boundary whitespace is processed <span>as
specified in <a href=
"http://www.w3.org/TR/xquery#id-whitespace">Section 3.7.1.4
Boundary Whitespace</a><sup><small>XQ</small></sup>,</span> and
non-literal characters (CharRefs, PredefinedEntityRefs,
CDataSections, and escaped-braces) are resolved according to the
rules in <a href="http://www.w3.org/TR/xquery#id-content">Section
3.7.1.3 Content</a><sup><small>XQ</small></sup>.</p>
<p>XML processing instructions and comments in element content are
normalized by applying the standard normalization rules for
expressions, which appear in <a href=
"#sec_other_constructors"><b>[4.7.2 Other Direct
Constructors]</b></a>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>DirPIConstructor</em><font size=
"6">]</font><a href="#jd_map_element_content" class=
"judgment"><sub><font size=
"2">ElementContentUnit</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>DirPIConstructor</em><font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>DirCommentConstructor</em><font size=
"6">]</font><a href="#jd_map_element_content" class=
"judgment"><sub><font size=
"2">ElementContentUnit</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>DirCommentConstructor</em><font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
</table>
</div>
<p>A direct element constructor is normalized using the
normalization rule for expressions.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>DirElemConstructor</em><font size=
"6">]</font><a href="#jd_map_element_content" class=
"judgment"><sub><font size=
"2">ElementContentUnit</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>DirElemConstructor</em><font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
</table>
</div>
<p>An enclosed expression in element content is normalized <span>by
normalizing each individual expression in its expression sequence
and then constructing a sequence of the normalized values:</span>
<span>into a call to the function <a href=
"#sec_items_to_nodes"><em>fs:</em><code>item-sequence-to-node-sequence</code></a>,
which implements various rules for converting a sequence of atomic
values and nodes into a sequence of nodes before element
construction.</span></p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font> { <span><em>Expr</em><sub><font size=
"2">1</font></sub>, ..., <em>Expr</em><sub><font size=
"2">n</font></sub></span> <span><em>Expr</em></span> } <font size=
"6">]</font><a href="#jd_map_element_content" class=
"judgment"><sub><font size=
"2">ElementContentUnit</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><span><font size=
"6">[</font> <em>Expr</em><sub><font size="2">1</font></sub>
<font size="6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a> , ...,
<font size="6">[</font> <em>Expr</em><sub><font size=
"2">n</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a></span>
<span><a href=
"#sec_items_to_nodes"><em>fs:</em><code>item-sequence-to-node-sequence</code></a>((
<font size="6">[</font><em>Expr</em><font size="6">]</font><a href=
"#jd_map_expr" class="judgment"><sub><font size=
"2">Expr</font></sub></a> ))</span></td>
</tr>
</table>
</div>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>There are no additional static typing rules for direct XML
element or attribute constructors.</p>
<p><b><a href="#processing_dynamic" class="processing">Dynamic
Evaluation</a></b></p>
<p>There are no additional dynamic evaluation rules for direct XML
element or attribute constructors.</p>
<div class="div4">
<h5><a name="sec_direct_attributes" id=
"sec_direct_attributes"></a>4.7.1.1 Attributes</h5>
<p>Like direct element constructors, direct attribute constructors
are normalized to computed attribute constructors.</p>
<p><b>Notation</b></p>
<p id="jd_map_attr_content">The auxiliary mapping rules <font size=
"6">[</font><font size="6">]</font><a href="#jd_map_attribute"
class="judgment"><sub><font size="2">Attribute</font></sub></a>,
<span><font size="6">[</font><font size="6">]</font><a href=
"#jd_map_dir_attribute_value" class="judgment"><sub><font size=
"2">DirAttributeValue</font></sub></a>,</span> <font size=
"6">[</font><font size="6">]</font><a href="#jd_map_attr_content"
class="judgment"><sub><font size=
"2">AttributeContent</font></sub></a>, <font size=
"6">[</font><font size="6">]</font><a href="#jd_map_attr_content"
class="judgment"><sub><font size=
"2">AttributeContentUnit</font></sub></a>, and <span><font size=
"6">[</font><font size="6">]</font><a href=
"#jd_map_attribute_chars_unit" class="judgment"><sub><font size=
"2">AttributeCharsUnit</font></sub></a>,</span> are defined in this
section and are used for the normalization of direct attribute
constructors.</p>
<p>We use the following grammar productions to represent
<em>AttributeContentUnit</em>s, i.e., the expressions used to
compute the content of an attribute.</p>
<h5><a name="d6e17600" id="d6e17600"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-AttributeContentUnits" id=
"doc-fs-AttributeContentUnits"></a>[<small>87&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-AttributeContentUnits">AttributeContentUnits</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-fs-AttributeContentUnit">AttributeContentUnit</a>*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-AttributeContentUnit" id=
"doc-fs-AttributeContentUnit"></a>[<small>88&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-AttributeContentUnit">AttributeContentUnit</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-fs-AttributeCharsUnit">AttributeCharsUnit</a> |
EnclosedExpr</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-AttributeCharsUnit" id=
"doc-fs-AttributeCharsUnit"></a>[<small>91&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-AttributeCharsUnit">AttributeCharsUnit</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(QuotAttrContentChar | AposAttrContentChar | EscapeQuot |
EscapeApos | PredefinedEntityRef | CharRef | "{{" |
"}}")+</code></td>
</tr>
</tbody>
</table>
<p>An <em>AttributeCharsUnit</em> is required to be maximal, i.e.,
it must extend as far as possible in both directions. In other
words, an <em>AttributeContentUnits</em> must not contain two
adjacent <em>AttributeCharsUnit</em>s.</p>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p id="sec_attribute_normalization">Direct attributes may contain
namespace-declaration attributes. The normalization rules in this
section ignore namespace-declaration attributes -- they are handled
by the normalization rules in <a href=
"#sec_namespace_attrs"><b>[4.7.1.2 Namespace Declaration
Attributes]</b></a>.</p>
<p>A <em>DirAttributeList</em> is normalized by the following rule,
which maps each of the individual attribute-value expressions in
the attribute list and constructs a sequence of the normalized
values.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>
<table summary="">
<tbody>
<tr>
<td><em>QName</em><sub><font size="2">1</font></sub> S? = S?
<a href=
"#doc-xquery-DirAttributeValue"><em>DirAttributeValue</em></a><sub><font size="2">1</font></sub></td>
</tr>
<tr>
<td>...</td>
</tr>
<tr>
<td><em>QName</em><sub><font size="2">n</font></sub> S? = S?
<a href=
"#doc-xquery-DirAttributeValue"><em>DirAttributeValue</em></a><sub><font size="2">n</font></sub></td>
</tr>
</tbody>
</table>
<font size="6">]</font><a href="#jd_map_attribute" class=
"judgment"><sub><font size="2">Attribute</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<table summary="">
<tbody>
<tr>
<td>(<font size="6">[</font><em>QName</em><sub><font size=
"2">1</font></sub> S? = S? <a href=
"#doc-xquery-DirAttributeValue"><em>DirAttributeValue</em></a><sub><font size="2">1</font></sub>
<font size="6">]</font><a href="#jd_map_attribute" class=
"judgment"><sub><font size="2">Attribute</font></sub></a></td>
</tr>
<tr>
<td>...,</td>
</tr>
<tr>
<td><font size="6">[</font><em>QName</em><sub><font size=
"2">n</font></sub> S? = S? <a href=
"#doc-xquery-DirAttributeValue"><em>DirAttributeValue</em></a><sub><font size="2">n</font></sub><font size="6">]</font><a href="#jd_map_attribute"
class="judgment"><sub><font size=
"2">Attribute</font></sub></a>)</td>
</tr>
</tbody>
</table>
</td>
</tr>
</table>
</div>
<p id="jd_map_attribute">Namespace-declaration attributes, i.e.,
those attributes whose prefix is <code>xmlns</code> are ignored by
mapping them to the empty sequence.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<table summary="">
<tbody>
<tr>
<td><font size="6">[</font><em>Prefix</em>:<em>LocalPart</em> S? =
S? <a href=
"#doc-xquery-DirAttributeValue"><em>DirAttributeValue</em></a><font size="6">]</font><a href="#jd_map_attribute"
class="judgment"><sub><font size=
"2">Attribute</font></sub></a></td>
</tr>
<tr>
<td>(<em>Prefix</em> = <code>xmlns</code>)</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">()</td>
</tr>
</table>
</div>
<p>All attributes that are not namespace-declaration attributes are
mapped to computed attribute constructors.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<table summary="">
<tbody>
<tr>
<td><font size="6">[</font><em>Prefix</em>:<em>LocalPart</em> S? =
S? <span><a href=
"#doc-xquery-DirAttributeValue"><em>DirAttributeValue</em></a></span><font size="6">]</font><a href="#jd_map_attribute"
class="judgment"><sub><font size=
"2">Attribute</font></sub></a></td>
</tr>
<tr>
<td><a href="#jd_not" class=
"judgment"><b>not</b></a>(<em>Prefix</em> =
<code>xmlns</code>)</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">attribute
<em>Prefix</em>:<em>LocalPart</em> { <font size="6">[</font>
<span><font size="6">[</font><a href=
"#doc-xquery-DirAttributeValue"><em>DirAttributeValue</em></a><font size="6">]</font><a href="#jd_map_dir_attribute_value"
class="judgment"><sub><font size=
"2">DirAttributeValue</font></sub></a></span> <font size=
"6">]</font><a href="#jd_map_attr_content" class=
"judgment"><sub><font size="2">AttributeContent</font></sub></a>
}</td>
</tr>
</table>
</div>
<p id="jd_map_dir_attribute_value">The effect of <font size=
"6">[</font><a href=
"#doc-xquery-DirAttributeValue"><em>DirAttributeValue</em></a><font size="6">]</font><a href="#jd_map_dir_attribute_value"
class="judgment"><sub><font size=
"2">DirAttributeValue</font></sub></a> is not specified formally;
informally, it partitions the content of <a href=
"#doc-xquery-DirAttributeValue"><em>DirAttributeValue</em></a> into
a sequence of <em>AttributeContentUnit</em>s, each of which is
either an enclosed expression (<em>EnclosedExpr</em>) or a maximal
run of character content (<em>AttributeCharsUnit</em>). These
content units are then normalized via <font size=
"6">[</font><font size="6">]</font><a href="#jd_map_attr_content"
class="judgment"><sub><font size=
"2">AttributeContent</font></sub></a>, which is defined below.</p>
<p>As with literal XML elements, we need to distinguish between
direct attribute constructors that contain one attribute-content
unit and those that contain multiple attribute-content units,
because the rule for converting sequences of atomic values into
strings is applied to sequences within distinct enclosed
expressions. If the direct attribute constructor contains exactly
one attribute-content unit, we simply normalize that unit by
applying the normalization rule for attribute content units:</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font> <em>AttributeContentUnit</em><sub><font size=
"2">1</font></sub> <font size="6">]</font><a href=
"#jd_map_attr_content" class="judgment"><sub><font size=
"2">AttributeContent</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>AttributeContentUnit</em><sub><font size=
"2">1</font></sub><font size="6">]</font><a href=
"#jd_map_attr_content" class="judgment"><sub><font size=
"2">AttributeContentUnit</font></sub></a></td>
</tr>
</table>
</div>
<p><span>To apply <font size="6">[</font><font size=
"6">]</font><a href="#jd_map_attr_content" class=
"judgment"><sub><font size="2">AttributeContent</font></sub></a> to
zero or more attribute-content units,</span> we normalize each unit
individually and construct a sequence of the normalized results
<span>interleaved with empty text nodes. The empty text nodes
guarantee that the results of evaluating consecutive
attribute-content units can be distinguished</span>. Then we apply
the function <span><a href=
"#sec_item_seq_to_untypedAtomic"><em>fs:</em><code>item-sequence-to-untypedAtomic</code></a>,
which applies the appropriate conversion rules to the normalized
attribute content:</span> <span><code>fn:string-join</code>, which
will concatenate the values of the normalized units.</span></p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font> <em>AttributeContentUnit</em><sub><font size=
"2">1</font></sub> ...
<em>AttributeContentUnit</em><sub><font size="2">n</font></sub>
<font size="6">]</font><a href="#jd_map_attr_content" class=
"judgment"><sub><font size=
"2">AttributeContent</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><span><a href=
"#sec_item_seq_to_untypedAtomic"><em>fs:</em><code>item-sequence-to-untypedAtomic</code></a></span>
<span>fn:string-join</span> ((<font size="6">[</font>
<em>AttributeContentUnit</em><sub><font size="2">1</font></sub>
<font size="6">]</font><a href="#jd_map_attr_content" class=
"judgment"><sub><font size=
"2">AttributeContentUnit</font></sub></a> , <span>text { ""
},</span> ..., <span>text {""},</span> <font size="6">[</font>
<em>AttributeContentUnit</em><sub><font size=
"2">n</font></sub><font size="6">]</font><a href=
"#jd_map_attr_content" class="judgment"><sub><font size=
"2">AttributeContentUnit</font></sub></a>) <span>, ''</span> )</td>
</tr>
</table>
</div>
<p>(Note that this rule should be understood to cover the
degenerate cases of n=0 and n=1, where the attribute constructor's
content consists of zero or one attribute-content units.)</p>
<p>Literal characters, escaped curly braces, character references,
and predefined entity references in attribute content are treated
as in element content. In addition, the normalization rule for
characters in attributes assumes:</p>
<ol class="enumar">
<li>
<p>that an escaped single or double quote is converted to an
individual single or double quote.</p>
</li>
</ol>
<p>The following normalization rules take the longest consecutive
sequence of individual characters that include literal characters,
escaped curly braces, escaped quotes, character references,
predefined entity references, and escaped single and double quotes
and normalizes the character sequence as a string.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>( <em>Char</em> | <em>CharRef</em> |
<em>EscapeQuot</em> | <em>EscapeApos</em> |
<em>PredefinedEntityRef</em> ) +<font size="6">]</font><a href=
"#jd_map_attr_content" class="judgment"><sub><font size=
"2">AttributeContentUnit</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<code>fn:codepoints-to-string</code>(( <em>Char</em> |
<em>CharRef</em> | <em>EscapeQuot</em> | <em>EscapeApos</em> |
<em>PredefinedEntityRef</em> )+)</td>
</tr>
</table>
</div>
<p>The next two rules specify the normalization of each
attribute-content unit via <font size="6">[</font><font size=
"6">]</font><a href="#jd_map_attr_content" class=
"judgment"><sub><font size=
"2">AttributeContentUnit</font></sub></a>.</p>
<p>We normalize an <em>AttributeCharsUnit</em> (i.e., a maximal run
of attribute-content characters, including literal characters,
character references, predefined entity references, escaped curly
braces, and escaped single and double quotes) by converting it into
a string literal.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font> <span><em>AttributeCharsUnit</em></span> <font size=
"6">]</font><a href="#jd_map_attr_content" class=
"judgment"><sub><font size=
"2">AttributeContentUnit</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font> <em>AttributeCharsUnit</em> <font size=
"6">]</font><a href="#jd_map_attribute_chars_unit" class=
"judgment"><sub><font size=
"2">AttributeCharsUnit</font></sub></a></td>
</tr>
</table>
</div>
<p id="jd_map_attribute_chars_unit">The effect of <font size=
"6">[</font><em>AttributeCharsUnit</em><font size=
"6">]</font><a href="#jd_map_attribute_chars_unit" class=
"judgment"><sub><font size="2">AttributeCharsUnit</font></sub></a>
is not specified formally; informally, it unescapes any escaped
braces or quotes, performs attribute value normalization as
specified in <a href=
"http://www.w3.org/TR/xquery#id-attributes">Section 3.7.1.1
Attributes</a><sup><small>XQ</small></sup>, and then represents the
resulting string value as a string literal.</p>
<p>We normalize an enclosed expression <span>by normalizing each
individual expression in its expression sequence and then
constructing a sequence of the normalized values:</span> <span>into
a call to the function <a href=
"#sec_item_seq_to_string"><em>fs:</em><code>item-sequence-to-string</code></a>,
which implements various rules for converting a sequence of atomic
values and nodes into a string.</span></p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font> { <span><em>Expr</em><sub><font size=
"2">1</font></sub>, ..., <em>Expr</em><sub><font size=
"2">n</font></sub></span> <span><em>Expr</em></span> } <font size=
"6">]</font><a href="#jd_map_attr_content" class=
"judgment"><sub><font size=
"2">AttributeContentUnit</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><span>(<font size=
"6">[</font> <em>Expr</em><sub><font size="2">1</font></sub>
<font size="6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a> , ...,
<font size="6">[</font> <em>Expr</em><sub><font size=
"2">n</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>)</span>
<span><a href=
"#sec_item_seq_to_string"><em>fs:</em><code>item-sequence-to-string</code></a>((
<font size="6">[</font> <em>Expr</em> <font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a> ))</span></td>
</tr>
</table>
</div>
</div>
<div class="div4">
<h5><a name="sec_namespace_attrs" id=
"sec_namespace_attrs"></a>4.7.1.2 Namespace Declaration
Attributes</h5>
<p><b>Notation</b></p>
<p id="jd_map_namespace_attr">The auxiliary mapping rules
<font size="6">[</font><font size="6">]</font><a href=
"#jd_map_namespace_attr" class="judgment"><sub><font size=
"2">NamespaceAttr</font></sub></a>, and <font size=
"6">[</font><font size="6">]</font><a href="#jd_map_namespace_attr"
class="judgment"><sub><font size=
"2">NamespaceAttrs</font></sub></a> are defined in this section and
are used for the normalization of namespace declaration
attributes.</p>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>Some direct attributes may be namespace-declaration attributes.
The normalization rules for namespace-declaration attributes ignore
all non-namespace attributes -- they are handled by the
normalization rules in <a href="#sec_direct_attributes"><b>[4.7.1.1
Attributes]</b></a>.</p>
<p>A <em>DirAttributeList</em> containing namespace-declaration
attributes is normalized by the following rule, which maps each of
the individual namespace-declaration attributes in the attribute
list and constructs a sequence of the normalized namespace
attribute values.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>
<table summary="">
<tbody>
<tr>
<td><em>QName</em><sub><font size="2">1</font></sub> S? = S?
<a href=
"#doc-xquery-DirAttributeValue"><em>DirAttributeValue</em></a><sub><font size="2">1</font></sub></td>
</tr>
<tr>
<td>...</td>
</tr>
<tr>
<td><em>QName</em><sub><font size="2">n</font></sub> S? = S?
<a href=
"#doc-xquery-DirAttributeValue"><em>DirAttributeValue</em></a><sub><font size="2">n</font></sub></td>
</tr>
</tbody>
</table>
<font size="6">]</font><a href="#jd_map_namespace_attr" class=
"judgment"><sub><font size="2">NamespaceAttrs</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<table summary="">
<tbody>
<tr>
<td>(<font size="6">[</font><em>QName</em><sub><font size=
"2">1</font></sub> S? = S? <a href=
"#doc-xquery-DirAttributeValue"><em>DirAttributeValue</em></a><sub><font size="2">1</font></sub><font size="6">]</font><a href="#jd_map_namespace_attr"
class="judgment"><sub><font size=
"2">NamespaceAttr</font></sub></a></td>
</tr>
<tr>
<td>...,</td>
</tr>
<tr>
<td><font size="6">[</font><em>QName</em><sub><font size=
"2">n</font></sub> S? = S? <a href=
"#doc-xquery-DirAttributeValue"><em>DirAttributeValue</em></a><sub><font size="2">n</font></sub><font size="6">]</font><a href="#jd_map_namespace_attr"
class="judgment"><sub><font size=
"2">NamespaceAttr</font></sub></a>)</td>
</tr>
</tbody>
</table>
</td>
</tr>
</table>
</div>
<p>Attributes whose prefix is not <code>xmlns</code> are ignored by
mapping them to the empty sequence.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<table summary="">
<tbody>
<tr>
<td><font size="6">[</font><em>Prefix</em>:<em>LocalPart</em> S? =
S? <a href=
"#doc-xquery-DirAttributeValue"><em>DirAttributeValue</em></a><font size="6">]</font><a href="#jd_map_namespace_attr"
class="judgment"><sub><font size=
"2">NamespaceAttr</font></sub></a></td>
</tr>
<tr>
<td><a href="#jd_not" class=
"judgment"><b>not</b></a>(<em>Prefix</em> =
<code>xmlns</code>)</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">()</td>
</tr>
</table>
</div>
<p>Namespace-declaration attributes are normalized to local
namespace declarations (<span><a href=
"#doc-core-LocalNamespaceDecl"><em>LocalNamespaceDecl</em></a></span>).
The content of such attributes must be defined with a URI
literal.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<table summary="">
<tbody>
<tr>
<td><font size="6">[</font><em>Prefix</em>:<em>LocalPart</em> S? =
S? " <em>URILiteral</em> "<font size="6">]</font><a href=
"#jd_map_namespace_attr" class="judgment"><sub><font size=
"2">NamespaceAttr</font></sub></a></td>
</tr>
<tr>
<td>(<em>Prefix</em> = <code>xmlns</code>)</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">namespace
<em>LocalPart</em> { <em>URILiteral</em> }</td>
</tr>
</table>
</div>
</div>
<div class="div4">
<h5><a name="sec_content" id="sec_content"></a>4.7.1.3 Content</h5>
<p>The rules for normalizing element content are given above in
<a href="#id_element_constructor"><b>[4.7.1 Direct Element
Constructors]</b></a>.</p>
</div>
<div class="div4">
<h5><a name="sec_whitespace" id="sec_whitespace"></a>4.7.1.4
Boundary Whitespace</h5>
<p><a href="http://www.w3.org/TR/xquery#id-whitespace">Section
3.7.1.4 Boundary Whitespace</a><sup><small>XQ</small></sup>
describes how whitespace is processed in element constructors
depending on the value of the <code>boundary-space</code>
declaration in the query prolog. The Formal Semantics assumes that
the rules for handling whitespace are applied by the (informally
defined) auxiliary rule <font size="6">[</font><font size=
"6">]</font><a href="#jd_map_element_content" class=
"judgment"><sub><font size="2">DirCharsUnits</font></sub></a>.</p>
</div>
</div>
<div class="div3">
<h4><a name="sec_other_constructors" id=
"sec_other_constructors"></a>4.7.2 Other Direct Constructors</h4>
<h5><a name="d6e18427" id="d6e18427"></a>Other Constructors</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-DirPIConstructor" id=
"doc-xquery10-DirPIConstructor"></a>[<small>150&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-DirPIConstructor">DirPIConstructor</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"&lt;?" <a href="#prod-xquery10-PITarget">PITarget</a>
(<a href="#prod-xquery10-S">S</a> <a href=
"#doc-xquery10-DirPIContents">DirPIContents</a>)?
"?&gt;"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-DirPIContents" id=
"doc-xquery10-DirPIContents"></a>[<small>151&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-DirPIContents">DirPIContents</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xquery10-Char">Char</a>* - (Char* '?&gt;'
Char*))</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-DirCommentConstructor" id=
"doc-xquery10-DirCommentConstructor"></a>[<small>148&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-DirCommentConstructor">DirCommentConstructor</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"&lt;!--" <a href=
"#doc-xquery10-DirCommentContents">DirCommentContents</a>
"--&gt;"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-DirCommentContents" id=
"doc-xquery10-DirCommentContents"></a>[<small>149&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-DirCommentContents">DirCommentContents</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>((<a href="#prod-xquery10-Char">Char</a> - '-') | ('-'
(<a href="#prod-xquery10-Char">Char</a> - '-')))*</code></td>
</tr>
</tbody>
</table>
<p><b>Notation</b></p>
<p id="jd_map_characters">The auxiliary mapping rule <font size=
"6">[</font><font size="6">]</font><a href="#jd_map_characters"
class="judgment"><sub><font size="2">Characters</font></sub></a> is
defined in this section and used for the normalization of direct PI
and comment constructors.</p>
<p><font size="6">[</font><em>Char</em>*<font size=
"6">]</font><a href="#jd_map_characters" class=
"judgment"><sub><font size="2">Characters</font></sub></a> takes
the character content of a PI or comment constructor and yields a
corresponding <em>StringLiteral</em>.</p>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>A literal XML processing instruction is normalized into a
computed processing-instruction constructor; its character content
is converted to a string using the auxiliary mapping rule
<font size="6">[</font><font size="6">]</font><a href=
"#jd_map_characters" class="judgment"><sub><font size=
"2">Characters</font></sub></a>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>&lt;? <em>NCName</em> <em>DirPIContents</em>
?&gt;<font size="6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>processing-instruction <em>NCName</em> { <font size=
"6">[</font><em>DirPIContents</em><font size="6">]</font><a href=
"#jd_map_characters" class="judgment"><sub><font size=
"2">Characters</font></sub></a> }<font size="6">]</font><a href=
"#jd_map_expr" class="judgment"><sub><font size=
"2">Expr</font></sub></a></td>
</tr>
</table>
</div>
<p>A literal XML comment is normalized into a computed comment
constructor; its character content is converted to a string using
the auxiliary mapping rule <font size="6">[</font><font size=
"6">]</font><a href="#jd_map_characters" class=
"judgment"><sub><font size="2">Characters</font></sub></a>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>&lt;!-- <em>DirCommentContents</em> --&gt;<font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>comment { <font size=
"6">[</font><em>DirCommentContents</em><font size=
"6">]</font><a href="#jd_map_characters" class=
"judgment"><sub><font size="2">Characters</font></sub></a>
}<font size="6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
</table>
</div>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>There are no additional static typing rules for direct
processing-instruction or comment constructors.</p>
<p><b><a href="#processing_dynamic" class="processing">Dynamic
Evaluation</a></b></p>
<p>There are no additional dynamic evaluation rules for direct
processing-instruction or comment constructors.</p>
</div>
<div class="div3">
<h4><a name="sec_computedConstructors" id=
"sec_computedConstructors"></a>4.7.3 Computed Constructors</h4>
<h5><a name="d6e18579" id="d6e18579"></a>Computed Constructors</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-ComputedConstructor" id=
"doc-xquery10-ComputedConstructor"></a>[<small>154&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-ComputedConstructor">ComputedConstructor</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery10-CompDocConstructor">CompDocConstructor</a><br />
| <a href=
"#doc-xquery10-CompElemConstructor">CompElemConstructor</a><br />
| <a href=
"#doc-xquery10-CompAttrConstructor">CompAttrConstructor</a><br />
| CompNamespaceConstructor<br />
| <a href=
"#doc-xquery10-CompTextConstructor">CompTextConstructor</a><br />
| <a href=
"#doc-xquery10-CompCommentConstructor">CompCommentConstructor</a><br />

| <a href=
"#doc-xquery10-CompPIConstructor">CompPIConstructor</a></code></td>
</tr>
</tbody>
</table>
<div class="div4">
<h5><a name="sec_comp_elem_constructor" id=
"sec_comp_elem_constructor"></a>4.7.3.1 Computed Element
Constructors</h5>
<p><b>Introduction</b></p>
<p>This section describes the semantics of computed element
constructors. Remember that direct element constructors are
normalized into computed element constructors. This document does
not formally specify how namespaces are copied. The semantics of
namespaces copying in element constructors can be found in <a href=
"#xquery-11">[XQuery 1.1: An XML Query Language]</a>.</p>
<h5><a name="d6e18621" id="d6e18621"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-CompElemConstructor" id=
"doc-xquery10-CompElemConstructor"></a>[<small>156&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-CompElemConstructor">CompElemConstructor</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"element" (_QName_or_EQName | ("{" <a href=
"#doc-xquery10-Expr">Expr</a> "}")) "{" <a href=
"#doc-xquery10-ContentExpr">ContentExpr</a>? "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-ContentExpr" id=
"doc-xquery10-ContentExpr"></a>[<small>157&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-ContentExpr">ContentExpr</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery10-Expr">Expr</a></code></td>
</tr>
</tbody>
</table>
<p><b>Core Grammar</b></p>
<p>The Core grammar productions for computed element constructors
are:</p>
<h5><a name="d6e18647" id="d6e18647"></a>Computed Element
Constructors</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-CompElemConstructor" id=
"doc-xcore-CompElemConstructor"></a>[<small>77&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-CompElemConstructor"></a><a href=
"#prod-xcore-CompElemConstructor">CompElemConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"element" (_QName_or_EQName | ("{" <a href=
"#doc-xcore-Expr">Expr</a> "}")) "{" <a href=
"#doc-xcore-ContentExpr">ContentExpr</a> "}" "{" <a href=
"#doc-xcore-LocalNamespaceDecls">LocalNamespaceDecls</a>
"}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-ContentExpr" id=
"doc-xcore-ContentExpr"></a>[<small>80&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-ContentExpr"></a><a href=
"#prod-xcore-ContentExpr">ContentExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-Expr">Expr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-LocalNamespaceDecls" id=
"doc-xcore-LocalNamespaceDecls"></a>[<small>78&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-LocalNamespaceDecls"></a><a href=
"#prod-xcore-LocalNamespaceDecls">LocalNamespaceDecls</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xcore-LocalNamespaceDecl">LocalNamespaceDecl</a>*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-LocalNamespaceDecl" id=
"doc-xcore-LocalNamespaceDecl"></a>[<small>79&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-LocalNamespaceDecl"></a><a href=
"#prod-xcore-LocalNamespaceDecl">LocalNamespaceDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"namespace" <a href="#prod-xcore-NCName">NCName</a> "{"
<a href="#doc-xcore-URILiteral">URILiteral</a> "}"</code></td>
</tr>
</tbody>
</table>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>If the content expression is missing, the computed element
constructor is normalized as if its content expression was the
empty sequence.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>element <em>QName</em> { }<font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>element <em>QName</em> { () }<font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
</table>
</div>
<p>Computed element constructors are normalized using the <a href=
"#sec_items_to_nodes"><em>fs:</em><code>item-sequence-to-node-sequence</code></a>
function over their content expression.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>element <em>QName</em> { <em>Expr</em> }<font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">element <em>QName</em>
{ <a href=
"#sec_items_to_nodes"><em>fs:</em><code>item-sequence-to-node-sequence</code></a>((<font size="6">[</font><em>Expr</em><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>)) }
<span>{}</span></td>
</tr>
</table>
</div>
<p>When the name of the element is also computed, the normalization
rule applies atomization to the name expression.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>element { <em>Expr</em><sub><font size=
"2">1</font></sub> } { <em>Expr</em><sub><font size=
"2">2</font></sub> }<font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">element {
<code>fn:data</code>((<font size=
"6">[</font><em>Expr</em><sub><font size=
"2">1</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>)) }{
<a href=
"#sec_items_to_nodes"><em>fs:</em><code>item-sequence-to-node-sequence</code></a>((<font size="6">[</font><em>Expr</em><sub><font size="2">2</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>)) }
<span>{}</span></td>
</tr>
</table>
</div>
<p><b>Notation</b></p>
<p id="jd_add_namespace_bindings">The following auxiliary judgment
adds a sequence of namespace bindings to the static context.</p>
<div align="center"><a href="#jd_add_namespace_bindings" class=
"judgment"><b>add namespace bindings</b></a> <span><a href=
"#doc-core-LocalNamespaceDecls"><em>LocalNamespaceDecls</em></a></span>
<a href="#jd_add_namespace_bindings" class="judgment"><b>to</b></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">1</font></sub> <a href="#jd_add_namespace_bindings" class=
"judgment"><b>yields</b></a> <a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">2</font></sub></div>
<p>This judgment is defined as follows.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <a href="#jd_add_namespace_bindings" class=
"judgment"><b>add namespace bindings</b></a> <a href=
"#jd_add_namespace_bindings" class="judgment"><b>to</b></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">0</font></sub> <a href="#jd_add_namespace_bindings" class=
"judgment"><b>yields</b></a> <a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">0</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><span><a href=
"#doc-core-LocalNamespaceDecl"><em>LocalNamespaceDecl</em></a><sub><font size="2">1</font></sub></span>
= namespace <em>LocalPart</em><sub><font size="2">1</font></sub> {
<em>URILiteral</em><sub><font size="2">1</font></sub> }</td>
</tr>
<tr align="center" valign="middle">
<td>...</td>
</tr>
<tr align="center" valign="middle">
<td><span><a href=
"#doc-core-LocalNamespaceDecl"><em>LocalNamespaceDecl</em></a><sub><font size="2">n</font></sub></span>
= namespace <em>LocalPart</em><sub><font size="2">n</font></sub> {
<em>URILiteral</em><sub><font size="2">n</font></sub> }</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_default_dyn_env" class=
"env">dynEnvDefault</a><b>&#160;|-&#160;</b><em>URILiteral</em><sub><font size="2">1</font></sub>
<a href="#jd_has_atomic_value" class="judgment"><b>has atomic
value</b></a> <em>AnyURI</em></td>
</tr>
<tr align="center" valign="middle">
<td>...</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_default_dyn_env" class=
"env">dynEnvDefault</a><b>&#160;|-&#160;</b><em>URILiteral</em><sub><font size="2">1</font></sub>
<a href="#jd_has_atomic_value" class="judgment"><b>has atomic
value</b></a> <em>AnyURI</em></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">1</font></sub>.<a href=
"#xq_ns_env" class="env">namespace</a> = <a href="#xq_stat_env_def"
class="env">statEnv</a><sub><font size="2">0</font></sub> +
<a href="#xq_ns_env" class=
"env">namespace</a>(<em>LocalPart</em><sub><font size=
"2">1</font></sub> =&gt; (passive, <em>AnyURI</em><sub><font size=
"2">1</font></sub>))</td>
</tr>
<tr align="center" valign="middle">
<td>...</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">n</font></sub>.<a href=
"#xq_ns_env" class="env">namespace</a> = <a href="#xq_stat_env_def"
class="env">statEnv</a><sub><font size="2">n-1</font></sub> +
<a href="#xq_ns_env" class=
"env">namespace</a>(<em>LocalPart</em><sub><font size=
"2">n</font></sub> =&gt; (passive, <em>AnyURI</em><sub><font size=
"2">n</font></sub>))</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <a href="#jd_add_namespace_bindings" class=
"judgment"><b>add namespace bindings</b></a> <span><a href=
"#doc-core-LocalNamespaceDecl"><em>LocalNamespaceDecl</em></a><sub><font size="2">1</font></sub>
... <a href=
"#doc-core-LocalNamespaceDecl"><em>LocalNamespaceDecl</em></a><sub><font size="2">n</font></sub></span>
<a href="#jd_add_namespace_bindings" class="judgment"><b>to</b></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">0</font></sub> <a href="#jd_add_namespace_bindings" class=
"judgment"><b>yields</b></a> <a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">n</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>The normalization rules of direct element and attribute
constructors leave us with only the computed forms of constructors.
The static semantics for constructors is defined on all the
computed forms. The computed element constructor itself has two
forms: one in which the element name is a literal <em>QName</em>,
and the other in which the element name is a computed
expression.</p>
<p>A computed element constructor creates a new element with either
the <a href="http://www.w3.org/TR/xquery#dt-type-annotation">type
annotation</a><sup><small>XQ</small></sup> <a href=
"#dt-xs_untyped"><code>xs:untyped</code></a> (in strip construction
mode), or with the <a href=
"http://www.w3.org/TR/xquery#dt-type-annotation">type
annotation</a><sup><small>XQ</small></sup> <code>xs:anyType</code>
(in preserve construction mode). The content expression must return
a <span>sequence of nodes with attribute nodes at the
beginning.</span></p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_construction_mode_env" class="env">constructionMode</a> =
preserve</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#jd_add_namespace_bindings" class="judgment"><b>add
namespace bindings</b></a> <span><a href=
"#doc-core-LocalNamespaceDecls"><em>LocalNamespaceDecls</em></a></span>
<a href="#jd_add_namespace_bindings" class="judgment"><b>to</b></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">1</font></sub> <a href="#jd_add_namespace_bindings" class=
"judgment"><b>yields</b></a> <a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size=
"2">2</font></sub><b>&#160;|-&#160;</b><em>Expr</em> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size=
"2">2</font></sub><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a> <a href="#jd_subtype_of" class=
"judgment"><b>&lt;:</b></a> attribute <span>*</span>*, (element
<span>*</span> | text | comment | processing-instruction
<span>*</span>) *</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size=
"2">1</font></sub><b>&#160;|-&#160;</b> element <em>QName</em> {
<em>Expr</em> } { <span><a href=
"#doc-core-LocalNamespaceDecls"><em>LocalNamespaceDecls</em></a></span>
} <a href="#jd_has_type" class="judgment"><b>:</b></a> element
<em>QName</em> of type <code>xs:anyType</code></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_construction_mode_env" class="env">constructionMode</a> =
strip</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#jd_add_namespace_bindings" class="judgment"><b>add
namespace bindings</b></a> <span><a href=
"#doc-core-LocalNamespaceDecls"><em>LocalNamespaceDecls</em></a></span>
<a href="#jd_add_namespace_bindings" class="judgment"><b>to</b></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">1</font></sub> <a href="#jd_add_namespace_bindings" class=
"judgment"><b>yields</b></a> <a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size=
"2">2</font></sub><b>&#160;|-&#160;</b><em>Expr</em> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size=
"2">2</font></sub><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a> <a href="#jd_subtype_of" class=
"judgment"><b>&lt;:</b></a> attribute <span>*</span>*, (element
<span>*</span> | text | comment | processing-instruction
<span>*</span>) *</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size=
"2">1</font></sub><b>&#160;|-&#160;</b> element <em>QName</em> {
<em>Expr</em> } { <span><a href=
"#doc-core-LocalNamespaceDecls"><em>LocalNamespaceDecls</em></a></span>
} <a href="#jd_has_type" class="judgment"><b>:</b></a> element
<em>QName</em> of type <a href=
"#dt-xs_untyped"><code>xs:untyped</code></a></td>
</tr>
</table>
<br /></div>
<p>In case the element name is computed as well, the name
expression must be of type <code>xs:QName</code>,
<code>xs:string</code>, or <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_construction_mode_env" class="env">constructionMode</a> =
preserve</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#jd_add_namespace_bindings" class="judgment"><b>add
namespace bindings</b></a> <span><a href=
"#doc-core-LocalNamespaceDecls"><em>LocalNamespaceDecls</em></a></span>
<a href="#jd_add_namespace_bindings" class="judgment"><b>to</b></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">1</font></sub> <a href="#jd_add_namespace_bindings" class=
"judgment"><b>yields</b></a> <a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size=
"2">2</font></sub><b>&#160;|-&#160;</b><em>Expr</em><sub><font size="2">1</font></sub>
<a href="#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size=
"2">2</font></sub><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
(<code>xs:QName</code> | <code>xs:string</code> | <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size=
"2">2</font></sub><b>&#160;|-&#160;</b><em>Expr</em><sub><font size="2">2</font></sub>
<a href="#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size=
"2">2</font></sub><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
attribute <span>*</span>*, (element <span>*</span> | text | comment
| processing-instruction <span>*</span>) *</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size=
"2">1</font></sub><b>&#160;|-&#160;</b> element {
<em>Expr</em><sub><font size="2">1</font></sub> } {
<em>Expr</em><sub><font size="2">2</font></sub> } { <span><a href=
"#doc-core-LocalNamespaceDecls"><em>LocalNamespaceDecls</em></a></span>
} <a href="#jd_has_type" class="judgment"><b>:</b></a> element
<span>*</span> of type <code>xs:anyType</code></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_construction_mode_env" class="env">constructionMode</a> =
strip</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#jd_add_namespace_bindings" class="judgment"><b>add
namespace bindings</b></a> <span><a href=
"#doc-core-LocalNamespaceDecls"><em>LocalNamespaceDecls</em></a></span>
<a href="#jd_add_namespace_bindings" class="judgment"><b>to</b></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">1</font></sub> <a href="#jd_add_namespace_bindings" class=
"judgment"><b>yields</b></a> <a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size=
"2">2</font></sub><b>&#160;|-&#160;</b><em>Expr</em><sub><font size="2">1</font></sub>
<a href="#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size=
"2">2</font></sub><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
(<code>xs:QName</code> | <code>xs:string</code> | <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size=
"2">2</font></sub><b>&#160;|-&#160;</b>
<em>Expr</em><sub><font size="2">2</font></sub> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size=
"2">2</font></sub><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
attribute <span>*</span>*, (element <span>*</span> | text | comment
| processing-instruction <span>*</span>) *</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size=
"2">1</font></sub><b>&#160;|-&#160;</b> element {
<em>Expr</em><sub><font size="2">1</font></sub> } {
<em>Expr</em><sub><font size="2">2</font></sub> } { <span><a href=
"#doc-core-LocalNamespaceDecls"><em>LocalNamespaceDecls</em></a></span>
} <a href="#jd_has_type" class="judgment"><b>:</b></a> element
<span>*</span> of type <a href=
"#dt-xs_untyped"><code>xs:untyped</code></a></td>
</tr>
</table>
<br /></div>
<p><b>Notation</b></p>
<p id="jd_with_text_nodes_processed_is">The following auxiliary
judgment is used in the dynamic semantics of node constructors.</p>
<div align="center"><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">0</font></sub> <a href="#jd_with_text_nodes_processed_is"
class="judgment"><b>with text nodes processed is</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub></div>
<p>This judgment is informally defined to hold when <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> is obtained by applying the following
modifications to <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">0</font></sub>:</p>
<ul>
<li>
<p>Adjacent text nodes in <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">0</font></sub> are merged into a single text node by
concatenating their contents, with no intervening blanks.</p>
</li>
<li>
<p>After concatenation, any text node whose content is a
zero-length string is deleted from the sequence.</p>
</li>
</ul>
<p><b><a href="#processing_dynamic" class="processing">Dynamic
Evaluation</a></b></p>
<p>The following rules take a computed element constructor
expression and construct an element node. The dynamic semantics for
computed element constructors is the most complex of all
expressions in XQuery. Here is how to read the rule below.</p>
<p><span>First, the constructor's</span> local namespace
declarations are evaluated, yielding a sequence of namespace
bindings. The static environment is extended to include the new
namespace bindings, which are all <a href=
"#term_active">active</a>. In <a href=
"http://www.w3.org/TR/xquery#id-namespaces">Section 3.7.1.2
Namespace Declaration Attributes</a><sup><small>XQ</small></sup>,
it is implementation-defined whether undeclaration of namespace
prefixes (by setting the namespace prefix to the zero-length
string) in an element constructor is supported. In the dynamic
semantics below, we assume all local namespace declarations declare
a binding of a prefix to a URI.</p>
<p>Second, the expression is evaluated, <span>and the resulting
value <a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">0</font></sub></span> <span>and its value's text nodes are
processed. The resulting sequence</span> must match zero-or-more
attributes followed by zero-or-more element, text,
processing-instruction or comment nodes.</p>
<p>Third, the namespace bindings are concatenated with the list of
active namespaces in the namespace environment <a href=
"#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env"
class="env">namespace</a> and the namespaces corresponding to the
element's name and all attributes names. The resulting sequence is
the sequence of namespace bindings for the element.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><em>Expr</em> = <em>Expr</em><sub><font size=
"2">0</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">n</font></sub>; <a href=
"#xq_dyn_env_def" class="env">dynEnv</a><b>&#160;|-&#160;</b>
<em>Expr</em><sub><font size="2">0</font></sub> <a href=
"#jd_yields" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">0</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">0</font></sub> <a href="#jd_with_text_nodes_processed_is"
class="judgment"><b>with text nodes processed is</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <span><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">0</font></sub></span> <span><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub></span> <a href="#jd_matches" class=
"judgment"><b>matches</b></a> (attribute<span>*</span>*, (element
<span>*</span> | text | processing-instruction <span>*</span> |
comment)*)</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>; <a href=
"#xq_dyn_env_def" class="env">dynEnv</a><b>&#160;|-&#160;</b>
element <em>QName</em> { <em>Expr</em> } <span>{}</span> <a href=
"#jd_yields" class="judgment"><b>=&gt;</b></a> element
<em>QName</em> of type <code>xs:anyType</code> { <span><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">0</font></sub></span> <span><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub></span> } { }</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><em>Expr</em> = <span><em>Expr</em><sub><font size=
"2">0</font></sub></span></td>
</tr>
<tr align="center" valign="middle">
<td><a href=
"#doc-core-LocalNamespaceDecls"><em>LocalNamespaceDecls</em></a> =
<a href=
"#doc-core-LocalNamespaceDecl"><em>LocalNamespaceDecl</em></a><sub><font size="2">1</font></sub>
... <a href=
"#doc-core-LocalNamespaceDecl"><em>LocalNamespaceDecl</em></a><sub><font size="2">n</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href=
"#doc-core-LocalNamespaceDecl"><em>LocalNamespaceDecl</em></a><sub><font size="2">1</font></sub>
= namespace <em>NCName</em><sub><font size="2">1</font></sub> {
<em>URILiteral</em><sub><font size="2">1</font></sub> }</td>
</tr>
<tr align="center" valign="middle">
<td>...</td>
</tr>
<tr align="center" valign="middle">
<td><a href=
"#doc-core-LocalNamespaceDecl"><em>LocalNamespaceDecl</em></a><sub><font size="2">n</font></sub>
= namespace <em>NCName</em><sub><font size="2">n</font></sub> {
<em>URILiteral</em><sub><font size="2">n</font></sub> }</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_default_dyn_env" class=
"env">dynEnvDefault</a><b>&#160;|-&#160;</b><em>URILiteral</em><sub><font size="2">1</font></sub>
<a href="#jd_has_atomic_value" class="judgment"><b>has atomic
value</b></a> <em>AnyURI</em><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td>...</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_default_dyn_env" class=
"env">dynEnvDefault</a><b>&#160;|-&#160;</b><em>URILiteral</em><sub><font size="2">n</font></sub>
<a href="#jd_has_atomic_value" class="judgment"><b>has atomic
value</b></a> <em>AnyURI</em><sub><font size=
"2">n</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href=
"#doc-fs-NamespaceBinding"><em>NamespaceBinding</em></a><sub><font size="2">1</font></sub>
= namespace <em>NCName</em><sub><font size="2">1</font></sub> {
<em>AnyURI</em><sub><font size="2">1</font></sub> }</td>
</tr>
<tr align="center" valign="middle">
<td>...</td>
</tr>
<tr align="center" valign="middle">
<td><a href=
"#doc-fs-NamespaceBinding"><em>NamespaceBinding</em></a><sub><font size="2">n</font></sub>
= namespace <em>NCName</em><sub><font size="2">n</font></sub> {
<em>AnyURI</em><sub><font size="2">n</font></sub> }</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">1</font></sub> = <a href=
"#xq_stat_env_def" class="env">statEnv</a> + <a href="#xq_ns_env"
class="env">namespace</a>(<em>NCName</em><sub><font size=
"2">1</font></sub> =&gt; (active, <em>AnyURI</em><sub><font size=
"2">1</font></sub>))</td>
</tr>
<tr align="center" valign="middle">
<td>...</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">n</font></sub> = <a href=
"#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">n-1</font></sub> + <a href="#xq_ns_env" class=
"env">namespace</a>(<em>NCName</em><sub><font size=
"2">n</font></sub> =&gt; (active, <em>AnyURI</em><sub><font size=
"2">n</font></sub>))</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">n</font></sub>; <a href=
"#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">0</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">0</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">0</font></sub> <a href="#jd_with_text_nodes_processed_is"
class="judgment"><b>with text nodes processed is</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <span><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">0</font></sub></span> <span><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub></span> <a href="#jd_matches" class=
"judgment"><b>matches</b></a> (attribute<span>*</span>*, (element
<span>*</span> | text | processing-instruction <span>*</span> |
comment)*)</td>
</tr>
<tr align="center" valign="middle">
<td><a href=
"#doc-fs-NamespaceBindings"><em>NamespaceBindings</em></a> =
<a href=
"#doc-fs-NamespaceBinding"><em>NamespaceBinding</em></a><sub><font size="2">1</font></sub>,
..., <a href=
"#doc-fs-NamespaceBinding"><em>NamespaceBinding</em></a><sub><font size="2">n</font></sub>,
<a href="#fs_activeNS">fs:<code>active_ns</code></a>(<a href=
"#xq_stat_env_def" class="env">statEnv</a>), <a href=
"#fs_ns_from_items">fs:<code>get_static_ns_from_items</code></a>(<a href="#xq_stat_env_def"
class="env">statEnv</a>, <span><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">0</font></sub></span> <span><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub></span> )</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>; <a href=
"#xq_dyn_env_def" class="env">dynEnv</a><b>&#160;|-&#160;</b>
element <em>QName</em> { <em>Expr</em> } <span>{ <a href=
"#doc-core-LocalNamespaceDecls"><em>LocalNamespaceDecls</em></a>
}</span> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a>
element <em>QName</em> of type <code>xs:anyType</code> {
<span><a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">0</font></sub></span> <span><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub></span> } { <a href=
"#doc-fs-NamespaceBindings"><em>NamespaceBindings</em></a> }</td>
</tr>
</table>
<br /></div>
<p>The dynamic evaluation of an element constructor with a computed
name is similar. There is one additional rule that checks that the
value of the element's name expression matches
<code>xs:QName</code>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">1</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">0</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">0</font></sub> <a href="#jd_matches" class=
"judgment"><b>matches</b></a> <code>xs:QName</code></td>
</tr>
<tr align="center" valign="middle">
<td><em>QName</em> = <code>fn:prefix-from-QName</code>(<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">0</font></sub>)<code>:</code><code>fn:local-name-from-QName</code>(<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">0</font></sub>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> element <em>QName</em> {
<em>Expr</em><sub><font size="2">2</font></sub> } <span>{ <a href=
"#doc-core-LocalNamespaceDecls"><em>LocalNamespaceDecls</em></a>
}</span> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a>
<a href="#doc-fs-Value"><em>Value</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> element {
<em>Expr</em><sub><font size="2">1</font></sub> } {
<em>Expr</em><sub><font size="2">2</font></sub> } <span>{ <a href=
"#doc-core-LocalNamespaceDecls"><em>LocalNamespaceDecls</em></a>
}</span> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a>
<a href="#doc-fs-Value"><em>Value</em></a></td>
</tr>
</table>
<br /></div>
</div>
<div class="div4">
<h5><a name="sec_attribute_constructor" id=
"sec_attribute_constructor"></a>4.7.3.2 Computed Attribute
Constructors</h5>
<h5><a name="d6e20489" id="d6e20489"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-CompAttrConstructor" id=
"doc-xquery10-CompAttrConstructor"></a>[<small>158&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-CompAttrConstructor">CompAttrConstructor</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"attribute" (_QName_or_EQName | ("{" <a href=
"#doc-xquery10-Expr">Expr</a> "}")) "{" <a href=
"#doc-xquery10-Expr">Expr</a>? "}"</code></td>
</tr>
</tbody>
</table>
<p><b>Core Grammar</b></p>
<p>The Core grammar production for computed attribute constructors
is:</p>
<h5><a name="d6e20508" id="d6e20508"></a>Computed Attribute
Constructors</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-CompAttrConstructor" id=
"doc-xcore-CompAttrConstructor"></a>[<small>81&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-CompAttrConstructor"></a><a href=
"#prod-xcore-CompAttrConstructor">CompAttrConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"attribute" (_QName_or_EQName | ("{" <a href=
"#doc-xcore-Expr">Expr</a> "}")) "{" <a href=
"#doc-xcore-Expr">Expr</a> "}"</code></td>
</tr>
</tbody>
</table>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>Computed attribute constructors are normalized by mapping their
name and content expression in a similar way as computed element
constructors. The normalization rule uses the <span><a href=
"#sec_item_seq_to_untypedAtomic"><em>fs:</em><code>item-sequence-to-untypedAtomic</code></a></span>
<span><a href=
"#sec_item_seq_to_string"><em>fs:</em><code>item-sequence-to-string</code></a></span>
function.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>attribute <em>QName</em> { }<font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>attribute <em>QName</em> { () }<font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>attribute <em>QName</em> { <em>Expr</em> }<font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">attribute
<em>QName</em> { <span><a href=
"#sec_item_seq_to_untypedAtomic"><em>fs:</em><code>item-sequence-to-untypedAtomic</code></a></span>
<span><a href=
"#sec_item_seq_to_string"><em>fs:</em><code>item-sequence-to-string</code></a></span>
((<font size="6">[</font><em>Expr</em><font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a>)) }</td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>attribute { <em>Expr</em><sub><font size=
"2">1</font></sub> } { <em>Expr</em><sub><font size=
"2">2</font></sub> }<font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">attribute {
<code>fn:data</code>((<font size=
"6">[</font><em>Expr</em><sub><font size=
"2">1</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>)) } {
<span><a href=
"#sec_item_seq_to_untypedAtomic"><em>fs:</em><code>item-sequence-to-untypedAtomic</code></a></span>
<span><a href=
"#sec_item_seq_to_string"><em>fs:</em><code>item-sequence-to-string</code></a></span>
((<font size="6">[</font><em>Expr</em><sub><font size=
"2">2</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>)) }</td>
</tr>
</table>
</div>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>The normalization rules for direct attribute constructors leave
us with only the computed form of the attribute constructors. Like
in a computed element constructor, a computed attribute constructor
has two forms: one in which the attribute name is a literal
<em>QName</em>, and the other in which the attribute name is a
computed expression.</p>
<p>In the case of attribute constructors, the <a href=
"http://www.w3.org/TR/xquery#dt-type-annotation">type
annotation</a><sup><small>XQ</small></sup> is always <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <em>Expr</em> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><a href="#doc-fs-Type"><em>Type</em></a>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
<span><a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a></span>
<span><code>xs:string</code></span></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> attribute <em>QName</em> {
<em>Expr</em> } <a href="#jd_has_type" class=
"judgment"><b>:</b></a> attribute <em>QName</em> of type <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
<em>Expr</em><sub><font size="2">1</font></sub> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
(<code>xs:QName</code> | <code>xs:string</code> | <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
<em>Expr</em><sub><font size="2">2</font></sub> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
<span><a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a></span>
<span><code>xs:string</code></span></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> attribute {
<em>Expr</em><sub><font size="2">1</font></sub> } {
<em>Expr</em><sub><font size="2">2</font></sub> } <a href=
"#jd_has_type" class="judgment"><b>:</b></a> attribute
<span>*</span> of type <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a></td>
</tr>
</table>
<br /></div>
<p><b><a href="#processing_dynamic" class="processing">Dynamic
Evaluation</a></b></p>
<p>The following rules take a computed attribute constructor
expression and construct an attribute node. The rules are similar
to those rules for element constructors. First, the attribute's
name is expanded into a qualified name. Second, <span>the content
expression is evaluated in the dynamic environment.</span>
<span>Recall from <a href="#sec_attribute_constructor"><b>[4.7.3.2
Computed Attribute Constructors]</b></a> that during normalization,
we do not convert the content of direct attribute constructors that
contain one attribute-content unit. This guarantees that useful
type information is preserved for static analysis. Since the
conversion function <a href=
"#sec_item_seq_to_untypedAtomic"><em>fs:</em><code>item-sequence-to-untypedAtomic</code></a>
was not applied to all attribute constructors during normalization,
we have to apply it at evaluation time. (As before, it is possible
to elide the application of <a href=
"#sec_item_seq_to_untypedAtomic"><em>fs:</em><code>item-sequence-to-untypedAtomic</code></a>
injected during normalization and the application injected during
evaluation.)</span></p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><span><em>Expr</em></span>
<a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-AtomicValue"><em>AtomicValue</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> attribute <em>QName</em> {
<em>Expr</em> } <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> attribute <em>QName</em> of type
<a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> {
<a href="#doc-fs-AtomicValue"><em>AtomicValue</em></a> }</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <em>Expr</em><sub><font size=
"2">1</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_matches" class=
"judgment"><b>matches</b></a> <code>xs:QName</code></td>
</tr>
<tr align="center" valign="middle">
<td><em>QName</em><sub><font size="2">1</font></sub> =
<code>fn:prefix-from-QName</code>(<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>)<code>:</code><code>fn:local-name-from-QName</code>(<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b>
<span><em>Expr</em><sub><font size="2">2</font></sub></span>
<a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-AtomicValue"><em>AtomicValue</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> attribute {
<em>Expr</em><sub><font size="2">1</font></sub> } {
<em>Expr</em><sub><font size="2">2</font></sub> } <a href=
"#jd_yields" class="judgment"><b>=&gt;</b></a> attribute
<em>QName</em><sub><font size="2">1</font></sub> of type <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> { <a href=
"#doc-fs-AtomicValue"><em>AtomicValue</em></a><sub><font size=
"2">2</font></sub> }</td>
</tr>
</table>
<br /></div>
</div>
<div class="div4">
<h5><a name="sec_documentConstructors" id=
"sec_documentConstructors"></a>4.7.3.3 Document Node
Constructors</h5>
<h5><a name="d6e21084" id="d6e21084"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-CompDocConstructor" id=
"doc-xquery10-CompDocConstructor"></a>[<small>155&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-CompDocConstructor">CompDocConstructor</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"document" "{" <a href="#doc-xquery10-Expr">Expr</a>
"}"</code></td>
</tr>
</tbody>
</table>
<p><b>Core Grammar</b></p>
<p>The Core grammar production for a computed document constructor
is:</p>
<h5><a name="d6e21097" id="d6e21097"></a>Core computed document
constructor</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-CompDocConstructor" id=
"doc-xcore-CompDocConstructor"></a>[<small>76&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-CompDocConstructor"></a><a href=
"#prod-xcore-CompDocConstructor">CompDocConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"document" "{" <a href="#doc-xcore-Expr">Expr</a>
"}"</code></td>
</tr>
</tbody>
</table>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>A document node constructor contains an expression, which must
evaluate to a sequence of element, text, comment, or
processing-instruction nodes. <a href=
"http://www.w3.org/TR/xquery#id-documentConstructors">Section
3.7.3.3 Document Node Constructors</a><sup><small>XQ</small></sup>
specifies the rules for converting a sequence of atomic values and
nodes into a sequence of nodes before document construction. The
built-in function <span><a href="#sec_items_to_nodes_doc"><b>[7.1.6
The fs:item-sequence-to-node-sequence-doc function]</b></a></span>
<span><a href=
"#sec_items_to_nodes"><em>fs:</em><code>item-sequence-to-node-sequence</code></a></span>
implements <span>most of</span> this conversion.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>document { <em>Expr</em> }<font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">document {
<span><a href=
"#sec_items_to_nodes"><em>fs:</em><code>item-sequence-to-node-sequence-doc</code></a></span>
<span><a href=
"#sec_items_to_nodes"><em>fs:</em><code>item-sequence-to-node-sequence</code></a></span>
((<font size="6">[</font><em>Expr</em><font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a>)) }</td>
</tr>
</table>
</div>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p><span>The static typing rule does not need to check that the
type of the argument expression is a sequence of element, text,
processing-instruction, and comment nodes, as it is already checked
by the <a href=
"#sec_items_to_nodes"><em>fs:</em><code>item-sequence-to-node-sequence-doc</code></a>
introduced during normalization.</span> The type of the entire
expression is the most general <code>document</code> type, because
the document constructor erases all <a href=
"http://www.w3.org/TR/xquery#dt-type-annotation">type
annotation</a><sup><small>XQ</small></sup> on its content
nodes.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <em>Expr</em> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a> <a href="#jd_subtype_of" class=
"judgment"><b>&lt;:</b></a>
(element*|text|processing-instruction*|comment)*</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> document { <em>Expr</em> }
<a href="#jd_has_type" class="judgment"><b>:</b></a> document {
<a href="#doc-fs-Type"><em>Type</em></a> }</td>
</tr>
</table>
<br /></div>
<p><b><a href="#processing_dynamic" class="processing">Dynamic
Evaluation</a></b></p>
<p>The dynamic semantics checks that the argument expression
evaluates to a value that is a sequence of element, text,
processing-instruction, or comment nodes. The entire expression
evaluates to a new document node value. If the construction mode is
set to <code>strip</code>, the <a href=
"http://www.w3.org/TR/xquery#dt-type-annotation">type
annotation</a><sup><small>XQ</small></sup> for all the nodes in
content of a document node are erased.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_construction_mode_env" class="env">constructionMode</a> =
preserve</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <em>Expr</em> <a href=
"#jd_yields" class="judgment"><b>=&gt;</b></a> <span><a href=
"#doc-fs-Value"><em>Value</em></a></span> <span><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub></span></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_with_text_nodes_processed_is"
class="judgment"><b>with text nodes processed is</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <span><a href=
"#doc-fs-Value"><em>Value</em></a></span> <span><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></span> <a href="#jd_matches" class=
"judgment"><b>matches</b></a> (element <span>*</span> | text |
processing-instruction <span>*</span> | comment)*</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> document { <em>Expr</em> }
<a href="#jd_yields" class="judgment"><b>=&gt;</b></a> document {
<span><a href="#doc-fs-Value"><em>Value</em></a></span>
<span><a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></span> }</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_construction_mode_env" class="env">constructionMode</a> =
strip</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <em>Expr</em> <a href=
"#jd_yields" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_erases_to" class=
"judgment"><b>erases to</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_with_text_nodes_processed_is"
class="judgment"><b>with text nodes processed is</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">3</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <span><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></span> <span><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">3</font></sub></span> <a href="#jd_matches" class=
"judgment"><b>matches</b></a> (element <span>*</span> | text |
processing-instruction <span>*</span> | comment)*</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> document { <em>Expr</em> }
<a href="#jd_yields" class="judgment"><b>=&gt;</b></a> document {
<span><a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></span> <span><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">3</font></sub></span> }</td>
</tr>
</table>
<br /></div>
</div>
<div class="div4">
<h5><a name="sec_textConstructors" id=
"sec_textConstructors"></a>4.7.3.4 Text Node Constructors</h5>
<h5><a name="d6e21483" id="d6e21483"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-CompTextConstructor" id=
"doc-xquery10-CompTextConstructor"></a>[<small>163&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-CompTextConstructor">CompTextConstructor</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"text" "{" <a href="#doc-xquery10-Expr">Expr</a>
"}"</code></td>
</tr>
</tbody>
</table>
<p><b>Core Grammar</b></p>
<p>The Core grammar production for a computed text constructor
is:</p>
<h5><a name="d6e21496" id="d6e21496"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-CompTextConstructor" id=
"doc-xcore-CompTextConstructor"></a>[<small>82&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-CompTextConstructor"></a><a href=
"#prod-xcore-CompTextConstructor">CompTextConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"text" "{" <a href="#doc-xcore-Expr">Expr</a>
"}"</code></td>
</tr>
</tbody>
</table>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>A text node constructor contains an expression, which must
evaluate to an <code>xs:string</code> value. <a href=
"http://www.w3.org/TR/xquery#id-textConstructors">Section 3.7.3.4
Text Node Constructors</a><sup><small>XQ</small></sup> specifies
the rules for converting a sequence of atomic values into a string
prior to construction of a text node. Each node is replaced by its
string value. For each adjacent sequence of one or more atomic
values returned by an enclosed expression, a untyped atomic value
is constructed, containing the canonical lexical representation of
all the atomic values, with a single blank character inserted
between adjacent values. As formal specification of these
conversion rules is not instructive, <span><a href=
"#sec_item_seq_to_untypedAtomic">[<b>Missing Reference :&#160;
sec_item_seq_to_untypedAtomic</b>]</a></span> <span>the <a href=
"#sec_item_seq_to_untypedAtomic_text"><em>fs:</em><code>item-sequence-to-untypedAtomic-text</code></a>
function</span> implements this conversion.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>text { <em>Expr</em> }<font size="6">]</font><a href=
"#jd_map_expr" class="judgment"><sub><font size=
"2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">text { (<a href=
"#sec_item_seq_to_untypedAtomic_text"><em>fs:</em><code>item-sequence-to-untypedAtomic-text</code></a>(<code>fn:data</code>((<font size="6">[</font><em>Expr</em><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>)))) cast
as <code>xs:string</code>? }</td>
</tr>
</table>
</div>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>The static semantics checks that the argument expression has
type <code>xs:string</code> or <code>empty</code>. The type of the
entire expression is an optional text node type, as the text node
constructor returns the empty sequence if its argument is the empty
sequence.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <em>Expr</em> <a href=
"#jd_has_type" class="judgment"><b>:</b></a>
<code>xs:string</code>?</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> text { <em>Expr</em> }
<a href="#jd_has_type" class="judgment"><b>:</b></a> text?</td>
</tr>
</table>
<br /></div>
<p><b><a href="#processing_dynamic" class="processing">Dynamic
Evaluation</a></b></p>
<p>If the argument expression returns the empty sequence, the text
node constructor returns the empty sequence.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <em>Expr</em> <a href=
"#jd_yields" class="judgment"><b>=&gt;</b></a> <code>()</code></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> text { <em>Expr</em> }
<a href="#jd_yields" class="judgment"><b>=&gt;</b></a>
<code>()</code></td>
</tr>
</table>
<br /></div>
<p>If the argument expression returns a value of type
<code>xs:string</code>, the text node constructor returns a text
node with that string as content.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <em>Expr</em> <a href=
"#jd_yields" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a> &#160;&#160;&#160;&#160;<a href=
"#xq_stat_env_def" class="env">statEnv</a><b>&#160;|-&#160;</b>
<a href="#doc-fs-Value"><em>Value</em></a> <a href="#jd_matches"
class="judgment"><b>matches</b></a> <code>xs:string</code></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> text { <em>Expr</em> }
<a href="#jd_yields" class="judgment"><b>=&gt;</b></a> text {
<a href="#doc-fs-Value"><em>Value</em></a> }</td>
</tr>
</table>
<br /></div>
</div>
<div class="div4">
<h5><a name="sec_computed-pis" id="sec_computed-pis"></a>4.7.3.5
Computed Processing Instruction Constructors</h5>
<h5><a name="d6e21707" id="d6e21707"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-CompPIConstructor" id=
"doc-xquery10-CompPIConstructor"></a>[<small>165&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-CompPIConstructor">CompPIConstructor</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"processing-instruction" (<a href=
"#prod-xquery10-NCName">NCName</a> | ("{" <a href=
"#doc-xquery10-Expr">Expr</a> "}")) "{" <a href=
"#doc-xquery10-Expr">Expr</a>? "}"</code></td>
</tr>
</tbody>
</table>
<p><b>Core Grammar</b></p>
<p>The Core grammar production for computed processing-instruction
constructors is:</p>
<h5><a name="d6e21726" id="d6e21726"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-CompPIConstructor" id=
"doc-xcore-CompPIConstructor"></a>[<small>84&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-CompPIConstructor"></a><a href=
"#prod-xcore-CompPIConstructor">CompPIConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"processing-instruction" (<a href=
"#prod-xcore-NCName">NCName</a> | ("{" <a href=
"#doc-xcore-Expr">Expr</a> "}")) "{" <a href=
"#doc-xcore-Expr">Expr</a>? "}"</code></td>
</tr>
</tbody>
</table>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>Computed processing-instruction constructors are normalized by
mapping their name and content expression in the same way that
computed element and attribute constructors are normalized.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>processing-instruction <em>NCName</em> { }<font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>processing-instruction <em>NCName</em> { ()
}<font size="6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>processing-instruction <em>NCName</em> { <em>Expr</em>
}<font size="6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">processing-instruction
<em>NCName</em> { <a href=
"#sec_item_seq_to_untypedAtomic_PI"><em>fs:</em><code>item-sequence-to-untypedAtomic-PI</code></a>((<font size="6">[</font><em>Expr</em><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>)) }</td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>processing-instruction { <em>Expr</em><sub><font size=
"2">1</font></sub> } { <em>Expr</em><sub><font size=
"2">2</font></sub> }<font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">processing-instruction
{ <code>fn:data</code>((<font size=
"6">[</font><em>Expr</em><sub><font size=
"2">1</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>)) } {
<a href=
"#sec_item_seq_to_untypedAtomic_PI"><em>fs:</em><code>item-sequence-to-untypedAtomic-PI</code></a>((<font size="6">[</font><em>Expr</em><sub><font size="2">2</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>)) }</td>
</tr>
</table>
</div>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>The static typing rules for processing-instruction constructors
are straightforward.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <em>Expr</em> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> processing-instruction
<em>NCName</em> { <em>Expr</em> } <a href="#jd_has_type" class=
"judgment"><b>:</b></a> processing-instruction
<span><em>NCName</em></span></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
<em>Expr</em><sub><font size="2">1</font></sub> <a href=
"#jd_has_type" class="judgment"><b>:</b></a>
(<code>xs:NCName</code> | <code>xs:string</code> | <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>)
&#160;&#160;&#160;&#160;<a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
<em>Expr</em><sub><font size="2">2</font></sub> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> processing-instruction {
<em>Expr</em><sub><font size="2">1</font></sub> } {
<em>Expr</em><sub><font size="2">2</font></sub> } <a href=
"#jd_has_type" class="judgment"><b>:</b></a> processing-instruction
<span>*</span></td>
</tr>
</table>
<br /></div>
<p><b><a href="#processing_dynamic" class="processing">Dynamic
Evaluation</a></b></p>
<p>The dynamic evaluation rules for computed
processing-instructions are straightforward.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <em>Expr</em> <a href=
"#jd_yields" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a> &#160;&#160;&#160;&#160;<a href=
"#xq_stat_env_def" class="env">statEnv</a><b>&#160;|-&#160;</b>
<a href="#doc-fs-Value"><em>Value</em></a> <a href="#jd_matches"
class="judgment"><b>matches</b></a> <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> processing-instruction
<em>NCName</em> { <em>Expr</em> } <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> processing-instruction <em>NCName</em>
{ <a href="#doc-fs-Value"><em>Value</em></a> }</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <em>Expr</em><sub><font size=
"2">1</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_matches" class=
"judgment"><b>matches</b></a> (<code>xs:NCName</code> | <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> |
<code>xs:string</code>)</td>
</tr>
<tr align="center" valign="middle">
<td><code>xs:NCName</code>(<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>) = <em>NCName</em><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub> &#160;&#160;&#160;&#160;<a href=
"#xq_stat_env_def" class="env">statEnv</a><b>&#160;|-&#160;</b>
<a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_matches" class=
"judgment"><b>matches</b></a> <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> processing-instruction {
<em>Expr</em><sub><font size="2">1</font></sub> } {
<em>Expr</em><sub><font size="2">2</font></sub> } <a href=
"#jd_yields" class="judgment"><b>=&gt;</b></a>
processing-instruction <em>NCName</em><sub><font size=
"2">1</font></sub> { <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub> }</td>
</tr>
</table>
<br /></div>
</div>
<div class="div4">
<h5><a name="sec_computed-comments" id=
"sec_computed-comments"></a>4.7.3.6 Computed Comment
Constructors</h5>
<h5><a name="d6e22184" id="d6e22184"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-CompCommentConstructor" id=
"doc-xquery10-CompCommentConstructor"></a>[<small>164&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-CompCommentConstructor">CompCommentConstructor</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"comment" "{" <a href="#doc-xquery10-Expr">Expr</a>
"}"</code></td>
</tr>
</tbody>
</table>
<p><b>Core Grammar</b></p>
<p>The Core grammar production for computed comment constructors
is:</p>
<h5><a name="d6e22197" id="d6e22197"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-CompCommentConstructor" id=
"doc-xcore-CompCommentConstructor"></a>[<small>83&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-CompCommentConstructor"></a><a href=
"#prod-xcore-CompCommentConstructor">CompCommentConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"comment" "{" <a href="#doc-xcore-Expr">Expr</a>
"}"</code></td>
</tr>
</tbody>
</table>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>Computed comment constructors are normalized by mapping their
content expression.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>comment { <em>Expr</em> }<font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">comment { (<a href=
"#sec_item_seq_to_untypedAtomic_comment"><em>fs:</em><code>item-sequence-to-untypedAtomic-comment</code></a>((<font size="6">[</font><em>Expr</em><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>))) cast
as <code>xs:string</code> }</td>
</tr>
</table>
</div>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>The static typing rule for computed comment constructors is
straightforward.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <em>Expr</em> <a href=
"#jd_has_type" class="judgment"><b>:</b></a>
<code>xs:string</code></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> comment { <em>Expr</em> }
<a href="#jd_has_type" class="judgment"><b>:</b></a> comment</td>
</tr>
</table>
<br /></div>
<p><b><a href="#processing_dynamic" class="processing">Dynamic
Evaluation</a></b></p>
<p>The dynamic evaluation rule for computed comment constructors is
straightforward.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <em>Expr</em> <a href=
"#jd_yields" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a> &#160;&#160;&#160;&#160;<a href=
"#xq_stat_env_def" class="env">statEnv</a><b>&#160;|-&#160;</b>
<a href="#doc-fs-Value"><em>Value</em></a> <a href="#jd_matches"
class="judgment"><b>matches</b></a> <code>xs:string</code></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> comment { <em>Expr</em> }
<a href="#jd_yields" class="judgment"><b>=&gt;</b></a> comment {
<a href="#doc-fs-Value"><em>Value</em></a> }</td>
</tr>
</table>
<br /></div>
</div>
</div>
<div class="div3">
<h4><a name="id-ns-nodes-on-elements" id=
"id-ns-nodes-on-elements"></a>4.7.4 In-scope Namespaces of a
Constructed Element</h4>
<p>The effect of in-scope namespaces on constructed elements is
specified in <a href="#id_element_constructor"><b>[4.7.1 Direct
Element Constructors]</b></a> and <a href=
"#sec_comp_elem_constructor"><b>[4.7.3.1 Computed Element
Constructors]</b></a>.</p>
</div>
</div>
<div class="div2">
<h3><a name="sec_for-expressions" id="sec_for-expressions"></a>4.8
[For/FLWOR] Expressions</h3>
<p><b>Introduction</b></p>
<p>[XPath/XQuery] provides [For/FLWOR] expressions for iteration,
for binding variables to intermediate results, and filtering bound
variables according to a predicate.</p>
<p>A <em>FLWORExpr</em> in XQuery 1.0 consists of a sequence of
<em>ForClause</em>s and <em>LetClause</em>s, followed by an
optional <em>WhereClause</em>, followed by an optional
<em>OrderByClause</em>, as described by the following grammar
productions. Each variable binding is preceded by an optional type
declaration which specify the type expected for the variable.</p>
<p>The dynamic semantics of the ordering mode in FLWOR expressions
is not specified formally, as it would require the introduction of
tuples, which are not supported in the [XPath/XQuery] data
model.</p>
<h5><a name="d6e22371" id="d6e22371"></a>[For/FLWOR]
Expressions</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-ForClause" id=
"doc-xquery10-ForClause"></a>[<small>45&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-ForClause">ForClause</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"for" ForBinding ForBinding ("," ForBinding
ForBinding)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-LetClause" id=
"doc-xquery10-LetClause"></a>[<small>49&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-LetClause">LetClause</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"let" LetBinding LetBinding ("," LetBinding
LetBinding)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-TypeDeclaration" id=
"doc-xquery10-TypeDeclaration"></a>[<small>170&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-TypeDeclaration">TypeDeclaration</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"as" <a href=
"#doc-xquery10-SequenceType">SequenceType</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-PositionalVar" id=
"doc-xquery10-PositionalVar"></a>[<small>48&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-PositionalVar">PositionalVar</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"at" "$" <a href=
"#doc-xquery10-VarName">VarName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-WhereClause" id=
"doc-xquery10-WhereClause"></a>[<small>61&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-WhereClause">WhereClause</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"where" <a href=
"#doc-xquery10-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-OrderByClause" id=
"doc-xquery10-OrderByClause"></a>[<small>65&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-OrderByClause">OrderByClause</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(("order" "by") | ("stable" "order" "by")) <a href=
"#doc-xquery10-OrderSpecList">OrderSpecList</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-OrderSpecList" id=
"doc-xquery10-OrderSpecList"></a>[<small>66&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-OrderSpecList">OrderSpecList</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery10-OrderSpec">OrderSpec</a> (","
<a href="#doc-xquery10-OrderSpec">OrderSpec</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-OrderSpec" id=
"doc-xquery10-OrderSpec"></a>[<small>67&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-OrderSpec">OrderSpec</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery10-ExprSingle">ExprSingle</a>
<a href="#doc-xquery10-OrderModifier">OrderModifier</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-OrderModifier" id=
"doc-xquery10-OrderModifier"></a>[<small>68&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-OrderModifier">OrderModifier</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("ascending" | "descending")? ("empty" ("greatest" |
"least"))? ("collation" <a href=
"#doc-xquery10-URILiteral">URILiteral</a>)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath20-ForExpr" id=
"doc-xpath20-ForExpr"></a>[<small>8&#160;(XPath)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xpath20/#prod-xpath-ForExpr">ForExpr</a><sup><small>XP</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath20-SimpleForClause">SimpleForClause</a> "return"
ExprSingle</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath20-SimpleForClause" id=
"doc-xpath20-SimpleForClause"></a>[<small>9&#160;(XPath)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xpath20/#prod-xpath-SimpleForClause">SimpleForClause</a><sup><small>XP</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"for" SimpleForBinding SimpleForBinding (","
SimpleForBinding SimpleForBinding)*</code></td>
</tr>
</tbody>
</table>
<p><b>Core Grammar</b></p>
<p>The Core grammar productions for FLWOR expressions are:</p>
<h5><a name="d6e22493" id="d6e22493"></a>For Expressions</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-ForClause" id=
"doc-xcore-ForClause"></a>[<small>25&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-ForClause"></a><a href=
"#prod-xcore-ForClause">ForClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"for" ForBinding</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-LetClause" id=
"doc-xcore-LetClause"></a>[<small>27&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-LetClause"></a><a href=
"#prod-xcore-LetClause">LetClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"let" LetBinding</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-PositionalVar" id=
"doc-xcore-PositionalVar"></a>[<small>26&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-PositionalVar"></a><a href=
"#prod-xcore-PositionalVar">PositionalVar</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"at" "$" <a href=
"#doc-xcore-VarName">VarName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-TypeDeclaration" id=
"doc-xcore-TypeDeclaration"></a>[<small>86&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-TypeDeclaration"></a><a href=
"#prod-xcore-TypeDeclaration">TypeDeclaration</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"as" <a href=
"#doc-xcore-SequenceType">SequenceType</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-OrderByClause" id=
"doc-xcore-OrderByClause"></a>[<small>28&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-OrderByClause"></a><a href=
"#prod-xcore-OrderByClause">OrderByClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(("order" "by") | ("stable" "order" "by")) <a href=
"#doc-xcore-OrderSpecList">OrderSpecList</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-OrderSpecList" id=
"doc-xcore-OrderSpecList"></a>[<small>29&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-OrderSpecList"></a><a href=
"#prod-xcore-OrderSpecList">OrderSpecList</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-OrderSpec">OrderSpec</a> (","
<a href="#doc-xcore-OrderSpec">OrderSpec</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-OrderSpec" id=
"doc-xcore-OrderSpec"></a>[<small>30&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-OrderSpec"></a><a href=
"#prod-xcore-OrderSpec">OrderSpec</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-ExprSingle">ExprSingle</a> <a href=
"#doc-xcore-OrderModifier">OrderModifier</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-OrderModifier" id=
"doc-xcore-OrderModifier"></a>[<small>31&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-OrderModifier"></a><a href=
"#prod-xcore-OrderModifier">OrderModifier</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("ascending" | "descending")? ("empty" ("greatest" |
"least"))? ("collation" <a href=
"#doc-xcore-URILiteral">URILiteral</a>)?</code></td>
</tr>
</tbody>
</table>
<div class="div3">
<h4><a name="sec_flwor-expressions" id=
"sec_flwor-expressions"></a>4.8.1 FLWOR expressions</h4>
<p><b>Notation</b></p>
<p>For convenience, we introduce the following auxiliary grammar
productions to represent optional type declarations and positional
variables in For and Let clauses.</p>
<h5><a name="d6e22564" id="d6e22564"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-OptTypeDeclaration" id=
"doc-fs-OptTypeDeclaration"></a>[<small>79&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-OptTypeDeclaration">OptTypeDeclaration</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>TypeDeclaration?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-OptPositionalVar" id=
"doc-fs-OptPositionalVar"></a>[<small>80&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-OptPositionalVar">OptPositionalVar</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>PositionalVar?</code></td>
</tr>
</tbody>
</table>
<p><b>Notation</b></p>
<p>To facilitate the specification of normalization, we also
introduce the following auxiliary grammar productions as an
alternative grammar for FLWOR expressions.</p>
<h5><a name="d6e22583" id="d6e22583"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-FormalFLWORClause" id=
"doc-fs-FormalFLWORClause"></a>[<small>65&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-FormalFLWORClause">FormalFLWORClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>ForClause | LetClause | WhereClause |
OrderByClause</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-FormalReturnClause" id=
"doc-fs-FormalReturnClause"></a>[<small>66&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-FormalReturnClause">FormalReturnClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-FormalFLWORExpr">FormalFLWORExpr</a> |
("return" Expr)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-FormalFLWORExpr" id=
"doc-fs-FormalFLWORExpr"></a>[<small>67&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-FormalFLWORExpr">FormalFLWORExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-FormalFLWORClause">FormalFLWORClause</a>
<a href=
"#doc-fs-FormalReturnClause">FormalReturnClause</a></code></td>
</tr>
</tbody>
</table>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>Full FLWOR expressions are normalized to nested Core FLWOR
expressions with a single for or let clause. Note that some of the
normalization rules below accept ungrammatical FLWOR expressions
such as "where <em>Expr</em><sub><font size="2">1</font></sub>
return <em>Expr</em><sub><font size="2">2</font></sub>". This does
not matter, as normalization is always applied on parsed
[XPath/XQuery] expressions, and such ungrammatical FLWOR
expressions would be rejected by the parser beforehand.</p>
<p>Normalized FLWOR expressions restrict a For and Let clause to
bind only one variable. Otherwise, the Core FLWOR expression is the
same as the XQuery FLWOR expression. The first normalization rule
is applied on a full [For/FLWOR] expression, splitting it at the
clause level, then applying further normalization on each separate
clause.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>
<table summary="">
<tbody>
<tr>
<td>for $<em>VarName</em><sub><font size="2">1</font></sub>
<em>OptTypeDeclaration</em><sub><font size="2">1</font></sub>
<em>OptPositionalVar</em><sub><font size="2">1</font></sub> in
<em>Expr</em><sub><font size="2">1</font></sub>,</td>
</tr>
<tr>
<td>···,</td>
</tr>
<tr>
<td>$<em>VarName</em><sub><font size="2">n</font></sub>
<em>OptTypeDeclaration</em><sub><font size="2">n</font></sub>
<em>OptPositionalVar</em><sub><font size="2">n</font></sub> in
<em>Expr</em><sub><font size="2">n</font></sub></td>
</tr>
<tr>
<td><em>FormalReturnClause</em></td>
</tr>
</tbody>
</table>
<font size="6">]</font> <a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<table summary="">
<tbody>
<tr>
<td>for $<em>VarName</em><sub><font size="2">1</font></sub>
<em>OptTypeDeclaration</em><sub><font size="2">1</font></sub>
<em>OptPositionalVar</em><sub><font size="2">1</font></sub> in
<font size="6">[</font><em>Expr</em><sub><font size=
"2">1</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>
return</td>
</tr>
<tr>
<td>&#160;&#160;···</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160; for $<em>VarName</em><sub><font size=
"2">n</font></sub> <em>OptTypeDeclaration</em><sub><font size=
"2">n</font></sub> <em>OptPositionalVar</em><sub><font size=
"2">n</font></sub> in <font size="6">[</font>
<em>Expr</em><sub><font size="2">n</font></sub> <font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a> return</td>
</tr>
<tr>
<td><font size="6">[</font><em>FormalReturnClause</em><font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
</tbody>
</table>
</td>
</tr>
</table>
</div>
<p>Likewise, a <em>LetClause</em> clause is normalized to nested
let expressions, each of which binds one variable:</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>
<table summary="">
<tbody>
<tr>
<td>let $<em>VarName</em><sub><font size="2">1</font></sub>
<em>OptTypeDeclaration</em><sub><font size="2">1</font></sub> :=
<em>Expr</em><sub><font size="2">1</font></sub>,</td>
</tr>
<tr>
<td>···,</td>
</tr>
<tr>
<td>$<em>VarName</em><sub><font size="2">n</font></sub>
<em>OptTypeDeclaration</em><sub><font size="2">n</font></sub> :=
<em>Expr</em><sub><font size="2">n</font></sub></td>
</tr>
<tr>
<td><em>FormalReturnClause</em></td>
</tr>
</tbody>
</table>
<font size="6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<table summary="">
<tbody>
<tr>
<td>let $<em>VarName</em><sub><font size="2">1</font></sub>
<em>OptTypeDeclaration</em><sub><font size="2">1</font></sub> :=
<font size="6">[</font><em>Expr</em><sub><font size=
"2">1</font></sub> <font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>
return</td>
</tr>
<tr>
<td>&#160;&#160;···</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;let $<em>VarName</em><sub><font size=
"2">n</font></sub> <em>OptTypeDeclaration</em><sub><font size=
"2">n</font></sub> := <font size=
"6">[</font><em>Expr</em><sub><font size=
"2">n</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>
return</td>
</tr>
<tr>
<td><font size="6">[</font><em>FormalReturnClause</em><font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
</tbody>
</table>
</td>
</tr>
</table>
</div>
<p>A <em>WhereClause</em> is normalized to an <em>IfExpr</em>, with
the else-branch returning the empty sequence:</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font> where <em>Expr</em><sub><font size="2">1</font></sub>
<em>FormalReturnClause</em><font size="6">]</font><a href=
"#jd_map_expr" class="judgment"><sub><font size=
"2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">if (
<span>fn:boolean(( <font size=
"6">[</font><em>Expr</em><sub><font size=
"2">1</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>
))</span> ) then <font size=
"6">[</font><em>FormalReturnClause</em><font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a> else ()</td>
</tr>
</table>
</div>
<p>The order by clause is normalized using the auxiliary mapping
rule <font size="6">[</font><font size="6">]</font><a href=
"#jd_map_orderspeclist" class="judgment"><sub><font size=
"2">OrderSpecList</font></sub></a> which is defined in <a href=
"#id_orderby_clause"><b>[4.8.4 Order By and Return
Clauses]</b></a>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font> stable? order by <em>OrderSpecList</em>
<em>FormalReturnClause</em><font size="6">]</font><a href=
"#jd_map_expr" class="judgment"><sub><font size=
"2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>OrderSpecList</em><font size="6">]</font><a href=
"#jd_map_orderspeclist" class="judgment"><sub><font size=
"2">OrderSpecList</font></sub></a> return <font size=
"6">[</font><em>FormalReturnClause</em><font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
</table>
</div>
<p>Finally, a stand-alone return clause is normalized into the
corresponding expression. Recall that <code>return</code> keywords
are introduced in the previous rule after the normalization of each
clause.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font> return <em>Expr</em> <font size="6">]</font><a href=
"#jd_map_expr" class="judgment"><sub><font size=
"2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font> <em>Expr</em> <font size="6">]</font><a href=
"#jd_map_expr" class="judgment"><sub><font size=
"2">Expr</font></sub></a></td>
</tr>
</table>
</div>
<p><b>Example</b></p>
<p>The following simple example illustrates how a
<em>FLWORExpr</em> is normalized. The <code>for</code> expression
in the example below is used to iterate over two collections,
binding variables <code>$i</code> and <code>$j</code> to items in
these collections. It uses a <code>let</code> clause to bind the
local variable <code>$k</code> to the sum of both numbers, and a
<code>where</code> clause to select only those numbers that have a
sum equal to or greater than the integer <code>5</code>.</p>
<div class="exampleInner">
<pre>
  for $i as xs:integer in (1, 2),
      $j in (3, 4)
  let $k := $i + $j
  where $k &gt;= 5
  return
    &lt;tuple&gt;
       &lt;i&gt; { $i } &lt;/i&gt;
       &lt;j&gt; { $j } &lt;/j&gt;
    &lt;/tuple&gt;
</pre></div>
<p>By the first set of rules, this is normalized to (except for the
operators and element constructor which are not treated here):</p>
<div class="exampleInner">
<pre>
  for $i as xs:integer in (1, 2) return
    for $j in (3, 4) return
      let $k := $i + $j return
        if ($k &gt;= 5) then 
          &lt;tuple&gt;
            &lt;i&gt; { $i } &lt;/i&gt;
            &lt;j&gt; { $j } &lt;/j&gt;
          &lt;/tuple&gt;
        else
          ()
</pre></div>
<p>For each binding of <code>$i</code> to an item in the sequence
<code>(1 , 2)</code> the inner <code>for</code> expression iterates
over the sequence <code>(3 , 4)</code> to produce tuples ordered by
the ordering of the outer sequence and then by the ordering of the
inner sequence. This Core expression eventually results in the
following document fragment:</p>
<div class="exampleInner">
<pre>
  (&lt;tuple&gt;
      &lt;i&gt;1&lt;/i&gt;
      &lt;j&gt;4&lt;/j&gt;
   &lt;/tuple&gt;,
   &lt;tuple&gt;
      &lt;i&gt;2&lt;/i&gt;
      &lt;j&gt;3&lt;/j&gt;
   &lt;/tuple&gt;,
   &lt;tuple&gt;
      &lt;i&gt;2&lt;/i&gt;
      &lt;j&gt;4&lt;/j&gt;
   &lt;/tuple&gt;)
</pre></div>
</div>
<div class="div3">
<h4><a name="id-for-expression" id="id-for-expression"></a>4.8.2
For expression</h4>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>A single <code>for</code> expression is typed as follows: First
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub> of the iteration expression
<em>Expr</em><sub><font size="2">1</font></sub> is inferred. Then
the <a title="prime type" href="#term-prime-type">prime type</a> of
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>, <a href="#jd_prime" class=
"judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>), is computed. This is a union over all item
types in <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub> (See <a href="#sec_factor"><b>[8.4 Judgments for
FLWOR and other expressions on sequences]</b></a>). With the
variable component of the static environment <a href=
"#xq_stat_env_def" class="env">statEnv</a> extended with
$<em>VarName</em><sub><font size="2">1</font></sub> as type
<a href="#jd_prime" class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>), the type <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
of <em>Expr</em><sub><font size="2">2</font></sub> is inferred.
Because the <code>for</code> expression iterates over the result of
<em>Expr</em><sub><font size="2">1</font></sub>, the final type of
the iteration is <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
multiplied with the possible number of items in <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
(one, <code>?</code>, <code>*</code>, or <code>+</code>). This
number is determined by the auxiliary type-function <a href=
"#jd_quantifier" class="judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>). Operations between quantifiers and types, such
as <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_quantifier" class="judgment">·</a>
<a href="#jd_quantifier" class="judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>), used in the following rule, are defined in
<a href="#sec_factor"><b>[8.4 Judgments for FLWOR and other
expressions on sequences]</b></a>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">1</font></sub> <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>VarName</em><sub><font size="2">1</font></sub>
<a href="#jd_var_qname_expands_to" class="judgment"><b>of var
expands to</b></a> <em>Variable</em><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a> + <a href=
"#xq_type_env" class=
"env">varType</a>(<em>Variable</em><sub><font size=
"2">1</font></sub> =&gt; <a href="#jd_prime" class=
"judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>)) <b>&#160;|-&#160;</b>
<em>Expr</em><sub><font size="2">2</font></sub> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>for
$<em>VarName</em><sub><font size="2">1</font></sub> in
<em>Expr</em><sub><font size="2">1</font></sub> return
<em>Expr</em><sub><font size="2">2</font></sub> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_quantifier" class="judgment">·</a> <a href=
"#jd_quantifier" class="judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>)</td>
</tr>
</table>
<br /></div>
<p>When a positional variable <em>Variable</em><sub><font size=
"2">pos</font></sub> is present, the static environment is also
extended with the positional variable typed as an
<code>xs:integer</code>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">1</font></sub> <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>VarName</em><sub><font size="2">1</font></sub>
<a href="#jd_var_qname_expands_to" class="judgment"><b>of var
expands to</b></a> <em>Variable</em><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>VarName</em><sub><font size="2">pos</font></sub>
<a href="#jd_var_qname_expands_to" class="judgment"><b>of var
expands to</b></a> <em>Variable</em><sub><font size=
"2">pos</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a> + <a href=
"#xq_type_env" class=
"env">varType</a>(<em>Variable</em><sub><font size=
"2">1</font></sub> =&gt; <a href="#jd_prime" class=
"judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>);<em>Variable</em><sub><font size=
"2">pos</font></sub> =&gt; <code>xs:integer</code>)
<b>&#160;|-&#160;</b> <em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>for
$<em>VarName</em><sub><font size="2">1</font></sub> at
$<em>VarName</em><sub><font size="2">pos</font></sub> in
<em>Expr</em><sub><font size="2">1</font></sub> return
<em>Expr</em><sub><font size="2">2</font></sub> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_quantifier" class="judgment">·</a> <a href=
"#jd_quantifier" class="judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>)</td>
</tr>
</table>
<br /></div>
<p>When a type declaration is present, the static semantics also
checks that the type of the input expression is a subtype of the
declared type and extends the static environment by typing
$<em>VarName</em><sub><font size="2">1</font></sub> with type
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub>. This semantics is specified by the following
static typing rule.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">1</font></sub> <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub> = <font size="6">[</font> <em>SequenceType</em>
<font size="6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><a href="#jd_prime" class=
"judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>VarName</em><sub><font size="2">1</font></sub>
<a href="#jd_var_qname_expands_to" class="judgment"><b>of var
expands to</b></a> <em>Variable</em><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a> + <a href=
"#xq_type_env" class=
"env">varType</a>(<em>Variable</em><sub><font size=
"2">1</font></sub> =&gt; <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>)
<b>&#160;|-&#160;</b> <em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>for
$<em>VarName</em><sub><font size="2">1</font></sub> as
<em>SequenceType</em> in <em>Expr</em><sub><font size=
"2">1</font></sub> return <em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_quantifier" class="judgment">·</a> <a href=
"#jd_quantifier" class="judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>)</td>
</tr>
</table>
<br /></div>
<p>The last rule handles For expressions that contain a type
declaration and a positional variable. When the positional variable
is present, the static environment is also extended with the
positional variable typed as an integer.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">1</font></sub> <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub> = <font size="6">[</font> <em>SequenceType</em>
<font size="6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><a href="#jd_prime" class=
"judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>VarName</em><sub><font size="2">1</font></sub>
<a href="#jd_var_qname_expands_to" class="judgment"><b>of var
expands to</b></a> <em>Variable</em><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>VarName</em><sub><font size="2">pos</font></sub>
<a href="#jd_var_qname_expands_to" class="judgment"><b>of var
expands to</b></a> <em>Variable</em><sub><font size=
"2">pos</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a> + <a href=
"#xq_type_env" class=
"env">varType</a>(<em>Variable</em><sub><font size=
"2">1</font></sub> =&gt; <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>;
<em>Variable</em><sub><font size="2">pos</font></sub> =&gt;
<code>xs:integer</code>) <b>&#160;|-&#160;</b>
<em>Expr</em><sub><font size="2">2</font></sub> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>for
$<em>VarName</em><sub><font size="2">1</font></sub> as
<em>SequenceType</em> at $<em>VarName</em><sub><font size=
"2">pos</font></sub> in <em>Expr</em><sub><font size=
"2">1</font></sub> return <em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_quantifier" class="judgment">·</a> <a href=
"#jd_quantifier" class="judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>)</td>
</tr>
</table>
<br /></div>
<p><b>Example</b></p>
<p>For example, if <code>$example</code> is bound to the sequence
<code>10.0, 1.0E1, 10</code> of type <code>xs:decimal, xs:float,
xs:integer</code>, then the query</p>
<div class="exampleInner">
<pre>
  for $s in $example
  return $s * 2
</pre></div>
<p>is typed as follows:</p>
<div class="exampleInner">
<pre>
  (1) prime(xs:decimal, xs:float, xs:integer) =
      xs:decimal | xs:float | xs:integer
  (2) quantifier(xs:decimal, xs:float, xs:integer) = +
  (3) $s : xs:decimal | xs:float | xs:integer
  (4) $s * 2 : 
      xs:decimal | xs:float | xs:integer
  (5) result-type :
      ( xs:decimal | xs:float | xs:integer ) +
</pre></div>
<p>This result-type is not the most specific type possible. It does
not take into account the order of elements in the input type, and
it ignores the individual and overall number of elements in the
input type. The most specific type possible is: <code>xs:decimal,
xs:float, xs:integer</code>. However, inferring such a specific
type for arbitrary input types and arbitrary return clauses
requires significantly more complex static typing rules. In
addition, if put into the context of an element, the specific type
violates the "unique particle attribution" restriction of XML
schema, which requires that an element must have a unique content
model within a particular context.</p>
<p><b><a href="#processing_dynamic" class="processing">Dynamic
Evaluation</a></b></p>
<p>The evaluation of a <code>for</code> expression distinguishes
two cases: If the iteration expression
<em>Expr</em><sub><font size="2">1</font></sub> evaluates to the
empty sequence, then the entire expression evaluates to the empty
sequence:</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">1</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> ()</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b>for
$<em>VarName</em><sub><font size="2">1</font></sub>
<em>OptTypeDeclaration</em> <em>OptPositionalVar</em> in
<em>Expr</em><sub><font size="2">1</font></sub> return
<em>Expr</em><sub><font size="2">2</font></sub> <a href=
"#jd_yields" class="judgment"><b>=&gt;</b></a> ()</td>
</tr>
</table>
<br /></div>
<p>Otherwise, the iteration expression
<em>Expr</em><sub><font size="2">1</font></sub> is evaluated to
produce the sequence <a href=
"#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub>,
..., <a href="#doc-fs-Item"><em>Item</em></a><sub><font size=
"2">n</font></sub>. For each item <a href=
"#doc-fs-Item"><em>Item</em></a><sub><font size="2">i</font></sub>
in this sequence, the body of the <code>for</code> expression
<em>Expr</em><sub><font size="2">2</font></sub> is evaluated in the
dynamic environment <a href="#xq_dyn_env_def" class=
"env">dynEnv</a> extended with $<em>VarName</em><sub><font size=
"2">1</font></sub> bound to <a href=
"#doc-fs-Item"><em>Item</em></a><sub><font size="2">i</font></sub>.
This produces values <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">i</font></sub>, ..., <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">n</font></sub> which are concatenated to produce the result
sequence.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <em>Expr</em><sub><font size=
"2">1</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub>
,..., <a href="#doc-fs-Item"><em>Item</em></a><sub><font size=
"2">n</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>VarName</em> <a href=
"#jd_var_qname_expands_to" class="judgment"><b>of var expands
to</b></a> <em>Variable</em></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href=
"#xq_val_env" class="env">varValue</a>(<em>Variable</em> =&gt;
<a href="#doc-fs-Item"><em>Item</em></a><sub><font size=
"2">1</font></sub>)
<b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td>···</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href=
"#xq_val_env" class="env">varValue</a>(<em>Variable</em> =&gt;
<a href="#doc-fs-Item"><em>Item</em></a><sub><font size=
"2">n</font></sub>)
<b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">n</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> for $<em>VarName</em> in
<em>Expr</em><sub><font size="2">1</font></sub> return
<em>Expr</em><sub><font size="2">2</font></sub> <a href=
"#jd_yields" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> ,..., <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">n</font></sub></td>
</tr>
</table>
<br /></div>
<p>The following rule is the same as the rule above, but includes
the optional positional variable $<em>VarName</em><sub><font size=
"2">pos</font></sub>. If present, $<em>VarName</em><sub><font size=
"2">pos</font></sub> is bound to the position of the item in the
input sequence, i.e., the value <em>i</em>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <em>Expr</em><sub><font size=
"2">1</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub>
,..., <a href="#doc-fs-Item"><em>Item</em></a><sub><font size=
"2">n</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>VarName</em> <a href=
"#jd_var_qname_expands_to" class="judgment"><b>of var expands
to</b></a> <em>Variable</em>&#160;&#160;&#160;&#160;<a href=
"#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>VarName</em><sub><font size=
"2">pos</font></sub> <a href="#jd_var_qname_expands_to" class=
"judgment"><b>of var expands to</b></a>
<em>Variable</em><sub><font size="2">pos</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href=
"#xq_val_env" class="env">varValue</a>(<em>Variable</em> =&gt;
<a href="#doc-fs-Item"><em>Item</em></a><sub><font size=
"2">1</font></sub>; <em>Variable</em><sub><font size=
"2">pos</font></sub> =&gt; 1)
<b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td>···</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href=
"#xq_val_env" class="env">varValue</a>(<em>Variable</em> =&gt;
<a href="#doc-fs-Item"><em>Item</em></a><sub><font size=
"2">n</font></sub>; <em>Variable</em><sub><font size=
"2">pos</font></sub> =&gt; n)
<b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">n</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> for $<em>VarName</em> at
$<em>VarName</em><sub><font size="2">pos</font></sub> in
<em>Expr</em><sub><font size="2">1</font></sub> return
<em>Expr</em><sub><font size="2">2</font></sub> <a href=
"#jd_yields" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> ,..., <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">n</font></sub></td>
</tr>
</table>
<br /></div>
<p>When a type declaration is present, the dynamic semantics also
checks that each item in the result of evaluating
<em>Expr</em><sub><font size="2">1</font></sub> matches the
declared type. This semantics is specified by the following dynamic
evaluation rule.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <em>Expr</em><sub><font size=
"2">1</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub>
,..., <a href="#doc-fs-Item"><em>Item</em></a><sub><font size=
"2">n</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub> = <font size="6">[</font> <em>SequenceType</em>
<font size="6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <a href=
"#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub>
<a href="#jd_matches" class="judgment"><b>matches</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td>···</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <a href=
"#doc-fs-Item"><em>Item</em></a><sub><font size="2">n</font></sub>
<a href="#jd_matches" class="judgment"><b>matches</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>VarName</em> <a href=
"#jd_var_qname_expands_to" class="judgment"><b>of var expands
to</b></a> <em>Variable</em></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href=
"#xq_val_env" class="env">varValue</a>(<em>Variable</em> =&gt;
<a href="#doc-fs-Item"><em>Item</em></a><sub><font size=
"2">1</font></sub>)
<b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td>···</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href=
"#xq_val_env" class="env">varValue</a>(<em>Variable</em> =&gt;
<a href="#doc-fs-Item"><em>Item</em></a><sub><font size=
"2">n</font></sub>)
<b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">n</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> for $<em>VarName</em> as
<em>SequenceType</em> in <em>Expr</em><sub><font size=
"2">1</font></sub> return <em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> ,..., <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">n</font></sub></td>
</tr>
</table>
<br /></div>
<p>The last rule covers a <code>for</code> expression that contains
a type declaration and a positional variable.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <em>Expr</em><sub><font size=
"2">1</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub>
,..., <a href="#doc-fs-Item"><em>Item</em></a><sub><font size=
"2">n</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub> = <font size="6">[</font> <em>SequenceType</em>
<font size="6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <a href=
"#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub>
<a href="#jd_matches" class="judgment"><b>matches</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td>···</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <a href=
"#doc-fs-Item"><em>Item</em></a><sub><font size="2">n</font></sub>
<a href="#jd_matches" class="judgment"><b>matches</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>VarName</em> <a href=
"#jd_var_qname_expands_to" class="judgment"><b>of var expands
to</b></a> <em>Variable</em></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>VarName</em><sub><font size=
"2">pos</font></sub> <a href="#jd_var_qname_expands_to" class=
"judgment"><b>of var expands to</b></a>
<em>Variable</em><sub><font size="2">pos</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href=
"#xq_val_env" class="env">varValue</a>(<em>Variable</em> =&gt;
<a href="#doc-fs-Item"><em>Item</em></a><sub><font size=
"2">1</font></sub>; <em>Variable</em><sub><font size=
"2">pos</font></sub> =&gt; 1)
<b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td>···</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href=
"#xq_val_env" class="env">varValue</a>(<em>Variable</em> =&gt;
<a href="#doc-fs-Item"><em>Item</em></a><sub><font size=
"2">n</font></sub>; <em>Variable</em><sub><font size=
"2">pos</font></sub> =&gt; n)
<b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">n</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> for $<em>VarName</em> as
<em>SequenceType</em> at $<em>VarName</em><sub><font size=
"2">pos</font></sub> in <em>Expr</em><sub><font size=
"2">1</font></sub> return <em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> ,..., <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">n</font></sub></td>
</tr>
</table>
<br /></div>
<p>Note that this definition allows <em>non-deterministic</em>
evaluation of the resulting sequence, since the preconditions in
the above rule can be evaluated in any order.</p>
<p><b>Example</b></p>
<p>Note that if the expression in the <code>return</code> clause
results in a sequence, sequences are never nested in the
[XPath/XQuery] data model. For instance, in the following for
expression:</p>
<div class="exampleInner">
<pre>
  
  for $i in (1,2)
    return (&lt;i&gt; {$i} &lt;/i&gt;, &lt;negi&gt; {-$i} &lt;/negi&gt;)
</pre></div>
<p>each iteration in the <code>for</code> results in a sequence of
two elements, which are then concatenated and flattened in the
resulting sequence:</p>
<div class="exampleInner">
<pre>
  
  (&lt;i&gt;1&lt;/i&gt;,
   &lt;negi&gt;-1&lt;/negi&gt;,
   &lt;i&gt;2&lt;/i&gt;,
   &lt;negi&gt;-2&lt;/negi&gt;)
</pre></div>
</div>
<div class="div3">
<h4><a name="sec_lets" id="sec_lets"></a>4.8.3 Let Expression</h4>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>A <code>let</code> expression extends the static environment
<a href="#xq_stat_env_def" class="env">statEnv</a> with
<em>Variable</em><sub><font size="2">1</font></sub> of type
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub> inferred from <em>Expr</em><sub><font size=
"2">1</font></sub>, and infers the type of
<em>Expr</em><sub><font size="2">2</font></sub> in the extended
environment to produce the result type <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
<em>Expr</em><sub><font size="2">1</font></sub> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
&#160;&#160;&#160;&#160;<a href="#xq_stat_env_def" class=
"env">statEnv</a> <b>&#160;|-&#160;</b><em>VarName</em> <a href=
"#jd_var_qname_expands_to" class="judgment"><b>of var expands
to</b></a> <em>Variable</em>&#160;&#160;&#160;&#160; <a href=
"#xq_stat_env_def" class="env">statEnv</a> + <a href="#xq_type_env"
class="env">varType</a>(<em>Variable</em> =&gt; <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
<b>&#160;|-&#160;</b> <em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>let $<em>VarName</em> :=
<em>Expr</em><sub><font size="2">1</font></sub> return
<em>Expr</em><sub><font size="2">2</font></sub> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
<br /></div>
<p>When a type declaration is present, the static semantics also
checks that the type of the input expression is a subtype of the
declared type and extends the static environment by typing
<em>Variable</em><sub><font size="2">1</font></sub> with type
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub>. This semantics is specified by the following
static typing rule.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
<em>Expr</em><sub><font size="2">1</font></sub> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub> = <font size="6">[</font> <em>SequenceType</em>
<font size="6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>VarName</em> <a href=
"#jd_var_qname_expands_to" class="judgment"><b>of var expands
to</b></a> <em>Variable</em>&#160;&#160;&#160;&#160; <a href=
"#xq_stat_env_def" class="env">statEnv</a> + <a href="#xq_type_env"
class="env">varType</a>(<em>Variable</em><sub><font size=
"2">1</font></sub> =&gt; <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>
) <b>&#160;|-&#160;</b> <em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>let
$<em>VarName</em><sub><font size="2">1</font></sub> as
<em>SequenceType</em> := <em>Expr</em><sub><font size=
"2">1</font></sub> return <em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
<br /></div>
<p><b><a href="#processing_dynamic" class="processing">Dynamic
Evaluation</a></b></p>
<p>A <code>let</code> expression extends the dynamic environment
<a href="#xq_dyn_env_def" class="env">dynEnv</a> with
<em>Variable</em> bound to <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> returned by <em>Expr</em><sub><font size=
"2">1</font></sub>, and evaluates <em>Expr</em><sub><font size=
"2">2</font></sub> in the extended environment to produce <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">1</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>VarName</em> <a href=
"#jd_var_qname_expands_to" class="judgment"><b>of var expands
to</b></a> <em>Variable</em>&#160;&#160;&#160;&#160; <a href=
"#xq_dyn_env_def" class="env">dynEnv</a> + <a href="#xq_val_env"
class="env">varValue</a>(<em>Variable</em><sub><font size=
"2">1</font></sub> =&gt; <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>)
<b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b>let
$<em>VarName</em><sub><font size="2">1</font></sub> :=
<em>Expr</em><sub><font size="2">1</font></sub> return
<em>Expr</em><sub><font size="2">2</font></sub> <a href=
"#jd_yields" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
<br /></div>
<p>When a type declaration is present, the dynamic semantics also
checks that the result of evaluating <em>Expr</em><sub><font size=
"2">1</font></sub> matches the declared type. This semantics is
specified as the following dynamic evaluation rule.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">1</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub> = <font size="6">[</font> <em>SequenceType</em>
<font size="6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_matches" class=
"judgment"><b>matches</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>VarName</em> <a href=
"#jd_var_qname_expands_to" class="judgment"><b>of var expands
to</b></a> <em>Variable</em>&#160;&#160;&#160;&#160; <a href=
"#xq_dyn_env_def" class="env">dynEnv</a> + <a href="#xq_val_env"
class="env">varValue</a>(<em>Variable</em><sub><font size=
"2">1</font></sub> =&gt; <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>)
<b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b>let
$<em>VarName</em><sub><font size="2">1</font></sub> as
<em>SequenceType</em> := <em>Expr</em><sub><font size=
"2">1</font></sub> return <em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
<br /></div>
<p><b>Example</b></p>
<p>Note the use of the environments to define the scope of each
variable. For instance, in the following nested <code>let</code>
expression:</p>
<div class="exampleInner">
<pre>
  let $k := 5 return
    let $k := $k + 1 return
      $k+1
</pre></div>
<p>the outermost <code>let</code> expression binds variable
<code>$k</code> to the integer <code>5</code> in the environment,
then the expression <code>$k+1</code> is computed, yielding value
<code>6</code>, to which the second variable <code>$k</code> is
bound. The expression then results in the final integer
<code>7</code>.</p>
</div>
<div class="div3">
<h4><a name="id_orderby_clause" id="id_orderby_clause"></a>4.8.4
Order By and Return Clauses</h4>
<p><b>Introduction</b></p>
<p>The dynamic semantics of the <em>OrderByClause</em> is not
specified formally, as doing so would require the introduction of
tuples, which are not supported in the [XPath/XQuery] data model.
The dynamic semantics of the order-by clause can be found in
<a href="http://www.w3.org/TR/xquery#id-orderby-return">Section
3.8.3 Order By and Return
Clauses</a><sup><small>XQ</small></sup>.</p>
<p>Although an <em>OrderByClause</em> does not affect the type of a
<em>FLWORExpr</em> expression, it must still undergo static
analysis, in case this raises a static error. The static semantics
of a <em>FLWORExpr</em> expression with an <em>OrderByClause</em>
is equivalent to the static semantics of an equivalent
<em>FLWORExpr</em> in which the <em>OrderByClause</em> is replaced
by a call to the <code>gt</code> comparison over the corresponding
<em>OrderSpec</em> expression(s).</p>
<p><b>Notation</b></p>
<p id="jd_map_orderspeclist">To define normalization of OrderBy,
the following auxiliary mapping rule is used.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>OrderSpecList</em><font size="6">]</font><a href=
"#jd_map_orderspeclist" class="judgment"><sub><font size=
"2">OrderSpecList</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><em>LetClause</em> ...
<em>LetClause</em></td>
</tr>
</table>
</div>
<p>This rules specifies that <em>OrderSpecList</em> is mapped to a
sequence of <em>LetClause</em>s.</p>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>Proper static typing for FLWOR expressions with an
<em>OrderByClause</em> is obtained by normalizing the
<em>OrderByClause</em> to a Let clause, nested For expressions, and
atomization, then by applying the standard static typing rules for
those expressions. Note that if evaluated dynamically, the
normalization of <em>OrderByClause</em> given here does not express
the required sorting semantics. Notably, the normalization rule
introduces the <code>gt</code> operation which is used implicitely
in the semantics of order by.</p>
<p>Each <em>OrderSpec</em> is normalized by the following
rules.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>OrderSpec</em><sub><font size="2">1</font></sub>
... <em>OrderSpec</em><sub><font size="2">n</font></sub><font size=
"6">]</font><a href="#jd_map_orderspeclist" class=
"judgment"><sub><font size="2">OrderSpecList</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>OrderSpec</em><sub><font size=
"2">1</font></sub><font size="6">]</font><a href=
"#jd_map_orderspeclist" class="judgment"><sub><font size=
"2">OrderSpecList</font></sub></a>, ... <font size=
"6">[</font><em>OrderSpec</em><sub><font size=
"2">n</font></sub><font size="6">]</font><a href=
"#jd_map_orderspeclist" class="judgment"><sub><font size=
"2">OrderSpecList</font></sub></a></td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>Expr</em> <em>OrderModifier</em><font size=
"6">]</font><a href="#jd_map_orderspeclist" class=
"judgment"><sub><font size="2">OrderSpecList</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<table summary="">
<tbody>
<tr>
<td>let $<em>fs:</em>new<sub><font size="2">0</font></sub> :=</td>
</tr>
<tr>
<td>&#160;&#160; let $<em>fs:</em>new<sub><font size=
"2">1</font></sub> := <font size=
"6">[</font><em>Expr</em><font size="6">]</font><a href=
"#jd_map_expr" class="judgment"><sub><font size=
"2">Expr</font></sub></a> return</td>
</tr>
<tr>
<td>&#160;&#160; for $<em>fs:</em>new<sub><font size=
"2">2</font></sub> in $<em>fs:</em>new<sub><font size=
"2">1</font></sub> return</td>
</tr>
<tr>
<td>&#160;&#160; for $<em>fs:</em>new<sub><font size=
"2">3</font></sub> in $<em>fs:</em>new<sub><font size=
"2">1</font></sub> return</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160; <font size=
"6">[</font>$<em>fs:</em>new<sub><font size="2">2</font></sub> gt
$<em>fs:</em>new<sub><font size="2">3</font></sub><font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td><font size="6">[</font><em>OrderSpecList</em><font size=
"6">]</font><a href="#jd_map_orderspeclist" class=
"judgment"><sub><font size="2">OrderSpecList</font></sub></a></td>
</tr>
</tbody>
</table>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="div2">
<h3><a name="sec_unordered-expressions" id=
"sec_unordered-expressions"></a>4.9 Ordered and Unordered
Expressions</h3>
<p><b>Introduction</b></p>
<p>The purpose of <code>ordered</code> and <code>unordered</code>
expressions is to set the ordering mode in the static context to
<code>ordered</code> or <code>unordered</code> for a certain region
in a query. The specified ordering mode applies to the expression
nested inside the curly braces.</p>
<h5><a name="d6e25883" id="d6e25883"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-OrderedExpr" id=
"doc-xquery10-OrderedExpr"></a>[<small>134&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-OrderedExpr">OrderedExpr</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"ordered" "{" <a href="#doc-xquery10-Expr">Expr</a>
"}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-UnorderedExpr" id=
"doc-xquery10-UnorderedExpr"></a>[<small>135&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-UnorderedExpr">UnorderedExpr</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"unordered" "{" <a href="#doc-xquery10-Expr">Expr</a>
"}"</code></td>
</tr>
</tbody>
</table>
<p><b>Core Grammar</b></p>
<p>The Core grammar productions for ordered/unordered expressions
are:</p>
<h5><a name="d6e25904" id="d6e25904"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-OrderedExpr" id=
"doc-xcore-OrderedExpr"></a>[<small>71&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-OrderedExpr"></a><a href=
"#prod-xcore-OrderedExpr">OrderedExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"ordered" "{" <a href="#doc-xcore-Expr">Expr</a>
"}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-UnorderedExpr" id=
"doc-xcore-UnorderedExpr"></a>[<small>72&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-UnorderedExpr"></a><a href=
"#prod-xcore-UnorderedExpr">UnorderedExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"unordered" "{" <a href="#doc-xcore-Expr">Expr</a>
"}"</code></td>
</tr>
</tbody>
</table>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p><em>OrderedExpr</em> (resp. <em>UnorderedExpr</em>) expressions
are normalized to <em>OrderedExpr</em> (resp.
<em>UnorderedExpr</em>) expressions in the [XPath/XQuery] Core.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>ordered { <em>Expr</em> }<font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">ordered { <font size=
"6">[</font><em>Expr</em><font size="6">]</font><a href=
"#jd_map_expr" class="judgment"><sub><font size=
"2">Expr</font></sub></a> }</td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>unordered { <em>Expr</em> }<font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">unordered {
<font size="6">[</font><em>Expr</em><font size="6">]</font><a href=
"#jd_map_expr" class="judgment"><sub><font size=
"2">Expr</font></sub></a> }</td>
</tr>
</table>
</div>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p><em>OrderedExpr</em> and <em>UnorderedExpr</em> expressions set
the ordering mode in the static context to <code>ordered</code> or
<code>unordered</code>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">1</font></sub> = <a href=
"#xq_stat_env_def" class="env">statEnv</a> + <a href=
"#xq_ordering_mode_env" class=
"env">orderingMode</a>(<code>ordered</code>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size=
"2">1</font></sub><b>&#160;|-&#160;</b> <em>Expr</em> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> ordered { <em>Expr</em> }
<a href="#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">1</font></sub> = <a href=
"#xq_stat_env_def" class="env">statEnv</a> + <a href=
"#xq_ordering_mode_env" class=
"env">orderingMode</a>(<code>unordered</code>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size=
"2">1</font></sub><b>&#160;|-&#160;</b> <em>Expr</em> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> unordered { <em>Expr</em> }
<a href="#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
<br /></div>
<p><b><a href="#processing_dynamic" class="processing">Dynamic
Evaluation</a></b></p>
<p><em>OrderedExpr</em> and <em>UnorderedExpr</em> expressions only
have an effect on the static context. The effect on the evaluation
of its subexpression(s) is captured using the <a href=
"#sec_apply_ordering_mode"><em>fs:</em><code>apply-ordering-mode</code></a>
function, which introduced during normalization of axis steps,
<code>union</code>, <code>intersect</code>, and <code>except</code>
expressions, and FLWOR expressions that have no <code>order
by</code> clause.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <em>Expr</em> <a href=
"#jd_yields" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> ordered { <em>Expr</em> }
<a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <em>Expr</em> <a href=
"#jd_yields" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> unordered { <em>Expr</em> }
<a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></td>
</tr>
</table>
<br /></div>
</div>
<div class="div2">
<h3><a name="sec_conditionals" id="sec_conditionals"></a>4.10
Conditional Expressions</h3>
<p><b>Introduction</b></p>
<p>A conditional expression supports conditional evaluation of one
of two expressions.</p>
<h5><a name="d6e26225" id="d6e26225"></a>Conditional
Expression</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-IfExpr" id=
"doc-xquery10-IfExpr"></a>[<small>77&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-IfExpr">IfExpr</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"if" "(" <a href="#doc-xquery10-Expr">Expr</a> ")" "then"
<a href="#doc-xquery10-ExprSingle">ExprSingle</a> "else" <a href=
"#doc-xquery10-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
</table>
<p><b>Core Grammar</b></p>
<p>The Core grammar production for the conditional expression
is:</p>
<h5><a name="d6e26244" id="d6e26244"></a>Core Conditional
Expression</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-IfExpr" id=
"doc-xcore-IfExpr"></a>[<small>35&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-IfExpr"></a><a href=
"#prod-xcore-IfExpr">IfExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"if" "(" <a href="#doc-xcore-Expr">Expr</a> ")" "then"
<a href="#doc-xcore-ExprSingle">ExprSingle</a> "else" <a href=
"#doc-xcore-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
</table>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>Conditional expressions are normalized as follows.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>if (<em>Expr</em><sub><font size="2">1</font></sub>)
then <em>Expr</em><sub><font size="2">2</font></sub> else
<em>Expr</em><sub><font size="2">3</font></sub><font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;if (<code>fn:boolean</code>((<font size=
"6">[</font> <em>Expr</em><sub><font size="2">1</font></sub>
<font size="6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a>))) then
<font size="6">[</font><em>Expr</em><sub><font size=
"2">2</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a> else
<font size="6">[</font><em>Expr</em><sub><font size=
"2">3</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
</tbody>
</table>
</td>
</tr>
</table>
</div>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">1</font></sub> <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <code>xs:boolean</code>
&#160;&#160;&#160;&#160;<a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
&#160;&#160;&#160;&#160;<a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">3</font></sub> <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">3</font></sub></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <code>if</code>
(<em>Expr</em><sub><font size="2">1</font></sub>) <code>then</code>
<em>Expr</em><sub><font size="2">2</font></sub> <code>else</code>
<em>Expr</em><sub><font size="2">3</font></sub> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> (<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
| <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">3</font></sub>)</td>
</tr>
</table>
<br /></div>
<p><b><a href="#processing_dynamic" class="processing">Dynamic
Evaluation</a></b></p>
<p>If the conditional's boolean expression
<em>Expr</em><sub><font size="2">1</font></sub> evaluates to true,
<em>Expr</em><sub><font size="2">2</font></sub> is evaluated and
its value is produced. If the conditional's boolean expression
evaluates to false, <em>Expr</em><sub><font size="2">3</font></sub>
is evaluated and its value is produced. Note that the existence of
two separate dynamic evaluation rules ensures that only one branch
of the conditional is evaluated.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">1</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> true&#160;&#160;&#160;&#160;<a href=
"#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b>if
(<em>Expr</em><sub><font size="2">1</font></sub>) then
<em>Expr</em><sub><font size="2">2</font></sub> else
<em>Expr</em><sub><font size="2">3</font></sub> <a href=
"#jd_yields" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
<br />
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">1</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> false&#160;&#160;&#160;&#160;<a href=
"#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">3</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">3</font></sub></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b>if
(<em>Expr</em><sub><font size="2">1</font></sub>) then
<em>Expr</em><sub><font size="2">2</font></sub> else
<em>Expr</em><sub><font size="2">3</font></sub> <a href=
"#jd_yields" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">3</font></sub></td>
</tr>
</table>
<br /></div>
</div>
<div class="div2">
<h3><a name="id-quantified-expressions" id=
"id-quantified-expressions"></a>4.11 Quantified Expressions</h3>
<p><b>Introduction</b></p>
<p>[XPath/XQuery] defines two quantification expressions:</p>
<h5><a name="d6e26599" id="d6e26599"></a>Quantified Expression</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-QuantifiedExpr" id=
"doc-xquery10-QuantifiedExpr"></a>[<small>70&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-QuantifiedExpr">QuantifiedExpr</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("some" | "every") "$" <a href=
"#doc-xquery10-VarName">VarName</a> <a href=
"#doc-xquery10-TypeDeclaration">TypeDeclaration</a>? "in" <a href=
"#doc-xquery10-ExprSingle">ExprSingle</a> ("," "$" <a href=
"#doc-xquery10-VarName">VarName</a> <a href=
"#doc-xquery10-TypeDeclaration">TypeDeclaration</a>? "in" <a href=
"#doc-xquery10-ExprSingle">ExprSingle</a>)* "satisfies" <a href=
"#doc-xquery10-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e24436.doc-xpath20-QuantifiedExpr" id=
"noid_d3e24436.doc-xpath20-QuantifiedExpr"></a>[<small>14&#160;(XPath)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xpath20/#prod-xpath-QuantifiedExpr">QuantifiedExpr</a><sup><small>XP</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("some" | "every") "$" VarName "in" ExprSingle ("," "$"
VarName "in" ExprSingle)* "satisfies" ExprSingle</code></td>
</tr>
</tbody>
</table>
<p><b>Core Grammar</b></p>
<p>The Core grammar production for quantified expressions is:</p>
<h5><a name="d6e26650" id="d6e26650"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-QuantifiedExpr" id=
"doc-xcore-QuantifiedExpr"></a>[<small>32&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-QuantifiedExpr"></a><a href=
"#prod-xcore-QuantifiedExpr">QuantifiedExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("some" | "every") "$" <a href=
"#doc-xcore-VarName">VarName</a> <a href=
"#doc-xcore-TypeDeclaration">TypeDeclaration</a>? "in" <a href=
"#doc-xcore-ExprSingle">ExprSingle</a> ("," "$" <a href=
"#doc-xcore-VarName">VarName</a> <a href=
"#doc-xcore-TypeDeclaration">TypeDeclaration</a>? "in" <a href=
"#doc-xcore-ExprSingle">ExprSingle</a>)* "satisfies" <a href=
"#doc-xcore-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
</table>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>The quantified expressions are normalized into nested Core
quantified expressions, each of which binds one variable.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>some $<em>VarName</em><sub><font size=
"2">1</font></sub> in <em>Expr</em><sub><font size=
"2">1</font></sub>, ..., $<em>VarName</em><sub><font size=
"2">n</font></sub> in <em>Expr</em><sub><font size=
"2">n</font></sub> satisfies <em>Expr</em><font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<table summary="">
<tbody>
<tr>
<td>some $<em>VarName</em><sub><font size="2">1</font></sub> in
<font size="6">[</font><em>Expr</em><sub><font size=
"2">1</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>
satisfies</td>
</tr>
<tr>
<td>&#160;&#160; some $<em>VarName</em><sub><font size=
"2">2</font></sub> in <font size=
"6">[</font><em>Expr</em><sub><font size=
"2">2</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>
satisfies</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160; &#160;&#160;&#160;&#160;...</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160; some $<em>VarName</em><sub><font size=
"2">n</font></sub> in <font size=
"6">[</font><em>Expr</em><sub><font size=
"2">n</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>
satisfies</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160; <code>fn:boolean</code>((<font size=
"6">[</font><em>Expr</em><font size="6">]</font><a href=
"#jd_map_expr" class="judgment"><sub><font size=
"2">Expr</font></sub></a>))</td>
</tr>
</tbody>
</table>
</td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>every $<em>VarName</em><sub><font size=
"2">1</font></sub> in <em>Expr</em><sub><font size=
"2">1</font></sub>, ..., $<em>VarName</em><sub><font size=
"2">n</font></sub> in <em>Expr</em><sub><font size=
"2">n</font></sub> satisfies <em>Expr</em><font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<table summary="">
<tbody>
<tr>
<td>every $<em>VarName</em><sub><font size="2">1</font></sub> in
<font size="6">[</font><em>Expr</em><sub><font size=
"2">1</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>
satisfies</td>
</tr>
<tr>
<td>&#160;&#160; every $<em>VarName</em><sub><font size=
"2">2</font></sub> in <font size=
"6">[</font><em>Expr</em><sub><font size=
"2">2</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>
satisfies</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160; &#160;&#160;&#160;&#160;...</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160; every
$<em>VarName</em><sub><font size="2">n</font></sub> in <font size=
"6">[</font><em>Expr</em><sub><font size=
"2">n</font></sub><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a>
satisfies</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160; <code>fn:boolean</code>((<font size=
"6">[</font><em>Expr</em><font size="6">]</font><a href=
"#jd_map_expr" class="judgment"><sub><font size=
"2">Expr</font></sub></a>))</td>
</tr>
</tbody>
</table>
</td>
</tr>
</table>
</div>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>The static semantics of the quantified expressions uses the
notion of <a title="prime type" href="#term-prime-type">prime
type</a>. These rules are similar to those for <code>for</code>
expressions in <a href="#id-for-expression"><b>[4.8.2 For
expression]</b></a>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">1</font></sub> <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>VarName</em><sub><font size=
"2">1</font></sub> <a href="#jd_var_qname_expands_to" class=
"judgment"><b>of var expands to</b></a>
<em>Variable</em><sub><font size="2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a> + <a href=
"#xq_type_env" class=
"env">varType</a>(<em>Variable</em><sub><font size=
"2">1</font></sub> =&gt; <a href="#jd_prime" class=
"judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>)) <b>&#160;|-&#160;</b>
<em>Expr</em><sub><font size="2">2</font></sub> <a href=
"#jd_has_type" class="judgment"><b>:</b></a>
<code>xs:boolean</code></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>some
$<em>VarName</em><sub><font size="2">1</font></sub> in
<em>Expr</em><sub><font size="2">1</font></sub> satisfies
<em>Expr</em><sub><font size="2">2</font></sub> <a href=
"#jd_has_type" class="judgment"><b>:</b></a>
<code>xs:boolean</code></td>
</tr>
</table>
<br /></div>
<p>The next rule is for <em>SomeExpr</em> with the optional type
declaration.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">1</font></sub> <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub> = <font size="6">[</font> <em>SequenceType</em>
<font size="6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><a href="#jd_prime" class=
"judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>VarName</em><sub><font size=
"2">1</font></sub> <a href="#jd_var_qname_expands_to" class=
"judgment"><b>of var expands to</b></a>
<em>Variable</em><sub><font size="2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a> + <a href=
"#xq_type_env" class=
"env">varType</a>(<em>Variable</em><sub><font size=
"2">1</font></sub> =&gt; <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>)
<b>&#160;|-&#160;</b> <em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <code>xs:boolean</code></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>some
$<em>VarName</em><sub><font size="2">1</font></sub> as
<em>SequenceType</em> in <em>Expr</em><sub><font size=
"2">1</font></sub> satisfies <em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <code>xs:boolean</code></td>
</tr>
</table>
<br /></div>
<p>The next rule is for <em>EveryExpr</em> without the optional
type declaration.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">1</font></sub> <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>VarName</em><sub><font size=
"2">1</font></sub> <a href="#jd_var_qname_expands_to" class=
"judgment"><b>of var expands to</b></a>
<em>Variable</em><sub><font size="2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a> + <a href=
"#xq_type_env" class=
"env">varType</a>(<em>Variable</em><sub><font size=
"2">1</font></sub> =&gt; <a href="#jd_prime" class=
"judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>)) <b>&#160;|-&#160;</b>
<em>Expr</em><sub><font size="2">2</font></sub> <a href=
"#jd_has_type" class="judgment"><b>:</b></a>
<code>xs:boolean</code></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>every
$<em>VarName</em><sub><font size="2">1</font></sub> in
<em>Expr</em><sub><font size="2">1</font></sub> satisfies
<em>Expr</em><sub><font size="2">2</font></sub> <a href=
"#jd_has_type" class="judgment"><b>:</b></a>
<code>xs:boolean</code></td>
</tr>
</table>
<br /></div>
<p>The next rule is for <em>EveryExpr</em> with the optional type
declaration.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">1</font></sub> <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub> = <font size="6">[</font> <em>SequenceType</em>
<font size="6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><a href="#jd_prime" class=
"judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>VarName</em><sub><font size=
"2">1</font></sub> <a href="#jd_var_qname_expands_to" class=
"judgment"><b>of var expands to</b></a>
<em>Variable</em><sub><font size="2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a> + <a href=
"#xq_type_env" class=
"env">varType</a>(<em>Variable</em><sub><font size=
"2">1</font></sub> =&gt; <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>)
<b>&#160;|-&#160;</b> <em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <code>xs:boolean</code></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>every
$<em>VarName</em><sub><font size="2">1</font></sub> as
<em>SequenceType</em> in <em>Expr</em><sub><font size=
"2">1</font></sub> satisfies <em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <code>xs:boolean</code></td>
</tr>
</table>
<br /></div>
<p><b><a href="#processing_dynamic" class="processing">Dynamic
Evaluation</a></b></p>
<p>If its input expression returns the empty sequence, the
<em>SomeExpr</em> expression returns false.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">1</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> ()</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b>some
$<em>VarName</em><sub><font size="2">1</font></sub>
<em>OptTypeDeclaration</em> in <em>Expr</em><sub><font size=
"2">1</font></sub> satisfies <em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> false</td>
</tr>
</table>
<br /></div>
<p>The <em>SomeExpr</em> expression yields true if any evaluation
of the satisfies expression yields true. The <em>SomeExpr</em>
expression yields false if every evaluation of the satisfies
expression is false. A quantified expression may raise an error if
any evaluation of the satisfies expression raises an error. The
dynamic semantics of quantified expressions is non-deterministic.
This non-determinism permits implementations to use short-circuit
evaluation strategies when evaluating quantified expressions.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">1</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub>,
..., <a href="#doc-fs-Item"><em>Item</em></a><sub><font size=
"2">n</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>VarName</em><sub><font size=
"2">1</font></sub> <a href="#jd_var_qname_expands_to" class=
"judgment"><b>of var expands to</b></a>
<em>Variable</em><sub><font size="2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href=
"#xq_val_env" class=
"env">varValue</a>(<em>Variable</em><sub><font size=
"2">1</font></sub> =&gt; <a href=
"#doc-fs-Item"><em>Item</em></a><sub><font size="2">i</font></sub>)
<b>&#160;|-&#160;</b> <em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> true</td>
</tr>
<tr align="center" valign="middle">
<td>i <a href="#jd_isin" class="judgment"><b>in</b></a> { 1,...,n
}</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b>some
$<em>VarName</em><sub><font size="2">1</font></sub> in
<em>Expr</em><sub><font size="2">1</font></sub> satisfies
<em>Expr</em><sub><font size="2">2</font></sub> <a href=
"#jd_yields" class="judgment"><b>=&gt;</b></a> true</td>
</tr>
</table>
<br /></div>
<p>The next rule is for <em>SomeExpr</em> with the optional type
declaration, in which some evaluation of the satisfies expression
yields true.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">1</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub>,
..., <a href="#doc-fs-Item"><em>Item</em></a><sub><font size=
"2">n</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub> = <font size="6">[</font> <em>SequenceType</em>
<font size="6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <a href=
"#doc-fs-Item"><em>Item</em></a><sub><font size="2">i</font></sub>
<a href="#jd_matches" class="judgment"><b>matches</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td>i <a href="#jd_isin" class="judgment"><b>in</b></a> { 1,...,n
}</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>VarName</em><sub><font size=
"2">1</font></sub> <a href="#jd_var_qname_expands_to" class=
"judgment"><b>of var expands to</b></a>
<em>Variable</em><sub><font size="2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href=
"#xq_val_env" class=
"env">varValue</a>(<em>Variable</em><sub><font size=
"2">1</font></sub> =&gt; <a href=
"#doc-fs-Item"><em>Item</em></a><sub><font size="2">i</font></sub>)
<b>&#160;|-&#160;</b> <em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> true</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b>some
$<em>VarName</em><sub><font size="2">1</font></sub> as
<em>SequenceType</em> in <em>Expr</em><sub><font size=
"2">1</font></sub> satisfies <em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> true</td>
</tr>
</table>
<br /></div>
<p>The next rule is for <em>SomeExpr</em> without the optional type
declaration, in which all evaluations of the satisfies expression
yield false.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">1</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub>,
..., <a href="#doc-fs-Item"><em>Item</em></a><sub><font size=
"2">n</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>VarName</em><sub><font size=
"2">1</font></sub> <a href="#jd_var_qname_expands_to" class=
"judgment"><b>of var expands to</b></a>
<em>Variable</em><sub><font size="2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href=
"#xq_val_env" class=
"env">varValue</a>(<em>Variable</em><sub><font size=
"2">1</font></sub> =&gt; <a href=
"#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub>)
<b>&#160;|-&#160;</b> <em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> false</td>
</tr>
<tr align="center" valign="middle">
<td>...</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href=
"#xq_val_env" class=
"env">varValue</a>(<em>Variable</em><sub><font size=
"2">1</font></sub> =&gt; <a href=
"#doc-fs-Item"><em>Item</em></a><sub><font size="2">n</font></sub>)
<b>&#160;|-&#160;</b> <em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> false</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b>some
$<em>VarName</em><sub><font size="2">1</font></sub> in
<em>Expr</em><sub><font size="2">1</font></sub> satisfies
<em>Expr</em><sub><font size="2">2</font></sub> <a href=
"#jd_yields" class="judgment"><b>=&gt;</b></a> false</td>
</tr>
</table>
<br /></div>
<p>The next rule is for <em>SomeExpr</em> with the optional type
declaration, in which all evaluations of the satisfies expression
yield false.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">1</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub>,
..., <a href="#doc-fs-Item"><em>Item</em></a><sub><font size=
"2">n</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub> = <font size="6">[</font> <em>SequenceType</em>
<font size="6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>VarName</em><sub><font size=
"2">1</font></sub> <a href="#jd_var_qname_expands_to" class=
"judgment"><b>of var expands to</b></a>
<em>Variable</em><sub><font size="2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href=
"#xq_val_env" class=
"env">varValue</a>(<em>Variable</em><sub><font size=
"2">1</font></sub> =&gt; <a href=
"#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub>)
<b>&#160;|-&#160;</b> <em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> false</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <a href=
"#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub>
<a href="#jd_matches" class="judgment"><b>matches</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td>...</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href=
"#xq_val_env" class=
"env">varValue</a>(<em>Variable</em><sub><font size=
"2">1</font></sub> =&gt; <a href=
"#doc-fs-Item"><em>Item</em></a><sub><font size="2">n</font></sub>)
<b>&#160;|-&#160;</b> <em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> false</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <a href=
"#doc-fs-Item"><em>Item</em></a><sub><font size="2">n</font></sub>
<a href="#jd_matches" class="judgment"><b>matches</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b>some
$<em>VarName</em><sub><font size="2">1</font></sub> as
<em>SequenceType</em> in <em>Expr</em><sub><font size=
"2">1</font></sub> satisfies <em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> false</td>
</tr>
</table>
<br /></div>
<p>If its input expression returns the empty sequence, the
<em>EveryExpr</em> expression returns true.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">1</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> ()</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b>every
$<em>VarName</em><sub><font size="2">1</font></sub>
<em>OptTypeDeclaration</em> in <em>Expr</em><sub><font size=
"2">1</font></sub> satisfies <em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> true</td>
</tr>
</table>
<br /></div>
<p>The <em>EveryExpr</em> expression yields false if any evaluation
of the satisfies expression yields false. The <em>EveryExpr</em>
expression yields true if every evaluation of the satisfies
expression is true.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">1</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub>,
..., <a href="#doc-fs-Item"><em>Item</em></a><sub><font size=
"2">n</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>VarName</em><sub><font size=
"2">1</font></sub> <a href="#jd_var_qname_expands_to" class=
"judgment"><b>of var expands to</b></a>
<em>Variable</em><sub><font size="2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href=
"#xq_val_env" class=
"env">varValue</a>(<em>Variable</em><sub><font size=
"2">1</font></sub> =&gt; <a href=
"#doc-fs-Item"><em>Item</em></a><sub><font size="2">i</font></sub>)
<b>&#160;|-&#160;</b> <em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> false</td>
</tr>
<tr align="center" valign="middle">
<td>i <a href="#jd_isin" class="judgment"><b>in</b></a> { 1,...,n
}</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b>every
$<em>VarName</em><sub><font size="2">1</font></sub> in
<em>Expr</em><sub><font size="2">1</font></sub> satisfies
<em>Expr</em><sub><font size="2">2</font></sub> <a href=
"#jd_yields" class="judgment"><b>=&gt;</b></a> false</td>
</tr>
</table>
<br /></div>
<p>The next rule is for <em>EveryExpr</em> with the optional type
declaration, in which some evaluation of the satisfies expression
yields false.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">1</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub>,
..., <a href="#doc-fs-Item"><em>Item</em></a><sub><font size=
"2">n</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub> = <font size="6">[</font> <em>SequenceType</em>
<font size="6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <a href=
"#doc-fs-Item"><em>Item</em></a><sub><font size="2">i</font></sub>
<a href="#jd_matches" class="judgment"><b>matches</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>VarName</em><sub><font size=
"2">1</font></sub> <a href="#jd_var_qname_expands_to" class=
"judgment"><b>of var expands to</b></a>
<em>Variable</em><sub><font size="2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href=
"#xq_val_env" class=
"env">varValue</a>(<em>Variable</em><sub><font size=
"2">1</font></sub> =&gt; <a href=
"#doc-fs-Item"><em>Item</em></a><sub><font size="2">i</font></sub>)
<b>&#160;|-&#160;</b> <em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> false</td>
</tr>
<tr align="center" valign="middle">
<td>i <a href="#jd_isin" class="judgment"><b>in</b></a> { 1,...,n
}</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b>every
$<em>VarName</em><sub><font size="2">1</font></sub> as
<em>SequenceType</em> in <em>Expr</em><sub><font size=
"2">1</font></sub> satisfies <em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> false</td>
</tr>
</table>
<br /></div>
<p>The next rule is for <em>EveryExpr</em> in which all evaluations
of the satisfies expression yield true.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">1</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub>,
..., <a href="#doc-fs-Item"><em>Item</em></a><sub><font size=
"2">n</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>VarName</em><sub><font size=
"2">1</font></sub> <a href="#jd_var_qname_expands_to" class=
"judgment"><b>of var expands to</b></a>
<em>Variable</em><sub><font size="2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href=
"#xq_val_env" class=
"env">varValue</a>(<em>Variable</em><sub><font size=
"2">1</font></sub> =&gt; <a href=
"#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub>)
<b>&#160;|-&#160;</b> <em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> true</td>
</tr>
<tr align="center" valign="middle">
<td>...</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href=
"#xq_val_env" class=
"env">varValue</a>(<em>Variable</em><sub><font size=
"2">1</font></sub> =&gt; <a href=
"#doc-fs-Item"><em>Item</em></a><sub><font size="2">n</font></sub>)
<b>&#160;|-&#160;</b> <em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> true</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b>every
$<em>VarName</em><sub><font size="2">1</font></sub> in
<em>Expr</em><sub><font size="2">1</font></sub> satisfies
<em>Expr</em><sub><font size="2">2</font></sub> <a href=
"#jd_yields" class="judgment"><b>=&gt;</b></a> true</td>
</tr>
</table>
<br /></div>
<p>The next rule is for <em>EveryExpr</em> with the optional type
declaration in which all evaluations of the satisfies expression
yield true.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">1</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub>,
..., <a href="#doc-fs-Item"><em>Item</em></a><sub><font size=
"2">n</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub> = <font size="6">[</font> <em>SequenceType</em>
<font size="6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>VarName</em><sub><font size=
"2">1</font></sub> <a href="#jd_var_qname_expands_to" class=
"judgment"><b>of var expands to</b></a>
<em>Variable</em><sub><font size="2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href=
"#xq_val_env" class=
"env">varValue</a>(<em>Variable</em><sub><font size=
"2">1</font></sub> =&gt; <a href=
"#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub>)
<b>&#160;|-&#160;</b> <em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> true</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <a href=
"#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub>
<a href="#jd_matches" class="judgment"><b>matches</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td>...</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href=
"#xq_val_env" class=
"env">varValue</a>(<em>Variable</em><sub><font size=
"2">1</font></sub> =&gt; <a href=
"#doc-fs-Item"><em>Item</em></a><sub><font size="2">n</font></sub>)
<b>&#160;|-&#160;</b> <em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> true</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <a href=
"#doc-fs-Item"><em>Item</em></a><sub><font size="2">n</font></sub>
<a href="#jd_matches" class="judgment"><b>matches</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b>every
$<em>VarName</em><sub><font size="2">1</font></sub> as
<em>SequenceType</em> in <em>Expr</em><sub><font size=
"2">1</font></sub> satisfies <em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> true</td>
</tr>
</table>
<br /></div>
</div>
<div class="div2">
<h3><a name="sec_sequencetype-matching" id=
"sec_sequencetype-matching"></a>4.12 Expressions on
SequenceTypes</h3>
<p><b>Introduction</b></p>
<p>Some of the expressions relying on the SequenceTypes syntax are
called expressions on SequenceTypes. The syntax of SequenceTypes is
described in <a href="#id-sequencetype"><b>[3.5.3 SequenceType
Syntax]</b></a>.</p>
<div class="div3">
<h4><a name="sec_instance-of" id="sec_instance-of"></a>4.12.1
Instance Of</h4>
<h5><a name="d6e28937" id="d6e28937"></a>SequenceType
expressions</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-InstanceofExpr" id=
"doc-xquery10-InstanceofExpr"></a>[<small>95&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-InstanceofExpr">InstanceofExpr</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery10-TreatExpr">TreatExpr</a> (
"instance" "of" <a href=
"#doc-xquery10-SequenceType">SequenceType</a> )?</code></td>
</tr>
</tbody>
</table>
<p><b>Introduction</b></p>
<p>The SequenceType expression "<em>Expr</em> instance of
<em>SequenceType</em>" is true if and only if the result of
evaluating expression <em>Expr</em> is an instance of the type
referred to by <em>SequenceType</em>.</p>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>An <em>InstanceofExpr</em> expression is normalized into a
<em>TypeswitchExpr</em> expression. Note that the following
normalization rule uses a variable $<em>fs:</em>new, which is a
newly created variable which must not conflict with any variables
already in scope. This variable is necessary to comply with the
syntax of typeswitch expressions in the Core [XPath/XQuery], but is
never used.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>Expr</em> instance of
<em>SequenceType</em><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<table summary="">
<tbody>
<tr>
<td>typeswitch (<font size="6">[</font> <em>Expr</em> <font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a>)</td>
</tr>
<tr>
<td>&#160;&#160;case $<em>fs:</em>new as <em>SequenceType</em>
return <code>fn:true</code>()</td>
</tr>
<tr>
<td>&#160;&#160;default $<em>fs:</em>new return
<code>fn:false</code>()</td>
</tr>
</tbody>
</table>
</td>
</tr>
</table>
</div>
</div>
<div class="div3">
<h4><a name="sec_typeswitch" id="sec_typeswitch"></a>4.12.2
Typeswitch</h4>
<h5><a name="d6e29032" id="d6e29032"></a>SequenceType
expressions</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-TypeswitchExpr" id=
"doc-xquery10-TypeswitchExpr"></a>[<small>74&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-TypeswitchExpr">TypeswitchExpr</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"typeswitch" "(" <a href="#doc-xquery10-Expr">Expr</a>
")" <a href="#doc-xquery10-CaseClause">CaseClause</a>+ "default"
("$" <a href="#doc-xquery10-VarName">VarName</a>)? "return"
<a href="#doc-xquery10-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-CaseClause" id=
"doc-xquery10-CaseClause"></a>[<small>75&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-CaseClause">CaseClause</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"case" ("$" <a href="#doc-xquery10-VarName">VarName</a>
"as")? <a href="#doc-xquery10-SequenceType">SequenceType</a>
SequenceTypeUnion "return" <a href=
"#doc-xquery10-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
</table>
<p><b>Introduction</b></p>
<p>The <b>typeswitch</b> expression chooses one of several
expressions to evaluate based on the dynamic type of an input
value.</p>
<p>Each branch of a typeswitch expression may have an optional
$<em>VarName</em>, which is bound to the value of the input
expression. One reason for using a variable on one of the branches
is that it is assigned a type specific for that branch. This
variable is optional in [XPath/XQuery] but made mandatory in the
[XPath/XQuery] Core.</p>
<p><b>Core Grammar</b></p>
<p>The Core grammar productions for <code>typeswitch</code>
are:</p>
<h5><a name="d6e29084" id="d6e29084"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-TypeswitchExpr" id=
"doc-xcore-TypeswitchExpr"></a>[<small>33&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-TypeswitchExpr"></a><a href=
"#prod-xcore-TypeswitchExpr">TypeswitchExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"typeswitch" "(" <a href="#doc-xcore-Expr">Expr</a> ")"
<a href="#doc-xcore-CaseClause">CaseClause</a>+ "default" "$"
<a href="#doc-xcore-VarName">VarName</a> "return" <a href=
"#doc-xcore-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-CaseClause" id=
"doc-xcore-CaseClause"></a>[<small>34&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-CaseClause"></a><a href=
"#prod-xcore-CaseClause">CaseClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"case" "$" <a href="#doc-xcore-VarName">VarName</a> "as"
<a href="#doc-xcore-SequenceType">SequenceType</a> "return"
<a href="#doc-xcore-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
</table>
<p><b>Notation</b></p>
<p>For convenience, we introduce the following auxiliary grammar
production.</p>
<h5><a name="d6e29118" id="d6e29118"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-OptVarName" id=
"doc-fs-OptVarName"></a>[<small>81&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-OptVarName">OptVarName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("$" VarName)?</code></td>
</tr>
</tbody>
</table>
<p><b>Notation</b></p>
<p id="jd_map_case">To define normalization of case clauses to the
[XPath/XQuery] Core, the following auxiliary mapping rules are
used.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>CaseClause</em><font size="6">]</font><a href=
"#jd_map_case" class="judgment"><sub><font size=
"2">Case</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<em>CaseClause</em></td>
</tr>
</table>
</div>
<p>specifies that <em>CaseClause</em> is mapped to
<em>CaseClause</em>, in the [XPath/XQuery] Core.</p>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>Normalization of a typeswitch expression guarantees that every
branch has an associated $<em>VarName</em>. The following
normalization rules add newly created variables that must not
conflict with any variables already in scope.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font> &#160;&#160;case <em>SequenceType</em> return
<em>Expr</em> <font size="6">]</font><a href="#jd_map_case" class=
"judgment"><sub><font size="2">Case</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">&#160;&#160;case
$<em>fs:</em>new<sub><font size="2">1</font></sub> as
<em>SequenceType</em> return <font size="6">[</font> <em>Expr</em>
<font size="6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font> &#160;&#160;case $<em>VarName</em> as
<em>SequenceType</em> return <em>Expr</em> <font size=
"6">]</font><a href="#jd_map_case" class=
"judgment"><sub><font size="2">Case</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">&#160;&#160;case
$<em>VarName</em> as <em>SequenceType</em> return <font size=
"6">[</font> <em>Expr</em> <font size="6">]</font><a href=
"#jd_map_expr" class="judgment"><sub><font size=
"2">Expr</font></sub></a></td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font> default return <em>Expr</em> <font size=
"6">]</font><a href="#jd_map_case" class=
"judgment"><sub><font size="2">Case</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">default
$<em>fs:</em>new<sub><font size="2">1</font></sub> return
<font size="6">[</font> <em>Expr</em> <font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font> default $<em>VarName</em> return <em>Expr</em>
<font size="6">]</font><a href="#jd_map_case" class=
"judgment"><sub><font size="2">Case</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">default
$<em>VarName</em> return <font size="6">[</font> <em>Expr</em>
<font size="6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>
<table summary="">
<tbody>
<tr>
<td>typeswitch ( <em>Expr</em><sub><font size="2">0</font></sub>
)</td>
</tr>
<tr>
<td>&#160;&#160;<em>CaseClause</em><sub><font size=
"2">1</font></sub></td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;···</td>
</tr>
<tr>
<td>&#160;&#160;<em>CaseClause</em><sub><font size=
"2">n</font></sub></td>
</tr>
<tr>
<td>&#160;&#160;default <em>OptVarName</em> return
<em>Expr</em><sub><font size="2">n+1</font></sub></td>
</tr>
</tbody>
</table>
<font size="6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<table summary="">
<tbody>
<tr>
<td>typeswitch ( <font size="6">[</font>
<em>Expr</em><sub><font size="2">0</font></sub> <font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a> )</td>
</tr>
<tr>
<td><font size="6">[</font><em>CaseClause</em><sub><font size=
"2">1</font></sub><font size="6">]</font><a href="#jd_map_case"
class="judgment"><sub><font size="2">Case</font></sub></a></td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;···</td>
</tr>
<tr>
<td><font size="6">[</font><em>CaseClause</em><sub><font size=
"2">n</font></sub><font size="6">]</font><a href="#jd_map_case"
class="judgment"><sub><font size="2">Case</font></sub></a></td>
</tr>
<tr>
<td><font size="6">[</font>&#160;&#160;default <em>OptVarName</em>
return <em>Expr</em><sub><font size="2">n+1</font></sub>
<font size="6">]</font><a href="#jd_map_case" class=
"judgment"><sub><font size="2">Case</font></sub></a></td>
</tr>
</tbody>
</table>
</td>
</tr>
</table>
</div>
<p><b>Notation</b></p>
<p>For convenience, we use the following auxiliary grammar
productions to denote case clauses in a typeswitch.</p>
<h5><a name="d6e29409" id="d6e29409"></a>FormalCaseClauses</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-FormalCaseClauses" id=
"doc-fs-FormalCaseClauses"></a>[<small>68&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-FormalCaseClauses">FormalCaseClauses</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#doc-fs-FormalCaseClause">FormalCaseClause</a>
<a href="#doc-fs-FormalCaseClauses">FormalCaseClauses</a>) |
<a href=
"#doc-fs-FormalDefaultCaseClause">FormalDefaultCaseClause</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-FormalCaseClause" id=
"doc-fs-FormalCaseClause"></a>[<small>69&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-FormalCaseClause">FormalCaseClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"case" "$" VarName "as" SequenceType "return"
Expr</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-FormalDefaultCaseClause" id=
"doc-fs-FormalDefaultCaseClause"></a>[<small>70&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-FormalDefaultCaseClause">FormalDefaultCaseClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"default" "$" VarName "return" Expr</code></td>
</tr>
</tbody>
</table>
<p id="jd_type_case">The following judgments</p>
<div align="center"><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_type_case" class="judgment"><b>case</b></a>
<em>FormalCaseClause</em> <a href="#jd_type_case" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></div>
<div align="center"><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_type_case" class="judgment"><b>case</b></a>
<em>FormalDefaultCaseClause</em> <a href="#jd_type_case" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></div>
<p>is used in the static semantics of typeswitch. It indicates that
under the static environment <a href="#xq_stat_env_def" class=
"env">statEnv</a>, and with the input type of the typeswitch being
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>, the given case clause yields the type <a href=
"#doc-fs-Type"><em>Type</em></a>.</p>
<p id="jd_against">The following judgment</p>
<div align="center"><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_against" class=
"judgment"><b>against</b></a> <em>FormalCaseClauses</em> <a href=
"#jd_against" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></div>
<p>is used in the dynamic semantics of typeswitch. It indicates
that under the dynamic environment <a href="#xq_dyn_env_def" class=
"env">dynEnv</a>, with the input value of the typeswitch being
<a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>, the given case clauses yield the value <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub>.</p>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>The static typing rules for the typeswitch expression are
simple. Each case clause and the default clause of the typeswitch
is typed independently. The type of the entire typeswitch
expression is the union of the types of all the clauses.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">0</font></sub> <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>
<a href="#jd_type_case" class="judgment"><b>case</b></a> case
$<em>VarName</em><sub><font size="2">1</font></sub> as
<em>SequenceType</em><sub><font size="2">1</font></sub> return
<em>Expr</em><sub><font size="2">1</font></sub> <a href=
"#jd_type_case" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td>&#160;&#160;&#160;&#160;···</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>
<a href="#jd_type_case" class="judgment"><b>case</b></a> case
$<em>VarName</em><sub><font size="2">n</font></sub> as
<em>SequenceType</em><sub><font size="2">n</font></sub> return
<em>Expr</em><sub><font size="2">n</font></sub> <a href=
"#jd_type_case" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">n</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>
<a href="#jd_type_case" class="judgment"><b>case</b></a> default
$<em>VarName</em><sub><font size="2">n+1</font></sub> return
<em>Expr</em><sub><font size="2">n</font></sub> <a href=
"#jd_type_case" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">n+1</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
<table summary="">
<tbody>
<tr>
<td>
<table summary="">
<tbody>
<tr>
<td>(typeswitch (<em>Expr</em><sub><font size=
"2">0</font></sub>)</td>
</tr>
<tr>
<td>&#160;&#160;case $<em>VarName</em><sub><font size=
"2">1</font></sub> as <em>SequenceType</em><sub><font size=
"2">1</font></sub> return <em>Expr</em><sub><font size=
"2">1</font></sub></td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;···</td>
</tr>
<tr>
<td>&#160;&#160;case $<em>VarName</em><sub><font size=
"2">n</font></sub> as <em>SequenceType</em><sub><font size=
"2">n</font></sub> return <em>Expr</em><sub><font size=
"2">n</font></sub></td>
</tr>
<tr>
<td>&#160;&#160;default $<em>VarName</em><sub><font size=
"2">n+1</font></sub> return <em>Expr</em><sub><font size=
"2">n+1</font></sub>)</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
<a href="#jd_has_type" class="judgment"><b>:</b></a> (<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
| ... | <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">n+1</font></sub>)</td>
</tr>
</table>
<br /></div>
<p>To type one case clause, the case variable is assigned the type
of the case clause <em>Case</em><a href=
"#doc-fs-Type"><em>Type</em></a> and the body of the clause is
typed in the extended environment. Thus, the type of a case clause
is independent of the type of the input expression.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><em>Case</em><a href="#doc-fs-Type"><em>Type</em></a> =
<font size="6">[</font> <em>SequenceType</em> <font size=
"6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>VarName</em> <a href=
"#jd_var_qname_expands_to" class="judgment"><b>of var expands
to</b></a> <em>Variable</em></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a> + <a href=
"#xq_type_env" class="env">varType</a>(<em>Variable</em> =&gt;
<em>Case</em><a href="#doc-fs-Type"><em>Type</em></a> )
<b>&#160;|-&#160;</b><em>Expr</em> <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>
<a href="#jd_type_case" class="judgment"><b>case</b></a> case
$<em>VarName</em> as <em>SequenceType</em> return <em>Expr</em>
<a href="#jd_type_case" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
<br /></div>
<p>To type the default clause, the variable is assigned the type of
the input expression and the body of the default clause is typed in
the extended environment.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>VarName</em> <a href=
"#jd_var_qname_expands_to" class="judgment"><b>of var expands
to</b></a> <em>Variable</em></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a> + <a href=
"#xq_type_env" class="env">varType</a>(<em>Variable</em> =&gt;
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub> ) <b>&#160;|-&#160;</b><em>Expr</em> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>
<a href="#jd_type_case" class="judgment"><b>case</b></a> default
$<em>VarName</em> return <em>Expr</em> <a href="#jd_type_case"
class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
<br /></div>
<p><b><a href="#processing_dynamic" class="processing">Dynamic
Evaluation</a></b></p>
<p>The evaluation of a typeswitch proceeds as follows. First, the
input expression is evaluated, yielding an input value. The
<b>effective case</b> is the first <code>case</code> clause such
that the input value matches the SequenceType in the
<code>case</code> clause. The <code>return</code> clause of the
effective case is evaluated and the value of the
<code>return</code> expression is the value of the typeswitch
expression.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>Expr</em> <a href=
"#jd_yields" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">0</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">0</font></sub> <a href="#jd_against" class=
"judgment"><b>against</b></a> <em>FormalCaseClauses</em> <a href=
"#jd_against" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b>typeswitch (<em>Expr</em>)
<em>FormalCaseClauses</em> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
<br /></div>
<p>If the value matches the sequence type, the following rule
applies: It extends the dynamic environment by binding the variable
<em>Variable</em> to <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">0</font></sub> and evaluates the body of the
<code>return</code> clause.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><em>Case</em><a href="#doc-fs-Type"><em>Type</em></a> =
<font size="6">[</font> <em>SequenceType</em> <font size=
"6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">0</font></sub> <a href="#jd_matches" class=
"judgment"><b>matches</b></a> <em>Case</em><a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>VarName</em> <a href=
"#jd_var_qname_expands_to" class="judgment"><b>of var expands
to</b></a> <em>Variable</em></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href=
"#xq_val_env" class="env">varValue</a>(<em>Variable</em> =&gt;
<a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">0</font></sub>) <b>&#160;|-&#160;</b> <em>Expr</em> <a href=
"#jd_yields" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">0</font></sub> <a href="#jd_against" class=
"judgment"><b>against</b></a> case $<em>VarName</em> as
<em>SequenceType</em> return <em>Expr</em>
<em>FormalCaseClauses</em> <a href="#jd_against" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
<br /></div>
<p>If the value does not match the sequence type, the current case
is not evaluated, and the remaining case clauses are evaluated in
order by applying the inference rule recursively.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><em>Case</em><a href="#doc-fs-Type"><em>Type</em></a> =
<font size="6">[</font> <em>SequenceType</em> <font size=
"6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a>
&#160;&#160;&#160;&#160; <a href="#xq_stat_env_def" class=
"env">statEnv</a> <b>&#160;|-&#160;</b><a href="#jd_not" class=
"judgment"><b>not</b></a>(<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">0</font></sub> <a href="#jd_matches" class=
"judgment"><b>matches</b></a> <em>Case</em><a href=
"#doc-fs-Type"><em>Type</em></a>)&#160;&#160;&#160;&#160; <a href=
"#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">0</font></sub> <a href="#jd_against" class=
"judgment"><b>against</b></a> <em>FormalCaseClauses</em> <a href=
"#jd_against" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">0</font></sub> <a href="#jd_against" class=
"judgment"><b>against</b></a> case $<em>VarName</em> as
<em>SequenceType</em> return <em>Expr</em>
<em>FormalCaseClauses</em> <a href="#jd_against" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
<br /></div>
<p>The last rule states that the <code>default</code> branch of a
typeswitch expression always evaluates to the value of its
<code>return</code> clause.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>VarName</em> <a href=
"#jd_var_qname_expands_to" class="judgment"><b>of var expands
to</b></a> <em>Variable</em></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href=
"#xq_val_env" class="env">varValue</a>(<em>Variable</em> =&gt;
<a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">0</font></sub>) <b>&#160;|-&#160;</b><em>Expr</em> <a href=
"#jd_yields" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">0</font></sub> <a href="#jd_against" class=
"judgment"><b>against</b></a> default $<em>VarName</em> return
<em>Expr</em> <a href="#jd_against" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
<br /></div>
</div>
<div class="div3">
<h4><a name="sec_cast" id="sec_cast"></a>4.12.3 Cast</h4>
<p><b>Introduction</b></p>
<p>The <code>cast</code> expression can be used to convert a value
to a specific datatype. It changes both the type and value of the
result of an expression, and can only be applied to an atomic
value.</p>
<h5><a name="d6e30462" id="d6e30462"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-CastExpr" id=
"doc-xquery10-CastExpr"></a>[<small>98&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-CastExpr">CastExpr</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery10-UnaryExpr">UnaryExpr</a> ( "cast"
"as" <a href="#doc-xquery10-SingleType">SingleType</a>
)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-SingleType" id=
"doc-xquery10-SingleType"></a>[<small>169&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-SingleType">SingleType</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery10-AtomicType">AtomicType</a>
"?"?</code></td>
</tr>
</tbody>
</table>
<p><b>Core Grammar</b></p>
<p>The Core grammar productions for <code>cast</code> expressions
are:</p>
<h5><a name="d6e30487" id="d6e30487"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-CastExpr" id=
"doc-xcore-CastExpr"></a>[<small>41&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-CastExpr"></a><a href=
"#prod-xcore-CastExpr">CastExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>UnaryExpr ( "cast" "as" <a href=
"#doc-xcore-SingleType">SingleType</a> )?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-SingleType" id=
"doc-xcore-SingleType"></a>[<small>85&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-SingleType"></a><a href=
"#prod-xcore-SingleType">SingleType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-AtomicType">AtomicType</a>
"?"?</code></td>
</tr>
</tbody>
</table>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>The normalization of cast applies atomization to its argument.
The type declaration asserts that the result is a single atomic
value. The second normalization rule applies when the target type
is optional.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>Expr</em> cast as <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a> <font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<table summary="">
<tbody>
<tr>
<td>let $v as <a href=
"#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a> :=
<code>fn:data</code>((<font size="6">[</font> <em>Expr</em>
<font size="6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a>)) return</td>
</tr>
<tr>
<td>&#160;&#160;$v cast as <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a></td>
</tr>
</tbody>
</table>
</td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>Expr</em> cast as <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a>? <font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<table summary="">
<tbody>
<tr>
<td>let $v as <a href=
"#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>? :=
<code>fn:data</code>((<font size="6">[</font> <em>Expr</em>
<font size="6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a>)) return</td>
</tr>
<tr>
<td>&#160;&#160;typeswitch ($v)</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;case $<em>fs:</em>new as
empty-sequence() return ()</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;default $<em>fs:</em>new return $v cast
as <a href="#doc-core-AtomicType"><em>AtomicType</em></a></td>
</tr>
</tbody>
</table>
</td>
</tr>
</table>
</div>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>The static typing rule of <code>cast</code> expression is as
follows. The type of a Core <code>cast</code> expression is always
the target type. Note that a <code>cast</code> expression can fail
at run-time if the given value cannot be cast to the target
type.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>Expr</em> cast as
<a href="#doc-core-AtomicType"><em>AtomicType</em></a> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a></td>
</tr>
</table>
<br /></div>
<p><b>Notation</b></p>
<p>The dynamic semantics of <code>cast</code> expressions is
defined in <a href=
"http://www.w3.org/TR/xpath-functions/#casting">Section 17
Casting</a><sup><small>FO</small></sup>. The semantics of cast
expressions depends on the type of the input value and on the
target type. For any source and target primitive types, the
<em>casting table</em> in <a href=
"http://www.w3.org/TR/xpath-functions/#casting">Section 17
Casting</a><sup><small>FO</small></sup> indicates whether the cast
from the source type to the target type is permitted. When a cast
is permitted, the detailed dynamic evaluation rules for cast in
<a href="http://www.w3.org/TR/xpath-functions/#casting">Section 17
Casting</a><sup><small>FO</small></sup> are applied. We refer to
those rules using an auxiliary judgment defined as follows.</p>
<p id="jd_cast_value_to">The judgment</p>
<div align="center"><a href=
"#doc-fs-AtomicValue"><em>AtomicValue</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_cast_value_to" class=
"judgment"><b>cast value to type</b></a> <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a> <a href=
"#jd_cast_value_to" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-AtomicValue"><em>AtomicValue</em></a><sub><font size=
"2">2</font></sub></div>
<p>holds if <a href=
"#doc-fs-AtomicValue"><em>AtomicValue</em></a><sub><font size=
"2">1</font></sub> can be cast to type <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a>, resulting in the
new value <a href=
"#doc-fs-AtomicValue"><em>AtomicValue</em></a><sub><font size=
"2">2</font></sub> according to the rules in <a href=
"http://www.w3.org/TR/xpath-functions/#casting">Section 17
Casting</a><sup><small>FO</small></sup>.</p>
<p><b><a href="#processing_dynamic" class="processing">Dynamic
Evaluation</a></b></p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <em>Expr</em> <a href=
"#jd_yields" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-AtomicValue"><em>AtomicValue</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href=
"#doc-fs-AtomicValue"><em>AtomicValue</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_cast_value_to" class=
"judgment"><b>cast value to type</b></a> <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a> <a href=
"#jd_cast_value_to" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-AtomicValue"><em>AtomicValue</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>Expr</em> cast as <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a> <a href="#jd_yields"
class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-AtomicValue"><em>AtomicValue</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
<br /></div>
</div>
<div class="div3">
<h4><a name="sec_castable" id="sec_castable"></a>4.12.4
Castable</h4>
<h5><a name="d6e30788" id="d6e30788"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-CastableExpr" id=
"doc-xquery10-CastableExpr"></a>[<small>97&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-CastableExpr">CastableExpr</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery10-CastExpr">CastExpr</a> (
"castable" "as" <a href="#doc-xquery10-SingleType">SingleType</a>
)?</code></td>
</tr>
</tbody>
</table>
<p>Castable expressions check whether a value can be cast to a
given type.</p>
<p><b>Core Grammar</b></p>
<p>The Core grammar production for castable is:</p>
<h5><a name="d6e30805" id="d6e30805"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-CastableExpr" id=
"doc-xcore-CastableExpr"></a>[<small>40&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-CastableExpr"></a><a href=
"#prod-xcore-CastableExpr">CastableExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-CastExpr">CastExpr</a> ( "castable"
"as" <a href="#doc-xcore-SingleType">SingleType</a> )?</code></td>
</tr>
</tbody>
</table>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>The normalization of castable simply maps its expression
argument.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>Expr</em> castable as <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<table summary="">
<tbody>
<tr>
<td>let $v as <a href=
"#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a> :=
<code>fn:data</code>((<font size="6">[</font> <em>Expr</em>
<font size="6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a>)) return</td>
</tr>
<tr>
<td>$v castable as <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a></td>
</tr>
</tbody>
</table>
</td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>Expr</em> castable as <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a>?<font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<table summary="">
<tbody>
<tr>
<td>let $v as <a href=
"#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>? :=
<code>fn:data</code>((<font size="6">[</font> <em>Expr</em>
<font size="6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a>)) return</td>
</tr>
<tr>
<td>$v castable as <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a>?</td>
</tr>
</tbody>
</table>
</td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>Expr</em> castable as
<em>SingleType</em><font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">( <font size=
"6">[</font><em>Expr</em><font size="6">]</font><a href=
"#jd_map_expr" class="judgment"><sub><font size=
"2">Expr</font></sub></a> ) castable as <em>SingleType</em></td>
</tr>
</table>
</div>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>The type of a Core <code>castable</code> expression is always a
boolean.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>Expr</em> castable as
<a href="#doc-core-AtomicType"><em>AtomicType</em></a> <a href=
"#jd_has_type" class="judgment"><b>:</b></a>
<code>xs:boolean</code></td>
</tr>
</table>
<br /></div>
<p><b>Notation</b></p>
<p id="jd_can_be_cast_to">The auxiliary judgment:</p>
<div align="center"><a href="#doc-fs-Value"><em>Value</em></a>
<a href="#jd_can_be_cast_to" class="judgment"><b>can be cast
to</b></a> <em>SingleType</em></div>
<p>holds when <a href="#doc-fs-Value"><em>Value</em></a> can be
atomized and cast to <em>SingleType</em>. Its definition depends on
the <a href="#jd_cast_value_to" class="judgment"><b>cast value to
type</b></a> judgment.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>() <a href="#jd_can_be_cast_to" class="judgment"><b>can be cast
to</b></a> <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a>?</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#doc-fs-Value"><em>Value</em></a> <a href=
"#jd_can_be_cast_to" class="judgment"><b>can be cast to</b></a>
<a href="#doc-core-AtomicType"><em>AtomicType</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#doc-fs-Value"><em>Value</em></a> <a href=
"#jd_can_be_cast_to" class="judgment"><b>can be cast to</b></a>
<a href="#doc-core-AtomicType"><em>AtomicType</em></a>?</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>fn:data(<a href="#doc-fs-Value"><em>Value</em></a>) = <a href=
"#doc-fs-AtomicValue"><em>AtomicValue</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href=
"#doc-fs-AtomicValue"><em>AtomicValue</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_cast_value_to" class=
"judgment"><b>cast value to type</b></a> <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a> <a href=
"#jd_cast_value_to" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-AtomicValue"><em>AtomicValue</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#doc-fs-Value"><em>Value</em></a> <a href=
"#jd_can_be_cast_to" class="judgment"><b>can be cast to</b></a>
<a href="#doc-core-AtomicType"><em>AtomicType</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p><b><a href="#processing_dynamic" class="processing">Dynamic
Evaluation</a></b></p>
<p><span>If casting succeeds,</span> <span>If the value of the
operand expression can be cast to the given type,</span> then the
<code>castable</code> expression evaluates to true.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>Expr</em> cast as <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a> <a href="#jd_yields"
class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>Expr</em> <a href=
"#jd_yields" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Value"><em>Value</em></a> <a href=
"#jd_can_be_cast_to" class="judgment"><b>can be cast to</b></a>
<em>SingleType</em></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>Expr</em> castable as
<span><a href="#doc-core-AtomicType"><em>AtomicType</em></a></span>
<span><em>SingleType</em></span> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> true</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>Otherwise, 'castable as' evaluates to false.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><a href="#jd_not" class=
"judgment"><b>not</b></a>(<em>Expr</em> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>Expr</em> <a href=
"#jd_yields" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#jd_not" class="judgment"><b>not</b></a>(<a href=
"#doc-fs-Value"><em>Value</em></a> <a href="#jd_can_be_cast_to"
class="judgment"><b>can be cast to</b></a>
<em>SingleType</em>)</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b>
<span><em>Expr</em><sub><font size="2">1</font></sub></span>
<span><em>Expr</em></span> castable as <span><a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">2</font></sub></span> <span><em>SingleType</em></span> <a href=
"#jd_yields" class="judgment"><b>=&gt;</b></a> false</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
</div>
<div class="div3">
<h4><a name="sec_constructor-functions" id=
"sec_constructor-functions"></a>4.12.5 Constructor Functions</h4>
<p>Constructor functions provide an alternative syntax for
casting.</p>
<p><b>Notation</b></p>
<p id="jd_denotes_a_constructor_function">Calls to constructor
functions are normalized differently from other function calls, so
we introduce an auxiliary judgment to detect whether the function
being called is a constructor function.</p>
<div align="center"><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a> <a href=
"#jd_denotes_a_constructor_function" class="judgment"><b>denotes a
constructor function</b></a></div>
<p>This judgment holds when the expanded function name maps to an
atomic type in the in-scope schema types.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_type_defn" class="env">typeDefn</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>) = define type
<em>QName</em> <a href=
"#doc-fs-AtomicTypeDerivation"><em>AtomicTypeDerivation</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a> <a href=
"#jd_denotes_a_constructor_function" class="judgment"><b>denotes a
constructor function</b></a></td>
</tr>
</table>
<br /></div>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>Constructor functions for atomic types are normalized to
explicit <code>cast as</code> expressions. Note that the following
normalization rule requires to resolve the name of the function
call and <span>confirm that it denotes a constructor
function</span> in the static context.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>QName</em> <a href=
"#jd_func_qname_expands_to" class="judgment"><b>of func expands
to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a> <a href=
"#jd_denotes_a_constructor_function" class="judgment"><b>denotes a
constructor function</b></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <font size=
"6">[</font><em>QName</em>(<em>ExprSingle</em><sub><font size=
"2">1</font></sub>)<font size="6">]</font><a href="#jd_map_expr"
class="judgment"><sub><font size="2">Expr</font></sub></a> =
<font size="6">[</font><em>ExprSingle</em><sub><font size=
"2">1</font></sub> cast as <em>QName</em>?<font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
</table>
<br /></div>
</div>
<div class="div3">
<h4><a name="sec_treat" id="sec_treat"></a>4.12.6 Treat</h4>
<h5><a name="d6e31436" id="d6e31436"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-TreatExpr" id=
"doc-xquery10-TreatExpr"></a>[<small>96&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-TreatExpr">TreatExpr</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery10-CastableExpr">CastableExpr</a> (
"treat" "as" <a href="#doc-xquery10-SequenceType">SequenceType</a>
)?</code></td>
</tr>
</tbody>
</table>
<p><b>Introduction</b></p>
<p>The expression "<em>Expr</em> treat as <em>SequenceType</em>",
can be used to change the static type of the result of an
expression without changing its value. The treat-as expression
raises a dynamic error if the dynamic type of the input value does
not match the specified type.</p>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>Treat as expressions are normalized to typeswitch expressions.
Note that the following normalization rule uses a variable
$<em>fs:</em>new, which is a newly created variable that does not
conflict with any variables already in scope.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>Expr</em> treat as <em>SequenceType</em><font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<table summary="">
<tbody>
<tr>
<td>typeswitch (<font size="6">[</font> <em>Expr</em> <font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a>)</td>
</tr>
<tr>
<td>&#160;&#160;case $<em>fs:</em>new as <em>SequenceType</em>
return $<em>fs:</em>new</td>
</tr>
<tr>
<td>&#160;&#160;default $<em>fs:</em>new return
<code>fn:error</code>()</td>
</tr>
</tbody>
</table>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="div2">
<h3><a name="sec_validate_expr" id="sec_validate_expr"></a>4.13
Validate Expressions</h3>
<h5><a name="d6e31518" id="d6e31518"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-ValidateExpr" id=
"doc-xquery10-ValidateExpr"></a>[<small>104&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-ValidateExpr">ValidateExpr</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"validate" (<a href=
"#doc-xquery10-ValidationMode">ValidationMode</a> | ("type"
<a href="#doc-xquery10-TypeName">TypeName</a>))? "{" <a href=
"#doc-xquery10-Expr">Expr</a> "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-ValidationMode" id=
"doc-xquery10-ValidationMode"></a>[<small>105&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-ValidationMode">ValidationMode</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"lax" | "strict"</code></td>
</tr>
</tbody>
</table>
<p><b>Core Grammar</b></p>
<p>The Core grammar productions for validate are:</p>
<h5><a name="d6e31542" id="d6e31542"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-ValidateExpr" id=
"doc-xcore-ValidateExpr"></a>[<small>44&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-ValidateExpr"></a><a href=
"#prod-xcore-ValidateExpr">ValidateExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"validate" <a href=
"#doc-xcore-ValidationMode">ValidationMode</a>? "{" <a href=
"#doc-xcore-Expr">Expr</a> "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-ValidationMode" id=
"doc-xcore-ValidationMode"></a>[<small>45&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-ValidationMode"></a><a href=
"#prod-xcore-ValidationMode">ValidationMode</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"lax" | "strict"</code></td>
</tr>
</tbody>
</table>
<p>A <code>validate</code> expression validates its argument with
respect to the <b>in-scope schema definitions</b>, using the schema
validation process described in <a href="#xmlschema-1">[Schema Part
1]</a>. The argument to a validate expression must be either an
element or a document node. Validation replaces all nodes with new
nodes that have their own identity, the <a href=
"http://www.w3.org/TR/xquery#dt-type-annotation">type
annotation</a><sup><small>XQ</small></sup>, and default values
created during the validation process.</p>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>A validate expression with no validation mode is normalized into
a validate expression with the validation mode set to strict.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>validate { <em>Expr</em> }<font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">validate strict {
<font size="6">[</font><em>Expr</em><font size="6">]</font><a href=
"#jd_map_expr" class="judgment"><sub><font size=
"2">Expr</font></sub></a> }</td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>validate <em>ValidationMode</em> { <em>Expr</em>
}<font size="6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">validate
<em>ValidationMode</em> { <font size=
"6">[</font><em>Expr</em><font size="6">]</font><a href=
"#jd_map_expr" class="judgment"><sub><font size=
"2">Expr</font></sub></a> }</td>
</tr>
</table>
</div>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>Static typing of the validate operation is defined by the
following rule. Note the use of a subtyping check to ensure that
the type of the expression to validate is either an element or a
well-formed document node (i.e., with only one root element and no
text nodes). The type of the expression to validate may be a union
of more than one element type. We apply the <a href=
"#jd_in_validation_context" class="judgment"><b>with mode</b></a>
judgment to each element type to determine the meaning of that
element type with the given validation mode, which yields a new
element type. The result type is the union over all new element
types.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>Expr</em> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a> <a href="#jd_subtype_of" class=
"judgment"><b>&lt;:</b></a> (element <span>*</span> | document {
<a href="#doc-fs-ElementType"><em>ElementType</em></a> })</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_prime" class=
"judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a>) =
<a href=
"#doc-fs-ElementType"><em>ElementType</em></a><sub><font size=
"2">1</font></sub> | ... | <a href=
"#doc-fs-ElementType"><em>ElementType</em></a><sub><font size=
"2">n</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href=
"#doc-fs-ElementType"><em>ElementType</em></a><sub><font size=
"2">1</font></sub> = element <a href=
"#doc-xquery-ElementNameOrWildcard"><em>ElementNameOrWildcard</em></a><sub><font size="2">1</font></sub>
<a href=
"#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a><sub><font size="2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td>···</td>
</tr>
<tr align="center" valign="middle">
<td><a href=
"#doc-fs-ElementType"><em>ElementType</em></a><sub><font size=
"2">n</font></sub> = element <a href=
"#doc-xquery-ElementNameOrWildcard"><em>ElementNameOrWildcard</em></a><sub><font size="2">n</font></sub>
<a href=
"#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a><sub><font size="2">n</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-xquery-ElementNameOrWildcard"><em>ElementNameOrWildcard</em></a><sub><font size="2">1</font></sub>
<a href="#jd_in_validation_context" class="judgment"><b>with
mode</b></a> <em>ValidationMode</em> <a href=
"#jd_in_validation_context" class="judgment"><b>resolves to</b></a>
<a href=
"#doc-fs-ElementType"><em>ElementType</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td>···</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-xquery-ElementNameOrWildcard"><em>ElementNameOrWildcard</em></a><sub><font size="2">n</font></sub>
<a href="#jd_in_validation_context" class="judgment"><b>with
mode</b></a> <em>ValidationMode</em> <a href=
"#jd_in_validation_context" class="judgment"><b>resolves to</b></a>
<a href=
"#doc-fs-ElementType"><em>ElementType</em></a><sub><font size=
"2">n</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub> = <a href=
"#doc-fs-ElementType"><em>ElementType</em></a><sub><font size=
"2">1</font></sub> | ... | <a href=
"#doc-fs-ElementType"><em>ElementType</em></a><sub><font size=
"2">n</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>validate
<em>ValidationMode</em> { <em>Expr</em> } <a href="#jd_has_type"
class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
<br /></div>
<div class="div3">
<h4><a name="sec_validating_element" id=
"sec_validating_element"></a>4.13.1 Validating an Element Node</h4>
<p><b><a href="#processing_dynamic" class="processing">Dynamic
Evaluation</a></b></p>
<p>The normative dynamic semantics of validation is specified in
<a href="http://www.w3.org/TR/xquery#id-validate">Section 3.13
Validate Expressions</a><sup><small>XQ</small></sup>. The effect of
validation of a data model value is equivalent to:</p>
<ul>
<li>
<p>serialization of the data model, as described in <a href=
"#xslt-xquery-serialization-11">[Data Model Serialization 1.1]</a>,
followed by</p>
</li>
<li>
<p>validation of the serialized value into a Post-Schema Validated
Infoset, as described in <a href="#xmlschema-1">[Schema Part
1]</a>, followed by</p>
</li>
<li>
<p>construction of a new data model value, as described in <a href=
"#xpath-datamodel-11">[Data Model]</a>.</p>
</li>
</ul>
<p>The above steps are expressed formally by the "erasure" and
"annotation" judgments. Formally, validation removes existing type
annotations from nodes ("erasure"), and it re-validates the
corresponding data model instance, possibly adding new type
annotations to nodes ("annotation"). Both erasure and annotation
are described formally in <a href="#sec_validation_judgments"><b>[F
Auxiliary Judgments for Validation]</b></a>. Indeed, the
conjunction of erasure and annotation provides a formal model for a
large part of actual schema validation. The semantics of the
<code>validate</code> expression is specified as follows.</p>
<p>In the first premise below, the expression to validate is
evaluated. The resulting value must be an element or document node.
The second premise constructs a new value in which all existing
type annotations have been erased. The third premise determines the
element type that corresponds to the element node's name in the
given validation mode. The last premise validates erased element
node with the type against which it is validated, using the
<a href="#jd_annotate_as" class="judgment"><b>annotate as</b></a>
judgment, yielding the final validated element.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>; <a href=
"#xq_dyn_env_def" class="env">dynEnv</a> <b>&#160;|-&#160;</b>
<em>Expr</em> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-ElementValue"><em>ElementValue</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href=
"#doc-fs-ElementValue"><em>ElementValue</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_erases_to" class=
"judgment"><b>erases to</b></a> <a href=
"#doc-fs-ElementValue"><em>ElementValue</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href=
"#doc-fs-ElementValue"><em>ElementValue</em></a><sub><font size=
"2">2</font></sub> = element <a href=
"#doc-fs-ElementName"><em>ElementName</em></a><sub><font size=
"2">2</font></sub> of type <a href=
"#doc-fs-TypeName"><em>TypeName</em></a><sub><font size=
"2">2</font></sub> { <a href="#doc-fs-Value"><em>Value</em></a>
}</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-ElementName"><em>ElementName</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_in_validation_context" class=
"judgment"><b>with mode</b></a> <em>ValidationMode</em> <a href=
"#jd_in_validation_context" class="judgment"><b>resolves to</b></a>
<a href=
"#doc-fs-ElementType"><em>ElementType</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_annotate_as"
class="judgment"><b>annotate as</b></a> <a href=
"#doc-fs-ElementType"><em>ElementType</em></a><sub><font size=
"2">2</font></sub> ( <a href=
"#doc-fs-ElementValue"><em>ElementValue</em></a><sub><font size=
"2">2</font></sub>) <a href="#jd_annotate_as" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-ElementValue"><em>ElementValue</em></a><sub><font size=
"2">3</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b>validate
<em>ValidationMode</em> { <em>Expr</em> } <a href="#jd_yields"
class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-ElementValue"><em>ElementValue</em></a><sub><font size=
"2">3</font></sub></td>
</tr>
</table>
<br /></div>
</div>
<div class="div3">
<h4><a name="sec_validating_document" id=
"sec_validating_document"></a>4.13.2 Validating a Document
Node</h4>
<p>The rule for validating a document node is similar to that for
validating an element node.</p>
<p><b><a href="#processing_dynamic" class="processing">Dynamic
Evaluation</a></b></p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>; <a href=
"#xq_dyn_env_def" class="env">dynEnv</a> <b>&#160;|-&#160;</b>
<em>Expr</em> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> document { <a href=
"#doc-fs-ElementValue"><em>ElementValue</em></a><sub><font size=
"2">1</font></sub> }</td>
</tr>
<tr align="center" valign="middle">
<td>document { <a href=
"#doc-fs-ElementValue"><em>ElementValue</em></a><sub><font size=
"2">1</font></sub> } <a href="#jd_erases_to" class=
"judgment"><b>erases to</b></a> document { <a href=
"#doc-fs-ElementValue"><em>ElementValue</em></a><sub><font size=
"2">2</font></sub> }</td>
</tr>
<tr align="center" valign="middle">
<td><a href=
"#doc-fs-ElementValue"><em>ElementValue</em></a><sub><font size=
"2">2</font></sub> = element <a href=
"#doc-fs-ElementName"><em>ElementName</em></a><sub><font size=
"2">2</font></sub> of type <a href=
"#doc-fs-TypeName"><em>TypeName</em></a><sub><font size=
"2">2</font></sub> { <a href="#doc-fs-Value"><em>Value</em></a>
}</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-ElementName"><em>ElementName</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_in_validation_context" class=
"judgment"><b>with mode</b></a> <em>ValidationMode</em> <a href=
"#jd_in_validation_context" class="judgment"><b>resolves to</b></a>
<a href=
"#doc-fs-ElementType"><em>ElementType</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_annotate_as"
class="judgment"><b>annotate as</b></a> document { <a href=
"#doc-fs-ElementType"><em>ElementType</em></a><sub><font size=
"2">2</font></sub> } (document { <a href=
"#doc-fs-ElementValue"><em>ElementValue</em></a><sub><font size=
"2">2</font></sub> }) <a href="#jd_annotate_as" class=
"judgment"><b>=&gt;</b></a> document { <a href=
"#doc-fs-ElementValue"><em>ElementValue</em></a><sub><font size=
"2">3</font></sub> }</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b>validate
<em>ValidationMode</em> { <em>Expr</em> } <a href="#jd_yields"
class="judgment"><b>=&gt;</b></a> document { <a href=
"#doc-fs-ElementValue"><em>ElementValue</em></a><sub><font size=
"2">3</font></sub> }</td>
</tr>
</table>
<br /></div>
</div>
</div>
<div class="div2">
<h3><a name="id-extension-expressions" id=
"id-extension-expressions"></a>4.14 Extension Expressions</h3>
<p><b>Introduction</b></p>
<p>An extension expression is an expression whose semantics are
implementation-defined. An extension expression consists of one or
more pragmas, followed by an expression enclosed in curly
braces.</p>
<h5><a name="d6e32215" id="d6e32215"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-ExtensionExpr" id=
"doc-xquery10-ExtensionExpr"></a>[<small>106&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-ExtensionExpr" class=
"xquery">ExtensionExpr</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery10-Pragma">Pragma</a>+ "{" <a href=
"#doc-xquery10-Expr">Expr</a>? "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-Pragma" id=
"doc-xquery10-Pragma"></a>[<small>107&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-Pragma"
class="xquery">Pragma</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(#" <a href="#prod-xquery10-S">S</a>? _QName_or_EQName
(<a href="#prod-xquery10-S">S</a> <a href=
"#doc-xquery10-PragmaContents">PragmaContents</a>)?
"#)"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-PragmaContents" id=
"doc-xquery10-PragmaContents"></a>[<small>108&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-PragmaContents" class=
"xquery">PragmaContents</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xquery10-Char">Char</a>* - (Char* '#)'
Char*))</code></td>
</tr>
</tbody>
</table>
<p><b>Core Grammar</b></p>
<p>The Core grammar productions for ExtensionExpr are:</p>
<h5><a name="d6e32255" id="d6e32255"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-ExtensionExpr" id=
"doc-xcore-ExtensionExpr"></a>[<small>46&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-ExtensionExpr"></a><a href=
"#prod-xcore-ExtensionExpr" class=
"xquery">ExtensionExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-Pragma">Pragma</a>+ "{" <a href=
"#doc-xcore-Expr">Expr</a>? "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-Pragma" id=
"doc-xcore-Pragma"></a>[<small>47&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-Pragma"></a><a href=
"#prod-xcore-Pragma" class="xquery">Pragma</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(#" <a href="#prod-xcore-S">S</a>? _QName_or_EQName
(<a href="#prod-xcore-S">S</a> <a href=
"#doc-xcore-PragmaContents">PragmaContents</a>)? "#)"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-PragmaContents" id=
"doc-xcore-PragmaContents"></a>[<small>48&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-PragmaContents"></a><a href=
"#prod-xcore-PragmaContents" class=
"xquery">PragmaContents</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xcore-Char">Char</a>* - (Char* '#)'
Char*))</code></td>
</tr>
</tbody>
</table>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>Extension expressions are normalized as extension expressions in
the [XPath/XQuery] Core.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>Pragma</em>+ { <em>Expr</em> }<font size=
"6">]</font><a href="#jd_map_expr" class=
"judgment"><sub><font size="2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><em>Pragma</em>+ {
<font size="6">[</font><em>Expr</em><font size="6">]</font><a href=
"#jd_map_expr" class="judgment"><sub><font size=
"2">Expr</font></sub></a> }</td>
</tr>
</table>
</div>
<p>If the extension expression does not contain any expression,
this is normalized into an extension expression with a call to the
<code>fn:error</code> function.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>Pragma</em>+ { }<font size="6">]</font><a href=
"#jd_map_expr" class="judgment"><sub><font size=
"2">Expr</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><em>Pragma</em>+ {
<code>fn:error</code>() }</td>
</tr>
</table>
</div>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>If at least one of the pragmas is recognized, the static
semantics are implementation-defined.</p>
<p>If none of the pragmas is recognized, the static semantics are
the same as for the input expression. In both cases, the static
typing must be applied on the input expression, possibly raising
the corresponding type errors.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <em>Expr</em> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> A <em>Pragma</em> is
recognized, yielding the implementation-defined static type
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>.</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <em>Pragma</em>+ {
<em>Expr</em> } <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <em>Expr</em> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> No <em>Pragma</em> is
recognized.</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <em>Pragma</em>+ {
<em>Expr</em> } <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
<br /></div>
<p><b><a href="#processing_dynamic" class="processing">Dynamic
Evaluation</a></b></p>
<p>The QName of a pragma must resolve to a namespace URI and local
name, using the statically known namespaces. If at least one of the
pragmas is recognized, the dynamic semantics is
implementation-defined.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> Some <em>Pragma</em> are
recognized, yielding the implementation-defined value <a href=
"#doc-fs-Value"><em>Value</em></a>.</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <em>Pragma</em>+ {
<em>Expr</em> } <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></td>
</tr>
</table>
<br /></div>
<p>If none of the pragmas is recognized, the dynamic semantics of
an <em>ExtensionExpr</em> are the same as evaluating the given
expression.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>No <em>Pragma</em> is recognized.
&#160;&#160;&#160;&#160;<a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <em>Expr</em> <a href=
"#jd_yields" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <em>Pragma</em>+ {
<em>Expr</em> } <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></td>
</tr>
</table>
<br /></div>
</div>
</div>
<div class="div1">
<h2><a name="id-query-prolog" id="id-query-prolog"></a>5 Modules
and Prologs</h2>
<p>The organization of this section parallels the organization of
<a href="http://www.w3.org/TR/xquery#id-query-prolog">Section 4
Modules and Prologs</a><sup><small>XQ</small></sup>.</p>
<p><b>Introduction</b></p>
<p>XQuery supports modules as defined in <a href=
"http://www.w3.org/TR/xquery#id-query-prolog">Section 4 Modules and
Prologs</a><sup><small>XQ</small></sup>. A <a href=
"http://www.w3.org/TR/xquery#dt-main-module">main
module</a><sup><small>XQ</small></sup> contains a <a href=
"http://www.w3.org/TR/xquery#dt-prolog">Prolog</a><sup><small>XQ</small></sup>
followed by a <a href=
"http://www.w3.org/TR/xquery#dt-queryBody">query
body</a><sup><small>XQ</small></sup>. A query has exactly one main
module. In a main module, the <a href=
"http://www.w3.org/TR/xquery#dt-queryBody">query
body</a><sup><small>XQ</small></sup> can be evaluated, and its
value is the result of the query. A <a href=
"http://www.w3.org/TR/xquery#dt-library-module">library
module</a><sup><small>XQ</small></sup> contains a module
declaration followed by a <a href=
"http://www.w3.org/TR/xquery#dt-prolog">Prolog</a><sup><small>XQ</small></sup>.</p>
<p>The Prolog is a sequence of declarations that affect query
processing. The Prolog can be used, for example, to declare
namespace prefixes, import types from XML Schemas, and declare
functions and variables. Namespace declarations and schema imports
always precede function and variable declarations, as specified by
the following grammar productions.</p>
<h5><a name="d6e32589" id="d6e32589"></a>Query Module</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-Module" id=
"doc-xquery10-Module"></a>[<small>1&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-Module">Module</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery10-VersionDecl">VersionDecl</a>?
(<a href="#doc-xquery10-LibraryModule">LibraryModule</a> | <a href=
"#doc-xquery10-MainModule">MainModule</a>)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-MainModule" id=
"doc-xquery10-MainModule"></a>[<small>3&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-MainModule">MainModule</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery10-Prolog">Prolog</a> <a href=
"#doc-xquery10-QueryBody">QueryBody</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-LibraryModule" id=
"doc-xquery10-LibraryModule"></a>[<small>4&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-LibraryModule">LibraryModule</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery10-ModuleDecl">ModuleDecl</a>
<a href="#doc-xquery10-Prolog">Prolog</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-Prolog" id=
"doc-xquery10-Prolog"></a>[<small>6&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-Prolog">Prolog</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>((<a href=
"#doc-xquery10-DefaultNamespaceDecl">DefaultNamespaceDecl</a> |
<a href="#doc-xquery10-Setter">Setter</a> | <a href=
"#doc-xquery10-NamespaceDecl">NamespaceDecl</a> | <a href=
"#doc-xquery10-Import">Import</a>) <a href=
"#doc-xquery10-Separator">Separator</a>)* ((<a href=
"#doc-xquery10-VarDecl">VarDecl</a> | ContextItemDecl | <a href=
"#doc-xquery10-FunctionDecl">FunctionDecl</a> | AnnotatedDecl |
<a href="#doc-xquery10-OptionDecl">OptionDecl</a>) <a href=
"#doc-xquery10-Separator">Separator</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-Setter" id=
"doc-xquery10-Setter"></a>[<small>8&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-Setter">Setter</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xquery10-BoundarySpaceDecl">BoundarySpaceDecl</a> | <a href=
"#doc-xquery10-DefaultCollationDecl">DefaultCollationDecl</a> |
<a href="#doc-xquery10-BaseURIDecl">BaseURIDecl</a> | <a href=
"#doc-xquery10-ConstructionDecl">ConstructionDecl</a> | <a href=
"#doc-xquery10-OrderingModeDecl">OrderingModeDecl</a> | <a href=
"#doc-xquery10-EmptyOrderDecl">EmptyOrderDecl</a> | <a href=
"#doc-xquery10-CopyNamespacesDecl">CopyNamespacesDecl</a> |
DecimalFormatDecl</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-Import" id=
"doc-xquery10-Import"></a>[<small>20&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-Import">Import</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery10-SchemaImport">SchemaImport</a> |
<a href="#doc-xquery10-ModuleImport">ModuleImport</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-Separator" id=
"doc-xquery10-Separator"></a>[<small>7&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-Separator">Separator</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>";"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-QueryBody" id=
"doc-xquery10-QueryBody"></a>[<small>38&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-QueryBody">QueryBody</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery10-Expr">Expr</a></code></td>
</tr>
</tbody>
</table>
<p>Function declarations are globally scoped, that is, the use of a
function name in a function call may precede declaration of the
function. Variable declarations are lexically scoped, i.e.,
variable declarations must precede variable uses.</p>
<p><b>Core Grammar</b></p>
<p>The module declarations and prolog are processed as part of the
static and dynamic context processing. In addition, normalization
of prolog declarations is performed into a simplified formal
grammar given below. As a result, the XQuery core does not need to
include the prolog and module declarations. The entry point for the
core grammar is the <em>Expr</em> non-terminal, as given in
<a href="#id-expressions"><b>[4 Expressions]</b></a>.</p>
<p><b>Notation</b></p>
<p>Modules are identified and can be imported using a target
namespace (a URI). In [XPath/XQuery], the process by which a module
is obtained from a given target namespace is implementation
defined. In this specification, we use the following auxiliary
judgment to model that implementation defined process.</p>
<p id="jd_is_target_namespace_of_modules">The judgment:</p>
<div align="center"><em>AnyURI</em> <a href=
"#jd_is_target_namespace_of_modules" class="judgment"><b>is target
namespace of modules</b></a> <em>Module</em><sub><font size=
"2">1</font></sub> ... <em>Module</em><sub><font size=
"2">n</font></sub></div>
<p>holds if <em>Module</em><sub><font size="2">1</font></sub> ...
<em>Module</em><sub><font size="2">n</font></sub> are the modules
associated to the target namespace <em>AnyURI</em>, and such as
<em>Module</em><sub><font size="2">i</font></sub> does not depend
directly, or transitively on any module after it. (See <a href=
"#xquery-11">[XQuery 1.1: An XML Query Language]</a> for the formal
definition of whether a module directly depends on another)</p>
<p><b>Notation</b></p>
<p>The XQuery Prolog requires that declarations appear in a
particular order. In the Formal Semantics, it is simpler to assume
the declarations can appear in any order, as it does not change
their semantics -- we simply assume that an XQuery parser has
enforced the required order.</p>
<p>The Prolog contains a variety of declarations that specify the
initial static and dynamic context of the query. The following
formal grammar productions represent any Prolog declaration.</p>
<h5><a name="d6e32776" id="d6e32776"></a>Prolog Declarations</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-PrologDeclList" id=
"doc-fs-PrologDeclList"></a>[<small>71&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-PrologDeclList">PrologDeclList</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#doc-fs-PrologDecl">PrologDecl</a> Separator
<a href="#doc-fs-PrologDeclList">PrologDeclList</a>)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-PrologDecl" id=
"doc-fs-PrologDecl"></a>[<small>72&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-PrologDecl">PrologDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>DefaultCollationDecl<br />
| BaseURIDecl<br />
| ConstructionDecl<br />
| OrderingModeDecl<br />
| EmptyOrderDecl<br />
| CopyNamespacesDecl<br />
| SchemaImport<br />
| ModuleImport<br />
| NamespaceDecl<br />
| DefaultNamespaceDecl<br />
| VarDecl<br />
| FunctionDecl<br />
| OptionDecl</code></td>
</tr>
</tbody>
</table>
<p id="jd_map_prolog">The function <font size=
"6">[</font><font size="6">]</font><a href="#jd_map_prolog" class=
"judgment"><sub><font size="2">PrologDecl</font></sub></a> takes a
prolog declaration and maps it into its equivalent declaration in
the Core grammar.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>PrologDecl</em><sub><font size=
"2">1</font></sub><font size="6">]</font><a href="#jd_map_prolog"
class="judgment"><sub><font size=
"2">PrologDecl</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<em>PrologDecl</em><sub><font size="2">2</font></sub></td>
</tr>
</table>
</div>
<p id="jd_yields_context">The following auxiliary judgments are
applied when statically processing the declarations in the prolog.
The effect of the judgment is to process each prolog declaration in
order, constructing a new static environment from the static
environment constructed from previous prolog declarations.</p>
<p>The judgment:</p>
<div align="center"><em>AnyURI</em> ; <a href="#xq_stat_env_def"
class="env">statEnv</a><sub><font size=
"2">1</font></sub><b>&#160;|-&#160;</b><em>PrologDeclList</em>
<a href="#jd_yields_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">2</font></sub> <a href="#jd_yields_context" class=
"judgment"><b>with</b></a> <em>PrologDeclList</em><sub><font size=
"2">1</font></sub></div>
<p>holds if for the given module with namespace <em>AnyURI</em>,
and under the static environment <a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">1</font></sub>, the sequence
of prolog declarations <em>PrologDeclList</em> yields the static
environment <a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">2</font></sub> and the
normalized sequence of prolog declarations in the Core grammar.</p>
<p>The judgment:</p>
<div align="center"><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size=
"2">1</font></sub><b>&#160;|-&#160;</b><em>PrologDecl</em> <a href=
"#jd_yields_context" class="judgment"><b>=&gt;</b><sub><font size=
"2">stat</font></sub></a> <a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">2</font></sub></div>
<p>holds if under the static environment <a href="#xq_stat_env_def"
class="env">statEnv</a><sub><font size="2">1</font></sub>, the
single prolog declaration <em>PrologDecl</em> yields the new static
environment <a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">2</font></sub>.</p>
<p><b>Notation</b></p>
<p>Because functions can be mutually referential, function
signatures must be defined in the static environment before static
type analysis is applied to the function bodies. The following
judgment is used to extend the static environment with the
appropriate function signatures. That judgment is used when
computing the static context for a given module before applying
static context processing.</p>
<p id="jd_yields_sigs">The judgment:</p>
<div align="center"><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size=
"2">1</font></sub><b>&#160;|-&#160;</b><em>PrologDeclList</em>
<a href="#jd_yields_sigs" class=
"judgment"><b>=&gt;</b><sub><font size="2">sigs</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">2</font></sub></div>
<p>holds if extending the static environment <a href=
"#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">1</font></sub> with the function signatures declared in
<em>PrologDeclList</em> yields the new static environment <a href=
"#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">2</font></sub>.</p>
<p>This judgment is defined as follows. In case there is no
declaration, the static environment is returned unchanged.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_yields_sigs"
class="judgment"><b>=&gt;</b><sub><font size=
"2">sigs</font></sub></a> <a href="#xq_stat_env_def" class=
"env">statEnv</a></td>
</tr>
</table>
<br /></div>
<p>If the case of a namespace declaration, the static context is
extended with the corresponding namespace binding.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><em>PrologDecl</em> = <em>NamespaceDecl</em> or
<em>PrologDecl</em> = <em>DefaultNamespaceDecl</em></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>PrologDecl</em> <a href=
"#jd_yields_context" class="judgment"><b>=&gt;</b><sub><font size=
"2">stat</font></sub></a> <a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size=
"2">1</font></sub><b>&#160;|-&#160;</b><em>PrologDeclList</em>
<a href="#jd_yields_sigs" class=
"judgment"><b>=&gt;</b><sub><font size="2">sigs</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>PrologDecl</em> ;
<em>PrologDeclList</em> <a href="#jd_yields_sigs" class=
"judgment"><b>=&gt;</b><sub><font size="2">sigs</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
<br /></div>
<p>If the case of a function declaration, the static context is
extended with the corresponding signature.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><em>PrologDecl</em> = <em>FunctionDecl</em></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>PrologDecl</em> <a href=
"#jd_yields_sigs" class="judgment"><b>=&gt;</b><sub><font size=
"2">sigs</font></sub></a> <a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size=
"2">1</font></sub><b>&#160;|-&#160;</b><em>PrologDeclList</em>
<a href="#jd_yields_sigs" class=
"judgment"><b>=&gt;</b><sub><font size="2">sigs</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>PrologDecl</em> ;
<em>PrologDeclList</em> <a href="#jd_yields_sigs" class=
"judgment"><b>=&gt;</b><sub><font size="2">sigs</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><em>FunctionDecl</em> = declare function <em>QName</em> (
$<em>VarName</em><sub><font size="2">1</font></sub> as
<em>SequenceType</em><sub><font size="2">1</font></sub>, ...,
$<em>VarName</em><sub><font size="2">n</font></sub> as
<em>SequenceType</em><sub><font size="2">n</font></sub>) as
<em>SequenceType</em><sub><font size="2">r</font></sub>
(<em>EnclosedExpr</em> | external)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>QName</em> <a href=
"#jd_func_qname_expands_to" class="judgment"><b>of func expands
to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><font size="6">[</font><em>SequenceType</em><sub><font size=
"2">1</font></sub><font size="6">]</font><a href=
"#jd_map_sequencetype" class="judgment"><sub><font size=
"2">sequencetype</font></sub></a> = <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td>...</td>
</tr>
<tr align="center" valign="middle">
<td><font size="6">[</font><em>SequenceType</em><sub><font size=
"2">n</font></sub><font size="6">]</font><a href=
"#jd_map_sequencetype" class="judgment"><sub><font size=
"2">sequencetype</font></sub></a> = <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">n</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><font size="6">[</font><em>SequenceType</em><sub><font size=
"2">r</font></sub><font size="6">]</font><a href=
"#jd_map_sequencetype" class="judgment"><sub><font size=
"2">sequencetype</font></sub></a> = <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">r</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><em>FunctionSig</em> = declare function <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,
..., <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">n</font></sub>) as <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">r</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">1</font></sub> = <a href=
"#xq_stat_env_def" class="env">statEnv</a> + <a href=
"#xq_functy_env" class="env">funcType</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><span>,n</span>
=&gt; <em>FunctionSig</em>)</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <em>FunctionDecl</em>
<a href="#jd_yields_sigs" class=
"judgment"><b>=&gt;</b><sub><font size="2">sigs</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
<br /></div>
<p>For all other kinds of declarations, the static context is left
unchanged.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#jd_not" class=
"judgment"><b>not</b></a>(<em>PrologDecl</em> =
<em>FunctionDecl</em>) and <a href="#jd_not" class=
"judgment"><b>not</b></a>(<em>PrologDecl</em> =
<em>NamespaceDecl</em>) and <a href="#jd_not" class=
"judgment"><b>not</b></a>(<em>PrologDecl</em> =
<em>DefaultNamespaceDecl</em>)</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>PrologDecl</em> ;
<em>PrologDeclList</em> <a href="#jd_yields_sigs" class=
"judgment"><b>=&gt;</b><sub><font size="2">sigs</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a></td>
</tr>
</table>
<br /></div>
<p>In case of a function declaration, the static context is
extended with the corresponding function signature.</p>
<p><b><a href="#processing_context" class="processing">Static
Context Processing</a></b></p>
<p>Prolog declarations are processed in the order they are
encountered. The normalization of a prolog declaration
<em>PrologDecl</em> depends on the static context processing of all
previous prolog declarations. In turn, static context processing of
<em>PrologDecl</em> depends on the normalization of the
<em>PrologDecl</em>. For example, because variables are lexically
scoped, the normalization and static context processing of a
variable declaration depends on the normalization and static
context processing of all previous variable declarations.
Therefore, the normalization phase and static context processing
are interleaved, with normalization preceding static context
processing for each prolog declaration.</p>
<p>The following inference rules express this dependency. The first
rule specifies that for an empty sequence of prolog declarations,
the initial static environment is left unchanged.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><em>AnyURI</em> ; <a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_yields_context"
class="judgment"><b>=&gt;</b><sub><font size=
"2">stat</font></sub></a> <a href="#xq_stat_env_def" class=
"env">statEnv</a> <a href="#jd_yields_context" class=
"judgment"><b>with</b></a></td>
</tr>
</table>
<br /></div>
<p>The next two rules interleaves normalization and static context
processing. The result of static context processing and
normalization is a static context and the normalized prolog
declarations. In case the declaration is a module import, the URI
for the current module is passed to the static context processing
rule. This allows to avoid self-import, which is handled globally
(See rules for building the context for module declarations in
<a href="#id-module-declaration"><b>[5.2 Module
Declaration]</b></a>).</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#jd_not" class=
"judgment"><b>not</b></a>(<em>PrologDecl</em> =
<em>ModuleImport</em>)</td>
</tr>
<tr align="center" valign="middle">
<td><font size="6">[</font><em>PrologDecl</em><font size=
"6">]</font><a href="#jd_map_prolog" class=
"judgment"><sub><font size="2">PrologDecl</font></sub></a>
<span>=</span> <em>PrologDecl</em><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>PrologDecl</em><sub><font size="2">1</font></sub>
<a href="#jd_yields_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><em>AnyURI</em> ; <a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size=
"2">1</font></sub><b>&#160;|-&#160;</b><em>PrologDeclList</em>
<a href="#jd_yields_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">2</font></sub> <a href="#jd_yields_context" class=
"judgment"><b>with</b></a> <em>PrologDeclList</em><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><em>AnyURI</em> ; <a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>PrologDecl</em> ;
<em>PrologDeclList</em> <a href="#jd_yields_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">2</font></sub> <a href="#jd_yields_context" class=
"judgment"><b>with</b></a> <em>PrologDecl</em><sub><font size=
"2">1</font></sub> ; <em>PrologDeclList</em><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><em>PrologDecl</em> = <em>ModuleImport</em></td>
</tr>
<tr align="center" valign="middle">
<td><font size="6">[</font><em>PrologDecl</em><font size=
"6">]</font><a href="#jd_map_prolog" class=
"judgment"><sub><font size="2">PrologDecl</font></sub></a>
<span>=</span> <em>PrologDecl</em><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><em>AnyURI</em> ; <a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>PrologDecl</em><sub><font size="2">1</font></sub>
<a href="#jd_yields_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><em>AnyURI</em> ; <a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size=
"2">1</font></sub><b>&#160;|-&#160;</b><em>PrologDeclList</em>
<a href="#jd_yields_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">2</font></sub> <a href="#jd_yields_context" class=
"judgment"><b>with</b></a> <em>PrologDeclList</em><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><em>AnyURI</em> ; <a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>PrologDecl</em> ;
<em>PrologDeclList</em> <a href="#jd_yields_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">2</font></sub> <a href="#jd_yields_context" class=
"judgment"><b>with</b></a> <em>PrologDecl</em><sub><font size=
"2">1</font></sub> ; <em>PrologDeclList</em><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
<br /></div>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>Static typing of a main module follows context processing and
normalization. Context processing and normalization of a main
module applies the rules above to the prolog, then using the
resulting static environment <a href="#xq_stat_env_def" class=
"env">statEnv</a>, the query body is normalized into a Core
expression, and the static typing rules are applied to this Core
expression.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><em>AnyURI</em> ; <a href="#xq_default_stat_env" class=
"env">statEnvDefault</a><b>&#160;|-&#160;</b><em>PrologDeclList</em>
<a href="#jd_yields_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a> <a href=
"#jd_yields_context" class="judgment"><b>with</b></a>
<em>PrologDeclList</em><sub><font size="2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><font size=
"6">[</font><em>QueryBody</em><font size="6">]</font><a href=
"#jd_map_expr" class="judgment"><sub><font size=
"2">Expr</font></sub></a> <span>=</span>
<em>Expr</em><sub><font size="2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><em>PrologDeclList</em> <em>QueryBody</em> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
<br /></div>
<p><b>Notation</b></p>
<p id="jd_yields_dyn_context">Similarly, the judgment:</p>
<div align="center"><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size=
"2">1</font></sub><b>&#160;|-&#160;</b><em>PrologDeclList</em>
<a href="#jd_yields_dyn_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a>
<a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size=
"2">2</font></sub></div>
<p>holds if under the dynamic environment <a href="#xq_dyn_env_def"
class="env">dynEnv</a><sub><font size="2">1</font></sub>, the
sequence of prolog declarations <em>PrologDeclList</em> yields the
dynamic environment <a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size="2">2</font></sub>.</p>
<p>The judgment:</p>
<div align="center"><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>PrologDecl</em> <a href=
"#jd_yields_dyn_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a>
<a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size=
"2">1</font></sub></div>
<p>holds if under the dynamic environment <a href="#xq_dyn_env_def"
class="env">dynEnv</a>, the single prolog declaration
<em>PrologDecl</em> yields the new dynamic environment <a href=
"#xq_dyn_env_def" class="env">dynEnv</a><sub><font size=
"2">1</font></sub>.</p>
<p><b><a href="#dyn_processing_context" class="processing">Dynamic
Context Processing</a></b></p>
<p>The rules for initializing the dynamic context are as follows.
The first rule specifies that for an empty sequence of prolog
declarations, the dynamic environment is left unchanged.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><a href=
"#jd_yields_dyn_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a>
<a href="#xq_dyn_env_def" class="env">dynEnv</a></td>
</tr>
</table>
<br /></div>
<p>The second rule simply computes the dynamic environment by
processing the prolog declarations in order.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>PrologDecl</em> <a href=
"#jd_yields_dyn_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a>
<a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size="2">1</font></sub><b>&#160;|-&#160;</b><em>PrologDeclList</em>
<a href="#jd_yields_dyn_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a>
<a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>PrologDecl</em> ;
<em>PrologDeclList</em> <a href="#jd_yields_dyn_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a>
<a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
<br /></div>
<p><b><a href="#processing_dynamic" class="processing">Dynamic
Evaluation</a></b></p>
<p>Dynamic evaluation of a main module applies the rules for
dynamic-context processing to the prolog declarations, then using
the resulting dynamic environment <a href="#xq_dyn_env_def" class=
"env">dynEnv</a>, the dynamic evaluation rules are applied to the
normalized query body.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>#MAIN ; <a href="#xq_default_stat_env" class=
"env">statEnvDefault</a><b>&#160;|-&#160;</b>
<em>PrologDeclList</em> <a href="#jd_yields_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a> <a href=
"#jd_yields_context" class="judgment"><b>with</b></a>
<em>PrologDeclList</em><sub><font size="2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><font size=
"6">[</font><em>QueryBody</em><font size="6">]</font><a href=
"#jd_map_expr" class="judgment"><sub><font size=
"2">Expr</font></sub></a> <span>=</span>
<em>Expr</em><sub><font size="2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_default_dyn_env" class=
"env">dynEnvDefault</a><b>&#160;|-&#160;</b><span><em>PrologDeclList</em><sub><font size="2">1</font></sub></span>
<a href="#jd_yields_dyn_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a>
<a href="#xq_dyn_env_def" class="env">dynEnv</a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><em>PrologDeclList</em> <em>QueryBody</em> <a href="#jd_yields"
class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p><b>Notation</b></p>
<p id="jd_module_statEnv">We define a new judgment that maps a
module's target namespace (or a main module) to the corresponding
module's static environment:</p>
<div align="center">(<em>AnyURI</em> | #MAIN) <a href=
"#jd_module_statEnv" class="judgment"><b>=&gt;</b><sub><font size=
"2">module_statEnv</font></sub></a> <a href="#xq_stat_env_def"
class="env">statEnv</a></div>
<p id="jd_module_dynEnv">We also define a new judgment that maps a
module's target namespace (or a main module) to the corresponding
module's dynamic environment:</p>
<div align="center">(<em>AnyURI</em> | #MAIN) <a href=
"#jd_module_dynEnv" class="judgment"><b>=&gt;</b><sub><font size=
"2">module_dynEnv</font></sub></a> <a href="#xq_dyn_env_def" class=
"env">dynEnv</a></div>
<p>For a main module, those judgments are defined as follows.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_default_stat_env" class=
"env">statEnvDefault</a><b>&#160;|-&#160;</b><em>PrologDeclList</em>
<a href="#jd_yields_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>#MAIN <a href="#jd_module_statEnv" class=
"judgment"><b>=&gt;</b><sub><font size=
"2">module_statEnv</font></sub></a> <a href="#xq_stat_env_def"
class="env">statEnv</a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_default_dyn_env" class=
"env">dynEnvDefault</a><b>&#160;|-&#160;</b><em>PrologDeclList</em>
<a href="#jd_yields_dyn_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a>
<a href="#xq_dyn_env_def" class="env">dynEnv</a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>#MAIN <a href="#jd_module_dynEnv" class=
"judgment"><b>=&gt;</b><sub><font size=
"2">module_dynEnv</font></sub></a> <a href="#xq_dyn_env_def" class=
"env">dynEnv</a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>For a library module, those judgments are defined in <a href=
"#id-module-imports"><b>[5.11 Module Import]</b></a>.</p>
<div class="div2">
<h3><a name="sec_version-declaration" id=
"sec_version-declaration"></a>5.1 Version Declaration</h3>
<h5><a name="d6e34222" id="d6e34222"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-VersionDecl" id=
"doc-xquery10-VersionDecl"></a>[<small>2&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-VersionDecl">VersionDecl</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"xquery" (("encoding" <a href=
"#doc-xquery10-StringLiteral">StringLiteral</a>) | ("version"
<a href="#doc-xquery10-StringLiteral">StringLiteral</a> ("encoding"
<a href="#doc-xquery10-StringLiteral">StringLiteral</a>)?))
<a href="#doc-xquery10-Separator">Separator</a></code></td>
</tr>
</tbody>
</table>
<p><b>Introduction</b></p>
<p>A version declaration specifies the applicable XQuery syntax and
semantics for a module. An XQuery implementation must raise a
static error when processing a query labeled with a version that
the implementation does not support. This document applies to
XQuery 1.0 only and does not specify this static error formally.
Verifying whether the proper version declaration is used is not
formally specified.</p>
</div>
<div class="div2">
<h3><a name="id-module-declaration" id=
"id-module-declaration"></a>5.2 Module Declaration</h3>
<p><b>Introduction</b></p>
<h5><a name="d6e34248" id="d6e34248"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-ModuleDecl" id=
"doc-xquery10-ModuleDecl"></a>[<small>5&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-ModuleDecl">ModuleDecl</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"module" "namespace" <a href=
"#prod-xquery10-NCName">NCName</a> "=" <a href=
"#doc-xquery10-URILiteral">URILiteral</a> <a href=
"#doc-xquery10-Separator">Separator</a></code></td>
</tr>
</tbody>
</table>
<p>We assume that the static-context processing and dynamic-context
processing described in <a href="#id-query-prolog"><b>[5 Modules
and Prologs]</b></a> are applied to all library modules
<em>before</em> the normalization, static context processing, and
dynamic context processing of the main module. That is, at the time
an "import module" declaration is processed, we assume that the
static and dynamic context of the imported module is already
available. This assumption does not require or assume separate
compilation of modules. An implementation might process all or some
imported modules statically (i.e., before the importing module is
identified) or dynamically (i.e., when the importing module is
identified and processed).</p>
<p><b>Core Grammar</b></p>
<p>The core grammar production for module declarations is:</p>
<h5><a name="d6e34273" id="d6e34273"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-ModuleDecl" id=
"doc-xcore-ModuleDecl"></a>[<small>1&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-ModuleDecl"></a><a href=
"#prod-xcore-ModuleDecl">ModuleDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"module" "namespace" <a href=
"#prod-xcore-NCName">NCName</a> "=" <a href=
"#doc-xcore-URILiteral">URILiteral</a> <a href=
"#doc-xcore-Separator">Separator</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-Separator" id=
"doc-xcore-Separator"></a>[<small>2&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-Separator"></a><a href=
"#prod-xcore-Separator">Separator</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>";"</code></td>
</tr>
</tbody>
</table>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>Module declarations are left unchanged through
normalization.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>ModuleDecl</em><font size="6">]</font><a href=
"#jd_map_prolog" class="judgment"><sub><font size=
"2">PrologDecl</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<em>ModuleDecl</em></td>
</tr>
</table>
</div>
<p><b><a href="#processing_context" class="processing">Static
Context Processing</a></b></p>
<p>The effect of a module declaration is to apply the static
context processing rules defined in <a href=
"#id-query-prolog"><b>[5 Modules and Prologs]</b></a> to the
module's prolog. The resulting static context is then available to
any importing module.</p>
<p>The module declaration extends the prolog with a namespace
declaration that binds the module's prefix to its target namespace
(a URI), then computes the static context for the complete
module.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><em>AnyURI</em> <a href="#jd_is_target_namespace_of_modules"
class="judgment"><b>is target namespace of modules</b></a>
<em>Module</em><sub><font size="2">1</font></sub> ...
<em>Module</em><sub><font size="2">n</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><em>Module</em><sub><font size="2">1</font></sub> = module
namespace <em>NCName</em><sub><font size="2">1</font></sub> =
<em>URILiteral</em>; <em>PrologDeclList</em><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td>...</td>
</tr>
<tr align="center" valign="middle">
<td><em>Module</em><sub><font size="2">1</font></sub> = module
namespace <em>NCName</em><sub><font size="2">1</font></sub> =
<em>URILiteral</em>; <em>PrologDeclList</em><sub><font size=
"2">n</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>URILiteral</em> <a href=
"#jd_has_atomic_value" class="judgment"><b>has atomic value</b></a>
<em>AnyURI</em></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_default_stat_env" class=
"env">statEnvDefault</a><b>&#160;|-&#160;</b><em>PrologDeclList</em><sub><font size="2">1</font></sub>
... <em>PrologDeclList</em><sub><font size="2">n</font></sub>
<a href="#jd_yields_sigs" class=
"judgment"><b>=&gt;</b><sub><font size="2">sigs</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">0</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><em>AnyURI</em> ; <a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size=
"2">0</font></sub><b>&#160;|-&#160;</b>declare namespace
<em>NCName</em> = <em>URILiteral</em>;
<em>PrologDeclList</em><sub><font size="2">1</font></sub> <a href=
"#jd_yields_context" class="judgment"><b>=&gt;</b><sub><font size=
"2">stat</font></sub></a> <a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">1</font></sub> <a href=
"#jd_yields_context" class="judgment"><b>with</b></a>
<em>PrologDeclList</em></td>
</tr>
<tr align="center" valign="middle">
<td>...</td>
</tr>
<tr align="center" valign="middle">
<td><em>AnyURI</em> ; <a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size=
"2">n-1</font></sub><b>&#160;|-&#160;</b>declare namespace
<em>NCName</em> = <em>URILiteral</em>;
<em>PrologDeclList</em><sub><font size="2">n</font></sub> <a href=
"#jd_yields_context" class="judgment"><b>=&gt;</b><sub><font size=
"2">stat</font></sub></a> <a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">n</font></sub> <a href=
"#jd_yields_context" class="judgment"><b>with</b></a>
<em>PrologDeclList</em></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><em>AnyURI</em> <a href="#jd_module_statEnv" class=
"judgment"><b>=&gt;</b><sub><font size=
"2">module_statEnv</font></sub></a> <a href="#xq_stat_env_def"
class="env">statEnv</a><sub><font size="2">n</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>Note that the rule above and the rules for static context
processing of an "import module" declaration in <a href=
"#id-module-imports"><b>[5.11 Module Import]</b></a> are mutually
recursive.</p>
<p><b><a href="#dyn_processing_context" class="processing">Dynamic
Context Processing</a></b></p>
<p>The dynamic context processing of a module declaration is
similar to that of static processing. The module declaration
extends the prolog with a namespace declaration that binds the
module's prefix to its target namespace (a URI), then computes the
dynamic context for the complete module.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><em>AnyURI</em> <a href="#jd_is_target_namespace_of_modules"
class="judgment"><b>is target namespace of modules</b></a>
<em>Module</em><sub><font size="2">1</font></sub> ...
<em>Module</em><sub><font size="2">n</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><em>Module</em><sub><font size="2">1</font></sub> = module
namespace <em>NCName</em> = <em>URILiteral</em>;
<em>PrologDeclList</em><sub><font size="2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td>...</td>
</tr>
<tr align="center" valign="middle">
<td><em>Module</em><sub><font size="2">n</font></sub> = module
namespace <em>NCName</em> = <em>URILiteral</em>;
<em>PrologDeclList</em><sub><font size="2">n</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>URILiteral</em> <a href=
"#jd_has_atomic_value" class="judgment"><b>has atomic value</b></a>
<em>AnyURI</em></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_default_dyn_env" class=
"env">dynEnvDefault</a><b>&#160;|-&#160;</b>declare namespace
<em>NCName</em> = <em>URILiteral</em>;
<em>PrologDeclList</em><sub><font size="2">1</font></sub> <a href=
"#jd_yields_dyn_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a>
<a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td>...</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size="2">n-1</font></sub><b>&#160;|-&#160;</b>declare
namespace <em>NCName</em> = <em>URILiteral</em>;
<em>PrologDeclList</em><sub><font size="2">n</font></sub> <a href=
"#jd_yields_dyn_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a>
<a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size=
"2">n</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><em>AnyURI</em> <a href="#jd_module_dynEnv" class=
"judgment"><b>=&gt;</b><sub><font size=
"2">module_dynEnv</font></sub></a> <a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size="2">n</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>Note that the rule above and the rules for dynamic context
processing of an "import module" declaration in <a href=
"#id-module-imports"><b>[5.11 Module Import]</b></a> are mutually
recursive.</p>
</div>
<div class="div2">
<h3><a name="sec_boundary-space-decls" id=
"sec_boundary-space-decls"></a>5.3 Boundary-space Declaration</h3>
<h5><a name="d6e34706" id="d6e34706"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-BoundarySpaceDecl" id=
"doc-xquery10-BoundarySpaceDecl"></a>[<small>9&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-BoundarySpaceDecl">BoundarySpaceDecl</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "boundary-space" ("preserve" |
"strip")</code></td>
</tr>
</tbody>
</table>
<p>The semantics of a boundary-space declaration is not specified
formally.</p>
</div>
<div class="div2">
<h3><a name="sec_default-collation-declaration" id=
"sec_default-collation-declaration"></a>5.4 Default Collation
Declaration</h3>
<h5><a name="d6e34718" id="d6e34718"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-DefaultCollationDecl" id=
"doc-xquery10-DefaultCollationDecl"></a>[<small>10&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-DefaultCollationDecl">DefaultCollationDecl</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "default" "collation" <a href=
"#doc-xquery10-URILiteral">URILiteral</a></code></td>
</tr>
</tbody>
</table>
<p><b>Core Grammar</b></p>
<p>The core grammar production for default collation declarations
is:</p>
<h5><a name="d6e34730" id="d6e34730"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-DefaultCollationDecl" id=
"doc-xcore-DefaultCollationDecl"></a>[<small>3&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-DefaultCollationDecl"></a><a href=
"#prod-xcore-DefaultCollationDecl">DefaultCollationDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "default" "collation" <a href=
"#doc-xcore-URILiteral">URILiteral</a></code></td>
</tr>
</tbody>
</table>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>Default collation declarations are left unchanged through
normalization.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>DefaultCollationDecl</em><font size=
"6">]</font><a href="#jd_map_prolog" class=
"judgment"><sub><font size="2">PrologDecl</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<em>DefaultCollationDecl</em></td>
</tr>
</table>
</div>
<p><b><a href="#processing_context" class="processing">Static
Context Processing</a></b></p>
<p>The default collation declaration updates the collations
environment component within the static environment. The collations
environment component is used by several functions in <a href=
"#xpath-functions-11">[Functions and Operators 1.1]</a>, but is not
used in the Formal Semantics.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>URILiteral</em> <a href=
"#jd_has_atomic_value" class="judgment"><b>has atomic value</b></a>
<em>AnyURI</em></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_collations_env" class="env">collations</a>(<em>AnyURI</em>) =
<em>Collation</em></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">1</font></sub> = <a href=
"#xq_stat_env_def" class="env">statEnv</a> + <a href=
"#xq_default_collation_env" class=
"env">defaultCollation</a>(<em>Collation</em>)</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>declare default collation
<em>URILiteral</em> <a href="#jd_yields_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p><b><a href="#dyn_processing_context" class="processing">Dynamic
Context Processing</a></b></p>
<p>The default collation declaration does not affect the dynamic
context.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b>declare default collation
<em>URILiteral</em> <a href="#jd_yields_dyn_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a>
<a href="#xq_dyn_env_def" class="env">dynEnv</a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
</div>
<div class="div2">
<h3><a name="sec_base-uri-decl" id="sec_base-uri-decl"></a>5.5 Base
URI Declaration</h3>
<h5><a name="d6e34868" id="d6e34868"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-BaseURIDecl" id=
"doc-xquery10-BaseURIDecl"></a>[<small>11&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-BaseURIDecl">BaseURIDecl</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "base-uri" <a href=
"#doc-xquery10-URILiteral">URILiteral</a></code></td>
</tr>
</tbody>
</table>
<p><b>Core Grammar</b></p>
<p>The core grammar production for base uri declarations is:</p>
<h5><a name="d6e34880" id="d6e34880"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-BaseURIDecl" id=
"doc-xcore-BaseURIDecl"></a>[<small>4&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-BaseURIDecl"></a><a href=
"#prod-xcore-BaseURIDecl">BaseURIDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "base-uri" <a href=
"#doc-xcore-URILiteral">URILiteral</a></code></td>
</tr>
</tbody>
</table>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>Base URI declarations are left unchanged through
normalization.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>BaseURIDecl</em><font size="6">]</font><a href=
"#jd_map_prolog" class="judgment"><sub><font size=
"2">PrologDecl</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<em>BaseURIDecl</em></td>
</tr>
</table>
</div>
<p><b><a href="#processing_context" class="processing">Static
Context Processing</a></b></p>
<p>A base URI declaration specifies the base URI property of the
static context, which is used when resolving relative URIs within a
module.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>URILiteral</em> <a href=
"#jd_has_atomic_value" class="judgment"><b>has atomic value</b></a>
<em>AnyURI</em></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">1</font></sub> = <a href=
"#xq_stat_env_def" class="env">statEnv</a> + <a href=
"#xq_base_uri_env" class="env">baseURI</a>(<em>AnyURI</em>)</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> declare base-uri
<em>URILiteral</em> <a href="#jd_yields_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p><b><a href="#dyn_processing_context" class="processing">Dynamic
Context Processing</a></b></p>
<p>The base URI declaration does not affect the dynamic
context.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b>declare base-uri
<em>URILiteral</em> <a href="#jd_yields_dyn_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a>
<a href="#xq_dyn_env_def" class="env">dynEnv</a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
</div>
<div class="div2">
<h3><a name="sec_validation_decl" id="sec_validation_decl"></a>5.6
Construction Declaration</h3>
<h5><a name="d6e35001" id="d6e35001"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-ConstructionDecl" id=
"doc-xquery10-ConstructionDecl"></a>[<small>12&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-ConstructionDecl">ConstructionDecl</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "construction" ("strip" |
"preserve")</code></td>
</tr>
</tbody>
</table>
<p><b>Core Grammar</b></p>
<p>The core grammar production for construction declarations
is:</p>
<h5><a name="d6e35011" id="d6e35011"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-ConstructionDecl" id=
"doc-xcore-ConstructionDecl"></a>[<small>5&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-ConstructionDecl"></a><a href=
"#prod-xcore-ConstructionDecl">ConstructionDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "construction" ("strip" |
"preserve")</code></td>
</tr>
</tbody>
</table>
<p><b>Notation</b></p>
<p>For convenience, we introduce the following auxiliary grammar
production.</p>
<h5><a name="d6e35021" id="d6e35021"></a>Constr Mode</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-ConstructionMode" id=
"doc-fs-ConstructionMode"></a>[<small>89&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-ConstructionMode">ConstructionMode</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"preserve" | "strip"</code></td>
</tr>
</tbody>
</table>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>Construction declarations are left unchanged through
normalization.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>ConstructionDecl</em><font size=
"6">]</font><a href="#jd_map_prolog" class=
"judgment"><sub><font size="2">PrologDecl</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<em>ConstructionDecl</em></td>
</tr>
</table>
</div>
<p><b><a href="#processing_context" class="processing">Static
Context Processing</a></b></p>
<p>The construction declaration modifies the construction mode in
the static context.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">1</font></sub> = <a href=
"#xq_stat_env_def" class="env">statEnv</a> + <a href=
"#xq_construction_mode_env" class="env">constructionMode</a>(
<em>ConstructionMode</em>)</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>declare construction
<em>ConstructionMode</em> <a href="#jd_yields_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p><b><a href="#dyn_processing_context" class="processing">Dynamic
Context Processing</a></b></p>
<p>The construction declaration does not have any effect on the
dynamic context.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b>declare construction
<em>ConstructionMode</em> <a href="#jd_yields_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a>
<a href="#xq_dyn_env_def" class="env">dynEnv</a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
</div>
<div class="div2">
<h3><a name="id-default-ordering-decl" id=
"id-default-ordering-decl"></a>5.7 Ordering Mode Declaration</h3>
<h5><a name="d6e35124" id="d6e35124"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-OrderingModeDecl" id=
"doc-xquery10-OrderingModeDecl"></a>[<small>13&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-OrderingModeDecl">OrderingModeDecl</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "ordering" ("ordered" |
"unordered")</code></td>
</tr>
</tbody>
</table>
<p><b>Core Grammar</b></p>
<p>The core grammar production for ordering mode declarations
is:</p>
<h5><a name="d6e35134" id="d6e35134"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-OrderingModeDecl" id=
"doc-xcore-OrderingModeDecl"></a>[<small>6&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-OrderingModeDecl"></a><a href=
"#prod-xcore-OrderingModeDecl">OrderingModeDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "ordering" ("ordered" |
"unordered")</code></td>
</tr>
</tbody>
</table>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>Ordering mode declarations are left unchanged through
normalization.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>OrderingModeDecl</em><font size=
"6">]</font><a href="#jd_map_prolog" class=
"judgment"><sub><font size="2">PrologDecl</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<em>OrderingModeDecl</em></td>
</tr>
</table>
</div>
<p><b><a href="#processing_context" class="processing">Static
Context Processing</a></b></p>
<p>The ordering mode declaration does not have any effect on the
static context.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>OrderingModeDecl</em>
<a href="#jd_yields_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p><b><a href="#dyn_processing_context" class="processing">Dynamic
Context Processing</a></b></p>
<p>The ordering mode declaration does not have any effect on the
dynamic context.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>OrderingModeDecl</em>
<a href="#jd_yields_dyn_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a>
<a href="#xq_dyn_env_def" class="env">dynEnv</a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
</div>
<div class="div2">
<h3><a name="id-empty-order-decl" id="id-empty-order-decl"></a>5.8
Empty Order Declaration</h3>
<h5><a name="d6e35212" id="d6e35212"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-EmptyOrderDecl" id=
"doc-xquery10-EmptyOrderDecl"></a>[<small>14&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-EmptyOrderDecl">EmptyOrderDecl</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "default" "order" "empty" ("greatest" |
"least")</code></td>
</tr>
</tbody>
</table>
<p><b>Core Grammar</b></p>
<p>The core grammar production for empty order declarations is:</p>
<h5><a name="d6e35222" id="d6e35222"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-EmptyOrderDecl" id=
"doc-xcore-EmptyOrderDecl"></a>[<small>7&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-EmptyOrderDecl"></a><a href=
"#prod-xcore-EmptyOrderDecl">EmptyOrderDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "default" "order" "empty" ("greatest" |
"least")</code></td>
</tr>
</tbody>
</table>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>Empty order declarations are left unchanged through
normalization.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>EmptyOrderDecl</em><font size="6">]</font><a href=
"#jd_map_prolog" class="judgment"><sub><font size=
"2">PrologDecl</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<em>EmptyOrderDecl</em></td>
</tr>
</table>
</div>
<p><b><a href="#processing_context" class="processing">Static
Context Processing</a></b></p>
<p>The empty order declaration does not have any effect on the
static context.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>EmptyOrderDecl</em>
<a href="#jd_yields_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p><b><a href="#dyn_processing_context" class="processing">Dynamic
Context Processing</a></b></p>
<p>The empty order declaration does not have any effect on the
dynamic context.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>EmptyOrderDecl</em>
<a href="#jd_yields_dyn_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a>
<a href="#xq_dyn_env_def" class="env">dynEnv</a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
</div>
<div class="div2">
<h3><a name="id-copy-namespaces-decl" id=
"id-copy-namespaces-decl"></a>5.9 Copy-Namespaces Declaration</h3>
<h5><a name="d6e35300" id="d6e35300"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-CopyNamespacesDecl" id=
"doc-xquery10-CopyNamespacesDecl"></a>[<small>15&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-CopyNamespacesDecl">CopyNamespacesDecl</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "copy-namespaces" <a href=
"#doc-xquery10-PreserveMode">PreserveMode</a> "," <a href=
"#doc-xquery10-InheritMode">InheritMode</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-PreserveMode" id=
"doc-xquery10-PreserveMode"></a>[<small>16&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-PreserveMode">PreserveMode</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"preserve" | "no-preserve"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-InheritMode" id=
"doc-xquery10-InheritMode"></a>[<small>17&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-InheritMode">InheritMode</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"inherit" | "no-inherit"</code></td>
</tr>
</tbody>
</table>
<p><b>Core Grammar</b></p>
<p>The core grammar productions for copy-namespaces declarations
are:</p>
<h5><a name="d6e35325" id="d6e35325"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-CopyNamespacesDecl" id=
"doc-xcore-CopyNamespacesDecl"></a>[<small>8&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-CopyNamespacesDecl"></a><a href=
"#prod-xcore-CopyNamespacesDecl">CopyNamespacesDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "copy-namespaces" <a href=
"#doc-xcore-PreserveMode">PreserveMode</a> "," <a href=
"#doc-xcore-InheritMode">InheritMode</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-PreserveMode" id=
"doc-xcore-PreserveMode"></a>[<small>9&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-PreserveMode"></a><a href=
"#prod-xcore-PreserveMode">PreserveMode</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"preserve" | "no-preserve"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-InheritMode" id=
"doc-xcore-InheritMode"></a>[<small>10&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-InheritMode"></a><a href=
"#prod-xcore-InheritMode">InheritMode</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"inherit" | "no-inherit"</code></td>
</tr>
</tbody>
</table>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>Copy-namespace declarations are left unchanged through
normalization.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>CopyNamespacesDecl</em><font size=
"6">]</font><a href="#jd_map_prolog" class=
"judgment"><sub><font size="2">PrologDecl</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<em>CopyNamespacesDecl</em></td>
</tr>
</table>
</div>
<p><b><a href="#processing_context" class="processing">Static
Context Processing</a></b></p>
<p>The copy-namespace declaration does not have any effect on the
static context.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>CopyNamespacesDecl</em>
<a href="#jd_yields_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p><b><a href="#dyn_processing_context" class="processing">Dynamic
Context Processing</a></b></p>
<p>The copy-namespace declaration does not have any effect on the
dynamic context.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>CopyNamespacesDecl</em>
<a href="#jd_yields_dyn_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a>
<a href="#xq_dyn_env_def" class="env">dynEnv</a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
</div>
<div class="div2">
<h3><a name="sec_schema_imports" id="sec_schema_imports"></a>5.10
Schema Import</h3>
<h5><a name="d6e35419" id="d6e35419"></a>Schema Imports</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-SchemaImport" id=
"doc-xquery10-SchemaImport"></a>[<small>21&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-SchemaImport">SchemaImport</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"import" "schema" <a href=
"#doc-xquery10-SchemaPrefix">SchemaPrefix</a>? <a href=
"#doc-xquery10-URILiteral">URILiteral</a> ("at" <a href=
"#doc-xquery10-URILiteral">URILiteral</a> ("," <a href=
"#doc-xquery10-URILiteral">URILiteral</a>)*)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-SchemaPrefix" id=
"doc-xquery10-SchemaPrefix"></a>[<small>22&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-SchemaPrefix">SchemaPrefix</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("namespace" <a href="#prod-xquery10-NCName">NCName</a>
"=") | ("default" "element" "namespace")</code></td>
</tr>
</tbody>
</table>
<p>The semantics of Schema Import is described in terms of the
[XPath/XQuery] type system. The process of converting an XML Schema
into a sequence of type declarations is described in Section
<a href="#sec_importing_schema"><b>[D Importing Schemas]</b></a>.
This section describes how the resulting sequence of type
declarations is added into the static context when the Prolog is
processed.</p>
<p><b>Core Grammar</b></p>
<p>The Core grammar productions for schema imports are:</p>
<h5><a name="d6e35454" id="d6e35454"></a>Schema Imports</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-SchemaImport" id=
"doc-xcore-SchemaImport"></a>[<small>11&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-SchemaImport"></a><a href=
"#prod-xcore-SchemaImport">SchemaImport</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"import" "schema" <a href=
"#doc-xcore-SchemaPrefix">SchemaPrefix</a>? <a href=
"#doc-xcore-URILiteral">URILiteral</a> ("at" <a href=
"#doc-xcore-URILiteral">URILiteral</a> ("," <a href=
"#doc-xcore-URILiteral">URILiteral</a>)*)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-SchemaPrefix" id=
"doc-xcore-SchemaPrefix"></a>[<small>12&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-SchemaPrefix"></a><a href=
"#prod-xcore-SchemaPrefix">SchemaPrefix</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("namespace" <a href="#prod-xcore-NCName">NCName</a> "=")
| ("default" "element" "namespace")</code></td>
</tr>
</tbody>
</table>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>Schema imports are left unchanged through normalization.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>SchemaImport</em><font size="6">]</font><a href=
"#jd_map_prolog" class="judgment"><sub><font size=
"2">PrologDecl</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<em>SchemaImport</em></td>
</tr>
</table>
</div>
<p><b>Notation</b></p>
<p>For convenience, we introduce the following auxiliary grammar
productions.</p>
<h5><a name="d6e35505" id="d6e35505"></a>Location Hints</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-LocationHints" id=
"doc-fs-LocationHints"></a>[<small>16&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-LocationHints">LocationHints</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"at" URILiteral ("," URILiteral)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-OptLocationHints" id=
"doc-fs-OptLocationHints"></a>[<small>82&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-OptLocationHints">OptLocationHints</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-fs-LocationHints">LocationHints</a>?</code></td>
</tr>
</tbody>
</table>
<p><b>Notation</b></p>
<p id="jd_yields_type_context">The following auxiliary judgments
are used when processing schema imports.</p>
<p>The judgment:</p>
<div align="center"><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size=
"2">1</font></sub><b>&#160;|-&#160;</b><em>Definitions</em>
<a href="#jd_yields_type_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">type</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">2</font></sub></div>
<p>holds if under the static environment <a href="#xq_stat_env_def"
class="env">statEnv</a><sub><font size="2">1</font></sub>, the
sequence of type definitions <em>Definitions</em> yields the new
static environment <a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">2</font></sub>.</p>
<p>The judgment:</p>
<div align="center"><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size=
"2">1</font></sub><b>&#160;|-&#160;</b><a href=
"#sec_top_level_definitions"><em>Definition</em></a> <a href=
"#jd_yields_type_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">type</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">2</font></sub></div>
<p>holds if under the static environment <a href="#xq_stat_env_def"
class="env">statEnv</a><sub><font size="2">1</font></sub>, the
single definition <a href=
"#sec_top_level_definitions"><em>Definition</em></a> yields the new
static environment <a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">2</font></sub>.</p>
<p><b><a href="#processing_context" class="processing">Static
Context Processing</a></b></p>
<p>A schema imported into a query is first mapped into the
[XPath/XQuery] type system, which yields a sequence of XQuery type
definitions. The rules for mapping the imported schema begin in
<a href="#sec_schema_as_a_whole"><b>[D.2 Schemas as a
whole]</b></a>. Each type definition in an imported schema is then
added to the static environment.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><em>Definitions</em> = <font size="6">[</font>schema
<em>URILiteral</em> <em>OptLocationHints</em><font size=
"6">]</font><a href="#jd_map_schema" class=
"judgment"><sub><font size="2">Schema</font></sub></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>Definitions</em> <a href=
"#jd_yields_type_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">type</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>import schema
<em>URILiteral</em> <em>OptLocationHints</em> <a href=
"#jd_yields_context" class="judgment"><b>=&gt;</b><sub><font size=
"2">stat</font></sub></a> <a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">1</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>The schema import declaration may also assign an element/type
namespace prefix to the URI of the imported schema, or assign the
default element namespace to the URI of the imported schema.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><em>Definitions</em> = <font size="6">[</font>schema
<em>URILiteral</em> <em>OptLocationHints</em><font size=
"6">]</font><a href="#jd_map_schema" class=
"judgment"><sub><font size="2">Schema</font></sub></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>Definitions</em> <a href=
"#jd_yields_type_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">type</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>URILiteral</em> <a href=
"#jd_has_atomic_value" class="judgment"><b>has atomic value</b></a>
<em>AnyURI</em></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">2</font></sub> = <a href=
"#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">1</font></sub> + <a href="#xq_ns_env" class=
"env">namespace</a>(<em>NCName</em> =&gt; (passive,
<em>AnyURI</em>))</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>import schema namespace
<em>NCName</em> = <em>URILiteral</em> <em>OptLocationHints</em>
<a href="#jd_yields_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><em>Definitions</em> = <font size="6">[</font>schema
<em>URILiteral</em> <em>OptLocationHints</em><font size=
"6">]</font><a href="#jd_map_schema" class=
"judgment"><sub><font size="2">Schema</font></sub></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>Definitions</em> <a href=
"#jd_yields_type_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">type</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>URILiteral</em> <a href=
"#jd_has_atomic_value" class="judgment"><b>has atomic value</b></a>
<em>AnyURI</em></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">2</font></sub> = <a href=
"#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">1</font></sub> + <a href="#xq_default_elem_ns_env" class=
"env">default_elem_namespace</a>( <em>AnyURI</em>)</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>import schema default element
namespace <em>URILiteral</em> <em>OptLocationHints</em> <a href=
"#jd_yields_context" class="judgment"><b>=&gt;</b><sub><font size=
"2">stat</font></sub></a> <a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>An empty sequence of type definitions yields the input
environment.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#jd_yields_type_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">type</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>Each type definition is added into the static environment.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>Definitions</em> <a href=
"#jd_yields_type_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">type</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size=
"2">1</font></sub><b>&#160;|-&#160;</b><a href=
"#sec_top_level_definitions"><em>Definition</em></a><sub><font size="2">1</font></sub>
<a href="#jd_yields_type_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">type</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#sec_top_level_definitions"><em>Definition</em></a><sub><font size="2">1</font></sub>
<span>;</span> <em>Definitions</em> <a href=
"#jd_yields_type_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">type</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>Each type, element, or attribute declaration is added
respectively to the type, element and attribute declarations
components of the static environment.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-TypeName"><em>TypeName</em></a> <a href=
"#jd_elem_qname_expands_to" class="judgment"><b>of elem/type
expands to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">1</font></sub> = <a href=
"#xq_stat_env_def" class="env">statEnv</a> + <a href=
"#xq_type_defn" class="env">typeDefn</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a> =&gt; define type
<a href="#doc-fs-TypeName"><em>TypeName</em></a> <a href=
"#doc-fs-TypeDerivation"><em>TypeDerivation</em></a> )</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>define type <a href=
"#doc-fs-TypeName"><em>TypeName</em></a> <a href=
"#doc-fs-TypeDerivation"><em>TypeDerivation</em></a> <a href=
"#jd_yields_type_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">type</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-ElementName"><em>ElementName</em></a> <a href=
"#jd_elem_qname_expands_to" class="judgment"><b>of elem/type
expands to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">1</font></sub> = <a href=
"#xq_stat_env_def" class="env">statEnv</a> + <a href=
"#xq_elem_decl" class="env">elemDecl</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a> =&gt; define
element <a href="#doc-fs-ElementName"><em>ElementName</em></a>
<a href="#doc-fs-OptSubstitution"><em>OptSubstitution</em></a>
<a href="#doc-fs-OptNillable"><em>OptNillable</em></a> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a>)</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>define element <a href=
"#doc-fs-ElementName"><em>ElementName</em></a> <a href=
"#doc-fs-OptSubstitution"><em>OptSubstitution</em></a> <a href=
"#doc-fs-OptNillable"><em>OptNillable</em></a> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a> <a href=
"#jd_yields_type_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">type</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-AttributeName"><em>AttributeName</em></a> <a href=
"#jd_attr_qname_expands_to" class="judgment"><b>of attr expands
to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">1</font></sub> = <a href=
"#xq_stat_env_def" class="env">statEnv</a> + <a href=
"#xq_attr_decl" class="env">attrDecl</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a> =&gt; define
attribute <a href=
"#doc-fs-AttributeName"><em>AttributeName</em></a> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a>)</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>define attribute <a href=
"#doc-fs-AttributeName"><em>AttributeName</em></a> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a> <a href=
"#jd_yields_type_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">type</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>Note that it is a static error to import two schemas that both
define the same name in the same symbol space and in the same
scope. That is multiple top-level definitions of the same type,
element, or attribute name raises a static error. For instance, a
query may not import two schemas that include top-level element
declarations for two elements with the same expanded name.</p>
<p><b><a href="#dyn_processing_context" class="processing">Dynamic
Context Processing</a></b></p>
<p>The schema import declarations do not affect the dynamic
context.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>SchemaImport</em> <a href=
"#jd_yields_dyn_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a>
<a href="#xq_dyn_env_def" class="env">dynEnv</a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
</div>
<div class="div2">
<h3><a name="id-module-imports" id="id-module-imports"></a>5.11
Module Import</h3>
<h5><a name="d6e36265" id="d6e36265"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-ModuleImport" id=
"doc-xquery10-ModuleImport"></a>[<small>23&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-ModuleImport">ModuleImport</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"import" "module" ("namespace" <a href=
"#prod-xquery10-NCName">NCName</a> "=")? <a href=
"#doc-xquery10-URILiteral">URILiteral</a> ("at" <a href=
"#doc-xquery10-URILiteral">URILiteral</a> ("," <a href=
"#doc-xquery10-URILiteral">URILiteral</a>)*)?</code></td>
</tr>
</tbody>
</table>
<p><b>Introduction</b></p>
<p>The effect of an "import module" declaration is to extend the
importing module's dynamic (and static) context with the global
variables (and their types) and the functions (and their
signatures) of the imported module. Module import is not
transitive, only the global variables and functions declared
explicitly in the imported module are available in the importing
module. Also, module import does not import schemas, therefore the
importing module must explicitly import any schemas on which the
imported global variables or functions depend.</p>
<p><b>Core Grammar</b></p>
<p>The core grammar production for module imports is:</p>
<h5><a name="d6e36290" id="d6e36290"></a>Module Import</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-ModuleImport" id=
"doc-xcore-ModuleImport"></a>[<small>13&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-ModuleImport"></a><a href=
"#prod-xcore-ModuleImport">ModuleImport</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"import" "module" ("namespace" <a href=
"#prod-xcore-NCName">NCName</a> "=")? <a href=
"#doc-xcore-URILiteral">URILiteral</a> ("at" <a href=
"#doc-xcore-URILiteral">URILiteral</a> ("," <a href=
"#doc-xcore-URILiteral">URILiteral</a>)*)?</code></td>
</tr>
</tbody>
</table>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>Module imports are left unchanged through normalization.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>ModuleImport</em><font size="6">]</font><a href=
"#jd_map_prolog" class="judgment"><sub><font size=
"2">PrologDecl</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<em>ModuleImport</em></td>
</tr>
</table>
</div>
<p><b>Notation</b></p>
<p>The rules below depend on the following auxiliary functions
which are used to import the proper fragment of the static
context.</p>
<p id="fs_local_variables">The function <a href=
"#fs_local_variables"><em>fs:</em><code>local-variables</code></a>(<a href="#xq_stat_env_def"
class="env">statEnv</a>, <em>AnyURI</em>) returns all the (<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>, <a href=
"#doc-fs-Type"><em>Type</em></a>) pairs in <a href=
"#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env"
class="env">varType</a> such that the URI part of the variable's
expanded-QName equals the given URI, that is, the variables that
are declared locally in the module with the given namespace
URI.</p>
<p id="fs_local_functions">The function <a href=
"#fs_local_functions"><em>fs:</em><code>local-functions</code></a>(<a href="#xq_stat_env_def"
class="env">statEnv</a>, <em>AnyURI</em>) returns all the
<span>(<em>FunctionKey</em>, <em>FunctionSig</em>) pairs</span> in
<a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_functy_env" class="env">funcType</a> such that the URI part of
the function's expanded-QName equals the given URI, that is, the
function signatures that are declared locally in the module with
the given namespace URI.</p>
<p><b>Notation</b></p>
<p>The following auxiliary judgments is used to extend a given
static environment with the static environment from an imported
module.</p>
<p id="jd_extended_with_static_environment">The judgment</p>
<div align="center"><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">1</font></sub> <a href=
"#jd_extended_with_static_environment" class="judgment"><b>extended
with static environment</b></a> <a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">2</font></sub> <a href=
"#jd_extended_with_static_environment" class=
"judgment"><b>yields</b></a> <a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">3</font></sub> <a href=
"#jd_extended_with_static_environment" class="judgment"><b>for
uri</b></a> <em>AnyURI</em><sub><font size="2">1</font></sub></div>
<p>holds if extending the environment <a href="#xq_stat_env_def"
class="env">statEnv</a><sub><font size="2">1</font></sub> with the
environment <a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">2</font></sub> yields the
environment <a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">3</font></sub> under the given
namespace uri <em>AnyURI</em>.</p>
<p>This judgment is defined as follows.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href=
"#fs_local_variables"><em>fs:</em><code>local-variables</code></a>(<a href="#xq_stat_env_def"
class="env">statEnv</a><sub><font size="2">2</font></sub>,
<em>AnyURI</em>) = (<em>Variable</em><sub><font size=
"2">1</font></sub>,<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
... (<em>Variable</em><sub><font size="2">m</font></sub>,<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">m</font></sub>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">3</font></sub> = <a href=
"#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">1</font></sub> + <a href="#xq_type_env" class=
"env">varType</a>(<em>Variable</em><sub><font size=
"2">1</font></sub> =&gt; <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
... ; <em>Variable</em><sub><font size="2">m</font></sub> =&gt;
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">m</font></sub>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href=
"#fs_local_functions"><em>fs:</em><code>local-functions</code></a>(<a href="#xq_stat_env_def"
class="env">statEnv</a><sub><font size="2">2</font></sub>,
<em>AnyURI</em>) = (<span><em>FunctionKey</em><sub><font size=
"2">1</font></sub></span>,<em>FunctionSig</em><sub><font size=
"2">1</font></sub>) ... (<span><em>FunctionKey</em><sub><font size=
"2">n</font></sub></span>,<em>FunctionSig</em><sub><font size=
"2">n</font></sub>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">4</font></sub> = <a href=
"#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">3</font></sub> + <a href="#xq_functy_env" class=
"env">funcType</a>( <span><em>FunctionKey</em><sub><font size=
"2">1</font></sub></span> =&gt;
<em>FunctionSig</em><sub><font size="2">1</font></sub>; ... ;
<span><em>FunctionKey</em><sub><font size="2">n</font></sub></span>
=&gt; <em>FunctionSig</em><sub><font size="2">n</font></sub> )</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">1</font></sub> <a href=
"#jd_extended_with_static_environment" class="judgment"><b>extended
with static environment</b></a> <a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">2</font></sub> <a href=
"#jd_extended_with_static_environment" class=
"judgment"><b>yields</b></a> <a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">4</font></sub> <a href=
"#jd_extended_with_static_environment" class="judgment"><b>for
uri</b></a> <em>AnyURI</em><sub><font size="2">1</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p><b>Notation</b></p>
<p>The rules below depend on the following auxiliary judgments.</p>
<p id="jd_import_variables">The following rules add each variable
explicitly declared in the imported module to the importing
module's dynamic variable environment.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size="2">1</font></sub> ;
<em>AnyURI</em><b>&#160;|-&#160;</b><a href="#jd_import_variables"
class="judgment"><b>=&gt;</b><sub><font size=
"2">import_variables</font></sub></a> <a href="#xq_dyn_env_def"
class="env">dynEnv</a><sub><font size="2">1</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size="2">2</font></sub> = <a href=
"#xq_dyn_env_def" class="env">dynEnv</a><sub><font size=
"2">1</font></sub> + <a href="#xq_val_env" class=
"env">varValue</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size=
"2">1</font></sub> =&gt;
<code>#IMPORTED</code>(<em>AnyURI</em>))</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size="2">2</font></sub> ;
<em>AnyURI</em><b>&#160;|-&#160;</b>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size=
"2">2</font></sub>, <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>), ···, (<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size=
"2">n</font></sub>, <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>)
<a href="#jd_import_variables" class=
"judgment"><b>=&gt;</b><sub><font size=
"2">import_variables</font></sub></a> <a href="#xq_dyn_env_def"
class="env">dynEnv</a><sub><font size="2">3</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size="2">1</font></sub> ;
<em>AnyURI</em><b>&#160;|-&#160;</b>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size=
"2">1</font></sub>, <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>), ···, (<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size=
"2">n</font></sub>, <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>)
<a href="#jd_import_variables" class=
"judgment"><b>=&gt;</b><sub><font size=
"2">import_variables</font></sub></a> <a href="#xq_dyn_env_def"
class="env">dynEnv</a><sub><font size="2">3</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p id="jd_import_functions">The following rules add each function
explicitly declared in the imported module to the importing
module's dynamic function environment.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size="2">1</font></sub> ;
<em>AnyURI</em><b>&#160;|-&#160;</b><a href="#jd_import_functions"
class="judgment"><b>=&gt;</b><sub><font size=
"2">import_functions</font></sub></a> <a href="#xq_dyn_env_def"
class="env">dynEnv</a><sub><font size="2">1</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size="2">2</font></sub> = <a href=
"#xq_dyn_env_def" class="env">dynEnv</a><sub><font size=
"2">1</font></sub> + <a href="#xq_func_env" class=
"env">funcDefn</a>(<span><em>FunctionKey</em><sub><font size=
"2">1</font></sub></span> =&gt;
<code>#IMPORTED</code>(<em>AnyURI</em>))</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size="2">2</font></sub> ;
<em>AnyURI</em><b>&#160;|-&#160;</b>
<span>(<em>FunctionKey</em><sub><font size=
"2">2</font></sub>,<em>FunctionSig</em><sub><font size=
"2">2</font></sub>) ... (<em>FunctionKey</em><sub><font size=
"2">n</font></sub>,<em>FunctionSig</em><sub><font size=
"2">n</font></sub>)</span> <a href="#jd_import_functions" class=
"judgment"><b>=&gt;</b><sub><font size=
"2">import_functions</font></sub></a> <a href="#xq_dyn_env_def"
class="env">dynEnv</a><sub><font size="2">3</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size="2">1</font></sub> ;
<em>AnyURI</em><b>&#160;|-&#160;</b>
<span>(<em>FunctionKey</em><sub><font size=
"2">1</font></sub>,<em>FunctionSig</em><sub><font size=
"2">1</font></sub>) ... (<em>FunctionKey</em><sub><font size=
"2">n</font></sub>,<em>FunctionSig</em><sub><font size=
"2">n</font></sub>)</span> <a href="#jd_import_functions" class=
"judgment"><b>=&gt;</b><sub><font size=
"2">import_functions</font></sub></a> <a href="#xq_dyn_env_def"
class="env">dynEnv</a><sub><font size="2">3</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p><b>Notation</b></p>
<p>The following auxiliary judgments is used to extend a given
dynamic environment with the dynamic environment from an imported
module.</p>
<p id="jd_extended_with_dynamic_environment">The judgment</p>
<div align="center"><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size="2">1</font></sub> <a href=
"#jd_extended_with_dynamic_environment" class=
"judgment"><b>extended with dynamic environment</b></a> <a href=
"#xq_dyn_env_def" class="env">dynEnv</a><sub><font size=
"2">2</font></sub> <a href="#jd_extended_with_dynamic_environment"
class="judgment"><b>yields</b></a> <a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size="2">3</font></sub> <a href=
"#jd_extended_with_dynamic_environment" class="judgment"><b>for
uri</b></a> <em>AnyURI</em></div>
<p>holds if extending the dynamic environment <a href=
"#xq_dyn_env_def" class="env">dynEnv</a><sub><font size=
"2">1</font></sub> with the dynamic environment <a href=
"#xq_dyn_env_def" class="env">dynEnv</a><sub><font size=
"2">2</font></sub> yields the dynamic environment <a href=
"#xq_dyn_env_def" class="env">dynEnv</a><sub><font size=
"2">3</font></sub> under the given namespace uri
<em>AnyURI</em>.</p>
<p>This judgment is defined as follows.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size="2">1</font></sub> ;
<em>AnyURI</em><b>&#160;|-&#160;</b><a href=
"#fs_local_variables"><em>fs:</em><code>local-variables</code></a>(<a href="#xq_stat_env_def"
class="env">statEnv</a><sub><font size="2">2</font></sub>,
<em>AnyURI</em>) <a href="#jd_import_variables" class=
"judgment"><b>=&gt;</b><sub><font size=
"2">import_variables</font></sub></a> <a href="#xq_dyn_env_def"
class="env">dynEnv</a><sub><font size="2">3</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size="2">1</font></sub> ;
<em>AnyURI</em><b>&#160;|-&#160;</b><a href=
"#fs_local_variables"><em>fs:</em><code>local-variables</code></a>(<a href="#xq_stat_env_def"
class="env">statEnv</a><sub><font size="2">2</font></sub>,
<em>AnyURI</em>) <a href="#jd_import_variables" class=
"judgment"><b>=&gt;</b><sub><font size=
"2">import_variables</font></sub></a> <a href="#xq_dyn_env_def"
class="env">dynEnv</a><sub><font size="2">3</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size="2">3</font></sub> ;
<em>AnyURI</em><b>&#160;|-&#160;</b><a href=
"#fs_local_functions"><em>fs:</em><code>local-functions</code></a>(<a href="#xq_stat_env_def"
class="env">statEnv</a><sub><font size="2">2</font></sub>,
<em>AnyURI</em>) <a href="#jd_import_functions" class=
"judgment"><b>=&gt;</b><sub><font size=
"2">import_functions</font></sub></a> <a href="#xq_dyn_env_def"
class="env">dynEnv</a><sub><font size="2">4</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size="2">1</font></sub> <a href=
"#jd_extended_with_dynamic_environment" class=
"judgment"><b>extended with dynamic environment</b></a> <a href=
"#xq_dyn_env_def" class="env">dynEnv</a><sub><font size=
"2">2</font></sub> <a href="#jd_extended_with_dynamic_environment"
class="judgment"><b>yields</b></a> <a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size="2">4</font></sub> <a href=
"#jd_extended_with_dynamic_environment" class="judgment"><b>for
uri</b></a> <em>AnyURI</em></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p><b><a href="#processing_context" class="processing">Static
Context Processing</a></b></p>
<p>The first set of premises below "look up" the static contexts of
all the imported modules, as defined in <a href=
"#id-module-declaration"><b>[5.2 Module Declaration]</b></a>. The
second set of premises extend the input static context with the
global variables and function signatures declared in the imported
static contexts.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#jd_not" class=
"judgment"><b>not</b></a>(<em>AnyURI</em><sub><font size=
"2">1</font></sub> = <em>AnyURI</em>)</td>
</tr>
<tr align="center" valign="middle">
<td><em>AnyURI</em><sub><font size="2">1</font></sub> <a href=
"#jd_module_statEnv" class="judgment"><b>=&gt;</b><sub><font size=
"2">module_statEnv</font></sub></a> <a href="#xq_stat_env_def"
class="env">statEnv</a><sub><font size="2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a> <a href=
"#jd_extended_with_static_environment" class="judgment"><b>extended
with static environment</b></a> <a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">1</font></sub> <a href=
"#jd_extended_with_static_environment" class=
"judgment"><b>yields</b></a> <a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">2</font></sub> <a href=
"#jd_extended_with_static_environment" class="judgment"><b>for
uri</b></a> <em>AnyURI</em><sub><font size="2">1</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><em>AnyURI</em> ; <a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>import module
<em>AnyURI</em><sub><font size="2">1</font></sub>
<em>LocationHints</em>? <a href="#jd_yields_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><em>AnyURI</em><sub><font size="2">1</font></sub> =
<em>AnyURI</em></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><em>AnyURI</em> ; <a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>import module
<em>AnyURI</em><sub><font size="2">1</font></sub>
<em>LocationHints</em>? <a href="#jd_yields_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#jd_not" class=
"judgment"><b>not</b></a>(<em>AnyURI</em><sub><font size=
"2">1</font></sub> = <em>AnyURI</em>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>URILiteral</em><sub><font size="2">1</font></sub>
<a href="#jd_has_atomic_value" class="judgment"><b>has atomic
value</b></a> <em>AnyURI</em><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><em>AnyURI</em><sub><font size="2">1</font></sub> <a href=
"#jd_module_statEnv" class="judgment"><b>=&gt;</b><sub><font size=
"2">module_statEnv</font></sub></a> <a href="#xq_stat_env_def"
class="env">statEnv</a><sub><font size="2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a> <a href=
"#jd_extended_with_static_environment" class="judgment"><b>extended
with static environment</b></a> <a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">1</font></sub> <a href=
"#jd_extended_with_static_environment" class=
"judgment"><b>yields</b></a> <a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">2</font></sub> <a href=
"#jd_extended_with_static_environment" class="judgment"><b>for
uri</b></a> <em>AnyURI</em><sub><font size="2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">3</font></sub> = <a href=
"#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">2</font></sub> + <a href="#xq_ns_env" class=
"env">namespace</a>(<em>NCName</em> =&gt; (passive,
<em>AnyURI</em>))</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>import module namespace
<em>NCName</em> = <em>URILiteral</em><sub><font size=
"2">1</font></sub> <em>LocationHints</em>? <a href=
"#jd_yields_context" class="judgment"><b>=&gt;</b><sub><font size=
"2">stat</font></sub></a> <a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">3</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><em>AnyURI</em><sub><font size="2">1</font></sub> =
<em>AnyURI</em></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>URILiteral</em><sub><font size="2">1</font></sub>
<a href="#jd_has_atomic_value" class="judgment"><b>has atomic
value</b></a> <em>AnyURI</em><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">2</font></sub> = <a href=
"#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">1</font></sub> + <a href="#xq_ns_env" class=
"env">namespace</a>(<em>NCName</em> =&gt; (passive,
<em>AnyURI</em>))</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>import module namespace
<em>NCName</em> = <em>URILiteral</em><sub><font size=
"2">1</font></sub> <em>LocationHints</em>? <a href=
"#jd_yields_context" class="judgment"><b>=&gt;</b><sub><font size=
"2">stat</font></sub></a> <a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>Note that the rules above and the rules for processing a library
module in <a href="#id-module-declaration"><b>[5.2 Module
Declaration]</b></a> above are mutually recursive. It is possible
to define the semantics in that way, since XQuery forbids the use
of recursive modules.</p>
<p><b><a href="#dyn_processing_context" class="processing">Dynamic
Context Processing</a></b></p>
<p>During dynamic context processing, each variable and function
name is mapped to the special value
<code>#IMPORTED</code>(<em>AnyURI</em>) to indicate that the
variable or function is defined in the imported module with the
given URI.</p>
<p>The first set of premises below "look up" the dynamic contexts
of all the imported modules, as defined in <a href=
"#id-module-declaration"><b>[5.2 Module Declaration]</b></a>. The
second set of premises extend the input dynamic context with the
global variables and functions declared in the imported dynamic
contexts.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>URILiteral</em> <a href=
"#jd_has_atomic_value" class="judgment"><b>has atomic value</b></a>
<em>AnyURI</em></td>
</tr>
<tr align="center" valign="middle">
<td><em>AnyURI</em> <a href="#jd_module_dynEnv" class=
"judgment"><b>=&gt;</b><sub><font size=
"2">module_dynEnv</font></sub></a> <a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size="2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td>...</td>
</tr>
<tr align="center" valign="middle">
<td><em>AnyURI</em> <a href="#jd_module_dynEnv" class=
"judgment"><b>=&gt;</b><sub><font size=
"2">module_dynEnv</font></sub></a> <a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size="2">n</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a> <a href=
"#jd_extended_with_dynamic_environment" class=
"judgment"><b>extended with dynamic environment</b></a> <a href=
"#xq_dyn_env_def" class="env">dynEnv</a><sub><font size=
"2">1</font></sub> <a href="#jd_extended_with_dynamic_environment"
class="judgment"><b>yields</b></a> <a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size="2">1</font></sub>' <a href=
"#jd_extended_with_dynamic_environment" class="judgment"><b>for
uri</b></a> <em>AnyURI</em></td>
</tr>
<tr align="center" valign="middle">
<td>...</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size="2">n-1</font></sub> <a href=
"#jd_extended_with_dynamic_environment" class=
"judgment"><b>extended with dynamic environment</b></a> <a href=
"#xq_dyn_env_def" class="env">dynEnv</a><sub><font size=
"2">n</font></sub> <a href="#jd_extended_with_dynamic_environment"
class="judgment"><b>yields</b></a> <a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size="2">n</font></sub>' <a href=
"#jd_extended_with_dynamic_environment" class="judgment"><b>for
uri</b></a> <em>AnyURI</em></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size="2">1</font></sub><b>&#160;|-&#160;</b>import
module (namespace <em>NCName</em> =)? <em>URILiteral</em>
<em>LocationHints</em>? <a href="#jd_yields_dyn_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a>
<a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size=
"2">n</font></sub>'</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>Note that the rule above and the rules for processing a library
module in <a href="#id-module-declaration"><b>[5.2 Module
Declaration]</b></a> above are mutually recursive. It is possible
to define the semantics in that way, since XQuery forbids the use
of recursive modules.</p>
</div>
<div class="div2">
<h3><a name="sec_namespace_decls" id="sec_namespace_decls"></a>5.12
Namespace Declaration</h3>
<h5><a name="d6e37733" id="d6e37733"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-NamespaceDecl" id=
"doc-xquery10-NamespaceDecl"></a>[<small>24&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-NamespaceDecl">NamespaceDecl</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "namespace" <a href=
"#prod-xquery10-NCName">NCName</a> "=" <a href=
"#doc-xquery10-URILiteral">URILiteral</a></code></td>
</tr>
</tbody>
</table>
<p><b>Core Grammar</b></p>
<p>The core grammar production for namespace declarations is:</p>
<h5><a name="d6e37748" id="d6e37748"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-NamespaceDecl" id=
"doc-xcore-NamespaceDecl"></a>[<small>14&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-NamespaceDecl"></a><a href=
"#prod-xcore-NamespaceDecl">NamespaceDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "namespace" <a href=
"#prod-xcore-NCName">NCName</a> "=" <a href=
"#doc-xcore-URILiteral">URILiteral</a></code></td>
</tr>
</tbody>
</table>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>Namespace declarations are left unchanged through
normalization.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>NamespaceDecl</em><font size="6">]</font><a href=
"#jd_map_prolog" class="judgment"><sub><font size=
"2">PrologDecl</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<em>NamespaceDecl</em></td>
</tr>
</table>
</div>
<p><b><a href="#processing_context" class="processing">Static
Context Processing</a></b></p>
<p>A namespace declaration adds a new (prefix,uri) binding in the
namespace component of the static environment. All namespace
declarations in the prolog are <b>passive</b> declarations.
Namespace declaration attributes of element constructors are
<b>active</b> declarations.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>URILiteral</em> <a href=
"#jd_has_atomic_value" class="judgment"><b>has atomic value</b></a>
<em>AnyURI</em></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">1</font></sub> = <a href=
"#xq_stat_env_def" class="env">statEnv</a> + <a href="#xq_ns_env"
class="env">namespace</a>(<em>NCName</em> =&gt; (passive,
<em>AnyURI</em>))</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>declare namespace
<em>NCName</em> = <em>URILiteral</em> <a href="#jd_yields_context"
class="judgment"><b>=&gt;</b><sub><font size=
"2">stat</font></sub></a> <a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">1</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>In case the <em>URILiteral</em> part of a namespace declaration
is a zero-length string, the namespace prefix is marked as
#UNDECLARED in the static context.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">1</font></sub> = <a href=
"#xq_stat_env_def" class="env">statEnv</a> + <a href="#xq_ns_env"
class="env">namespace</a>(<em>NCName</em> =&gt; (passive,
#UNDECLARED))</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>declare namespace
<em>NCName</em> = "" <a href="#jd_yields_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p><b><a href="#dyn_processing_context" class="processing">Dynamic
Context Processing</a></b></p>
<p>The namespace declaration does not affect the dynamic
context.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b>declare namespace
<em>NCName</em> = <em>URILiteral</em> <a href=
"#jd_yields_dyn_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a>
<a href="#xq_dyn_env_def" class="env">dynEnv</a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
</div>
<div class="div2">
<h3><a name="sec_default_namespace_decls" id=
"sec_default_namespace_decls"></a>5.13 Default Namespace
Declaration</h3>
<h5><a name="d6e37937" id="d6e37937"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-DefaultNamespaceDecl" id=
"doc-xquery10-DefaultNamespaceDecl"></a>[<small>25&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-DefaultNamespaceDecl">DefaultNamespaceDecl</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "default" ("element" | "function") "namespace"
<a href="#doc-xquery10-URILiteral">URILiteral</a></code></td>
</tr>
</tbody>
</table>
<p><b>Core Grammar</b></p>
<p>The core grammar production for default namespace declarations
is:</p>
<h5><a name="d6e37949" id="d6e37949"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-DefaultNamespaceDecl" id=
"doc-xcore-DefaultNamespaceDecl"></a>[<small>15&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-DefaultNamespaceDecl"></a><a href=
"#prod-xcore-DefaultNamespaceDecl">DefaultNamespaceDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "default" ("element" | "function") "namespace"
<a href="#doc-xcore-URILiteral">URILiteral</a></code></td>
</tr>
</tbody>
</table>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>Default namespace declarations are left unchanged through
normalization.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>DefaultNamespaceDecl</em><font size=
"6">]</font><a href="#jd_map_prolog" class=
"judgment"><sub><font size="2">PrologDecl</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<em>DefaultNamespaceDecl</em></td>
</tr>
</table>
</div>
<p><b><a href="#processing_context" class="processing">Static
Context Processing</a></b></p>
<p>A default element namespace declaration changes the default
element namespace component of the static environment. If the URI
literal is the zero-length string, the default element namespace is
set to the null namespace.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">1</font></sub> = <a href=
"#xq_stat_env_def" class="env">statEnv</a> + <a href=
"#xq_default_elem_ns_env" class=
"env">default_elem_namespace</a>(#NULL-NAMESPACE)</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>declare default element
namespace "" <a href="#jd_yields_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#jd_not" class=
"judgment"><b>not</b></a>(<em>URILiteral</em> = "")</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>URILiteral</em> <a href=
"#jd_has_atomic_value" class="judgment"><b>has atomic value</b></a>
<em>AnyURI</em></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">1</font></sub> = <a href=
"#xq_stat_env_def" class="env">statEnv</a> + <a href=
"#xq_default_elem_ns_env" class="env">default_elem_namespace</a>(
<em>AnyURI</em>)</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>declare default element
namespace <em>URILiteral</em> <a href="#jd_yields_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>A default function namespace declaration changes the default
function namespace component of the static environment. If the URI
literal is the zero-length string, the default function namespace
is set to the null namespace.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">1</font></sub> = <a href=
"#xq_stat_env_def" class="env">statEnv</a> + <a href=
"#xq_default_fn_ns_env" class=
"env">default_function_namespace</a>(#NULL-NAMESPACE)</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>declare default function
namespace "" <a href="#jd_yields_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#jd_not" class=
"judgment"><b>not</b></a>(<em>URILiteral</em> = "")</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>URILiteral</em> <a href=
"#jd_has_atomic_value" class="judgment"><b>has atomic value</b></a>
<em>AnyURI</em></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">1</font></sub> = <a href=
"#xq_stat_env_def" class="env">statEnv</a> + <a href=
"#xq_default_fn_ns_env" class="env">default_function_namespace</a>(
<em>AnyURI</em>)</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>declare default function
namespace <em>URILiteral</em> <a href="#jd_yields_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>Note that multiple declarations of the same namespace prefix in
the Prolog result in a static error. However, a declaration of a
namespace in the Prolog can override a prefix that has been
predeclared in the static context.</p>
<p><b><a href="#dyn_processing_context" class="processing">Dynamic
Context Processing</a></b></p>
<p>Default namespace declarations do not affect the dynamic
context.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>DefaultNamespaceDecl</em>
<a href="#jd_yields_dyn_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a>
<a href="#xq_dyn_env_def" class="env">dynEnv</a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
</div>
<div class="div2">
<h3><a name="sec_variable-declarations" id=
"sec_variable-declarations"></a>5.14 Variable Declaration</h3>
<h5><a name="d6e38232" id="d6e38232"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-VarDecl" id=
"doc-xquery10-VarDecl"></a>[<small>28&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-VarDecl">VarDecl</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "variable" "$" _QName_or_EQName <a href=
"#doc-xquery10-VarName">VarName</a> <a href=
"#doc-xquery10-TypeDeclaration">TypeDeclaration</a>? ((":="
<a href="#doc-xquery10-ExprSingle">ExprSingle</a> VarValue) |
("external" (":=" VarDefaultValue)?))</code></td>
</tr>
</tbody>
</table>
<p><b>Core Grammar</b></p>
<p>The core grammar production for variable declarations is:</p>
<h5><a name="d6e38261" id="d6e38261"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-VarDecl" id=
"doc-xcore-VarDecl"></a>[<small>16&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-VarDecl"></a><a href=
"#prod-xcore-VarDecl">VarDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "variable" "$" _QName_or_EQName <a href=
"#doc-xcore-TypeDeclaration">TypeDeclaration</a>? ((":=" <a href=
"#doc-xcore-ExprSingle">ExprSingle</a>) | "external")</code></td>
</tr>
</tbody>
</table>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>Normalization of a variable declaration normalizes its
initializing expression, if it is present.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font> declare variable $<em>VarName</em> as
<em>SequenceType</em> := <em>Expr</em> <font size=
"6">]</font><a href="#jd_map_prolog" class=
"judgment"><sub><font size="2">PrologDecl</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">declare variable
$<em>VarName</em> as <em>SequenceType</em> := <font size=
"6">[</font><em>Expr</em><font size="6">]</font><a href=
"#jd_map_expr" class="judgment"><sub><font size=
"2">Expr</font></sub></a></td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font> declare variable $<em>VarName</em> := <em>Expr</em>
<font size="6">]</font><a href="#jd_map_prolog" class=
"judgment"><sub><font size="2">PrologDecl</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">declare variable
$<em>VarName</em> := <font size=
"6">[</font><em>Expr</em><font size="6">]</font><a href=
"#jd_map_expr" class="judgment"><sub><font size=
"2">Expr</font></sub></a></td>
</tr>
</table>
</div>
<p>If an external variable declaration does not have a type
declaration it is treated as if the type declaration was
<code>item()*</code>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font> declare variable $<em>VarName</em> external
<font size="6">]</font><a href="#jd_map_prolog" class=
"judgment"><sub><font size="2">PrologDecl</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">declare variable
$<em>VarName</em> as item()* external</td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font> declare variable $<em>VarName</em> as
<em>SequenceType</em> external <font size="6">]</font><a href=
"#jd_map_prolog" class="judgment"><sub><font size=
"2">PrologDecl</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">declare variable
$<em>VarName</em> as <em>SequenceType</em> external</td>
</tr>
</table>
</div>
<p><b><a href="#processing_context" class="processing">Static
Context Processing</a></b></p>
<p>A variable declaration updates the variable component of the
static context by associating the given variable with a static
type.</p>
<p>If a variable declaration has an associated expression but does
not have a type declaration, the static type of the variable is the
static type of the expression.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>VarName</em> <a href=
"#jd_var_qname_expands_to" class="judgment"><b>of var expands
to</b></a> <em>Variable</em></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <em>Expr</em> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">1</font></sub> = <a href=
"#xq_stat_env_def" class="env">statEnv</a> + <a href="#xq_type_env"
class="env">varType</a>( <em>Variable</em> =&gt; <a href=
"#doc-fs-Type"><em>Type</em></a>)</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>declare variable
$<em>VarName</em> := <em>Expr</em> <a href="#jd_yields_context"
class="judgment"><b>=&gt;</b><sub><font size=
"2">stat</font></sub></a> <a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">1</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>If the variable declaration has an associated expression and has
a type declaration, the static type of the variable is the
specified type. The type of the expression must be a subtype of the
declared type.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>VarName</em> <a href=
"#jd_var_qname_expands_to" class="judgment"><b>of var expands
to</b></a> <em>Variable</em></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a> = <font size=
"6">[</font><em>SequenceType</em><font size="6">]</font><a href=
"#jd_map_sequencetype" class="judgment"><sub><font size=
"2">sequencetype</font></sub></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>Expr</em> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">1</font></sub> = <a href=
"#xq_stat_env_def" class="env">statEnv</a> + <a href="#xq_type_env"
class="env">varType</a>( <em>Variable</em> =&gt; <a href=
"#doc-fs-Type"><em>Type</em></a>)</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>declare variable
$<em>VarName</em> as <em>SequenceType</em> := <em>Expr</em>
<a href="#jd_yields_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a>
<span><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">2</font></sub></span>
<span><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">1</font></sub></span></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>If the variable declaration is external and has a type
declaration, the static type of the variable is the specified
type.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>VarName</em> <a href=
"#jd_var_qname_expands_to" class="judgment"><b>of var expands
to</b></a> <em>Variable</em></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a> = <font size=
"6">[</font><em>SequenceType</em><font size="6">]</font><a href=
"#jd_map_sequencetype" class="judgment"><sub><font size=
"2">sequencetype</font></sub></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">1</font></sub> = <a href=
"#xq_stat_env_def" class="env">statEnv</a> + <a href="#xq_type_env"
class="env">varType</a>( <em>Variable</em> =&gt; <a href=
"#doc-fs-Type"><em>Type</em></a>)</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>declare variable
$<em>VarName</em> as <em>SequenceType</em> external <a href=
"#jd_yields_context" class="judgment"><b>=&gt;</b><sub><font size=
"2">stat</font></sub></a> <span><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">2</font></sub></span>
<span><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">1</font></sub></span></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p><b><a href="#dyn_processing_context" class="processing">Dynamic
Context Processing</a></b></p>
<p>To evaluate a variable declaration, its associated expression is
evaluated, and the dynamic context is updated with the variable
bound to the resulting value.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>Expr</em> <a href=
"#jd_yields" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>VarName</em> <a href=
"#jd_var_qname_expands_to" class="judgment"><b>of var expands
to</b></a> <em>Variable</em></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size="2">1</font></sub> = <a href=
"#xq_dyn_env_def" class="env">dynEnv</a> + <a href="#xq_val_env"
class="env">varValue</a>( <em>Variable</em> =&gt; <a href=
"#doc-fs-Value"><em>Value</em></a>)</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b>declare variable
$<em>VarName</em> := <em>Expr</em> <a href="#jd_yields_dyn_context"
class="judgment"><b>=&gt;</b><sub><font size=
"2">dyn</font></sub></a> <a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size="2">1</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>Expr</em> <a href=
"#jd_yields" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a> = <font size=
"6">[</font> <em>SequenceType</em> <font size="6">]</font><a href=
"#jd_map_sequencetype" class="judgment"><sub><font size=
"2">sequencetype</font></sub></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <a href="#doc-fs-Value"><em>Value</em></a>
<a href="#jd_matches" class="judgment"><b>matches</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>VarName</em> <a href=
"#jd_var_qname_expands_to" class="judgment"><b>of var expands
to</b></a> <em>Variable</em></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size="2">1</font></sub> = <a href=
"#xq_dyn_env_def" class="env">dynEnv</a> + <a href="#xq_val_env"
class="env">varValue</a>( <em>Variable</em> =&gt; <a href=
"#doc-fs-Value"><em>Value</em></a>)</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b>declare variable
$<em>VarName</em> as <em>SequenceType</em> := <em>Expr</em>
<a href="#jd_yields_dyn_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a>
<a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>Dynamic evaluation does not apply to externally defined
variables. The dynamic environment must provide the values of
external variables in the initial dynamic context (<a href=
"#xq_default_dyn_env" class="env">dynEnvDefault</a>).</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b>declare variable
$<em>VarName</em> as <em>SequenceType</em> external <a href=
"#jd_yields_dyn_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a>
<a href="#xq_dyn_env_def" class="env">dynEnv</a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
</div>
<div class="div2">
<h3><a name="sec_FunctionDeclns" id="sec_FunctionDeclns"></a>5.15
Function Declaration</h3>
<p><b>Introduction</b></p>
<p>User-defined functions specify the name of the function, the
names and types of the parameters, and the type of the result. The
<b>function body</b> defines how the result of the function is
computed from its parameters.</p>
<h5><a name="d6e38957" id="d6e38957"></a>Function declarations</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-FunctionDecl" id=
"doc-xquery10-FunctionDecl"></a>[<small>32&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-FunctionDecl">FunctionDecl</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "function" _Function_QName_or_EQName "("
<a href="#doc-xquery10-ParamList">ParamList</a>? ")" ("as" <a href=
"#doc-xquery10-SequenceType">SequenceType</a>)? (<a href=
"#doc-xquery10-EnclosedExpr">EnclosedExpr</a> | FunctionBody |
"external")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-ParamList" id=
"doc-xquery10-ParamList"></a>[<small>33&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-ParamList">ParamList</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xquery10-Param">Param</a> ("," <a href=
"#doc-xquery10-Param">Param</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-Param" id=
"doc-xquery10-Param"></a>[<small>34&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-Param">Param</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"$" _QName_or_EQName <a href=
"#doc-xquery10-TypeDeclaration">TypeDeclaration</a>?</code></td>
</tr>
</tbody>
</table>
<p><b>Core Grammar</b></p>
<p>The core grammar productions for function declarations are:</p>
<h5><a name="d6e39004" id="d6e39004"></a>Function declarations</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-FunctionDecl" id=
"doc-xcore-FunctionDecl"></a>[<small>17&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-FunctionDecl"></a><a href=
"#prod-xcore-FunctionDecl">FunctionDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "function" _Function_QName_or_EQName "("
<a href="#doc-xcore-ParamList">ParamList</a>? ")" ("as" <a href=
"#doc-xcore-SequenceType">SequenceType</a>)? (<a href=
"#doc-xcore-EnclosedExpr">EnclosedExpr</a> |
"external")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-ParamList" id=
"doc-xcore-ParamList"></a>[<small>18&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-ParamList"></a><a href=
"#prod-xcore-ParamList">ParamList</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-Param">Param</a> ("," <a href=
"#doc-xcore-Param">Param</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-Param" id=
"doc-xcore-Param"></a>[<small>19&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-Param"></a><a href=
"#prod-xcore-Param">Param</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"$" _QName_or_EQName <a href=
"#doc-xcore-TypeDeclaration">TypeDeclaration</a>?</code></td>
</tr>
</tbody>
</table>
<p><b>Notation</b></p>
<p id="jd_map_param">The following auxiliary mapping rule is used
for the normalization of parameters in function declarations:
<font size="6">[</font><font size="6">]</font><a href=
"#jd_map_param" class="judgment"><sub><font size=
"2">Param</font></sub></a>.</p>
<p>Parameters without a declared type are given the item()*
sequence type.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>$<em>VarName</em><font size="6">]</font><a href=
"#jd_map_param" class="judgment"><sub><font size=
"2">Param</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">$<em>VarName</em> as
item()*</td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>$<em>VarName</em> as <em>SequenceType</em> <font size=
"6">]</font><a href="#jd_map_param" class=
"judgment"><sub><font size="2">Param</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">$<em>VarName</em> as
<em>SequenceType</em></td>
</tr>
</table>
</div>
<p>An empty parameter list is left unchanged.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><font size="6">]</font><a href="#jd_map_param" class=
"judgment"><sub><font size="2">Param</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"></td>
</tr>
</table>
</div>
<p>A parameter list is normalized by applying the normalization
rule to each parameter.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font> <em>Param</em><sub><font size="2">1</font></sub>, ...,
<em>Param</em><sub><font size="2">n</font></sub> <font size=
"6">]</font><a href="#jd_map_param" class=
"judgment"><sub><font size="2">Param</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font> <em>Param</em><sub><font size="2">1</font></sub>
<font size="6">]</font><a href="#jd_map_param" class=
"judgment"><sub><font size="2">Param</font></sub></a>, ...,
<font size="6">[</font> <em>Param</em><sub><font size=
"2">n</font></sub> <font size="6">]</font><a href="#jd_map_param"
class="judgment"><sub><font size="2">Param</font></sub></a></td>
</tr>
</table>
</div>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>The parameter list and body of a user-defined function are all
normalized into Core expressions.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>QName</em> <a href=
"#jd_func_qname_expands_to" class="judgment"><b>of func expands
to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a> = <font size=
"6">[</font><em>SequenceType</em><font size="6">]</font><a href=
"#jd_map_sequencetype" class="judgment"><sub><font size=
"2">sequencetype</font></sub></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><font size="6">[</font>
declare function <em>QName</em> ( <em>ParamList</em>? ) as
<em>SequenceType</em> { <em>Expr</em> } <font size=
"6">]</font><a href="#jd_map_prolog" class=
"judgment"><sub><font size="2">PrologDecl</font></sub></a> =
declare function <em>QName</em> ( <font size=
"6">[</font><em>ParamList</em>?<font size="6">]</font><a href=
"#jd_map_param" class="judgment"><sub><font size=
"2">Param</font></sub></a> ) as <em>SequenceType</em> { <font size=
"6">[</font><em>Expr</em><font size="6">]</font><a href=
"#jd_map_function_argument" class="judgment"><sub><font size=
"2">FunctionArgument(Type)</font></sub></a> }</td>
</tr>
</table>
<br /></div>
<p>If the return type of the function is not provided, it is given
the <code>item()*</code> sequence type.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>declare function <em>QName</em> ( <em>ParamList</em>? )
{ <em>Expr</em> }<font size="6">]</font><a href="#jd_map_prolog"
class="judgment"><sub><font size=
"2">PrologDecl</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>declare function <em>QName</em> ( <em>ParamList</em>? )
as item()* { <em>Expr</em> }<font size="6">]</font><a href=
"#jd_map_prolog" class="judgment"><sub><font size=
"2">PrologDecl</font></sub></a></td>
</tr>
</table>
</div>
<p>Externally defined functions are normalized similarly.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font> declare function <em>QName</em> ( <em>ParamList</em>?
) as <em>SequenceType</em> external<font size="6">]</font><a href=
"#jd_map_prolog" class="judgment"><sub><font size=
"2">PrologDecl</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">declare function
<em>QName</em>( <font size=
"6">[</font><em>ParamList</em>?<font size="6">]</font><a href=
"#jd_map_param" class="judgment"><sub><font size=
"2">Param</font></sub></a> ) as <em>SequenceType</em> external</td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>declare function <em>QName</em> ( <em>ParamList</em>? )
external <font size="6">]</font><a href="#jd_map_prolog" class=
"judgment"><sub><font size="2">PrologDecl</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>declare function <em>QName</em> ( <em>ParamList</em>? )
as item()* external <font size="6">]</font><a href="#jd_map_prolog"
class="judgment"><sub><font size=
"2">PrologDecl</font></sub></a></td>
</tr>
</table>
</div>
<p><b>Notation</b></p>
<p>We use the following auxiliary judgment during static context
processing and static type analysis of function declarations.</p>
<p id="jd_function_declaration">The judgment:</p>
<div align="center"><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#jd_function_declaration" class="judgment"><b>function
declaration</b></a> <em>FunctionDecl</em> <a href=
"#jd_function_declaration" class="judgment"><b>with
signature</b></a> <em>FunctionSig</em> <a href=
"#jd_function_declaration" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></div>
<p>holds if the function declaration <em>FunctionDecl</em> with the
signature <em>FunctionSig</em> has the type <a href=
"#doc-fs-Type"><em>Type</em></a>.</p>
<p><b><a href="#processing_context" class="processing">Static
Context Processing</a></b></p>
<p>Static context processing accesses the function signature from
the static context, and checks that the function declaration
corresponds to the declared type.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_functy_env" class="env">funcType</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>,n) =
<em>FunctionSig</em></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#jd_function_declaration" class="judgment"><b>function
declaration</b></a> <em>FunctionDecl</em> <a href=
"#jd_function_declaration" class="judgment"><b>with
signature</b></a> <em>FunctionSig</em> <a href=
"#jd_function_declaration" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">r</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <em>FunctionDecl</em>
<a href="#jd_yields_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
<br /></div>
<p>Note that the static context processing is performing type
checking of the function, as defined below. Note also that the type
checking is done in the new environment in which the function
declaration has been added which ensures that recursive calls are
type-checked properly.</p>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>The static typing rules for function bodies follow normalization
and processing of the static context. The static typing rules below
construct a new environment in which each parameter has the given
expected type, then the static type of the function's body is
computed under the new environment. The function body's type must
be a subtype of the expected return type. If static typing fails, a
static type error is raised. Otherwise, static typing of the
function has no other effect, as function signatures are already
inside the static environment.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_type_env" class=
"env">varType</a><b>&#160;|-&#160;</b><em>Expr</em> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a> <a href="#jd_subtype_of" class=
"judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">r</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#jd_function_declaration" class="judgment"><b>function
declaration</b></a> declare function <em>QName</em> () as
<em>SequenceType</em><sub><font size="2">r</font></sub> {
<em>Expr</em> } <a href="#jd_function_declaration" class=
"judgment"><b>with signature</b></a> declare function <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>() as <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">r</font></sub>
<a href="#jd_function_declaration" class="judgment"><b>:</b></a>
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">r</font></sub></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>VarName</em><sub><font size=
"2">1</font></sub> <a href="#jd_var_qname_expands_to" class=
"judgment"><b>of var expands to</b></a>
<em>Variable</em><sub><font size="2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td>...</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>VarName</em><sub><font size=
"2">n</font></sub> <a href="#jd_var_qname_expands_to" class=
"judgment"><b>of var expands to</b></a>
<em>Variable</em><sub><font size="2">n</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a> + <a href=
"#xq_type_env" class="env">varType</a>(
<em>Variable</em><sub><font size="2">1</font></sub> =&gt; <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
;...; <em>Variable</em><sub><font size="2">n</font></sub> =&gt;
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">n</font></sub> ) <b>&#160;|-&#160;</b><em>Expr</em> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a> <a href="#jd_can_be_promoted_to"
class="judgment"><b>can be promoted to</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">r</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#jd_function_declaration" class="judgment"><b>function
declaration</b></a> declare function <em>QName</em>
($<em>VarName</em><sub><font size="2">1</font></sub> as
<em>SequenceType</em><sub><font size="2">1</font></sub>, ···,
$<em>VarName</em><sub><font size="2">n</font></sub> as
<em>SequenceType</em><sub><font size="2">n</font></sub>) as
<em>SequenceType</em><sub><font size="2">r</font></sub> {
<em>Expr</em> } <a href="#jd_function_declaration" class=
"judgment"><b>with signature</b></a> declare function <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,
..., <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">n</font></sub>) as <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">r</font></sub>
<a href="#jd_function_declaration" class="judgment"><b>:</b></a>
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">r</font></sub></td>
</tr>
</table>
<br /></div>
<p>The bodies of external functions are not available and therefore
cannot by type checked. To ensure type soundness, the
implementation must guarantee that the value returned by the
external function matches the expected return type.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#jd_function_declaration" class="judgment"><b>function
declaration</b></a> declare function <em>QName</em> () as
<em>SequenceType</em><sub><font size="2">r</font></sub> external
<a href="#jd_function_declaration" class="judgment"><b>with
signature</b></a> declare function <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>() as <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">r</font></sub>
<a href="#jd_function_declaration" class="judgment"><b>:</b></a>
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">r</font></sub></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>VarName</em><sub><font size=
"2">1</font></sub> <a href="#jd_var_qname_expands_to" class=
"judgment"><b>of var expands to</b></a>
<em>Variable</em><sub><font size="2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td>...</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>VarName</em><sub><font size=
"2">n</font></sub> <a href="#jd_var_qname_expands_to" class=
"judgment"><b>of var expands to</b></a>
<em>Variable</em><sub><font size="2">n</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#jd_function_declaration" class="judgment"><b>function
declaration</b></a> declare function <em>QName</em> (
$<em>VarName</em><sub><font size="2">1</font></sub> as
<em>SequenceType</em><sub><font size="2">1</font></sub>, ···,
$<em>VarName</em><sub><font size="2">n</font></sub> as
<em>SequenceType</em><sub><font size="2">n</font></sub> ) as
<em>SequenceType</em><sub><font size="2">r</font></sub> external
<a href="#jd_function_declaration" class="judgment"><b>with
signature</b></a> declare function <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,
..., <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">n</font></sub>) as <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">r</font></sub>
<a href="#jd_function_declaration" class="judgment"><b>:</b></a>
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">r</font></sub></td>
</tr>
</table>
<br /></div>
<p><b><a href="#dyn_processing_context" class="processing">Dynamic
Context Processing</a></b></p>
<p>A function declaration updates the dynamic context. The function
name with arity N is associated with the given function body. The
number of arguments is required, because XQuery permits overloading
of function names as long as each function signature has a
different number of arguments.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>QName</em> <a href=
"#jd_func_qname_expands_to" class="judgment"><b>of func expands
to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size="2">1</font></sub> = <a href=
"#xq_dyn_env_def" class="env">dynEnv</a> + <a href="#xq_func_env"
class="env">funcDefn</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><span>,0</span>
=&gt; (<em>Expr</em>))</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b>declare function
<em>QName</em> () as <em>SequenceType</em><sub><font size=
"2">r</font></sub> { <em>Expr</em> } <a href=
"#jd_yields_dyn_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a>
<a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>QName</em> <a href=
"#jd_func_qname_expands_to" class="judgment"><b>of func expands
to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>VarName</em><sub><font size="2">1</font></sub>
<a href="#jd_var_qname_expands_to" class="judgment"><b>of var
expands to</b></a> <em>Variable</em><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td>···</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>VarName</em><sub><font size=
"2">n</font></sub> <a href="#jd_var_qname_expands_to" class=
"judgment"><b>of var expands to</b></a>
<em>Variable</em><sub><font size="2">n</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><font size="6">[</font><em>SequenceType</em><sub><font size=
"2">1</font></sub><font size="6">]</font><a href=
"#jd_map_sequencetype" class="judgment"><sub><font size=
"2">sequencetype</font></sub></a> = <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td>...</td>
</tr>
<tr align="center" valign="middle">
<td><font size="6">[</font><em>SequenceType</em><sub><font size=
"2">n</font></sub><font size="6">]</font><a href=
"#jd_map_sequencetype" class="judgment"><sub><font size=
"2">sequencetype</font></sub></a> = <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">n</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size="2">1</font></sub> = <a href=
"#xq_dyn_env_def" class="env">dynEnv</a> + <a href="#xq_func_env"
class="env">funcDefn</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><span>,n</span>
=&gt; ( <em>Expr</em> , <em>Variable</em><sub><font size=
"2">1</font></sub> , ···, <em>Variable</em><sub><font size=
"2">n</font></sub>))</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b>declare function
<em>QName</em> ( $<em>VarName</em><sub><font size=
"2">1</font></sub> as <em>SequenceType</em><sub><font size=
"2">1</font></sub>, ···, $<em>VarName</em><sub><font size=
"2">n</font></sub> as <em>SequenceType</em><sub><font size=
"2">n</font></sub> ) as <em>SequenceType</em><sub><font size=
"2">r</font></sub> { <em>Expr</em> } <a href=
"#jd_yields_dyn_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a>
<a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
<br /></div>
<p>An external function declaration does not affect the dynamic
environment. The implementation must support the declared external
functions.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b>declare function
<em>QName</em> ( $<em>VarName</em><sub><font size=
"2">1</font></sub> as <em>SequenceType</em><sub><font size=
"2">1</font></sub>, ···, $<em>VarName</em><sub><font size=
"2">n</font></sub> as <em>SequenceType</em><sub><font size=
"2">n</font></sub> ) as <em>SequenceType</em><sub><font size=
"2">r</font></sub> external <a href="#jd_yields_dyn_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a>
<a href="#xq_dyn_env_def" class="env">dynEnv</a></td>
</tr>
</table>
<br /></div>
<p>The dynamic semantics of a function body are applied when the
function is called, as described in <a href=
"#id-function-calls"><b>[4.1.5 Function Calls]</b></a>.</p>
</div>
<div class="div2">
<h3><a name="id-option-declaration" id=
"id-option-declaration"></a>5.16 Option Declaration</h3>
<h5><a name="d6e40258" id="d6e40258"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery10-OptionDecl" id=
"doc-xquery10-OptionDecl"></a>[<small>37&#160;(XQuery)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xquery/#prod-xquery-OptionDecl">OptionDecl</a><sup><small>XQ</small></sup></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "option" _QName_or_EQName <a href=
"#doc-xquery10-StringLiteral">StringLiteral</a></code></td>
</tr>
</tbody>
</table>
<p><b>Core Grammar</b></p>
<p>The core grammar production for option declarations is:</p>
<h5><a name="d6e40273" id="d6e40273"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xcore-OptionDecl" id=
"doc-xcore-OptionDecl"></a>[<small>21&#160;(Core)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-OptionDecl"></a><a href=
"#prod-xcore-OptionDecl">OptionDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "option" _QName_or_EQName <a href=
"#doc-xcore-StringLiteral">StringLiteral</a></code></td>
</tr>
</tbody>
</table>
<p><b><a href="#processing_normalization" class=
"processing">Normalization</a></b></p>
<p>Option declarations are left unchanged through
normalization.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>OptionDecl</em><font size="6">]</font><a href=
"#jd_map_prolog" class="judgment"><sub><font size=
"2">PrologDecl</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<em>OptionDecl</em></td>
</tr>
</table>
</div>
<p><b><a href="#processing_context" class="processing">Static
Context Processing</a></b></p>
<p>An option declaration does not have any effect on the static
context.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>OptionDecl</em> <a href=
"#jd_yields_context" class="judgment"><b>=&gt;</b><sub><font size=
"2">stat</font></sub></a> <a href="#xq_stat_env_def" class=
"env">statEnv</a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p><b><a href="#dyn_processing_context" class="processing">Dynamic
Context Processing</a></b></p>
<p>An option declaration does not have any effect on the dynamic
context.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>OptionDecl</em> <a href=
"#jd_yields_dyn_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a>
<a href="#xq_dyn_env_def" class="env">dynEnv</a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
</div>
</div>
<div class="div1">
<h2><a name="id-xquery-conformance" id=
"id-xquery-conformance"></a>6 Conformance</h2>
<p>The XQuery Formal Semantics is intended primarily as a component
that can be used by <a href="#xquery-11">[XQuery 1.1: An XML Query
Language]</a>, or a host language of <a href="#xpath-21">[XML Path
Language (XPath) 2.1]</a>. Therefore, the XQuery Formal Semantics
relies on specifications that use it (such as [XPath 2.1], [XSLT
2.1], and [XQuery 1.1]) to specify conformance criteria in their
respective environments. Specifications that set conformance
criteria for their use of the formal semantics must not relax the
constraints expressed in this specification.</p>
<div class="div2">
<h3><a name="id-static-typing-feature" id=
"id-static-typing-feature"></a>6.1 Static Typing Feature</h3>
<p>This specification normatively defines the static typing feature
which can be used in <a href="#xquery-11">[XQuery 1.1: An XML Query
Language]</a> or a host language of <a href="#xpath-21">[XML Path
Language (XPath) 2.1]</a>. The static typing feature is specified
using the static typing judgment introduced in <a href=
"#sec_static"><b>[3.2.3 Static typing judgment]</b></a>.</p>
<div class="div3">
<h4><a name="id-static-extensions" id=
"id-static-extensions"></a>6.1.1 Static Typing Extensions</h4>
<p>In some cases, the static typing rules are not very precise
(see, for example, the type inference rules for the ancestor
axes—parent, ancestor, and ancestor-or-self—and for the function
<code>fn:root</code>). If an implementation supports a static
typing extension, it must always provide a more precise type than
the one defined in this specification.</p>
<p id="jd_has_type_extension">This constraint is formally expressed
as follows. A static typing extension <em>Expr</em> <a href=
"#jd_has_type_extension" class="judgment"><b>:</b><sub><font size=
"2">ext</font></sub></a> <a href="#doc-fs-Type"><em>Type</em></a>
must be such that for every expression <em>Expr</em> the following
holds.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>Expr</em> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a>' <a href="#jd_subtype_of" class=
"judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>Expr</em> <a href=
"#jd_has_type_extension" class="judgment"><b>:</b><sub><font size=
"2">ext</font></sub></a> <a href=
"#doc-fs-Type"><em>Type</em></a>'</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>It is not recommended for a static typing extension to change
the static typing behavior of expressions that specify a type
explicitly (<code>treat as</code>, <code>cast as</code>,
<code>typeswitch</code>, function parameters, and type declarations
in variable bindings), since the purpose of those expressions is to
impose a specific type.</p>
</div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="sec_special_functions" id=
"sec_special_functions"></a>7 Additional Semantics of
Functions</h2>
<p>This section defines the auxiliary functions required to define
the formal semantics of [XPath/XQuery], and gives special
normalization and static typing rules for some functions in
<a href="#xpath-functions-11">[Functions and Operators
1.1]</a>.</p>
<p>Remember from <a href="#id-function-calls"><b>[4.1.5 Function
Calls]</b></a> that the following rules operate after namespace
resolution for the function name, and directly over the input type
of the parameters. In the rest of the section, we will use the
following shortcuts notations for specific relevant URIs:</p>
<ul>
<li>
<p><code>FN-URI</code> for functions from the <a href=
"#xpath-functions-11">[Functions and Operators 1.1]</a>
document.</p>
</li>
<li>
<p><code>OP-URI</code> for operators from the <a href=
"#xpath-functions-11">[Functions and Operators 1.1]</a>
document.</p>
</li>
<li>
<p><code>FS-URI</code> for formal semantics functions.</p>
</li>
</ul>
<div class="div2">
<h3><a name="sec_special_fs_functions" id=
"sec_special_fs_functions"></a>7.1 Formal Semantics Functions</h3>
<p><b>Introduction</b></p>
<p>This section gives the definition and semantics of functions
that are used in the formal semantics but are not in <a href=
"#xpath-functions-11">[Functions and Operators 1.1]</a>. Their
dynamic semantics are defined in the same informal style as in the
<a href="#xpath-functions-11">[Functions and Operators 1.1]</a>
document. The static semantics of some formal-semantics functions
require custom static typing rules.</p>
<div class="div3">
<h4><a name="sec_convert_operand" id=
"sec_convert_operand"></a>7.1.1 <span>The <a href=
"#sec_convert_operand"><em>fs:</em><code>convert-operand</code></a>
function</span></h4>
<div class="exampleInner">
<div class="proto"><code class=
"function">fs:convert-operand</code>(<code class=
"arg">$actual</code><code class=
"as">&#160;as&#160;</code><code class=
"type">xs:anyAtomicType?</code>, <code class=
"arg">$expected</code><code class=
"as">&#160;as&#160;</code><code class=
"type">xs:anyAtomicType</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">xs:anyAtomicType ?</code></div>
</div>
<p>The formal-semantics function <a href=
"#sec_convert_operand"><em>fs:</em><code>convert-operand</code></a>
converts the operands of arithmetic and comparison operators as
follows:</p>
<ol class="enumar">
<li>
<p>If <code>$actual</code> is the empty sequence, returns the empty
sequence.</p>
</li>
<li>
<p>If <code>$actual</code> is an instance of type <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>, then</p>
<ol class="enumla">
<li>
<p>if <code>$expected</code> is an instance of type <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> or
<code>xs:string</code>, returns <code>$actual</code> cast to
<code>xs:string</code>;</p>
</li>
<li>
<p>if <code>$expected</code> is of numeric type, returns
<code>$actual</code> cast to <code>xs:double</code></p>
</li>
<li>
<p>otherwise returns <code>$actual</code> cast to the type of
<code>$expected</code>.</p>
</li>
</ol>
</li>
<li>
<p>Otherwise, returns <code>$actual</code>.</p>
</li>
</ol>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>No conversion is needed unless $actual is an instance of type
<a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> not(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>?)</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#sec_convert_operand">(<code>FS-URI</code>,"<code>convert-operand</code>")</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>) <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
<br /></div>
<p>Pairs of untyped atomic operands are converted to strings.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> ?</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
(<a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>|<code>xs:string</code>)</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#sec_convert_operand">(<code>FS-URI</code>,"<code>convert-operand</code>")</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>) <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <code>xs:string</code> <a href=
"#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier"
class="judgment">quantifier</a> (<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>)</td>
</tr>
</table>
<br /></div>
<p>When an untyped operand is paired with a numeric operand, it is
converted to xs:double.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> ?</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
<em>fs:</em><code>numeric</code></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#sec_convert_operand">(<code>FS-URI</code>,"<code>convert-operand</code>")</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>) <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <code>xs:double</code> <a href=
"#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier"
class="judgment">quantifier</a> (<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>)</td>
</tr>
</table>
<br /></div>
<p>Finally, an untyped atomic operand not dealt with by the above
rules is converted to the type of the other operand.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> ?</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <a href="#jd_not" class=
"judgment"><b>not</b></a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
(<a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>|<code>xs:string</code>|<em>fs:</em><code>numeric</code>))</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#sec_convert_operand">(<code>FS-URI</code>,"<code>convert-operand</code>")</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>) <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_quantifier" class="judgment">·</a> <a href=
"#jd_quantifier" class="judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>)</td>
</tr>
</table>
<br /></div>
</div>
<div class="div3">
<h4><a name="sec_convert_simple_operand" id=
"sec_convert_simple_operand"></a>7.1.2 <span>The <a href=
"#sec_convert_simple_operand"><em>fs:</em><code>convert-simple-operand</code></a>
function</span></h4>
<div class="exampleInner">
<div class="proto"><code class=
"function">fs:convert-simple-operand</code>(<code class=
"arg">$actual</code><code class=
"as">&#160;as&#160;</code><code class="type">xs:anyAtomicType
*</code>, <code class="arg">$expected</code><code class=
"as">&#160;as&#160;</code><code class=
"type">xs:anyAtomicType</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">xs:anyAtomicType *</code></div>
</div>
<p>The formal-semantics function <a href=
"#sec_convert_simple_operand"><em>fs:</em><code>convert-simple-operand</code></a>
is used to convert the value of the <code>$actual</code> argument
such that it matches the type of the <code>$expected</code>
argument (or matches a sequence of that type).</p>
<p>The dynamic semantics of this function are as follows:</p>
<ul>
<li>
<p>For each item in <code>$actual</code> argument that is of type
xs:untypedAtomic, that item is cast to the type of the
<code>$expected</code> argument, and the resulting sequence is
returned.</p>
</li>
</ul>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>The following static typing rules correspond to the dynamic
semantics rules given above.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">3</font></sub> = <a href="#jd_convert_untypedAtomic" class=
"judgment"><b>convert_untypedAtomic</b></a>(<a href="#jd_prime"
class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>), <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>)</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#sec_convert_simple_operand">(<code>FS-URI</code>,"<code>convert-simple-operand</code>")</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>) <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub>
<a href="#jd_quantifier" class="judgment">·</a> <a href=
"#jd_quantifier" class="judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>)</td>
</tr>
</table>
<br /></div>
</div>
<div class="div3">
<h4><a name="sec_distinct_docorder" id=
"sec_distinct_docorder"></a>7.1.3 <span>The <a href=
"#sec_distinct_docorder"><em>fs:</em><code>distinct-doc-order</code></a>
function</span></h4>
<div class="exampleInner">
<div class="proto"><code class=
"function">fs:distinct-doc-order</code>(<code class=
"arg">$nodes</code><code class=
"as">&#160;as&#160;</code><code class="type">node
*</code>)<code class="as">&#160;as&#160;</code><code class=
"return-type">node *</code></div>
</div>
<p>The <a href=
"#sec_distinct_docorder"><em>fs:</em><code>distinct-doc-order</code></a>
function sorts its input sequence of nodes by document order and
removes duplicates.</p>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>The <a href=
"#sec_distinct_docorder"><em>fs:</em><code>distinct-doc-order</code></a>
function expects a sequence of nodes as input. The resulting type
is computed using <a href="#jd_prime" class="judgment">prime</a>
and <a href="#jd_quantifier" class="judgment">quantifier</a>, which
are defined in <a href="#sec_factor"><b>[8.4 Judgments for FLWOR
and other expressions on sequences]</b></a>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <a href="#doc-fs-Type"><em>Type</em></a>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
node*</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#sec_distinct_docorder">(<code>FS-URI</code>,"<code>distinct-doc-order</code>")</a>
( <a href="#doc-fs-Type"><em>Type</em></a> ) <a href="#jd_has_type"
class="judgment"><b>:</b></a> <a href="#jd_prime" class=
"judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a>)
<a href="#jd_quantifier" class="judgment">·</a> <a href=
"#jd_quantifier" class="judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a>)</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
</div>
<div class="div3">
<h4><a name="sec_distinct_docorder_or_atomic_sequence" id=
"sec_distinct_docorder_or_atomic_sequence"></a>7.1.4 <span>The
<a href=
"#sec_distinct_docorder_or_atomic_sequence"><em>fs:</em><code>distinct-doc-order-or-atomic-sequence</code></a>
function</span></h4>
<div class="exampleInner">
<div class="proto"><code class=
"function">fs:distinct-doc-order-or-atomic-sequence</code>(<code class="arg">$item</code><code class="as">&#160;as&#160;</code><code class="type">item()*</code>)<code class="as">&#160;as&#160;</code><code class="return-type">item()*</code></div>
</div>
<p>The <a href=
"#sec_distinct_docorder_or_atomic_sequence"><em>fs:</em><code>distinct-doc-order-or-atomic-sequence</code></a>
function operates on either an homogeneous sequence of nodes or an
homogeneous sequence of atomic values. If the input is a sequence
of nodes, is sorts those nodes by document order and removes
duplicates, using the fs:distinct-doc-order function. If it is a
sequence of atomic values, it returns it unchanged.</p>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>The <a href=
"#sec_distinct_docorder"><em>fs:</em><code>distinct-doc-order</code></a>
function expects either a sequence of nodes as input or a sequence
of atomic values. The resulting type is computed using <a href=
"#jd_prime" class="judgment">prime</a> and <a href="#jd_quantifier"
class="judgment">quantifier</a>, which are defined in <a href=
"#sec_factor"><b>[8.4 Judgments for FLWOR and other expressions on
sequences]</b></a>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <a href="#doc-fs-Type"><em>Type</em></a>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
<font size="6">[</font>node()<font size="6">]</font><a href=
"#jd_map_sequencetype" class="judgment"><sub><font size=
"2">sequencetype</font></sub></a>*</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#sec_distinct_docorder_or_atomic_sequence">(<code>FS-URI</code>,"<code>distinct-doc-order-or-atomic-sequence</code>")</a>
( <a href="#doc-fs-Type"><em>Type</em></a> ) <a href="#jd_has_type"
class="judgment"><b>:</b></a> <a href="#jd_prime" class=
"judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a>)
<a href="#jd_quantifier" class="judgment">·</a> <a href=
"#jd_quantifier" class="judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a>)</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <a href="#doc-fs-Type"><em>Type</em></a>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>*</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#sec_distinct_docorder_or_atomic_sequence">(<code>FS-URI</code>,"<code>distinct-doc-order-or-atomic-sequence</code>")</a>
( <a href="#doc-fs-Type"><em>Type</em></a> ) <a href="#jd_has_type"
class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
</div>
<div class="div3">
<h4><a name="sec_items_to_nodes" id="sec_items_to_nodes"></a>7.1.5
<span>The <a href=
"#sec_items_to_nodes"><em>fs:</em><code>item-sequence-to-node-sequence</code></a>
function</span></h4>
<div class="exampleInner">
<div class="proto"><code class=
"function">fs:item-sequence-to-node-sequence</code>(<code class=
"arg">$items</code><code class=
"as">&#160;as&#160;</code><code class=
"type">item()*</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">node()*</code></div>
</div>
<p>The <a href=
"#sec_items_to_nodes"><em>fs:</em><code>item-sequence-to-node-sequence</code></a>
function converts a sequence of item values to nodes by applying
the normative rules numbered <span><code>1</code>, <code>2</code>,
<code>3</code> after the sentence "Processing of the computed
element constructor proceeds as follows:" in <a href=
"http://www.w3.org/TR/xquery#id-computedElements">Section 3.7.3.1
Computed Element
Constructors</a><sup><small>XQ</small></sup>.</span>
<span><code>1e</code> and <code>2</code> in <a href=
"http://www.w3.org/TR/xquery#id-content">Section 3.7.1.3
Content</a><sup><small>XQ</small></sup> (with the value bound to
<code>$items</code> playing the role of "the value of an enclosed
expression").</span></p>
<p>If the input sequence contains any attribute nodes, they must
precede any other items<span>, with the exception that text nodes
are allowed throughout. This exception results in looser type
checking, but it is necessitated by the possible presence of empty
text nodes introduced by normalization of direct element
constructors (see <a href="#id_element_constructor"><b>[4.7.1
Direct Element Constructors]</b></a>)</span>.</p>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-Type"><em>Type</em></a> <a href="#jd_subtype_of" class=
"judgment"><b>&lt;:</b></a> attribute**</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#sec_items_to_nodes">(<code>FS-URI</code>,"<code>item-sequence-to-node-sequence</code>")</a>(<a href="#doc-fs-Type"><em>Type</em></a>)
<a href="#jd_has_type" class="judgment"><b>:</b></a>
attribute**</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-Type"><em>Type</em></a> <a href="#jd_subtype_of" class=
"judgment"><b>&lt;:</b></a>
(element*|text|processing-instruction*|comment|document|<a href=
"#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>)*</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#sec_items_to_nodes">(<code>FS-URI</code>,"<code>item-sequence-to-node-sequence</code>")</a>(<a href="#doc-fs-Type"><em>Type</em></a>)
<a href="#jd_has_type" class="judgment"><b>:</b></a>
(element*|text|processing-instruction*|comment)*</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a> <a href="#jd_subtype_of" class=
"judgment"><b>&lt;:</b></a> <span><span>( attribute<span>*</span>*,
(element <span>*</span>|document|processing-instruction
<span>*</span>|comment|<code>xs:string</code>|<code>xs:float</code>|...|<code>xs:NOTATION</code>)*
) &amp; text*</span></span> <span>attribute<span>*</span>*,
(element <span>*</span>|text|processing-instruction
<span>*</span>|comment|document|<a href=
"#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>)*</span></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#sec_items_to_nodes">(<code>FS-URI</code>,"<code>item-sequence-to-node-sequence</code>")</a>
(<a href="#doc-fs-Type"><em>Type</em></a>) <a href="#jd_has_type"
class="judgment"><b>:</b></a> attribute<span>*</span>*, (element
<span>*</span>|text|processing-instruction
<span>*</span>|comment)*</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
</div>
<div class="div3">
<h4><a name="sec_items_to_nodes_doc" id=
"sec_items_to_nodes_doc"></a>7.1.6 <span>The <a href=
"#sec_items_to_nodes"><em>fs:</em><code>item-sequence-to-node-sequence-doc</code></a>
function</span></h4>
<div class="exampleInner">
<div class="proto"><code class=
"function">fs:item-sequence-to-node-sequence-doc</code>(<code class="arg">$items</code><code class="as">&#160;as&#160;</code><code class="type">item()*</code>)<code class="as">&#160;as&#160;</code><code class="return-type">node()*</code></div>
</div>
<p>The <a href=
"#sec_items_to_nodes"><em>fs:</em><code>item-sequence-to-node-sequence-doc</code></a>
function converts a sequence of item values to nodes by applying
the normative rules numbered <code>1</code>, <code>2</code>,
<code>3</code> after the sentence "Processing of the document node
constructor then proceeds as follows:" in <a href=
"http://www.w3.org/TR/xquery#id-documentConstructors">Section
3.7.3.3 Document Node
Constructors</a><sup><small>XQ</small></sup>.</p>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a> <a href="#jd_subtype_of" class=
"judgment"><b>&lt;:</b></a> (element
<span>*</span>|document|text|processing-instruction
<span>*</span>|comment|<code>xs:string</code>|<code>xs:float</code>|
...|<code>xs:NOTATION</code>)*</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#sec_items_to_nodes_doc">(<code>FS-URI</code>,"<code>item-sequence-to-node-sequence-doc</code>")</a>
(<a href="#doc-fs-Type"><em>Type</em></a>) <a href="#jd_has_type"
class="judgment"><b>:</b></a> (element
<span>*</span>|text|processing-instruction
<span>*</span>|comment)*</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
</div>
<div class="div3">
<h4><a name="sec_item_seq_to_string" id=
"sec_item_seq_to_string"></a>7.1.7 <span>The <span><a href=
"#sec_item_seq_to_untypedAtomic"><em>fs:</em><code>item-sequence-to-untypedAtomic</code></a></span>
<span><a href=
"#sec_item_seq_to_string"><em>fs:</em><code>item-sequence-to-string</code></a></span>
function</span></h4>
<p><b>Introduction</b></p>
<div class="exampleInner">
<div class="proto"><code class=
"function">fs:item-sequence-to-untypedAtomic</code>(<code class=
"arg">$items</code><code class=
"as">&#160;as&#160;</code><code class=
"type">item()*</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">xs:untypedAtomic</code></div>
<div class="proto"><code class=
"function">fs:item-sequence-to-string</code>(<code class=
"arg">$items</code><code class=
"as">&#160;as&#160;</code><code class=
"type">item()*</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">xs:string</code></div>
</div>
<p>The <span><a href=
"#sec_item_seq_to_untypedAtomic"><em>fs:</em><code>item-sequence-to-untypedAtomic</code></a></span>
<span><a href=
"#sec_item_seq_to_string"><em>fs:</em><code>item-sequence-to-string</code></a></span>
function converts a sequence of item values to a string <span>of
type <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a></span> by
applying the normative rules in <a href=
"http://www.w3.org/TR/xquery#id-computedAttributes">Section 3.7.3.2
Computed Attribute Constructors</a><sup><small>XQ</small></sup> for
processing the content expression.</p>
<p><b><a href="#processing_dynamic" class="processing">Dynamic
Evaluation</a></b></p>
<p>If the input of the <span><a href=
"#sec_item_seq_to_untypedAtomic"><em>fs:</em><code>item-sequence-to-untypedAtomic</code></a></span>
<span><a href=
"#sec_item_seq_to_string"><em>fs:</em><code>item-sequence-to-string</code></a></span>
function is an empty sequence, it returns a zero-length string.
Otherwise, each atomic value in the input sequence is cast into a
string. The individual strings resulting from the previous step are
merged into a single string by concatenating them with a single
space character between each pair.</p>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>There are no special static typing rules for this function.
Static type analysis for this function should be performed as for a
built-in function declared with the given signature.</p>
</div>
<div class="div3">
<h4><a name="sec_item_seq_to_untypedAtomic_PI" id=
"sec_item_seq_to_untypedAtomic_PI"></a>7.1.8 <span>The <a href=
"#sec_item_seq_to_untypedAtomic_PI"><em>fs:</em><code>item-sequence-to-untypedAtomic-PI</code></a>
function</span></h4>
<p><b>Introduction</b></p>
<div class="exampleInner">
<div class="proto"><code class=
"function">fs:item-sequence-to-untypedAtomic-PI</code>(<code class=
"arg">$items</code><code class=
"as">&#160;as&#160;</code><code class=
"type">item()*</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">xs:untypedAtomic</code></div>
</div>
<p>The <a href=
"#sec_item_seq_to_untypedAtomic_PI"><em>fs:</em><code>item-sequence-to-untypedAtomic-PI</code></a>
function converts a sequence of item values to a string of type
<a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> by
applying the normative rules in <a href=
"http://www.w3.org/TR/xquery#id-computed-pis">Section 3.7.3.5
Computed Processing Instruction
Constructors</a><sup><small>XQ</small></sup> for processing the
content expression.</p>
<p><b><a href="#processing_dynamic" class="processing">Dynamic
Evaluation</a></b></p>
<p>If the input is an empty sequence, the <a href=
"#sec_item_seq_to_untypedAtomic_PI"><em>fs:</em><code>item-sequence-to-untypedAtomic-PI</code></a>
function returns a zero-length string. Otherwise, each atomic value
in the input sequence is cast into a string. If any of the
resulting strings contains the string "?&gt;", a dynamic error is
raised. The individual strings resulting from the previous step are
merged into a single string by concatenating them with a single
space character between each pair. Leading whitespace is removed
from the resulting string.</p>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>There are no special static typing rules for this function.
Static type analysis for this function should be performed as for a
built-in function declared with the given signature.</p>
</div>
<div class="div3">
<h4><a name="sec_item_seq_to_untypedAtomic_text" id=
"sec_item_seq_to_untypedAtomic_text"></a>7.1.9 <span>The <a href=
"#sec_item_seq_to_untypedAtomic_text"><em>fs:</em><code>item-sequence-to-untypedAtomic-text</code></a>
function</span></h4>
<p><b>Introduction</b></p>
<div class="exampleInner">
<div class="proto"><code class=
"function">fs:item-sequence-to-untypedAtomic-text</code>(<code class="arg">$items</code><code class="as">&#160;as&#160;</code><code class="type">item()*</code>)<code class="as">&#160;as&#160;</code><code class="return-type">xs:untypedAtomic?</code></div>
</div>
<p>The <a href=
"#sec_item_seq_to_untypedAtomic_text"><em>fs:</em><code>item-sequence-to-untypedAtomic-text</code></a>
function converts a sequence of item values to a string of type
<a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>,
or empty, by applying the rules in <a href=
"http://www.w3.org/TR/xquery#id-textConstructors">Section 3.7.3.4
Text Node Constructors</a><sup><small>XQ</small></sup> for
processing the content expression.</p>
<p><b><a href="#processing_dynamic" class="processing">Dynamic
Evaluation</a></b></p>
<p>If the input is the empty sequence, the <a href=
"#sec_item_seq_to_untypedAtomic_text"><em>fs:</em><code>item-sequence-to-untypedAtomic-text</code></a>
function returns the empty sequence. Otherwise, each atomic value
in the input sequence is cast into a string. The individual strings
resulting from the previous step are merged into a single string by
concatenating them with a single space character between each
pair.</p>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>There are no special static typing rules for this function.
Static type analysis for this function should be performed as for a
built-in function declared with the given signature.</p>
</div>
<div class="div3">
<h4><a name="sec_item_seq_to_untypedAtomic_comment" id=
"sec_item_seq_to_untypedAtomic_comment"></a>7.1.10 <span>The
<a href=
"#sec_item_seq_to_untypedAtomic_comment"><em>fs:</em><code>item-sequence-to-untypedAtomic-comment</code></a>
function</span></h4>
<p><b>Introduction</b></p>
<div class="exampleInner">
<div class="proto"><code class=
"function">fs:item-sequence-to-untypedAtomic-comment</code>(<code class="arg">$items</code><code class="as">&#160;as&#160;</code><code class="type">item()*</code>)<code class="as">&#160;as&#160;</code><code class="return-type">xs:untypedAtomic</code></div>
</div>
<p>The <a href=
"#sec_item_seq_to_untypedAtomic_comment"><em>fs:</em><code>item-sequence-to-untypedAtomic-comment</code></a>
function converts a sequence of item values to a string of type
<a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> by
applying the normative rules in <a href=
"http://www.w3.org/TR/xquery#id-computed-comments">Section 3.7.3.6
Computed Comment Constructors</a><sup><small>XQ</small></sup> for
processing the content expression.</p>
<p><b><a href="#processing_dynamic" class="processing">Dynamic
Evaluation</a></b></p>
<p>If the input is the empty sequence, the <a href=
"#sec_item_seq_to_untypedAtomic_comment"><em>fs:</em><code>item-sequence-to-untypedAtomic-comment</code></a>
function returns a zero-length string. Otherwise, each atomic value
in the input sequence is cast into a string. The individual strings
resulting from the previous step are merged into a single string by
concatenating them with a single space character between each pair.
It is a dynamic error if the result of the content expression of a
computed comment constructor contains two adjacent hyphens or ends
with a hyphen.</p>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>There are no special static typing rules for this function.
Static type analysis for this function should be performed as for a
built-in function declared with the given signature.</p>
</div>
<div class="div3">
<h4><a name="sec_apply_ordering_mode" id=
"sec_apply_ordering_mode"></a>7.1.11 <span>The <a href=
"#sec_apply_ordering_mode"><em>fs:</em><code>apply-ordering-mode</code></a>
function</span></h4>
<div class="exampleInner">
<div class="proto"><code class=
"function">fs:apply-ordering-mode</code>(<code class=
"arg">$items</code><code class=
"as">&#160;as&#160;</code><code class=
"type">item()*</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">item()*</code></div>
</div>
<p><b><a href="#processing_dynamic" class="processing">Dynamic
Evaluation</a></b></p>
<p>If the <a href="#xq_stat_env_def" class=
"env">statEnv</a>.<a href="#xq_ordering_mode_env" class=
"env">orderingMode</a> is set to ordered, the <a href=
"#sec_apply_ordering_mode"><em>fs:</em><code>apply-ordering-mode</code></a>
function is the identity function, returning its input sequence in
its original order.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_ordering_mode_env" class="env">orderingMode</a> =
<code>ordered</code>&#160;&#160;&#160;&#160;<a href=
"#xq_dyn_env_def" class="env">dynEnv</a>
<b>&#160;|-&#160;</b><em>Expr</em> <a href="#jd_yields" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a>
<b>&#160;|-&#160;</b><a href=
"#sec_apply_ordering_mode"><em>fs:</em><code>apply-ordering-mode</code></a>(<em>Expr</em>)
<a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></td>
</tr>
</table>
<br /></div>
<p>If the <a href="#xq_stat_env_def" class=
"env">statEnv</a>.<a href="#xq_ordering_mode_env" class=
"env">orderingMode</a> is set to unordered, the <a href=
"#sec_apply_ordering_mode"><em>fs:</em><code>apply-ordering-mode</code></a>
is equivalent to the <code>fn:unordered</code> function, returning
the items from its input sequence in arbitrary order.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_ordering_mode_env" class="env">orderingMode</a> =
<code>unordered</code>&#160;&#160;&#160;&#160;<a href=
"#xq_dyn_env_def" class="env">dynEnv</a>
<b>&#160;|-&#160;</b><code>fn:unordered</code>(<em>Expr</em>)
<a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a>
<b>&#160;|-&#160;</b><a href=
"#sec_apply_ordering_mode"><em>fs:</em><code>apply-ordering-mode</code></a>(<em>Expr</em>)
<a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></td>
</tr>
</table>
<br /></div>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>If the ordering context is set to <code>ordered</code>, the
static type of the input expression of the <a href=
"#sec_apply_ordering_mode"><em>fs:</em><code>apply-ordering-mode</code></a>
function is left unchanged.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_ordering_mode_env" class="env">orderingMode</a> =
<code>ordered</code></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><a href=
"#sec_apply_ordering_mode">(<code>FS-URI</code>,"<code>apply-ordering-mode</code>")</a>(<a href="#doc-fs-Type"><em>Type</em></a>)
<a href="#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
<br /></div>
<p>If the ordering context is set to <code>unordered</code>, the
static type of the input expression of the <a href=
"#sec_apply_ordering_mode"><em>fs:</em><code>apply-ordering-mode</code></a>
function is computed using the <a href="#jd_prime" class=
"judgment">prime</a> and <a href="#jd_quantifier" class=
"judgment">quantifier</a> judgments, as for the
<code>fn:unordered</code> function.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_ordering_mode_env" class="env">orderingMode</a> =
<code>unordered</code></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><a href=
"#sec_apply_ordering_mode">(<code>FS-URI</code>,"<code>apply-ordering-mode</code>")</a>(<a href="#doc-fs-Type"><em>Type</em></a>)
<a href="#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#jd_prime" class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a>) <a href="#jd_quantifier" class=
"judgment">·</a> <a href="#jd_quantifier" class=
"judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a>)</td>
</tr>
</table>
<br /></div>
</div>
<div class="div3">
<h4><a name="sec_fs_to" id="sec_fs_to"></a>7.1.12 The
<em>fs:</em><code>to</code> function</h4>
<div class="exampleInner">
<div class="proto"><code class="function">fs:to</code>(<code class=
"arg">$firstval</code><code class=
"as">&#160;as&#160;</code><code class="type">xs:integer?</code>,
<code class="arg">$lastval</code><code class=
"as">&#160;as&#160;</code><code class=
"type">xs:integer?</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">xs:integer*</code></div>
</div>
<p>The formal semantics function <em>fs:</em><code>to</code> is a
wrapper function for the <code>op:to</code> operator, taking the
semantics of the range expression over empty sequences into
account.</p>
<p><b><a href="#processing_dynamic" class="processing">Dynamic
Evaluation</a></b></p>
<p>If one of the input parameters for <em>fs:</em><code>to</code>
is the empty sequence, the function returns the empty sequence,
otherwise it returns the result of calling the <code>op:to</code>
operator. This semantics is equivalent to the following
user-defined function.</p>
<div class="exampleInner">
<pre>
declare function fs:to($firstval as xs:integer?, $lastval as xs:integer?) as xs:integer* {
  if (fn:empty($firstval) or fn:empty($lastval)
  then ()
  else op:to($firstval,$lastval)
};
</pre></div>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>The static type of <em>fs:</em><code>to</code> does not require
any additional static typing rule, and is typed as a function call
based on the above signature.</p>
</div>
<div class="div3">
<h4><a name="sec_node_sequence" id="sec_node_sequence"></a>7.1.13
<span>The <a href=
"#sec_node_sequence"><em>fs:</em><code>node-sequence</code></a>
function</span></h4>
<div class="exampleInner">
<div class="proto"><code class=
"function">fs:node-sequence</code>(<code class=
"arg">$nodes</code><code class=
"as">&#160;as&#160;</code><code class=
"type">node()*</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">node()*</code></div>
</div>
<p>If the input is a (possibly empty) sequence of nodes, <a href=
"#sec_node_sequence"><em>fs:</em><code>node-sequence</code></a>
simply returns that sequence. Otherwise, it raises a type
error.</p>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>The static type of a call to <a href=
"#sec_node_sequence"><em>fs:</em><code>node-sequence</code></a> is
that of its argument, as long as that type is a subtype of
<code>node()*</code>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-Type"><em>Type</em></a> <a href="#jd_subtype_of" class=
"judgment"><b>&lt;:</b></a> <font size=
"6">[</font>node()*<font size="6">]</font><a href=
"#jd_map_sequencetype" class="judgment"><sub><font size=
"2">sequencetype</font></sub></a></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#sec_node_sequence">(<code>FS-URI</code>,"<code>node-sequence</code>")</a>(<a href="#doc-fs-Type"><em>Type</em></a>)
<a href="#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
<br /></div>
</div>
<div class="div3">
<h4><a name="sec_item_at" id="sec_item_at"></a>7.1.14 <span>The
<a href="#sec_item_at"><em>fs:</em><code>item-at</code></a>
function</span></h4>
<div class="exampleInner">
<div class="proto"><code class=
"function">fs:item-at</code>(<code class=
"arg">$sourceSeq</code><code class=
"as">&#160;as&#160;</code><code class="type">item()*</code>,
<code class="arg">$loc</code><code class=
"as">&#160;as&#160;</code><code class=
"type">xs:double</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">item()?</code></div>
</div>
<p>The <a href="#sec_item_at"><em>fs:</em><code>item-at</code></a>
function returns the item at a specified position in a
sequence.</p>
<p><b><a href="#processing_dynamic" class="processing">Dynamic
Evaluation</a></b></p>
<p>If <code>$loc</code> is numeric-equal to the position of some
item in <code>$sourceSeq</code>, that item is returned. (This
implies that <code>$sourceSeq</code> is non-empty, and
<code>$loc</code> is numeric-equal to an integer between 1 and
<code>n</code> inclusive, where <code>n</code> is the number of
items in <code>$sourceSeq</code>.)</p>
<p>Otherwise, the empty sequence is returned.</p>
<p>The function is roughly equivalent to the following user-defined
function.</p>
<div class="exampleInner">
<pre>
  declare function fs:item-at(
      $sourceSeq as item()*,
      $loc as xs:double) as item()?
  {
      if ($loc mod 1 eq 0) then
          fn:subsequence($sourceSeq,$loc,1)
      else
          ()
  };
</pre></div>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>The static typing rules for invocations of <a href=
"#sec_item_at"><em>fs:</em><code>item-at</code></a> depend on the
syntactic form of the second argument. If it is the IntegerLiteral
1, then we can be relatively precise about the resulting type.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>QName</em> <a href=
"#jd_func_qname_expands_to" class="judgment"><b>of func expands
to</b></a> <a href=
"#sec_item_at">(<code>FS-URI</code>,"<code>item-at</code>")</a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">1</font></sub> <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#jd_quantifier" class=
"judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
<a href="#jd_isin" class="judgment"><b>in</b></a> { 1, + }</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>QName</em>(<em>Expr</em><sub><font size="2">1</font></sub>,
1) <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#jd_prime" class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>)</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>Otherwise, the following less precise rule is used.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>QName</em> <a href=
"#jd_func_qname_expands_to" class="judgment"><b>of func expands
to</b></a> <a href=
"#sec_item_at">(<code>FS-URI</code>,"<code>item-at</code>")</a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">1</font></sub> <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>QName</em>(<em>Expr</em><sub><font size="2">1</font></sub>,
<em>Expr</em><sub><font size="2">2</font></sub>) <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href="#jd_prime"
class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
?</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>(Since invocations of <a href=
"#sec_item_at"><em>fs:</em><code>item-at</code></a> arise only as
the result of particular normalization rules, <em>Expr2</em> in the
above rule must be either <code>$fs:last</code>,
<code>$fs:position</code>, or a NumericLiteral. Thus, there is no
need to check its type.)</p>
</div>
</div>
<div class="div2">
<h3><a name="function_rules" id="function_rules"></a>7.2 Standard
functions with specific static typing rules</h3>
<p><b>Introduction</b></p>
<p>This section gives special normalization and static typing rules
for functions in <a href="#xpath-functions-11">[Functions and
Operators 1.1]</a> for which the standard normalization or static
typing rules are not appropriate. All functions that are not
mentioned behave as described in Section <a href=
"#id-function-calls"><b>[4.1.5 Function Calls]</b></a>. When given,
the static typing rules in this section always give more precise
type information than the generic rule based on the function's
signature.</p>
<div class="div3">
<h4><a name="sec_fn_last" id="sec_fn_last"></a>7.2.1 The
<code>fn:last</code> context function</h4>
<p>As explained in <a href="#eval_context"><b>[3.1.2 Dynamic
Context]</b></a>, the <code>fn:last()</code> context function is
modeled using the Formal Semantics variable <a href=
"#fs_builtin_vars"><code>$</code><em>fs:</em><code>last</code></a>.
For that function the following static typing and dynamic
evaluation rules apply.</p>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_type_env" class=
"env">varType</a>((<code>FS-URI</code>,"<code>last</code>")) =
<a href="#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
(<code>FN-URI</code>,"<code>last</code>")() <a href="#jd_has_type"
class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
<br /></div>
<p><b><a href="#processing_dynamic" class="processing">Dynamic
Evaluation</a></b></p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href=
"#xq_val_env" class=
"env">varValue</a>((<code>FS-URI</code>,"<code>last</code>")) =
<a href="#doc-fs-Value"><em>Value</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href=
"#jd_function_with_types" class="judgment"><b>function</b></a>
(<code>FN-URI</code>,"<code>last</code>")<span>()</span> <a href=
"#jd_function_with_types" class="judgment"><b>with types</b></a>
<a href="#jd_function_with_types" class="judgment"><b>on
values</b></a> <a href="#jd_function_with_types" class=
"judgment"><b>yields</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></td>
</tr>
</table>
<br /></div>
</div>
<div class="div3">
<h4><a name="sec_fn_position" id="sec_fn_position"></a>7.2.2 The
<code>fn:position</code> context function</h4>
<p>As explained in <a href="#eval_context"><b>[3.1.2 Dynamic
Context]</b></a>, the <code>fn:position()</code> context function
is modeled using the Formal Semantics variable <a href=
"#fs_builtin_vars"><code>$</code><em>fs:</em><code>position</code></a>.
For that function the following static typing and dynamic
evaluation rules apply.</p>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_type_env" class=
"env">varType</a>((<code>FS-URI</code>,"<code>position</code>")) =
<a href="#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
(<code>FN-URI</code>,"<code>position</code>")() <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
<br /></div>
<p><b><a href="#processing_dynamic" class="processing">Dynamic
Evaluation</a></b></p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href=
"#xq_val_env" class=
"env">varValue</a>((<code>FS-URI</code>,"<code>position</code>")) =
<a href="#doc-fs-Value"><em>Value</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href=
"#jd_function_with_types" class="judgment"><b>function</b></a>
(<code>FN-URI</code>,"<code>position</code>")<span>()</span>
<a href="#jd_function_with_types" class="judgment"><b>with
types</b></a> <a href="#jd_function_with_types" class=
"judgment"><b>on values</b></a> <a href="#jd_function_with_types"
class="judgment"><b>yields</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></td>
</tr>
</table>
<br /></div>
</div>
<div class="div3">
<h4><a name="sec_fn_abs_ceil_floor_round" id=
"sec_fn_abs_ceil_floor_round"></a>7.2.3 <span>The
<code>fn:abs</code>, <code>fn:ceiling</code>,
<code>fn:floor</code>, <code>fn:round</code>, and
<code>fn:round-half-to-even</code> functions</span></h4>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>The static typing rules for the <code>fn:abs</code>,
<code>fn:ceiling</code>, <code>fn:floor</code>,
<code>fn:round</code>, and <code>fn:round-half-to-even</code>
functions promote their input type to the (least) base primitive
numeric type from which the input type is derived. Note that the
fact that the type should be the least is <span>not</span>
expressed by the inference rule notation used here. Parameters of
type <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> are always
promoted to <code>xs:double</code>. <span>Instead of writing a
separate judgment for each function, we write one rule for the
functions whose name is either
(<code>FN-URI</code>,"<code>abs</code>"),
(<code>FN-URI</code>,"<code>ceiling</code>"),
(<code>FN-URI</code>,"<code>floor</code>"),
(<code>FN-URI</code>,"<code>round</code>"), or
(<code>FN-URI</code>,"<code>round-half-to-even</code>")
functions.</span></p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_isin" class=
"judgment"><b>in</b></a> { <code>xs:integer</code>,
<code>xs:decimal</code>, <code>xs:float</code>,
<code>xs:double</code> }</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a> <a href="#jd_subtype_of" class=
"judgment"><b>&lt;:</b></a> <a href=
"#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a> ?</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub> = <a href="#jd_convert_untypedAtomic" class=
"judgment"><b>convert_untypedAtomic</b></a>(<a href=
"#doc-fs-Type"><em>Type</em></a>, <code>xs:double</code>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_can_be_promoted_to" class="judgment"><b>can be
promoted to</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#id-expanded-qnames"><em>expanded-QName</em></a>
<a href="#jd_isin" class="judgment"><b>in</b></a> {
<span>(<code>FN-URI</code>,"<code>abs</code>"),</span>
(<code>FN-URI</code>,"<code>ceiling</code>"),
(<code>FN-URI</code>,"<code>floor</code>"),
(<code>FN-URI</code>,"<code>round</code>"),
(<code>FN-URI</code>,"<code>round-half-to-even</code>") }</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a> (<a href=
"#doc-fs-Type"><em>Type</em></a>) <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_quantifier" class="judgment">·</a> <a href=
"#jd_quantifier" class="judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a>)</td>
</tr>
</table>
<br /></div>
<p><b>Notation</b></p>
<p id="jd_has_base_atomic_type">The auxiliary judgment <a href=
"#jd_has_base_atomic_type" class="judgment"><b>has base atomic
type</b></a> is used in the next subsection and also in <a href=
"#sec_fn_aggregates"><b>[7.2.10 The fn:min, fn:max, fn:avg, and
fn:sum functions]</b></a>.</p>
<div align="center"><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">1</font></sub>
<a href="#jd_has_base_atomic_type" class="judgment"><b>has base
atomic type</b></a> <a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">2</font></sub></div>
<p>To a first approximation, this judgment holds when <a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">1</font></sub>
is (or is derived from) primitive atomic type <a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">2</font></sub>.
However, for the purpose of typing the functions that use this
judgment, there are three non-primitive atomic types that are
treated similarly to primitive types: <code>xs:integer</code>
(derived from <code>xs:decimal</code>), and <a href=
"#dt-xs_durations"><code>xs:yearMonthDuration</code></a> and
<a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>
(derived from <code>xs:duration</code>).</p>
<p>If <a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">1</font></sub>
is (or is a subtype of) any primitive atomic type other than
<code>xs:decimal</code> or <code>xs:duration</code>, then that type
is its base atomic type.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">1</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">2</font></sub>
is a primitive atomic type</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#jd_not" class="judgment"><b>not</b></a>(<a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">2</font></sub>
<a href="#jd_isin" class="judgment"><b>in</b></a> {
<code>xs:decimal</code>, <code>xs:duration</code> })</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">1</font></sub>
<a href="#jd_has_base_atomic_type" class="judgment"><b>has base
atomic type</b></a> <a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>Similarly for <code>xs:integer</code>, <a href=
"#dt-xs_durations"><code>xs:yearMonthDuration</code></a>, and
<a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>
.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">1</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">2</font></sub>
<a href="#jd_isin" class="judgment"><b>in</b></a> {
<code>xs:integer</code>, <a href=
"#dt-xs_durations"><code>xs:yearMonthDuration</code></a>, <a href=
"#dt-xs_durations"><code>xs:dayTimeDuration</code></a> }</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">1</font></sub>
<a href="#jd_has_base_atomic_type" class="judgment"><b>has base
atomic type</b></a> <a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>For <code>xs:decimal</code>, we exclude <code>xs:integer</code>
and its subtypes:</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">1</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
<code>xs:decimal</code></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_not" class=
"judgment"><b>not</b></a>( <a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">1</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
<code>xs:integer</code> )</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">1</font></sub>
<a href="#jd_has_base_atomic_type" class="judgment"><b>has base
atomic type</b></a> <code>xs:decimal</code></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>And finally, for <code>xs:duration</code>, we exclude <a href=
"#dt-xs_durations"><code>xs:yearMonthDuration</code></a> and
<a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a> ,
and their subtypes.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">1</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
<code>xs:duration</code></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_not" class=
"judgment"><b>not</b></a>( <a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">1</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#dt-xs_durations"><code>xs:yearMonthDuration</code></a> )</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_not" class=
"judgment"><b>not</b></a>( <a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">1</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#dt-xs_durations"><code>xs:dayTimeDuration</code></a> )</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">1</font></sub>
<a href="#jd_has_base_atomic_type" class="judgment"><b>has base
atomic type</b></a> <code>xs:duration</code></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>Note that, in the declarations for the built-in functions
<code>fn:abs</code>, <code>fn:ceiling</code>,
<code>fn:floor</code>, <code>fn:round</code>, and
<code>fn:round-half-to-even</code>, the (first) parameter is
declared with type "<code>numeric?</code>". Thus, for a call to one
of these functions, the normalization rules of <a href=
"#id-function-calls"><b>[4.1.5 Function Calls]</b></a> will have
wrapped the argument in calls to <code>fn:data</code>() and
<a href="#sec_convert_simple_operand"><em>fs:</em><code>convert-simple-operand</code></a>()
(with a 'prototypical value' of type <code>xs:double</code>). Thus,
static analysis of the call is guaranteed that the argument type is
a subtype of <a href=
"#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>*, with no
occurrences of <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>.</p>
<p>In the static typing rule for these functions, we check that the
argument type is numeric, extract its prime type (which must be a
choice of atomic types), find the base atomic type for each, and
then form the choice of those results.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#id-expanded-qnames"><em>expanded-QName</em></a>
<a href="#jd_isin" class="judgment"><b>in</b></a> {
(<code>FN-URI</code>,"<code>abs</code>"),
(<code>FN-URI</code>,"<code>ceiling</code>"),
(<code>FN-URI</code>,"<code>floor</code>"),
(<code>FN-URI</code>,"<code>round</code>"),
(<code>FN-URI</code>,"<code>round-half-to-even</code>") }</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
<em>fs:</em><code>numeric</code> ?</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#jd_prime" class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
= <a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">1</font></sub>
| ... | <a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">n</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">1</font></sub>
<a href="#jd_has_base_atomic_type" class="judgment"><b>has base
atomic type</b></a> <a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">1</font></sub>'</td>
</tr>
<tr align="center" valign="middle">
<td>...</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">n</font></sub>
<a href="#jd_has_base_atomic_type" class="judgment"><b>has base
atomic type</b></a> <a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">n</font></sub>'</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">3</font></sub> = <a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">1</font></sub>'
| ... | <a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">n</font></sub>'</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
<a href="#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub>
· <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>)</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>The <code>fn:round-half-to-even</code> function also has a
two-parameter version. Its static type-checking can be reduced to
that of the one-parameter version.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
<code>xs:integer</code></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
<a href="#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">3</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>(<code>FN-URI</code>,"<code>round-half-to-even</code>")(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>) <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">3</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
</div>
<div class="div3">
<h4><a name="sec_fn_boolean" id="sec_fn_boolean"></a>7.2.4
<span>The <code>fn:boolean</code> <span>and
<code>fn:not</code></span> functions</span></h4>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>The <code>fn:boolean</code> function as described in the
<a href="#xpath-functions-11">[Functions and Operators 1.1]</a>
document takes an empty sequence, a sequence <span>whose first item
is a node</span>, or a singleton value of type
<code>xs:boolean</code>, <code>xs:string</code>,
<span><code>xs:anyURI</code>,</span> <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> or some
numeric type. All other values are illegal. <span>The static typing
of <code>fn:boolean</code> reflects these restrictions, but further
constrains "a sequence whose first item is a node" to "a sequence
of nodes".</span></p>
<p>The <code>fn:not</code> function has an implicit call to
<code>fn:boolean</code>, and raises type errors for the same cases,
so its static typing is the same as <code>fn:boolean</code>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#id-expanded-qnames"><em>expanded-QName</em></a>
<a href="#jd_isin" class="judgment"><b>in</b></a> {
(<code>FN-URI</code>,"<code>boolean</code>"),
(<code>FN-URI</code>,"<code>not</code>") }</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a> <a href="#jd_subtype_of" class=
"judgment"><b>&lt;:</b></a> (empty | <span><font size=
"6">[</font>node()+<font size="6">]</font><a href=
"#jd_map_sequencetype" class="judgment"><sub><font size=
"2">sequencetype</font></sub></a></span> | <code>xs:boolean</code>
| <code>xs:string</code> | <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> |
<em>fs:</em><code>numeric</code> | <code>xs:anyURI</code>)</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><span><a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></span>(<a href=
"#doc-fs-Type"><em>Type</em></a>) <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <code>xs:boolean</code></td>
</tr>
</table>
<br /></div>
</div>
<div class="div3">
<h4><a name="sec_fn_doc_collection" id=
"sec_fn_doc_collection"></a>7.2.5 <span>The
<code>fn:collection</code> and <code>fn:doc</code>
functions</span></h4>
<p><b>Introduction</b></p>
<p>The static typing rules for <code>fn:collection</code> and
<code>fn:doc</code> depend on the syntactic form of their input
expression. As a result, the corresponding static typing rules must
be written directly over the input expression, unlike the other
functions in this section.</p>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>The <code>fn:collection</code> function as described in the
<a href="#xpath-functions-11">[Functions and Operators 1.1]</a>
document, takes a string-valued expression, which denotes a URI,
and returns a value.</p>
<p>If the <code>fn:collection</code> function has no parameter, the
result type is given by the implementation for the default sequence
if it exists.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>QName</em> <a href=
"#jd_func_qname_expands_to" class="judgment"><b>of func expands
to</b></a> (<code>FN-URI</code>,"<code>collection</code>")</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b>Implementation-defined default sequence has
type <a href="#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>QName</em>() <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
<br /></div>
<p>If the argument to <code>fn:collection</code> is a
<em>URILiteral</em> expression which is defined in <a href=
"#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_collection_type_env" class="env">collectionType</a>, then the
result type is the type corresponding to the <em>URILiteral</em> in
<a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_collection_type_env" class="env">collectionType</a>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>QName</em> <a href=
"#jd_func_qname_expands_to" class="judgment"><b>of func expands
to</b></a> (<code>FN-URI</code>,"<code>collection</code>")</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_collection_type_env" class=
"env">collectionType</a>(<em>URILiteral</em>) = <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>QName</em>(<em>URILiteral</em>) <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
<br /></div>
<p>Otherwise, if the argument is a URI literal but is not defined
in <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_collection_type_env" class="env">collectionType</a>, or if it
is not a URI literal, then we don't know anything about the URI and
the static type is a collection of nodes.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>QName</em> <a href=
"#jd_func_qname_expands_to" class="judgment"><b>of func expands
to</b></a> (<code>FN-URI</code>,"<code>collection</code>")</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_collection_type_env" class=
"env">collectionType</a>(<em>URILiteral</em>) undefined</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>QName</em>(<em>URILiteral</em>) <a href=
"#jd_has_type" class="judgment"><b>:</b></a> (element
<span>*</span> | attribute <span>*</span> | processing-instruction
<span>*</span> | text | comment | document ) *</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>QName</em> <a href=
"#jd_func_qname_expands_to" class="judgment"><b>of func expands
to</b></a> (<code>FN-URI</code>,"<code>collection</code>")</td>
</tr>
<tr align="center" valign="middle">
<td><em>Expr</em> is not a <em>URILiteral</em></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>QName</em>(<em>Expr</em>) <a href=
"#jd_has_type" class="judgment"><b>:</b></a> (element
<span>*</span> | attribute <span>*</span> | processing-instruction
<span>*</span> | text | comment | document ) *</td>
</tr>
</table>
<br /></div>
<p>The <code>fn:doc</code> function has similar static typing
rules, but, in addition, the static type must be a document
node.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>QName</em> <a href=
"#jd_func_qname_expands_to" class="judgment"><b>of func expands
to</b></a> (<code>FN-URI</code>,"<code>doc</code>")</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_doc_type_env" class="env">docType</a>(<em>URILiteral</em>) =
<a href="#doc-fs-Type"><em>Type</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><a href="#doc-fs-Type"><em>Type</em></a>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
document</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>QName</em>(<em>URILiteral</em>) <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
<br /></div>
<p>Otherwise, if the argument is a URI literal not defined in the
domain of <a href="#xq_stat_env_def" class=
"env">statEnv</a>.<a href="#xq_doc_type_env" class=
"env">docType</a> or if it is not a URI literal, then we don't know
anything about the URI, and the static type is document.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>QName</em> <a href=
"#jd_func_qname_expands_to" class="judgment"><b>of func expands
to</b></a> (<code>FN-URI</code>,"<code>doc</code>")</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_doc_type_env" class="env">docType</a>(<em>URILiteral</em>)
undefined</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>QName</em>(<em>URILiteral</em>) <a href=
"#jd_has_type" class="judgment"><b>:</b></a> document?</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>QName</em> <a href=
"#jd_func_qname_expands_to" class="judgment"><b>of func expands
to</b></a> (<code>FN-URI</code>,"<code>doc</code>")</td>
</tr>
<tr align="center" valign="middle">
<td><em>Expr</em> is not a <em>URILiteral</em></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>QName</em>(<em>Expr</em>) <a href=
"#jd_has_type" class="judgment"><b>:</b></a> document?</td>
</tr>
</table>
<br /></div>
</div>
<div class="div3">
<h4><a name="sec_fn_data" id="sec_fn_data"></a>7.2.6 The
<code>fn:data</code> function</h4>
<p><b>Introduction</b></p>
<p>The <code>fn:data</code> function converts a sequence of items
to a sequence of atomic values.</p>
<p><b>Notation</b></p>
<p id="jd_data">Inferring the type for the <code>fn:data</code>
function is done by applying the <a href="#jd_data" class=
"judgment"><b>data on</b></a> auxiliary judgment, using the same
approach as for the XPath steps.</p>
<div align="center"><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_data" class=
"judgment"><b>data on</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></div>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>The general rule for <code>fn:data</code> is to apply the filter
<a href="#jd_data" class="judgment"><b>data on</b></a> to the prime
type of its argument type, then apply the quantifier to the
result:</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_data" class=
"judgment"><b>data on</b></a> <a href="#jd_prime" class=
"judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a>)
<a href="#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
(<code>FN-URI</code>,"<code>data</code>")(<a href=
"#doc-fs-Type"><em>Type</em></a>) <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_quantifier" class="judgment">·</a> <a href=
"#jd_quantifier" class="judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a>)</td>
</tr>
</table>
<br /></div>
<p>When applied to none, <a href="#jd_data" class=
"judgment"><b>data on</b></a> yields none.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_data" class=
"judgment"><b>data on</b></a> <code>none</code> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <code>none</code></td>
</tr>
</table>
<br /></div>
<p>When applied to empty, <a href="#jd_data" class=
"judgment"><b>data on</b></a> yields empty.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_data" class=
"judgment"><b>data on</b></a> <code>empty</code> <a href=
"#jd_has_type" class="judgment"><b>:</b></a>
<code>empty</code></td>
</tr>
</table>
<br /></div>
<p>When applied to the union of two types, <a href="#jd_data"
class="judgment"><b>data on</b></a> is applied to each of the two
types. The resulting type is computed using <a href="#jd_prime"
class="judgment">prime</a> and <a href="#jd_quantifier" class=
"judgment">quantifier</a>, which are defined in <a href=
"#sec_factor"><b>[8.4 Judgments for FLWOR and other expressions on
sequences]</b></a>. This rule is necessary because <a href=
"#jd_data" class="judgment"><b>data on</b></a> may return a
sequence of atomic types.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_data" class=
"judgment"><b>data on</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>'</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_data" class=
"judgment"><b>data on</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>'</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_data" class=
"judgment"><b>data on</b></a> (<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>|<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>)
<a href="#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#jd_prime" class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>'|<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>') <a href="#jd_quantifier" class=
"judgment">·</a> <a href="#jd_quantifier" class=
"judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>'|<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>')</td>
</tr>
</table>
<br /></div>
<p>When applied to an atomic type, <a href="#jd_data" class=
"judgment"><b>data on</b></a> simply returns the atomic type:</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><a href="#doc-fs-Type"><em>Type</em></a>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_data" class=
"judgment"><b>data on</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a> <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
<br /></div>
<p>When applied to comment or processing instruction node types,
<a href="#jd_data" class="judgment"><b>data on</b></a> returns
<code>xs:string</code></p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <a href="#doc-fs-Type"><em>Type</em></a>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> comment
| processing-instruction <span>*</span></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_data" class=
"judgment"><b>data on</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a> <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <code>xs:string</code></td>
</tr>
</table>
<br /></div>
<p>When applied to text or document node types, <a href="#jd_data"
class="judgment"><b>data on</b></a> returns <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a></p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <a href="#doc-fs-Type"><em>Type</em></a>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> text |
document</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_data" class=
"judgment"><b>data on</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a> <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a></td>
</tr>
</table>
<br /></div>
<p>When applied to element node types with <a href=
"http://www.w3.org/TR/xquery#dt-type-annotation">type
annotation</a><sup><small>XQ</small></sup> <a href=
"#dt-xs_untyped"><code>xs:untyped</code></a>, the <a href=
"#jd_data" class="judgment"><b>data on</b></a> filter returns
<a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-ElementType"><em>ElementType</em></a> <a href=
"#jd_static_lookup" class="judgment"><b>type lookup</b></a> of type
<a href="#dt-xs_untyped"><code>xs:untyped</code></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_data" class=
"judgment"><b>data on</b></a> <a href=
"#doc-fs-ElementType"><em>ElementType</em></a> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a></td>
</tr>
</table>
<br /></div>
<p>When applied to an attribute node type, the <a href="#jd_data"
class="judgment"><b>data on</b></a> filter returns the attribute's
simple type.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-AttributeType"><em>AttributeType</em></a> <a href=
"#jd_static_lookup" class="judgment"><b>type lookup</b></a> of type
<a href="#doc-fs-TypeName"><em>TypeName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> of type <a href=
"#doc-fs-TypeName"><em>TypeName</em></a> <a href="#jd_expands_to"
class="judgment"><b>expands to</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_data" class=
"judgment"><b>data on</b></a> <a href=
"#doc-fs-AttributeType"><em>AttributeType</em></a> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
<br /></div>
<p>When applied to an element type whose <a href=
"http://www.w3.org/TR/xquery#dt-type-annotation">type
annotation</a><sup><small>XQ</small></sup> denotes a simple type or
a complex type of simple content, <a href="#jd_data" class=
"judgment"><b>data on</b></a> returns the element's simple
type.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-ElementType"><em>ElementType</em></a> <a href=
"#jd_static_lookup" class="judgment"><b>type lookup</b></a>
<a href="#doc-fs-TypeReference"><em>TypeReference</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a> <a href=
"#jd_expands_to" class="judgment"><b>expands to</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <a href="#doc-fs-Type"><em>Type</em></a>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
(attribute<span>*</span>*, <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
&#160;&#160;&#160;&#160; <a href="#xq_stat_env_def" class=
"env">statEnv</a> <b>&#160;|-&#160;</b> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>*</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_data" class=
"judgment"><b>data on</b></a> <a href=
"#doc-fs-ElementType"><em>ElementType</em></a> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
<br /></div>
<p>When applied to an element type whose <a href=
"http://www.w3.org/TR/xquery#dt-type-annotation">type
annotation</a><sup><small>XQ</small></sup> denotes a complex type
of mixed content, the <a href="#jd_data" class="judgment"><b>data
on</b></a> filter returns <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-ElementType"><em>ElementType</em></a> <a href=
"#jd_static_lookup" class="judgment"><b>type lookup</b></a> of type
<a href="#doc-fs-TypeName"><em>TypeName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-TypeName"><em>TypeName</em></a> <a href=
"#jd_elem_qname_expands_to" class="judgment"><b>of elem/type
expands to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>
&#160;&#160;&#160;&#160; <a href="#xq_stat_env_def" class=
"env">statEnv</a>.<a href="#xq_type_defn" class=
"env">typeDefn</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>) = define type
<a href="#doc-fs-TypeName"><em>TypeName</em></a> <a href=
"#doc-fs-Derivation"><em>Derivation</em></a> mixed { <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
}</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_data" class=
"judgment"><b>data on</b></a> <a href=
"#doc-fs-ElementType"><em>ElementType</em></a> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> xs:untypedAtomic</td>
</tr>
</table>
<br /></div>
<p>The <a href="#jd_data" class="judgment"><b>data on</b></a>
filter is not defined on any element type whose <a href=
"http://www.w3.org/TR/xquery#dt-type-annotation">type
annotation</a><sup><small>XQ</small></sup> denotes a complex type
of complex content and therefore applying <a href="#jd_data" class=
"judgment"><b>data on</b></a> to such a node raises a static
error.</p>
<p><b>Example</b></p>
<p>Consider the following variable and its corresponding static
type.</p>
<div class="exampleInner">
<pre>
    $x : (element price { attribute currency { xs:string }, xs:decimal }
         | element price_code { xs:integer })
</pre></div>
<p>Applying the <code>fn:data</code> function on that variable
results in the following type.</p>
<div class="exampleInner">
<pre>
    fn:data($x) : (xs:decimal | xs:integer)
</pre></div>
<p>Because the input type is a choice, applying the <a href=
"#jd_data" class="judgment"><b>data on</b></a> filter results in a
choice of simple types for the output of the <code>fn:data</code>
function.</p>
</div>
<div class="div3">
<h4><a name="sec_fn_distinct_node_vals" id=
"sec_fn_distinct_node_vals"></a>7.2.7 <span>The
<code>fn:distinct-values</code> function</span></h4>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>The <code>fn:distinct-values</code> function expects a sequence
of atomic values as input and returns a sequence of prime types,
which are defined in <a href="#sec_factor"><b>[8.4 Judgments for
FLWOR and other expressions on sequences]</b></a>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><a href="#doc-fs-Type"><em>Type</em></a>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>*</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b>(<code>FN-URI</code>,"<code>distinct-values</code>")(<a href="#doc-fs-Type"><em>Type</em></a>)
<a href="#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#jd_prime" class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a>) <a href="#jd_quantifier" class=
"judgment">·</a> <a href="#jd_quantifier" class=
"judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a>)</td>
</tr>
</table>
<br /></div>
</div>
<div class="div3">
<h4><a name="sec_fn_unordered" id="sec_fn_unordered"></a>7.2.8
<span>The <code>fn:unordered</code> function</span></h4>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>The static semantics for <code>fn:unordered</code> is computed
using <a href="#jd_prime" class="judgment">prime</a> and <a href=
"#jd_quantifier" class="judgment">quantifier</a>, which are defined
in <a href="#sec_factor"><b>[8.4 Judgments for FLWOR and other
expressions on sequences]</b></a>. The type of the argument is
determined, and then <a href="#jd_prime" class=
"judgment">prime</a>(.) and <a href="#jd_quantifier" class=
"judgment">quantifier</a>(.) are applied to that type.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b>(<code>FN-URI</code>,"<code>unordered</code>")(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
<a href="#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#jd_prime" class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
<a href="#jd_quantifier" class="judgment">·</a> <a href=
"#jd_quantifier" class="judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>)</td>
</tr>
</table>
<br /></div>
</div>
<div class="div3">
<h4><a name="sec_fnerror" id="sec_fnerror"></a>7.2.9 <span>The
<code>fn:error</code> function</span></h4>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>The fn:error function always has the <code>none</code> type.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b>(<code>FN-URI</code>,"<code>error</code>")()
<a href="#jd_has_type" class="judgment"><b>:</b></a>
<code>none</code></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><a href="#doc-fs-Type"><em>Type</em></a>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
<code>xs:QName</code></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b>(<code>FN-URI</code>,"<code>error</code>")(<a href="#doc-fs-Type"><em>Type</em></a>)
<a href="#jd_has_type" class="judgment"><b>:</b></a>
<code>none</code></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
<code>xs:QName</code>?&#160;&#160;&#160;&#160;<a href=
"#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
<code>xs:string</code></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b>(<code>FN-URI</code>,"<code>error</code>")(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>)
<a href="#jd_has_type" class="judgment"><b>:</b></a>
<code>none</code></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
<code>xs:QName</code>?&#160;&#160;&#160;&#160;<a href=
"#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
<code>xs:string</code></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b>(<code>FN-URI</code>,"<code>error</code>")(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>,<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub>)
<a href="#jd_has_type" class="judgment"><b>:</b></a>
<code>none</code></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
</div>
<div class="div3">
<h4><a name="sec_fn_aggregates" id="sec_fn_aggregates"></a>7.2.10
<span>The <code>fn:min</code>, <code>fn:max</code>,
<code>fn:avg</code>, and <code>fn:sum</code> functions</span></h4>
<p><b>Introduction</b></p>
<p>The semantics of aggregate functions convert any item of type
<a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> in
the input sequence to <code>xs:double</code>, then attempt to
promote all values in the input sequence to values that are
comparable. The static typing rules reflect the dynamic evaluation
rules.</p>
<p>The <code>fn:sum</code> function has two forms. The first form
takes two arguments: The first argument is the input sequence and
the second argument is the value that should be returned if the
input sequence is empty. In case there is no second argument, the
value returned for an empty sequence is the <code>xs:integer</code>
value 0. The following static typing rule applies in the case there
is no second argument.</p>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
(<code>FN-URI</code>,"<code>sum</code>")(
<span><em>Expr</em>,0</span> <span><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,
<code>xs:integer</code></span> ) <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <span><a href=
"#doc-fs-Type"><em>Type</em></a></span> <span><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></span></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
(<code>FN-URI</code>,"<code>sum</code>")(
<span><em>Expr</em></span> <span><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></span> ) <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <span><a href=
"#doc-fs-Type"><em>Type</em></a></span> <span><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></span></td>
</tr>
</table>
<br /></div>
<p><b>Notation</b></p>
<p id="jd_convert_untypedAtomic">The type function <a href=
"#jd_convert_untypedAtomic" class=
"judgment"><b>convert_untypedAtomic</b></a> takes a prime type and
converts all occurrences of the type <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> to a
target type. It is defined recursively as follows.</p>
<table summary="" class="figure">
<col align="left" span="1" />
<col align="left" span="1" />
<col align="center" span="1" />
<col align="left" span="1" />
<col align="left" span="1" />
<tbody>
<tr>
<td></td>
<td><a href="#jd_convert_untypedAtomic" class=
"judgment"><b>convert_untypedAtomic</b></a>(<a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>, <a href=
"#doc-fs-Type"><em>Type</em></a>)</td>
<td>&#160;&#160;=&#160;&#160;</td>
<td><a href="#doc-fs-Type"><em>Type</em></a></td>
</tr>
<tr>
<td>if not(<a href=
"#doc-fs-FormalItemType"><em>FormalItemType</em></a> = <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>)</td>
<td><a href="#jd_convert_untypedAtomic" class=
"judgment"><b>convert_untypedAtomic</b></a>(<a href=
"#doc-fs-FormalItemType"><em>FormalItemType</em></a>, <a href=
"#doc-fs-Type"><em>Type</em></a>)</td>
<td>&#160;&#160;=&#160;&#160;</td>
<td><a href=
"#doc-fs-FormalItemType"><em>FormalItemType</em></a></td>
</tr>
<tr>
<td></td>
<td><a href="#jd_convert_untypedAtomic" class=
"judgment"><b>convert_untypedAtomic</b></a>(<code>empty</code>,
<a href="#doc-fs-Type"><em>Type</em></a>)</td>
<td>&#160;&#160;=&#160;&#160;</td>
<td><code>empty</code></td>
</tr>
<tr>
<td></td>
<td><a href="#jd_convert_untypedAtomic" class=
"judgment"><b>convert_untypedAtomic</b></a>(<code>none</code>,
<a href="#doc-fs-Type"><em>Type</em></a>)</td>
<td>&#160;&#160;=&#160;&#160;</td>
<td><code>none</code></td>
</tr>
<tr>
<td></td>
<td><a href="#jd_convert_untypedAtomic" class=
"judgment"><b>convert_untypedAtomic</b></a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
| <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>, <a href="#doc-fs-Type"><em>Type</em></a>)</td>
<td>&#160;&#160;=&#160;&#160;</td>
<td><a href="#jd_convert_untypedAtomic" class=
"judgment"><b>convert_untypedAtomic</b></a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,
<a href="#doc-fs-Type"><em>Type</em></a>) | <a href=
"#jd_convert_untypedAtomic" class=
"judgment"><b>convert_untypedAtomic</b></a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>,
<a href="#doc-fs-Type"><em>Type</em></a>)</td>
</tr>
</tbody>
</table>
<p><b>Notation</b></p>
<p id="jd_agg_quantifier">The function <a href="#jd_agg_quantifier"
class="judgment"><b>aggregate_quantifier</b></a> converts the input
type quantifier zero-or-more or zero-or-one to the result type
quantifier zero-or-one, and converts the input type quantifier one
or one-or-more, to the result type quantifier one.</p>
<table summary="" class="figure">
<col align="left" span="1" />
<col align="center" span="1" />
<col align="left" span="1" />
<tbody>
<tr>
<td><a href="#jd_agg_quantifier" class=
"judgment"><b>aggregate_quantifier</b></a>(<code>?</code>)</td>
<td>&#160;&#160;=&#160;&#160;</td>
<td><code>?</code></td>
</tr>
<tr>
<td><a href="#jd_agg_quantifier" class=
"judgment"><b>aggregate_quantifier</b></a>(<code>*</code>)</td>
<td>&#160;&#160;=&#160;&#160;</td>
<td><code>?</code></td>
</tr>
<tr>
<td><a href="#jd_agg_quantifier" class=
"judgment"><b>aggregate_quantifier</b></a>(<code>1</code>)</td>
<td>&#160;&#160;=&#160;&#160;</td>
<td><code>1</code></td>
</tr>
<tr>
<td><a href="#jd_agg_quantifier" class=
"judgment"><b>aggregate_quantifier</b></a>(<code>+</code>)</td>
<td>&#160;&#160;=&#160;&#160;</td>
<td><code>1</code></td>
</tr>
</tbody>
</table>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>Now we can define the static typing rules for the aggregate
functions. First, the input type is converted to a prime type.
Second, the type function <a href="#jd_convert_untypedAtomic"
class="judgment"><b>convert_untypedAtomic</b></a> is applied to the
prime type, yielding a new prime type, in which occurrences of
<a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>
are converted to <code>xs:double</code>. Third, the judgment
<a href="#jd_can_be_promoted_to" class="judgment"><b>can be
promoted to</b></a> is applied to the new prime type and target
type. The result type is combined with the aggregate quantifier of
the input type.</p>
<p>For a given aggregate function, instead of writing a separate
judgment for each target type, we write one rule using a target
type <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub>.</p>
<p>For <code>fn:min</code> and <code>fn:max</code>, the target type
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub> is either <code>xs:string</code>,
<code>xs:integer</code>, <code>xs:decimal</code>,
<code>xs:float</code>, <code>xs:double</code>,
<code>xs:date</code>, <code>xs:time</code>,
<code>xs:dateTime</code>, <a href=
"#dt-xs_durations"><code>xs:yearMonthDuration</code></a>, or
<a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>
.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub> = <a href="#jd_prime" class=
"judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub> = <a href="#jd_convert_untypedAtomic" class=
"judgment"><b>convert_untypedAtomic</b></a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,
<code>xs:double</code>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub> = empty</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
(<code>FN-URI</code>,"<code>min</code>")(<a href=
"#doc-fs-Type"><em>Type</em></a>) <a href="#jd_has_type" class=
"judgment"><b>:</b></a> empty</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub> = <a href="#jd_prime" class=
"judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub> = <a href="#jd_convert_untypedAtomic" class=
"judgment"><b>convert_untypedAtomic</b></a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,
<code>xs:double</code>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href=
"#doc-fs-FormalItemType"><em>FormalItemType</em></a><sub><font size="2">1</font></sub>,
...,<a href=
"#doc-fs-FormalItemType"><em>FormalItemType</em></a><sub><font size="2">n</font></sub>
= <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-FormalItemType"><em>FormalItemType</em></a><sub><font size="2">1</font></sub>
<a href="#jd_can_be_promoted_to" class="judgment"><b>can be
promoted to</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td>...</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-FormalItemType"><em>FormalItemType</em></a><sub><font size="2">n</font></sub>
<a href="#jd_can_be_promoted_to" class="judgment"><b>can be
promoted to</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub> <a href="#jd_isin" class=
"judgment"><b>in</b></a> { <code>xs:string</code>,
<code>xs:integer</code>, <code>xs:decimal</code>,
<code>xs:float</code>, <code>xs:double</code>,
<code>xs:date</code>, <code>xs:time</code>,
<code>xs:dateTime</code>, <a href=
"#dt-xs_durations"><code>xs:yearMonthDuration</code></a>, <a href=
"#dt-xs_durations"><code>xs:dayTimeDuration</code></a> }</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
(<code>FN-URI</code>,"<code>min</code>")(<a href=
"#doc-fs-Type"><em>Type</em></a>) <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>
<a href="#jd_quantifier" class="judgment">·</a> <a href=
"#jd_agg_quantifier" class=
"judgment"><b>aggregate_quantifier</b></a>(<a href="#jd_quantifier"
class="judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a>))</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub> = <a href="#jd_prime" class=
"judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub> = <a href="#jd_convert_untypedAtomic" class=
"judgment"><b>convert_untypedAtomic</b></a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,
<code>xs:double</code>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub> = empty</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
(<code>FN-URI</code>,"<code>max</code>")(<a href=
"#doc-fs-Type"><em>Type</em></a>) <a href="#jd_has_type" class=
"judgment"><b>:</b></a> empty</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub> = <a href="#jd_prime" class=
"judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub> = <a href="#jd_convert_untypedAtomic" class=
"judgment"><b>convert_untypedAtomic</b></a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,
<code>xs:double</code>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub> = <a href=
"#doc-fs-FormalItemType"><em>FormalItemType</em></a><sub><font size="2">1</font></sub>,
...,<a href=
"#doc-fs-FormalItemType"><em>FormalItemType</em></a><sub><font size="2">n</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-FormalItemType"><em>FormalItemType</em></a><sub><font size="2">1</font></sub>
<a href="#jd_can_be_promoted_to" class="judgment"><b>can be
promoted to</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td>...</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-FormalItemType"><em>FormalItemType</em></a><sub><font size="2">n</font></sub>
<a href="#jd_can_be_promoted_to" class="judgment"><b>can be
promoted to</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub> <a href="#jd_isin" class=
"judgment"><b>in</b></a> { <code>xs:string</code>,
<code>xs:integer</code>, <code>xs:decimal</code>,
<code>xs:float</code>, <code>xs:double</code>,
<code>xs:date</code>, <code>xs:time</code>,
<code>xs:dateTime</code>, <a href=
"#dt-xs_durations"><code>xs:yearMonthDuration</code></a>, <a href=
"#dt-xs_durations"><code>xs:dayTimeDuration</code></a> }</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
(<code>FN-URI</code>,"<code>max</code>")(<a href=
"#doc-fs-Type"><em>Type</em></a>) <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>
<a href="#jd_quantifier" class="judgment">·</a> <a href=
"#jd_agg_quantifier" class=
"judgment"><b>aggregate_quantifier</b></a>(<a href="#jd_quantifier"
class="judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a>))</td>
</tr>
</table>
<br /></div>
<p>For <code>fn:avg</code>, the target type <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>
is either <code>xs:decimal</code>, <code>xs:float</code>,
<code>xs:double</code>, <a href=
"#dt-xs_durations"><code>xs:yearMonthDuration</code></a>, or
<a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>
.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub> = <a href="#jd_prime" class=
"judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub> = <a href="#jd_convert_untypedAtomic" class=
"judgment"><b>convert_untypedAtomic</b></a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,
<code>xs:double</code>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub> = empty</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
(<code>FN-URI</code>,"<code>avg</code>")(<a href=
"#doc-fs-Type"><em>Type</em></a>) <a href="#jd_has_type" class=
"judgment"><b>:</b></a> empty</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub> = <a href="#jd_prime" class=
"judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub> = <a href="#jd_convert_untypedAtomic" class=
"judgment"><b>convert_untypedAtomic</b></a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,
<code>xs:double</code>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href=
"#doc-fs-FormalItemType"><em>FormalItemType</em></a><sub><font size="2">1</font></sub>,
...,<a href=
"#doc-fs-FormalItemType"><em>FormalItemType</em></a><sub><font size="2">n</font></sub>
= <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-FormalItemType"><em>FormalItemType</em></a><sub><font size="2">1</font></sub>
<a href="#jd_can_be_promoted_to" class="judgment"><b>can be
promoted to</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td>...</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-FormalItemType"><em>FormalItemType</em></a><sub><font size="2">n</font></sub>
<a href="#jd_can_be_promoted_to" class="judgment"><b>can be
promoted to</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub> <a href="#jd_isin" class=
"judgment"><b>in</b></a> { <code>xs:decimal</code>,
<code>xs:float</code>, <code>xs:double</code>, <a href=
"#dt-xs_durations"><code>xs:yearMonthDuration</code></a>, <a href=
"#dt-xs_durations"><code>xs:dayTimeDuration</code></a> }</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
(<code>FN-URI</code>,"<code>avg</code>")(<a href=
"#doc-fs-Type"><em>Type</em></a>) <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>
<a href="#jd_quantifier" class="judgment">·</a> <a href=
"#jd_agg_quantifier" class=
"judgment"><b>aggregate_quantifier</b></a>(<a href="#jd_quantifier"
class="judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a>))</td>
</tr>
</table>
<br /></div>
<p>For <code>fn:sum</code>, the target type <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>
is either <code>xs:integer</code>, <code>xs:decimal</code>,
<code>xs:float</code>, <code>xs:double</code>, <a href=
"#dt-xs_durations"><code>xs:yearMonthDuration</code></a>, or
<a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a> .
The second argument in <code>fn:sum</code> is the value that should
be returned if the input sequence is empty. The result type is the
union of the target type and the type of the second argument. Note
that the rule checks that the type for the zero value is consistent
with the type of the input sequence.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub> = <a href="#jd_prime" class=
"judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub> = <a href="#jd_convert_untypedAtomic" class=
"judgment"><b>convert_untypedAtomic</b></a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,
<code>xs:double</code>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub> = empty</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
(<code>FN-URI</code>,"<code>sum</code>")(<a href=
"#doc-fs-Type"><em>Type</em></a>) <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <code>xs:integer</code></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a> ?</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">3</font></sub> = <a href="#jd_prime" class=
"judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">4</font></sub> = <a href="#jd_convert_untypedAtomic" class=
"judgment"><b>convert_untypedAtomic</b></a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub>,
<code>xs:double</code>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href=
"#doc-fs-FormalItemType"><em>FormalItemType</em></a><sub><font size="2">1</font></sub>,
...,<a href=
"#doc-fs-FormalItemType"><em>FormalItemType</em></a><sub><font size="2">n</font></sub>
= <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">4</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-FormalItemType"><em>FormalItemType</em></a><sub><font size="2">1</font></sub>
<a href="#jd_can_be_promoted_to" class="judgment"><b>can be
promoted to</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td>...</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-FormalItemType"><em>FormalItemType</em></a><sub><font size="2">n</font></sub>
<a href="#jd_can_be_promoted_to" class="judgment"><b>can be
promoted to</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub> <a href="#jd_isin" class=
"judgment"><b>in</b></a> { <code>xs:integer</code>,
<code>xs:decimal</code>, <code>xs:float</code>,
<code>xs:double</code>, <a href=
"#dt-xs_durations"><code>xs:yearMonthDuration</code></a> }</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
(<code>FN-URI</code>,"<code>sum</code>")(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>,<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>)
<a href="#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>
<a href="#jd_quantifier" class="judgment">·</a> <a href=
"#jd_agg_quantifier" class=
"judgment"><b>aggregate_quantifier</b></a>(<a href="#jd_quantifier"
class="judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>))</td>
</tr>
</table>
<br /></div>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>Now we can define the static typing rules for the aggregate
functions. Note that the normalization rules of <a href=
"#id-function-calls"><b>[4.1.5 Function Calls]</b></a> will have
wrapped each argument in calls to <code>fn:data</code>() and
<a href=
"#sec_convert_simple_operand"><em>fs:</em><code>convert-simple-operand</code></a>()
(with a 'prototypical value' of type <code>xs:double</code>). Thus,
static analysis of the call to an aggregate function is guaranteed
that any argument type is a subtype of <a href=
"#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>*, with no
occurrences of <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>.</p>
<p>First, we can quickly deal with <code>fn:avg</code>. For the
purposes of static type analysis, <code>fn:avg($arg)</code> is
equivalent to <code>fs:div( fn:sum($arg,()), fn:count($arg)
)</code> Thus, we have the rule:</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>(<code>FN-URI</code>,"<code>sum</code>")(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,
empty) <a href="#jd_has_type" class="judgment"><b>:</b></a>
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>(<code>FS-URI</code>,"<code>div</code>")(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>,
<code>xs:integer</code>) <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">3</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>(<code>FN-URI</code>,"<code>avg</code>")(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
<a href="#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">3</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>For the remaining aggregate functions (<code>fn:min</code>,
<code>fn:max</code>, and <code>fn:sum</code>), the general approach
is as follows. First, we check that the input type(s) are
acceptable for the function. Then we construct the (first)
argument's prime type, a union of AtomicTypeNames. For each of the
latter, we find the 'base atomic type'. The union of these base
atomic types is the basis for the result type, which may finally be
adjusted for cardinality (<code>fn:min</code> and
<code>fn:max</code>) or for the effect of the second argument
(<code>fn:sum</code>). In addition, we provide a rule for the
special case when the (first) argument has type 'empty'.</p>
<p>For <code>fn:min</code> and <code>fn:max</code>, the permitted
input types are all those for which ge(T,T) and le(T,T) are
defined. An empty input sequence yields an empty result.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#id-expanded-qnames"><em>expanded-QName</em></a>
<a href="#jd_isin" class="judgment"><b>in</b></a> {
(<code>FN-URI</code>,"<code>min</code>"),
(<code>FN-URI</code>,"<code>max</code>") }</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a> = empty</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>(<a href=
"#doc-fs-Type"><em>Type</em></a>) <a href="#jd_has_type" class=
"judgment"><b>:</b></a> empty</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#id-expanded-qnames"><em>expanded-QName</em></a>
<a href="#jd_isin" class="judgment"><b>in</b></a> {
(<code>FN-URI</code>,"<code>min</code>"),
(<code>FN-URI</code>,"<code>max</code>") }</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">3</font></sub>*</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">3</font></sub> <a href="#jd_isin" class=
"judgment"><b>in</b></a> { <em>fs:</em><code>numeric</code>,
<code>xs:anyURI</code>|<code>xs:string</code>, <a href=
"#dt-xs_durations"><code>xs:yearMonthDuration</code></a>, <a href=
"#dt-xs_durations"><code>xs:dayTimeDuration</code></a> ,
<code>xs:date</code>, <code>xs:time</code>,
<code>xs:dateTime</code>, <code>xs:boolean</code> }</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#jd_prime" class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
= <a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">1</font></sub>
| ... | <a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">n</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">1</font></sub>
<a href="#jd_has_base_atomic_type" class="judgment"><b>has base
atomic type</b></a> <a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">1</font></sub>'</td>
</tr>
<tr align="center" valign="middle">
<td>...</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">n</font></sub>
<a href="#jd_has_base_atomic_type" class="judgment"><b>has base
atomic type</b></a> <a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">n</font></sub>'</td>
</tr>
<tr align="center" valign="middle">
<td><a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">1</font></sub>'
| ... | <a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">n</font></sub>'
= <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">4</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
<a href="#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">4</font></sub>
· <a href="#jd_agg_quantifier" class=
"judgment"><b>aggregate_quantifier</b></a>(<a href="#jd_quantifier"
class="judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>))</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>For <code>fn:sum</code>, the permitted input types for the first
argument are all those for which plus(T,T) is defined. If you pass
an empty sequence as the first argument, the function returns the
value of the second argument.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub> = empty</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>?</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>(<code>FN-URI</code>,"<code>sum</code>")(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>)
<a href="#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">3</font></sub>*</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">3</font></sub> <a href="#jd_isin" class=
"judgment"><b>in</b></a> {<em>fs:</em><code>numeric</code>,
<a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a>,
<a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>
}</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>?</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#jd_prime" class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
= <a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">1</font></sub>
| ... | <a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">n</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">1</font></sub>
<a href="#jd_has_base_atomic_type" class="judgment"><b>has base
atomic type</b></a> <a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">1</font></sub>'</td>
</tr>
<tr align="center" valign="middle">
<td>...</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">n</font></sub>
<a href="#jd_has_base_atomic_type" class="judgment"><b>has base
atomic type</b></a> <a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">n</font></sub>'</td>
</tr>
<tr align="center" valign="middle">
<td><a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">1</font></sub>'
| ... | <a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">n</font></sub>'
= <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">4</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_sacfsw" class=
"judgment"><b>second argument contribution for sum with</b></a>
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_sacfsw" class=
"judgment"><b>and</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_sacfsw" class="judgment"><b>is</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>'</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>(<code>FN-URI</code>,"<code>sum</code>")(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>)
<a href="#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">4</font></sub>
| <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>'</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p id="jd_sacfsw">The second argument's contribution (if any) to
the above result type is determined as follows. If the first
argument could be the empty sequence, we add the type of the second
argument to the result type. Otherwise, the type of the second
argument is ignored.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>empty <a href=
"#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_sacfsw" class=
"judgment"><b>second argument contribution for sum with</b></a>
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_sacfsw" class=
"judgment"><b>and</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_sacfsw" class="judgment"><b>is</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_not" class=
"judgment"><b>not</b></a> (empty <a href="#jd_subtype_of" class=
"judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>)</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_sacfsw" class=
"judgment"><b>second argument contribution for sum with</b></a>
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_sacfsw" class=
"judgment"><b>and</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_sacfsw" class="judgment"><b>is</b></a> none</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
</div>
<div class="div3">
<h4><a name="sec_fn_remove" id="sec_fn_remove"></a>7.2.11 <span>The
<code>fn:remove</code> function</span></h4>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>The static type for the <code>fn:remove</code> function is
computed using <a href="#jd_prime" class="judgment">prime</a> and
<a href="#jd_quantifier" class="judgment">quantifier</a>, which are
defined in <a href="#sec_factor"><b>[8.4 Judgments for FLWOR and
other expressions on sequences]</b></a>. Since one item may be
removed from the sequence, the resulting type is made optional.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
<code>xs:integer</code></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
(<code>FN-URI</code>,"<code>remove</code>")(<a href=
"#doc-fs-Type"><em>Type</em></a>, <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
<a href="#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#jd_prime" class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a>) <a href="#jd_quantifier" class=
"judgment">·</a> <a href="#jd_quantifier" class=
"judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a>)
<a href="#jd_quantifier" class="judgment">·</a> ?</td>
</tr>
</table>
<br /></div>
</div>
<div class="div3">
<h4><a name="sec_fn_reverse" id="sec_fn_reverse"></a>7.2.12
<span>The <code>fn:reverse</code> function</span></h4>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>The static type for the <code>fn:reverse</code> function is
computed using <a href="#jd_prime" class="judgment">prime</a> and
<a href="#jd_quantifier" class="judgment">quantifier</a>, which are
defined in <a href="#sec_factor"><b>[8.4 Judgments for FLWOR and
other expressions on sequences]</b></a>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
(<code>FN-URI</code>,"<code>reverse</code>")(<a href=
"#doc-fs-Type"><em>Type</em></a>) <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href="#jd_prime" class=
"judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a>)
<a href="#jd_quantifier" class="judgment">·</a> <a href=
"#jd_quantifier" class="judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a>)</td>
</tr>
</table>
<br /></div>
</div>
<div class="div3">
<h4><a name="sec_fn_subsequence" id="sec_fn_subsequence"></a>7.2.13
<span>The <code>fn:subsequence</code> function</span></h4>
<p><b>Introduction</b></p>
<p>The <code>fn:subsequence</code> function has special static
typing rules when its second argument is the numeric literal value
1 or the built-in variable <a href=
"#fs_builtin_vars"><code>$</code><em>fs:</em><code>last</code></a>.
These rules provide better typing for path expressions such as
<em>Expr</em>[1] and <em>Expr</em>[<code>fn:last</code>()].</p>
<p>The static typing rules for <code>fn:subsequence</code> depends
on the syntactic form of their input expression. As a result, the
corresponding static typing rules must be written directly over the
input expression, unlike the other functions in this section.</p>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>If the type of the input expression has exactly one or
one-or-more items, then the type inferred for
<code>fn:subsequence</code> is the prime type of the input
type.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>QName</em> <a href=
"#jd_func_qname_expands_to" class="judgment"><b>of func expands
to</b></a> (<code>FN-URI</code>,"<code>subsequence</code>")</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>Expr</em> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a>&#160;&#160;&#160;&#160;<a href=
"#jd_quantifier" class="judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a>) <a href="#jd_isin" class=
"judgment"><b>in</b></a> { <code>1</code>, <code>+</code> }</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>QName</em>(<em>Expr</em>, 1, 1) <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href="#jd_prime"
class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a>)</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>If the type of the input expression has zero or more items,
<code>fn:subsequence</code> is applied on a numeric literal,
<a href=
"#fs_builtin_vars"><code>$</code><em>fs:</em><code>position</code></a>,
or <a href=
"#fs_builtin_vars"><code>$</code><em>fs:</em><code>last</code></a>,
then the static type is zero-or-one of the prime type of the input
type. Those static typing rules are intended to support more
precise typing for the cases where <code>fn:subsequence</code> is
the result of normalizing an XPath predicate of the form
<em>Expr</em>[<em>NumericLiteral</em>] of <em>Expr</em>[last()],
see <a href="#id-axis-steps"><b>[4.2.1 Steps]</b></a>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>QName</em> <a href=
"#jd_func_qname_expands_to" class="judgment"><b>of func expands
to</b></a> (<code>FN-URI</code>,"<code>subsequence</code>")</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>Expr</em> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a>&#160;&#160;&#160;&#160;<a href=
"#jd_quantifier" class="judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a>) <a href="#jd_isin" class=
"judgment"><b>in</b></a> { <code>*</code>, <code>+</code> }</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>QName</em>(<em>Expr</em>,
<em>NumericLiteral</em>, 1) <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href="#jd_prime" class=
"judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a>)
<code>?</code></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>The same rule applies when the last item in the input sequence
is selected.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>QName</em> <a href=
"#jd_func_qname_expands_to" class="judgment"><b>of func expands
to</b></a> (<code>FN-URI</code>,"<code>subsequence</code>")</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>Expr</em> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a>&#160;&#160;&#160;&#160;<a href=
"#jd_quantifier" class="judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a>) <a href="#jd_isin" class=
"judgment"><b>in</b></a> { <code>*</code>, <code>+</code> }</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>QName</em>(<em>Expr</em>, <a href=
"#fs_builtin_vars"><code>$</code><em>fs:</em><code>last</code></a>,
1) <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#jd_prime" class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a>) <code>?</code></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>The same rule applies when an item is selected based on its
position in the input sequence.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>QName</em> <a href=
"#jd_func_qname_expands_to" class="judgment"><b>of func expands
to</b></a> (<code>FN-URI</code>,"<code>subsequence</code>")</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>Expr</em> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a>&#160;&#160;&#160;&#160;<a href=
"#jd_quantifier" class="judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a>) <a href="#jd_isin" class=
"judgment"><b>in</b></a> { <code>*</code>, <code>+</code> }</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><em>QName</em>(<em>Expr</em>, <a href=
"#fs_builtin_vars"><code>$</code><em>fs:</em><code>position</code></a>,
1) <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#jd_prime" class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a>) <code>?</code></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>The last rule applies to all other applications of the
<code>fn:subsequence</code> function.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>QName</em> <a href=
"#jd_func_qname_expands_to" class="judgment"><b>of func expands
to</b></a> (<code>FN-URI</code>,"<code>subsequence</code>")</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>Expr</em> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">1</font></sub> <a href="#jd_has_type" class=
"judgment"><b>:</b></a>
<code>xs:double</code>&#160;&#160;&#160;&#160;<a href=
"#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>Expr</em><sub><font size=
"2">2</font></sub> <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <code>xs:double</code></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
<em>QName</em>(<em>Expr</em>, <em>Expr</em><sub><font size=
"2">1</font></sub>, <em>Expr</em><sub><font size=
"2">2</font></sub>) <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href="#jd_prime" class=
"judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a>)
<a href="#jd_quantifier" class="judgment">·</a> <a href=
"#jd_quantifier" class="judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a>) <a href="#jd_quantifier" class=
"judgment">·</a> ?</td>
</tr>
</table>
<br /></div>
<p>The static type of a call to <code>fn:subsequence</code> is
computed using <a href="#jd_prime" class="judgment">prime</a>() and
<a href="#jd_quantifier" class="judgment">quantifier</a>(), which
are defined in <a href="#sec_factor"><b>[8.4 Judgments for FLWOR
and other expressions on sequences]</b></a>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
<em>fs:</em><code>numeric</code>&#160;&#160;&#160;&#160;<a href=
"#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
<em>fs:</em><code>numeric</code></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
(<code>FN-URI</code>,"<code>subsequence</code>")(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>, <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub>)
<a href="#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#jd_prime" class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
<a href="#jd_quantifier" class="judgment">·</a> <a href=
"#jd_quantifier" class="judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
<a href="#jd_quantifier" class="judgment">·</a> ?</td>
</tr>
</table>
<br /></div>
</div>
<div class="div3">
<h4><a name="sec_op_union_intersect_except" id=
"sec_op_union_intersect_except"></a>7.2.14 <span>The
<code>op:union</code>, <code>op:intersect</code>, and
<code>op:except</code> operators</span></h4>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>The static semantics for <code>op:union</code> is computed using
<a href="#jd_prime" class="judgment">prime</a> and <a href=
"#jd_quantifier" class="judgment">quantifier</a>, which are defined
in <a href="#sec_factor"><b>[8.4 Judgments for FLWOR and other
expressions on sequences]</b></a>. The type of each argument is
determined, and then <a href="#jd_prime" class=
"judgment">prime</a>(.) and <a href="#jd_quantifier" class=
"judgment">quantifier</a>(.) are applied to the sequence type
(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>, <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>).</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b>(<code>OP-URI</code>,"<code>union</code>")(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>) <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href="#jd_prime" class=
"judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
, <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>) <a href="#jd_quantifier" class="judgment">·</a>
<a href="#jd_quantifier" class="judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
, <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>)</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>The static semantics of <code>op:intersect</code> is analogous
to that for <code>op:union</code>. Because an intersection may be
empty, the result type is optional.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b>(<code>OP-URI</code>,"<code>intersect</code>")(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>) <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href="#jd_prime" class=
"judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>) <a href="#jd_quantifier" class="judgment">·</a>
<a href="#jd_quantifier" class="judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>,<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>)
<a href="#jd_quantifier" class="judgment">·</a> ?</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>The static semantics of <code>op:except</code> follows. The type
of the second argument is ignored as it does not contribute to the
result type. As with <code>op:intersect</code>, the result of
<code>op:except</code> may be the empty sequence.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b>(<code>OP-URI</code>,"<code>except</code>")(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>) <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href="#jd_prime" class=
"judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
<a href="#jd_quantifier" class="judgment">·</a> <a href=
"#jd_quantifier" class="judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
<a href="#jd_quantifier" class="judgment">·</a> ?</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
</div>
<div class="div3">
<h4><a name="sec_fn_insert_before" id=
"sec_fn_insert_before"></a>7.2.15 <span>The
<code>fn:insert-before</code> function</span></h4>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>The static type for the <code>fn:insert-before</code> function
is computed using <a href="#jd_prime" class="judgment">prime</a>
and <a href="#jd_quantifier" class="judgment">quantifier</a>, which
are defined in <a href="#sec_factor"><b>[8.4 Judgments for FLWOR
and other expressions on sequences]</b></a>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
<code>xs:integer</code></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">4</font></sub> = (<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>,<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">3</font></sub>)</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
(<code>FN-URI</code>,"<code>insert-before</code>")(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>,<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>,<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub>)
<a href="#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#jd_prime" class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">4</font></sub>)
<a href="#jd_quantifier" class="judgment">·</a> <a href=
"#jd_quantifier" class="judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">4</font></sub>)</td>
</tr>
</table>
<br /></div>
</div>
<div class="div3">
<h4><a name="sec_fn_cardinality_funcs" id=
"sec_fn_cardinality_funcs"></a>7.2.16 <span>The
<code>fn:zero-or-one</code>, <code>fn:one-or-more</code>, and
<code>fn:exactly-one</code> functions</span></h4>
<p>The functions <code>fn:zero-or-one</code>,
<code>fn:one-or-more</code>, and <code>fn:exactly-one</code> check
that the cardinality of a sequence is in the expected range. They
are useful to override the static type inferred for a given
query.</p>
<p>For example, in the following query, the user may know that all
ISBN numbers are unique and therefore that the function always
returns at most one book element. However, the static typing
feature cannot infer a precise enough type and will raise a type
error during static type analysis.</p>
<div class="exampleInner">
<pre>
  declare function book_with_isbn($isbn as xs:string) as schema-element(book)? {
    //book[@isbn=$isbn]
  }
</pre></div>
<p>In that query, the <code>fn:zero-or-one</code> function can be
used to tell the type system that the cardinality is known to be
zero or one.</p>
<div class="exampleInner">
<pre>
  declare function book_with_isbn($isbn as xs:string) as schema-element(book)? {
    fn:zero-or-one(//book[@isbn=$isbn])
  }
</pre></div>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>The static typing rules for those functions always infer a type
with the cardinality indicated by that function.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b>(<code>FN-URI</code>,"<code>zero-or-one</code>")(<a href="#doc-fs-Type"><em>Type</em></a>)
<a href="#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#jd_prime" class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a>)?</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b>(<code>FN-URI</code>,"<code>one-or-more</code>")(<a href="#doc-fs-Type"><em>Type</em></a>)
<a href="#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#jd_prime" class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a>)+</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b>(<code>FN-URI</code>,"<code>exactly-one</code>")(<a href="#doc-fs-Type"><em>Type</em></a>)
<a href="#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#jd_prime" class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a>)</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="sec_auxiliary_judgments" id=
"sec_auxiliary_judgments"></a>8 Auxiliary Judgments</h2>
<p>This section defines auxiliary judgments used in defining the
formal semantics. Many auxiliary judgments are used in both static
typing and dynamic evaluation rules. Those auxiliary judgments that
are used in only the static or dynamic semantics are labeled as
such.</p>
<div class="div2">
<h3><a name="sec_accessing_types" id="sec_accessing_types"></a>8.1
Judgments for accessing types</h3>
<p><b>Introduction</b></p>
<p>This section defines several auxiliary judgments to access
components of the [XPath/XQuery] type system. The first two
judgments (<a href="#jd_derives_from" class="judgment"><b>derives
from</b></a> and <a href="#jd_substitutes_for" class=
"judgment"><b>substitutes for</b></a>) are used to access the type
and element name hierarchies in an XML Schema. The other judgments
(<a href="#jd_lookup" class="judgment"><b>name lookup</b></a>,
<a href="#jd_static_lookup" class="judgment"><b>type
lookup</b></a>, <a href="#jd_extended_by" class=
"judgment"><b>extended by</b></a>, <a href="#jd_adjusts_to" class=
"judgment"><b>adjusts to</b></a> and <a href="#jd_expands_to"
class="judgment"><b>expands to</b></a>) are used to lookup the
meaning of element or attribute types from the schema. These
judgments are used in many expressions, notably in the
specification of type matching (See <a href=
"#sec_type_matching"><b>[8.3 Judgments for type matching]</b></a>),
validation (See <a href="#sec_validate"><b>[F.1 Judgments for the
validate expression]</b></a>), and the static semantics of step
expressions (See <a href="#sec_auxiliary_xpath"><b>[8.2 Judgments
for step expressions and filtering]</b></a>).</p>
<div class="div3">
<h4><a name="jd_aux_derives_from" id=
"jd_aux_derives_from"></a>8.1.1 Derives from</h4>
<p><b>Notation</b></p>
<p id="jd_derives_from">The judgment</p>
<div align="center"><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-TypeName"><em>TypeName</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_derives_from" class=
"judgment"><b>derives from</b></a> <a href=
"#doc-fs-TypeName"><em>TypeName</em></a><sub><font size=
"2">2</font></sub></div>
<p>holds when <a href=
"#doc-fs-TypeName"><em>TypeName</em></a><sub><font size=
"2">1</font></sub> derives from <a href=
"#doc-fs-TypeName"><em>TypeName</em></a><sub><font size=
"2">2</font></sub>. This judgment formalizes the definition of the
<code>derives-from</code> function in <a href=
"http://www.w3.org/TR/xquery#id-sequencetype-matching">Section
2.5.4 SequenceType Matching</a><sup><small>XQ</small></sup>.</p>
<p><b>Example</b></p>
<p>For example, assuming the extended XML Schema given in section
<a href="#sec_types_example"><b>[2.4.5 Example of a complete
Schema]</b></a>, then the following judgments hold.</p>
<div class="exampleInner">
<pre>
  USAddress            derives from  xs:anyType
  NYCAddress           derives from  USAddress
  NYCAddress           derives from  xs:anyType
  xsd:positiveInteger  derives from  xsd:integer
  xsd:integer          derives from  xs:anySimpleType
  fs:anon3             derives from  xsd:positiveInteger
  fs:anon3             derives from  xsd:integer
  fs:anon3             derives from  xs:anySimpleType
  fs:anon3             derives from  xs:anyType
</pre></div>
<p><b>Note</b></p>
<p>Derivation is a partial order. It is reflexive and transitive by
the definition below.</p>
<p><b>Semantics</b></p>
<p>This judgment is specified by the following rules.</p>
<p>Every type name derives from itself.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-TypeName"><em>TypeName</em></a> <a href="#jd_derives_from"
class="judgment"><b>derives from</b></a> <a href=
"#doc-fs-TypeName"><em>TypeName</em></a></td>
</tr>
</table>
<br /></div>
<p>Every type name derives from the type it is declared to derive
from by extension or restriction.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-TypeName"><em>TypeName</em></a> <a href=
"#jd_elem_qname_expands_to" class="judgment"><b>of elem/type
expands to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_type_defn" class="env">typeDefn</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>) = define type
<a href="#doc-fs-TypeName"><em>TypeName</em></a> extends <a href=
"#doc-fs-TypeName"><em>BaseTypeName</em></a> <a href=
"#doc-fs-OptMixed"><em>OptMixed</em></a> { <a href=
"#doc-fs-Type"><em>Type</em></a> }</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-TypeName"><em>TypeName</em></a> <a href="#jd_derives_from"
class="judgment"><b>derives from</b></a> <a href=
"#doc-fs-TypeName"><em>BaseTypeName</em></a></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-TypeName"><em>TypeName</em></a> <a href=
"#jd_elem_qname_expands_to" class="judgment"><b>of elem/type
expands to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_type_defn" class="env">typeDefn</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>) = define type
<a href="#doc-fs-TypeName"><em>TypeName</em></a> restricts <a href=
"#doc-fs-TypeName"><em>BaseTypeName</em></a> <a href=
"#doc-fs-OptMixed"><em>OptMixed</em></a> { <a href=
"#doc-fs-Type"><em>Type</em></a> }</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-TypeName"><em>TypeName</em></a> <a href="#jd_derives_from"
class="judgment"><b>derives from</b></a> <a href=
"#doc-fs-TypeName"><em>BaseTypeName</em></a></td>
</tr>
</table>
<br /></div>
<p>The above rules all require that the type names be defined in
the static context, but [XPath/XQuery] permits references to
"unknown" type names, i.e., type names that are not defined in the
static context. An unknown type name might be encountered, if a
module in which the given type name occurs does not import the
schema in which the given type name is defined. In this case, an
implementation is allowed (but is not required) to provide an
implementation-dependent mechanism for determining whether the
unknown type name is the same as or derived by restriction from the
expected type name. The following rule formalizes this
implementation dependent mechanism.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>"The implementation is able to determine that <a href=
"#doc-fs-TypeName"><em>TypeName</em></a><sub><font size=
"2">1</font></sub> is derived by restriction from <a href=
"#doc-fs-TypeName"><em>TypeName</em></a><sub><font size=
"2">2</font></sub>."</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-TypeName"><em>TypeName</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_derives_from" class=
"judgment"><b>derives from</b></a> <a href=
"#doc-fs-TypeName"><em>TypeName</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
<br /></div>
<p>The derivation relation is transitive.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-TypeName"><em>TypeName</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_derives_from" class=
"judgment"><b>derives from</b></a> <a href=
"#doc-fs-TypeName"><em>TypeName</em></a><sub><font size=
"2">2</font></sub>&#160;&#160;&#160;&#160;<a href=
"#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-TypeName"><em>TypeName</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_derives_from" class=
"judgment"><b>derives from</b></a> <a href=
"#doc-fs-TypeName"><em>TypeName</em></a><sub><font size=
"2">3</font></sub></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-TypeName"><em>TypeName</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_derives_from" class=
"judgment"><b>derives from</b></a> <a href=
"#doc-fs-TypeName"><em>TypeName</em></a><sub><font size=
"2">3</font></sub></td>
</tr>
</table>
<br /></div>
</div>
<div class="div3">
<h4><a name="sec_substitutes" id="sec_substitutes"></a>8.1.2
Substitutes for</h4>
<p>The substitutes judgment is used to know whether an element name
is in the substitution group of another element name.</p>
<p><b>Notation</b></p>
<p id="jd_substitutes_for">The judgment</p>
<div align="center"><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-ElementName"><em>ElementName</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_substitutes_for" class=
"judgment"><b>substitutes for</b></a> <a href=
"#doc-fs-ElementName"><em>ElementName</em></a><sub><font size=
"2">2</font></sub></div>
<p>holds when <a href=
"#doc-fs-ElementName"><em>ElementName</em></a><sub><font size=
"2">1</font></sub> substitutes for <a href=
"#doc-fs-ElementName"><em>ElementName</em></a><sub><font size=
"2">2</font></sub>.</p>
<p><b>Example</b></p>
<p>For example, assuming the extended XML Schema given in section
<a href="#sec_types_example"><b>[2.4.5 Example of a complete
Schema]</b></a>, then the following judgments hold.</p>
<div class="exampleInner">
<pre>
  usaddress  substitutes for  address
  nyaddress  substitutes for  usaddress
  nyaddress  substitutes for  address
</pre></div>
<p><b>Note</b></p>
<p>Substitution is a partial order. It is reflexive and transitive
by the definition below. It is asymmetric because no cycles are
allowed in substitution groups.</p>
<p><b>Semantics</b></p>
<p>The substitutes judgment for element names is specified by the
following rules.</p>
<p>Every element name substitutes for itself.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-ElementName"><em>ElementName</em></a> <a href=
"#jd_substitutes_for" class="judgment"><b>substitutes for</b></a>
<a href="#doc-fs-ElementName"><em>ElementName</em></a></td>
</tr>
</table>
<br /></div>
<p>Every element name substitutes for the element it is declared to
substitute for.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-ElementName"><em>ElementName</em></a> <a href=
"#jd_elem_qname_expands_to" class="judgment"><b>of elem/type
expands to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_elem_decl" class="env">elemDecl</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>) = define element
<a href="#doc-fs-ElementName"><em>ElementName</em></a> substitutes
for <a href="#doc-fs-ElementName"><em>BaseElementName</em></a>
<a href="#doc-fs-OptNillable"><em>OptNillable</em></a> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-ElementName"><em>ElementName</em></a> <a href=
"#jd_substitutes_for" class="judgment"><b>substitutes for</b></a>
<a href="#doc-fs-ElementName"><em>BaseElementName</em></a></td>
</tr>
</table>
<br /></div>
<p>Substitution is transitive.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-ElementName"><em>ElementName</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_substitutes_for" class=
"judgment"><b>substitutes for</b></a> <a href=
"#doc-fs-ElementName"><em>ElementName</em></a><sub><font size=
"2">2</font></sub>&#160;&#160;&#160;&#160;<a href=
"#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-ElementName"><em>ElementName</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_substitutes_for" class=
"judgment"><b>substitutes for</b></a> <a href=
"#doc-fs-ElementName"><em>ElementName</em></a><sub><font size=
"2">3</font></sub></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-ElementName"><em>ElementName</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_substitutes_for" class=
"judgment"><b>substitutes for</b></a> <a href=
"#doc-fs-ElementName"><em>ElementName</em></a><sub><font size=
"2">3</font></sub></td>
</tr>
</table>
<br /></div>
</div>
<div class="div3">
<h4><a name="sec_element_lookup" id="sec_element_lookup"></a>8.1.3
Element and attribute name lookup (Dynamic)</h4>
<p>The <a href="#jd_lookup" class="judgment"><b>name lookup</b></a>
judgment is used in the definition of the <a href="#jd_matches"
class="judgment"><b>matches</b></a> judgment, which takes a value
and a type and determines whether the value matches, or is an
instance of, the given type. Both <a href="#jd_lookup" class=
"judgment"><b>name lookup</b></a> and <a href="#jd_matches" class=
"judgment"><b>matches</b></a> are used in the dynamic
semantics.</p>
<p>The <a href="#jd_lookup" class="judgment"><b>name lookup</b></a>
judgment takes an element(attribute) name (derived from a node
value) and an element(attribute) type and if the element(attribute)
name matches the corresponding name in the element(attribute) type,
the judgment yields the type's corresponding type reference and for
elements, its nillable property.</p>
<p><b>Notation</b></p>
<p id="jd_lookup">The judgment</p>
<div align="center"><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-ElementName"><em>ElementName</em></a> <a href="#jd_lookup"
class="judgment"><b>name lookup</b></a> <a href=
"#doc-fs-ElementType"><em>ElementType</em></a> <a href="#jd_lookup"
class="judgment"><b>yields</b></a> <a href=
"#doc-fs-OptNillable"><em>OptNillable</em></a> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a></div>
<p>holds when the given element name matches the given element type
and requires that the element be nillable as indicated and have the
given type reference.</p>
<p><b>Example</b></p>
<p>For example, assuming the extended XML Schema given in section
<a href="#sec_types_example"><b>[2.4.5 Example of a complete
Schema]</b></a>, then the following judgments hold.</p>
<div class="exampleInner">
<pre>
  comment    name lookup element comment                          yields of type xsd:string
  size       name lookup element size nillable of type xs:integer yields nillable of type xsd:string
  apt        name lookup element apt                              yields of type fs:anon3
  nycaddress name lookup element address                          yields of type NYCAddress
</pre></div>
<p>Note that when the element name is in a substitution group, the
name lookup returns the type name corresponding to the original
element name (here the type <code>NYCAddress</code> for the element
<code>nycaddress</code>, instead of <code>Address</code> for the
element <code>address</code>).</p>
<p><b>Semantics</b></p>
<p>This judgment is specified by the following rules.</p>
<p>If the element type is a reference to a global element, then
name lookup yields the type reference in the element declaration
for the given element name. The given element name must be in the
substitution group of the global element.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-ElementName"><em>ElementName</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_substitutes_for" class=
"judgment"><b>substitutes for</b></a> <a href=
"#doc-fs-ElementName"><em>ElementName</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-ElementName"><em>ElementName</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_elem_qname_expands_to" class=
"judgment"><b>of elem/type expands to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_elem_decl" class="env">elemDecl</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size=
"2">1</font></sub>) = define element <a href=
"#doc-fs-ElementName"><em>ElementName</em></a><sub><font size=
"2">1</font></sub> <a href=
"#doc-fs-OptSubstitution"><em>OptSubstitution</em></a> <a href=
"#doc-fs-OptNillable"><em>OptNillable</em></a> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-ElementName"><em>ElementName</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_lookup" class="judgment"><b>name
lookup</b></a> element <a href=
"#doc-fs-ElementName"><em>ElementName</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_lookup" class=
"judgment"><b>yields</b></a> <a href=
"#doc-fs-OptNillable"><em>OptNillable</em></a> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a></td>
</tr>
</table>
<br /></div>
<p>If the given element name matches the element name in the
element type, and the element type contains a type reference, then
name lookup yields that type reference.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-ElementName"><em>ElementName</em></a> <a href="#jd_lookup"
class="judgment"><b>name lookup</b></a> element <a href=
"#doc-fs-ElementName"><em>ElementName</em></a> <a href=
"#doc-fs-OptNillable"><em>OptNillable</em></a> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a> <a href=
"#jd_lookup" class="judgment"><b>yields</b></a> <a href=
"#doc-fs-OptNillable"><em>OptNillable</em></a> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a></td>
</tr>
</table>
<br /></div>
<p>If the element type has no element name but contains a type
reference, then name lookup yields the type reference.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-ElementName"><em>ElementName</em></a> <a href="#jd_lookup"
class="judgment"><b>name lookup</b></a> element <span>*</span>
<a href="#doc-fs-TypeReference"><em>TypeReference</em></a> <a href=
"#jd_lookup" class="judgment"><b>yields</b></a> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a></td>
</tr>
</table>
<br /></div>
<p>If the element type has no element name and no type reference,
then name lookup yields <code>xs:anyType</code>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-ElementName"><em>ElementName</em></a> <a href="#jd_lookup"
class="judgment"><b>name lookup</b></a> element <span>*</span>
<a href="#jd_lookup" class="judgment"><b>yields</b></a> of type
<code>xs:anyType</code></td>
</tr>
</table>
<br /></div>
<p><b>Notation</b></p>
<p id="jd_attribute_lookup">The judgment</p>
<div align="center"><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-AttributeName"><em>AttributeName</em></a> <a href=
"#jd_attribute_lookup" class="judgment"><b>name lookup</b></a>
<a href="#doc-fs-AttributeType"><em>AttributeType</em></a> <a href=
"#jd_attribute_lookup" class="judgment"><b>yields</b></a> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a></div>
<p>holds when matching an attribute with the given attribute name
against the given attribute type matches the type reference.</p>
<p><b>Example</b></p>
<p>For example, assuming the extended XML Schema given in section
<a href="#sec_types_example"><b>[2.4.5 Example of a complete
Schema]</b></a>, then the following judgments hold.</p>
<div class="exampleInner">
<pre>
  orderDate  name lookup  attribute orderDate of type xsd:date  yields  of type xsd:date?
  orderDate  name lookup  attribute of type xsd:date            yields  of type xsd:date?
</pre></div>
<p><b>Semantics</b></p>
<p>This judgment is specified by the following rules.</p>
<p>If the attribute type is a reference to a global attribute, then
name lookup yields the type reference in the attribute declaration
for the given attribute name.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-AttributeName"><em>AttributeName</em></a> <a href=
"#jd_attr_qname_expands_to" class="judgment"><b>of attr expands
to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_attr_decl" class="env">attrDecl</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>) = define
attribute <a href=
"#doc-fs-AttributeName"><em>AttributeName</em></a> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-AttributeName"><em>AttributeName</em></a> <a href=
"#jd_attribute_lookup" class="judgment"><b>name lookup</b></a>
attribute <a href=
"#doc-fs-AttributeName"><em>AttributeName</em></a> <a href=
"#jd_attribute_lookup" class="judgment"><b>yields</b></a> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a></td>
</tr>
</table>
<br /></div>
<p>If the given attribute name matches the attribute name in the
attribute type, and the attribute type contains a type reference,
then name lookup yields that type reference.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-AttributeName"><em>AttributeName</em></a> <a href=
"#jd_attribute_lookup" class="judgment"><b>name lookup</b></a>
attribute <a href=
"#doc-fs-AttributeName"><em>AttributeName</em></a> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a> <a href=
"#jd_attribute_lookup" class="judgment"><b>yields</b></a> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a></td>
</tr>
</table>
<br /></div>
<p>If the attribute type has no attribute name but contains a type
reference, then name lookup yields the type reference.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-AttributeName"><em>AttributeName</em></a> <a href=
"#jd_attribute_lookup" class="judgment"><b>name lookup</b></a>
attribute <span>*</span> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a> <a href=
"#jd_attribute_lookup" class="judgment"><b>yields</b></a> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a></td>
</tr>
</table>
<br /></div>
<p>If the attribute type has no attribute name and no type
reference, then name lookup yields
<code>xs:anySimpleType</code>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-AttributeName"><em>AttributeName</em></a> <a href=
"#jd_attribute_lookup" class="judgment"><b>name lookup</b></a>
attribute <span>*</span> <a href="#jd_attribute_lookup" class=
"judgment"><b>yields</b></a> of type
<code>xs:anySimpleType</code></td>
</tr>
</table>
<br /></div>
</div>
<div class="div3">
<h4><a name="jd_aux_static_lookup" id=
"jd_aux_static_lookup"></a>8.1.4 Element and attribute type lookup
(Static)</h4>
<p>The type lookup judgments are used to obtain the appropriate
type reference for an attribute or element.</p>
<p><b>Notation</b></p>
<p id="jd_static_lookup">The judgment</p>
<div align="center"><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-ElementType"><em>ElementType</em></a> <a href=
"#jd_static_lookup" class="judgment"><b>type lookup</b></a>
<a href="#doc-fs-OptNillable"><em>OptNillable</em></a> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a></div>
<p>holds when the element type is optionally nillable and has the
given type reference.</p>
<p><b>Semantics</b></p>
<p>The element type lookup judgments are specified by the following
rules.</p>
<p>A reference to a global element yields the type reference in the
global element declaration with the given element name.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-ElementName"><em>ElementName</em></a> <a href=
"#jd_elem_qname_expands_to" class="judgment"><b>of elem/type
expands to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_elem_decl" class="env">elemDecl</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>) = define element
<a href="#doc-fs-ElementName"><em>ElementName</em></a> <a href=
"#doc-fs-OptSubstitution"><em>OptSubstitution</em></a> <a href=
"#doc-fs-OptNillable"><em>OptNillable</em></a> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>element <a href=
"#doc-fs-ElementName"><em>ElementName</em></a> <a href=
"#jd_static_lookup" class="judgment"><b>type lookup</b></a>
<a href="#doc-fs-OptNillable"><em>OptNillable</em></a> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a></td>
</tr>
</table>
<br /></div>
<p>In the case of a local element type, type lookup yields the
corresponding type reference.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>element <a href=
"#doc-fs-ElementName"><em>ElementName</em></a> <a href=
"#doc-fs-OptNillable"><em>OptNillable</em></a> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a> <a href=
"#jd_static_lookup" class="judgment"><b>type lookup</b></a>
<a href="#doc-fs-OptNillable"><em>OptNillable</em></a> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a></td>
</tr>
</table>
<br /></div>
<p>If the element type has no element name but contains a type
reference, then type lookup yields that type reference.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>element <span>*</span>
<a href="#doc-fs-OptNillable"><em>OptNillable</em></a> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a> <a href=
"#jd_static_lookup" class="judgment"><b>type lookup</b></a>
<a href="#doc-fs-TypeReference"><em>TypeReference</em></a></td>
</tr>
</table>
<br /></div>
<p>If the element type has no element name and no type reference,
then lookup yields <code>xs:anyType</code>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>element <span>*</span>
<a href="#jd_static_lookup" class="judgment"><b>type lookup</b></a>
of type <code>xs:anyType</code></td>
</tr>
</table>
<br /></div>
<p><b>Notation</b></p>
<p id="jd_attribute_static_lookup">The judgment</p>
<div align="center"><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-AttributeType"><em>AttributeType</em></a> <a href=
"#jd_attribute_static_lookup" class="judgment"><b>type
lookup</b></a> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a></div>
<p>holds when the attribute type has the given type reference.</p>
<p><b>Semantics</b></p>
<p>This judgment is specified by the following rules.</p>
<p>A reference to a global attribute yields the type reference in
the global attribute declaration with the given attribute name.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-AttributeName"><em>AttributeName</em></a> <a href=
"#jd_attr_qname_expands_to" class="judgment"><b>of attr expands
to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_attr_decl" class="env">attrDecl</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>) = define
attribute <a href=
"#doc-fs-AttributeName"><em>AttributeName</em></a> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>attribute <a href=
"#doc-fs-AttributeName"><em>AttributeName</em></a> <a href=
"#jd_attribute_static_lookup" class="judgment"><b>type
lookup</b></a> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a></td>
</tr>
</table>
<br /></div>
<p>If the attribute name is not defined, i.e., it is not declared
in the in-scope schema definitions, then the attribute's default
type is <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-AttributeName"><em>AttributeName</em></a> <a href=
"#jd_attr_qname_expands_to" class="judgment"><b>of attr expands
to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_attr_decl" class="env">attrDecl</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>) undefined</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>attribute <a href=
"#doc-fs-AttributeName"><em>AttributeName</em></a> <a href=
"#jd_attribute_static_lookup" class="judgment"><b>type
lookup</b></a> of type <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a></td>
</tr>
</table>
<br /></div>
<p>In the case of a local attribute type, type lookup yields the
corresponding type reference.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>attribute <a href=
"#doc-fs-AttributeName"><em>AttributeName</em></a> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a> <a href=
"#jd_attribute_static_lookup" class="judgment"><b>type
lookup</b></a> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a></td>
</tr>
</table>
<br /></div>
<p>If the attribute type has no attribute name but contains a type
reference, then type lookup yields the type reference.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>attribute <span>*</span>
<a href="#doc-fs-TypeReference"><em>TypeReference</em></a> <a href=
"#jd_attribute_static_lookup" class="judgment"><b>type
lookup</b></a> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a></td>
</tr>
</table>
<br /></div>
<p>If the attribute type has no attribute name and no type
reference, then type lookup yields
<code>xs:anySimpleType</code>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>attribute <span>*</span>
<a href="#jd_attribute_static_lookup" class="judgment"><b>type
lookup</b></a> of type <code>xs:anySimpleType</code></td>
</tr>
</table>
<br /></div>
</div>
<div class="div3">
<h4><a name="sec_extension" id="sec_extension"></a>8.1.5
Extension</h4>
<p><b>Notation</b></p>
<p id="jd_extended_by">The judgment</p>
<div align="center"><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_extended_by" class="judgment"><b>extended by</b></a>
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_extended_by" class=
"judgment"><b>is</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></div>
<p>holds when the result of extending <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
by <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub> is <a href="#doc-fs-Type"><em>Type</em></a>.
This judgment is used in the definition of type expansion <a href=
"#sec_type_expansion"><b>[8.1.9 Type expansion]</b></a>, which
expands a type to include the union of all types derived from the
given type,</p>
<p><b>Semantics</b></p>
<p>This judgment is specified by the following rules.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
= <a href=
"#doc-fs-AttributeModel"><em>AttributeModel</em></a><sub><font size="2">1</font></sub>
, <a href=
"#doc-fs-ElementModel"><em>ElementModel</em></a><sub><font size=
"2">1</font></sub>&#160;&#160;&#160;&#160;<a href=
"#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
= <a href=
"#doc-fs-AttributeModel"><em>AttributeModel</em></a><sub><font size="2">2</font></sub>
, <a href=
"#doc-fs-ElementModel"><em>ElementModel</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_extended_by" class="judgment"><b>extended by</b></a>
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_extended_by" class=
"judgment"><b>is</b></a> (<a href=
"#doc-fs-AttributeModel"><em>AttributeModel</em></a><sub><font size="2">1</font></sub>
&amp; <a href=
"#doc-fs-AttributeModel"><em>AttributeModel</em></a><sub><font size="2">2</font></sub>)
, <a href=
"#doc-fs-ElementModel"><em>ElementModel</em></a><sub><font size=
"2">1</font></sub> , <a href=
"#doc-fs-ElementModel"><em>ElementModel</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
<br /></div>
</div>
<div class="div3">
<h4><a name="sec_mixed" id="sec_mixed"></a>8.1.6 Mixed content</h4>
<p><b>Notation</b></p>
<p id="jd_mixes_to">The judgment</p>
<div align="center"><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_mixes_to" class="judgment"><b>mixes to</b></a>
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></div>
<p>holds when the result of creating a mixed content from <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
is <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>.</p>
<p><b>Semantics</b></p>
<p>This judgment is specified by the following rule, which
interleaves the element content with a sequence of text nodes and
adds a union of <a href=
"#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a> values.
The <a href=
"#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a> sequence
is required because it is possible to derive an element containing
only atomic values from an element that is mixed.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a> = <a href=
"#doc-fs-AttributeModel"><em>AttributeModel</em></a> , <a href=
"#doc-fs-ElementModel"><em>ElementModel</em></a></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a> <a href="#jd_mixes_to" class=
"judgment"><b>mixes to</b></a> <a href=
"#doc-fs-AttributeModel"><em>AttributeModel</em></a> , ( <a href=
"#doc-fs-ElementModel"><em>ElementModel</em></a> &amp; text* |
<a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>
*)</td>
</tr>
</table>
<br /></div>
</div>
<div class="div3">
<h4><a name="sec_adjustment" id="sec_adjustment"></a>8.1.7 Type
adjustment</h4>
<p>In the [XPath/XQuery] type system, a complex-type declaration
does not include the implicit attributes and nodes that may be
included in the type. Type adjustment takes a complex type and
adjusts it to include implicit attributes and nodes. In particular,
type adjustment:</p>
<ul>
<li>
<p>adds the four (optional) built-in attributes xsi:type, xsi:nil,
xsi:schemaLocation, or xsi:noNamespaceSchemaLocation,</p>
</li>
<li>
<p>interleaves the type with a sequence of comments and
processing-instructions, and</p>
</li>
<li>
<p>if the complex type is mixed, interleaves the type with a
sequence of text nodes and <a href=
"#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>.</p>
</li>
</ul>
<p><b>Notation</b></p>
<p id="jd_adjusts_to">The judgment</p>
<div align="center"><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-OptMixed"><em>OptMixed</em></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_adjusts_to" class="judgment"><b>adjusts to</b></a>
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></div>
<p>holds when the second type is the same as the first after the
first has been adjusted as described above.</p>
<p><b>Semantics</b></p>
<p>This judgment is specified by the following rules.</p>
<p>If the type is flagged as mixed, then mix the type and extend it
by the built-in attributes.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_mixes_to" class="judgment"><b>mixes to</b></a>
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_extended_by" class="judgment"><b>extended by</b></a>
<a href=
"#sec_built_in_attributes"><code>BuiltInAttributes</code></a>
<a href="#jd_extended_by" class="judgment"><b>is</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">3</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">4</font></sub>
= <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">3</font></sub> &amp;
<code>processing-instruction<span>*</span>*</code> &amp;
<code>comment*</code></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>mixed <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_adjusts_to" class="judgment"><b>adjusts to</b></a>
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">4</font></sub></td>
</tr>
</table>
<br /></div>
<p>Otherwise, just extend the type by the built-in attributes.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_extended_by" class="judgment"><b>extended by</b></a>
<a href=
"#sec_built_in_attributes"><code>BuiltInAttributes</code></a>
<a href="#jd_extended_by" class="judgment"><b>is</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub>
= <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub> &amp;
<code>processing-instruction<span>*</span>*</code> &amp;
<code>comment*</code></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_adjusts_to" class="judgment"><b>adjusts to</b></a>
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">3</font></sub></td>
</tr>
</table>
<br /></div>
</div>
<div class="div3">
<h4><a name="sec_built_in_attributes" id=
"sec_built_in_attributes"></a>8.1.8 Builtin attributes</h4>
<p>Schema defines four built-in attributes that can appear on any
element in the document without being explicitly declared in the
schema. Those four attributes need to be added inside content
models when doing matching. The four built-in attributes of Schema
are declared as follows.</p>
<div class="exampleInner">
<pre>
  define attribute xsi:type of type xs:QName<span>;</span>
  define attribute xsi:nil of type xs:boolean<span>;</span>
  define attribute xsi:schemaLocation of type fs:anon<span>;</span>
  define type fs:anon1 { xs:anyURI* }<span>;</span>
  define attribute xsi:noNamespaceSchemaLocation of type xs:anyURI<span>;</span>
</pre></div>
<p>For convenience, a type that is an all group of the four
built-in XML Schema attributes is defined.</p>
<div class="exampleInner">
<pre>
  BuiltInAttributes =
      attribute xsi:type ?
    &amp; attribute xsi:nil ?
    &amp; attribute xsi:schemaLocation ?
    &amp; attribute xsi:noNamespaceSchemaLocation ?
</pre></div>
</div>
<div class="div3">
<h4><a name="sec_type_expansion" id="sec_type_expansion"></a>8.1.9
Type expansion</h4>
<p>The <a href="#jd_expands_to" class="judgment"><b>expands
to</b></a> judgment is one of the most important static judgments.
It is used in the static semantics of the child axis <a href=
"#sec_static_axis_judge"><b>[8.2.2.1 Static semantics of
axes]</b></a>, which is used in the definition of many other rules
that extract element types from an arbitrary content type.</p>
<p>The judgment takes a type name and computes the union of all
types derived from the given type. If the type is nillable, it also
makes sure the content model allows the empty sequence. If the type
is mixed, it also adjusts the type to include the mixed content
model. The judgment depends on the <a href=
"#jd_union_interpretation" class="judgment"><b>extended with union
interpretation of</b></a> judgment to recursively compute all
derived types.</p>
<p><b>Notation</b></p>
<p id="jd_expands_to">The judgment</p>
<div align="center"><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a> <a href=
"#jd_expands_to" class="judgment"><b>expands to</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></div>
<p>holds when expanding the type specifier results in the given
type.</p>
<p><b>Semantics</b></p>
<p>This judgment is specified by the following rules.</p>
<p>If the type is nillable, then it expands into an optional
type.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a> <a href=
"#jd_expands_to" class="judgment"><b>expands to</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>nillable <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a> <a href=
"#jd_expands_to" class="judgment"><b>expands to</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a>?</td>
</tr>
</table>
<br /></div>
<p>The type definition for the type reference is contained in its
expansion.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-TypeName"><em>TypeName</em></a> <a href=
"#jd_elem_qname_expands_to" class="judgment"><b>of elem/type
expands to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_type_defn" class="env">typeDefn</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>) = define type
<a href="#doc-fs-TypeName"><em>TypeName</em></a> extends <a href=
"#doc-fs-TypeName"><em>BaseTypeName</em></a> <a href=
"#doc-fs-OptMixed"><em>OptMixed</em></a> { <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
}</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_union_interpretation" class="judgment"><b>is</b></a>
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_union_interpretation" class=
"judgment"><b>extended with union interpretation of</b></a>
<a href="#doc-fs-TypeName"><em>TypeName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-OptMixed"><em>OptMixed</em></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_adjusts_to" class="judgment"><b>adjusts to</b></a>
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">3</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>of type <a href=
"#doc-fs-TypeName"><em>TypeName</em></a> <a href="#jd_expands_to"
class="judgment"><b>expands to</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">3</font></sub></td>
</tr>
</table>
<br /></div>
<p>In case the type is <a href=
"#dt-xs_untyped"><code>xs:untyped</code></a>, the type does not
need to be adjusted as is required for other XML Schema types. See
the corresponding definition in <a href=
"#id-predefined-types"><b>[3.5.1 Predefined Schema
Types]</b></a>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#dt-xs_untyped"><code>xs:untyped</code></a> <a href=
"#jd_elem_qname_expands_to" class="judgment"><b>of elem/type
expands to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_type_defn" class="env">typeDefn</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>) = define type
<a href="#dt-xs_untyped"><code>xs:untyped</code></a> extends
<code>xs:anyType</code> { <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
}</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>of type <a href=
"#dt-xs_untyped"><code>xs:untyped</code></a> <a href=
"#jd_expands_to" class="judgment"><b>expands to</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
<br /></div>
</div>
<div class="div3">
<h4><a name="sec_union_interpretation" id=
"sec_union_interpretation"></a>8.1.10 Union interpretation of
derived types</h4>
<p><b>Notation</b></p>
<p id="jd_union_interpretation">The judgment</p>
<div align="center"><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_union_interpretation" class="judgment"><b>is</b></a>
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_union_interpretation" class=
"judgment"><b>extended with union interpretation of</b></a>
<a href="#doc-fs-TypeName"><em>TypeName</em></a></div>
<p>holds when the type <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
is the expansion of the type name <a href=
"#doc-fs-TypeName"><em>TypeName</em></a> with definition <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
to include all types derived by extension and restriction from the
given type name. This rule is recursive, because each type name
itself may have other type names that are derived from it. The
recursive rules traverse the entire derivation tree, identifying
every type name derived from the original type name.</p>
<p><b>Semantics</b></p>
<p>This judgment is specified by the following rules.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><em>No type derives from <a href=
"#doc-fs-TypeName"><em>TypeName</em></a><sub><font size=
"2">0</font></sub></em></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>
<a href="#jd_union_interpretation" class="judgment"><b>is</b></a>
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub> <a href="#jd_union_interpretation" class=
"judgment"><b>extended with union interpretation of</b></a>
<a href="#doc-fs-TypeName"><em>TypeName</em></a><sub><font size=
"2">0</font></sub></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_type_defn" class="env">typeDefn</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size=
"2">R,1</font></sub>) = define type <a href=
"#doc-fs-TypeName"><em>TypeName</em></a><sub><font size=
"2">R,1</font></sub> restricts <a href=
"#doc-fs-TypeName"><em>TypeName</em></a><sub><font size=
"2">0</font></sub> <a href=
"#doc-fs-OptMixed"><em>OptMixed</em></a><sub><font size=
"2">R,1</font></sub> { <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">R,1</font></sub> }</td>
</tr>
<tr align="center" valign="middle">
<td>· · ·</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_type_defn" class="env">typeDefn</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size=
"2">R,n</font></sub>) = define type <a href=
"#doc-fs-TypeName"><em>TypeName</em></a><sub><font size=
"2">R,n</font></sub> restricts <a href=
"#doc-fs-TypeName"><em>TypeName</em></a><sub><font size=
"2">0</font></sub> <a href=
"#doc-fs-OptMixed"><em>OptMixed</em></a><sub><font size=
"2">R,n</font></sub> { <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">R,n</font></sub> }</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">R,1</font></sub>' <a href="#jd_union_interpretation" class=
"judgment"><b>is</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">R,1</font></sub> <a href="#jd_union_interpretation" class=
"judgment"><b>extended with union interpretation of</b></a>
<a href="#doc-fs-TypeName"><em>TypeName</em></a><sub><font size=
"2">R,1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td>· · ·</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">R,n</font></sub>' <a href="#jd_union_interpretation" class=
"judgment"><b>is</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">R,n</font></sub> <a href="#jd_union_interpretation" class=
"judgment"><b>extended with union interpretation of</b></a>
<a href="#doc-fs-TypeName"><em>TypeName</em></a><sub><font size=
"2">R,n</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_type_defn" class="env">typeDefn</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size=
"2">E,1</font></sub>) = define type <a href=
"#doc-fs-TypeName"><em>TypeName</em></a><sub><font size=
"2">E,1</font></sub> extends <a href=
"#doc-fs-TypeName"><em>TypeName</em></a><sub><font size=
"2">0</font></sub> <a href=
"#doc-fs-OptMixed"><em>OptMixed</em></a><sub><font size=
"2">E,1</font></sub> { <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">E,1</font></sub> }</td>
</tr>
<tr align="center" valign="middle">
<td>· · ·</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_type_defn" class="env">typeDefn</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size=
"2">E,m</font></sub>) = define type <a href=
"#doc-fs-TypeName"><em>TypeName</em></a><sub><font size=
"2">E,m</font></sub> extends <a href=
"#doc-fs-TypeName"><em>TypeName</em></a><sub><font size=
"2">0</font></sub> <a href=
"#doc-fs-OptMixed"><em>OptMixed</em></a><sub><font size=
"2">E,m</font></sub> { <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">E,m</font></sub> }</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">E,1</font></sub>' <a href="#jd_union_interpretation" class=
"judgment"><b>is</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">E,1</font></sub> <a href="#jd_union_interpretation" class=
"judgment"><b>extended with union interpretation of</b></a>
<a href="#doc-fs-TypeName"><em>TypeName</em></a><sub><font size=
"2">E,1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td>· · ·</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">E,m</font></sub>' <a href="#jd_union_interpretation" class=
"judgment"><b>is</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">E,m</font></sub> <a href="#jd_union_interpretation" class=
"judgment"><b>extended with union interpretation of</b></a>
<a href="#doc-fs-TypeName"><em>TypeName</em></a><sub><font size=
"2">E,m</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub> = <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">R,1</font></sub>' | · · · | <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">R,n</font></sub>' | <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>
| (<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub>, <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">E,1</font></sub>' ) | · · · | (<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub>,<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">E,m</font></sub>')</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_union_interpretation" class="judgment"><b>is</b></a>
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">0</font></sub> <a href="#jd_union_interpretation" class=
"judgment"><b>extended with union interpretation of</b></a>
<a href="#doc-fs-TypeName"><em>TypeName</em></a><sub><font size=
"2">0</font></sub></td>
</tr>
</table>
<br /></div>
<p><b>Examples</b></p>
<p>Note that this expansion does not enforce the <b>unique
particule attribution</b> property specified by XML Schema in the
resulting content models. Implementations may want to implement an
equivalent alternative expansion that enforces that property. For
example, expanding type <code>T1</code> below yields the following
type that is not one-deterministic:</p>
<div class="exampleInner">
<pre>
define type T1 { element a }
define type T2 extends T1 { element b }

(element a | element a, element b) is (element a) extended with union interpretation of T1
</pre></div>
<p>An implementation might want to infer the equivalent content
model that verifies the <b>unique particule attribution</b>
property of XML Schema:</p>
<div class="exampleInner">
<pre>
(element a, (() | element b)) is (element a) extended with union interpretation of T1
</pre></div>
</div>
</div>
<div class="div2">
<h3><a name="sec_auxiliary_xpath" id="sec_auxiliary_xpath"></a>8.2
Judgments for step expressions and filtering</h3>
<p><b>Introduction</b></p>
<p>Step expressions are one of the elementary operations in
[XPath/XQuery]. Steps select nodes reachable from the root of an
XML tree. Defining the semantics of step expressions requires a
detailed analysis of all the possible cases of axis and node
tests.</p>
<p>This section introduces auxiliary judgments used to define the
semantics of step expressions. The <a href="#jd_principal" class=
"judgment"><b>has principal</b></a> judgment (<a href=
"#sec_jd_principal"><b>[8.2.1 Principal Node Kind]</b></a>)
captures the notion of <em>principal node kind</em> in XPath. The
Axis judgments (<a href="#sec_axis_judge"><b>[8.2.2 Auxiliary
judgments for axes]</b></a>) define the static and dynamic
semantics of all axes, and the Node Test judgments (<a href=
"#sec_test_judge"><b>[8.2.3 Auxiliary judgments for node
tests]</b></a>) define the static and dynamic semantics of all node
tests. The <a href="#jd_filter" class="judgment"><b>filter</b></a>
judgment accesses the value of an attribute and is used in the
definition of validation (<a href="#sec_validation_judgments"><b>[F
Auxiliary Judgments for Validation]</b></a>).</p>
<div class="div3">
<h4><a name="sec_jd_principal" id="sec_jd_principal"></a>8.2.1
Principal Node Kind</h4>
<p><b>Notation</b></p>
<p>The following auxiliary grammar production describes principal
node kinds (See <a href="#xpath-21">[XML Path Language (XPath)
2.1]</a>).</p>
<h5><a name="d6e52543" id="d6e52543"></a>PrincipalNodeKind</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-PrincipalNodeKind" id=
"doc-fs-PrincipalNodeKind"></a>[<small>64&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-PrincipalNodeKind">PrincipalNodeKind</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"element" | "attribute" | "namespace"</code></td>
</tr>
</tbody>
</table>
<p><b>Notation</b></p>
<p id="jd_principal">The judgment</p>
<div align="center"><em>Axis</em> <a href="#jd_principal" class=
"judgment"><b>has principal</b></a>
<em>PrincipalNodeKind</em></div>
<p>holds when <em>PrincipalNodeKind</em> is the principal node kind
for <em>Axis</em>.</p>
<p><b>Example</b></p>
<p>For example, the following judgments hold.</p>
<div class="exampleInner">
<pre>
  child::       principal  element
  descendant::  principal  element
  preceding::   principal  element
  attribute::   principal  attribute
  namespace::   principal  namespace
</pre></div>
<p><b>Semantics</b></p>
<p>This judgment is specified by the following rules.</p>
<p>The principal node type for the attribute axis is attribute.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><code>attribute::</code> <a href="#jd_principal" class=
"judgment"><b>has principal</b></a> attribute</td>
</tr>
</table>
<br /></div>
<p>The principal node type for the namespace axis is namespace.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><code>namespace::</code> <a href="#jd_principal" class=
"judgment"><b>has principal</b></a> namespace</td>
</tr>
</table>
<br /></div>
<p>The principal node type for all other axis is element.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><em>Axis</em> !=
<code>attribute::</code>&#160;&#160;&#160;&#160;<em>Axis</em> !=
<code>namespace::</code></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><em>Axis</em> <a href="#jd_principal" class="judgment"><b>has
principal</b></a> element</td>
</tr>
</table>
<br /></div>
</div>
<div class="div3">
<h4><a name="sec_axis_judge" id="sec_axis_judge"></a>8.2.2
Auxiliary judgments for axes</h4>
<div class="div4">
<h5><a name="sec_static_axis_judge" id=
"sec_static_axis_judge"></a>8.2.2.1 Static semantics of axes</h5>
<p><b>Notation</b></p>
<p id="jd_axis_type">The following judgment</p>
<div align="center"><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <em>Axis</em> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_axis_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></div>
<p>holds when applying the axis <em>Axis</em> on type <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
yields the type <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>.</p>
<p id="jd_has_element_content">The following two judgments are used
in the definition of <a href="#jd_axis_type" class=
"judgment"><b>axis</b></a>. The judgment</p>
<div align="center"><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_has_element_content" class="judgment"><b>has node
content</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></div>
<p>only applies to a type that is a valid element content type and
holds when <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub> has the content type <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>.
The judgment separates the attribute types from the other node or
atomic-valued types of the element content type and yields the
non-attribute types.</p>
<p id="jd_has_attribute_content">The judgment</p>
<div align="center"><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_has_attribute_content" class="judgment"><b>has
attribute content</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></div>
<p>only applies to a type that is a valid element content type and
holds when <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub> has attribute types <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>.
The judgment yields the attribute types of the element content
type.</p>
<p><b>Example</b></p>
<p>For example, the following judgments hold.</p>
<div class="exampleInner">
<pre>
  axis child::      of  element of type xs:string   :  text
  axis child::      of  element items of type Items :  element item of type fs:anon1*

  axis child::      of  element purchaseOrder       : 
    element shipTo of type USAddress,
    element billTo of type USAddress,
    element ipo:comment?,
    element items of type Items

  axis attribute::  of  element of type xs:string   :  empty

    attribute partNum of type SKU,
    element item of type fs:anon1*
  has-node-content
    element item of type fs:anon1*

    attribute partNum of type SKU,
    element item of type fs:anon1*
  has-attribute-content
    attribute partNum of type SKU

    (attribute partNum of type SKU,
     element item of type fs:anon1*) |
    (attribute orderDate of type xs:date?,
     element shipTo of type USAddress,
     element billTo of type USAddress,
     element comment?,
     element items of type Items)
  has-node-content
    (element item of type fs:anon1*) |
    (element shipTo of type USAddress,
     element billTo of type USAddress,
     element comment?,
     element items of type Items)

    (attribute partNum of type SKU,
     element item of type fs:anon1*) |
    (attribute orderDate of type xs:date?,
     element shipTo of type USAddress,
     element billTo of type USAddress,
     element comment?,
     element items of type Items)
  has-attribute-content
    (attribute partNum of type SKU) |
    (attribute orderDate of type xs:date?)
</pre></div>
<div class="div5">
<h6><a name="sec_inference_axis" id=
"sec_inference_axis"></a>8.2.2.1.1 Inference rules for all
axes</h6>
<p><b>Semantics</b></p>
<p>The following rules compute the type of the axis expression when
applied to each item type in the content model.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <em>Axis</em> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_axis_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <em>Axis</em> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<em>OccurrenceIndicator</em> <a href="#jd_axis_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<em>OccurrenceIndicator</em></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <em>Axis</em> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_axis_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">3</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <em>Axis</em> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_axis_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">4</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <em>Axis</em> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>&amp;<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_axis_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">3</font></sub>&amp;<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">4</font></sub></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <em>Axis</em> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_axis_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">3</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <em>Axis</em> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_axis_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">4</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <em>Axis</em> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>,<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_axis_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">3</font></sub>,<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">4</font></sub></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <em>Axis</em> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_axis_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">3</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <em>Axis</em> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_axis_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">4</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <em>Axis</em> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>|<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_axis_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">3</font></sub>|<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">4</font></sub></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>&#160;&#160;</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <em>Axis</em> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a> none <a href=
"#jd_axis_type" class="judgment"><b>:</b></a> none</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>&#160;&#160;</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <em>Axis</em> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a> <code>empty</code>
<a href="#jd_axis_type" class="judgment"><b>:</b></a>
<code>empty</code></td>
</tr>
</table>
<br /></div>
<p>The rules in the following subsections specify how to compute
the type of each axis applied to an item type.</p>
</div>
<div class="div5">
<h6><a name="sec_inference_self" id=
"sec_inference_self"></a>8.2.2.1.2 Inference rules for the
<code>self</code> axis</h6>
<p><b>Semantics</b></p>
<p>Applying the self axis to a node type results in the same node
type.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <code>self::</code> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a> <a href=
"#doc-fs-NodeType"><em>NodeType</em></a> <a href="#jd_axis_type"
class="judgment"><b>:</b></a> <a href=
"#doc-fs-NodeType"><em>NodeType</em></a></td>
</tr>
</table>
<br /></div>
</div>
<div class="div5">
<h6><a name="sec_inference_child" id=
"sec_inference_child"></a>8.2.2.1.3 Inference rules for the
<code>child</code> axis</h6>
<p><b>Semantics</b></p>
<p>In the case of an element type, the static type of the child
axis is obtained by type lookup and expansion of the resulting
type. Note that the <a href="#jd_expands_to" class=
"judgment"><b>expands to</b></a> judgment yields the type that
corresponds to a given type name. Because the meaning of a type
name includes the definitions of <em>all</em> type names derived by
extension and restriction from the given type name, <a href=
"#jd_expands_to" class="judgment"><b>expands to</b></a> yields the
<em>union</em> of all the type definitions of all type names
derived from the input type name. Each type in the union contains
the complete definition of the type name, i.e., it includes
built-in attributes and, if necessary, processing-instruction,
comment, and text types.</p>
<p>After type expansion, the judgment <a href=
"#jd_has_element_content" class="judgment"><b>has node
content</b></a> is applied to each type in the union. The resulting
type is the union of all non-attribute types in the expanded
type.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-ElementType"><em>ElementType</em></a> <a href=
"#jd_static_lookup" class="judgment"><b>type lookup</b></a>
<a href="#doc-fs-OptNillable"><em>OptNillable</em></a> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-OptNillable"><em>OptNillable</em></a> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a> <a href=
"#jd_expands_to" class="judgment"><b>expands to</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
| · · · | <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">n</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_has_element_content" class="judgment"><b>has node
content</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>'</td>
</tr>
<tr align="center" valign="middle">
<td>· · ·</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>
<a href="#jd_has_element_content" class="judgment"><b>has node
content</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">n</font></sub>'</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <code>child::</code> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a> <a href=
"#doc-fs-ElementType"><em>ElementType</em></a> <a href=
"#jd_axis_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>'
| ... | <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">n</font></sub>'</td>
</tr>
</table>
<br /></div>
<p>If the type is a sequence of attributes, then the content type
is <code>empty</code>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a> <a href="#jd_subtype_of" class=
"judgment"><b>&lt;:</b></a> attribute<span>*</span>*</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-Type"><em>Type</em></a> <a href="#jd_has_element_content"
class="judgment"><b>has node content</b></a>
<code>empty</code></td>
</tr>
</table>
<br /></div>
<p>If the type is attributes followed by a simple type, the content
type is zero-or-one text nodes. The resulting type is optional
since an expression returning the empty sequence results in no text
node being constructed.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a> = <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
attribute<span>*</span>*</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>*</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-Type"><em>Type</em></a> <a href="#jd_has_element_content"
class="judgment"><b>has node content</b></a> text?</td>
</tr>
</table>
<br /></div>
<p>In the case of an element type with complex content type, the
content type is simply the non-attribute part of the complex
content type.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a> = <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
attribute<span>*</span>*</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-ElementModel"><em>ElementModel</em></a>*</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-Type"><em>Type</em></a> <a href="#jd_has_element_content"
class="judgment"><b>has node content</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
<br /></div>
<p>In the case of an attribute type, the static type of the child
axis is empty.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <code>child::</code> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a> <a href=
"#doc-fs-AttributeType"><em>AttributeType</em></a> <a href=
"#jd_axis_type" class="judgment"><b>:</b></a>
<code>empty</code></td>
</tr>
</table>
<br /></div>
<p>In the case of a text node type, the static type of the child
axis is empty.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <code>child::</code> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a> text <a href=
"#jd_axis_type" class="judgment"><b>:</b></a>
<code>empty</code></td>
</tr>
</table>
<br /></div>
<p>In the case of a comment node type, the static type of the child
axis is empty.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <code>child::</code> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a> comment <a href=
"#jd_axis_type" class="judgment"><b>:</b></a>
<code>empty</code></td>
</tr>
</table>
<br /></div>
<p>In the case of a processing-instruction node type, the static
type of the child axis is empty.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <code>child::</code> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a>
processing-instruction<span>*</span> <a href="#jd_axis_type" class=
"judgment"><b>:</b></a> <code>empty</code></td>
</tr>
</table>
<br /></div>
<p>In case of a document node type, the static type of the child
axis is the type of the document node content, interleaved with a
sequence of comments and processing-instructions.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <code>child::</code> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a> document { <a href=
"#doc-fs-Type"><em>Type</em></a> } <a href="#jd_axis_type" class=
"judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
&amp; processing-instruction<span>*</span>* &amp; comment*</td>
</tr>
</table>
<br /></div>
</div>
<div class="div5">
<h6><a name="sec_inference_attribute" id=
"sec_inference_attribute"></a>8.2.2.1.4 Inference rules for the
<code>attribute</code> axis</h6>
<p><b>Semantics</b></p>
<p>The static type for the attribute axis is computed in a similar
way as the static type for the child axis. As above, the <a href=
"#jd_expands_to" class="judgment"><b>expands to</b></a> judgment
may yield a union type. After type expansion, the judgment <a href=
"#jd_has_attribute_content" class="judgment"><b>has attribute
content</b></a> is applied to each type in the union.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-ElementType"><em>ElementType</em></a> <a href=
"#jd_static_lookup" class="judgment"><b>type lookup</b></a>
<a href="#doc-fs-OptNillable"><em>OptNillable</em></a> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-OptNillable"><em>OptNillable</em></a> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a> <a href=
"#jd_expands_to" class="judgment"><b>expands to</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
| · · · | <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">n</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_has_attribute_content" class="judgment"><b>has
attribute content</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>'</td>
</tr>
<tr align="center" valign="middle">
<td>· · ·</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>
<a href="#jd_has_attribute_content" class="judgment"><b>has
attribute content</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">n</font></sub>'</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <code>attribute::</code> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a> <a href=
"#doc-fs-ElementType"><em>ElementType</em></a> <a href=
"#jd_axis_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>'
| ... | <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">n</font></sub>'</td>
</tr>
</table>
<br /></div>
<p>When applied to an element type, <a href=
"#jd_has_attribute_content" class="judgment"><b>has attribute
content</b></a> yields the type of the element's content that are
attributes.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a> = (<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
attribute<span>*</span>*</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-ElementModel"><em>ElementModel</em></a>* | <a href=
"#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>*</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-Type"><em>Type</em></a> <a href=
"#jd_has_attribute_content" class="judgment"><b>has attribute
content</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
<br /></div>
<p>In case of an attribute type, the static type of the attribute
axis is empty.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <code>attribute::</code> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a> <a href=
"#doc-fs-AttributeType"><em>AttributeType</em></a> <a href=
"#jd_axis_type" class="judgment"><b>:</b></a>
<code>empty</code></td>
</tr>
</table>
<br /></div>
<p>In case of a text node type, the static type of the attribute
axis is empty.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <code>attribute::</code> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a> text <a href=
"#jd_axis_type" class="judgment"><b>:</b></a>
<code>empty</code></td>
</tr>
</table>
<br /></div>
<p>In case of a comment node type, the static type of the attribute
axis is empty.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <code>attribute::</code> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a> comment <a href=
"#jd_axis_type" class="judgment"><b>:</b></a>
<code>empty</code></td>
</tr>
</table>
<br /></div>
<p>In case of a processing-instruction node type, the static type
of the attribute axis is empty.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <code>attribute::</code> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a>
processing-instruction <span>*</span> <a href="#jd_axis_type"
class="judgment"><b>:</b></a> <code>empty</code></td>
</tr>
</table>
<br /></div>
<p>In case of a document node type, the static type of the
attribute axis is the empty.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <code>attribute::</code> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a> document { <a href=
"#doc-fs-Type"><em>Type</em></a> } <a href="#jd_axis_type" class=
"judgment"><b>:</b></a> <code>empty</code></td>
</tr>
</table>
<br /></div>
</div>
<div class="div5">
<h6><a name="sec_inference_parent" id=
"sec_inference_parent"></a>8.2.2.1.5 Inference rules for the
<code>parent</code> axis</h6>
<p><b>Semantics</b></p>
<p>The type for the parent of an element type, a text node type, a
PI node type, or a comment node type is either an element, a
document, or empty.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <code>parent::</code> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a> element
<span>*</span> <a href="#jd_axis_type" class=
"judgment"><b>:</b></a> (element <span>*</span> | document)?</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <code>parent::</code> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a> text <a href=
"#jd_axis_type" class="judgment"><b>:</b></a> (element
<span>*</span> | document)?</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <code>parent::</code> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a>
processing-instruction <span>*</span> <a href="#jd_axis_type"
class="judgment"><b>:</b></a> (element <span>*</span> |
document)?</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <code>parent::</code> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a> comment <a href=
"#jd_axis_type" class="judgment"><b>:</b></a> (element
<span>*</span> | document)?</td>
</tr>
</table>
<br /></div>
<p>The type for the parent of an attribute node is an element or
empty.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <code>parent::</code> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a> <a href=
"#doc-fs-AttributeType"><em>AttributeType</em></a> <a href=
"#jd_axis_type" class="judgment"><b>:</b></a> element
<span>*</span>?</td>
</tr>
</table>
<br /></div>
<p>The type for the parent of a document node type is always
empty.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <code>parent::</code> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a> <a href=
"#doc-fs-DocumentType"><em>DocumentType</em></a> <a href=
"#jd_axis_type" class="judgment"><b>:</b></a>
<code>empty</code></td>
</tr>
</table>
<br /></div>
</div>
<div class="div5">
<h6><a name="sec_inference_namespace" id=
"sec_inference_namespace"></a>8.2.2.1.6 Inference rules for the
<code>namespace</code> axis</h6>
<p><b>Semantics</b></p>
<p>The type for the namespace axis is always empty.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <code>namespace::</code> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a> <a href=
"#doc-fs-NodeType"><em>NodeType</em></a> <a href="#jd_axis_type"
class="judgment"><b>:</b></a> <code>empty</code></td>
</tr>
</table>
<br /></div>
</div>
<div class="div5">
<h6><a name="sec_inference_descendant" id=
"sec_inference_descendant"></a>8.2.2.1.7 Inference rules for the
<code>descendant</code> axis</h6>
<p><b>Semantics</b></p>
<p>The types for the descendant axis is obtained as the closure of
the type of the child axis. This is expressed by the following
inference rule.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <code>child::</code> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a> <a href="#jd_axis_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <code>child::</code> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a> <a href="#jd_prime"
class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
<a href="#jd_axis_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td>...</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <code>child::</code> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a> <a href="#jd_prime"
class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>)
<a href="#jd_axis_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">n+1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_prime" class=
"judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">n+1</font></sub>) <a href="#jd_subtype_of" class=
"judgment"><b>&lt;:</b></a> <a href="#jd_prime" class=
"judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
| ... | <a href="#jd_prime" class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">n</font></sub>)</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <code>descendant::</code> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a> <a href="#jd_axis_type" class=
"judgment"><b>:</b></a> (<a href="#jd_prime" class=
"judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
| ... | <a href="#jd_prime" class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">n</font></sub>))*</td>
</tr>
</table>
<br /></div>
<p><b>Note</b></p>
<p>Note that the last premise in the above rule terminates the
recursion. The rule computes the n-th type <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>
such that applying the child axis one more time does not add any
new item type to the union. This condition is guaranteed to hold at
some point, because the number of item types is bounded by all of
the item types defined in the in-scope schema definitions.</p>
</div>
<div class="div5">
<h6><a name="sec_inference_descendant_of_self" id=
"sec_inference_descendant_of_self"></a>8.2.2.1.8 Inference rules
for the <code>descendant-or-self</code> axis</h6>
<p><b>Semantics</b></p>
<p>The type for the descendant-or-self axis is the union of the
type for the self axis and for the descendant axis.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <code>descendant::</code> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_axis_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <code>descendant-or-self::</code>
<a href="#jd_axis_type" class="judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_axis_type" class="judgment"><b>:</b></a> (<a href=
"#jd_prime" class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
| <a href="#jd_prime" class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>))*</td>
</tr>
</table>
<br /></div>
</div>
<div class="div5">
<h6><a name="sec_inference_ancestor" id=
"sec_inference_ancestor"></a>8.2.2.1.9 Inference rules for the
<code>ancestor</code> axis</h6>
<p><b>Semantics</b></p>
<p>The type for the ancestor axis is computed similarly as for the
descendant axis.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <code>ancestor::</code> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a> <a href=
"#doc-fs-NodeType"><em>NodeType</em></a> <a href="#jd_axis_type"
class="judgment"><b>:</b></a> (element <span>*</span> |
document)*</td>
</tr>
</table>
<br /></div>
<p>Note that this rule will always result in the type
<code>(element <span>*</span> | document)*</code> type, but this
formulation is preferred for consistency, and in case the static
typing for the parent axis gets improved in a future version.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <code>parent::</code> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a> <a href="#jd_axis_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <code>parent::</code> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a> <a href="#jd_prime"
class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
<a href="#jd_axis_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td>...</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <code>parent::</code> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a> <a href="#jd_prime"
class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>)
<a href="#jd_axis_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">n+1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_prime" class=
"judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">n+1</font></sub>) <a href="#jd_subtype_of" class=
"judgment"><b>&lt;:</b></a> <a href="#jd_prime" class=
"judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
| ... | <a href="#jd_prime" class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">n</font></sub>)</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <code>ancestor::</code> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a> <a href="#jd_axis_type" class=
"judgment"><b>:</b></a> (<a href="#jd_prime" class=
"judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
| ... | <a href="#jd_prime" class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">n</font></sub>))*</td>
</tr>
</table>
<br /></div>
</div>
<div class="div5">
<h6><a name="sec_inference_ancestor_of_self" id=
"sec_inference_ancestor_of_self"></a>8.2.2.1.10 Inference rules for
the <code>ancestor-or-self</code> axis</h6>
<p><b>Semantics</b></p>
<p>The type for the ancestor-or-self axis is the union of the type
for the self axis and for the ancestor axis.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <code>ancestor::</code> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_axis_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <code>ancestor-or-self::</code>
<a href="#jd_axis_type" class="judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_axis_type" class="judgment"><b>:</b></a> (<a href=
"#jd_prime" class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
| <a href="#jd_prime" class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>))*</td>
</tr>
</table>
<br /></div>
</div>
</div>
<div class="div4">
<h5><a name="sec_dyn_axes" id="sec_dyn_axes"></a>8.2.2.2 Dynamic
semantics of axes</h5>
<p><b>Notation</b></p>
<p id="jd_axis">The following judgment</p>
<div align="center"><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis" class=
"judgment"><b>axis</b></a> <em>Axis</em> <a href="#jd_axis" class=
"judgment"><b>of</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_axis" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></div>
<p>holds when applying the axis <em>Axis</em> on <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> yields <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub>:</p>
<p><b>Example</b></p>
<p>For example, the following judgments hold.</p>
<div class="exampleInner">
<pre>
  axis child::      of    element sizes { text { "1 2 3" } }  =&gt;  text { "1 2 3" }

  axis attribute::  of
     element weight of type xs:integer {
       attribute xsi:type of type xs:QName {
         "xs:integer" of type xs:QName
       },
       42 of type xs:integer
     }
  =&gt; attribute xsi:type of type xs:QName {
       "xs:integer" of type xs:QName
     }

  
</pre></div>
<p><b>Semantics</b></p>
<p>This judgment is specified by the following rules.</p>
<p>The first set of rules are used to process the axis judgment on
each individual item in the input sequence.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis" class=
"judgment"><b>axis</b></a> <em>Axis</em> <a href="#jd_axis" class=
"judgment"><b>of</b></a> () <a href="#jd_axis" class=
"judgment"><b>=&gt;</b></a> ()</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis" class=
"judgment"><b>axis</b></a> <em>Axis</em> <a href="#jd_axis" class=
"judgment"><b>of</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_axis" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">3</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis" class=
"judgment"><b>axis</b></a> <em>Axis</em> <a href="#jd_axis" class=
"judgment"><b>of</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_axis" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">4</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis" class=
"judgment"><b>axis</b></a> <em>Axis</em> <a href="#jd_axis" class=
"judgment"><b>of</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>,<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_axis" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">3</font></sub>,<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">4</font></sub></td>
</tr>
</table>
<br /></div>
<p>The following rules specifies how the value filter judgment is
applied on each Axis.</p>
<p>The self axis just returns the context node.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis" class=
"judgment"><b>axis</b></a> <code>self::</code> <a href="#jd_axis"
class="judgment"><b>of</b></a> <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a> <a href="#jd_axis"
class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a></td>
</tr>
</table>
<br /></div>
<p>The child, parent, attribute and namespace axis are specified as
follows.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis" class=
"judgment"><b>axis</b></a> <code>child::</code> <a href="#jd_axis"
class="judgment"><b>of</b></a> element <a href=
"#doc-fs-ElementName"><em>ElementName</em></a> { <a href=
"#doc-fs-AttributeValue"><em>AttributeValue</em></a>,<a href=
"#doc-fs-ElementValue"><em>ElementValue</em></a> } <a href=
"#jd_axis" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-ElementValue"><em>ElementValue</em></a></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis" class=
"judgment"><b>axis</b></a> <code>attribute::</code> <a href=
"#jd_axis" class="judgment"><b>of</b></a> element <a href=
"#doc-fs-ElementName"><em>ElementName</em></a> { <a href=
"#doc-fs-AttributeValue"><em>AttributeValue</em></a>,<a href=
"#doc-fs-ElementValue"><em>ElementValue</em></a> } <a href=
"#jd_axis" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-AttributeValue"><em>AttributeValue</em></a></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis" class=
"judgment"><b>axis</b></a> <code>parent::</code> <a href="#jd_axis"
class="judgment"><b>of</b></a> <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a> <a href="#jd_axis"
class="judgment"><b>=&gt;</b></a> <em>dm:</em>parent(<a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a>)</td>
</tr>
</table>
<br /></div>
<p>The descendant, descendant-or-self, ancestor, and
ancestor-or-self axis are implemented through recursive application
of the children and parent filters.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis" class=
"judgment"><b>axis</b></a> <code>child::</code> <a href="#jd_axis"
class="judgment"><b>of</b></a> <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a> <a href="#jd_axis"
class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><a href="#jd_axis" class=
"judgment"><b>axis</b></a> <code>descendant::</code> <a href=
"#jd_axis" class="judgment"><b>of</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_axis" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis" class=
"judgment"><b>axis</b></a> <code>descendant::</code> <a href=
"#jd_axis" class="judgment"><b>of</b></a> <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a> <a href="#jd_axis"
class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>, <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis" class=
"judgment"><b>axis</b></a> <code>self::</code> <a href="#jd_axis"
class="judgment"><b>of</b></a> <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a> <a href="#jd_axis"
class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis" class=
"judgment"><b>axis</b></a> <code>descendant::</code> <a href=
"#jd_axis" class="judgment"><b>of</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_axis" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis" class=
"judgment"><b>axis</b></a> <code>descendant-or-self::</code>
<a href="#jd_axis" class="judgment"><b>of</b></a> <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a> <a href="#jd_axis"
class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>, <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis" class=
"judgment"><b>axis</b></a> <code>parent::</code> <a href="#jd_axis"
class="judgment"><b>of</b></a> <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a> <a href="#jd_axis"
class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis" class=
"judgment"><b>axis</b></a> <code>ancestor::</code> <a href=
"#jd_axis" class="judgment"><b>of</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_axis" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis" class=
"judgment"><b>axis</b></a> <code>ancestor::</code> <a href=
"#jd_axis" class="judgment"><b>of</b></a> <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a> <a href="#jd_axis"
class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>, <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis" class=
"judgment"><b>axis</b></a> <code>self::</code> <a href="#jd_axis"
class="judgment"><b>of</b></a> <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a> <a href="#jd_axis"
class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><a href="#jd_axis" class=
"judgment"><b>axis</b></a> <code>ancestor::</code> <a href=
"#jd_axis" class="judgment"><b>of</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_axis" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis" class=
"judgment"><b>axis</b></a> <code>ancestor-or-self::</code> <a href=
"#jd_axis" class="judgment"><b>of</b></a> <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a> <a href="#jd_axis"
class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>, <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
<br /></div>
<p>In all the other cases, the axis application results in an empty
sequence, and the following judgment holds.</p>
<div align="center"><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis" class=
"judgment"><b>axis</b></a> <em>Axis</em> <a href="#jd_axis" class=
"judgment"><b>of</b></a> <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a> <a href="#jd_axis"
class="judgment"><b>=&gt;</b></a> ()</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><em>Otherwise</em></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_axis" class=
"judgment"><b>axis</b></a> <em>Axis</em> <a href="#jd_axis" class=
"judgment"><b>of</b></a> <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a> <a href="#jd_axis"
class="judgment"><b>=&gt;</b></a> ()</td>
</tr>
</table>
<br /></div>
</div>
</div>
<div class="div3">
<h4><a name="sec_test_judge" id="sec_test_judge"></a>8.2.3
Auxiliary judgments for node tests</h4>
<p>A node test may be a name test or a kind test. In the static and
dynamic semantics, we begin with name tests, followed by kind
tests.</p>
<div class="div4">
<h5><a name="sec_sem_node_tests" id=
"sec_sem_node_tests"></a>8.2.3.1 Static semantics of node
tests</h5>
<p><b>Notation</b></p>
<p id="jd_test_type">The following judgment</p>
<div align="center"><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>NodeTest</em> <a href=
"#jd_test_type" class="judgment"><b>with</b></a>
<em>PrincipalNodeKind</em> <a href="#jd_test_type" class=
"judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_test_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></div>
<p>holds when applying the node test <em>NodeTest</em> on the type
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub> in the context of the given principal node kind,
yields the type <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>.</p>
<p><b>Example</b></p>
<p>For example, assuming the extended XML Schema given in section
<a href="#sec_types_example"><b>[2.4.5 Example of a complete
Schema]</b></a>, then the following judgments hold.</p>
<div class="exampleInner">
<pre>
  test shipTo with element of
    element shipTo of type USAddress,
    element billTo of type USAddress,
    element ipo:comment?,
    element items of type Items
  : element shipTo of type USAddress
</pre></div>
<p><b>Semantics</b></p>
<p>This judgment is specified by the following rules.</p>
<p>The first set of rules is similar to that for axes, and are used
to process the content each individual item type in the input
content model.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>NodeTest</em> <a href=
"#jd_test_type" class="judgment"><b>with</b></a>
<em>PrincipalNodeKind</em> <a href="#jd_test_type" class=
"judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_test_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>NodeTest</em> <a href=
"#jd_test_type" class="judgment"><b>with</b></a>
<em>PrincipalNodeKind</em> <a href="#jd_test_type" class=
"judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<em>OccurrenceIndicator</em> <a href="#jd_test_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<em>OccurrenceIndicator</em></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>NodeTest</em> <a href=
"#jd_test_type" class="judgment"><b>with</b></a>
<em>PrincipalNodeKind</em> <a href="#jd_test_type" class=
"judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_test_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">3</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>NodeTest</em> <a href=
"#jd_test_type" class="judgment"><b>with</b></a>
<em>PrincipalNodeKind</em> <a href="#jd_test_type" class=
"judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_test_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">4</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>NodeTest</em> <a href=
"#jd_test_type" class="judgment"><b>with</b></a>
<em>PrincipalNodeKind</em> <a href="#jd_test_type" class=
"judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
&amp; <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_test_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub>
&amp; <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">4</font></sub></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>NodeTest</em> <a href=
"#jd_test_type" class="judgment"><b>with</b></a>
<em>PrincipalNodeKind</em> <a href="#jd_test_type" class=
"judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_test_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">3</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>NodeTest</em> <a href=
"#jd_test_type" class="judgment"><b>with</b></a>
<em>PrincipalNodeKind</em> <a href="#jd_test_type" class=
"judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_test_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">4</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>NodeTest</em> <a href=
"#jd_test_type" class="judgment"><b>with</b></a>
<em>PrincipalNodeKind</em> <a href="#jd_test_type" class=
"judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
, <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_test_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub>
, <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">4</font></sub></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>NodeTest</em> <a href=
"#jd_test_type" class="judgment"><b>with</b></a>
<em>PrincipalNodeKind</em> <a href="#jd_test_type" class=
"judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_test_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">3</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>NodeTest</em> <a href=
"#jd_test_type" class="judgment"><b>with</b></a>
<em>PrincipalNodeKind</em> <a href="#jd_test_type" class=
"judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_test_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">4</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>NodeTest</em> <a href=
"#jd_test_type" class="judgment"><b>with</b></a>
<em>PrincipalNodeKind</em> <a href="#jd_test_type" class=
"judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>|<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_test_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">3</font></sub>|<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">4</font></sub></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>&#160;&#160;</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>NodeTest</em> <a href=
"#jd_test_type" class="judgment"><b>with</b></a>
<em>PrincipalNodeKind</em> <a href="#jd_test_type" class=
"judgment"><b>of</b></a> none <a href="#jd_test_type" class=
"judgment"><b>:</b></a> none</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>&#160;&#160;</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>NodeTest</em> <a href=
"#jd_test_type" class="judgment"><b>with</b></a>
<em>PrincipalNodeKind</em> <a href="#jd_test_type" class=
"judgment"><b>of</b></a> empty <a href="#jd_test_type" class=
"judgment"><b>:</b></a> empty</td>
</tr>
</table>
<br /></div>
<p>The following rules specify how the test judgment apply to node
tests in the context of a principal node kind. We start with name
tests followed by kind tests.</p>
<div class="div5">
<h6><a name="sec_sem_name_tests" id=
"sec_sem_name_tests"></a>8.2.3.1.1 Name Tests</h6>
<p>Name tests on elements and attributes always compute the most
specific type possible. For example, if <code>$v</code> is bound to
an element with a computed name, the type of <code>$v</code> is
<code>element</code>. The static type computed for the expression
<code>$v/self::foo</code> is <code>element foo of type
xs:anyType</code>, which makes use of <code>foo</code> in the name
test to compute a more specific type. Also note that each case of
name matching restricts the principal node kind appropriately.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
<em>QName</em><sub><font size="2">1</font></sub> <a href=
"#jd_elem_qname_expands_to" class="judgment"><b>of elem/type
expands to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
<em>QName</em><sub><font size="2">2</font></sub> <a href=
"#jd_elem_qname_expands_to" class="judgment"><b>of elem/type
expands to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>QName</em><sub><font size=
"2">2</font></sub> <a href="#jd_test_type" class=
"judgment"><b>with</b></a> element <a href="#jd_test_type" class=
"judgment"><b>of</b></a> element <em>QName</em><sub><font size=
"2">1</font></sub> <a href=
"#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a> <a href=
"#jd_test_type" class="judgment"><b>:</b></a> element
<em>QName</em><sub><font size="2">1</font></sub> <a href=
"#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
<em>QName</em><sub><font size="2">1</font></sub> <a href=
"#jd_elem_qname_expands_to" class="judgment"><b>of elem/type
expands to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
<em>QName</em><sub><font size="2">2</font></sub> <a href=
"#jd_elem_qname_expands_to" class="judgment"><b>of elem/type
expands to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#jd_not" class="judgment"><b>not</b></a>( <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size=
"2">1</font></sub> = <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size=
"2">2</font></sub> )</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>QName</em><sub><font size=
"2">2</font></sub> <a href="#jd_test_type" class=
"judgment"><b>with</b></a> element <a href="#jd_test_type" class=
"judgment"><b>of</b></a> element <em>QName</em><sub><font size=
"2">1</font></sub> <a href=
"#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a><sub><font size="2">1</font></sub>
<a href="#jd_test_type" class="judgment"><b>:</b></a> empty</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>QName</em><sub><font size=
"2">2</font></sub> <a href="#jd_test_type" class=
"judgment"><b>with</b></a> element <a href="#jd_test_type" class=
"judgment"><b>of</b></a> element <code>*</code> <a href=
"#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a> <a href=
"#jd_test_type" class="judgment"><b>:</b></a> element
<em>QName</em><sub><font size="2">2</font></sub> <a href=
"#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a>
<span>?</span></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>QName</em><sub><font size=
"2">2</font></sub> <a href="#jd_test_type" class=
"judgment"><b>with</b></a> element <a href="#jd_test_type" class=
"judgment"><b>of</b></a> element <a href=
"#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a> <a href=
"#jd_test_type" class="judgment"><b>:</b></a> element
<em>QName</em><sub><font size="2">2</font></sub> <a href=
"#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
<em>QName</em><sub><font size="2">1</font></sub> <a href=
"#jd_elem_qname_expands_to" class="judgment"><b>of elem/type
expands to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_ns_env" class=
"env">namespace</a>(<em>Prefix</em><sub><font size=
"2">1</font></sub>) = (<a href=
"#xq_ns_env"><em>NamespaceKind</em></a>,<em>AnyURI</em>)</td>
</tr>
<tr align="center" valign="middle">
<td><code>fn:namespace-uri-from-QName</code>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size=
"2">1</font></sub>) = <em>AnyURI</em></td>
</tr>
<tr align="center" valign="middle">
<td><em>LocalPart</em><sub><font size="2">2</font></sub> =
<code>fn:local-name-from-QName</code>( <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size=
"2">1</font></sub> )</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a>
<code>*:</code><em>LocalPart</em><sub><font size="2">2</font></sub>
<a href="#jd_test_type" class="judgment"><b>with</b></a> element
<a href="#jd_test_type" class="judgment"><b>of</b></a> element
<em>QName</em><sub><font size="2">1</font></sub> <a href=
"#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a> <a href=
"#jd_test_type" class="judgment"><b>:</b></a> element
<em>QName</em><sub><font size="2">1</font></sub> <a href=
"#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
<em>QName</em><sub><font size="2">1</font></sub> <a href=
"#jd_elem_qname_expands_to" class="judgment"><b>of elem/type
expands to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><code>fn:local-name-from-QName</code>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size=
"2">1</font></sub>) = <em>LocalPart</em><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#jd_not" class="judgment"><b>not</b></a>(
<em>LocalPart</em><sub><font size="2">1</font></sub> =
<em>LocalPart</em><sub><font size="2">2</font></sub> )</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a>
*:<em>LocalPart</em><sub><font size="2">2</font></sub> <a href=
"#jd_test_type" class="judgment"><b>with</b></a> element <a href=
"#jd_test_type" class="judgment"><b>of</b></a> element
<em>QName</em><sub><font size="2">1</font></sub> <a href=
"#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a><sub><font size="2">1</font></sub>
<a href="#jd_test_type" class="judgment"><b>:</b></a> empty</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a>
<code>*:</code><em>LocalPart</em><sub><font size="2">2</font></sub>
<a href="#jd_test_type" class="judgment"><b>with</b></a> element
<a href="#jd_test_type" class="judgment"><b>of</b></a> element *
<a href="#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a>
<a href="#jd_test_type" class="judgment"><b>:</b></a> element
<span>*</span> <a href=
"#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a>
<span>?</span></td>
</tr>
</table>
<br />
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
<em>QName</em><sub><font size="2">1</font></sub> <a href=
"#jd_elem_qname_expands_to" class="judgment"><b>of elem/type
expands to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_ns_env" class=
"env">namespace</a>(<span><em>Prefix</em><sub><font size=
"2">2</font></sub></span>) = (<a href=
"#xq_ns_env"><em>NamespaceKind</em></a>,<em>AnyURI</em>)</td>
</tr>
<tr align="center" valign="middle">
<td><code>fn:namespace-uri-from-QName</code>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size=
"2">1</font></sub>) = <em>AnyURI</em></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>Prefix</em><sub><font size=
"2">2</font></sub>:* <a href="#jd_test_type" class=
"judgment"><b>with</b></a> element <a href="#jd_test_type" class=
"judgment"><b>of</b></a> element <em>QName</em><sub><font size=
"2">1</font></sub> <a href=
"#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a> <a href=
"#jd_test_type" class="judgment"><b>:</b></a> element
<em>QName</em><sub><font size="2">1</font></sub> <a href=
"#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
<em>QName</em><sub><font size="2">1</font></sub> <a href=
"#jd_elem_qname_expands_to" class="judgment"><b>of elem/type
expands to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><code>fn:namespace-uri-from-QName</code>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size=
"2">1</font></sub>) = <em>AnyURI</em><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_ns_env" class=
"env">namespace</a>(<em>Prefix</em><sub><font size=
"2">2</font></sub>) = (<a href=
"#xq_ns_env"><em>NamespaceKind</em></a>,<em>AnyURI</em><sub><font size="2">2</font></sub>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#jd_not" class="judgment"><b>not</b></a>(
<em>AnyURI</em><sub><font size="2">1</font></sub> =
<em>AnyURI</em><sub><font size="2">2</font></sub> )</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>Prefix</em><sub><font size=
"2">2</font></sub>:* <a href="#jd_test_type" class=
"judgment"><b>with</b></a> element <a href="#jd_test_type" class=
"judgment"><b>of</b></a> element <em>QName</em><sub><font size=
"2">1</font></sub> <a href=
"#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a><sub><font size="2">1</font></sub>
<a href="#jd_test_type" class="judgment"><b>:</b></a> empty</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>Prefix</em><sub><font size=
"2">2</font></sub><code>:*</code> <a href="#jd_test_type" class=
"judgment"><b>with</b></a> element <a href="#jd_test_type" class=
"judgment"><b>of</b></a> element * <a href=
"#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a> <a href=
"#jd_test_type" class="judgment"><b>:</b></a> element
<span>*</span> <a href=
"#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a>
<span>?</span></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <code>*</code> <a href=
"#jd_test_type" class="judgment"><b>with</b></a> element <a href=
"#jd_test_type" class="judgment"><b>of</b></a> <span><a href=
"#doc-fs-ElementType"><em>ElementType</em></a></span> <a href=
"#jd_test_type" class="judgment"><b>:</b></a> <span><a href=
"#doc-fs-ElementType"><em>ElementType</em></a></span></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#jd_not" class="judgment"><b>not</b></a>( <a href=
"#doc-fs-Type"><em>Type</em></a> is an element type )</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>NameTest</em> <a href=
"#jd_test_type" class="judgment"><b>with</b></a> element <a href=
"#jd_test_type" class="judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a> <a href="#jd_test_type" class=
"judgment"><b>:</b></a> empty</td>
</tr>
</table>
<br /></div>
<p>Similar static typing rules apply to the attribute name
tests:</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
<em>QName</em><sub><font size="2">1</font></sub> <a href=
"#jd_attr_qname_expands_to" class="judgment"><b>of attr expands
to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
<em>QName</em><sub><font size="2">2</font></sub> <a href=
"#jd_attr_qname_expands_to" class="judgment"><b>of attr expands
to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>QName</em><sub><font size=
"2">2</font></sub> <a href="#jd_test_type" class=
"judgment"><b>with</b></a> attribute <a href="#jd_test_type" class=
"judgment"><b>of</b></a> attribute <em>QName</em><sub><font size=
"2">1</font></sub> <a href=
"#doc-fs-OptTypeReference"><em>OptTypeReference</em></a> <a href=
"#jd_test_type" class="judgment"><b>:</b></a> attribute
<em>QName</em><sub><font size="2">1</font></sub> <a href=
"#doc-fs-OptTypeReference"><em>OptTypeReference</em></a></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
<em>QName</em><sub><font size="2">1</font></sub> <a href=
"#jd_attr_qname_expands_to" class="judgment"><b>of attr expands
to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
<em>QName</em><sub><font size="2">2</font></sub> <a href=
"#jd_attr_qname_expands_to" class="judgment"><b>of attr expands
to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#jd_not" class="judgment"><b>not</b></a>( <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size=
"2">1</font></sub> = <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size=
"2">2</font></sub> )</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>QName</em><sub><font size=
"2">2</font></sub> <a href="#jd_test_type" class=
"judgment"><b>with</b></a> attribute <a href="#jd_test_type" class=
"judgment"><b>of</b></a> attribute <em>QName</em><sub><font size=
"2">1</font></sub> <a href=
"#doc-fs-OptTypeReference"><em>OptTypeReference</em></a> <a href=
"#jd_test_type" class="judgment"><b>:</b></a> empty</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>QName</em><sub><font size=
"2">2</font></sub> <a href="#jd_test_type" class=
"judgment"><b>with</b></a> attribute <a href="#jd_test_type" class=
"judgment"><b>of</b></a> attribute <code>*</code> <a href=
"#doc-fs-OptTypeReference"><em>OptTypeReference</em></a> <a href=
"#jd_test_type" class="judgment"><b>:</b></a> attribute
<em>QName</em><sub><font size="2">2</font></sub> <a href=
"#doc-fs-OptTypeReference"><em>OptTypeReference</em></a>
<span>?</span></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>QName</em><sub><font size=
"2">2</font></sub> <a href="#jd_test_type" class=
"judgment"><b>with</b></a> attribute <a href="#jd_test_type" class=
"judgment"><b>of</b></a> attribute <a href=
"#doc-fs-OptTypeReference"><em>OptTypeReference</em></a> <a href=
"#jd_test_type" class="judgment"><b>:</b></a> attribute
<em>QName</em><sub><font size="2">2</font></sub> <a href=
"#doc-fs-OptTypeReference"><em>OptTypeReference</em></a></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
<em>QName</em><sub><font size="2">1</font></sub> <a href=
"#jd_attr_qname_expands_to" class="judgment"><b>of attr expands
to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><code>fn:local-name-from-QName</code>( <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size=
"2">1</font></sub> ) = <em>LocalPart</em><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a>
<code>*:</code><em>LocalPart</em><sub><font size="2">2</font></sub>
<a href="#jd_test_type" class="judgment"><b>with</b></a> attribute
<a href="#jd_test_type" class="judgment"><b>of</b></a> attribute
<em>QName</em><sub><font size="2">1</font></sub> <a href=
"#doc-fs-OptTypeReference"><em>OptTypeReference</em></a> <a href=
"#jd_test_type" class="judgment"><b>:</b></a> attribute
<em>QName</em><sub><font size="2">1</font></sub> <a href=
"#doc-fs-OptTypeReference"><em>OptTypeReference</em></a></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
<em>QName</em><sub><font size="2">1</font></sub> <a href=
"#jd_attr_qname_expands_to" class="judgment"><b>of attr expands
to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><code>fn:local-name-from-QName</code>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size=
"2">1</font></sub>) = <em>LocalPart</em><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#jd_not" class="judgment"><b>not</b></a>(
<em>LocalPart</em><sub><font size="2">1</font></sub> =
<em>LocalPart</em><sub><font size="2">2</font></sub> )</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a>
*:<em>LocalPart</em><sub><font size="2">2</font></sub> <a href=
"#jd_test_type" class="judgment"><b>with</b></a> attribute <a href=
"#jd_test_type" class="judgment"><b>of</b></a> attribute
<em>QName</em><sub><font size="2">1</font></sub> <a href=
"#doc-fs-OptTypeReference"><em>OptTypeReference</em></a> <a href=
"#jd_test_type" class="judgment"><b>:</b></a> empty</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a>
<code>*:</code><em>LocalPart</em><sub><font size="2">2</font></sub>
<a href="#jd_test_type" class="judgment"><b>with</b></a> attribute
<a href="#jd_test_type" class="judgment"><b>of</b></a> attribute *
<a href="#doc-fs-OptTypeReference"><em>OptTypeReference</em></a>
<a href="#jd_test_type" class="judgment"><b>:</b></a> attribute
<span>*</span> <a href=
"#doc-fs-OptTypeReference"><em>OptTypeReference</em></a>
<span>?</span></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_ns_env" class=
"env">namespace</a>(<em>Prefix</em><sub><font size=
"2">2</font></sub>) = (<a href=
"#xq_ns_env"><em>NamespaceKind</em></a>,<em>AnyURI</em>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
<em>QName</em><sub><font size="2">1</font></sub> <span><a href=
"#jd_attr_qname_expands_to" class="judgment"><b>of attr expands
to</b></a></span> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><code>fn:namespace-uri-from-QName</code>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size=
"2">1</font></sub>) = <em>AnyURI</em></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>Prefix</em><sub><font size=
"2">2</font></sub><code>:*</code> <a href="#jd_test_type" class=
"judgment"><b>with</b></a> attribute <a href="#jd_test_type" class=
"judgment"><b>of</b></a> attribute <em>QName</em><sub><font size=
"2">1</font></sub> <a href=
"#doc-fs-OptTypeReference"><em>OptTypeReference</em></a> <a href=
"#jd_test_type" class="judgment"><b>:</b></a> attribute
<em>QName</em><sub><font size="2">1</font></sub> <a href=
"#doc-fs-OptTypeReference"><em>OptTypeReference</em></a></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>
<em>QName</em><sub><font size="2">1</font></sub> <a href=
"#jd_attr_qname_expands_to" class="judgment"><b>of attr expands
to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><code>fn:namespace-uri-from-QName</code>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size=
"2">1</font></sub>) = <em>AnyURI</em><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_ns_env" class=
"env">namespace</a>(<em>Prefix</em><sub><font size=
"2">2</font></sub>) = (<a href=
"#xq_ns_env"><em>NamespaceKind</em></a>,<em>AnyURI</em><sub><font size="2">2</font></sub>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#jd_not" class="judgment"><b>not</b></a>(
<em>AnyURI</em><sub><font size="2">1</font></sub> =
<em>AnyURI</em><sub><font size="2">2</font></sub> )</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>Prefix</em><sub><font size=
"2">2</font></sub>:* <a href="#jd_test_type" class=
"judgment"><b>with</b></a> attribute <a href="#jd_test_type" class=
"judgment"><b>of</b></a> attribute <em>QName</em><sub><font size=
"2">1</font></sub> <a href=
"#doc-fs-OptTypeReference"><em>OptTypeReference</em></a> <a href=
"#jd_test_type" class="judgment"><b>:</b></a> empty</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>Prefix</em><sub><font size=
"2">2</font></sub><code>:*</code> <a href="#jd_test_type" class=
"judgment"><b>with</b></a> attribute <a href="#jd_test_type" class=
"judgment"><b>of</b></a> attribute * <a href=
"#doc-fs-OptTypeReference"><em>OptTypeReference</em></a> <a href=
"#jd_test_type" class="judgment"><b>:</b></a> attribute
<span>*</span> <a href=
"#doc-fs-OptTypeReference"><em>OptTypeReference</em></a>
<span>?</span></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <code>*</code> <a href=
"#jd_test_type" class="judgment"><b>with</b></a> attribute <a href=
"#jd_test_type" class="judgment"><b>of</b></a> <span><a href=
"#doc-fs-AttributeType"><em>AttributeType</em></a></span> <a href=
"#jd_test_type" class="judgment"><b>:</b></a> <span><a href=
"#doc-fs-AttributeType"><em>AttributeType</em></a></span></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#jd_not" class="judgment"><b>not</b></a>( <a href=
"#doc-fs-Type"><em>Type</em></a> is an attribute type )</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>NameTest</em> <a href=
"#jd_test_type" class="judgment"><b>with</b></a> attribute <a href=
"#jd_test_type" class="judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a> <a href="#jd_test_type" class=
"judgment"><b>:</b></a> empty</td>
</tr>
</table>
<br /></div>
<p>Lastly, if none of the above rules holds, then the type of the
input expression is empty.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href=
"#doc-xquery-ElementNameOrWildcard"><em>ElementNameOrWildcard</em></a><sub><font size="2">1</font></sub>
= <em>NameTest</em></td>
</tr>
<tr align="center" valign="middle">
<td><a href=
"#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size=
"2">1</font></sub> = of type <code>xs:anyType</code></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_not" class=
"judgment"><b>not</b></a>(element <a href=
"#doc-xquery-ElementNameOrWildcard"><em>ElementNameOrWildcard</em></a><sub><font size="2">1</font></sub>
<a href=
"#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_subtype_of" class=
"judgment"><b>&lt;:</b></a> element <a href=
"#doc-xquery-ElementNameOrWildcard"><em>ElementNameOrWildcard</em></a><sub><font size="2">2</font></sub>
<a href=
"#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size=
"2">2</font></sub>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_not" class=
"judgment"><b>not</b></a>(element <a href=
"#doc-xquery-ElementNameOrWildcard"><em>ElementNameOrWildcard</em></a><sub><font size="2">2</font></sub>
<a href=
"#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_subtype_of" class=
"judgment"><b>&lt;:</b></a> element <a href=
"#doc-xquery-ElementNameOrWildcard"><em>ElementNameOrWildcard</em></a><sub><font size="2">1</font></sub>
<a href=
"#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size=
"2">1</font></sub>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_expands_to" class=
"judgment"><b>expands to</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_expands_to" class=
"judgment"><b>expands to</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_not" class=
"judgment"><b>not</b></a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_not" class=
"judgment"><b>not</b></a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>)</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>NameTest</em> <a href=
"#jd_test_type" class="judgment"><b>with</b></a> element <a href=
"#jd_test_type" class="judgment"><b>of</b></a> element <a href=
"#doc-xquery-ElementNameOrWildcard"><em>ElementNameOrWildcard</em></a><sub><font size="2">2</font></sub>
<a href=
"#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_test_type" class=
"judgment"><b>:</b></a> empty</td>
</tr>
</table>
<br /></div>
</div>
<div class="div5">
<h6><a name="sec_sem_kind_tests" id=
"sec_sem_kind_tests"></a>8.2.3.1.2 Kind Tests</h6>
<p>All the rules for typing the document, element, and attribute
kind tests are similar. First, the document, element, or attribute
test is normalized to the equivalent document, element, or
attribute type by applying the <font size="6">[</font><font size=
"6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a>
normalization rule to the kind test.</p>
<p>After normalization of the kind test as an XQuery type, that
type is compared to the expression's inferred type. If the latter
is a subtype of the former other, then the kind test yields the
smaller type.</p>
<p><b><em>Document kind test</em></b></p>
<p><b>Semantics</b></p>
<p>If the type of the expression is a subtype of the document kind
test, then we are guaranteed that during evaluation, the
expression's value will always match the document kind test, and
therefore the type of the entire expression is the type of the
input expression.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><font size="6">[</font><em>DocumentTest</em><font size=
"6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a> =
<a href="#doc-fs-DocumentType"><em>DocumentType</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-DocumentType"><em>DocumentType</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>DocumentTest</em> <a href=
"#jd_test_type" class="judgment"><b>with</b></a> element <a href=
"#jd_test_type" class="judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_test_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
<br /></div>
<p>Conversely, if the type of the document kind test is a subtype
of the expression, then during evaluation, the expression's value
may or may not match the document kind test, and therefore the type
of the entire expression is zero-or-one of the type of the document
kind test.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><font size="6">[</font><em>DocumentTest</em><font size=
"6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a> =
<a href="#doc-fs-DocumentType"><em>DocumentType</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-DocumentType"><em>DocumentType</em></a> <a href=
"#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>DocumentTest</em> <a href=
"#jd_test_type" class="judgment"><b>with</b></a> element <a href=
"#jd_test_type" class="judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_test_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-DocumentType"><em>DocumentType</em></a>?</td>
</tr>
</table>
<br /></div>
<p>If the types of the expression and document kind test are
unrelated, then we apply the kind test rule recursively on the
element types, which may yield a non-empty type.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><font size="6">[</font>document-node
(<em>ElementTest</em>)<font size="6">]</font><a href=
"#jd_map_sequencetype" class="judgment"><sub><font size=
"2">sequencetype</font></sub></a> = <a href=
"#doc-fs-DocumentType"><em>DocumentType</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_not" class=
"judgment"><b>not</b></a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-DocumentType"><em>DocumentType</em></a>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_not" class=
"judgment"><b>not</b></a>(<a href=
"#doc-fs-DocumentType"><em>DocumentType</em></a> <a href=
"#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>ElementTest</em> <a href=
"#jd_test_type" class="judgment"><b>with</b></a> element <a href=
"#jd_test" class="judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_test_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
&#160;&#160;&#160;&#160;<a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_not" class=
"judgment"><b>not</b></a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
<code>empty</code>)</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> document-node
(<em>ElementTest</em>) <a href="#jd_test_type" class=
"judgment"><b>with</b></a> element <a href="#jd_test" class=
"judgment"><b>of</b></a> document { <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
} <a href="#jd_test_type" class="judgment"><b>:</b></a> document {
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub> }</td>
</tr>
</table>
<br /></div>
<p>If there is no non-empty type, then the kind test yields the
empty type.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><font size="6">[</font>document-node
(<em>ElementTest</em>)<font size="6">]</font><a href=
"#jd_map_sequencetype" class="judgment"><sub><font size=
"2">sequencetype</font></sub></a> = <a href=
"#doc-fs-DocumentType"><em>DocumentType</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_not" class=
"judgment"><b>not</b></a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-DocumentType"><em>DocumentType</em></a>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_not" class=
"judgment"><b>not</b></a>(<a href=
"#doc-fs-DocumentType"><em>DocumentType</em></a> <a href=
"#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>ElementTest</em> <a href=
"#jd_test_type" class="judgment"><b>with</b></a> element <a href=
"#jd_test" class="judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_test_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
<code>empty</code></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> document-node
(<em>ElementTest</em>) <a href="#jd_test_type" class=
"judgment"><b>with</b></a> element <a href="#jd_test" class=
"judgment"><b>of</b></a> document { <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
} <a href="#jd_test_type" class="judgment"><b>:</b></a> empty</td>
</tr>
</table>
<br /></div>
<p><b><em>Element kind test</em></b></p>
<p><b>Semantics</b></p>
<p>The rules for the element kind test are similar to those for the
document kind test.</p>
<p>If the type of the expression is a subtype of the element kind
test, then we are guaranteed that during evaluation, the
expression's element value will always match the element kind test,
and therefore the type of the entire expression is the type of the
input expression.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><font size="6">[</font><em>ElementTest</em><font size=
"6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a> =
<a href="#doc-fs-ElementType"><em>ElementType</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-ElementType"><em>ElementType</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>ElementTest</em> <a href=
"#jd_test_type" class="judgment"><b>with</b></a> element <a href=
"#jd_test_type" class="judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_test_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
<br /></div>
<p>Conversely, if the type of the element kind test is a subtype of
the expression, then during evaluation, the expression's element
value may or may not match the element kind test, and therefore the
type of the entire expression is zero-or-one of the type of the
element kind test.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><font size="6">[</font><em>ElementTest</em><font size=
"6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a> =
<a href="#doc-fs-ElementType"><em>ElementType</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-ElementType"><em>ElementType</em></a> <a href=
"#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>ElementTest</em> <a href=
"#jd_test_type" class="judgment"><b>with</b></a> element <a href=
"#jd_test_type" class="judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_test_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-ElementType"><em>ElementType</em></a>?</td>
</tr>
</table>
<br /></div>
<p>If the types of the expression and element kind test are
unrelated (i.e., neither type is a subtype of the other), then we
must compare the structure of the type of the element test with the
type of the element expression, as an element type or test may
contain wildcards.</p>
<p>In the first case, the element kind test contains an element
name and a type name and the input expression's type contains only
a type name. If the input expression's content type is a subtype of
the element kind test's content type, then the type of the entire
expression is zero-or-one of an element with the given name and the
input expression's content type.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><font size="6">[</font><em>ElementTest</em><font size=
"6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a> =
element <a href=
"#doc-fs-ElementName"><em>ElementName</em></a><sub><font size=
"2">1</font></sub> <a href=
"#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size=
"2">1</font></sub>&#160;&#160;&#160;&#160;<a href=
"#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_expands_to" class=
"judgment"><b>expands to</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_expands_to" class=
"judgment"><b>expands to</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>ElementTest</em> <a href=
"#jd_test_type" class="judgment"><b>with</b></a> element <a href=
"#jd_test_type" class="judgment"><b>of</b></a> element
<span>*</span> <a href=
"#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_test_type" class=
"judgment"><b>:</b></a> element <a href=
"#doc-fs-ElementName"><em>ElementName</em></a><sub><font size=
"2">1</font></sub> <a href=
"#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size=
"2">2</font></sub>?</td>
</tr>
</table>
<br /></div>
<p>In the second case, the structure of the input types is
reversed: The input expression's type contains an element name and
a type name and the element kind test's type contains only a type
name. If the element kind test's content type is a subtype of the
input expression's content type, then the type of the entire
expression is zero-or-one of an element with the given name and the
element kind test's content type.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><font size="6">[</font><em>ElementTest</em><font size=
"6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a> =
element <span>*</span> <a href=
"#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size=
"2">1</font></sub>&#160;&#160;&#160;&#160;<a href=
"#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_expands_to" class=
"judgment"><b>expands to</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_expands_to" class=
"judgment"><b>expands to</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>ElementTest</em> <a href=
"#jd_test_type" class="judgment"><b>with</b></a> element <a href=
"#jd_test_type" class="judgment"><b>of</b></a> element <a href=
"#doc-fs-ElementName"><em>ElementName</em></a><sub><font size=
"2">2</font></sub> <a href=
"#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_test_type" class=
"judgment"><b>:</b></a> element <a href=
"#doc-fs-ElementName"><em>ElementName</em></a><sub><font size=
"2">2</font></sub> <a href=
"#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size=
"2">1</font></sub>?</td>
</tr>
</table>
<br /></div>
<p>Lastly, if none of the above rules holds, then the type of the
input expression is empty.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><font size="6">[</font><em>ElementTest</em><font size=
"6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a> =
element <a href=
"#doc-xquery-ElementNameOrWildcard"><em>ElementNameOrWildcard</em></a><sub><font size="2">1</font></sub>
<a href=
"#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_not" class=
"judgment"><b>not</b></a>(element <a href=
"#doc-xquery-ElementNameOrWildcard"><em>ElementNameOrWildcard</em></a><sub><font size="2">1</font></sub>
<a href=
"#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_subtype_of" class=
"judgment"><b>&lt;:</b></a> element <a href=
"#doc-xquery-ElementNameOrWildcard"><em>ElementNameOrWildcard</em></a><sub><font size="2">2</font></sub>
<a href=
"#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size=
"2">2</font></sub>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_not" class=
"judgment"><b>not</b></a>(element <a href=
"#doc-xquery-ElementNameOrWildcard"><em>ElementNameOrWildcard</em></a><sub><font size="2">2</font></sub>
<a href=
"#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_subtype_of" class=
"judgment"><b>&lt;:</b></a> element <a href=
"#doc-xquery-ElementNameOrWildcard"><em>ElementNameOrWildcard</em></a><sub><font size="2">1</font></sub>
<a href=
"#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size=
"2">1</font></sub>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_expands_to" class=
"judgment"><b>expands to</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_expands_to" class=
"judgment"><b>expands to</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_not" class=
"judgment"><b>not</b></a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_not" class=
"judgment"><b>not</b></a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>)</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>ElementTest</em> <a href=
"#jd_test_type" class="judgment"><b>with</b></a> element <a href=
"#jd_test_type" class="judgment"><b>of</b></a> element <a href=
"#doc-xquery-ElementNameOrWildcard"><em>ElementNameOrWildcard</em></a><sub><font size="2">2</font></sub>
<a href=
"#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_test_type" class=
"judgment"><b>:</b></a> empty</td>
</tr>
</table>
<br /></div>
<p><b><em>Attribute kind test</em></b></p>
<p><b>Semantics</b></p>
<p>The rules for the attribute kind test are isomorphic to those
for element kind test.</p>
<p>If the type of the expression is a subtype of the attribute kind
test, then we are guaranteed that during evaluation, the
expression's attribute value will always match the attribute kind
test, and therefore the type of the entire expression is the type
of the input expression.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><font size="6">[</font><em>AttributeTest</em><font size=
"6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a> =
<a href="#doc-fs-AttributeType"><em>AttributeType</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-AttributeType"><em>AttributeType</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>AttributeTest</em> <a href=
"#jd_test_type" class="judgment"><b>with</b></a> attribute <a href=
"#jd_test_type" class="judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_test_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
<br /></div>
<p>Conversely, if the type of the attribute kind test is a subtype
of the expression, then during evaluation, the expression's
attribute value may or may not match the attribute kind test, and
therefore the type of the entire expression is zero-or-one of the
type of the attribute kind test.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><font size="6">[</font><em>AttributeTest</em><font size=
"6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a> =
<a href="#doc-fs-AttributeType"><em>AttributeType</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-AttributeType"><em>AttributeType</em></a> <a href=
"#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>AttributeTest</em> <a href=
"#jd_test_type" class="judgment"><b>with</b></a> attribute <a href=
"#jd_test_type" class="judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_test_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-AttributeType"><em>AttributeType</em></a>?</td>
</tr>
</table>
<br /></div>
<p>If the types of the expression and attribute kind test are
unrelated (i.e., neither type is a subtype of the other), then we
must compare the structure of the type of the attribute test with
the type of the attribute expression, as an attribute type or test
may contain wildcards.</p>
<p>In the first case, the attribute kind test contains an attribute
name and a type name and the input expression's type contains only
a type name. If the input expression's content type is a subtype of
the attribute kind test's content type, then the type of the entire
expression is zero-or-one of an attribute with the given name and
the input expression's content type.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><font size="6">[</font><em>AttributeTest</em><font size=
"6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a> =
attribute <a href=
"#doc-fs-AttributeName"><em>AttributeName</em></a><sub><font size=
"2">1</font></sub> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a><sub><font size=
"2">1</font></sub>&#160;&#160;&#160;&#160;<a href=
"#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_expands_to" class=
"judgment"><b>expands to</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_expands_to" class=
"judgment"><b>expands to</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>AttributeTest</em> <a href=
"#jd_test_type" class="judgment"><b>with</b></a> attribute <a href=
"#jd_test_type" class="judgment"><b>of</b></a> attribute
<span>*</span> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_test_type" class=
"judgment"><b>:</b></a> attribute <a href=
"#doc-fs-AttributeName"><em>AttributeName</em></a><sub><font size=
"2">1</font></sub> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a><sub><font size=
"2">2</font></sub>?</td>
</tr>
</table>
<br /></div>
<p>In the second case, the structure of the input types is
reversed: The input expression's type contains an attribute name
and a type name and the attribute kind test's type contains only a
type name. If the attribute kind test's content type is a subtype
of the input expression's content type, then the type of the entire
expression is zero-or-one of an attribute with the given name and
the attribute kind test's content type.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><font size="6">[</font><em>AttributeTest</em><font size=
"6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a> =
attribute <span>*</span> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a><sub><font size=
"2">1</font></sub>&#160;&#160;&#160;&#160;<a href=
"#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_expands_to" class=
"judgment"><b>expands to</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_expands_to" class=
"judgment"><b>expands to</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>AttributeTest</em> <a href=
"#jd_test_type" class="judgment"><b>with</b></a> attribute <a href=
"#jd_test_type" class="judgment"><b>of</b></a> attribute <a href=
"#doc-fs-AttributeName"><em>AttributeName</em></a><sub><font size=
"2">2</font></sub> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_test_type" class=
"judgment"><b>:</b></a> attribute <a href=
"#doc-fs-AttributeName"><em>AttributeName</em></a><sub><font size=
"2">2</font></sub> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a><sub><font size=
"2">1</font></sub>?</td>
</tr>
</table>
<br /></div>
<p>Lastly, if none of the above rules holds, then the type of the
input expression is empty.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><font size="6">[</font><em>AttributeTest</em><font size=
"6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a> =
attribute <a href=
"#doc-fs-AttributeNameOrWildcard"><em>AttributeName</em></a><sub><font size="2">1</font></sub>
<a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_not" class=
"judgment"><b>not</b></a>(attribute <a href=
"#doc-fs-AttributeNameOrWildcard"><em>AttributeName</em></a><sub><font size="2">1</font></sub>
<a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_subtype_of" class=
"judgment"><b>&lt;:</b></a> attribute <a href=
"#doc-fs-AttributeNameOrWildcard"><em>AttributeName</em></a><sub><font size="2">2</font></sub>
<a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a><sub><font size=
"2">2</font></sub>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_not" class=
"judgment"><b>not</b></a>(attribute <a href=
"#doc-fs-AttributeNameOrWildcard"><em>AttributeName</em></a><sub><font size="2">2</font></sub>
<a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_subtype_of" class=
"judgment"><b>&lt;:</b></a> attribute <a href=
"#doc-fs-AttributeNameOrWildcard"><em>AttributeName</em></a><sub><font size="2">1</font></sub>
<a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a><sub><font size=
"2">1</font></sub>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_expands_to" class=
"judgment"><b>expands to</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_expands_to" class=
"judgment"><b>expands to</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_not" class=
"judgment"><b>not</b></a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_not" class=
"judgment"><b>not</b></a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>)</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>AttributeTest</em> <a href=
"#jd_test_type" class="judgment"><b>with</b></a> attribute <a href=
"#jd_test_type" class="judgment"><b>of</b></a> attribute <a href=
"#doc-fs-AttributeNameOrWildcard"><em>AttributeName</em></a><sub><font size="2">2</font></sub>
<a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_test_type" class=
"judgment"><b>:</b></a> empty</td>
</tr>
</table>
<br /></div>
<p><b><em>Processing instruction, comment, and text kind
tests</em></b></p>
<p><b>Semantics</b></p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><font size="6">[</font><em>PITest</em><font size=
"6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a> =
processing-instruction *</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>PITest</em> <a href=
"#jd_test_type" class="judgment"><b>with</b></a>
<em>PrincipalNodeKind</em> <a href="#jd_test_type" class=
"judgment"><b>of</b></a> <a href=
"#doc-fs-ProcessingInstructionType"><em>ProcessingInstructionType</em></a>
<a href="#jd_test_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-ProcessingInstructionType"><em>ProcessingInstructionType</em></a></td>
</tr>
</table>
<br /></div>
<p>A processing-instruction node test with a string literal or
NCName matches a processing instruction whose target has the given
name. <span>Since target matching cannot be checked statically, the
static type of the node test is zero-or-one processing
instruction.</span></p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><font size="6">[</font><em>PITest</em><font size=
"6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a> =
processing-instruction <em>NCName</em></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>PITest</em> <a href=
"#jd_test_type" class="judgment"><b>with</b></a>
<em>PrincipalNodeKind</em> <a href="#jd_test_type" class=
"judgment"><b>of</b></a> processing-instruction <em>NCName</em>
<a href="#jd_test_type" class="judgment"><b>:</b></a>
processing-instruction <em>NCName</em></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><font size="6">[</font><em>PITest</em><font size=
"6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a> =
processing-instruction <em>NCName</em></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>PITest</em> <a href=
"#jd_test_type" class="judgment"><b>with</b></a>
<em>PrincipalNodeKind</em> <a href="#jd_test_type" class=
"judgment"><b>of</b></a> processing-instruction * <a href=
"#jd_test_type" class="judgment"><b>:</b></a>
processing-instruction <em>NCName</em> ?</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <code>comment()</code> <a href=
"#jd_test_type" class="judgment"><b>with</b></a>
<em>PrincipalNodeKind</em> <a href="#jd_test_type" class=
"judgment"><b>of</b></a> comment <a href="#jd_test_type" class=
"judgment"><b>:</b></a> comment</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <code>text()</code> <a href=
"#jd_test_type" class="judgment"><b>with</b></a>
<em>PrincipalNodeKind</em> <a href="#jd_test_type" class=
"judgment"><b>of</b></a> text <a href="#jd_test_type" class=
"judgment"><b>:</b></a> text</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <code>node()</code> <a href=
"#jd_test_type" class="judgment"><b>with</b></a>
<em>PrincipalNodeKind</em> <a href="#jd_test_type" class=
"judgment"><b>of</b></a> <a href=
"#doc-fs-NodeType"><em>NodeType</em></a> <a href="#jd_test_type"
class="judgment"><b>:</b></a> <a href=
"#doc-fs-NodeType"><em>NodeType</em></a></td>
</tr>
</table>
<br /></div>
<p>If none of the above rules applies then the node test returns
the empty sequence, and the following dynamic rule is applied:</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><em>Otherwise</em></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>NodeTest</em> <a href=
"#jd_test_type" class="judgment"><b>with</b></a>
<em>PrincipalNodeKind</em> <a href="#jd_test_type" class=
"judgment"><b>of</b></a> <a href=
"#doc-fs-NodeType"><em>NodeType</em></a> <a href="#jd_test_type"
class="judgment"><b>:</b></a> <code>empty</code></td>
</tr>
</table>
<br /></div>
</div>
</div>
<div class="div4">
<h5><a name="sec_dyn_node_tests" id=
"sec_dyn_node_tests"></a>8.2.3.2 Dynamic semantics of node
tests</h5>
<p><b>Notation</b></p>
<p id="jd_test">The following judgment</p>
<div align="center"><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test" class=
"judgment"><b>test</b></a> <em>NodeTest</em> <a href="#jd_test"
class="judgment"><b>with</b></a> <em>PrincipalNodeKind</em>
<a href="#jd_test" class="judgment"><b>of</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_test" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></div>
<p>holds when applying the node test <em>NodeTest</em> on <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> in the context of the <em>PrincipalNodeKind</em>
yields <a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub>:</p>
<p><b>Example</b></p>
<p>For example, the following judgments hold.</p>
<div class="exampleInner">
<pre>
  test node()  with element  of    text { "1 2 3" }  =&gt; text { "1 2 3" }
  test size    with element  of    text { "1 2 3" }  =&gt; ()

  test foo:*   with element  of
     (element foo:a of type xs:int { 1 },
      element foo:a of type xs:int { 2 },
      element bar:b of type xs:int { 3 },
      element bar:c of type xs:int { 4 },
      element foo:d of type xs:int { 5 })
  =&gt; (element foo:a of type xs:int { 1 },
      element foo:a of type xs:int { 2 },
      (),
      (),
      element foo:d of type xs:int { 5 })
</pre></div>
<p><b>Note</b></p>
<p>The last example illustrates how a test judgment operates on a
sequence of nodes, applying the test on each node in the sequence
individually, while preserving the structure of the sequence.</p>
<p><b>Semantics</b></p>
<p>This judgment is specified by the following rules.</p>
<p>The first set of rules are similar to those for axes, and are
used to process the test judgment on each individual item in the
input sequence.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test" class=
"judgment"><b>test</b></a> <em>NodeTest</em> <a href="#jd_test"
class="judgment"><b>with</b></a> <em>PrincipalNodeKind</em>
<a href="#jd_test" class="judgment"><b>of</b></a> () <a href=
"#jd_test" class="judgment"><b>=&gt;</b></a> ()</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test" class=
"judgment"><b>test</b></a> <em>NodeTest</em> <a href="#jd_test"
class="judgment"><b>with</b></a> <em>PrincipalNodeKind</em>
<a href="#jd_test" class="judgment"><b>of</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_test" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">3</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test" class=
"judgment"><b>test</b></a> <em>NodeTest</em> <a href="#jd_test"
class="judgment"><b>with</b></a> <em>PrincipalNodeKind</em>
<a href="#jd_test" class="judgment"><b>of</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_test" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">4</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test" class=
"judgment"><b>test</b></a> <em>NodeTest</em> <a href="#jd_test"
class="judgment"><b>with</b></a> <em>PrincipalNodeKind</em>
<a href="#jd_test" class="judgment"><b>of</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>,<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_test" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">3</font></sub>,<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">4</font></sub></td>
</tr>
</table>
<br /></div>
<div class="div5">
<h6><a name="sec_dyn_sem_name_tests" id=
"sec_dyn_sem_name_tests"></a>8.2.3.2.1 Name Tests</h6>
<p>The following rules specify how the value filter judgment is
applied on a name test in the context of a principal node kind.</p>
<p><b>Semantics</b></p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><em>dm:</em><code>node-kind</code>( <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a> ) =
<em>PrincipalNodeKind</em></td>
</tr>
<tr align="center" valign="middle">
<td><code>fn:node-name</code>( <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a> ) = <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_ns_env" class="env">namespace</a>(<em>Prefix</em>) = (<a href=
"#xq_ns_env"><em>NamespaceKind</em></a>,<em>AnyURI</em>)</td>
</tr>
<tr align="center" valign="middle">
<td><code>fn:namespace-uri-from-QName</code>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>) =
<em>AnyURI</em></td>
</tr>
<tr align="center" valign="middle">
<td><code>fn:local-name-from-QName</code>( <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a> ) =
<em>LocalPart</em></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test" class=
"judgment"><b>test</b></a> <em>Prefix</em>:<em>LocalPart</em>
<a href="#jd_test" class="judgment"><b>with</b></a>
<em>PrincipalNodeKind</em> <a href="#jd_test" class=
"judgment"><b>of</b></a> <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a> <a href="#jd_test"
class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><em>dm:</em><code>node-kind</code>( <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a> ) =
<em>PrincipalNodeKind</em></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test" class=
"judgment"><b>test</b></a> <code>*</code> <a href="#jd_test" class=
"judgment"><b>with</b></a> <em>PrincipalNodeKind</em> <a href=
"#jd_test" class="judgment"><b>of</b></a> <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a> <a href="#jd_test"
class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><em>dm:</em><code>node-kind</code>( <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a> ) =
<em>PrincipalNodeKind</em></td>
</tr>
<tr align="center" valign="middle">
<td><code>fn:node-name</code> ( <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a> ) = <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_ns_env" class="env">namespace</a>(<em>Prefix</em>) = (<a href=
"#xq_ns_env"><em>NamespaceKind</em></a>,<em>AnyURI</em>)</td>
</tr>
<tr align="center" valign="middle">
<td><code>fn:namespace-uri-from-QName</code>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>) =
<em>AnyURI</em></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test" class=
"judgment"><b>test</b></a> <em>Prefix</em><code>:*</code> <a href=
"#jd_test" class="judgment"><b>with</b></a>
<em>PrincipalNodeKind</em> <a href="#jd_test" class=
"judgment"><b>of</b></a> <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a> <a href="#jd_test"
class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><em>dm:</em><code>node-kind</code>( <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a> ) =
<em>PrincipalNodeKind</em></td>
</tr>
<tr align="center" valign="middle">
<td><code>fn:node-name</code> ( <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a> ) = <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><code>fn:local-name-from-QName</code> ( <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a> ) =
<em>LocalPart</em></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test" class=
"judgment"><b>test</b></a> <code>*:</code><em>LocalPart</em>
<a href="#jd_test" class="judgment"><b>with</b></a>
<em>PrincipalNodeKind</em> <a href="#jd_test" class=
"judgment"><b>of</b></a> <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a> <a href="#jd_test"
class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a></td>
</tr>
</table>
<br /></div>
</div>
<div class="div5">
<h6><a name="sec_dyn_kind_tests" id=
"sec_dyn_kind_tests"></a>8.2.3.2.2 Kind Tests</h6>
<p>All the rules for evaluating the document, element, and
attribute kind tests are similar. First, the document, element, or
attribute test is normalized to the equivalent document, element,
or attribute type by applying the <font size=
"6">[</font><font size="6">]</font><a href="#jd_map_sequencetype"
class="judgment"><sub><font size="2">sequencetype</font></sub></a>
normalization rule. As explained in <a href=
"#id-sequencetype"><b>[3.5.3 SequenceType Syntax]</b></a>,
SequenceTypes are normalized to XQuery types whenever a dynamic
evaluation or static typing rule requires the corresponding type.
The reason for this deviation from the processing model is that the
result of SequenceType normalization is not part of the
[XPath/XQuery] core syntax.</p>
<p>After normalization of the SequenceType to an XQuery type, the
document, element, or attribute value is simply matched against the
XQuery type. If the value matches the type, then the judgment
yields the value, otherwise the judgment yields the empty
sequence.</p>
<p><b><em>Document kind test</em></b></p>
<p><b>Semantics</b></p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><font size="6">[</font><em>DocumentTest</em><font size=
"6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a> =
<a href="#doc-fs-DocumentType"><em>DocumentType</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-DocumentValue"><em>DocumentValue</em></a> <a href=
"#jd_matches" class="judgment"><b>matches</b></a> <a href=
"#doc-fs-DocumentType"><em>DocumentType</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test" class=
"judgment"><b>test</b></a> <em>DocumentTest</em> <a href="#jd_test"
class="judgment"><b>with</b></a> element <a href="#jd_test" class=
"judgment"><b>of</b></a> <a href=
"#doc-fs-DocumentValue"><em>DocumentValue</em></a> <a href=
"#jd_test" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-DocumentValue"><em>DocumentValue</em></a></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><font size="6">[</font><em>DocumentTest</em><font size=
"6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a> =
<a href="#doc-fs-DocumentType"><em>DocumentType</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_not" class=
"judgment"><b>not</b></a>(<a href=
"#doc-fs-DocumentValue"><em>DocumentValue</em></a> <a href=
"#jd_matches" class="judgment"><b>matches</b></a> <a href=
"#doc-fs-DocumentType"><em>DocumentType</em></a>)</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test" class=
"judgment"><b>test</b></a> <em>DocumentTest</em> <a href="#jd_test"
class="judgment"><b>with</b></a> element <a href="#jd_test" class=
"judgment"><b>of</b></a> <a href=
"#doc-fs-DocumentValue"><em>DocumentValue</em></a> <a href=
"#jd_test" class="judgment"><b>=&gt;</b></a> ()</td>
</tr>
</table>
<br /></div>
<p><b><em>Element kind test</em></b></p>
<p><b>Semantics</b></p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><font size="6">[</font><em>ElementTest</em><font size=
"6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a> =
<a href="#doc-fs-ElementType"><em>ElementType</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-ElementValue"><em>ElementValue</em></a> <a href=
"#jd_matches" class="judgment"><b>matches</b></a> <a href=
"#doc-fs-ElementType"><em>ElementType</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test" class=
"judgment"><b>test</b></a> <em>ElementTest</em> <a href="#jd_test"
class="judgment"><b>with</b></a> element <a href="#jd_test" class=
"judgment"><b>of</b></a> <a href=
"#doc-fs-ElementValue"><em>ElementValue</em></a> <a href="#jd_test"
class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-ElementValue"><em>ElementValue</em></a></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><font size="6">[</font><em>ElementTest</em><font size=
"6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a> =
<a href="#doc-fs-ElementType"><em>ElementType</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_not" class=
"judgment"><b>not</b></a>(<a href=
"#doc-fs-ElementValue"><em>ElementValue</em></a> <a href=
"#jd_matches" class="judgment"><b>matches</b></a> <a href=
"#doc-fs-ElementType"><em>ElementType</em></a>)</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test" class=
"judgment"><b>test</b></a> <em>ElementTest</em> <a href="#jd_test"
class="judgment"><b>with</b></a> element <a href="#jd_test" class=
"judgment"><b>of</b></a> <a href=
"#doc-fs-ElementValue"><em>ElementValue</em></a> <a href="#jd_test"
class="judgment"><b>=&gt;</b></a> ()</td>
</tr>
</table>
<br /></div>
<p><b><em>Attribute kind test</em></b></p>
<p><b>Semantics</b></p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><font size="6">[</font><em>AttributeTest</em><font size=
"6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a> =
<a href="#doc-fs-AttributeType"><em>AttributeType</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-AttributeValue"><em>AttributeValue</em></a> <a href=
"#jd_matches" class="judgment"><b>matches</b></a> <a href=
"#doc-fs-AttributeType"><em>AttributeType</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test" class=
"judgment"><b>test</b></a> <em>AttributeTest</em> <a href=
"#jd_test" class="judgment"><b>with</b></a> attribute <a href=
"#jd_test" class="judgment"><b>of</b></a> <a href=
"#doc-fs-AttributeValue"><em>AttributeValue</em></a> <a href=
"#jd_test" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-AttributeValue"><em>AttributeValue</em></a></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><font size="6">[</font><em>AttributeTest</em><font size=
"6">]</font><a href="#jd_map_sequencetype" class=
"judgment"><sub><font size="2">sequencetype</font></sub></a> =
<a href="#doc-fs-AttributeType"><em>AttributeType</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_not" class=
"judgment"><b>not</b></a>(<a href=
"#doc-fs-AttributeValue"><em>AttributeValue</em></a> <a href=
"#jd_matches" class="judgment"><b>matches</b></a> <a href=
"#doc-fs-AttributeType"><em>AttributeType</em></a>)</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test" class=
"judgment"><b>test</b></a> <em>AttributeTest</em> <a href=
"#jd_test" class="judgment"><b>with</b></a> attribute <a href=
"#jd_test" class="judgment"><b>of</b></a> <a href=
"#doc-fs-AttributeValue"><em>AttributeValue</em></a> <a href=
"#jd_test" class="judgment"><b>=&gt;</b></a> ()</td>
</tr>
</table>
<br /></div>
<p><b><em>Processing instruction, comment, and text kind
tests</em></b></p>
<p><b>Semantics</b></p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><em>dm:</em><code>node-kind</code> ( <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a> ) =
"processing-instruction"</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test" class=
"judgment"><b>test</b></a> <code>processing-instruction()</code>
<a href="#jd_test" class="judgment"><b>with</b></a>
<em>PrincipalNodeKind</em> <a href="#jd_test" class=
"judgment"><b>of</b></a> <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a> <a href="#jd_test"
class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><em>dm:</em><code>node-kind</code> ( <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a> ) =
"processing-instruction"</td>
</tr>
<tr align="center" valign="middle">
<td><code>fn:node-name</code> ( <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a> ) = <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>StringLiteral</em>
<a href="#jd_has_atomic_value" class="judgment"><b>has atomic
value</b></a> <em>String</em></td>
</tr>
<tr align="center" valign="middle">
<td><code>fn:local-name-from-QName</code> ( <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a> ) =
<em>String</em></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test" class=
"judgment"><b>test</b></a> <code>processing-instruction(</code>
<em>StringLiteral</em> <code>)</code> <a href="#jd_test" class=
"judgment"><b>with</b></a> <em>PrincipalNodeKind</em> <a href=
"#jd_test" class="judgment"><b>of</b></a> <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a> <a href="#jd_test"
class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#jd_not" class=
"judgment"><b>not</b></a>(<em>dm:</em><code>node-kind</code> (
<a href="#doc-fs-NodeValue"><em>NodeValue</em></a> ) =
"processing-instruction")</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test" class=
"judgment"><b>test</b></a> <code>processing-instruction()</code>
<a href="#jd_test" class="judgment"><b>with</b></a>
<em>PrincipalNodeKind</em> <a href="#jd_test" class=
"judgment"><b>of</b></a> <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a> <a href="#jd_test"
class="judgment"><b>=&gt;</b></a> ()</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><em>dm:</em><code>node-kind</code> ( <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a> ) = "comment"</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test" class=
"judgment"><b>test</b></a> <code>comment()</code> <a href=
"#jd_test" class="judgment"><b>with</b></a>
<em>PrincipalNodeKind</em> <a href="#jd_test" class=
"judgment"><b>of</b></a> <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a> <a href="#jd_test"
class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#jd_not" class=
"judgment"><b>not</b></a>(<em>dm:</em><code>node-kind</code> (
<a href="#doc-fs-NodeValue"><em>NodeValue</em></a> ) =
"comment")</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test" class=
"judgment"><b>test</b></a> <code>comment()</code> <a href=
"#jd_test" class="judgment"><b>with</b></a>
<em>PrincipalNodeKind</em> <a href="#jd_test" class=
"judgment"><b>of</b></a> <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a> <a href="#jd_test"
class="judgment"><b>=&gt;</b></a> ()</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><em>dm:</em><code>node-kind</code> ( <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a> ) = "text"</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test" class=
"judgment"><b>test</b></a> <code>text()</code> <a href="#jd_test"
class="judgment"><b>with</b></a> <em>PrincipalNodeKind</em>
<a href="#jd_test" class="judgment"><b>of</b></a> <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a> <a href="#jd_test"
class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#jd_not" class=
"judgment"><b>not</b></a>(<em>dm:</em><code>node-kind</code> (
<a href="#doc-fs-NodeValue"><em>NodeValue</em></a> ) = "text")</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test" class=
"judgment"><b>test</b></a> <code>text()</code> <a href="#jd_test"
class="judgment"><b>with</b></a> <em>PrincipalNodeKind</em>
<a href="#jd_test" class="judgment"><b>of</b></a> <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a> <a href="#jd_test"
class="judgment"><b>=&gt;</b></a> ()</td>
</tr>
</table>
<br /></div>
<p>The <code>node()</code> node test is true for all nodes.
Therefore, the following rule does not have any precondition
(remember that an empty upper part in the rule indicates that the
rule is always true).</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test" class=
"judgment"><b>test</b></a> <code>node()</code> <a href="#jd_test"
class="judgment"><b>with</b></a> <em>PrincipalNodeKind</em>
<a href="#jd_test" class="judgment"><b>of</b></a> <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a> <a href="#jd_test"
class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a></td>
</tr>
</table>
<br /></div>
<p>If none of the above rules applies then the node test returns
the empty sequence, and the following dynamic rule is applied:</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><em>Otherwise</em></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b> <a href="#jd_test" class=
"judgment"><b>test</b></a> <em>NodeTest</em> <a href="#jd_test"
class="judgment"><b>with</b></a> <em>PrincipalNodeKind</em>
<a href="#jd_test" class="judgment"><b>of</b></a> <a href=
"#doc-fs-NodeValue"><em>NodeValue</em></a> <a href="#jd_test"
class="judgment"><b>=&gt;</b></a> ()</td>
</tr>
</table>
<br /></div>
</div>
</div>
</div>
</div>
<div class="div2">
<h3><a name="sec_type_matching" id="sec_type_matching"></a>8.3
Judgments for type matching</h3>
<p><b>Introduction</b></p>
<p>XQuery supports type declarations on variable bindings, and
several operations on types (<code>typeswitch</code>,
<code>instance of</code>, etc). This section describes judgments
used for the specification of the semantics of those
operations.</p>
<ul>
<li>
<p>The "match" judgment specifies formally type matching. It takes
as input a value and a type and either succeeds or fails. It is
used in matching parameters against function signatures, type
declarations, and matching values against cases in "typeswitch". An
informal description of type matching is given in <a href=
"http://www.w3.org/TR/xquery#id-sequencetype-matching">Section
2.5.4 SequenceType Matching</a><sup><small>XQ</small></sup>.</p>
</li>
<li>
<p>The "subtyping" judgment takes two types and succeeds if all
values matching the first type also match the second. It is used to
define the static semantics of operations using type matching.</p>
</li>
</ul>
<div class="div3">
<h4><a name="sec_matches" id="sec_matches"></a>8.3.1 Matches</h4>
<p><b>Notation</b></p>
<p id="jd_matches">The judgment</p>
<div align="center"><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Value"><em>Value</em></a> <a href="#jd_matches" class=
"judgment"><b>matches</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></div>
<p>holds when the given value matches the given type.</p>
<p><b>Example</b></p>
<p>For example, assuming the extended XML Schema given in section
<a href="#sec_types_example"><b>[2.4.5 Example of a complete
Schema]</b></a>, then the following judgments hold.</p>
<div class="exampleInner">
<pre>
  element comment of type xsd:string { "This is not important" }
    matches
  element comment of type xsd:string

  (element apt of type fs:anon3 { 2510 },
   element apt of type fs:anon3 { 2511 })
    matches
  element apt+

  ()
    matches
  element usaddress?

  element usaddress of type USAddress {
    element name of type xsd:string { "The Archive" },
    element street of type xsd:string { "Christopher Street" },
    element city of type xsd:string { "New York" },
    element state of type xsd:string { "NY" },
    element zip of type xsd:decimal { 10210 }
  }
    matches
  element usaddress?
</pre></div>
<p><b>Semantics</b></p>
<p>We start by giving the inference rules for matching an item
value with an item type.</p>
<p>An atomic value matches an atomic type if its <a href=
"http://www.w3.org/TR/xquery#dt-type-annotation">type
annotation</a><sup><small>XQ</small></sup> derives from the atomic
type. The value itself is ignored -- this is checked as part of
validation.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">1</font></sub>
<a href="#jd_derives_from" class="judgment"><b>derives from</b></a>
<a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">2</font></sub></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-AtomicValueContent"><em>AtomicValueContent</em></a> of
type <a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">1</font></sub>
<a href="#jd_matches" class="judgment"><b>matches</b></a> <a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">2</font></sub></td>
</tr>
</table>
<br /></div>
<p>A text node matches text.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>text { <em>String</em> }
<a href="#jd_matches" class="judgment"><b>matches</b></a> text</td>
</tr>
</table>
<br /></div>
<p>A comment node matches comment.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>comment { <em>String</em> }
<a href="#jd_matches" class="judgment"><b>matches</b></a>
comment</td>
</tr>
</table>
<br /></div>
<p>A processing-instruction node matches <span>the general
processing-instruction type, and also the particular
processing-instruction type that shares its PITarget.</span></p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>processing-instruction
<em>NCName</em> { <em>String</em> } <a href="#jd_matches" class=
"judgment"><b>matches</b></a> processing-instruction
<span>*</span></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>processing-instruction
<em>NCName</em> { <em>String</em> } <a href="#jd_matches" class=
"judgment"><b>matches</b></a> processing-instruction
<em>NCName</em></td>
</tr>
</table>
<br /></div>
<p>A document node matches a document type if the node's content
matches the document type's corresponding content type.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-Value"><em>Value</em></a> <a href="#jd_matches" class=
"judgment"><b>matches</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>document { <a href=
"#doc-fs-Value"><em>Value</em></a> } <a href="#jd_matches" class=
"judgment"><b>matches</b></a> document { <a href=
"#doc-fs-Type"><em>Type</em></a> }</td>
</tr>
</table>
<br /></div>
<p>The rules for matching an element value with an element type are
more complicated. When an element value is not nilled, the element
matches an element type if the element name and the element type
resolve to some type name, and the element value's <a href=
"http://www.w3.org/TR/xquery#dt-type-annotation">type
annotation</a><sup><small>XQ</small></sup> is derived from the
resolved type name. Note that there is no need to check structural
constraints on the value since those have been checked during XML
Schema validation and the value is assumed to be consistent with
its <a href="http://www.w3.org/TR/xquery#dt-type-annotation">type
annotation</a><sup><small>XQ</small></sup>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-ElementName"><em>ElementName</em></a> <a href="#jd_lookup"
class="judgment"><b>name lookup</b></a> <a href=
"#doc-fs-ElementType"><em>ElementType</em></a> <a href="#jd_lookup"
class="judgment"><b>yields</b></a> <a href=
"#doc-fs-OptNillable"><em>OptNillable</em></a> of type <a href=
"#doc-fs-TypeName"><em>BaseTypeName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-TypeName"><em>TypeName</em></a> <a href="#jd_derives_from"
class="judgment"><b>derives from</b></a> <a href=
"#doc-fs-TypeName"><em>BaseTypeName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_filter" class=
"judgment"><b>filter</b></a> @xsi:nil <a href="#jd_filter" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a> <a href=
"#jd_isin" class="judgment"><b>in</b></a> { (), false }</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>element <a href=
"#doc-fs-ElementName"><em>ElementName</em></a> of type <a href=
"#doc-fs-TypeName"><em>TypeName</em></a> { <a href=
"#doc-fs-Value"><em>Value</em></a> } <a href="#jd_matches" class=
"judgment"><b>matches</b></a> <a href=
"#doc-fs-ElementType"><em>ElementType</em></a></td>
</tr>
</table>
<br /></div>
<p><b>Note</b></p>
<p>Type matching uses the name lookup judgment defined in <a href=
"#sec_element_lookup"><b>[8.1.3 Element and attribute name lookup
(Dynamic)]</b></a>.</p>
<p>In the case the element has been nilled, that is there exists
and xsi:nil attribute set to true in the element value, the
following rule checks that the type is nillable.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-ElementName"><em>ElementName</em></a> <a href="#jd_lookup"
class="judgment"><b>name lookup</b></a> <a href=
"#doc-fs-ElementType"><em>ElementType</em></a> <a href="#jd_lookup"
class="judgment"><b>yields</b></a> nillable of type <a href=
"#doc-fs-TypeName"><em>BaseTypeName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-TypeName"><em>TypeName</em></a> <a href="#jd_derives_from"
class="judgment"><b>derives from</b></a> <a href=
"#doc-fs-TypeName"><em>BaseTypeName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Value"><em>Value</em></a> <a href="#jd_filter"
class="judgment"><b>filter</b></a> @xsi:nil <a href="#jd_filter"
class="judgment"><b>=&gt;</b></a> true</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>element <a href=
"#doc-fs-ElementName"><em>ElementName</em></a> of type <a href=
"#doc-fs-TypeName"><em>TypeName</em></a> { <a href=
"#doc-fs-Value"><em>Value</em></a> } <a href="#jd_matches" class=
"judgment"><b>matches</b></a> <a href=
"#doc-fs-ElementType"><em>ElementType</em></a></td>
</tr>
</table>
<br /></div>
<p>The rule for attributes is similar, but does not require the
check for the xsi:nil attribute.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-AttributeName"><em>AttributeName</em></a> <a href=
"#jd_attribute_lookup" class="judgment"><b>name lookup</b></a>
<a href="#doc-fs-AttributeType"><em>AttributeType</em></a> <a href=
"#jd_attribute_lookup" class="judgment"><b>yields</b></a> of type
<a href="#doc-fs-TypeName"><em>BaseTypeName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-TypeName"><em>TypeName</em></a> <a href="#jd_derives_from"
class="judgment"><b>derives from</b></a> <a href=
"#doc-fs-TypeName"><em>BaseTypeName</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>attribute <a href=
"#doc-fs-AttributeName"><em>AttributeName</em></a> of type <a href=
"#doc-fs-TypeName"><em>TypeName</em></a> { <a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a> } <a href=
"#jd_matches" class="judgment"><b>matches</b></a> <a href=
"#doc-fs-AttributeType"><em>AttributeType</em></a></td>
</tr>
</table>
<br /></div>
<p>A type can also be a sequence of items, in that case the
matching rules also need to check whether the constraints described
by the type as a regular expression hold. This is specified by the
following rules.</p>
<p>The empty sequence matches the empty sequence type.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>() <a href="#jd_matches"
class="judgment"><b>matches</b></a> <code>empty</code></td>
</tr>
</table>
<br /></div>
<p>If two values match two types, then their sequence matches the
corresponding sequence type.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_matches" class=
"judgment"><b>matches</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_matches" class=
"judgment"><b>matches</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>,<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_matches" class=
"judgment"><b>matches</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>,<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
<br /></div>
<p>If a value matches a type, then it also matches a choice type
where that type is one of the choices.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Value"><em>Value</em></a> <a href="#jd_matches" class=
"judgment"><b>matches</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Value"><em>Value</em></a> <a href="#jd_matches" class=
"judgment"><b>matches</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>|<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Value"><em>Value</em></a> <a href="#jd_matches" class=
"judgment"><b>matches</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Value"><em>Value</em></a> <a href="#jd_matches" class=
"judgment"><b>matches</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>|<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
<br /></div>
<p>If two values match two types, then their interleaving matches
the corresponding all group.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_matches" class=
"judgment"><b>matches</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_matches" class=
"judgment"><b>matches</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_interleave" class=
"judgment"><b>interleave</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_interleave" class=
"judgment"><b>yields</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Value"><em>Value</em></a> <a href="#jd_matches" class=
"judgment"><b>matches</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
&amp; <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
<br /></div>
<p>An optional type matches a value of that type or the empty
sequence.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Value"><em>Value</em></a> <a href="#jd_matches" class=
"judgment"><b>matches</b></a> (<a href=
"#doc-fs-Type"><em>Type</em></a> | empty)</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Value"><em>Value</em></a> <a href="#jd_matches" class=
"judgment"><b>matches</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a>?</td>
</tr>
</table>
<br /></div>
<p>The following rules are used to match a value against a sequence
of zero (or one) or more types.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>() <a href="#jd_matches"
class="judgment"><b>matches</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a>*</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_matches" class=
"judgment"><b>matches</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a>&#160;&#160;&#160;&#160;<a href=
"#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_matches" class=
"judgment"><b>matches</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a>*</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>, <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_matches" class=
"judgment"><b>matches</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a>*</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_matches" class=
"judgment"><b>matches</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a>&#160;&#160;&#160;&#160;<a href=
"#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_matches" class=
"judgment"><b>matches</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a>*</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>, <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_matches" class=
"judgment"><b>matches</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a>+</td>
</tr>
</table>
<br /></div>
<p><b>Note</b></p>
<p>The above definition of type matching, although complete and
precise, does not give a simple means to <em>compute</em> type
matching. Notably, some of the above rules can be non-deterministic
(e.g., the rule for matching of choice or repetition).</p>
<p>The structural component of the [XPath/XQuery] type system can
be modeled by regular expressions. Regular expressions can be
implemented by means of finite state automata. Computing type
matching then is equivalent to check if a given sequence of items
is <em>recognized</em> by its corresponding finite state automata.
Finite state automata and their relationships to regular
expressions have been extensively studied and documented in
computer-science literature. The interested reader can consult the
relevant literature, for instance <a href=
"#Languages">[Languages]</a>, or <a href="#TATA">[TATA]</a>.</p>
</div>
<div class="div3">
<h4><a name="sec_subtyping" id="sec_subtyping"></a>8.3.2 Subtyping
(&lt;:)</h4>
<p><b>Introduction</b></p>
<p>This section defines the semantics of subtyping in
[XPath/XQuery]. Subtyping is used during static type analysis, in
typeswitch, treat and assert expressions, and to check the
correctness of function applications.</p>
<p>Note that intuitive relationships between types. For instance,
that (<a href="#doc-fs-Type"><em>Type</em></a>,()) is equivalent to
<a href="#doc-fs-Type"><em>Type</em></a> can be deduced using the
subtyping judgment (and algorithm) described here.</p>
<p><b>Notation</b></p>
<p id="jd_subtype_of">The judgment</p>
<div align="center"><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></div>
<p>holds if the first type is a subtype of the second.</p>
<p><b>Semantics</b></p>
<p>This judgment is true if and only if, for every value <a href=
"#doc-fs-Value"><em>Value</em></a>, if <a href=
"#doc-fs-Value"><em>Value</em></a> <a href="#jd_matches" class=
"judgment"><b>matches</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
holds, then <a href="#doc-fs-Value"><em>Value</em></a> <a href=
"#jd_matches" class="judgment"><b>matches</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
also holds.</p>
<p><b>Note</b></p>
<p>It is easy to see that the subtype relation <a href=
"#jd_subtype_of" class="judgment"><b>&lt;:</b></a> is a partial
order, i.e. it is <b>reflexive</b>:</p>
<a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <a href="#doc-fs-Type"><em>Type</em></a>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a> &#160;&#160;&#160;&#160;
<p>and it is <b>transitive</b>: if,</p>
<a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
&#160;&#160;&#160;&#160;
<p>and,</p>
<a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub>
&#160;&#160;&#160;&#160;
<p>then,</p>
<a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub>
&#160;&#160;&#160;&#160;
<p>Finally, two types are equal if each is a subtype of the other,
that is:</p>
<a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
&#160;&#160;&#160;&#160;
<p>and,</p>
<a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
&#160;&#160;&#160;&#160;
<p>then,</p>
<a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
= <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>
<p><b>Note</b></p>
<p>The above definition, although complete and precise, does not
give a simple means to <em>compute</em> subtyping. Notably the
definition above refers to values, which are not available at
static type checking time.</p>
<p>The structural component of the [XPath/XQuery] type system can
be modeled by regular expressions. Regular expressions can be
implemented by means of finite state automata. Computing subtyping
between two types can then be done by computing if
<em>inclusion</em> holds between their corresponding finite state
automata.</p>
<p>Finite state automata and how to compute operations on those
automata, such as inclusion, emptiness or intersection, have been
extensively studied and documented in the literature. The
interested reader can consult the relevant literature on tree
grammars, for instance <a href="#Languages">[Languages]</a>, or
<a href="#TATA">[TATA]</a>.</p>
</div>
</div>
<div class="div2">
<h3><a name="sec_factor" id="sec_factor"></a>8.4 Judgments for
FLWOR and other expressions on sequences</h3>
<p><b>Introduction</b></p>
<p>Some [XPath/XQuery] operations work on sequences of items. For
instance, [For/FLWOR] expressions iterate over a sequence of items
and the <code>fn:unordered</code> function can return all items in
a sequence in any order, etc.</p>
<p>Static typing for those operations needs to infer a type
acceptable for <em>all</em> the items in the sequence. This
sometimes requires approximating the type known for each item
individually.</p>
<p><b>Example</b></p>
<p>Assume the variable <code>$shipTo</code> is bound to the shipTo
element</p>
<div class="exampleInner">
<pre>
    &lt;shipTo country="US"&gt;
        &lt;name&gt;Alice Smith&lt;/name&gt;
        &lt;street&gt;123 Maple Street&lt;/street&gt;
        &lt;city&gt;Mill Valley&lt;/city&gt;
        &lt;state&gt;CA&lt;/state&gt;
        &lt;zip&gt;90952&lt;/zip&gt;
    &lt;/shipTo&gt;
</pre></div>
<p>and has type</p>
<div class="exampleInner">
<pre>
   element shipTo of type USAddress
</pre></div>
<p>The following query orders all children of the shipTo element by
alphabetical order of their content.</p>
<div class="exampleInner">
<pre>
   for $x in $shipTo/*
   order by $x/text()
   return $x
</pre></div>
<p>resulting in the sequence</p>
<div class="exampleInner">
<pre>
    (&lt;street&gt;123 Maple Street&lt;/street&gt;,
     &lt;zip&gt;90952&lt;/zip&gt;,
     &lt;name&gt;Alice Smith&lt;/name&gt;,
     &lt;state&gt;CA&lt;/state&gt;,
     &lt;city&gt;Mill Valley&lt;/city&gt;)
</pre></div>
<p>This operation iterates over the elements in the input sequence
returned by the expression <code>$shipTo/*</code>, whose type is
the content of a type USAddress.</p>
<div class="exampleInner">
<pre>
    (element name of type xsd:string,
     element street of type xsd:string,
     element city of type xsd:string,
     element state of type xsd:string,
     element zip of type xsd:decimal)
</pre></div>
<p>During static typing, one must give a type to the variable
<code>$x</code> which corresponds to the type of each element in
the sequence. Since each item is of a different type, one must find
an item type which is valid for all cases in the sequence. This can
be done by using a choice for the variable <code>$x</code>, as
follows</p>
<div class="exampleInner">
<pre>
    (element name of type xsd:string |
     element street of type xsd:string |
     element city of type xsd:string |
     element state of type xsd:string |
     element zip of type xsd:decimal)
</pre></div>
<p>This type indicates that the type of the variable can be of any
of the item types in the input sequence.</p>
<p>The static inference also needs to approximate the number of
occurrences of items in the sequence. In this example, there is at
least one item and more than one, so the closest occurrence
indicator is <code>+</code> for one or more items.</p>
<p>The static inference for this example finally results in the
following type.</p>
<div class="exampleInner">
<pre>
    (element name of type xsd:string |
     element street of type xsd:string |
     element city of type xsd:string |
     element state of type xsd:string |
     element zip of type xsd:decimal)+
</pre></div>
<p>[<a name="term-prime-type" id="term-prime-type" title=
"prime type">Definition</a>: A <b><span>prime type</span></b> is a
choice of item types<span>.</span>] This section defines two
functions on types that compute the prime type of an arbitrary
type, and approximate the occurrence of items in an arbitrary type.
These type functions are used in the static semantics of many
expressions, including "for", "some", and "every" expressions, and
many functions, including "fn:unordered" and
<span>"fn:distinct"</span> <span>"fn:distinct-values"</span>.</p>
<p><b>Notation</b></p>
<p>A choice of item types is called a <em>prime type</em>, as
described by the following grammar production.</p>
<h5><a name="d6e64020" id="d6e64020"></a>Prime Types</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-PrimeType" id=
"doc-fs-PrimeType"></a>[<small>44&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-PrimeType">PrimeType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-FormalItemType">FormalItemType</a><br />
| (<a href="#doc-fs-PrimeType">PrimeType</a> "|" <a href=
"#doc-fs-PrimeType">PrimeType</a>)</code></td>
</tr>
</tbody>
</table>
<p><b>Notation</b></p>
<p id="jd_prime">The type function <a href="#jd_prime" class=
"judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a>)
extracts all item types from the type <a href=
"#doc-fs-Type"><em>Type</em></a>, and combines them into a
choice.</p>
<p id="jd_quantifier">The function <a href="#jd_quantifier" class=
"judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a>)
approximates the possible number of items in <a href=
"#doc-fs-Type"><em>Type</em></a> with the occurrence indicators
supported by the [XPath/XQuery] type system (<code>?, +,
*</code>).</p>
<p>For interim results, the auxiliary occurrence indicator
<code>1</code> denotes exactly one occurrence.</p>
<p><b>Semantics</b></p>
<p>The <a href="#jd_prime" class="judgment">prime</a> function is
defined by induction as follows.</p>
<table summary="" class="figure">
<col align="left" span="1" />
<col align="center" span="1" />
<col align="left" span="1" />
<tbody>
<tr>
<td><a href="#jd_prime" class="judgment">prime</a>(<a href=
"#doc-fs-FormalItemType"><em>FormalItemType</em></a>)</td>
<td>&#160;&#160;=&#160;&#160;</td>
<td><a href=
"#doc-fs-FormalItemType"><em>FormalItemType</em></a></td>
</tr>
<tr>
<td><a href="#jd_prime" class=
"judgment">prime</a>(<code>empty</code>)</td>
<td>&#160;&#160;=&#160;&#160;</td>
<td><code>none</code></td>
</tr>
<tr>
<td><a href="#jd_prime" class=
"judgment">prime</a>(<code>none</code>)</td>
<td>&#160;&#160;=&#160;&#160;</td>
<td><code>none</code></td>
</tr>
<tr>
<td><a href="#jd_prime" class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
, <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>)</td>
<td>&#160;&#160;=&#160;&#160;</td>
<td><a href="#jd_prime" class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
| <a href="#jd_prime" class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>)</td>
</tr>
<tr>
<td><a href="#jd_prime" class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
&amp; <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>)</td>
<td>&#160;&#160;=&#160;&#160;</td>
<td><a href="#jd_prime" class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
| <a href="#jd_prime" class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>)</td>
</tr>
<tr>
<td><a href="#jd_prime" class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
| <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>)</td>
<td>&#160;&#160;=&#160;&#160;</td>
<td><a href="#jd_prime" class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
| <a href="#jd_prime" class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>)</td>
</tr>
<tr>
<td><a href="#jd_prime" class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a>?)</td>
<td>&#160;&#160;=&#160;&#160;</td>
<td><a href="#jd_prime" class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a>)</td>
</tr>
<tr>
<td><a href="#jd_prime" class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a>*)</td>
<td>&#160;&#160;=&#160;&#160;</td>
<td><a href="#jd_prime" class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a>)</td>
</tr>
<tr>
<td><a href="#jd_prime" class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a>+)</td>
<td>&#160;&#160;=&#160;&#160;</td>
<td><a href="#jd_prime" class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a>)</td>
</tr>
</tbody>
</table>
<p><b>Semantics</b></p>
<p>The <a href="#jd_quantifier" class="judgment">quantifier</a>
function is defined by induction as follows.</p>
<table summary="" class="figure">
<col align="left" span="1" />
<col align="center" span="1" />
<col align="left" span="1" />
<tbody>
<tr>
<td><a href="#jd_quantifier" class=
"judgment">quantifier</a>(<a href=
"#doc-fs-FormalItemType"><em>FormalItemType</em></a>)</td>
<td>&#160;&#160;=&#160;&#160;</td>
<td>1</td>
</tr>
<tr>
<td><a href="#jd_quantifier" class=
"judgment">quantifier</a>(<code>empty</code>)</td>
<td>&#160;&#160;=&#160;&#160;</td>
<td>?</td>
</tr>
<tr>
<td><a href="#jd_quantifier" class=
"judgment">quantifier</a>(<code>none</code>)</td>
<td>&#160;&#160;=&#160;&#160;</td>
<td>1</td>
</tr>
<tr>
<td><a href="#jd_quantifier" class=
"judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
, <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>)</td>
<td>&#160;&#160;=&#160;&#160;</td>
<td><a href="#jd_quantifier" class=
"judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
, <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>)</td>
</tr>
<tr>
<td><a href="#jd_quantifier" class=
"judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
&amp; <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>)</td>
<td>&#160;&#160;=&#160;&#160;</td>
<td><a href="#jd_quantifier" class=
"judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
, <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>)</td>
</tr>
<tr>
<td><a href="#jd_quantifier" class=
"judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
| <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>)</td>
<td>&#160;&#160;=&#160;&#160;</td>
<td><a href="#jd_quantifier" class=
"judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
| <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>)</td>
</tr>
<tr>
<td><a href="#jd_quantifier" class=
"judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a>?)</td>
<td>&#160;&#160;=&#160;&#160;</td>
<td><a href="#jd_quantifier" class=
"judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a>)
<a href="#jd_quantifier" class="judgment">·</a> ?</td>
</tr>
<tr>
<td><a href="#jd_quantifier" class=
"judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a>*)</td>
<td>&#160;&#160;=&#160;&#160;</td>
<td><a href="#jd_quantifier" class=
"judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a>)
<a href="#jd_quantifier" class="judgment">·</a> *</td>
</tr>
<tr>
<td><a href="#jd_quantifier" class=
"judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a>+)</td>
<td>&#160;&#160;=&#160;&#160;</td>
<td><a href="#jd_quantifier" class=
"judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a>)
<a href="#jd_quantifier" class="judgment">·</a> +</td>
</tr>
</tbody>
</table>
<p>This definition uses the sum
(<em>OccurrenceIndicator</em><sub><font size="2">1</font></sub> ,
<em>OccurrenceIndicator</em><sub><font size="2">2</font></sub>),
the choice (<em>OccurrenceIndicator</em><sub><font size=
"2">1</font></sub> | <em>OccurrenceIndicator</em><sub><font size=
"2">2</font></sub>), and the product
(<em>OccurrenceIndicator</em><sub><font size="2">1</font></sub>
<a href="#jd_quantifier" class="judgment">·</a>
<em>OccurrenceIndicator</em><sub><font size="2">2</font></sub>) of
two occurrence indicators
<em>OccurrenceIndicator</em><sub><font size="2">1</font></sub>,
<em>OccurrenceIndicator</em><sub><font size="2">2</font></sub>,
which are defined by the following tables.</p>
<table summary="" class="figure">
<tbody>
<tr>
<td>
<table summary="" border="1">
<tbody>
<tr>
<td>&#160;,&#160;</td>
<td>&#160;1&#160;</td>
<td>&#160;?&#160;</td>
<td>&#160;+&#160;</td>
<td>&#160;*&#160;</td>
</tr>
<tr>
<td>&#160;1&#160;</td>
<td>&#160;+&#160;</td>
<td>&#160;+&#160;</td>
<td>&#160;+&#160;</td>
<td>&#160;+&#160;</td>
</tr>
<tr>
<td>&#160;?&#160;</td>
<td>&#160;+&#160;</td>
<td>&#160;*&#160;</td>
<td>&#160;+&#160;</td>
<td>&#160;*&#160;</td>
</tr>
<tr>
<td>&#160;+&#160;</td>
<td>&#160;+&#160;</td>
<td>&#160;+&#160;</td>
<td>&#160;+&#160;</td>
<td>&#160;+&#160;</td>
</tr>
<tr>
<td>&#160;*&#160;</td>
<td>&#160;+&#160;</td>
<td>&#160;*&#160;</td>
<td>&#160;+&#160;</td>
<td>&#160;*&#160;</td>
</tr>
</tbody>
</table>
</td>
<td>&#160;&#160;&#160;&#160;</td>
<td>
<table summary="" border="1">
<tbody>
<tr>
<td>&#160;|&#160;</td>
<td>&#160;1&#160;</td>
<td>&#160;?&#160;</td>
<td>&#160;+&#160;</td>
<td>&#160;*&#160;</td>
</tr>
<tr>
<td>&#160;1&#160;</td>
<td>&#160;1&#160;</td>
<td>&#160;?&#160;</td>
<td>&#160;+&#160;</td>
<td>&#160;*&#160;</td>
</tr>
<tr>
<td>&#160;?&#160;</td>
<td>&#160;?&#160;</td>
<td>&#160;?&#160;</td>
<td>&#160;*&#160;</td>
<td>&#160;*&#160;</td>
</tr>
<tr>
<td>&#160;+&#160;</td>
<td>&#160;+&#160;</td>
<td>&#160;*&#160;</td>
<td>&#160;+&#160;</td>
<td>&#160;*&#160;</td>
</tr>
<tr>
<td>&#160;*&#160;</td>
<td>&#160;*&#160;</td>
<td>&#160;*&#160;</td>
<td>&#160;*&#160;</td>
<td>&#160;*&#160;</td>
</tr>
</tbody>
</table>
</td>
<td>&#160;&#160;&#160;&#160;</td>
<td>
<table summary="" border="1">
<tbody>
<tr>
<td>&#160;·&#160;</td>
<td>&#160;1&#160;</td>
<td>&#160;?&#160;</td>
<td>&#160;+&#160;</td>
<td>&#160;*&#160;</td>
</tr>
<tr>
<td>&#160;1&#160;</td>
<td>&#160;1&#160;</td>
<td>&#160;?&#160;</td>
<td>&#160;+&#160;</td>
<td>&#160;*&#160;</td>
</tr>
<tr>
<td>&#160;?&#160;</td>
<td>&#160;?&#160;</td>
<td>&#160;?&#160;</td>
<td>&#160;*&#160;</td>
<td>&#160;*&#160;</td>
</tr>
<tr>
<td>&#160;+&#160;</td>
<td>&#160;+&#160;</td>
<td>&#160;*&#160;</td>
<td>&#160;+&#160;</td>
<td>&#160;*&#160;</td>
</tr>
<tr>
<td>&#160;*&#160;</td>
<td>&#160;*&#160;</td>
<td>&#160;*&#160;</td>
<td>&#160;*&#160;</td>
<td>&#160;*&#160;</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
<p><b>Examples</b></p>
<p>For example, here are the result of applying <a href="#jd_prime"
class="judgment">prime</a> and <a href="#jd_quantifier" class=
"judgment">quantifier</a> on a few simple types.</p>
<div class="exampleInner">
<pre>
  prime(element a+)                         = element a
  prime(element a | empty)                  = element a
  prime(element a?,element b?)              = element a | element b
  prime(element a | element b+, element c*) = element a | element b | element c

  quantifier(element a+)                         = +
  quantifier(element a | empty)                  = ?
  quantifier(element a?,element b?)              = *
  quantifier(element a | element b+, element d*) = +
</pre></div>
<p>Note that the last occurrence indicator should be '+', since the
regular expression is such that there must be at least one element
in the sequence (this element being an 'a' element or a 'b'
element).</p>
<p><b>Note</b></p>
<p>Note that <a href="#jd_prime" class=
"judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a>) ·
<a href="#jd_quantifier" class="judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a>) is always a super type of the
original type <a href="#doc-fs-Type"><em>Type</em></a> I.e.,
<span><a href="#jd_prime" class="judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a>) · <a href="#jd_quantifier" class=
"judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a>)
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></span> <span><a href=
"#doc-fs-Type"><em>Type</em></a> <a href="#jd_subtype_of" class=
"judgment"><b>&lt;:</b></a> <a href="#jd_prime" class=
"judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a>) ·
<a href="#jd_quantifier" class="judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a>)</span> always holds. Therefore,
it is appropriate to used it as an approximation for the type of an
expression. This property is required for the soundness of the
static type analysis.</p>
<p><b>Semantics</b></p>
<p>Finally, a type <a href="#doc-fs-Type"><em>Type</em></a> and an
occurrence indicator can be combined back together to yield a new
type with the · operation, as follows.</p>
<table summary="" class="figure">
<col align="left" span="1" />
<col align="center" span="1" />
<col align="left" span="1" />
<tbody>
<tr>
<td><a href="#doc-fs-Type"><em>Type</em></a> <a href=
"#jd_quantifier" class="judgment">·</a> 1</td>
<td>&#160;&#160;=&#160;&#160;</td>
<td><a href="#doc-fs-Type"><em>Type</em></a></td>
</tr>
<tr>
<td><a href="#doc-fs-Type"><em>Type</em></a> <a href=
"#jd_quantifier" class="judgment">·</a> ?</td>
<td>&#160;&#160;=&#160;&#160;</td>
<td><a href="#doc-fs-Type"><em>Type</em></a>?</td>
</tr>
<tr>
<td><a href="#doc-fs-Type"><em>Type</em></a> <a href=
"#jd_quantifier" class="judgment">·</a> +</td>
<td>&#160;&#160;=&#160;&#160;</td>
<td><a href="#doc-fs-Type"><em>Type</em></a>+</td>
</tr>
<tr>
<td><a href="#doc-fs-Type"><em>Type</em></a> <a href=
"#jd_quantifier" class="judgment">·</a> *</td>
<td>&#160;&#160;=&#160;&#160;</td>
<td><a href="#doc-fs-Type"><em>Type</em></a>*</td>
</tr>
</tbody>
</table>
</div>
<div class="div2">
<h3><a name="sec_promotion_judgments" id=
"sec_promotion_judgments"></a>8.5 Judgments for function calls</h3>
<p><b>Introduction</b></p>
<p>Function calls can perform type promotion between atomic types.
This section introduces judgments which describe type promotion for
the purpose of the dynamic and static semantics. These promotion
rules include promoting <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> to any
other type.</p>
<div class="div3">
<h4><a name="sec_promotion" id="sec_promotion"></a>8.5.1 Type
promotion</h4>
<p><b>Notation</b></p>
<p id="jd_can_be_promoted_to">The judgment</p>
<div align="center"><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_can_be_promoted_to" class="judgment"><b>can be
promoted to</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></div>
<p>holds if type <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
can be promoted to type <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>.</p>
<p><b>Example</b></p>
<p>For example, the following judgments hold:</p>
<div class="exampleInner">
<pre>
  xs:integer  can be promoted to  xs:integer
  xs:decimal  can be promoted to  xs:float
  xs:integer  can be promoted to  xs:float
  xs:float    can be promoted to  xs:double
</pre></div>
<p><b>Semantics</b></p>
<p>This judgment is specified by the following rules.</p>
<p><code>xs:decimal</code> can be promoted to
<code>xs:float</code>:</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <code>xs:decimal</code>
<a href="#jd_can_be_promoted_to" class="judgment"><b>can be
promoted to</b></a> <code>xs:float</code></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p><code>xs:float</code> can be promoted to
<code>xs:double</code>:</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <code>xs:float</code>
<a href="#jd_can_be_promoted_to" class="judgment"><b>can be
promoted to</b></a> <code>xs:double</code></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p><code>xs:anyURI</code> can be promoted to
<code>xs:string</code>:</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <code>xs:anyURI</code>
<a href="#jd_can_be_promoted_to" class="judgment"><b>can be
promoted to</b></a> <code>xs:string</code></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p><a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>
can be promoted to any atomic type:</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-Type"><em>Type</em></a> <a href="#jd_subtype_of" class=
"judgment"><b>&lt;:</b></a> <a href=
"#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> <a href=
"#jd_can_be_promoted_to" class="judgment"><b>can be promoted
to</b></a> <a href="#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>A type can be promoted to itself or to any type of which it is a
subtype:</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-Type"><em>Type</em></a> <a href="#jd_can_be_promoted_to"
class="judgment"><b>can be promoted to</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <a href="#doc-fs-Type"><em>Type</em></a>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-Type"><em>Type</em></a> <a href="#jd_can_be_promoted_to"
class="judgment"><b>can be promoted to</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>Type promotion is transitive:</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_can_be_promoted_to" class="judgment"><b>can be
promoted to</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
&#160;&#160;&#160;&#160;<a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_can_be_promoted_to" class="judgment"><b>can be
promoted to</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">3</font></sub></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_can_be_promoted_to" class="judgment"><b>can be
promoted to</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">3</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>Finally, type promotion distributes over occurrence and union
constructors.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href="#jd_prime" class=
"judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
<a href="#jd_can_be_promoted_to" class="judgment"><b>can be
promoted to</b></a> <a href="#jd_prime" class=
"judgment">prime</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>)
&#160;&#160;&#160;&#160; <a href="#jd_quantifier" class=
"judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
&lt;= <a href="#jd_quantifier" class=
"judgment">quantifier</a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>)</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_can_be_promoted_to" class="judgment"><b>can be
promoted to</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br />
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_can_be_promoted_to" class="judgment"><b>can be
promoted to</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
&#160;&#160;&#160;&#160;<a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_can_be_promoted_to" class="judgment"><b>can be
promoted to</b></a> <a href="#doc-fs-Type"><em>Type</em></a></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> (<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
| <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>) <a href="#jd_can_be_promoted_to" class=
"judgment"><b>can be promoted to</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>where the "&lt;=" operator for occurrence indicators denotes set
inclusion of the subsets of the allowed occurrences.</p>
<p><b>Notation</b></p>
<p id="jd_promotes_to">The judgment</p>
<div align="center"><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_promotes_to" class=
"judgment"><b>against</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_promotes_to" class="judgment"><b>promotes to</b></a>
<a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></div>
<p>holds if value <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> can be promoted to the value <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub> against the type <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub>.</p>
<p><b>Example</b></p>
<p>For example, the following judgments hold</p>
<div class="exampleInner">
<pre>
  1     of type xs:integer  against  xs:integer  promotes to  1     of type xs:integer
  1     of type xs:integer  against  xs:decimal  promotes to  1     of type xs:integer
  1     of type xs:integer  against  xs:float    promotes to  1.0e0 of type xs:float
  1.0e0 of type xs:float    against  xs:double   promotes to  1.0e0 of type xs:double
</pre></div>
<p>Note that type promotion changes the value, and only occurs if
the input value does not match the target type.</p>
<p><b>Semantics</b></p>
<p>This judgment is specified by the following rules.</p>
<p>If the value matches the target type, then it is promoted to
itself</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Value"><em>Value</em></a> <a href="#jd_matches" class=
"judgment"><b>matches</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-Value"><em>Value</em></a> <a href="#jd_promotes_to" class=
"judgment"><b>against</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a> <a href="#jd_promotes_to" class=
"judgment"><b>promotes to</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p>If the value does not match the target type, but is an atomic
value and it matches a type which can be promoted to the target
type, then the value is cast to the target type.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-AtomicValue"><em>AtomicValue</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_matches" class=
"judgment"><b>matches</b></a> <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_can_be_promoted_to" class=
"judgment"><b>can be promoted to</b></a> <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">1</font></sub> != <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href=
"#doc-fs-AtomicValue"><em>AtomicValue</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_cast_value_to" class=
"judgment"><b>cast value to type</b></a> <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_cast_value_to" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-AtomicValue"><em>AtomicValue</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-AtomicValue"><em>AtomicValue</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_promotes_to" class=
"judgment"><b>against</b></a> <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_promotes_to" class=
"judgment"><b>promotes to</b></a> <a href=
"#doc-fs-AtomicValue"><em>AtomicValue</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
</div>
</div>
<div class="div2">
<h3><a name="sec_validation_mode" id="sec_validation_mode"></a>8.6
Judgments for validation modes and contexts</h3>
<div class="div3">
<h4><a name="jd_aux_context_is" id="jd_aux_context_is"></a>8.6.1
Elements in validation mode</h4>
<p><b>Notation</b></p>
<p>A validation mode may occur explicitly in a validate expression
<a href="#sec_validate_expr"><b>[4.13 Validate
Expressions]</b></a>. The following <a href=
"#jd_in_validation_context" class="judgment"><b>with mode</b></a>
judgment resolves an element name within a given validation mode to
the type that the element name denotes. The judgment is used in the
semantics of the validate expression and in sequence type.</p>
<p id="jd_in_validation_context">The judgment</p>
<div align="center"><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-xquery-ElementNameOrWildcard"><em>ElementNameOrWildcard</em></a>
<a href="#jd_in_validation_context" class="judgment"><b>with
mode</b></a> <em>ValidationMode</em> <a href=
"#jd_in_validation_context" class="judgment"><b>resolves to</b></a>
<a href="#doc-fs-Type"><em>Type</em></a></div>
<p>holds when the possibly optional element name resolves to the
given type in the given validation mode.</p>
<p><b>Semantics</b></p>
<p>We start with the rules for the global validation context.</p>
<p>If no element name is present, the global validation context
resolves to the union of all element types that are globally
declared.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-ElementName"><em>ElementName</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_elem_qname_expands_to" class=
"judgment"><b>of elem/type expands to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td>...</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-ElementName"><em>ElementName</em></a><sub><font size=
"2">n</font></sub> <a href="#jd_elem_qname_expands_to" class=
"judgment"><b>of elem/type expands to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size=
"2">n</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_elem_decl" class="env">elemDecl</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size=
"2">1</font></sub>) = define element <a href=
"#doc-fs-ElementName"><em>ElementName</em></a><sub><font size=
"2">1</font></sub> <a href=
"#doc-fs-OptSubstitution"><em>OptSubstitution</em></a><sub><font size="2">1</font></sub>
<a href=
"#doc-fs-OptNillable"><em>OptNillable</em></a><sub><font size=
"2">1</font></sub> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td>...</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_elem_decl" class="env">elemDecl</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size=
"2">n</font></sub>) = define element <a href=
"#doc-fs-ElementName"><em>ElementName</em></a><sub><font size=
"2">n</font></sub> <a href=
"#doc-fs-OptSubstitution"><em>OptSubstitution</em></a><sub><font size="2">n</font></sub>
<a href=
"#doc-fs-OptNillable"><em>OptNillable</em></a><sub><font size=
"2">n</font></sub> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a><sub><font size=
"2">n</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><span>*</span> <a href=
"#jd_in_validation_context" class="judgment"><b>with mode</b></a>
<em>ValidationMode</em> <a href="#jd_in_validation_context" class=
"judgment"><b>resolves to</b></a> (element <a href=
"#doc-fs-ElementName"><em>ElementName</em></a><sub><font size=
"2">1</font></sub> | ... | element <a href=
"#doc-fs-ElementName"><em>ElementName</em></a><sub><font size=
"2">n</font></sub>)</td>
</tr>
</table>
<br /></div>
<p>If the element name is globally declared in the schema, it
resolves to the element type of the corresponding global element
declaration, independently of the validation mode.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-ElementName"><em>ElementName</em></a> <a href=
"#jd_elem_qname_expands_to" class="judgment"><b>of elem/type
expands to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_elem_decl" class="env">elemDecl</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>) = define element
<a href="#doc-fs-ElementName"><em>ElementName</em></a> <a href=
"#doc-fs-OptSubstitution"><em>OptSubstitution</em></a> <a href=
"#doc-fs-OptNillable"><em>OptNillable</em></a> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-ElementName"><em>ElementName</em></a> <a href=
"#jd_in_validation_context" class="judgment"><b>with mode</b></a>
<em>ValidationMode</em> <a href="#jd_in_validation_context" class=
"judgment"><b>resolves to</b></a> element <a href=
"#doc-fs-ElementName"><em>ElementName</em></a></td>
</tr>
</table>
<br /></div>
<p>If an element name is not globally defined and the validation
mode is lax, then the element name resolves to the element type
with the given element name with any content type.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-ElementName"><em>ElementName</em></a> <a href=
"#jd_elem_qname_expands_to" class="judgment"><b>of elem/type
expands to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_elem_decl" class="env">elemDecl</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>) undefined</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-ElementName"><em>ElementName</em></a> <a href=
"#jd_in_validation_context" class="judgment"><b>with mode</b></a>
lax <a href="#jd_in_validation_context" class=
"judgment"><b>resolves to</b></a> element <a href=
"#doc-fs-ElementName"><em>ElementName</em></a> of type
<code>xs:anyType</code></td>
</tr>
</table>
<br /></div>
</div>
</div>
</div>
</div>
<div class="back">
<div class="div1">
<h2><a name="sec_core" id="sec_core"></a>A Normalized core and
formal grammars</h2>
<p>This section contains the set of productions for the of
[XPath/XQuery] grammar after it has been normalized, sometimes
referred to as the "core" grammar, and for the formal grammar
productions.</p>
<div class="div2">
<h3><a name="sec_core_grammar" id="sec_core_grammar"></a>A.1 Core
BNF</h3>
<p>The following grammar uses the same Basic EBNF notation as
<a href="#REC-xml">[XML]</a>, except that grammar symbols always
have initial capital letters. The EBNF contains the lexemes
embedded in the productions.</p>
<h5><a name="d6e66044" id="d6e66044"></a>Named Terminals</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-IntegerLiteral" id=
"prod-xcore-IntegerLiteral"></a>[<small>109</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-IntegerLiteral"></a><a href=
"#doc-xcore-IntegerLiteral">IntegerLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-Digits">Digits</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-DecimalLiteral" id=
"prod-xcore-DecimalLiteral"></a>[<small>110</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-DecimalLiteral"></a><a href=
"#doc-xcore-DecimalLiteral">DecimalLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("." <a href="#prod-xcore-Digits">Digits</a>) | (<a href=
"#prod-xcore-Digits">Digits</a> "." [0-9]*)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-DoubleLiteral" id=
"prod-xcore-DoubleLiteral"></a>[<small>111</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-DoubleLiteral"></a><a href=
"#doc-xcore-DoubleLiteral">DoubleLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(("." <a href="#prod-xcore-Digits">Digits</a>) |
(<a href="#prod-xcore-Digits">Digits</a> ("." [0-9]*)?)) [eE] [+-]?
<a href="#prod-xcore-Digits">Digits</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-StringLiteral" id=
"prod-xcore-StringLiteral"></a>[<small>112</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-StringLiteral"></a><a href=
"#doc-xcore-StringLiteral">StringLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>('"' (<a href="#prod-xcore-EscapeQuot">EscapeQuot</a> |
[^"])* '"') | ("'" (<a href="#prod-xcore-EscapeApos">EscapeApos</a>
| [^'])* "'")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-EscapeQuot" id=
"prod-xcore-EscapeQuot"></a>[<small>113</small>]&#160;&#160;&#160;</td>
<td><code>EscapeQuot</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>'""'</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-EscapeApos" id=
"prod-xcore-EscapeApos"></a>[<small>114</small>]&#160;&#160;&#160;</td>
<td><code>EscapeApos</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"''"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-ElementContentChar" id=
"prod-xcore-ElementContentChar"></a>[<small>115</small>]&#160;&#160;&#160;</td>
<td><code>ElementContentChar</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-Char">Char</a> -
[{}&lt;&amp;]</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-QuotAttrContentChar" id=
"prod-xcore-QuotAttrContentChar"></a>[<small>116</small>]&#160;&#160;&#160;</td>
<td><code>QuotAttrContentChar</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-Char">Char</a> -
["{}&lt;&amp;]</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-AposAttrContentChar" id=
"prod-xcore-AposAttrContentChar"></a>[<small>117</small>]&#160;&#160;&#160;</td>
<td><code>AposAttrContentChar</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-Char">Char</a> -
['{}&lt;&amp;]</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-PITarget" id=
"prod-xcore-PITarget"></a>[<small>118</small>]&#160;&#160;&#160;</td>
<td><code>PITarget</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/REC-xml#NT-PITarget">[http://www.w3.org/TR/REC-xml#NT-PITarget]</a><sup><small>XML</small></sup></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-QName" id=
"prod-xcore-QName"></a>[<small>119</small>]&#160;&#160;&#160;</td>
<td><code>QName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/REC-xml-names/#NT-QName">[http://www.w3.org/TR/REC-xml-names/#NT-QName]</a><sup><small>Names</small></sup></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-NCName" id=
"prod-xcore-NCName"></a>[<small>120</small>]&#160;&#160;&#160;</td>
<td><code>NCName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/REC-xml-names/#NT-NCName">[http://www.w3.org/TR/REC-xml-names/#NT-NCName]</a><sup><small>Names</small></sup></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-S" id=
"prod-xcore-S"></a>[<small>121</small>]&#160;&#160;&#160;</td>
<td><code>S</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/REC-xml#NT-S">[http://www.w3.org/TR/REC-xml#NT-S]</a><sup><small>XML</small></sup></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-Char" id=
"prod-xcore-Char"></a>[<small>122</small>]&#160;&#160;&#160;</td>
<td><code>Char</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/REC-xml#NT-Char">[http://www.w3.org/TR/REC-xml#NT-Char]</a><sup><small>XML</small></sup></code></td>
</tr>
</tbody>
</table>
<h5><a name="BNF-Grammar" id="BNF-Grammar"></a>Non-Terminals</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-ModuleDecl" id=
"prod-xcore-ModuleDecl"></a>[<small>1</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-ModuleDecl"></a><a href=
"#doc-xcore-ModuleDecl">ModuleDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"module" "namespace" <a href=
"#prod-xcore-NCName">NCName</a> "=" <a href=
"#prod-xcore-URILiteral">URILiteral</a> <a href=
"#prod-xcore-Separator">Separator</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-Separator" id=
"prod-xcore-Separator"></a>[<small>2</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-Separator"></a><a href=
"#doc-xcore-Separator">Separator</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>";"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-DefaultCollationDecl" id=
"prod-xcore-DefaultCollationDecl"></a>[<small>3</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-DefaultCollationDecl"></a><a href=
"#doc-xcore-DefaultCollationDecl">DefaultCollationDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "default" "collation" <a href=
"#prod-xcore-URILiteral">URILiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-BaseURIDecl" id=
"prod-xcore-BaseURIDecl"></a>[<small>4</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-BaseURIDecl"></a><a href=
"#doc-xcore-BaseURIDecl">BaseURIDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "base-uri" <a href=
"#prod-xcore-URILiteral">URILiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-ConstructionDecl" id=
"prod-xcore-ConstructionDecl"></a>[<small>5</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-ConstructionDecl"></a><a href=
"#doc-xcore-ConstructionDecl">ConstructionDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "construction" ("strip" |
"preserve")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-OrderingModeDecl" id=
"prod-xcore-OrderingModeDecl"></a>[<small>6</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-OrderingModeDecl"></a><a href=
"#doc-xcore-OrderingModeDecl">OrderingModeDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "ordering" ("ordered" |
"unordered")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-EmptyOrderDecl" id=
"prod-xcore-EmptyOrderDecl"></a>[<small>7</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-EmptyOrderDecl"></a><a href=
"#doc-xcore-EmptyOrderDecl">EmptyOrderDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "default" "order" "empty" ("greatest" |
"least")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-CopyNamespacesDecl" id=
"prod-xcore-CopyNamespacesDecl"></a>[<small>8</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-CopyNamespacesDecl"></a><a href=
"#doc-xcore-CopyNamespacesDecl">CopyNamespacesDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "copy-namespaces" <a href=
"#prod-xcore-PreserveMode">PreserveMode</a> "," <a href=
"#prod-xcore-InheritMode">InheritMode</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-PreserveMode" id=
"prod-xcore-PreserveMode"></a>[<small>9</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-PreserveMode"></a><a href=
"#doc-xcore-PreserveMode">PreserveMode</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"preserve" | "no-preserve"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-InheritMode" id=
"prod-xcore-InheritMode"></a>[<small>10</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-InheritMode"></a><a href=
"#doc-xcore-InheritMode">InheritMode</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"inherit" | "no-inherit"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-SchemaImport" id=
"prod-xcore-SchemaImport"></a>[<small>11</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-SchemaImport"></a><a href=
"#doc-xcore-SchemaImport">SchemaImport</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"import" "schema" <a href=
"#prod-xcore-SchemaPrefix">SchemaPrefix</a>? <a href=
"#prod-xcore-URILiteral">URILiteral</a> ("at" <a href=
"#prod-xcore-URILiteral">URILiteral</a> ("," <a href=
"#prod-xcore-URILiteral">URILiteral</a>)*)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-SchemaPrefix" id=
"prod-xcore-SchemaPrefix"></a>[<small>12</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-SchemaPrefix"></a><a href=
"#doc-xcore-SchemaPrefix">SchemaPrefix</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("namespace" <a href="#prod-xcore-NCName">NCName</a> "=")
| ("default" "element" "namespace")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-ModuleImport" id=
"prod-xcore-ModuleImport"></a>[<small>13</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-ModuleImport"></a><a href=
"#doc-xcore-ModuleImport">ModuleImport</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"import" "module" ("namespace" <a href=
"#prod-xcore-NCName">NCName</a> "=")? <a href=
"#prod-xcore-URILiteral">URILiteral</a> ("at" <a href=
"#prod-xcore-URILiteral">URILiteral</a> ("," <a href=
"#prod-xcore-URILiteral">URILiteral</a>)*)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-NamespaceDecl" id=
"prod-xcore-NamespaceDecl"></a>[<small>14</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-NamespaceDecl"></a><a href=
"#doc-xcore-NamespaceDecl">NamespaceDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "namespace" <a href=
"#prod-xcore-NCName">NCName</a> "=" <a href=
"#prod-xcore-URILiteral">URILiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-DefaultNamespaceDecl" id=
"prod-xcore-DefaultNamespaceDecl"></a>[<small>15</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-DefaultNamespaceDecl"></a><a href=
"#doc-xcore-DefaultNamespaceDecl">DefaultNamespaceDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "default" ("element" | "function") "namespace"
<a href="#prod-xcore-URILiteral">URILiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-VarDecl" id=
"prod-xcore-VarDecl"></a>[<small>16</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-VarDecl"></a><a href=
"#doc-xcore-VarDecl">VarDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "variable" "$" _QName_or_EQName <a href=
"#prod-xcore-TypeDeclaration">TypeDeclaration</a>? ((":=" <a href=
"#prod-xcore-ExprSingle">ExprSingle</a>) | "external")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-FunctionDecl" id=
"prod-xcore-FunctionDecl"></a>[<small>17</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-FunctionDecl"></a><a href=
"#doc-xcore-FunctionDecl">FunctionDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "function" _Function_QName_or_EQName "("
<a href="#prod-xcore-ParamList">ParamList</a>? ")" ("as" <a href=
"#prod-xcore-SequenceType">SequenceType</a>)? (<a href=
"#prod-xcore-EnclosedExpr">EnclosedExpr</a> |
"external")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-ParamList" id=
"prod-xcore-ParamList"></a>[<small>18</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-ParamList"></a><a href=
"#doc-xcore-ParamList">ParamList</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-Param">Param</a> ("," <a href=
"#prod-xcore-Param">Param</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-Param" id=
"prod-xcore-Param"></a>[<small>19</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-Param"></a><a href=
"#doc-xcore-Param">Param</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"$" _QName_or_EQName <a href=
"#prod-xcore-TypeDeclaration">TypeDeclaration</a>?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-EnclosedExpr" id=
"prod-xcore-EnclosedExpr"></a>[<small>20</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-EnclosedExpr"></a><a href=
"#doc-xcore-EnclosedExpr">EnclosedExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"{" <a href="#prod-xcore-Expr">Expr</a> "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-OptionDecl" id=
"prod-xcore-OptionDecl"></a>[<small>21</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-OptionDecl"></a><a href=
"#doc-xcore-OptionDecl">OptionDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "option" _QName_or_EQName <a href=
"#prod-xcore-StringLiteral">StringLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-Expr" id=
"prod-xcore-Expr"></a>[<small>22</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-Expr"></a><a href=
"#doc-xcore-Expr">Expr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-ExprSingle">ExprSingle</a> (","
<a href="#prod-xcore-ExprSingle">ExprSingle</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-ExprSingle" id=
"prod-xcore-ExprSingle"></a>[<small>23</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-ExprSingle"></a><a href=
"#doc-xcore-ExprSingle">ExprSingle</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-FLWORExpr">FLWORExpr</a><br />
| <a href="#prod-xcore-QuantifiedExpr">QuantifiedExpr</a><br />
| <a href="#prod-xcore-TypeswitchExpr">TypeswitchExpr</a><br />
| <a href="#prod-xcore-IfExpr">IfExpr</a><br />
| <a href="#prod-xcore-OrExpr">OrExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-FLWORExpr" id=
"prod-xcore-FLWORExpr"></a>[<small>24</small>]&#160;&#160;&#160;</td>
<td><code>FLWORExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xcore-ForClause">ForClause</a> | <a href=
"#prod-xcore-LetClause">LetClause</a>) "return" <a href=
"#prod-xcore-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-ForClause" id=
"prod-xcore-ForClause"></a>[<small>25</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-ForClause"></a><a href=
"#doc-xcore-ForClause">ForClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"for" ForBinding</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-PositionalVar" id=
"prod-xcore-PositionalVar"></a>[<small>26</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-PositionalVar"></a><a href=
"#doc-xcore-PositionalVar">PositionalVar</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"at" "$" <a href=
"#prod-xcore-VarName">VarName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-LetClause" id=
"prod-xcore-LetClause"></a>[<small>27</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-LetClause"></a><a href=
"#doc-xcore-LetClause">LetClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"let" LetBinding</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-OrderByClause" id=
"prod-xcore-OrderByClause"></a>[<small>28</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-OrderByClause"></a><a href=
"#doc-xcore-OrderByClause">OrderByClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(("order" "by") | ("stable" "order" "by")) <a href=
"#prod-xcore-OrderSpecList">OrderSpecList</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-OrderSpecList" id=
"prod-xcore-OrderSpecList"></a>[<small>29</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-OrderSpecList"></a><a href=
"#doc-xcore-OrderSpecList">OrderSpecList</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-OrderSpec">OrderSpec</a> (","
<a href="#prod-xcore-OrderSpec">OrderSpec</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-OrderSpec" id=
"prod-xcore-OrderSpec"></a>[<small>30</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-OrderSpec"></a><a href=
"#doc-xcore-OrderSpec">OrderSpec</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-ExprSingle">ExprSingle</a> <a href=
"#prod-xcore-OrderModifier">OrderModifier</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-OrderModifier" id=
"prod-xcore-OrderModifier"></a>[<small>31</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-OrderModifier"></a><a href=
"#doc-xcore-OrderModifier">OrderModifier</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("ascending" | "descending")? ("empty" ("greatest" |
"least"))? ("collation" <a href=
"#prod-xcore-URILiteral">URILiteral</a>)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-QuantifiedExpr" id=
"prod-xcore-QuantifiedExpr"></a>[<small>32</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-QuantifiedExpr"></a><a href=
"#doc-xcore-QuantifiedExpr">QuantifiedExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("some" | "every") "$" <a href=
"#prod-xcore-VarName">VarName</a> <a href=
"#prod-xcore-TypeDeclaration">TypeDeclaration</a>? "in" <a href=
"#prod-xcore-ExprSingle">ExprSingle</a> ("," "$" <a href=
"#prod-xcore-VarName">VarName</a> <a href=
"#prod-xcore-TypeDeclaration">TypeDeclaration</a>? "in" <a href=
"#prod-xcore-ExprSingle">ExprSingle</a>)* "satisfies" <a href=
"#prod-xcore-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-TypeswitchExpr" id=
"prod-xcore-TypeswitchExpr"></a>[<small>33</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-TypeswitchExpr"></a><a href=
"#doc-xcore-TypeswitchExpr">TypeswitchExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"typeswitch" "(" <a href="#prod-xcore-Expr">Expr</a> ")"
<a href="#prod-xcore-CaseClause">CaseClause</a>+ "default" "$"
<a href="#prod-xcore-VarName">VarName</a> "return" <a href=
"#prod-xcore-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-CaseClause" id=
"prod-xcore-CaseClause"></a>[<small>34</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-CaseClause"></a><a href=
"#doc-xcore-CaseClause">CaseClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"case" "$" <a href="#prod-xcore-VarName">VarName</a> "as"
<a href="#prod-xcore-SequenceType">SequenceType</a> "return"
<a href="#prod-xcore-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-IfExpr" id=
"prod-xcore-IfExpr"></a>[<small>35</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-IfExpr"></a><a href=
"#doc-xcore-IfExpr">IfExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"if" "(" <a href="#prod-xcore-Expr">Expr</a> ")" "then"
<a href="#prod-xcore-ExprSingle">ExprSingle</a> "else" <a href=
"#prod-xcore-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-OrExpr" id=
"prod-xcore-OrExpr"></a>[<small>36</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-OrExpr"></a><a href=
"#doc-xcore-OrExpr">OrExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-AndExpr">AndExpr</a> ( "or" <a href=
"#prod-xcore-AndExpr">AndExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-AndExpr" id=
"prod-xcore-AndExpr"></a>[<small>37</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-AndExpr"></a><a href=
"#doc-xcore-AndExpr">AndExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-AdditiveExpr">AdditiveExpr</a> (
"and" <a href="#prod-xcore-AdditiveExpr">AdditiveExpr</a>
)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-AdditiveExpr" id=
"prod-xcore-AdditiveExpr"></a>[<small>38</small>]&#160;&#160;&#160;</td>
<td><code>AdditiveExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xcore-MultiplicativeExpr">MultiplicativeExpr</a> ( ("+" |
"-") <a href=
"#prod-xcore-MultiplicativeExpr">MultiplicativeExpr</a>
)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-MultiplicativeExpr" id=
"prod-xcore-MultiplicativeExpr"></a>[<small>39</small>]&#160;&#160;&#160;</td>
<td><code>MultiplicativeExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-CastableExpr">CastableExpr</a> (
("*" | "div" | "idiv" | "mod") <a href=
"#prod-xcore-CastableExpr">CastableExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-CastableExpr" id=
"prod-xcore-CastableExpr"></a>[<small>40</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-CastableExpr"></a><a href=
"#doc-xcore-CastableExpr">CastableExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-CastExpr">CastExpr</a> ( "castable"
"as" <a href="#prod-xcore-SingleType">SingleType</a> )?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-CastExpr" id=
"prod-xcore-CastExpr"></a>[<small>41</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-CastExpr"></a><a href=
"#doc-xcore-CastExpr">CastExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-UnaryExpr">UnaryExpr</a> ( "cast"
"as" <a href="#prod-xcore-SingleType">SingleType</a> )?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-UnaryExpr" id=
"prod-xcore-UnaryExpr"></a>[<small>42</small>]&#160;&#160;&#160;</td>
<td><code>UnaryExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"-"* <a href=
"#prod-xcore-ValueExpr">ValueExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-ValueExpr" id=
"prod-xcore-ValueExpr"></a>[<small>43</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-ValueExpr"></a><a href=
"#doc-xcore-ValueExpr">ValueExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-ValidateExpr">ValidateExpr</a> |
<a href="#prod-xcore-PathExpr">PathExpr</a> | <a href=
"#prod-xcore-StepExpr">StepExpr</a> | <a href=
"#prod-xcore-ExtensionExpr">ExtensionExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-ValidateExpr" id=
"prod-xcore-ValidateExpr"></a>[<small>44</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-ValidateExpr"></a><a href=
"#doc-xcore-ValidateExpr">ValidateExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"validate" <a href=
"#prod-xcore-ValidationMode">ValidationMode</a>? "{" <a href=
"#prod-xcore-Expr">Expr</a> "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-ValidationMode" id=
"prod-xcore-ValidationMode"></a>[<small>45</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-ValidationMode"></a><a href=
"#doc-xcore-ValidationMode">ValidationMode</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"lax" | "strict"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-ExtensionExpr" id=
"prod-xcore-ExtensionExpr"></a>[<small>46</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-ExtensionExpr"></a><a href=
"#doc-xcore-ExtensionExpr">ExtensionExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-Pragma">Pragma</a>+ "{" <a href=
"#prod-xcore-Expr">Expr</a>? "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-Pragma" id=
"prod-xcore-Pragma"></a>[<small>47</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-Pragma"></a><a href=
"#doc-xcore-Pragma">Pragma</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(#" <a href="#prod-xcore-S">S</a>? _QName_or_EQName
(<a href="#prod-xcore-S">S</a> <a href=
"#prod-xcore-PragmaContents">PragmaContents</a>)? "#)"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-PragmaContents" id=
"prod-xcore-PragmaContents"></a>[<small>48</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-PragmaContents"></a><a href=
"#doc-xcore-PragmaContents">PragmaContents</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xcore-Char">Char</a>* - (Char* '#)'
Char*))</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-PathExpr" id=
"prod-xcore-PathExpr"></a>[<small>49</small>]&#160;&#160;&#160;</td>
<td><code>PathExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("/" <a href=
"#prod-xcore-RelativePathExpr">RelativePathExpr</a>?)<br />
| ("//" <a href=
"#prod-xcore-RelativePathExpr">RelativePathExpr</a>)<br />
| <a href=
"#prod-xcore-RelativePathExpr">RelativePathExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-RelativePathExpr" id=
"prod-xcore-RelativePathExpr"></a>[<small>50</small>]&#160;&#160;&#160;</td>
<td><code>RelativePathExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-StepExpr">StepExpr</a> (("/" | "//")
<a href="#prod-xcore-StepExpr">StepExpr</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-StepExpr" id=
"prod-xcore-StepExpr"></a>[<small>51</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-StepExpr"></a><a href=
"#doc-xcore-StepExpr">StepExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-PrimaryExpr">PrimaryExpr</a> |
<a href="#prod-xcore-AxisStep">AxisStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-AxisStep" id=
"prod-xcore-AxisStep"></a>[<small>52</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-AxisStep"></a><a href=
"#doc-xcore-AxisStep">AxisStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xcore-ReverseStep">ReverseStep</a> |
<a href="#prod-xcore-ForwardStep">ForwardStep</a>) <a href=
"#prod-xcore-PredicateList">PredicateList</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-ForwardStep" id=
"prod-xcore-ForwardStep"></a>[<small>53</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-ForwardStep"></a><a href=
"#doc-xcore-ForwardStep">ForwardStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xcore-ForwardAxis">ForwardAxis</a>
<a href="#prod-xcore-NodeTest">NodeTest</a>) | <a href=
"#prod-xcore-AbbrevForwardStep">AbbrevForwardStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-ForwardAxis" id=
"prod-xcore-ForwardAxis"></a>[<small>54</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-ForwardAxis"></a><a href=
"#doc-xcore-ForwardAxis">ForwardAxis</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("child" "::")<br />
| ("descendant" "::")<br />
| ("attribute" "::")<br />
| ("self" "::")<br />
| ("descendant-or-self" "::")<br />
| ("following-sibling" "::")<br />
| ("following" "::")<br />
| ("namespace" "::")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-AbbrevForwardStep" id=
"prod-xcore-AbbrevForwardStep"></a>[<small>55</small>]&#160;&#160;&#160;</td>
<td><code>AbbrevForwardStep</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"@"? <a href=
"#prod-xcore-NodeTest">NodeTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-ReverseStep" id=
"prod-xcore-ReverseStep"></a>[<small>56</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-ReverseStep"></a><a href=
"#doc-xcore-ReverseStep">ReverseStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-ReverseAxis">ReverseAxis</a>
<a href="#prod-xcore-NodeTest">NodeTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-ReverseAxis" id=
"prod-xcore-ReverseAxis"></a>[<small>57</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-ReverseAxis"></a><a href=
"#doc-xcore-ReverseAxis">ReverseAxis</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("parent" "::")<br />
| ("ancestor" "::")<br />
| ("preceding-sibling" "::")<br />
| ("preceding" "::")<br />
| ("ancestor-or-self" "::")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-AbbrevReverseStep" id=
"prod-xcore-AbbrevReverseStep"></a>[<small>58</small>]&#160;&#160;&#160;</td>
<td><code>AbbrevReverseStep</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>".."</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-NodeTest" id=
"prod-xcore-NodeTest"></a>[<small>59</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-NodeTest"></a><a href=
"#doc-xcore-NodeTest">NodeTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-KindTest">KindTest</a> | <a href=
"#prod-xcore-NameTest">NameTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-NameTest" id=
"prod-xcore-NameTest"></a>[<small>60</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-NameTest"></a><a href=
"#doc-xcore-NameTest">NameTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>_QName_or_EQName | <a href=
"#prod-xcore-Wildcard">Wildcard</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-Wildcard" id=
"prod-xcore-Wildcard"></a>[<small>61</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-Wildcard"></a><a href=
"#doc-xcore-Wildcard">Wildcard</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"*"<br />
| (<a href="#prod-xcore-NCName">NCName</a> ":" "*")<br />
| ("*" ":" <a href="#prod-xcore-NCName">NCName</a>)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-PredicateList" id=
"prod-xcore-PredicateList"></a>[<small>62</small>]&#160;&#160;&#160;</td>
<td><code>PredicateList</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xcore-Predicate">Predicate</a>*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-Predicate" id=
"prod-xcore-Predicate"></a>[<small>63</small>]&#160;&#160;&#160;</td>
<td><code>Predicate</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"[" "]"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-PrimaryExpr" id=
"prod-xcore-PrimaryExpr"></a>[<small>64</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-PrimaryExpr"></a><a href=
"#doc-xcore-PrimaryExpr">PrimaryExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-Literal">Literal</a><br />
| <a href="#prod-xcore-VarRef">VarRef</a><br />
| <a href=
"#prod-xcore-ParenthesizedExpr">ParenthesizedExpr</a><br />
| <a href="#prod-xcore-FunctionCall">FunctionCall</a><br />
| <a href="#prod-xcore-OrderedExpr">OrderedExpr</a><br />
| <a href="#prod-xcore-UnorderedExpr">UnorderedExpr</a><br />
| <a href="#prod-xcore-Constructor">Constructor</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-Literal" id=
"prod-xcore-Literal"></a>[<small>65</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-Literal"></a><a href=
"#doc-xcore-Literal">Literal</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-NumericLiteral">NumericLiteral</a> |
<a href="#prod-xcore-StringLiteral">StringLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-NumericLiteral" id=
"prod-xcore-NumericLiteral"></a>[<small>66</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-NumericLiteral"></a><a href=
"#doc-xcore-NumericLiteral">NumericLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-IntegerLiteral">IntegerLiteral</a> |
<a href="#prod-xcore-DecimalLiteral">DecimalLiteral</a> | <a href=
"#prod-xcore-DoubleLiteral">DoubleLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-VarRef" id=
"prod-xcore-VarRef"></a>[<small>67</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-VarRef"></a><a href=
"#doc-xcore-VarRef">VarRef</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"$" <a href="#prod-xcore-VarName">VarName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-VarName" id=
"prod-xcore-VarName"></a>[<small>68</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-VarName"></a><a href=
"#doc-xcore-VarName">VarName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>_QName_or_EQName</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-ParenthesizedExpr" id=
"prod-xcore-ParenthesizedExpr"></a>[<small>69</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-ParenthesizedExpr"></a><a href=
"#doc-xcore-ParenthesizedExpr">ParenthesizedExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(" <a href="#prod-xcore-Expr">Expr</a>? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-ContextItemExpr" id=
"prod-xcore-ContextItemExpr"></a>[<small>70</small>]&#160;&#160;&#160;</td>
<td><code>ContextItemExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"."</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-OrderedExpr" id=
"prod-xcore-OrderedExpr"></a>[<small>71</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-OrderedExpr"></a><a href=
"#doc-xcore-OrderedExpr">OrderedExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"ordered" "{" <a href="#prod-xcore-Expr">Expr</a>
"}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-UnorderedExpr" id=
"prod-xcore-UnorderedExpr"></a>[<small>72</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-UnorderedExpr"></a><a href=
"#doc-xcore-UnorderedExpr">UnorderedExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"unordered" "{" <a href="#prod-xcore-Expr">Expr</a>
"}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-FunctionCall" id=
"prod-xcore-FunctionCall"></a>[<small>73</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-FunctionCall"></a><a href=
"#doc-xcore-FunctionCall">FunctionCall</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>_Function_QName_or_EQName "(" (<a href=
"#prod-xcore-ExprSingle">ExprSingle</a> ("," <a href=
"#prod-xcore-ExprSingle">ExprSingle</a>)*)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-Constructor" id=
"prod-xcore-Constructor"></a>[<small>74</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-Constructor"></a><a href=
"#doc-xcore-Constructor">Constructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xcore-ComputedConstructor">ComputedConstructor</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-ComputedConstructor" id=
"prod-xcore-ComputedConstructor"></a>[<small>75</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-ComputedConstructor"></a><a href=
"#doc-xcore-ComputedConstructor">ComputedConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xcore-CompDocConstructor">CompDocConstructor</a><br />
| <a href=
"#prod-xcore-CompElemConstructor">CompElemConstructor</a><br />
| <a href=
"#prod-xcore-CompAttrConstructor">CompAttrConstructor</a><br />
| <a href=
"#prod-xcore-CompTextConstructor">CompTextConstructor</a><br />
| <a href=
"#prod-xcore-CompCommentConstructor">CompCommentConstructor</a><br />

| <a href=
"#prod-xcore-CompPIConstructor">CompPIConstructor</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-CompDocConstructor" id=
"prod-xcore-CompDocConstructor"></a>[<small>76</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-CompDocConstructor"></a><a href=
"#doc-xcore-CompDocConstructor">CompDocConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"document" "{" <a href="#prod-xcore-Expr">Expr</a>
"}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-CompElemConstructor" id=
"prod-xcore-CompElemConstructor"></a>[<small>77</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-CompElemConstructor"></a><a href=
"#doc-xcore-CompElemConstructor">CompElemConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"element" (_QName_or_EQName | ("{" <a href=
"#prod-xcore-Expr">Expr</a> "}")) "{" <a href=
"#prod-xcore-ContentExpr">ContentExpr</a> "}" "{" <a href=
"#prod-xcore-LocalNamespaceDecls">LocalNamespaceDecls</a>
"}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-LocalNamespaceDecls" id=
"prod-xcore-LocalNamespaceDecls"></a>[<small>78</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-LocalNamespaceDecls"></a><a href=
"#doc-xcore-LocalNamespaceDecls">LocalNamespaceDecls</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xcore-LocalNamespaceDecl">LocalNamespaceDecl</a>*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-LocalNamespaceDecl" id=
"prod-xcore-LocalNamespaceDecl"></a>[<small>79</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-LocalNamespaceDecl"></a><a href=
"#doc-xcore-LocalNamespaceDecl">LocalNamespaceDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"namespace" <a href="#prod-xcore-NCName">NCName</a> "{"
<a href="#prod-xcore-URILiteral">URILiteral</a> "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-ContentExpr" id=
"prod-xcore-ContentExpr"></a>[<small>80</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-ContentExpr"></a><a href=
"#doc-xcore-ContentExpr">ContentExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-Expr">Expr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-CompAttrConstructor" id=
"prod-xcore-CompAttrConstructor"></a>[<small>81</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-CompAttrConstructor"></a><a href=
"#doc-xcore-CompAttrConstructor">CompAttrConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"attribute" (_QName_or_EQName | ("{" <a href=
"#prod-xcore-Expr">Expr</a> "}")) "{" <a href=
"#prod-xcore-Expr">Expr</a> "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-CompTextConstructor" id=
"prod-xcore-CompTextConstructor"></a>[<small>82</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-CompTextConstructor"></a><a href=
"#doc-xcore-CompTextConstructor">CompTextConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"text" "{" <a href="#prod-xcore-Expr">Expr</a>
"}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-CompCommentConstructor" id=
"prod-xcore-CompCommentConstructor"></a>[<small>83</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-CompCommentConstructor"></a><a href=
"#doc-xcore-CompCommentConstructor">CompCommentConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"comment" "{" <a href="#prod-xcore-Expr">Expr</a>
"}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-CompPIConstructor" id=
"prod-xcore-CompPIConstructor"></a>[<small>84</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-CompPIConstructor"></a><a href=
"#doc-xcore-CompPIConstructor">CompPIConstructor</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"processing-instruction" (<a href=
"#prod-xcore-NCName">NCName</a> | ("{" <a href=
"#prod-xcore-Expr">Expr</a> "}")) "{" <a href=
"#prod-xcore-Expr">Expr</a>? "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-SingleType" id=
"prod-xcore-SingleType"></a>[<small>85</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-SingleType"></a><a href=
"#doc-xcore-SingleType">SingleType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-AtomicType">AtomicType</a>
"?"?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-TypeDeclaration" id=
"prod-xcore-TypeDeclaration"></a>[<small>86</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-TypeDeclaration"></a><a href=
"#doc-xcore-TypeDeclaration">TypeDeclaration</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"as" <a href=
"#prod-xcore-SequenceType">SequenceType</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-SequenceType" id=
"prod-xcore-SequenceType"></a>[<small>87</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-SequenceType"></a><a href=
"#doc-xcore-SequenceType">SequenceType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("empty-sequence" "(" ")")<br />
| (<a href="#prod-xcore-ItemType">ItemType</a> <a href=
"#prod-xcore-OccurrenceIndicator">OccurrenceIndicator</a>?)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-OccurrenceIndicator" id=
"prod-xcore-OccurrenceIndicator"></a>[<small>88</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-OccurrenceIndicator"></a><a href=
"#doc-xcore-OccurrenceIndicator">OccurrenceIndicator</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"?" | "*" | "+"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-ItemType" id=
"prod-xcore-ItemType"></a>[<small>89</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-ItemType"></a><a href=
"#doc-xcore-ItemType">ItemType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-KindTest">KindTest</a> | ("item" "("
")") | <a href="#prod-xcore-AtomicType">AtomicType</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-AtomicType" id=
"prod-xcore-AtomicType"></a>[<small>90</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-AtomicType"></a><a href=
"#doc-xcore-AtomicType">AtomicType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>_QName_or_EQName</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-KindTest" id=
"prod-xcore-KindTest"></a>[<small>91</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-KindTest"></a><a href=
"#doc-xcore-KindTest">KindTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-DocumentTest">DocumentTest</a><br />
| <a href="#prod-xcore-ElementTest">ElementTest</a><br />
| <a href="#prod-xcore-AttributeTest">AttributeTest</a><br />
| <a href=
"#prod-xcore-SchemaElementTest">SchemaElementTest</a><br />
| <a href=
"#prod-xcore-SchemaAttributeTest">SchemaAttributeTest</a><br />
| <a href="#prod-xcore-PITest">PITest</a><br />
| <a href="#prod-xcore-CommentTest">CommentTest</a><br />
| <a href="#prod-xcore-TextTest">TextTest</a><br />
| <a href="#prod-xcore-AnyKindTest">AnyKindTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-AnyKindTest" id=
"prod-xcore-AnyKindTest"></a>[<small>92</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-AnyKindTest"></a><a href=
"#doc-xcore-AnyKindTest">AnyKindTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"node" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-DocumentTest" id=
"prod-xcore-DocumentTest"></a>[<small>93</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-DocumentTest"></a><a href=
"#doc-xcore-DocumentTest">DocumentTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"document-node" "(" (<a href=
"#prod-xcore-ElementTest">ElementTest</a> | <a href=
"#prod-xcore-SchemaElementTest">SchemaElementTest</a>)?
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-TextTest" id=
"prod-xcore-TextTest"></a>[<small>94</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-TextTest"></a><a href=
"#doc-xcore-TextTest">TextTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"text" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-CommentTest" id=
"prod-xcore-CommentTest"></a>[<small>95</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-CommentTest"></a><a href=
"#doc-xcore-CommentTest">CommentTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"comment" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-PITest" id=
"prod-xcore-PITest"></a>[<small>96</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-PITest"></a><a href=
"#doc-xcore-PITest">PITest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"processing-instruction" "(" (<a href=
"#prod-xcore-NCName">NCName</a> | <a href=
"#prod-xcore-StringLiteral">StringLiteral</a>)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-AttributeTest" id=
"prod-xcore-AttributeTest"></a>[<small>97</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-AttributeTest"></a><a href=
"#doc-xcore-AttributeTest">AttributeTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"attribute" "(" (<a href=
"#prod-xcore-AttribNameOrWildcard">AttribNameOrWildcard</a> (","
<a href="#prod-xcore-TypeName">TypeName</a>)?)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-AttribNameOrWildcard" id=
"prod-xcore-AttribNameOrWildcard"></a>[<small>98</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-AttribNameOrWildcard"></a><a href=
"#doc-xcore-AttribNameOrWildcard">AttribNameOrWildcard</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-AttributeName">AttributeName</a> |
"*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-SchemaAttributeTest" id=
"prod-xcore-SchemaAttributeTest"></a>[<small>99</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-SchemaAttributeTest"></a><a href=
"#doc-xcore-SchemaAttributeTest">SchemaAttributeTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"schema-attribute" "(" <a href=
"#prod-xcore-AttributeDeclaration">AttributeDeclaration</a>
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-AttributeDeclaration" id=
"prod-xcore-AttributeDeclaration"></a>[<small>100</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-AttributeDeclaration"></a><a href=
"#doc-xcore-AttributeDeclaration">AttributeDeclaration</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xcore-AttributeName">AttributeName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-ElementTest" id=
"prod-xcore-ElementTest"></a>[<small>101</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-ElementTest"></a><a href=
"#doc-xcore-ElementTest">ElementTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"element" "(" (<a href=
"#prod-xcore-ElementNameOrWildcard">ElementNameOrWildcard</a> (","
<a href="#prod-xcore-TypeName">TypeName</a> "?"?)?)?
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-ElementNameOrWildcard" id=
"prod-xcore-ElementNameOrWildcard"></a>[<small>102</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-ElementNameOrWildcard"></a><a href=
"#doc-xcore-ElementNameOrWildcard">ElementNameOrWildcard</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xcore-ElementName">ElementName</a> |
"*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-SchemaElementTest" id=
"prod-xcore-SchemaElementTest"></a>[<small>103</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-SchemaElementTest"></a><a href=
"#doc-xcore-SchemaElementTest">SchemaElementTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"schema-element" "(" <a href=
"#prod-xcore-ElementDeclaration">ElementDeclaration</a>
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-ElementDeclaration" id=
"prod-xcore-ElementDeclaration"></a>[<small>104</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-ElementDeclaration"></a><a href=
"#doc-xcore-ElementDeclaration">ElementDeclaration</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xcore-ElementName">ElementName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-AttributeName" id=
"prod-xcore-AttributeName"></a>[<small>105</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-AttributeName"></a><a href=
"#doc-xcore-AttributeName">AttributeName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>_QName_or_EQName</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-ElementName" id=
"prod-xcore-ElementName"></a>[<small>106</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-ElementName"></a><a href=
"#doc-xcore-ElementName">ElementName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>_QName_or_EQName</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-TypeName" id=
"prod-xcore-TypeName"></a>[<small>107</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-TypeName"></a><a href=
"#doc-xcore-TypeName">TypeName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>_QName_or_EQName</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-URILiteral" id=
"prod-xcore-URILiteral"></a>[<small>108</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-URILiteral"></a><a href=
"#doc-xcore-URILiteral">URILiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xcore-StringLiteral">StringLiteral</a></code></td>
</tr>
</tbody>
</table>
<h5><a name="d6e67311" id="d6e67311"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="prod-xcore-Digits" id=
"prod-xcore-Digits"></a>[<small>123</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xcore-Digits"></a><a href=
"#doc-xcore-Digits">Digits</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>[0-9]+</code></td>
</tr>
</tbody>
</table>
</div>
<div class="div2">
<h3><a name="sec_formal_grammar" id="sec_formal_grammar"></a>A.2
Formal BNF</h3>
<p>The following grammar uses the same Basic EBNF notation as
<a href="#REC-xml">[XML]</a>, except that grammar symbols always
have initial capital letters. The EBNF contains the lexemes
embedded in the productions.</p>
<h5><a name="d6e67325" id="d6e67325"></a>Named Terminals</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-HexDigits" id=
"prod-fs-HexDigits"></a>[<small>96</small>]&#160;&#160;&#160;</td>
<td><code><span class="xquery">HexDigits</span></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>[0-9a-fA-F]+</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-CharRef" id=
"prod-fs-CharRef"></a>[<small>97</small>]&#160;&#160;&#160;</td>
<td><code><span class="xquery">CharRef</span></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"&amp;#" (Digits | ("x" <a href=
"#prod-fs-HexDigits">HexDigits</a>)) ";"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-Char" id=
"prod-fs-Char"></a>[<small>98</small>]&#160;&#160;&#160;</td>
<td><code>Char</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>#x0009#x000D#x000A#x0020-#xFFFD</code></td>
</tr>
</tbody>
</table>
<h5><a name="Formal-BNF-Grammar" id=
"Formal-BNF-Grammar"></a>Non-Terminals</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-AtomicValueContent" id=
"prod-fs-AtomicValueContent"></a>[<small>1</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-AtomicValueContent"></a><a href=
"#doc-fs-AtomicValueContent">AtomicValueContent</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>String<br />
| Boolean<br />
| Decimal<br />
| Float<br />
| Double<br />
| Duration<br />
| DateTime<br />
| Time<br />
| Date<br />
| GYearMonth<br />
| GYear<br />
| GMonthDay<br />
| GDay<br />
| GMonth<br />
| HexBinary<br />
| Base64Binary<br />
| AnyURI<br />
| expanded-QName<br />
| NOTATION</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-TypeAnnotation" id=
"prod-fs-TypeAnnotation"></a>[<small>2</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-TypeAnnotation"></a><a href=
"#doc-fs-TypeAnnotation">TypeAnnotation</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"of" "type" <a href=
"#prod-fs-TypeName">TypeName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-ElementName" id=
"prod-fs-ElementName"></a>[<small>3</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-ElementName"></a><a href=
"#doc-fs-ElementName">ElementName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>QName</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-ElementNameOrWildcard" id=
"prod-fs-ElementNameOrWildcard"></a>[<small>4</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-ElementNameOrWildcard"></a><a href=
"#doc-fs-ElementNameOrWildcard">ElementNameOrWildcard</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>QName | "*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-AttributeNameOrWildcard" id=
"prod-fs-AttributeNameOrWildcard"></a>[<small>5</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-AttributeNameOrWildcard"></a><a href=
"#doc-fs-AttributeNameOrWildcard">AttributeNameOrWildcard</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>QName | "*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-AttributeName" id=
"prod-fs-AttributeName"></a>[<small>6</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-AttributeName"></a><a href=
"#doc-fs-AttributeName">AttributeName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>QName</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-Value" id=
"prod-fs-Value"></a>[<small>7</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-Value"></a><a href=
"#doc-fs-Value">Value</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-Item">Item</a><br />
| (<a href="#prod-fs-Value">Value</a> "," <a href=
"#prod-fs-Value">Value</a>)<br />
| ("(" ")")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-SimpleValue" id=
"prod-fs-SimpleValue"></a>[<small>8</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-SimpleValue"></a><a href=
"#doc-fs-SimpleValue">SimpleValue</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-AtomicValue">AtomicValue</a><br />
| (<a href="#prod-fs-SimpleValue">SimpleValue</a> "," <a href=
"#prod-fs-SimpleValue">SimpleValue</a>)<br />
| ("(" ")")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-ElementValue" id=
"prod-fs-ElementValue"></a>[<small>9</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-ElementValue"></a><a href=
"#doc-fs-ElementValue">ElementValue</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"element" <a href="#prod-fs-ElementName">ElementName</a>
"nilled"? <a href="#prod-fs-TypeAnnotation">TypeAnnotation</a>? "{"
<a href="#prod-fs-Value">Value</a> "}" ("{" <a href=
"#prod-fs-NamespaceBindings">NamespaceBindings</a>
"}")?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-AttributeValue" id=
"prod-fs-AttributeValue"></a>[<small>10</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-AttributeValue"></a><a href=
"#doc-fs-AttributeValue">AttributeValue</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"attribute" <a href=
"#prod-fs-AttributeName">AttributeName</a> <a href=
"#prod-fs-TypeAnnotation">TypeAnnotation</a>? "{" <a href=
"#prod-fs-SimpleValue">SimpleValue</a> "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-DocumentValue" id=
"prod-fs-DocumentValue"></a>[<small>11</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-DocumentValue"></a><a href=
"#doc-fs-DocumentValue">DocumentValue</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"document" "{" <a href="#prod-fs-Value">Value</a>
"}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-TextValue" id=
"prod-fs-TextValue"></a>[<small>12</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-TextValue"></a><a href=
"#doc-fs-TextValue">TextValue</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"text" "{" String "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-CommentValue" id=
"prod-fs-CommentValue"></a>[<small>13</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-CommentValue"></a><a href=
"#doc-fs-CommentValue">CommentValue</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"comment" "{" String "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-ProcessingInstructionValue" id=
"prod-fs-ProcessingInstructionValue"></a>[<small>14</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-ProcessingInstructionValue"></a><a href=
"#doc-fs-ProcessingInstructionValue">ProcessingInstructionValue</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"processing-instruction" NCName "{" String
"}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-NamespaceBindings" id=
"prod-fs-NamespaceBindings"></a>[<small>15</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-NamespaceBindings"></a><a href=
"#doc-fs-NamespaceBindings">NamespaceBindings</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-NamespaceBinding">NamespaceBinding</a>
("," <a href=
"#prod-fs-NamespaceBinding">NamespaceBinding</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-LocationHints" id=
"prod-fs-LocationHints"></a>[<small>16</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-LocationHints"></a><a href=
"#doc-fs-LocationHints">LocationHints</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"at" URILiteral ("," URILiteral)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-NamespaceBinding" id=
"prod-fs-NamespaceBinding"></a>[<small>17</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-NamespaceBinding"></a><a href=
"#doc-fs-NamespaceBinding">NamespaceBinding</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"namespace" NCName "{" AnyURI "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-Prefix" id=
"prod-fs-Prefix"></a>[<small>18</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-Prefix"></a><a href=
"#doc-fs-Prefix">Prefix</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>NCName</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-LocalPart" id=
"prod-fs-LocalPart"></a>[<small>19</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-LocalPart"></a><a href=
"#doc-fs-LocalPart">LocalPart</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>NCName</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-NodeValue" id=
"prod-fs-NodeValue"></a>[<small>20</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-NodeValue"></a><a href=
"#doc-fs-NodeValue">NodeValue</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-ElementValue">ElementValue</a><br />
| <a href="#prod-fs-AttributeValue">AttributeValue</a><br />
| <a href="#prod-fs-DocumentValue">DocumentValue</a><br />
| <a href="#prod-fs-TextValue">TextValue</a><br />
| <a href="#prod-fs-CommentValue">CommentValue</a><br />
| <a href=
"#prod-fs-ProcessingInstructionValue">ProcessingInstructionValue</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-Item" id=
"prod-fs-Item"></a>[<small>21</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-Item"></a><a href=
"#doc-fs-Item">Item</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-NodeValue">NodeValue</a><br />
| <a href="#prod-fs-AtomicValue">AtomicValue</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-AtomicValue" id=
"prod-fs-AtomicValue"></a>[<small>22</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-AtomicValue"></a><a href=
"#doc-fs-AtomicValue">AtomicValue</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-AtomicValueContent">AtomicValueContent</a> <a href=
"#prod-fs-TypeAnnotation">TypeAnnotation</a>?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-TypeName" id=
"prod-fs-TypeName"></a>[<small>23</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-TypeName"></a><a href=
"#doc-fs-TypeName">TypeName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>QName</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-Type" id=
"prod-fs-Type"></a>[<small>24</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-Type"></a><a href=
"#doc-fs-Type">Type</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-FormalItemType">FormalItemType</a><br />
| (<a href="#prod-fs-Type">Type</a> OccurrenceIndicator)<br />
| (<a href="#prod-fs-Type">Type</a> "&amp;" <a href=
"#prod-fs-Type">Type</a>)<br />
| (<a href="#prod-fs-Type">Type</a> "," <a href=
"#prod-fs-Type">Type</a>)<br />
| (<a href="#prod-fs-Type">Type</a> "|" <a href=
"#prod-fs-Type">Type</a>)<br />
| "empty"<br />
| "none"<br />
| ("(" <a href="#prod-fs-Type">Type</a> ")")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-FormalItemType" id=
"prod-fs-FormalItemType"></a>[<small>25</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-FormalItemType"></a><a href=
"#doc-fs-FormalItemType">FormalItemType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-AtomicTypeName">AtomicTypeName</a> |
<a href="#prod-fs-NodeType">NodeType</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-NodeType" id=
"prod-fs-NodeType"></a>[<small>26</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-NodeType"></a><a href=
"#doc-fs-NodeType">NodeType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-DocumentType">DocumentType</a><br />
| <a href="#prod-fs-AttributeType">AttributeType</a><br />
| <a href=
"#prod-fs-ElementContentType">ElementContentType</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-ElementContentType" id=
"prod-fs-ElementContentType"></a>[<small>27</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-ElementContentType"></a><a href=
"#doc-fs-ElementContentType">ElementContentType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-ElementType">ElementType</a><br />
| "comment"<br />
| <a href=
"#prod-fs-ProcessingInstructionType">ProcessingInstructionType</a><br />

| "text"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-AtomicTypeName" id=
"prod-fs-AtomicTypeName"></a>[<small>28</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-AtomicTypeName"></a><a href=
"#doc-fs-AtomicTypeName">AtomicTypeName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-TypeName">TypeName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-ElementType" id=
"prod-fs-ElementType"></a>[<small>29</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-ElementType"></a><a href=
"#doc-fs-ElementType">ElementType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"element" <a href=
"#prod-fs-ElementNameOrWildcard">ElementNameOrWildcard</a> <a href=
"#prod-fs-OptTypeSpecifier">OptTypeSpecifier</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-TypeSpecifier" id=
"prod-fs-TypeSpecifier"></a>[<small>30</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-TypeSpecifier"></a><a href=
"#doc-fs-TypeSpecifier">TypeSpecifier</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-OptNillable">OptNillable</a> <a href=
"#prod-fs-TypeReference">TypeReference</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-AttributeType" id=
"prod-fs-AttributeType"></a>[<small>31</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-AttributeType"></a><a href=
"#doc-fs-AttributeType">AttributeType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"attribute" <a href=
"#prod-fs-AttributeNameOrWildcard">AttributeNameOrWildcard</a>
<a href=
"#prod-fs-OptTypeReference">OptTypeReference</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-Nillable" id=
"prod-fs-Nillable"></a>[<small>32</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-Nillable"></a><a href=
"#doc-fs-Nillable">Nillable</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"nillable"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-TypeDerivation" id=
"prod-fs-TypeDerivation"></a>[<small>33</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-TypeDerivation"></a><a href=
"#doc-fs-TypeDerivation">TypeDerivation</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-ComplexTypeDerivation">ComplexTypeDerivation</a> |
<a href=
"#prod-fs-AtomicTypeDerivation">AtomicTypeDerivation</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-ComplexTypeDerivation" id=
"prod-fs-ComplexTypeDerivation"></a>[<small>34</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-ComplexTypeDerivation"></a><a href=
"#doc-fs-ComplexTypeDerivation">ComplexTypeDerivation</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-OptDerivation">OptDerivation</a>
<a href="#prod-fs-OptMixed">OptMixed</a> "{" <a href=
"#prod-fs-Type">Type</a>? "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-AtomicTypeDerivation" id=
"prod-fs-AtomicTypeDerivation"></a>[<small>35</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-AtomicTypeDerivation"></a><a href=
"#doc-fs-AtomicTypeDerivation">AtomicTypeDerivation</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"restricts" <a href=
"#prod-fs-AtomicTypeName">AtomicTypeName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-TypeReference" id=
"prod-fs-TypeReference"></a>[<small>36</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-TypeReference"></a><a href=
"#doc-fs-TypeReference">TypeReference</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"of" "type" <a href=
"#prod-fs-TypeName">TypeName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-Derivation" id=
"prod-fs-Derivation"></a>[<small>37</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-Derivation"></a><a href=
"#doc-fs-Derivation">Derivation</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("restricts" <a href=
"#prod-fs-TypeName">TypeName</a>)<br />
| ("extends" <a href="#prod-fs-TypeName">TypeName</a>)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-Mixed" id=
"prod-fs-Mixed"></a>[<small>38</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-Mixed"></a><a href=
"#doc-fs-Mixed">Mixed</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"mixed"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-Definition" id=
"prod-fs-Definition"></a>[<small>39</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-Definition"></a><a href=
"#doc-fs-Definition">Definition</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("define" "element" <a href=
"#prod-fs-ElementName">ElementName</a> <a href=
"#prod-fs-OptSubstitution">OptSubstitution</a> <a href=
"#prod-fs-OptNillable">OptNillable</a> <a href=
"#prod-fs-TypeReference">TypeReference</a>)<br />
| ("define" "attribute" <a href=
"#prod-fs-AttributeName">AttributeName</a> <a href=
"#prod-fs-TypeReference">TypeReference</a>)<br />
| ("define" "type" <a href="#prod-fs-TypeName">TypeName</a>
<a href="#prod-fs-TypeDerivation">TypeDerivation</a>)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-Definitions" id=
"prod-fs-Definitions"></a>[<small>40</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-Definitions"></a><a href=
"#doc-fs-Definitions">Definitions</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-fs-Definition">Definition</a> Separator
<a href="#prod-fs-Definitions">Definitions</a>)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-Substitution" id=
"prod-fs-Substitution"></a>[<small>41</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-Substitution"></a><a href=
"#doc-fs-Substitution">Substitution</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"substitutes" "for" <a href=
"#prod-fs-ElementName">ElementName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-AttributeModel" id=
"prod-fs-AttributeModel"></a>[<small>42</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-AttributeModel"></a><a href=
"#doc-fs-AttributeModel">AttributeModel</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-AttributeType">AttributeType</a><br />
| (<a href="#prod-fs-AttributeType">AttributeType</a> "?")<br />
| (<a href="#prod-fs-AttributeModel">AttributeModel</a> "&amp;"
<a href="#prod-fs-AttributeModel">AttributeModel</a>)<br />
| "empty"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-ElementModel" id=
"prod-fs-ElementModel"></a>[<small>43</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-ElementModel"></a><a href=
"#doc-fs-ElementModel">ElementModel</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-ElementType">ElementType</a><br />
| (<a href="#prod-fs-ElementType">ElementType</a> "?")<br />
| (<a href="#prod-fs-ElementModel">ElementModel</a> "&amp;"
<a href="#prod-fs-ElementModel">ElementModel</a>)<br />
| "empty"<br />
| "none"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-PrimeType" id=
"prod-fs-PrimeType"></a>[<small>44</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-PrimeType"></a><a href=
"#doc-fs-PrimeType">PrimeType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-FormalItemType">FormalItemType</a><br />
| (<a href="#prod-fs-PrimeType">PrimeType</a> "|" <a href=
"#prod-fs-PrimeType">PrimeType</a>)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-DocumentType" id=
"prod-fs-DocumentType"></a>[<small>45</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-DocumentType"></a><a href=
"#doc-fs-DocumentType">DocumentType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"document" ("{" <a href="#prod-fs-Type">Type</a>
"}")?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-SPragma" id=
"prod-fs-SPragma"></a>[<small>46</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-SPragma"></a><a href=
"#doc-fs-SPragma">SPragma</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("include" | "import" | "redefine" |
"annotation")*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-Content" id=
"prod-fs-Content"></a>[<small>47</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-Content"></a><a href=
"#doc-fs-Content">Content</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(("simpleType" | "complexType" | "element" | "attribute"
| "attributeGroup" | "group" | "notation")
"annotation"*)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-MixedAttribute" id=
"prod-fs-MixedAttribute"></a>[<small>48</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-MixedAttribute"></a><a href=
"#doc-fs-MixedAttribute">MixedAttribute</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"mixed" "=" Boolean</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-NillableAttribute" id=
"prod-fs-NillableAttribute"></a>[<small>49</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-NillableAttribute"></a><a href=
"#doc-fs-NillableAttribute">NillableAttribute</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"nillable" "=" Boolean</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-substitutionGroupAttribute" id=
"prod-fs-substitutionGroupAttribute"></a>[<small>50</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-substitutionGroupAttribute"></a><a href=
"#doc-fs-substitutionGroupAttribute">substitutionGroupAttribute</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"substitutionGroup" "=" QName</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-maxLength" id=
"prod-fs-maxLength"></a>[<small>51</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-maxLength"></a><a href=
"#doc-fs-maxLength">maxLength</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"maxLength" "=" "nonNegativeInteger"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-minLength" id=
"prod-fs-minLength"></a>[<small>52</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-minLength"></a><a href=
"#doc-fs-minLength">minLength</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"minLength" "=" "nonNegativeInteger"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-length" id=
"prod-fs-length"></a>[<small>53</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-length"></a><a href=
"#doc-fs-length">length</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"length" "=" "nonNegativeInteger"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-maxOccurs" id=
"prod-fs-maxOccurs"></a>[<small>54</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-maxOccurs"></a><a href=
"#doc-fs-maxOccurs">maxOccurs</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"maxOccurs" "=" ("nonNegativeInteger" |
"unbounded")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-minOccurs" id=
"prod-fs-minOccurs"></a>[<small>55</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-minOccurs"></a><a href=
"#doc-fs-minOccurs">minOccurs</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"minOccurs" "=" "nonNegativeInteger"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-OccursAttributes" id=
"prod-fs-OccursAttributes"></a>[<small>56</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-OccursAttributes"></a><a href=
"#doc-fs-OccursAttributes">OccursAttributes</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-maxOccurs">maxOccurs</a> | <a href=
"#prod-fs-minOccurs">minOccurs</a> | <a href=
"#prod-fs-maxLength">maxLength</a> | <a href=
"#prod-fs-minLength">minLength</a> | <a href=
"#prod-fs-length">length</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-ComplexTypeContent" id=
"prod-fs-ComplexTypeContent"></a>[<small>57</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-ComplexTypeContent"></a><a href=
"#doc-fs-ComplexTypeContent">ComplexTypeContent</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"annotation"? ("simpleContent" | "complexContent" |
(<a href="#prod-fs-ChildrenContent">ChildrenContent</a> <a href=
"#prod-fs-AttributeContent">AttributeContent</a>))</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-ChildrenContent" id=
"prod-fs-ChildrenContent"></a>[<small>58</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-ChildrenContent"></a><a href=
"#doc-fs-ChildrenContent">ChildrenContent</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("group" | "all" | "choice" | "sequence")?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-GroupComponent" id=
"prod-fs-GroupComponent"></a>[<small>59</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-GroupComponent"></a><a href=
"#doc-fs-GroupComponent">GroupComponent</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"element" | "group" | "choice" | "sequence" |
"any"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-AttributeContent" id=
"prod-fs-AttributeContent"></a>[<small>60</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-AttributeContent"></a><a href=
"#doc-fs-AttributeContent">AttributeContent</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("attribute" | "attributeGroup")*
"anyAttribute"?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-UseAttribute" id=
"prod-fs-UseAttribute"></a>[<small>61</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-UseAttribute"></a><a href=
"#doc-fs-UseAttribute">UseAttribute</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"use" "=" ("optional" | "prohibited" |
"required")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-DefaultAttribute" id=
"prod-fs-DefaultAttribute"></a>[<small>62</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-DefaultAttribute"></a><a href=
"#doc-fs-DefaultAttribute">DefaultAttribute</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"default" "=" String</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-FixedAttribute" id=
"prod-fs-FixedAttribute"></a>[<small>63</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-FixedAttribute"></a><a href=
"#doc-fs-FixedAttribute">FixedAttribute</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"fixed" "=" String</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-PrincipalNodeKind" id=
"prod-fs-PrincipalNodeKind"></a>[<small>64</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-PrincipalNodeKind"></a><a href=
"#doc-fs-PrincipalNodeKind">PrincipalNodeKind</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"element" | "attribute" | "namespace"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-FormalFLWORClause" id=
"prod-fs-FormalFLWORClause"></a>[<small>65</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-FormalFLWORClause"></a><a href=
"#doc-fs-FormalFLWORClause">FormalFLWORClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>ForClause | LetClause | WhereClause |
OrderByClause</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-FormalReturnClause" id=
"prod-fs-FormalReturnClause"></a>[<small>66</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-FormalReturnClause"></a><a href=
"#doc-fs-FormalReturnClause">FormalReturnClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-FormalFLWORExpr">FormalFLWORExpr</a> |
("return" Expr)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-FormalFLWORExpr" id=
"prod-fs-FormalFLWORExpr"></a>[<small>67</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-FormalFLWORExpr"></a><a href=
"#doc-fs-FormalFLWORExpr">FormalFLWORExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-FormalFLWORClause">FormalFLWORClause</a> <a href=
"#prod-fs-FormalReturnClause">FormalReturnClause</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-FormalCaseClauses" id=
"prod-fs-FormalCaseClauses"></a>[<small>68</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-FormalCaseClauses"></a><a href=
"#doc-fs-FormalCaseClauses">FormalCaseClauses</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-fs-FormalCaseClause">FormalCaseClause</a>
<a href="#prod-fs-FormalCaseClauses">FormalCaseClauses</a>) |
<a href=
"#prod-fs-FormalDefaultCaseClause">FormalDefaultCaseClause</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-FormalCaseClause" id=
"prod-fs-FormalCaseClause"></a>[<small>69</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-FormalCaseClause"></a><a href=
"#doc-fs-FormalCaseClause">FormalCaseClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"case" "$" VarName "as" SequenceType "return"
Expr</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-FormalDefaultCaseClause" id=
"prod-fs-FormalDefaultCaseClause"></a>[<small>70</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-FormalDefaultCaseClause"></a><a href=
"#doc-fs-FormalDefaultCaseClause">FormalDefaultCaseClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"default" "$" VarName "return" Expr</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-PrologDeclList" id=
"prod-fs-PrologDeclList"></a>[<small>71</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-PrologDeclList"></a><a href=
"#doc-fs-PrologDeclList">PrologDeclList</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-fs-PrologDecl">PrologDecl</a> Separator
<a href="#prod-fs-PrologDeclList">PrologDeclList</a>)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-PrologDecl" id=
"prod-fs-PrologDecl"></a>[<small>72</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-PrologDecl"></a><a href=
"#doc-fs-PrologDecl">PrologDecl</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>DefaultCollationDecl<br />
| BaseURIDecl<br />
| ConstructionDecl<br />
| OrderingModeDecl<br />
| EmptyOrderDecl<br />
| CopyNamespacesDecl<br />
| SchemaImport<br />
| ModuleImport<br />
| NamespaceDecl<br />
| DefaultNamespaceDecl<br />
| VarDecl<br />
| FunctionDecl<br />
| OptionDecl</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-OptAtomicType" id=
"prod-fs-OptAtomicType"></a>[<small>73</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-OptAtomicType"></a><a href=
"#doc-fs-OptAtomicType">OptAtomicType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-AtomicTypeName">AtomicTypeName</a> |
(<a href="#prod-fs-AtomicTypeName">AtomicTypeName</a> "?") |
"empty"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-OptMixed" id=
"prod-fs-OptMixed"></a>[<small>74</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-OptMixed"></a><a href=
"#doc-fs-OptMixed">OptMixed</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-Mixed">Mixed</a>?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-OptNillable" id=
"prod-fs-OptNillable"></a>[<small>75</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-OptNillable"></a><a href=
"#doc-fs-OptNillable">OptNillable</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-Nillable">Nillable</a>?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-OptSubstitution" id=
"prod-fs-OptSubstitution"></a>[<small>76</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-OptSubstitution"></a><a href=
"#doc-fs-OptSubstitution">OptSubstitution</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-Substitution">Substitution</a>?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-OptTypeSpecifier" id=
"prod-fs-OptTypeSpecifier"></a>[<small>77</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-OptTypeSpecifier"></a><a href=
"#doc-fs-OptTypeSpecifier">OptTypeSpecifier</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-TypeSpecifier">TypeSpecifier</a>?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-OptTypeReference" id=
"prod-fs-OptTypeReference"></a>[<small>78</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-OptTypeReference"></a><a href=
"#doc-fs-OptTypeReference">OptTypeReference</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-TypeReference">TypeReference</a>?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-OptTypeDeclaration" id=
"prod-fs-OptTypeDeclaration"></a>[<small>79</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-OptTypeDeclaration"></a><a href=
"#doc-fs-OptTypeDeclaration">OptTypeDeclaration</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>TypeDeclaration?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-OptPositionalVar" id=
"prod-fs-OptPositionalVar"></a>[<small>80</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-OptPositionalVar"></a><a href=
"#doc-fs-OptPositionalVar">OptPositionalVar</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>PositionalVar?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-OptVarName" id=
"prod-fs-OptVarName"></a>[<small>81</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-OptVarName"></a><a href=
"#doc-fs-OptVarName">OptVarName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("$" VarName)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-OptLocationHints" id=
"prod-fs-OptLocationHints"></a>[<small>82</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-OptLocationHints"></a><a href=
"#doc-fs-OptLocationHints">OptLocationHints</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-LocationHints">LocationHints</a>?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-ElementContentUnit" id=
"prod-fs-ElementContentUnit"></a>[<small>83</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-ElementContentUnit"></a><a href=
"#doc-fs-ElementContentUnit">ElementContentUnit</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>DirectConstructor | EnclosedExpr | <a href=
"#prod-fs-DirCharsUnit">DirCharsUnit</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-DirCharsUnit" id=
"prod-fs-DirCharsUnit"></a>[<small>84</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-DirCharsUnit"></a><a href=
"#doc-fs-DirCharsUnit">DirCharsUnit</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(CDataSection | PredefinedEntityRef | CharRef | "{{" |
"}}" | ElementContentChar)+</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-FunctionSig" id=
"prod-fs-FunctionSig"></a>[<small>85</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-FunctionSig"></a><a href=
"#doc-fs-FunctionSig">FunctionSig</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"declare" "function" expanded-QName "(" <a href=
"#prod-fs-TypeList">TypeList</a>? ")" "as" <a href=
"#prod-fs-Type">Type</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-TypeList" id=
"prod-fs-TypeList"></a>[<small>86</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-TypeList"></a><a href=
"#doc-fs-TypeList">TypeList</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-Type">Type</a> ("," <a href=
"#prod-fs-Type">Type</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-AttributeContentUnits" id=
"prod-fs-AttributeContentUnits"></a>[<small>87</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-AttributeContentUnits"></a><a href=
"#doc-fs-AttributeContentUnits">AttributeContentUnits</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-AttributeContentUnit">AttributeContentUnit</a>*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-AttributeContentUnit" id=
"prod-fs-AttributeContentUnit"></a>[<small>88</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-AttributeContentUnit"></a><a href=
"#doc-fs-AttributeContentUnit">AttributeContentUnit</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-AttributeCharsUnit">AttributeCharsUnit</a> |
EnclosedExpr</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-ConstructionMode" id=
"prod-fs-ConstructionMode"></a>[<small>89</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-ConstructionMode"></a><a href=
"#doc-fs-ConstructionMode">ConstructionMode</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"preserve" | "strip"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-Axis" id=
"prod-fs-Axis"></a>[<small>90</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-Axis"></a><a href=
"#doc-fs-Axis">Axis</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>ForwardAxis | ReverseAxis</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-AttributeCharsUnit" id=
"prod-fs-AttributeCharsUnit"></a>[<small>91</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-AttributeCharsUnit"></a><a href=
"#doc-fs-AttributeCharsUnit">AttributeCharsUnit</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(QuotAttrContentChar | AposAttrContentChar | EscapeQuot |
EscapeApos | PredefinedEntityRef | CharRef | "{{" |
"}}")+</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-FunctionKey" id=
"prod-fs-FunctionKey"></a>[<small>92</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-FunctionKey"></a><a href=
"#doc-fs-FunctionKey">FunctionKey</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>expanded-QName "," Arity</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-ProcessingInstructionType" id=
"prod-fs-ProcessingInstructionType"></a>[<small>93</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-ProcessingInstructionType"></a><a href=
"#doc-fs-ProcessingInstructionType">ProcessingInstructionType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"processing-instruction" <a href=
"#prod-fs-PITargetOrWildcard">PITargetOrWildcard</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-PITargetOrWildcard" id=
"prod-fs-PITargetOrWildcard"></a>[<small>94</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-PITargetOrWildcard"></a><a href=
"#doc-fs-PITargetOrWildcard">PITargetOrWildcard</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>NCName | "*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-fs-OptDerivation" id=
"prod-fs-OptDerivation"></a>[<small>95</small>]&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-OptDerivation"></a><a href=
"#doc-fs-OptDerivation">OptDerivation</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-Derivation">Derivation</a>?</code></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="div1">
<h2><a name="sec_indexes" id="sec_indexes"></a>B Index of
judgments</h2>
<p>Here is the list of the judgments defined in this
specification.</p>
<p>Main judgments:</p>
<ul>
<li>
<p><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>Expr</em> <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></p>
</li>
<li>
<p><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>Expr</em> <a href=
"#jd_has_type_extension" class="judgment"><b>:</b><sub><font size=
"2">ext</font></sub></a> <a href=
"#doc-fs-Type"><em>Type</em></a></p>
</li>
<li>
<p><a href="#xq_stat_env_def" class="env">statEnv</a>; <a href=
"#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>Expr</em> <a href=
"#jd_yields" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></p>
</li>
</ul>
<p>Auxiliary judgments:</p>
<ul>
<li>
<p><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></p>
</li>
<li>
<p><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>(<em>AnyURI</em> | #MAIN)
<a href="#jd_module_statEnv" class=
"judgment"><b>=&gt;</b><sub><font size=
"2">module_statEnv</font></sub></a> <a href="#xq_stat_env_def"
class="env">statEnv</a></p>
</li>
<li>
<p><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>(<em>AnyURI</em> | #MAIN)
<a href="#jd_module_dynEnv" class=
"judgment"><b>=&gt;</b><sub><font size=
"2">module_dynEnv</font></sub></a> <a href="#xq_dyn_env_def" class=
"env">dynEnv</a></p>
</li>
<li>
<p><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size=
"2">1</font></sub><b>&#160;|-&#160;</b><em>PrologDeclList</em>
<a href="#jd_yields_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">2</font></sub> <a href="#jd_yields_context" class=
"judgment"><b>with</b></a> <em>PrologDeclList</em><sub><font size=
"2">1</font></sub></p>
</li>
<li>
<p><a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size=
"2">1</font></sub><b>&#160;|-&#160;</b><em>PrologDeclList</em>
<a href="#jd_yields_dyn_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a>
<a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size=
"2">2</font></sub></p>
</li>
<li>
<p><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size=
"2">1</font></sub><b>&#160;|-&#160;</b><em>Definitions</em>
<a href="#jd_yields_type_context" class=
"judgment"><b>=&gt;</b><sub><font size="2">type</font></sub></a>
<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size=
"2">2</font></sub></p>
</li>
<li>
<p><a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size=
"2">1</font></sub> ; <em>AnyURI</em><b>&#160;|-&#160;</b>
<span>(<em>FunctionKey</em><sub><font size=
"2">1</font></sub>,<em>FunctionSig</em><sub><font size=
"2">1</font></sub>) ... (<em>FunctionKey</em><sub><font size=
"2">n</font></sub>,<em>FunctionSig</em><sub><font size=
"2">n</font></sub>)</span> <a href="#jd_import_functions" class=
"judgment"><b>=&gt;</b><sub><font size=
"2">import_functions</font></sub></a> <a href="#xq_dyn_env_def"
class="env">dynEnv</a><sub><font size="2">2</font></sub></p>
</li>
<li>
<p><a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size=
"2">1</font></sub> ; <em>AnyURI</em><b>&#160;|-&#160;</b>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size=
"2">1</font></sub>, <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>), ···, (<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size=
"2">n</font></sub>, <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>)
<a href="#jd_import_variables" class=
"judgment"><b>=&gt;</b><sub><font size=
"2">import_variables</font></sub></a> <a href="#xq_dyn_env_def"
class="env">dynEnv</a><sub><font size="2">2</font></sub></p>
</li>
<li>
<p><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-OptMixed"><em>OptMixed</em></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_adjusts_to" class="judgment"><b>adjusts to</b></a>
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></p>
</li>
<li>
<p><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_promotes_to" class=
"judgment"><b>against</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_promotes_to" class="judgment"><b>promotes to</b></a>
<a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></p>
</li>
<li>
<p><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_against" class=
"judgment"><b>against</b></a> <em>FormalCaseClauses</em> <a href=
"#jd_against" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></p>
</li>
<li>
<p><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_annotate_as"
class="judgment"><b>annotate as</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a> ( <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> ) <a href="#jd_annotate_as" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></p>
</li>
<li>
<p><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_axis_type"
class="judgment"><b>axis</b></a> <em>Axis</em> <a href=
"#jd_axis_type" class="judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_axis_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></p>
</li>
<li>
<p><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><a href="#jd_axis" class=
"judgment"><b>axis</b></a> <em>Axis</em> <a href="#jd_axis" class=
"judgment"><b>of</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_axis" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></p>
</li>
<li>
<p><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_type_case" class="judgment"><b>case</b></a>
<em>FormalCaseClause</em> <a href="#jd_type_case" class=
"judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></p>
</li>
<li>
<p><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Value"><em>Value</em></a> <a href="#jd_can_be_cast_to"
class="judgment"><b>can be cast to</b></a> <em>SingleType</em></p>
</li>
<li>
<p><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_can_be_promoted_to" class="judgment"><b>can be
promoted to</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></p>
</li>
<li>
<p><a href=
"#doc-fs-AtomicValue"><em>AtomicValue</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_cast_value_to" class=
"judgment"><b>cast value to type</b></a> <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a> <a href=
"#jd_cast_value_to" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-AtomicValue"><em>AtomicValue</em></a><sub><font size=
"2">2</font></sub></p>
</li>
<li>
<p><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_data" class=
"judgment"><b>data on</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></p>
</li>
<li>
<p><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#id-expanded-qnames"><em>expanded-QName</em></a> <a href=
"#jd_denotes_a_constructor_function" class="judgment"><b>denotes a
constructor function</b></a></p>
</li>
<li>
<p><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_erases_to" class=
"judgment"><b>erases to</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></p>
</li>
<li>
<p><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a> <a href=
"#jd_expands_to" class="judgment"><b>expands to</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></p>
</li>
<li>
<p><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_extended_by" class="judgment"><b>extended by</b></a>
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_extended_by" class=
"judgment"><b>is</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></p>
</li>
<li>
<p><a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size=
"2">1</font></sub> <a href="#jd_extended_with_dynamic_environment"
class="judgment"><b>extended with dynamic environment</b></a>
<a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size=
"2">2</font></sub> <a href="#jd_extended_with_dynamic_environment"
class="judgment"><b>yields</b></a> <a href="#xq_dyn_env_def" class=
"env">dynEnv</a><sub><font size="2">3</font></sub> <a href=
"#jd_extended_with_dynamic_environment" class="judgment"><b>for
uri</b></a> <em>AnyURI</em></p>
</li>
<li>
<p><a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">1</font></sub> <a href=
"#jd_extended_with_static_environment" class="judgment"><b>extended
with static environment</b></a> <a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">2</font></sub> <a href=
"#jd_extended_with_static_environment" class=
"judgment"><b>yields</b></a> <a href="#xq_stat_env_def" class=
"env">statEnv</a><sub><font size="2">3</font></sub> <a href=
"#jd_extended_with_static_environment" class="judgment"><b>for
uri</b></a> <em>AnyURI</em></p>
</li>
<li>
<p><a href="#doc-fs-Value"><em>Value</em></a> <a href="#jd_filter"
class="judgment"><b>filter</b></a> @<em>QName</em> <a href=
"#jd_filter" class="judgment"><b>=&gt;</b></a> <a href="#jd_filter"
class="judgment"><b>absent</b></a></p>
</li>
<li>
<p><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#jd_function_declaration" class="judgment"><b>function
declaration</b></a> <em>FunctionDecl</em> <a href=
"#jd_function_declaration" class="judgment"><b>with
signature</b></a> <em>FunctionSig</em> <a href=
"#jd_function_declaration" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">r</font></sub></p>
</li>
<li>
<p><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><a href=
"#jd_function_with_types" class="judgment"><b>function</b></a>
<a href="#id-expanded-qnames"><em>expanded-QName</em></a> <a href=
"#jd_function_with_types" class="judgment"><b>with types</b></a>
(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>,...,<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>)
<a href="#jd_function_with_types" class="judgment"><b>on
values</b></a> (<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>,...,<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">n</font></sub>) <a href="#jd_function_with_types" class=
"judgment"><b>yields</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></p>
</li>
<li>
<p><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><em>LiteralExpr</em> <a href=
"#jd_has_atomic_value" class="judgment"><b>has atomic value</b></a>
<a href="#doc-fs-AtomicValue"><em>AtomicValue</em></a></p>
</li>
<li>
<p><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_has_attribute_content" class="judgment"><b>has
attribute content</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></p>
</li>
<li>
<p><a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">1</font></sub>
<a href="#jd_has_base_atomic_type" class="judgment"><b>has base
atomic type</b></a> <a href=
"#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">2</font></sub></p>
</li>
<li>
<p><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_has_element_content" class="judgment"><b>has node
content</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></p>
</li>
<li>
<p><em>Axis</em> <a href="#jd_principal" class="judgment"><b>has
principal</b></a> <em>PrincipalNodeKind</em></p>
</li>
<li>
<p><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_interleave" class=
"judgment"><b>interleave</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_interleave" class=
"judgment"><b>yields</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">3</font></sub></p>
</li>
<li>
<p><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_union_interpretation" class="judgment"><b>is</b></a>
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_union_interpretation" class=
"judgment"><b>extended with union interpretation of</b></a>
<a href="#doc-fs-TypeName"><em>TypeName</em></a></p>
</li>
<li>
<p><em>AnyURI</em> <a href="#jd_is_target_namespace_of_modules"
class="judgment"><b>is target namespace of modules</b></a>
<em>Module</em><sub><font size="2">1</font></sub> ...
<em>Module</em><sub><font size="2">n</font></sub></p>
</li>
<li>
<p><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Value"><em>Value</em></a> <a href="#jd_matches" class=
"judgment"><b>matches</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a></p>
</li>
<li>
<p><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_mixes_to" class="judgment"><b>mixes to</b></a>
<a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></p>
</li>
<li>
<p><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-ElementName"><em>ElementName</em></a> <a href="#jd_lookup"
class="judgment"><b>name lookup</b></a> <a href=
"#doc-fs-ElementType"><em>ElementType</em></a> <a href="#jd_lookup"
class="judgment"><b>yields</b></a> <a href=
"#doc-fs-OptNillable"><em>OptNillable</em></a> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a></p>
</li>
<li>
<p><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-AttributeName"><em>AttributeName</em></a> <a href=
"#jd_attribute_lookup" class="judgment"><b>name lookup</b></a>
<a href="#doc-fs-AttributeType"><em>AttributeType</em></a> <a href=
"#jd_attribute_lookup" class="judgment"><b>yields</b></a> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a></p>
</li>
<li>
<p><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_nil_annotate_as"
class="judgment"><b>nil-annotate as</b></a> <a href=
"#doc-fs-Nillable"><em>Nillable</em></a>? <a href=
"#doc-fs-Type"><em>Type</em></a> ( <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> ) <a href="#jd_nil_annotate_as" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></p>
</li>
<li>
<p><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>QName</em> <a href=
"#jd_attr_qname_expands_to" class="judgment"><b>of attr expands
to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></p>
</li>
<li>
<p><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>QName</em> <a href=
"#jd_elem_qname_expands_to" class="judgment"><b>of elem/type
expands to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></p>
</li>
<li>
<p><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>QName</em> <a href=
"#jd_func_qname_expands_to" class="judgment"><b>of func expands
to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></p>
</li>
<li>
<p><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>QName</em> <a href=
"#jd_var_qname_expands_to" class="judgment"><b>of var expands
to</b></a> <em>Variable</em></p>
</li>
<li>
<p><a href="#id-expanded-qnames"><em>expanded-QName</em></a>
<a href="#jd_operator_type_for" class="judgment"><b>operator type
for</b></a> <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_operator_type_for" class=
"judgment"><b>and</b></a> <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_operator_type_for" class=
"judgment"><b>is</b></a> <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">3</font></sub></p>
</li>
<li>
<p><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a> <a href=
"#jd_resolves_to" class="judgment"><b>resolves to</b></a> <a href=
"#doc-fs-TypeName"><em>TypeName</em></a> { <a href=
"#doc-fs-Type"><em>Type</em></a> }</p>
</li>
<li>
<p><a href="#jd_sacfsw" class="judgment"><b>second argument
contribution for sum with</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_sacfsw" class="judgment"><b>and</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
<a href="#jd_sacfsw" class="judgment"><b>is</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">3</font></sub></p>
</li>
<li>
<p><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_cast_as" class=
"judgment"><b>simply annotate as</b></a> <em>SimpleType</em> (
<a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a> ) <a href=
"#jd_cast_as" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size=
"2">2</font></sub></p>
</li>
<li>
<p><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a> <a href=
"#jd_simply_erases_to" class="judgment"><b>simply erases to</b></a>
<em>String</em></p>
</li>
<li>
<p><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-ElementName"><em>ElementName</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_substitutes_for" class=
"judgment"><b>substitutes for</b></a> <a href=
"#doc-fs-ElementName"><em>ElementName</em></a><sub><font size=
"2">2</font></sub></p>
</li>
<li>
<p><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-AttributeType"><em>AttributeType</em></a> <a href=
"#jd_attribute_static_lookup" class="judgment"><b>type
lookup</b></a> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a></p>
</li>
<li>
<p><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-ElementType"><em>ElementType</em></a> <a href=
"#jd_static_lookup" class="judgment"><b>type lookup</b></a>
<a href="#doc-fs-OptNillable"><em>OptNillable</em></a> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a></p>
</li>
<li>
<p><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_test_type"
class="judgment"><b>test</b></a> <em>NodeTest</em> <a href=
"#jd_test_type" class="judgment"><b>with</b></a>
<em>PrincipalNodeKind</em> <a href="#jd_test_type" class=
"judgment"><b>of</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
<a href="#jd_test_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub></p>
</li>
<li>
<p><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><a href="#jd_test" class=
"judgment"><b>test</b></a> <em>NodeTest</em> <a href="#jd_test"
class="judgment"><b>with</b></a> <em>PrincipalNodeKind</em>
<a href="#jd_test" class="judgment"><b>of</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_test" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></p>
</li>
<li>
<p><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-xquery-ElementNameOrWildcard"><em>ElementNameOrWildcard</em></a>
<a href="#jd_in_validation_context" class="judgment"><b>with
mode</b></a> <em>ValidationMode</em> <a href=
"#jd_in_validation_context" class="judgment"><b>resolves to</b></a>
<a href="#doc-fs-Type"><em>Type</em></a></p>
</li>
<li>
<p><a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">0</font></sub> <a href="#jd_with_text_nodes_processed_is"
class="judgment"><b>with text nodes processed is</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub></p>
</li>
</ul>
</div>
<div class="div1">
<h2><a name="sec_functions_and_operators" id=
"sec_functions_and_operators"></a>C Functions and Operators</h2>
<div class="div2">
<h3><a name="sec_used_functions" id="sec_used_functions"></a>C.1
Functions and Operators used in the Formal Semantics</h3>
<p>Here is the list of functions from the <a href=
"#xpath-functions-11">[Functions and Operators 1.1]</a> document
that are used in the [XPath/XQuery] Formal Semantics:</p>
<ul>
<li>
<p id="func-add-dayTimeDurations"><a href=
"http://www.w3.org/TR/xpath-functions/#func-add-dayTimeDurations">Section
10.6.6 op:add-dayTimeDurations</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-add-dayTimeDuration-to-dateTime"><a href=
"http://www.w3.org/TR/xpath-functions/#func-add-dayTimeDuration-to-dateTime">
Section 10.8.5
op:add-dayTimeDuration-to-dateTime</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-add-dayTimeDuration-to-date"><a href=
"http://www.w3.org/TR/xpath-functions/#func-add-dayTimeDuration-to-date">
Section 10.8.9
op:add-dayTimeDuration-to-date</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-add-dayTimeDuration-to-time"><a href=
"http://www.w3.org/TR/xpath-functions/#func-add-dayTimeDuration-to-time">
Section 10.8.12
op:add-dayTimeDuration-to-time</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-add-yearMonthDurations"><a href=
"http://www.w3.org/TR/xpath-functions/#func-add-yearMonthDurations">
Section 10.6.1
op:add-yearMonthDurations</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-add-yearMonthDuration-to-dateTime"><a href=
"http://www.w3.org/TR/xpath-functions/#func-add-yearMonthDuration-to-dateTime">
Section 10.8.4
op:add-yearMonthDuration-to-dateTime</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-add-yearMonthDuration-to-date"><a href=
"http://www.w3.org/TR/xpath-functions/#func-add-yearMonthDuration-to-date">
Section 10.8.8
op:add-yearMonthDuration-to-date</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-boolean-equal"><a href=
"http://www.w3.org/TR/xpath-functions/#func-boolean-equal">Section
9.2.1 op:boolean-equal</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-boolean-greater-than"><a href=
"http://www.w3.org/TR/xpath-functions/#func-boolean-greater-than">Section
9.2.3 op:boolean-greater-than</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-boolean-less-than"><a href=
"http://www.w3.org/TR/xpath-functions/#func-boolean-less-than">Section
9.2.2 op:boolean-less-than</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-boolean"><a href=
"http://www.w3.org/TR/xpath-functions/#func-boolean">Section 15.1.1
fn:boolean</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-compare"><a href=
"http://www.w3.org/TR/xpath-functions/#func-compare">Section 7.3.2
fn:compare</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-concatenate"><a href=
"http://www.w3.org/TR/xpath-functions/#func-concatenate">Section
15.1.2 op:concatenate</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-count"><a href=
"http://www.w3.org/TR/xpath-functions/#func-count">Section 15.4.1
fn:count</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-dateTime-equal"><a href=
"http://www.w3.org/TR/xpath-functions/#func-dateTime-equal">Section
10.4.6 op:dateTime-equal</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-dateTime-greater-than"><a href=
"http://www.w3.org/TR/xpath-functions/#func-dateTime-greater-than">Section
10.4.8 op:dateTime-greater-than</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-dateTime-less-than"><a href=
"http://www.w3.org/TR/xpath-functions/#func-dateTime-less-than">Section
10.4.7 op:dateTime-less-than</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-dayTimeDuration-greater-than"><a href=
"http://www.w3.org/TR/xpath-functions/#func-dayTimeDuration-greater-than">
Section 10.4.4
op:dayTimeDuration-greater-than</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-dayTimeDuration-less-than"><a href=
"http://www.w3.org/TR/xpath-functions/#func-dayTimeDuration-less-than">
Section 10.4.3
op:dayTimeDuration-less-than</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-divide-dayTimeDuration"><a href=
"http://www.w3.org/TR/xpath-functions/#func-divide-dayTimeDuration">
Section 10.6.9
op:divide-dayTimeDuration</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-divide-yearMonthDuration"><a href=
"http://www.w3.org/TR/xpath-functions/#func-divide-yearMonthDuration">
Section 10.6.4
op:divide-yearMonthDuration</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-data"><a href=
"http://www.w3.org/TR/xpath-functions/#func-data">Section 2.4
fn:data</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-empty"><a href=
"http://www.w3.org/TR/xpath-functions/#func-empty">Section 15.1.4
fn:empty</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-error"><a href=
"http://www.w3.org/TR/xpath-functions/#func-error">Section 3 The
Error Function</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-except"><a href=
"http://www.w3.org/TR/xpath-functions/#func-except">Section 15.3.4
op:except</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-false"><a href=
"http://www.w3.org/TR/xpath-functions/#func-false">Section 9.1.2
fn:false</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-intersect"><a href=
"http://www.w3.org/TR/xpath-functions/#func-intersect">Section
15.3.3 op:intersect</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-is-same-node"><a href=
"http://www.w3.org/TR/xpath-functions/#func-is-same-node">Section
14.6 op:is-same-node</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-last"><a href=
"http://www.w3.org/TR/xpath-functions/#func-last">Section 16.2
fn:last</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-multiply-dayTimeDuration"><a href=
"http://www.w3.org/TR/xpath-functions/#func-multiply-dayTimeDuration">
Section 10.6.8
op:multiply-dayTimeDuration</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-multiply-yearMonthDuration"><a href=
"http://www.w3.org/TR/xpath-functions/#func-multiply-yearMonthDuration">
Section 10.6.3
op:multiply-yearMonthDuration</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-node-after"><a href=
"http://www.w3.org/TR/xpath-functions/#func-node-after">Section
14.8 op:node-after</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-node-before"><a href=
"http://www.w3.org/TR/xpath-functions/#func-node-before">Section
14.7 op:node-before</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-NOTATION-equal"><a href=
"http://www.w3.org/TR/xpath-functions/#func-NOTATION-equal">Section
13.1.1 op:NOTATION-equal</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-not"><a href=
"http://www.w3.org/TR/xpath-functions/#func-not">Section 9.3.1
fn:not</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-numeric-add"><a href=
"http://www.w3.org/TR/xpath-functions/#func-numeric-add">Section
6.2.1 op:numeric-add</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-numeric-divide"><a href=
"http://www.w3.org/TR/xpath-functions/#func-numeric-divide">Section
6.2.4 op:numeric-divide</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-numeric-equal"><a href=
"http://www.w3.org/TR/xpath-functions/#func-numeric-equal">Section
6.3.1 op:numeric-equal</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-numeric-greater-than"><a href=
"http://www.w3.org/TR/xpath-functions/#func-numeric-greater-than">Section
6.3.3 op:numeric-greater-than</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-numeric-less-than"><a href=
"http://www.w3.org/TR/xpath-functions/#func-numeric-less-than">Section
6.3.2 op:numeric-less-than</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-numeric-mod"><a href=
"http://www.w3.org/TR/xpath-functions/#func-numeric-mod">Section
6.2.6 op:numeric-mod</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-numeric-multiply"><a href=
"http://www.w3.org/TR/xpath-functions/#func-numeric-multiply">Section
6.2.3 op:numeric-multiply</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-numeric-subtract"><a href=
"http://www.w3.org/TR/xpath-functions/#func-numeric-subtract">Section
6.2.2 op:numeric-subtract</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-numeric-unary-minus"><a href=
"http://www.w3.org/TR/xpath-functions/#func-numeric-unary-minus">Section
6.2.8 op:numeric-unary-minus</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-numeric-unary-plus"><a href=
"http://www.w3.org/TR/xpath-functions/#func-numeric-unary-plus">Section
6.2.7 op:numeric-unary-plus</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-position"><a href=
"http://www.w3.org/TR/xpath-functions/#func-position">Section 16.1
fn:position</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-QName-equal"><a href=
"http://www.w3.org/TR/xpath-functions/#func-QName-equal">Section
11.2.1 op:QName-equal</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-root"><a href=
"http://www.w3.org/TR/xpath-functions/#func-root">Section 14.9
fn:root</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-round"><a href=
"http://www.w3.org/TR/xpath-functions/#func-round">Section 6.4.4
fn:round</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-string-join"><a href=
"http://www.w3.org/TR/xpath-functions/#func-string-join">Section
7.4.2 fn:string-join</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-subsequence"><a href=
"http://www.w3.org/TR/xpath-functions/#func-subsequence">Section
15.1.10 fn:subsequence</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-subtract-dayTimeDuration-from-dateTime"><a href=
"http://www.w3.org/TR/xpath-functions/#func-subtract-dayTimeDuration-from-dateTime">
Section 10.8.7
op:subtract-dayTimeDuration-from-dateTime</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-subtract-dayTimeDuration-from-date"><a href=
"http://www.w3.org/TR/xpath-functions/#func-subtract-dayTimeDuration-from-date">
Section 10.8.11
op:subtract-dayTimeDuration-from-date</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-subtract-dayTimeDuration-from-time"><a href=
"http://www.w3.org/TR/xpath-functions/#func-subtract-dayTimeDuration-from-time">
Section 10.8.13
op:subtract-dayTimeDuration-from-time</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-subtract-dayTimeDurations"><a href=
"http://www.w3.org/TR/xpath-functions/#func-subtract-dayTimeDurations">
Section 10.6.7
op:subtract-dayTimeDurations</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-subtract-yearMonthDuration-from-dateTime"><a href=
"http://www.w3.org/TR/xpath-functions/#func-subtract-yearMonthDuration-from-dateTime">
Section 10.8.6
op:subtract-yearMonthDuration-from-dateTime</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-subtract-yearMonthDuration-from-date"><a href=
"http://www.w3.org/TR/xpath-functions/#func-subtract-yearMonthDuration-from-date">
Section 10.8.10
op:subtract-yearMonthDuration-from-date</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-subtract-yearMonthDurations"><a href=
"http://www.w3.org/TR/xpath-functions/#func-subtract-yearMonthDurations">
Section 10.6.2
op:subtract-yearMonthDurations</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-to"><a href=
"http://www.w3.org/TR/xpath-functions/#func-to">Section 15.5.1
op:to</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-true"><a href=
"http://www.w3.org/TR/xpath-functions/#func-true">Section 9.1.1
fn:true</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-union"><a href=
"http://www.w3.org/TR/xpath-functions/#func-union">Section 15.3.2
op:union</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-yearMonthDuration-greater-than"><a href=
"http://www.w3.org/TR/xpath-functions/#func-yearMonthDuration-greater-than">
Section 10.4.2
op:yearMonthDuration-greater-than</a><sup><small>FO</small></sup></p>
</li>
<li>
<p id="func-yearMonthDuration-less-than"><a href=
"http://www.w3.org/TR/xpath-functions/#func-yearMonthDuration-less-than">
Section 10.4.1
op:yearMonthDuration-less-than</a><sup><small>FO</small></sup></p>
</li>
</ul>
</div>
<div class="div2">
<h3><a name="sec_operators" id="sec_operators"></a>C.2 Mapping of
Overloaded Internal Functions</h3>
<p>This section gives the semantics specific to overloaded internal
functions (with prefix <em>fs:</em>) that are used to define
overloaded XQuery operators (with prefix <em>op:</em>), such as
comparison expressions or arithmetic expressions. Static typing for
those functions are defined over unions of (possibly optional)
atomic types. The semantics is obtained in three steps. First, a
rule is applied to deal with the union of those (possibly optional)
atomic types. A second set of rules treat the cases where one of
the operands of those functions is the empty type (resp. empty
sequence) or optional. Finally, a final rule deals with type
promotion and access to an operators mapping table which maps the
overloaded internal functions to the appropriate operator functions
defined in <a href="#xpath-functions-11">[Functions and Operators
1.1]</a> and give the corresponding type.</p>
<p><b>Notation</b></p>
<p>The following auxiliary grammar production describe optional
atomic types.</p>
<h5><a name="d6e70318" id="d6e70318"></a>OptAtomicType</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-OptAtomicType" id=
"doc-fs-OptAtomicType"></a>[<small>73&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-OptAtomicType">OptAtomicType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-AtomicTypeName">AtomicTypeName</a> |
(<a href="#doc-fs-AtomicTypeName">AtomicTypeName</a> "?") |
"empty"</code></td>
</tr>
</tbody>
</table>
<p><b><a href="#processing_static" class="processing">Static Type
Analysis</a></b></p>
<p>The following static typing rules apply generically to all the
<em>fs:</em> special functions. They do not apply to any other
function calls, which are treated in <a href=
"#id-function-calls"><b>[4.1.5 Function Calls]</b></a>.</p>
<p>First, if the static type of one or several of the expressions
passed as argument is a union of atomic types, the function call is
type checked once separately for each atomic type in that union.
The static type of the entire function call expression is then the
union of the types computed in each case.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub> = (<a href=
"#doc-fs-OptAtomicType"><em>OptAtomicType</em></a><sub><font size=
"2">1</font></sub><sub><font size="2">,1</font></sub>|...|<a href=
"#doc-fs-OptAtomicType"><em>OptAtomicType</em></a><sub><font size=
"2">m</font></sub><sub><font size="2">,1</font></sub>)</td>
</tr>
<tr align="center" valign="middle">
<td>...</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">n</font></sub> = (<a href=
"#doc-fs-OptAtomicType"><em>OptAtomicType</em></a><sub><font size=
"2">1</font></sub><sub><font size="2">,n</font></sub>|...|<a href=
"#doc-fs-OptAtomicType"><em>OptAtomicType</em></a><sub><font size=
"2">m</font></sub><sub><font size="2">,n</font></sub>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>(<a href=
"#doc-fs-OptAtomicType"><em>OptAtomicType</em></a><sub><font size=
"2">1</font></sub><sub><font size="2">,1</font></sub>,..., <a href=
"#doc-fs-OptAtomicType"><em>OptAtomicType</em></a><sub><font size=
"2">1</font></sub><sub><font size="2">,n</font></sub>) <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-OptAtomicType"><em>OptAtomicType</em></a><sub><font size=
"2">1</font></sub>'</td>
</tr>
<tr align="center" valign="middle">
<td>...</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>(<a href=
"#doc-fs-OptAtomicType"><em>OptAtomicType</em></a><sub><font size=
"2">m</font></sub><sub><font size="2">,1</font></sub>,..., <a href=
"#doc-fs-OptAtomicType"><em>OptAtomicType</em></a><sub><font size=
"2">m</font></sub><sub><font size="2">,n</font></sub>) <a href=
"#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-fs-OptAtomicType"><em>OptAtomicType</em></a><sub><font size=
"2">r</font></sub>'</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,
..., <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">n</font></sub>) <a href="#jd_has_type" class=
"judgment"><b>:</b></a> (<a href=
"#doc-fs-OptAtomicType"><em>OptAtomicType</em></a><sub><font size=
"2">1</font></sub>'|...|<a href=
"#doc-fs-OptAtomicType"><em>OptAtomicType</em></a><sub><font size=
"2">r</font></sub>')</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p><b>Note</b></p>
<p>Note that this approach can be used since the type declared for
a function parameter is never itself be a union.</p>
<p>The following rules deal with optional arguments. In the case of
binary operators, if either one of the types of the operands is
empty, the resulting type is empty.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub> = empty</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <em><a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></em>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>,<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>)
<a href="#jd_has_type" class="judgment"><b>:</b></a> empty</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub> = empty</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <em><a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></em>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>,<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>)
<a href="#jd_has_type" class="judgment"><b>:</b></a> empty</td>
</tr>
</table>
<br /></div>
<p>If either one of the types of the operands is optional, the type
obtained by propagating the optional occurrence indicator.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub> = <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub> = <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">2</font></sub>?</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>(<a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">1</font></sub>,<a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">2</font></sub>) <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">3</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <em><a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></em>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>,<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>)
<a href="#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">3</font></sub>?</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub> = <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">1</font></sub>?</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub> = <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>(<a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">1</font></sub>,<a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">2</font></sub>) <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">3</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <em><a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></em>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>,<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>)
<a href="#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">3</font></sub>?</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub> = <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">1</font></sub>?</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub> = <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">2</font></sub>?</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>(<a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">1</font></sub>,<a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">2</font></sub>) <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">3</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <em><a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></em>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>,<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>)
<a href="#jd_has_type" class="judgment"><b>:</b></a> <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">3</font></sub>?</td>
</tr>
</table>
<br /></div>
<p>In the case of unary operators, if the type of the operand is
empty, the resulting type is empty.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub> = empty</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <em><a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></em>(<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
<a href="#jd_has_type" class="judgment"><b>:</b></a> empty</td>
</tr>
</table>
<br /></div>
<p>Finally, the resulting type is obtained by performing type
promotion and accessing the operators mapping table (using the
<a href="#jd_operator_type_for" class="judgment"><b>operator type
for</b></a> judgment defined below).</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_can_be_promoted_to" class=
"judgment"><b>can be promoted to</b></a> <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">1</font></sub>'</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_can_be_promoted_to" class=
"judgment"><b>can be promoted to</b></a> <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">2</font></sub>'</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#id-expanded-qnames"><em>expanded-QName</em></a>
<a href="#jd_operator_type_for" class="judgment"><b>operator type
for</b></a> <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_operator_type_for" class=
"judgment"><b>and</b></a> <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_operator_type_for" class=
"judgment"><b>is</b></a> <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">3</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>(<a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">1</font></sub>,<a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">2</font></sub>) <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">3</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b><a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_can_be_promoted_to" class=
"judgment"><b>can be promoted to</b></a> <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">1</font></sub>'</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#id-expanded-qnames"><em>expanded-QName</em></a>
<a href="#jd_operator_type_for" class="judgment"><b>operator type
for</b></a> <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_operator_type_for" class=
"judgment"><b>is</b></a> <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">3</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>
<b>&#160;|-&#160;</b> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>(<a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">1</font></sub>) <a href="#jd_has_type" class=
"judgment"><b>:</b></a> <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">3</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<br /></div>
<p><b><a href="#processing_dynamic" class="processing">Dynamic
Evaluation</a></b></p>
<p>Each <code>fs:</code> overloaded operator maps to the
corresponding equivalent overloaded <code>op:</code> operator, as
defined in <a href="#xpath-functions-11">[Functions and Operators
1.1]</a>, and deals with the case where one of the operands is the
empty sequence.</p>
<p>The dynamic semantics of the <code>fs:</code> operator is
similar to using the following user-defined function.</p>
<table summary="">
<tbody>
<tr>
<td><code>declare function</code> <em>fs:opname</em><code>($x1 as
xs:anyAtomicType?, $x2 as xs:anyAtomicType?) as xs:anyAtomicType?
{</code></td>
</tr>
<tr>
<td>&#160;&#160;<code>if (fn:empty($x1) or fn:empty($x2)) then ()
else</code> <font size=
"6">[</font><em>fs:opname($x1,$x2)</em><font size=
"6">]</font><a href="#jd_map_overloaded_op" class=
"judgment"><sub><font size="2">OverloadedOp</font></sub></a></td>
</tr>
<tr>
<td><code>};</code></td>
</tr>
</tbody>
</table>
<p>Where <font size="6">[</font><em>fs:opname()</em><font size=
"6">]</font><a href="#jd_map_overloaded_op" class=
"judgment"><sub><font size="2">OverloadedOp</font></sub></a> maps
to the corresponding op: operator in <a href=
"#xpath-functions-11">[Functions and Operators 1.1]</a>, as defined
in the table below.</p>
<p><b>Notation</b></p>
<p>The operators mapping table is given below. The table is used to
define the following auxiliary mapping rules and judgments.</p>
<p id="jd_map_overloaded_op">The mapping rule for binary and unary
operators</p>
<div align="center"><font size=
"6">[</font><em>fs:opname1</em>(<em>Expr</em><sub><font size=
"2">1</font></sub>,<em>Expr</em><sub><font size=
"2">2</font></sub>)<font size="6">]</font><a href=
"#jd_map_overloaded_op" class="judgment"><sub><font size=
"2">OverloadedOp</font></sub></a> ==
<em>op:opname2</em>(<em>Expr</em><sub><font size=
"2">1</font></sub>,<em>Expr</em><sub><font size=
"2">2</font></sub>)</div>
<p>and</p>
<div align="center"><font size=
"6">[</font><em>fs:opname1</em>(<em>Expr</em><sub><font size=
"2">1</font></sub>)<font size="6">]</font><a href=
"#jd_map_overloaded_op" class="judgment"><sub><font size=
"2">OverloadedOp</font></sub></a> ==
<em>op:opname2</em>(<em>Expr</em><sub><font size=
"2">1</font></sub>)</div>
<p>where the operator depends on the type of each value returned by
<em>Expr</em><sub><font size="2">1</font></sub> and
<em>Expr</em><sub><font size="2">2</font></sub>.</p>
<p id="jd_operator_type_for">The judgments for binary and unary
operators</p>
<div align="center"><a href=
"#id-expanded-qnames"><em>expanded-QName</em></a> <a href=
"#jd_operator_type_for" class="judgment"><b>operator type
for</b></a> <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_operator_type_for" class=
"judgment"><b>and</b></a> <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_operator_type_for" class=
"judgment"><b>is</b></a> <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">3</font></sub></div>
<p>and</p>
<div align="center"><a href=
"#id-expanded-qnames"><em>expanded-QName</em></a> <a href=
"#jd_operator_type_for" class="judgment"><b>operator type
for</b></a> <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_operator_type_for" class=
"judgment"><b>is</b></a> <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">3</font></sub></div>
<p>hold when the operator table indicates that the operator
<a href="#id-expanded-qnames"><em>expanded-QName</em></a> has the
output type <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">3</font></sub> for the input types <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">1</font></sub> and <a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">2</font></sub>.</p>
<p>Note that in the following table, all numeric functions are
applied to operands with the same type. Values are promoted to
compatible types using the function call semantics given in
<a href="#id-function-calls"><b>[4.1.5 Function Calls]</b></a>.</p>
<p><b>Gregorian</b> refers to the types <code>xs:gYearMonth</code>,
<code>xs:gYear</code>, <code>xs:gMonthDay</code>,
<code>xs:gDay</code>, and <code>xs:gMonth</code>. For binary
operators that accept two Gregorian-type operands, both operands
must have the same type (for example, if one operand is of type
<code>xs:gDay</code>, the other operand must be of type
<code>xs:gDay</code>.)</p>
<table summary="" border="1">
<caption>Binary Operators</caption>
<tbody>
<tr>
<th colspan="1"><small>Internal Function</small></th>
<th colspan="1"><small><a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">1</font></sub></small></th>
<th colspan="1"><small><a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">2</font></sub></small></th>
<th colspan="1"><small>Denotes</small></th>
<th colspan="1"><small><a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">3</font></sub></small></th>
</tr>
<tr>
<td><small><em>fs:</em><code>plus</code>(A, B)</small></td>
<td><small><code>xs:integer</code></small></td>
<td><small><code>xs:integer</code></small></td>
<td><small>op:numeric-add(A, B)</small></td>
<td><small><code>xs:integer</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>plus</code>(A, B)</small></td>
<td><small><code>xs:decimal</code></small></td>
<td><small><code>xs:decimal</code></small></td>
<td><small>op:numeric-add(A, B)</small></td>
<td><small><code>xs:decimal</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>plus</code>(A, B)</small></td>
<td><small><code>xs:float</code></small></td>
<td><small><code>xs:float</code></small></td>
<td><small>op:numeric-add(A, B)</small></td>
<td><small><code>xs:float</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>plus</code>(A, B)</small></td>
<td><small><code>xs:double</code></small></td>
<td><small><code>xs:double</code></small></td>
<td><small>op:numeric-add(A, B)</small></td>
<td><small><code>xs:double</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>plus</code>(A, B)</small></td>
<td><small><code>xs:date</code></small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td>
<td><small>op:add-yearMonthDuration-to-date(A, B)</small></td>
<td><small><code>xs:date</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>plus</code>(A, B)</small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td>
<td><small><code>xs:date</code></small></td>
<td><small>op:add-yearMonthDuration-to-date(B, A)</small></td>
<td><small><code>xs:date</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>plus</code>(A, B)</small></td>
<td><small><code>xs:date</code></small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:dayTimeDuration</code></a></small></td>
<td><small>op:add-dayTimeDuration-to-date(A, B)</small></td>
<td><small><code>xs:date</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>plus</code>(A, B)</small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:dayTimeDuration</code></a></small></td>
<td><small><code>xs:date</code></small></td>
<td><small>op:add-dayTimeDuration-to-date(B, A)</small></td>
<td><small><code>xs:date</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>plus</code>(A, B)</small></td>
<td><small><code>xs:time</code></small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:dayTimeDuration</code></a></small></td>
<td><small>op:add-dayTimeDuration-to-time(A, B)</small></td>
<td><small><code>xs:time</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>plus</code>(A, B)</small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:dayTimeDuration</code></a></small></td>
<td><small><code>xs:time</code></small></td>
<td><small>op:add-dayTimeDuration-to-time(B, A)</small></td>
<td><small><code>xs:time</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>plus</code>(A, B)</small></td>
<td><small><code>xs:dateTime</code></small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td>
<td><small>op:add-yearMonthDuration-to-dateTime(A, B)</small></td>
<td><small><code>xs:dateTime</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>plus</code>(A, B)</small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td>
<td><small><code>xs:dateTime</code></small></td>
<td><small>op:add-yearMonthDuration-to-dateTime(B, A)</small></td>
<td><small><code>xs:dateTime</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>plus</code>(A, B)</small></td>
<td><small><code>xs:dateTime</code></small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:dayTimeDuration</code></a></small></td>
<td><small>op:add-dayTimeDuration-to-dateTime(A, B)</small></td>
<td><small><code>xs:dateTime</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>plus</code>(A, B)</small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:dayTimeDuration</code></a></small></td>
<td><small><code>xs:dateTime</code></small></td>
<td><small>op:add-dayTimeDuration-to-dateTime(B, A)</small></td>
<td><small><code>xs:dateTime</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>plus</code>(A, B)</small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td>
<td><small>op:add-yearMonthDurations(A, B)</small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>plus</code>(A, B)</small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:dayTimeDuration</code></a></small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:dayTimeDuration</code></a></small></td>
<td><small>op:add-dayTimeDurations(A, B)</small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:dayTimeDuration</code></a></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>minus</code>(A, B)</small></td>
<td><small><code>xs:integer</code></small></td>
<td><small><code>xs:integer</code></small></td>
<td><small>op:numeric-subtract(A, B)</small></td>
<td><small><code>xs:integer</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>minus</code>(A, B)</small></td>
<td><small><code>xs:decimal</code></small></td>
<td><small><code>xs:decimal</code></small></td>
<td><small>op:numeric-subtract(A, B)</small></td>
<td><small><code>xs:decimal</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>minus</code>(A, B)</small></td>
<td><small><code>xs:float</code></small></td>
<td><small><code>xs:float</code></small></td>
<td><small>op:numeric-subtract(A, B)</small></td>
<td><small><code>xs:float</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>minus</code>(A, B)</small></td>
<td><small><code>xs:double</code></small></td>
<td><small><code>xs:double</code></small></td>
<td><small>op:numeric-subtract(A, B)</small></td>
<td><small><code>xs:double</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>minus</code>(A, B)</small></td>
<td><small><code>xs:date</code></small></td>
<td><small><code>xs:date</code></small></td>
<td><small><span>fn</span><span>op</span>:subtract-dates(A,
B)</small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:dayTimeDuration</code></a></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>minus</code>(A, B)</small></td>
<td><small><code>xs:date</code></small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td>
<td><small>op:subtract-yearMonthDuration-from-date(A,
B)</small></td>
<td><small><code>xs:date</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>minus</code>(A, B)</small></td>
<td><small><code>xs:date</code></small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:dayTimeDuration</code></a></small></td>
<td><small>op:subtract-dayTimeDuration-from-date(A, B)</small></td>
<td><small><code>xs:date</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>minus</code>(A, B)</small></td>
<td><small><code>xs:time</code></small></td>
<td><small><code>xs:time</code></small></td>
<td><small><span>fn</span><span>op</span>:subtract-times(A,
B)</small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:dayTimeDuration</code></a></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>minus</code>(A, B)</small></td>
<td><small><code>xs:time</code></small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:dayTimeDuration</code></a></small></td>
<td><small>op:subtract-dayTimeDuration-from-time(A, B)</small></td>
<td><small><code>xs:time</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>minus</code>(A, B)</small></td>
<td><small><code>xs:dateTime</code></small></td>
<td><small><code>xs:dateTime</code></small></td>
<td><small><span>fn</span><span>op</span>:subtract-dateTimes(A,
B)</small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:dayTimeDuration</code></a></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>minus</code>(A, B)</small></td>
<td><small><code>xs:dateTime</code></small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td>
<td><small>op:subtract-yearMonthDuration-from-dateTime(A,
B)</small></td>
<td><small><code>xs:dateTime</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>minus</code>(A, B)</small></td>
<td><small><code>xs:dateTime</code></small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:dayTimeDuration</code></a></small></td>
<td><small>op:subtract-dayTimeDuration-from-dateTime(A,
B)</small></td>
<td><small><code>xs:dateTime</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>minus</code>(A, B)</small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td>
<td><small>op:subtract-yearMonthDurations(A, B)</small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>minus</code>(A, B)</small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:dayTimeDuration</code></a></small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:dayTimeDuration</code></a></small></td>
<td><small>op:subtract-dayTimeDurations(A, B)</small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:dayTimeDuration</code></a></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>times</code>(A, B)</small></td>
<td><small><code>xs:integer</code></small></td>
<td><small><code>xs:integer</code></small></td>
<td><small>op:numeric-multiply(A, B)</small></td>
<td><small><code>xs:integer</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>times</code>(A, B)</small></td>
<td><small><code>xs:decimal</code></small></td>
<td><small><code>xs:decimal</code></small></td>
<td><small>op:numeric-multiply(A, B)</small></td>
<td><small><code>xs:decimal</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>times</code>(A, B)</small></td>
<td><small><code>xs:float</code></small></td>
<td><small><code>xs:float</code></small></td>
<td><small>op:numeric-multiply(A, B)</small></td>
<td><small><code>xs:float</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>times</code>(A, B)</small></td>
<td><small><code>xs:double</code></small></td>
<td><small><code>xs:double</code></small></td>
<td><small>op:numeric-multiply(A, B)</small></td>
<td><small><code>xs:double</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>times</code>(A, B)</small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td>
<td><small><code>xs:double</code></small></td>
<td><small>op:multiply-yearMonthDuration(A, B)</small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>times</code>(A, B)</small></td>
<td><small><code>xs:double</code></small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td>
<td><small>op:multiply-yearMonthDuration(B, A)</small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>times</code>(A, B)</small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:dayTimeDuration</code></a></small></td>
<td><small><code>xs:double</code></small></td>
<td><small>op:multiply-dayTimeDuration(A, B)</small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:dayTimeDuration</code></a></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>times</code>(A, B)</small></td>
<td><small><code>xs:double</code></small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:dayTimeDuration</code></a></small></td>
<td><small>op:multiply-dayTimeDuration(B, A)</small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:dayTimeDuration</code></a></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>idiv</code>(A, B)</small></td>
<td><small><code>xs:integer</code></small></td>
<td><small><code>xs:integer</code></small></td>
<td><small>op:numeric-integer-divide(A, B)</small></td>
<td><small><code>xs:integer</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>idiv</code>(A, B)</small></td>
<td><small><code>xs:decimal</code></small></td>
<td><small><code>xs:decimal</code></small></td>
<td><small>op:numeric-integer-divide(A, B)</small></td>
<td><small><code>xs:integer</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>idiv</code>(A, B)</small></td>
<td><small><code>xs:float</code></small></td>
<td><small><code>xs:float</code></small></td>
<td><small>op:numeric-integer-divide(A, B)</small></td>
<td><small><code>xs:integer</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>idiv</code>(A, B)</small></td>
<td><small><code>xs:double</code></small></td>
<td><small><code>xs:double</code></small></td>
<td><small>op:numeric-integer-divide(A, B)</small></td>
<td><small><code>xs:integer</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>div</code>(A, B)</small></td>
<td><small><code>xs:integer</code></small></td>
<td><small><code>xs:integer</code></small></td>
<td><small>op:numeric-divide(A, B)</small></td>
<td><small><code>xs:decimal</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>div</code>(A, B)</small></td>
<td><small><code>xs:decimal</code></small></td>
<td><small><code>xs:decimal</code></small></td>
<td><small>op:numeric-divide(A, B)</small></td>
<td><small><code>xs:decimal</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>div</code>(A, B)</small></td>
<td><small><code>xs:float</code></small></td>
<td><small><code>xs:float</code></small></td>
<td><small>op:numeric-divide(A, B)</small></td>
<td><small><code>xs:float</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>div</code>(A, B)</small></td>
<td><small><code>xs:double</code></small></td>
<td><small><code>xs:double</code></small></td>
<td><small>op:numeric-divide(A, B)</small></td>
<td><small><code>xs:double</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>div</code>(A, B)</small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td>
<td><small><code>xs:double</code></small></td>
<td><small>op:divide-yearMonthDuration(A, B)</small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>div</code>(A, B)</small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:dayTimeDuration</code></a></small></td>
<td><small><code>xs:double</code></small></td>
<td><small>op:divide-dayTimeDuration(A, B)</small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:dayTimeDuration</code></a></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>div</code>(A, B)</small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td>
<td><small>op:divide-yearMonthDuration-by-yearMonthDuration(A,
B)</small></td>
<td><small><code>xs:decimal</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>div</code>(A, B)</small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:dayTimeDuration</code></a></small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:dayTimeDuration</code></a></small></td>
<td><small>op:divide-dayTimeDuration-by-dayTimeDuration(A,
B)</small></td>
<td><small><code>xs:decimal</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>mod</code>(A, B)</small></td>
<td><small><code>xs:integer</code></small></td>
<td><small><code>xs:integer</code></small></td>
<td><small>op:numeric-mod(A, B)</small></td>
<td><small><code>xs:integer</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>mod</code>(A, B)</small></td>
<td><small><code>xs:decimal</code></small></td>
<td><small><code>xs:decimal</code></small></td>
<td><small>op:numeric-mod(A, B)</small></td>
<td><small><code>xs:decimal</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>mod</code>(A, B)</small></td>
<td><small><code>xs:float</code></small></td>
<td><small><code>xs:float</code></small></td>
<td><small>op:numeric-mod(A, B)</small></td>
<td><small><code>xs:float</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>mod</code>(A, B)</small></td>
<td><small><code>xs:double</code></small></td>
<td><small><code>xs:double</code></small></td>
<td><small>op:numeric-mod(A, B)</small></td>
<td><small><code>xs:double</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>eq</code>(A, B)</small></td>
<td><small><code>xs:integer</code></small></td>
<td><small><code>xs:integer</code></small></td>
<td><small>op:numeric-equal(A, B)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>eq</code>(A, B)</small></td>
<td><small><code>xs:decimal</code></small></td>
<td><small><code>xs:decimal</code></small></td>
<td><small>op:numeric-equal(A, B)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>eq</code>(A, B)</small></td>
<td><small><code>xs:float</code></small></td>
<td><small><code>xs:float</code></small></td>
<td><small>op:numeric-equal(A, B)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>eq</code>(A, B)</small></td>
<td><small><code>xs:double</code></small></td>
<td><small><code>xs:double</code></small></td>
<td><small>op:numeric-equal(A, B)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>eq</code>(A, B)</small></td>
<td><small><code>xs:boolean</code></small></td>
<td><small><code>xs:boolean</code></small></td>
<td><small>op:boolean-equal(A, B)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>eq</code>(A, B)</small></td>
<td><small><code>xs:string</code></small></td>
<td><small><code>xs:string</code></small></td>
<td><small>op:numeric-equal(fn:compare(A, B), 0)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>eq</code>(A, B)</small></td>
<td><small><code>xs:date</code></small></td>
<td><small><code>xs:date</code></small></td>
<td><small>op:date-equal(A, B)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>eq</code>(A, B)</small></td>
<td><small><code>xs:time</code></small></td>
<td><small><code>xs:time</code></small></td>
<td><small>op:time-equal(A, B)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>eq</code>(A, B)</small></td>
<td><small><code>xs:dateTime</code></small></td>
<td><small><code>xs:dateTime</code></small></td>
<td><small>op:dateTime-equal(A, B)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>eq</code>(A, B)</small></td>
<td><small><code>xs:duration</code></small></td>
<td><small><code>xs:duration</code></small></td>
<td><small>op:duration-equal(A, B)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>eq</code>(A, B)</small></td>
<td><small>Gregorian</small></td>
<td><small>Gregorian</small></td>
<td><small>op:gYear-equal(A, B) etc.</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>eq</code>(A, B)</small></td>
<td><small><code>xs:hexBinary</code></small></td>
<td><small><code>xs:hexBinary</code></small></td>
<td>
<small><span>op:hex-binary-equal</span><span>op:hexBinary-equal</span>(A,
B)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>eq</code>(A, B)</small></td>
<td><small><code>xs:base64Binary</code></small></td>
<td><small><code>xs:base64Binary</code></small></td>
<td>
<small><span>op:base64-binary-equal</span><span>op:base64Binary-equal</span>(A,
B)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>eq</code>(A, B)</small></td>
<td><small><code>xs:anyURI</code></small></td>
<td><small><code>xs:anyURI</code></small></td>
<td><small><span>op:numeric-equal(fn:compare(A, B),
0)</span></small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>eq</code>(A, B)</small></td>
<td><small><code>xs:QName</code></small></td>
<td><small><code>xs:QName</code></small></td>
<td><small>op:QName-equal(A, B)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>eq</code>(A, B)</small></td>
<td><small><code>xs:NOTATION</code></small></td>
<td><small><code>xs:NOTATION</code></small></td>
<td><small>op:NOTATION-equal(A, B)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>ne</code>(A, B)</small></td>
<td><small><code>xs:integer</code></small></td>
<td><small><code>xs:integer</code></small></td>
<td><small><code>fn:not</code>(op:numeric-equal(A, B))</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>ne</code>(A, B)</small></td>
<td><small><code>xs:decimal</code></small></td>
<td><small><code>xs:decimal</code></small></td>
<td><small><code>fn:not</code>(op:numeric-equal(A, B))</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>ne</code>(A, B)</small></td>
<td><small><code>xs:float</code></small></td>
<td><small><code>xs:float</code></small></td>
<td><small><code>fn:not</code>(op:numeric-equal(A, B))</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>ne</code>(A, B)</small></td>
<td><small><code>xs:double</code></small></td>
<td><small><code>xs:double</code></small></td>
<td><small><code>fn:not</code>(op:numeric-equal(A, B))</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>ne</code>(A, B)</small></td>
<td><small><code>xs:boolean</code></small></td>
<td><small><code>xs:boolean</code></small></td>
<td><small><code>fn:not</code>(op:boolean-equal(A, B))</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>ne</code>(A, B)</small></td>
<td><small><code>xs:string</code></small></td>
<td><small><code>xs:string</code></small></td>
<td><small><code>fn:not</code>(op:numeric-equal(fn:compare(A, B),
0))</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>ne</code>(A, B)</small></td>
<td><small><code>xs:date</code></small></td>
<td><small><code>xs:date</code></small></td>
<td><small><code>fn:not</code>(op:date-equal(A, B))</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>ne</code>(A, B)</small></td>
<td><small><code>xs:time</code></small></td>
<td><small><code>xs:time</code></small></td>
<td><small><code>fn:not</code>(op:time-equal(A, B))</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>ne</code>(A, B)</small></td>
<td><small><code>xs:dateTime</code></small></td>
<td><small><code>xs:dateTime</code></small></td>
<td><small><code>fn:not</code>(op:dateTime-equal(A,
B))</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>ne</code>(A, B)</small></td>
<td><small><code>xs:duration</code></small></td>
<td><small><code>xs:duration</code></small></td>
<td><small><code>fn:not</code>(op:duration-equal(A,
B))</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>ne</code>(A, B)</small></td>
<td><small>Gregorian</small></td>
<td><small>Gregorian</small></td>
<td><small><code>fn:not</code>(op:gYear-equal(A, B))
etc.</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>ne</code>(A, B)</small></td>
<td><small><code>xs:hexBinary</code></small></td>
<td><small><code>xs:hexBinary</code></small></td>
<td>
<small><code>fn:not</code>(<span>op:hex-binary-equal</span><span>op:hexBinary-equal</span>(A,
B))</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>ne</code>(A, B)</small></td>
<td><small><code>xs:base64Binary</code></small></td>
<td><small><code>xs:base64Binary</code></small></td>
<td>
<small><code>fn:not</code>(<span>op:base64-binary-equal</span><span>op:base64Binary-equal</span>(A,
B))</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>ne</code>(A, B)</small></td>
<td><small><code>xs:anyURI</code></small></td>
<td><small><code>xs:anyURI</code></small></td>
<td><small><code>fn:not</code>(<span>op:numeric-equal(fn:compare(A,
B), 0)</span>)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>ne</code>(A, B)</small></td>
<td><small><code>xs:QName</code></small></td>
<td><small><code>xs:QName</code></small></td>
<td><small><code>fn:not</code>(op:QName-equal(A, B))</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>ne</code>(A, B)</small></td>
<td><small><code>xs:NOTATION</code></small></td>
<td><small><code>xs:NOTATION</code></small></td>
<td><small><code>fn:not</code>(op:NOTATION-equal(A,
B))</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>gt</code>(A, B)</small></td>
<td><small><code>xs:integer</code></small></td>
<td><small><code>xs:integer</code></small></td>
<td><small>op:numeric-greater-than(A, B)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>gt</code>(A, B)</small></td>
<td><small><code>xs:decimal</code></small></td>
<td><small><code>xs:decimal</code></small></td>
<td><small>op:numeric-greater-than(A, B)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>gt</code>(A, B)</small></td>
<td><small><code>xs:float</code></small></td>
<td><small><code>xs:float</code></small></td>
<td><small>op:numeric-greater-than(A, B)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>gt</code>(A, B)</small></td>
<td><small><code>xs:double</code></small></td>
<td><small><code>xs:double</code></small></td>
<td><small>op:numeric-greater-than(A, B)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>gt</code>(A, B)</small></td>
<td><small><code>xs:boolean</code></small></td>
<td><small><code>xs:boolean</code></small></td>
<td><small>op:boolean-greater-than(A, B)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>gt</code>(A, B)</small></td>
<td><small><code>xs:string</code></small></td>
<td><small><code>xs:string</code></small></td>
<td><small>op:numeric-greater-than(<code>fn:compare</code>(A, B),
0)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>gt</code>(A, B)</small></td>
<td><small><code>xs:date</code></small></td>
<td><small><code>xs:date</code></small></td>
<td><small>op:date-greater-than(A, B)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>gt</code>(A, B)</small></td>
<td><small><code>xs:time</code></small></td>
<td><small><code>xs:time</code></small></td>
<td><small>op:time-greater-than(A, B)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>gt</code>(A, B)</small></td>
<td><small><code>xs:dateTime</code></small></td>
<td><small><code>xs:dateTime</code></small></td>
<td><small>op:dateTime-greater-than(A, B)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>gt</code>(A, B)</small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td>
<td><small>op:yearMonthDuration-greater-than(A, B)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>gt</code>(A, B)</small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:dayTimeDuration</code></a></small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:dayTimeDuration</code></a></small></td>
<td><small>op:dayTimeDuration-greater-than(A, B)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>lt</code>(A, B)</small></td>
<td><small><code>xs:integer</code></small></td>
<td><small><code>xs:integer</code></small></td>
<td><small>op:numeric-less-than(A, B)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>lt</code>(A, B)</small></td>
<td><small><code>xs:decimal</code></small></td>
<td><small><code>xs:decimal</code></small></td>
<td><small>op:numeric-less-than(A, B)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>lt</code>(A, B)</small></td>
<td><small><code>xs:float</code></small></td>
<td><small><code>xs:float</code></small></td>
<td><small>op:numeric-less-than(A, B)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>lt</code>(A, B)</small></td>
<td><small><code>xs:double</code></small></td>
<td><small><code>xs:double</code></small></td>
<td><small>op:numeric-less-than(A, B)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>lt</code>(A, B)</small></td>
<td><small><code>xs:boolean</code></small></td>
<td><small><code>xs:boolean</code></small></td>
<td><small>op:boolean-less-than(A, B)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>lt</code>(A, B)</small></td>
<td><small><code>xs:string</code></small></td>
<td><small><code>xs:string</code></small></td>
<td><small>op:numeric-less-than(<code>fn:compare</code>(A, B),
0)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>lt</code>(A, B)</small></td>
<td><small><code>xs:date</code></small></td>
<td><small><code>xs:date</code></small></td>
<td><small>op:date-less-than(A, B)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>lt</code>(A, B)</small></td>
<td><small><code>xs:time</code></small></td>
<td><small><code>xs:time</code></small></td>
<td><small>op:time-less-than(A, B)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>lt</code>(A, B)</small></td>
<td><small><code>xs:dateTime</code></small></td>
<td><small><code>xs:dateTime</code></small></td>
<td><small>op:dateTime-less-than(A, B)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>lt</code>(A, B)</small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td>
<td><small>op:yearMonthDuration-less-than(A, B)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>lt</code>(A, B)</small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:dayTimeDuration</code></a></small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:dayTimeDuration</code></a></small></td>
<td><small>op:dayTimeDuration-less-than(A, B)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>ge</code>(A, B)</small></td>
<td><small><code>xs:integer</code></small></td>
<td><small><code>xs:integer</code></small></td>
<td><small>op:numeric-greater-than(A, B) or
op:numeric-equal(A,B)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>ge</code>(A, B)</small></td>
<td><small><code>xs:decimal</code></small></td>
<td><small><code>xs:decimal</code></small></td>
<td><small>op:numeric-greater-than(A, B) or
op:numeric-equal(A,B)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>ge</code>(A, B)</small></td>
<td><small><code>xs:float</code></small></td>
<td><small><code>xs:float</code></small></td>
<td><small>op:numeric-greater-than(A, B) or
op:numeric-equal(A,B)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>ge</code>(A, B)</small></td>
<td><small><code>xs:double</code></small></td>
<td><small><code>xs:double</code></small></td>
<td><small>op:numeric-greater-than(A, B) or
op:numeric-equal(A,B)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>ge</code>(A, B)</small></td>
<td><small><code>xs:boolean</code></small></td>
<td><small><code>xs:boolean</code></small></td>
<td><small>op:numeric-greater-than(A, B) or
op:numeric-equal(A,B)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>ge</code>(A, B)</small></td>
<td><small><code>xs:string</code></small></td>
<td><small><code>xs:string</code></small></td>
<td><small>op:numeric-greater-than(<code>fn:compare</code>(A, B),
-1)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>ge</code>(A, B)</small></td>
<td><small><code>xs:date</code></small></td>
<td><small><code>xs:date</code></small></td>
<td><small>op:date-less-than(B, A)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>ge</code>(A, B)</small></td>
<td><small><code>xs:time</code></small></td>
<td><small><code>xs:time</code></small></td>
<td><small>op:time-less-than(B, A)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>ge</code>(A, B)</small></td>
<td><small><code>xs:dateTime</code></small></td>
<td><small><code>xs:dateTime</code></small></td>
<td><small>op:dateTime-less-than(B, A)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>ge</code>(A, B)</small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td>
<td><small>op:yearMonthDuration-less-than(B, A)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>ge</code>(A, B)</small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:dayTimeDuration</code></a></small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:dayTimeDuration</code></a></small></td>
<td><small>op:dayTimeDuration-less-than(B, A)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>le</code>(A, B)</small></td>
<td><small><code>xs:integer</code></small></td>
<td><small><code>xs:integer</code></small></td>
<td><small>op:numeric-less-than(A, B) or
op:numeric-equal(A,B)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>le</code>(A, B)</small></td>
<td><small><code>xs:decimal</code></small></td>
<td><small><code>xs:decimal</code></small></td>
<td><small>op:numeric-less-than(A, B) or
op:numeric-equal(A,B)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>le</code>(A, B)</small></td>
<td><small><code>xs:float</code></small></td>
<td><small><code>xs:float</code></small></td>
<td><small>op:numeric-less-than(A, B) or
op:numeric-equal(A,B)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>le</code>(A, B)</small></td>
<td><small><code>xs:double</code></small></td>
<td><small><code>xs:double</code></small></td>
<td><small>op:numeric-less-than(A, B) or
op:numeric-equal(A,B)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>le</code>(A, B)</small></td>
<td><small><code>xs:boolean</code></small></td>
<td><small><code>xs:boolean</code></small></td>
<td><small>op:numeric-less-than(A, B) or
op:numeric-equal(A,B)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>le</code>(A, B)</small></td>
<td><small><code>xs:string</code></small></td>
<td><small><code>xs:string</code></small></td>
<td><small>op:numeric-less-than(<code>fn:compare</code>(A, B),
1)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>le</code>(A, B)</small></td>
<td><small><code>xs:date</code></small></td>
<td><small><code>xs:date</code></small></td>
<td><small>op:date-greater-than(B, A)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>le</code>(A, B)</small></td>
<td><small><code>xs:time</code></small></td>
<td><small><code>xs:time</code></small></td>
<td><small>op:time-greater-than(B, A)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>le</code>(A, B)</small></td>
<td><small><code>xs:dateTime</code></small></td>
<td><small><code>xs:dateTime</code></small></td>
<td><small>op:dateTime-greater-than(B, A)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>le</code>(A, B)</small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td>
<td><small>op:yearMonthDuration-greater-than(B, A)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>le</code>(A, B)</small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:dayTimeDuration</code></a></small></td>
<td><small><a href=
"#dt-xs_durations"><code>xs:dayTimeDuration</code></a></small></td>
<td><small>op:dayTimeDuration-greater-than(B, A)</small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>is-same-node</code>(A, B)</small></td>
<td><small>node()</small></td>
<td><small>node()</small></td>
<td><small><code>op:is-same-node</code></small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>node-before</code>(A, B)</small></td>
<td><small>node()</small></td>
<td><small>node()</small></td>
<td><small><code>op:node-before</code></small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>node-after</code>(A, B)</small></td>
<td><small>node()</small></td>
<td><small>node()</small></td>
<td><small><code>op:node-after</code></small></td>
<td><small><code>xs:boolean</code></small></td>
</tr>
</tbody>
</table>
<table border="1" summary="Unary operators">
<caption>Unary Operators</caption>
<tbody>
<tr>
<th colspan="1"><small>Internal Function</small></th>
<th colspan="1"><small><a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">1</font></sub></small></th>
<th colspan="1"><small>Denotes</small></th>
<th colspan="1"><small><a href=
"#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size=
"2">3</font></sub></small></th>
</tr>
<tr>
<td><small><em>fs:</em><code>unary-plus</code>(A)</small></td>
<td><small><code>xs:integer</code></small></td>
<td><small>op:numeric-unary-plus(A)</small></td>
<td><small><code>xs:integer</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>unary-plus</code>(A)</small></td>
<td><small><code>xs:decimal</code></small></td>
<td><small>op:numeric-unary-plus(A)</small></td>
<td><small><code>xs:decimal</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>unary-plus</code>(A)</small></td>
<td><small><code>xs:float</code></small></td>
<td><small>op:numeric-unary-plus(A)</small></td>
<td><small><code>xs:float</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>unary-plus</code>(A)</small></td>
<td><small><code>xs:double</code></small></td>
<td><small>op:numeric-unary-plus(A)</small></td>
<td><small><code>xs:double</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>unary-minus</code>(A)</small></td>
<td><small><code>xs:integer</code></small></td>
<td><small>op:numeric-unary-minus(A)</small></td>
<td><small><code>xs:integer</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>unary-minus</code>(A)</small></td>
<td><small><code>xs:decimal</code></small></td>
<td><small>op:numeric-unary-minus(A)</small></td>
<td><small><code>xs:decimal</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>unary-minus</code>(A)</small></td>
<td><small><code>xs:float</code></small></td>
<td><small>op:numeric-unary-minus(A)</small></td>
<td><small><code>xs:float</code></small></td>
</tr>
<tr>
<td><small><em>fs:</em><code>unary-minus</code>(A)</small></td>
<td><small><code>xs:double</code></small></td>
<td><small>op:numeric-unary-minus(A)</small></td>
<td><small><code>xs:double</code></small></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="div1">
<h2><a name="sec_importing_schema" id="sec_importing_schema"></a>D
Importing Schemas</h2>
<p>This section describes how XML Schema declarations, as specified
by XML Schema are imported into the [XPath/XQuery] type system.</p>
<div class="div2">
<h3><a name="sec_import_intro" id="sec_import_intro"></a>D.1
Introduction</h3>
<p>During schema import processing, the [XPath/XQuery] environment
imports XML Schema declarations and loads them as declarations in
the [XPath/XQuery] type system. The semantics of that loading
process is defined by normalization rules that map XML Schema
descriptions into the [XPath/XQuery] type system.</p>
<div class="div3">
<h4><a name="sec_import_features" id=
"sec_import_features"></a>D.1.1 Features</h4>
<p>Here is summarized the XML Schema features which are covered by
the formal semantics, and handled by the import mapping described
in this section. For each feature, the following indications are
used.</p>
<ul>
<li>
<p><b>Handled</b> indicates features that are relevant for
[XPath/XQuery], are modeled in the [XPath/XQuery] type system, and
are supported by the mapping.</p>
</li>
<li>
<p><b>Not in v1.0</b> indicates features that are relevant to
[XPath/XQuery], but are not yet modeled in the [XPath/XQuery] type
system or are not handled by the mapping in XQuery V1.0. In case
the [XPath/XQuery] type system provides appropriate support for
those features, but the mapping is incomplete, the additional
annotation <b>mapping only</b> is used.</p>
</li>
<li>
<p><b>Not handled</b> indicates features that are relevant for
[XPath/XQuery], but are not modeled in the [XPath/XQuery] type
system, and are not handled by the mapping. Such features are
typically only related to validation, for which the formal
semantics defines a partial model.</p>
</li>
<li>
<p><b>Ignored</b> Indicates features that are not relevant for
[XPath/XQuery], are not modeled in the [XPath/XQuery] type system,
and are not relevant for the mapping. Such features might have to
do with documentation of the schema, or might affect which Schemas
are legal, but do not affect which documents match which
Schemas.</p>
</li>
</ul>
<p>Here is the exhaustive list of XML Schema features and their
status in this document.</p>
<table summary="" class="figure">
<col align="left" span="1" />
<col align="center" span="1" />
<col align="left" span="1" />
<tbody>
<tr>
<td><b>Feature:</b></td>
<td><b>Supported</b></td>
</tr>
<tr>
<td>Primitive Simple types</td>
<td>Handled</td>
</tr>
<tr>
<td>Simple type derivation by restriction</td>
<td>Handled</td>
</tr>
<tr>
<td>Derivation by list and union</td>
<td>Handled</td>
</tr>
<tr>
<td>Facets on simple types</td>
<td>Not handled</td>
</tr>
<tr>
<td>ID and IDREF constraints</td>
<td>Ignored</td>
</tr>
<tr>
<td>Attribute Declarations</td>
<td></td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;default,fixed,use</td>
<td>Not in v1.0</td>
</tr>
<tr>
<td>Element Declarations</td>
<td></td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;default, fixed (value constraint)</td>
<td>Not in v1.0</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;nillable</td>
<td>Handled</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;substitution group affiliation</td>
<td>Handled</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;substitution group exclusions</td>
<td>Ignored</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;disallowed substitutions</td>
<td>Ignored</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;abstract</td>
<td>Not in v1.0</td>
</tr>
<tr>
<td>Complex Type Definitions</td>
<td></td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;derivation by restriction</td>
<td>Handled</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;derivation by extension</td>
<td>Handled</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;final</td>
<td>Ignored</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;abstract</td>
<td>Not in v1.0</td>
</tr>
<tr>
<td>AttributeUses</td>
<td></td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;required</td>
<td>Not in v1.0, mapping only</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;default, fixed (value constraint)</td>
<td>Not in v1.0</td>
</tr>
<tr>
<td>Attribute Group Definitions</td>
<td>Not in v1.0, mapping only</td>
</tr>
<tr>
<td>Model Group Definitions</td>
<td>Not in v1.0, mapping only</td>
</tr>
<tr>
<td>Model Groups</td>
<td>Handled</td>
</tr>
<tr>
<td>Particles</td>
<td>Handled</td>
</tr>
<tr>
<td>Wildcards</td>
<td></td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;process contents strict, skip, lax</td>
<td>Ignored</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;namespace wild cards.</td>
<td>Ignored</td>
</tr>
<tr>
<td>Identity-constraint Definitions</td>
<td>Ignored</td>
</tr>
<tr>
<td>Notation Declarations</td>
<td>Ignored</td>
</tr>
<tr>
<td>Annotations</td>
<td>Ignored</td>
</tr>
</tbody>
</table>
<p>Note that the schema import feature specified here assumes it is
given a legal schema as input. As a result, it is not necessary to
check for 'block' or 'abstract' attributes.</p>
</div>
<div class="div3">
<h4><a name="sec_import_organization" id=
"sec_import_organization"></a>D.1.2 Organization</h4>
<p>The presentation of the schema mapping is done according to the
following organization.</p>
<p><b>Schema component</b></p>
<p>First each schema component is summarized using the same
notation used in the XML Representation Summary sections in XML
Schema. For instance, here is the XML Representation Summary for
complex types.</p>
<div class="exampleInner">
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;complexType</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> abstract = boolean : false</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> block = (#all | List of (extension |
restriction))</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> final = (#all | List of (extension |
restriction))</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> id = ID</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; mixed = boolean :
false</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; name = NCName</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> {any schemaAttributes with non-schema namespace
...} &gt;</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; Content:
(annotation?, (simpleContent | complexContent | ((group | all |
choice | sequence)?, ((schemaAttribute | schemaAttributeGroup)*,
anySchemaAttribute?))))</td>
</tr>
<tr>
<td>&#160;&#160;&lt;/complexType&gt;</td>
</tr>
</tbody>
</table>
</div>
<p>Attributes indicated as <b>[ ignored ]</b> are not mapped into
the [XPath/XQuery] type system.</p>
<p>Attributes indicated as <b>[ not handled ]</b> are not currently
handled by the mapping.</p>
<p>Note that in order to simplify the mapping, it is assumed that
the default values for all attributes in the XML Representation of
Schema are filled in. For instance in the above complex type, if
the <code>mixed</code> attribute is not present, it will be treated
as being present and having the value <code>"false"</code>.</p>
<p><b>Schema mapping</b></p>
<p>XML Schema import is specified by means of mapping rules. All
mapping rules have the structure below.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>SchemaComponent</em><font size=
"6">]</font><sub><font size="2">Subscript</font></sub></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<em>TypeComponent</em></td>
</tr>
</table>
</div>
<p>The <em>SchemaComponent</em> above the horizontal rule denotes
an XML Schema component before translation and the
<em>TypeComponent</em> beneath the horizontal rule denotes an
equivalent type component in the [XPath/XQuery] type system.</p>
<p><b>Notation</b></p>
<p>Whenever necessary for the mapping rules, specific grammar
productions which describe fragments of XML Schema may be
introduced. For instance, here are grammar productions used to
describes fragments of the XML Representation Summary for the
complexType Element Information Item.</p>
<h5><a name="d6e75185" id="d6e75185"></a>Complex type content</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e69846.doc-fs-ComplexTypeContent" id=
"noid_d3e69846.doc-fs-ComplexTypeContent"></a>[<small>57&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code>ComplexTypeContent</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"annotation"? ("simpleContent" | "complexContent" |
(<a href="#doc-fs-ChildrenContent">ChildrenContent</a> <a href=
"#doc-fs-AttributeContent">AttributeContent</a>))</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e69847.doc-fs-AttributeContent" id=
"noid_d3e69847.doc-fs-AttributeContent"></a>[<small>60&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code>AttributeContent</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("attribute" | "attributeGroup")*
"anyAttribute"?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d3e69848.doc-fs-ChildrenContent" id=
"noid_d3e69848.doc-fs-ChildrenContent"></a>[<small>58&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code>ChildrenContent</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("group" | "all" | "choice" | "sequence")?</code></td>
</tr>
</tbody>
</table>
<p>As in the rest of this document, some mapping rules may use
fragments of the XML Representation corresponding to the syntactic
categories defined by those grammar productions. For instance, the
following complex type fragment uses the syntactic categories:
<a href="#doc-fs-TypeName"><em>TypeName</em></a>,
<em>ComplexTypeContent</em>, and <em>AttributeContent</em>,
<em>ChildrenContent</em>, and <em>MixedAttribute</em>.</p>
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;complexType</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; name = <a href=
"#doc-fs-TypeName"><em>TypeName</em></a></td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160;
<em>MixedAttribute</em> &gt;</td>
</tr>
<tr>
<td>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;<em>ChildrenContent</em>
<em>AttributeContent</em></td>
</tr>
<tr>
<td>&#160;&#160;&lt;/complexType&gt;</td>
</tr>
</tbody>
</table>
</div>
<div class="div3">
<h4><a name="sec_import_mapping" id="sec_import_mapping"></a>D.1.3
Main mapping rules</h4>
<p><b>Notation</b></p>
<p id="jd_map_schema">The normalization rule</p>
<div align="center">
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>Schema</em><font size="6">]</font><a href=
"#jd_map_schema" class="judgment"><sub><font size=
"2">Schema</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<em>Definitions</em></td>
</tr>
</table>
</div>
</div>
<p>maps a complete schema into a set of <em>Definitions</em> in the
[XPath/XQuery] type system.</p>
<p id="jd_map_definition">The normalization rule</p>
<div align="center">
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>SchemaComponent</em><font size="6">]</font><a href=
"#jd_map_definition" class="judgment"><sub><font size=
"2">definition(targetNCName)</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><a href=
"#sec_top_level_definitions"><em>Definition</em></a></td>
</tr>
</table>
</div>
</div>
<p>maps a top level schema component into a <a href=
"#sec_top_level_definitions"><em>Definition</em></a> in the
[XPath/XQuery] type system, given the target namespace
<em>target</em><em>AnyURI</em>.</p>
<p id="jd_map_content">The normalization rule</p>
<div align="center">
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>SchemaComponent</em><font size="6">]</font><a href=
"#jd_map_content" class="judgment"><sub><font size=
"2">content(targetNCName)</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<em>TypeComponent</em></td>
</tr>
</table>
</div>
</div>
<p>maps a schema component not directly under the schema element,
into a <em>TypeComponent</em> in the [XPath/XQuery] type system,
given the target namespace <em>target</em><em>AnyURI</em>.</p>
</div>
<div class="div3">
<h4><a name="sec_use" id="sec_use"></a>D.1.4 Special
attributes</h4>
<p>The XML Schema attributes: use, default, fixed, minOccurs,
maxOccurs, mixed, nillable, and substitutionGroup, require specific
mapping rules.</p>
<div class="div4">
<h5><a name="sec_import_attributes" id=
"sec_import_attributes"></a>D.1.4.1 use, default, and fixed</h5>
<p>The "use", "default", and "fixed" attributes are used to
describe the occurrence and default behavior of a given
attribute.</p>
<p><b>Notation</b></p>
<p>The following auxiliary grammar productions are used to describe
the "use", "default", and "fixed" attributes.</p>
<h5><a name="d6e75385" id="d6e75385"></a>Use, default, and fixed
attributes</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-UseAttribute" id=
"doc-fs-UseAttribute"></a>[<small>61&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-UseAttribute">UseAttribute</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"use" "=" ("optional" | "prohibited" |
"required")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-DefaultAttribute" id=
"doc-fs-DefaultAttribute"></a>[<small>62&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-DefaultAttribute">DefaultAttribute</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"default" "=" String</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-FixedAttribute" id=
"doc-fs-FixedAttribute"></a>[<small>63&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-FixedAttribute">FixedAttribute</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"fixed" "=" String</code></td>
</tr>
</tbody>
</table>
<p id="jd_map_use">The normalization rule</p>
<div align="center">
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>UseAttribute</em> <em>DefaultAttribute</em>?
<em>FixedAttribute</em>? <font size="6">]</font><a href=
"#jd_map_use" class="judgment"><sub><font size=
"2">use</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<em>OccurrenceIndicator</em></td>
</tr>
</table>
</div>
</div>
<p>maps a combination of a use attribute <em>UseAttribute</em>,
along with an optional default or fixed attribute in Schema into
the occurrence indicator <em>OccurrenceIndicator</em> in the
[XPath/XQuery] type system.</p>
<p><b>Schema mapping</b></p>
<p>Use attributes are mapped to the type system in the following
way. In case there is a default or fixed attribute, the attribute
is always present in the PSVI and the use attribute is ignored.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><em>UseAttribute</em>
<em>DefaultAttribute</em><a href="#jd_map_use" class=
"judgment"><sub><font size="2">use</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">1</td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><em>UseAttribute</em>
<em>FixedAttribute</em><a href="#jd_map_use" class=
"judgment"><sub><font size="2">use</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">1</td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">use =
"optional"<a href="#jd_map_use" class="judgment"><sub><font size=
"2">use</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">?</td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">use =
"required"<a href="#jd_map_use" class="judgment"><sub><font size=
"2">use</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">1</td>
</tr>
</table>
</div>
<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&#160;</td>
</tr>
<tr>
<td colspan="2" align="left" valign="top">Issue: how derivation of
attribute declaration and the "prohibited" use attributes are
mapped in the [XPath/XQuery] type system is still an open
issue.</td>
</tr>
</table>
</div>
<div class="div4">
<h5><a name="prod-formal-OccursAttributes" id=
"prod-formal-OccursAttributes"></a>D.1.4.2 minOccurs, maxOccurs,
minLength, maxLength, and length</h5>
<p><b>Notation</b></p>
<p>The following auxiliary grammar productions are used to describe
occurrence attributes and the length facets.</p>
<h5><a name="d6e75507" id="d6e75507"></a>Occurrence attributes</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-OccursAttributes" id=
"doc-fs-OccursAttributes"></a>[<small>56&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-OccursAttributes">OccursAttributes</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-fs-maxOccurs">maxOccurs</a> | <a href=
"#doc-fs-minOccurs">minOccurs</a> | <a href=
"#doc-fs-maxLength">maxLength</a> | <a href=
"#doc-fs-minLength">minLength</a> | <a href=
"#doc-fs-length">length</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-maxOccurs" id=
"doc-fs-maxOccurs"></a>[<small>54&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-maxOccurs">maxOccurs</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"maxOccurs" "=" ("nonNegativeInteger" |
"unbounded")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-minOccurs" id=
"doc-fs-minOccurs"></a>[<small>55&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-minOccurs">minOccurs</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"minOccurs" "=" "nonNegativeInteger"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-maxLength" id=
"doc-fs-maxLength"></a>[<small>51&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-maxLength">maxLength</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"maxLength" "=" "nonNegativeInteger"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-minLength" id=
"doc-fs-minLength"></a>[<small>52&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-minLength">minLength</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"minLength" "=" "nonNegativeInteger"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-length" id=
"doc-fs-length"></a>[<small>53&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-length">length</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"length" "=" "nonNegativeInteger"</code></td>
</tr>
</tbody>
</table>
<p id="jd_map_occurs">The normalization rule</p>
<div align="center">
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><a href=
"#prod-formal-OccursAttributes"><em>OccursAttributes</em></a><font size="6">]</font><a href="#jd_map_occurs"
class="judgment"><sub><font size="2">occurs</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<em>OccurrenceIndicator</em></td>
</tr>
</table>
</div>
</div>
<p>maps the occurrence attributes and facets <a href=
"#prod-formal-OccursAttributes"><em>OccursAttributes</em></a> in
Schema into the occurrence indicator <em>OccurrenceIndicator</em>
in the [XPath/XQuery] type system.</p>
<p><b>Schema mapping</b></p>
<p>Occurrence attributes are mapped to the type system in the
following way.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>minOccurs="0" maxOccurs="1"<font size=
"6">]</font><a href="#jd_map_occurs" class=
"judgment"><sub><font size="2">occurs</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">?</td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>minOccurs="1" maxOccurs="1"<font size=
"6">]</font><a href="#jd_map_occurs" class=
"judgment"><sub><font size="2">occurs</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"></td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>minOccurs="0" maxOccurs="n"<font size=
"6">]</font><a href="#jd_map_occurs" class=
"judgment"><sub><font size="2">occurs</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">*</td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>minOccurs="1" maxOccurs="n"<font size=
"6">]</font><a href="#jd_map_occurs" class=
"judgment"><sub><font size="2">occurs</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">+</td>
</tr>
</table>
</div>
<p>where n &gt; 1.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>minOccurs="n" maxOccurs="m"<font size=
"6">]</font><a href="#jd_map_occurs" class=
"judgment"><sub><font size="2">occurs</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">+</td>
</tr>
</table>
</div>
<p>where m &gt;= n &gt; 1</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>minLength="0" maxLength="1"<font size=
"6">]</font><a href="#jd_map_occurs" class=
"judgment"><sub><font size="2">occurs</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">?</td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>minLength="1" maxLength="1"<font size=
"6">]</font><a href="#jd_map_occurs" class=
"judgment"><sub><font size="2">occurs</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"></td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>minLength="0" maxLength="n"<font size=
"6">]</font><a href="#jd_map_occurs" class=
"judgment"><sub><font size="2">occurs</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">*</td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>minLength="1" maxLength="n"<font size=
"6">]</font><a href="#jd_map_occurs" class=
"judgment"><sub><font size="2">occurs</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">+</td>
</tr>
</table>
</div>
<p>where n &gt; 1.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>minLength="n" maxLength="m"<font size=
"6">]</font><a href="#jd_map_occurs" class=
"judgment"><sub><font size="2">occurs</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">+</td>
</tr>
</table>
</div>
<p>where m &gt;= n &gt; 1</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>length="1"<font size="6">]</font><a href=
"#jd_map_occurs" class="judgment"><sub><font size=
"2">occurs</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"></td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>length="n"<font size="6">]</font><a href=
"#jd_map_occurs" class="judgment"><sub><font size=
"2">occurs</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">+</td>
</tr>
</table>
</div>
<p>where n &gt; 1</p>
</div>
<div class="div4">
<h5><a name="sec_import_mixed" id="sec_import_mixed"></a>D.1.4.3
mixed</h5>
<p><b>Notation</b></p>
<p>The following auxiliary grammar productions are used to describe
the "mixed" attribute.</p>
<h5><a name="d6e75749" id="d6e75749"></a>Mixed attribute</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-MixedAttribute" id=
"doc-fs-MixedAttribute"></a>[<small>48&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-MixedAttribute">MixedAttribute</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"mixed" "=" Boolean</code></td>
</tr>
</tbody>
</table>
<p id="jd_map_mixed">The normalization rule</p>
<div align="center">
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>MixedAttribute</em><font size="6">]</font><a href=
"#jd_map_mixed" class="judgment"><sub><font size=
"2">mixed</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><a href=
"#doc-fs-Mixed"><em>Mixed</em></a></td>
</tr>
</table>
</div>
</div>
<p>maps the mixed attribute <em>MixedAttribute</em> in Schema into
a <a href="#doc-fs-Mixed"><em>Mixed</em></a> notation in the
[XPath/XQuery] type system.</p>
<p><b>Schema mapping</b></p>
<p>If the mixed attribute is true it is mapped to a mixed notation
in the [XPath/XQuery] type system.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font> mixed = "true" <font size="6">]</font><a href=
"#jd_map_mixed" class="judgment"><sub><font size=
"2">mixed</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">mixed</td>
</tr>
</table>
</div>
<p>If the mixed attribute is false it is mapped to empty in the
[XPath/XQuery] type system.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font> mixed = "false" <font size="6">]</font><a href=
"#jd_map_mixed" class="judgment"><sub><font size=
"2">mixed</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"></td>
</tr>
</table>
</div>
</div>
<div class="div4">
<h5><a name="sec_import_nillable" id=
"sec_import_nillable"></a>D.1.4.4 nillable</h5>
<p><b>Notation</b></p>
<p>The following auxiliary grammar productions are used to describe
the "nillable" attribute.</p>
<h5><a name="d6e75834" id="d6e75834"></a>Nillable attribute</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-NillableAttribute" id=
"doc-fs-NillableAttribute"></a>[<small>49&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-NillableAttribute">NillableAttribute</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"nillable" "=" Boolean</code></td>
</tr>
</tbody>
</table>
<p id="jd_map_nillable">The normalization rule</p>
<div align="center">
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>NillableAttribute</em><font size=
"6">]</font><a href="#jd_map_nillable" class=
"judgment"><sub><font size="2">nillable</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><a href=
"#doc-fs-Nillable"><em>Nillable</em></a></td>
</tr>
</table>
</div>
</div>
<p>maps the nillable attribute <em>NillableAttribute</em> in Schema
into a <a href="#doc-fs-Nillable"><em>Nillable</em></a> notation in
the [XPath/XQuery] type system.</p>
<p><b>Schema mapping</b></p>
<p>If the nillable attribute is true it is mapped to a nillable
notation in the [XPath/XQuery] type system.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font> nillable = "true" <font size="6">]</font><a href=
"#jd_map_nillable" class="judgment"><sub><font size=
"2">nillable</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">nillable</td>
</tr>
</table>
</div>
<p>If the nillable attribute is false it is mapped to empty in the
[XPath/XQuery] type system.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font> nillable = "false" <font size="6">]</font><a href=
"#jd_map_nillable" class="judgment"><sub><font size=
"2">nillable</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"></td>
</tr>
</table>
</div>
</div>
<div class="div4">
<h5><a name="sec_import_substitution" id=
"sec_import_substitution"></a>D.1.4.5 substitutionGroup</h5>
<p><b>Notation</b></p>
<p>The substitution group declaration indicates the element that a
given element can be substituted for. The following auxiliary
grammar productions are used to describe the "substitutionGroup"
attribute.</p>
<h5><a name="d6e75919" id="d6e75919"></a>substitutionGroup
attribute</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-substitutionGroupAttribute" id=
"doc-fs-substitutionGroupAttribute"></a>[<small>50&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-substitutionGroupAttribute">substitutionGroupAttribute</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"substitutionGroup" "=" QName</code></td>
</tr>
</tbody>
</table>
<p id="jd_map_substitution">The normalization rule</p>
<div align="center">
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>substitutionGroupAttribute</em><font size=
"6">]</font><a href="#jd_map_substitution" class=
"judgment"><sub><font size="2">substitution</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<em>Substitution</em></td>
</tr>
</table>
</div>
</div>
<p>maps the substitutionGroup attribute
<em>substitutionGroupAttribute</em> in Schema into a
<em>Substitution</em> notation in the [XPath/XQuery] type
system.</p>
<p><b>Schema mapping</b></p>
<p>If the substitutionGroup attribute is present, it is mapped to a
substitutionGroup notation in the [XPath/XQuery] type system.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font> substitutionGroup = <em>QName</em> <font size=
"6">]</font><a href="#jd_map_substitution" class=
"judgment"><sub><font size="2">substitution</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">substitutes for
<em>QName</em></td>
</tr>
</table>
</div>
<p>Otherwise, it is mapped to empty.</p>
</div>
</div>
<div class="div3">
<h4><a name="sec_import_anonymous" id=
"sec_import_anonymous"></a>D.1.5 Anonymous type names</h4>
<p><b>Notation</b></p>
<p>As explained in <a href="#sec_types"><b>[2.4 The [XPath/XQuery]
Type System]</b></a>, the [XPath/XQuery] type uses system-generated
type names for anonymous types. For the purpose of this document
those type names are generated at XML Schema import time.</p>
</div>
</div>
<div class="div2">
<h3><a name="sec_schema_as_a_whole" id=
"sec_schema_as_a_whole"></a>D.2 Schemas as a whole</h3>
<div class="div3">
<h4><a name="sec_import_whole" id="sec_import_whole"></a>D.2.1
Schema</h4>
<p><b>Schema component</b></p>
<p>A schema is represented in XML by the following structure.</p>
<div class="exampleInner">
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;schema</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ not handled
]&#160;&#160;</b> attributeFormDefault = (qualified | unqualified)
: unqualified</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> blockDefault = (#all | List of (extension |
restriction | substitution)) : ' '</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ not handled
]&#160;&#160;</b> elementFormDefault = (qualified | unqualified) :
unqualified</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> finalDefault = (#all | List of (extension |
restriction)) : ' '</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> id = ID</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; targetNamespace =
anyURI</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> version = token</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> xml:lang = language</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> {any attributes with non-schema namespace ...}
&gt;</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; Content: ((include |
import | redefine | annotation)*, (((simpleType | complexType |
group | attributeGroup) | element | attribute | notation),
annotation*)*)</td>
</tr>
<tr>
<td>&#160;&#160;&lt;/schema&gt;</td>
</tr>
</tbody>
</table>
</div>
<p><b>Notation</b></p>
<p>The following auxiliary grammar productions are used.</p>
<h5><a name="d6e76026" id="d6e76026"></a>XML Schema Pragma and
Content</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-SPragma" id=
"doc-fs-SPragma"></a>[<small>46&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-SPragma">SPragma</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("include" | "import" | "redefine" |
"annotation")*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-Content" id=
"doc-fs-Content"></a>[<small>47&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href="#prod-fs-Content">Content</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(("simpleType" | "complexType" | "element" | "attribute"
| "attributeGroup" | "group" | "notation")
"annotation"*)*</code></td>
</tr>
</tbody>
</table>
<p id="jd_map_pragma">The auxiliary normalization rule</p>
<div align="center">
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>Pragma</em><font size="6">]</font><a href=
"#jd_map_pragma" class="judgment"><sub><font size=
"2">pragma(targetAnyURI)</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<em>Definitions</em></td>
</tr>
</table>
</div>
</div>
<p>maps the a schema pragma into a set of definitions in the
[XPath/XQuery] type system.</p>
<p><b>Schema mapping</b></p>
<p>Schemas are imported by the "schema" declaration in the preamble
of a query. To import a schema, the document referred to by the
given URI is opened and the schema declarations contained in the
document are translated into the corresponding in-line type
definitions. The mechanism for finding a schema document, possibly
using the optional schema location hint, is not specified
formally.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>schema <em>StringLiteral</em> (at
<em>StringLiteral</em>)?<font size="6">]</font><a href=
"#jd_map_schema" class="judgment"><sub><font size=
"2">Schema</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>open-schema-document(<em>StringLiteral</em> (at
<em>StringLiteral</em>)?)<font size="6">]</font><a href=
"#jd_map_schema" class="judgment"><sub><font size=
"2">Schema</font></sub></a></td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;schema</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; targetNamespace =
<em>target</em><em>AnyURI</em> &gt;</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <em>Pragma</em>
<em>Content</em></td>
</tr>
<tr>
<td>&#160;&#160;&lt;/schema&gt;</td>
</tr>
</tbody>
</table>
<font size="6">]</font><a href="#jd_map_schema" class=
"judgment"><sub><font size="2">Schema</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>Pragma</em><font size="6">]</font><a href=
"#jd_map_pragma" class="judgment"><sub><font size=
"2">pragma(targetAnyURI)</font></sub></a> <font size=
"6">[</font><em>Content</em><font size="6">]</font><a href=
"#jd_map_definition" class="judgment"><sub><font size=
"2">definition(targetNCName)</font></sub></a></td>
</tr>
</table>
</div>
</div>
<div class="div3">
<h4><a name="sec_import_include" id="sec_import_include"></a>D.2.2
Include</h4>
<p><b>Schema component</b></p>
<p>A schema include is represented in XML by the following
structure.</p>
<div class="exampleInner">
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;include</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> id = ID</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; schemaLocation =
anyURI</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> {any attributes with non-schema namespace ...}
&gt;</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; Content:
(annotation?)</td>
</tr>
<tr>
<td>&#160;&#160;&lt;/include&gt;</td>
</tr>
</tbody>
</table>
</div>
<p><b>Schema mapping</b></p>
<p>A schema include is not specified here, and is assumed to be
handled by the XML Schema processor.</p>
</div>
<div class="div3">
<h4><a name="sec_import_redefine" id=
"sec_import_redefine"></a>D.2.3 Redefine</h4>
<p><b>Schema component</b></p>
<p>A schema redefinition is represented in XML by the following
structure.</p>
<div class="exampleInner">
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;redefine</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> id = ID</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; schemaLocation =
anyURI</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> {any attributes with non-schema namespace ...}
&gt;</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; Content: (annotation
| (simpleType | complexType | group | attributeGroup))*</td>
</tr>
<tr>
<td>&#160;&#160;&lt;/redefine&gt;</td>
</tr>
</tbody>
</table>
</div>
<p><b>Schema mapping</b></p>
<p>A schema redefine is not specified here, and is assumed to be
handled by the XML Schema processor.</p>
</div>
<div class="div3">
<h4><a name="sec_import_import" id="sec_import_import"></a>D.2.4
Import</h4>
<p><b>Schema component</b></p>
<p>A schema import is represented in XML by the following
structure.</p>
<div class="exampleInner">
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;import</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> id = ID</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; namespace =
anyURI</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; schemaLocation =
anyURI</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> {any attributes with non-schema namespace ...}
&gt;</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; Content:
(annotation?)</td>
</tr>
<tr>
<td>&#160;&#160;&lt;/import&gt;</td>
</tr>
</tbody>
</table>
</div>
<p><b>Schema mapping</b></p>
<p>A schema import is not specified here, and is assumed to be
handled by the XML Schema processor.</p>
</div>
</div>
<div class="div2">
<h3><a name="sec_import_attribute_decl" id=
"sec_import_attribute_decl"></a>D.3 Attribute Declarations</h3>
<p><b>Schema component</b></p>
<p>The following structure describes attribute declarations in XML
Schema.</p>
<div class="exampleInner">
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;attribute</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ not handled
]&#160;&#160;</b> default = string</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ not handled
]&#160;&#160;</b> fixed = string</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ not handled
]&#160;&#160;</b> form = (qualified | unqualified)</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> id = ID</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; name = NCName</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; ref = QName</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; type = QName</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; use = (optional |
prohibited | required) : optional</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> {any attributes with non-schema namespace ...}
&gt;</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; Content:
(annotation?, (simpleType?))</td>
</tr>
<tr>
<td>&#160;&#160;&lt;/attribute&gt;</td>
</tr>
</tbody>
</table>
</div>
<div class="div3">
<h4><a name="sec_import_global_attributes" id=
"sec_import_global_attributes"></a>D.3.1 Global attributes
declarations</h4>
<p>Schema import distinguishes between global attribute
declarations and local attribute declarations.</p>
<p><b>Schema mapping</b></p>
<p>Global attribute declarations are mapped like local attribute
declarations, but are prefixed by a "define" keyword in the
[XPath/XQuery] type system.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>AttributeDecl</em><font size="6">]</font><a href=
"#jd_map_definition" class="judgment"><sub><font size=
"2">definition(targetNCName)</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">define <font size=
"6">[</font><em>AttributeDecl</em><font size="6">]</font><a href=
"#jd_map_content" class="judgment"><sub><font size=
"2">content(targetNCName)</font></sub></a></td>
</tr>
</table>
</div>
</div>
<div class="div3">
<h4><a name="sec_import_local_attributes" id=
"sec_import_local_attributes"></a>D.3.2 Local attribute
declarations</h4>
<p><b>Schema mapping</b></p>
<p>Local attributes whose type is given by a reference to a global
type name are mapped in the type system as follows.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;attribute</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; name =
<em>NCName</em></td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; type =
<em>QName</em></td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160;
<em>UseAttribute</em> &#160;/&gt;</td>
</tr>
</tbody>
</table>
<font size="6">]</font><a href="#jd_map_content" class=
"judgment"><sub><font size=
"2">content(targetNCName)</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">( attribute
<em>target</em><em>NCName</em>:<em>NCName</em> { of type
<em>QName</em> } )<font size=
"6">[</font><em>UseAttribute</em><font size="6">]</font><a href=
"#jd_map_use" class="judgment"><sub><font size=
"2">use</font></sub></a></td>
</tr>
</table>
</div>
<p>References to a global attribute are mapped in the type system
as follows.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;attribute</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; ref =
<em>QName</em></td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160;
<em>UseAttribute</em> &#160;/&gt;</td>
</tr>
</tbody>
</table>
<font size="6">]</font><a href="#jd_map_content" class=
"judgment"><sub><font size=
"2">content(targetNCName)</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">( attribute
<em>QName</em> )<font size=
"6">[</font><em>UseAttribute</em><font size="6">]</font><a href=
"#jd_map_use" class="judgment"><sub><font size=
"2">use</font></sub></a></td>
</tr>
</table>
</div>
<p>A local attribute with a local content is mapped to the
[XPath/XQuery] type system as follows. Let
<em>fs:</em>anon<sub><font size="2">k</font></sub> be a newly
generated anonymous name.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;attribute</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; name =
<em>NCName</em></td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160;
<em>UseAttribute</em> &gt;</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160;
<em>simpleType</em></td>
</tr>
<tr>
<td>&#160;&#160;&lt;/attribute&gt;</td>
</tr>
</tbody>
</table>
<font size="6">]</font><a href="#jd_map_content" class=
"judgment"><sub><font size=
"2">content(targetNCName)</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<table summary="">
<tbody>
<tr>
<td>( attribute <em>target</em><em>NCName</em>:<em>NCName</em> of
type <em>fs:</em>anon<sub><font size="2">k</font></sub>
)<font size="6">[</font><em>UseAttribute</em><font size=
"6">]</font><a href="#jd_map_use" class="judgment"><sub><font size=
"2">use</font></sub></a></td>
</tr>
<tr>
<td>&#160;&#160;with</td>
</tr>
<tr>
<td>define type <em>fs:</em>anon<sub><font size="2">k</font></sub>
of type xs:anySimpleType { <font size=
"6">[</font><em>simpleType</em><font size="6">]</font><a href=
"#jd_map_content" class="judgment"><sub><font size=
"2">content(targetNCName)</font></sub></a> }</td>
</tr>
</tbody>
</table>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="div2">
<h3><a name="sec_import_element" id="sec_import_element"></a>D.4
Element Declarations</h3>
<p><b>Schema component</b></p>
<p>The following structure describes attribute declarations in XML
Schema.</p>
<div class="exampleInner">
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;element</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> abstract = boolean : false</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> block = (#all | List of (extension |
restriction))</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ not handled
]&#160;&#160;</b> default = string</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> final = (#all | List of (extension |
restriction))</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ not handled
]&#160;&#160;</b> fixed = string</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ not handled
]&#160;&#160;</b> form = (qualified | unqualified)</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> id = ID</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; maxOccurs =
(nonNegativeInteger | unbounded) : 1</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; minOccurs =
nonNegativeInteger : 1</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; name = NCName</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; nillable = boolean :
false</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; ref = QName</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; substitutionGroup =
QName</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; type = QName</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> {any attributes with non-schema namespace ...}
&gt;</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; Content:
(annotation?, ((simpleType | complexType)?, (unique | key |
keyref)*))</td>
</tr>
<tr>
<td>&#160;&#160;&lt;/element&gt;</td>
</tr>
</tbody>
</table>
</div>
<div class="div3">
<h4><a name="sec_import_global_element" id=
"sec_import_global_element"></a>D.4.1 Global element
declarations</h4>
<p>Schema import distinguishes between global element declarations
and local element declarations.</p>
<p><b>Schema mapping</b></p>
<p>Global element declarations are mapped like local element
declarations, but are prefixed by a "define" keyword in the
[XPath/XQuery] type system.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;element</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; name =
<em>NCName</em></td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160;
<em>NillableAttribute</em></td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160;
<em>substitutionGroupAttribute</em></td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; type =
<em>QName</em> &#160;/&gt;</td>
</tr>
</tbody>
</table>
<font size="6">]</font><a href="#jd_map_definition" class=
"judgment"><sub><font size=
"2">definition(targetNCName)</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">define element
<em>target</em><em>NCName</em>:<em>NCName</em> <font size=
"6">[</font><em>substitutionGroupAttribute</em><font size=
"6">]</font><a href="#jd_map_substitution" class=
"judgment"><sub><font size="2">substitution</font></sub></a>
<font size="6">[</font><em>NillableAttribute</em><font size=
"6">]</font><a href="#jd_map_nillable" class=
"judgment"><sub><font size="2">nillable</font></sub></a> of type
<em>QName</em></td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;element</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; name =
<em>NCName</em></td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160;
<em>NillableAttribute</em></td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160;
<em>substitutionGroupAttribute</em> &gt;</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <a href=
"#doc-fs-ElementModel"><em>ElementModel</em></a></td>
</tr>
<tr>
<td>&#160;&#160;&lt;/element&gt;</td>
</tr>
</tbody>
</table>
<font size="6">]</font><a href="#jd_map_definition" class=
"judgment"><sub><font size=
"2">definition(targetNCName)</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">define element
<em>target</em><em>NCName</em>:<em>NCName</em> <font size=
"6">[</font><em>substitutionGroupAttribute</em><font size=
"6">]</font><a href="#jd_map_substitution" class=
"judgment"><sub><font size="2">substitution</font></sub></a>
<font size="6">[</font><em>NillableAttribute</em><font size=
"6">]</font><a href="#jd_map_nillable" class=
"judgment"><sub><font size="2">nillable</font></sub></a>
<font size="6">[</font><a href=
"#doc-fs-ElementModel"><em>ElementModel</em></a><font size=
"6">]</font><a href="#jd_map_content" class=
"judgment"><sub><font size=
"2">content(targetNCName)</font></sub></a></td>
</tr>
</table>
</div>
</div>
<div class="div3">
<h4><a name="sec_import_local_element" id=
"sec_import_local_element"></a>D.4.2 Local element
declarations</h4>
<p><b>Schema mapping</b></p>
<p>Local element declarations, but mapped into corresponding
notations in the [XPath/XQuery] type system. Note that substitution
group cannot be declared on local elements.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;element</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <a href=
"#prod-formal-OccursAttributes"><em>OccursAttributes</em></a></td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; name =
<em>NCName</em></td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160;
<em>NillableAttribute</em></td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; type =
<em>QName</em> &#160;/&gt;</td>
</tr>
</tbody>
</table>
<font size="6">]</font><a href="#jd_map_content" class=
"judgment"><sub><font size=
"2">content(targetNCName)</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">( element
<em>target</em><em>NCName</em>:<em>NCName</em> <font size=
"6">[</font><em>NillableAttribute</em><font size=
"6">]</font><a href="#jd_map_nillable" class=
"judgment"><sub><font size="2">nillable</font></sub></a> of type
<em>QName</em> ) <font size="6">[</font><a href=
"#prod-formal-OccursAttributes"><em>OccursAttributes</em></a><font size="6">]</font><a href="#jd_map_occurs"
class="judgment"><sub><font size="2">occurs</font></sub></a></td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;element</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <a href=
"#prod-formal-OccursAttributes"><em>OccursAttributes</em></a></td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; ref = <em>QName</em>
&#160;/&gt;</td>
</tr>
</tbody>
</table>
<font size="6">]</font><a href="#jd_map_content" class=
"judgment"><sub><font size=
"2">content(targetNCName)</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">( element
<em>QName</em> ) <font size="6">[</font><a href=
"#prod-formal-OccursAttributes"><em>OccursAttributes</em></a><font size="6">]</font><a href="#jd_map_occurs"
class="judgment"><sub><font size="2">occurs</font></sub></a></td>
</tr>
</table>
</div>
<p>Let <em>fs:</em>anon<sub><font size="2">k</font></sub> be a
newly generated anonymous name.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;element</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <a href=
"#prod-formal-OccursAttributes"><em>OccursAttributes</em></a></td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; name =
<em>NCName</em></td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160;
<em>NillableAttribute</em> &gt;</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <a href=
"#doc-fs-ElementModel"><em>ElementModel</em></a></td>
</tr>
<tr>
<td>&#160;&#160;&lt;/element&gt;</td>
</tr>
</tbody>
</table>
<font size="6">]</font><a href="#jd_map_definition" class=
"judgment"><sub><font size=
"2">definition(targetNCName)</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">
<table summary="">
<tbody>
<tr>
<td>( element <em>target</em><em>NCName</em>:<em>NCName</em>
<font size="6">[</font><em>NillableAttribute</em><font size=
"6">]</font><a href="#jd_map_nillable" class=
"judgment"><sub><font size="2">nillable</font></sub></a> of type
<em>fs:</em>anon<sub><font size="2">k</font></sub> ) <font size=
"6">[</font><a href=
"#prod-formal-OccursAttributes"><em>OccursAttributes</em></a><font size="6">]</font><a href="#jd_map_occurs"
class="judgment"><sub><font size="2">occurs</font></sub></a></td>
</tr>
<tr>
<td>&#160;&#160;with</td>
</tr>
<tr>
<td>define type <em>fs:</em>anon<sub><font size="2">k</font></sub>
<font size="6">[</font><a href=
"#doc-fs-ElementModel"><em>ElementModel</em></a><font size=
"6">]</font><a href="#jd_map_content" class=
"judgment"><sub><font size=
"2">content(targetNCName)</font></sub></a> }</td>
</tr>
</tbody>
</table>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="div2">
<h3><a name="sec_complex_type" id="sec_complex_type"></a>D.5
Complex Type Definitions</h3>
<p><b>Schema component</b></p>
<p>A complex type definition is represented in XML by the following
structure.</p>
<div class="exampleInner">
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;complexType</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> abstract = boolean : false</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> block = (#all | List of (extension |
restriction))</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> final = (#all | List of (extension |
restriction))</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> id = ID</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; mixed = boolean :
false</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; name = NCName</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> {any attributes with non-schema namespace ...}
&gt;</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; Content:
(annotation?, (simpleContent | complexContent | ((group | all |
choice | sequence)?, ((attribute | attributeGroup)*,
anyAttribute?))))</td>
</tr>
<tr>
<td>&#160;&#160;&lt;/complexType&gt;</td>
</tr>
</tbody>
</table>
</div>
<p><b>Notation</b></p>
<p>The following auxiliary grammar productions are used to describe
the content of a complex type definition.</p>
<h5><a name="d6e76956" id="d6e76956"></a>Complex type content</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-ComplexTypeContent" id=
"doc-fs-ComplexTypeContent"></a>[<small>57&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-ComplexTypeContent">ComplexTypeContent</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"annotation"? ("simpleContent" | "complexContent" |
(<a href="#doc-fs-ChildrenContent">ChildrenContent</a> <a href=
"#doc-fs-AttributeContent">AttributeContent</a>))</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-AttributeContent" id=
"doc-fs-AttributeContent"></a>[<small>60&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-AttributeContent">AttributeContent</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("attribute" | "attributeGroup")*
"anyAttribute"?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-ChildrenContent" id=
"doc-fs-ChildrenContent"></a>[<small>58&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-ChildrenContent">ChildrenContent</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("group" | "all" | "choice" | "sequence")?</code></td>
</tr>
</tbody>
</table>
<div class="div3">
<h4><a name="sec_import_global_complex_type" id=
"sec_import_global_complex_type"></a>D.5.1 Global complex type</h4>
<p>Schema import distinguishes between global complex types (which
are mapped to sort declarations) and local complex types (which are
mapped to type definitions).</p>
<p><b>Schema mapping</b></p>
<p>In the case of global complex types, the mapping rule which
applies is denoted by <font size="6">[</font><font size=
"6">]</font><a href="#jd_map_definition" class=
"judgment"><sub><font size=
"2">definition(targetNCName)</font></sub></a>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;complexType</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160;
<em>MixedAttribute</em></td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; name =
<em>NCName</em> &gt;</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160;
<em>ComplexTypeContent</em></td>
</tr>
<tr>
<td>&#160;&#160;&lt;/complexType&gt;</td>
</tr>
</tbody>
</table>
<font size="6">]</font><a href="#jd_map_definition" class=
"judgment"><sub><font size=
"2">definition(targetNCName)</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">define type
<em>target</em><em>NCName</em>:<em>NCName</em> <font size=
"6">[</font><em>MixedAttribute</em>
<em>ComplexTypeContent</em><font size="6">]</font><a href=
"#jd_map_mixed_content" class="judgment"><sub><font size=
"2">mixed_content(targetNCName)</font></sub></a></td>
</tr>
</table>
</div>
<p>Note that the <code>mixed</code> is passed along in the
normalization rules, in order to map it later on to the appropriate
indication in the [XPath/XQuery] type system.</p>
</div>
<div class="div3">
<h4><a name="sec_import_local_complex_type" id=
"sec_import_local_complex_type"></a>D.5.2 Local complex type</h4>
<p><b>Schema mapping</b></p>
<p>In the case of a local complex types, there must not be a name
attribute and the mapping rule which applies is denoted by
<font size="6">[</font><font size="6">]</font><a href=
"#jd_map_content" class="judgment"><sub><font size=
"2">content(targetNCName)</font></sub></a>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;complexType</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160;
<em>MixedAttribute</em> &gt;</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160;
<em>ComplexTypeContent</em></td>
</tr>
<tr>
<td>&#160;&#160;&lt;/complexType&gt;</td>
</tr>
</tbody>
</table>
<font size="6">]</font><a href="#jd_map_content" class=
"judgment"><sub><font size=
"2">content(targetNCName)</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>MixedAttribute</em>
<em>ComplexTypeContent</em><font size="6">]</font><a href=
"#jd_map_mixed_content" class="judgment"><sub><font size=
"2">mixed_content(targetNCName)</font></sub></a></td>
</tr>
</table>
</div>
<p>Note that the <code>mixed</code> is passed along in the
normalization rules, in order to map it later on to the appropriate
indication in the [XPath/XQuery] type system.</p>
</div>
<div class="div3">
<h4><a name="sec_import_ct_simple" id=
"sec_import_ct_simple"></a>D.5.3 Complex type with simple
content</h4>
<p><b>Schema component</b></p>
<p>A complex type can be of simple content. A simple content is
represented in XML by the following structure.</p>
<div class="exampleInner">
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;simpleContent</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> id = ID</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> {any attributes with non-schema namespace ...}
&gt;</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; Content:
(annotation?, (restriction | extension))</td>
</tr>
<tr>
<td>&#160;&#160;&lt;/simpleContent&gt;</td>
</tr>
</tbody>
</table>
</div>
<p>Derivation by restriction inside a simple content is represented
in XML by the following structure.</p>
<div class="exampleInner">
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;restriction</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; base = QName</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> id = ID</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> {any attributes with non-schema namespace ...}
&gt;</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; Content:
(annotation?, (simpleType?, (minExclusive | minInclusive |
maxExclusive | maxInclusive | totalDigits | fractionDigits | length
| minLength | maxLength | enumeration | whiteSpace | pattern)*)?,
((attribute | attributeGroup)*, anyAttribute?))</td>
</tr>
<tr>
<td>&#160;&#160;&lt;/restriction&gt;</td>
</tr>
</tbody>
</table>
</div>
<p>Derivation by extension inside a simple content is represented
in XML by the following structure.</p>
<div class="exampleInner">
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;extension</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>base</b> =
QName</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> id = ID</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> {any attributes with non-schema namespace ...}
&gt;</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; Content:
(annotation?, ((attribute | attributeGroup)*, anyAttribute?))</td>
</tr>
<tr>
<td>&#160;&#160;&lt;/extension&gt;</td>
</tr>
</tbody>
</table>
</div>
<p><b>Notation</b></p>
<p id="jd_map_mixed_content">The normalization rule</p>
<div align="center">
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>MixedAttribute</em>
<em>ComplexTypeContent</em><font size="6">]</font><a href=
"#jd_map_mixed_content" class="judgment"><sub><font size=
"2">mixed_content(targetNCName)</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><a href=
"#doc-fs-TypeDerivation"><em>TypeDerivation</em></a></td>
</tr>
</table>
</div>
</div>
<p>maps a pair of mixed attribute and complex type content to a
type derivation.</p>
<p><b>Schema mapping</b></p>
<p>A complex types with simple content must not have a
<code>mixed</code> attribute set to "true".</p>
<p>If the simple content is derived by restriction, it is mapped
into a simple type restriction in the [XPath/XQuery] type system.
Only the name of the base atomic type and attributes are mapped,
while the actual simple type restriction is ignored. (Remember that
facets are not captured in the [XPath/XQuery] type system.)</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>
<table summary="">
<tbody>
<tr>
<td>mixed = "false"</td>
<td>
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;simpleContent&gt;</td>
</tr>
<tr>
<td>
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;restriction</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; base =
<em>QName</em> &gt;</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160;
<em>simpleContentRestriction</em> <em>AttributeContent</em></td>
</tr>
<tr>
<td>&#160;&#160;&lt;/restriction&gt;</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td>&#160;&#160;&lt;/simpleContent&gt;</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
<font size="6">]</font><a href="#jd_map_mixed_content" class=
"judgment"><sub><font size=
"2">mixed_content(targetNCName)</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">restricts
<em>QName</em> { <font size=
"6">[</font><em>AttributeContent</em><font size=
"6">]</font><a href="#jd_map_content" class=
"judgment"><sub><font size=
"2">content(targetNCName)</font></sub></a> <em>QName</em> }</td>
</tr>
</table>
</div>
<p>If the simple type is derived by extension, it is mapped into an
extended type specifier into the [XPath/XQuery] type system.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>
<table summary="">
<tbody>
<tr>
<td>mixed = "false"</td>
<td>
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;simpleContent&gt;</td>
</tr>
<tr>
<td>
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;extension</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; base =
<em>QName</em> &gt;</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160;
<em>AttributeContent</em></td>
</tr>
<tr>
<td>&#160;&#160;&lt;/extension&gt;</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td>&#160;&#160;&lt;/simpleContent&gt;</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
<font size="6">]</font><a href="#jd_map_mixed_content" class=
"judgment"><sub><font size=
"2">mixed_content(targetNCName)</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">extends <em>QName</em>
{ <font size="6">[</font><em>AttributeContent</em><font size=
"6">]</font><a href="#jd_map_content" class=
"judgment"><sub><font size=
"2">content(targetNCName)</font></sub></a> }</td>
</tr>
</table>
</div>
</div>
<div class="div3">
<h4><a name="sec_import_ct_complex" id=
"sec_import_ct_complex"></a>D.5.4 Complex type with complex
content</h4>
<p><b>Schema component</b></p>
<p>A complex type can be of complex content. A complex content is
represented in XML by the following structure.</p>
<div class="exampleInner">
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;complexContent</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> id = ID</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; mixed = boolean :
false</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> {any attributes with non-schema namespace ...}
&gt;</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; Content:
(annotation?, (restriction | extension))</td>
</tr>
<tr>
<td>&#160;&#160;&lt;/complexContent&gt;</td>
</tr>
</tbody>
</table>
</div>
<p>Derivation by restriction inside a complex content is
represented in XML by the following structure.</p>
<div class="exampleInner">
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;restriction</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; base = QName</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> id = ID</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> {any attributes with non-schema namespace ...}
&gt;</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; Content:
(annotation?, (group | all | choice | sequence)?, ((attribute |
attributeGroup)*, anyAttribute?))</td>
</tr>
<tr>
<td>&#160;&#160;&lt;/restriction&gt;</td>
</tr>
</tbody>
</table>
</div>
<p>Derivation by extension inside a complex content is represented
in XML by the following structure.</p>
<div class="exampleInner">
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;extension</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>base</b> =
QName</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> id = ID</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> {any attributes with non-schema namespace ...}
&gt;</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; Content:
(annotation?, ((group | all | choice | sequence)?, ((attribute |
attributeGroup)*, anyAttribute?)))</td>
</tr>
<tr>
<td>&#160;&#160;&lt;/extension&gt;</td>
</tr>
</tbody>
</table>
</div>
<p><b>Schema mapping</b></p>
<p>If the complex content is derived by restriction, it is mapped
into a type restriction in the [XPath/XQuery] type system, and
the</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>
<table summary="">
<tbody>
<tr>
<td><em>MixedAttribute</em></td>
<td>
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;complexContent&gt;</td>
</tr>
<tr>
<td>
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;restriction</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; base =
<em>QName</em> &gt;</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <em>annotation</em>?
<em>ChildrenContent</em> <em>AttributeContent</em></td>
</tr>
<tr>
<td>&#160;&#160;&lt;/restriction&gt;</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td>&#160;&#160;&lt;/complexContent&gt;</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
<font size="6">]</font><a href="#jd_map_mixed_content" class=
"judgment"><sub><font size=
"2">mixed_content(targetNCName)</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">restricts
<em>QName</em> <font size=
"6">[</font><em>MixedAttribute</em><font size="6">]</font><a href=
"#jd_map_mixed" class="judgment"><sub><font size=
"2">mixed</font></sub></a> { <font size=
"6">[</font><em>AttributeContent</em><font size=
"6">]</font><a href="#jd_map_content" class=
"judgment"><sub><font size=
"2">content(targetNCName)</font></sub></a> <font size=
"6">[</font><em>ChildrenContent</em><font size="6">]</font><a href=
"#jd_map_content" class="judgment"><sub><font size=
"2">content(targetNCName)</font></sub></a> }</td>
</tr>
</table>
</div>
<p>If the complex content is derived by extension, it is mapped
into an extended type specifier into the [XPath/XQuery] type
system.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>
<table summary="">
<tbody>
<tr>
<td><em>MixedAttribute</em></td>
<td>
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;complexContent&gt;</td>
</tr>
<tr>
<td>
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;extension</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; base =
<em>QName</em> &gt;</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <em>annotation</em>?
<em>ChildrenContent</em> <em>AttributeContent</em></td>
</tr>
<tr>
<td>&#160;&#160;&lt;/extension&gt;</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td>&#160;&#160;&lt;/complexContent&gt;</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
<font size="6">]</font><a href="#jd_map_mixed_content" class=
"judgment"><sub><font size=
"2">mixed_content(targetNCName)</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">extends <em>QName</em>
<font size="6">[</font><em>MixedAttribute</em><font size=
"6">]</font><a href="#jd_map_mixed" class=
"judgment"><sub><font size="2">mixed</font></sub></a> { <font size=
"6">[</font><em>AttributeContent</em><font size=
"6">]</font><a href="#jd_map_content" class=
"judgment"><sub><font size=
"2">content(targetNCName)</font></sub></a> <font size=
"6">[</font><em>ChildrenContent</em><font size="6">]</font><a href=
"#jd_map_content" class="judgment"><sub><font size=
"2">content(targetNCName)</font></sub></a> }</td>
</tr>
</table>
</div>
</div>
</div>
<div class="div2">
<h3><a name="sec_attribute_use" id="sec_attribute_use"></a>D.6
Attribute Uses</h3>
<p>Mapping for attribute uses is given in <a href=
"#sec_use"><b>[D.1.4 Special attributes]</b></a>.</p>
</div>
<div class="div2">
<h3><a name="sec_attribute_group" id="sec_attribute_group"></a>D.7
Attribute Group Definitions</h3>
<div class="div3">
<h4><a name="sec_attribute_group_def" id=
"sec_attribute_group_def"></a>D.7.1 Attribute group
definitions</h4>
<p><b>Schema component</b></p>
<p>Model group definitions are represented in XML by the following
structure.</p>
<div class="exampleInner">
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;attributeGroup</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> id = ID</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; name = NCame</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; ref = QName</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> {any attributes with non-schema namespace ...}
&gt;</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; Content:
(annotation?, ((attribute | attributeGroup)*, anyAttribute?))</td>
</tr>
<tr>
<td>&#160;&#160;&lt;/attributeGroup&gt;</td>
</tr>
</tbody>
</table>
</div>
<p><b>Schema mapping</b></p>
<p>Attribute group definitions are not currently handled by the
mapping. See Issue 501 (FS-Issue-0158).</p>
</div>
<div class="div3">
<h4><a name="sec_import_attribute_group_ref" id=
"sec_import_attribute_group_ref"></a>D.7.2 Attribute group
reference</h4>
<p><b>Schema mapping</b></p>
<p>Attribute group references are not currently handled by the
mapping. See Issue 501 (FS-Issue-0158).</p>
</div>
</div>
<div class="div2">
<h3><a name="sec_import_model" id="sec_import_model"></a>D.8 Model
Group Definitions</h3>
<p><b>Schema component</b></p>
<p>Model group definitions are represented in XML by the following
structure.</p>
<div class="exampleInner">
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;group</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>name</b> = NCame
&gt;</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; Content:
(annotation?, (all | choice | sequence))</td>
</tr>
<tr>
<td>&#160;&#160;&lt;/group&gt;</td>
</tr>
</tbody>
</table>
</div>
<p><b>Schema mapping</b></p>
<p>Model group definitions are not currently handled by the
mapping. See Issue 501 (FS-Issue-0158).</p>
</div>
<div class="div2">
<h3><a name="sec_import_model_groups" id=
"sec_import_model_groups"></a>D.9 Model Groups</h3>
<p>Model groups are either "all", "sequence" or "choice". One can
also refer to a model group definition.</p>
<div class="div3">
<h4><a name="sec_import_all_groups" id=
"sec_import_all_groups"></a>D.9.1 All groups</h4>
<p><b>Schema component</b></p>
<p>All groups are represented in XML by the following
structure.</p>
<div class="exampleInner">
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;all</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> id = ID</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; maxOccurs = 1 :
1</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; minOccurs = (0 | 1)
: 1</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> {any attributes with non-schema namespace ...}
&gt;</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; Content:
(annotation?, element*)</td>
</tr>
<tr>
<td>&#160;&#160;&lt;/all&gt;</td>
</tr>
</tbody>
</table>
</div>
<p><b>Schema mapping</b></p>
<p>All groups are mapped into the "&amp;" operation in the
[XPath/XQuery] type system.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;all</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <a href=
"#prod-formal-OccursAttributes"><em>OccursAttributes</em></a>
&gt;</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160;
<em>Element</em><sub><font size="2">1</font></sub> ...
<em>Element</em><sub><font size="2">n</font></sub></td>
</tr>
<tr>
<td>&#160;&#160;&lt;/all&gt;</td>
</tr>
</tbody>
</table>
<font size="6">]</font><a href="#jd_map_content" class=
"judgment"><sub><font size=
"2">content(targetNCName)</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">(<font size=
"6">[</font><em>Element</em><sub><font size=
"2">1</font></sub><font size="6">]</font><a href="#jd_map_content"
class="judgment"><sub><font size=
"2">content(targetNCName)</font></sub></a> &amp; ... &amp;
<font size="6">[</font><em>Element</em><sub><font size=
"2">n</font></sub><font size="6">]</font><a href="#jd_map_content"
class="judgment"><sub><font size=
"2">content(targetNCName)</font></sub></a>) <font size=
"6">[</font><a href=
"#prod-formal-OccursAttributes"><em>OccursAttributes</em></a><font size="6">]</font><a href="#jd_map_occurs"
class="judgment"><sub><font size="2">occurs</font></sub></a></td>
</tr>
</table>
</div>
</div>
<div class="div3">
<h4><a name="sec_import_choice_groups" id=
"sec_import_choice_groups"></a>D.9.2 Choice groups</h4>
<p><b>Schema component</b></p>
<p>Choice groups are represented in XML by the following
structure.</p>
<div class="exampleInner">
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;choice</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> id = ID</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; maxOccurs =
(nonNegativeInteger | unbounded) : 1</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; minOccurs =
nonNegativeInteger : 1</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> {any attributes with non-schema namespace ...}
&gt;</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; Content:
(annotation?, (element | group | choice | sequence | any)*)</td>
</tr>
<tr>
<td>&#160;&#160;&lt;/choice&gt;</td>
</tr>
</tbody>
</table>
</div>
<p><b>Notation</b></p>
<p>The following auxiliary grammar productions are used to describe
group components.</p>
<h5><a name="d6e77779" id="d6e77779"></a>Group Component</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-fs-GroupComponent" id=
"doc-fs-GroupComponent"></a>[<small>59&#160;(Formal)</small>]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-fs-GroupComponent">GroupComponent</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"element" | "group" | "choice" | "sequence" |
"any"</code></td>
</tr>
</tbody>
</table>
<p><b>Schema mapping</b></p>
<p>Choice groups are mapped into the "|" operation in the
[XPath/XQuery] type system.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;choice</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <a href=
"#prod-formal-OccursAttributes"><em>OccursAttributes</em></a>
&gt;</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160;
<em>GroupComponent</em><sub><font size="2">1</font></sub> ...
<em>GroupComponent</em><sub><font size="2">n</font></sub></td>
</tr>
<tr>
<td>&#160;&#160;&lt;/choice&gt;</td>
</tr>
</tbody>
</table>
<font size="6">]</font><a href="#jd_map_content" class=
"judgment"><sub><font size=
"2">content(targetNCName)</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">(<font size=
"6">[</font><em>GroupComponent</em><sub><font size=
"2">1</font></sub><font size="6">]</font><a href="#jd_map_content"
class="judgment"><sub><font size=
"2">content(targetNCName)</font></sub></a> | ... | <font size=
"6">[</font><em>GroupComponent</em><sub><font size=
"2">n</font></sub><font size="6">]</font><a href="#jd_map_content"
class="judgment"><sub><font size=
"2">content(targetNCName)</font></sub></a>) <font size=
"6">[</font><a href=
"#prod-formal-OccursAttributes"><em>OccursAttributes</em></a><font size="6">]</font><a href="#jd_map_occurs"
class="judgment"><sub><font size="2">occurs</font></sub></a></td>
</tr>
</table>
</div>
</div>
<div class="div3">
<h4><a name="sec_import_sequence_groups" id=
"sec_import_sequence_groups"></a>D.9.3 Sequence groups</h4>
<p><b>Schema component</b></p>
<p>Sequence groups are represented in XML by the following
structure.</p>
<div class="exampleInner">
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;sequence</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> id = ID</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; maxOccurs =
(nonNegativeInteger | unbounded) : 1</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; minOccurs =
nonNegativeInteger : 1</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> {any attributes with non-schema namespace ...}
&gt;</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; Content:
(annotation?, (element | group | choice | sequence | any)*)</td>
</tr>
<tr>
<td>&#160;&#160;&lt;/sequence&gt;</td>
</tr>
</tbody>
</table>
</div>
<p><b>Schema mapping</b></p>
<p>Sequence groups are mapped into the "," operation in the
[XPath/XQuery] type system.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;sequence</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <a href=
"#prod-formal-OccursAttributes"><em>OccursAttributes</em></a>
&gt;</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160;
<em>GroupComponent</em><sub><font size="2">1</font></sub> ...
<em>GroupComponent</em><sub><font size="2">n</font></sub></td>
</tr>
<tr>
<td>&#160;&#160;&lt;/sequence&gt;</td>
</tr>
</tbody>
</table>
<font size="6">]</font><a href="#jd_map_content" class=
"judgment"><sub><font size=
"2">content(targetNCName)</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">(<font size=
"6">[</font><em>GroupComponent</em><sub><font size=
"2">1</font></sub><font size="6">]</font><a href="#jd_map_content"
class="judgment"><sub><font size=
"2">content(targetNCName)</font></sub></a> , ... , <font size=
"6">[</font><em>GroupComponent</em><sub><font size=
"2">n</font></sub><font size="6">]</font><a href="#jd_map_content"
class="judgment"><sub><font size=
"2">content(targetNCName)</font></sub></a>) <font size=
"6">[</font><a href=
"#prod-formal-OccursAttributes"><em>OccursAttributes</em></a><font size="6">]</font><a href="#jd_map_occurs"
class="judgment"><sub><font size="2">occurs</font></sub></a></td>
</tr>
</table>
</div>
</div>
</div>
<div class="div2">
<h3><a name="sec_import_particles" id=
"sec_import_particles"></a>D.10 Particles</h3>
<p>Particles contribute to the definition of content models.</p>
<p>A particle can be either an element reference, a group reference
or a wildcard.</p>
<div class="div3">
<h4><a name="sec_import_element_ref" id=
"sec_import_element_ref"></a>D.10.1 Element reference</h4>
<p><b>Schema component</b></p>
<p>Element reference particles are represented in XML by the
following structure.</p>
<div class="exampleInner">
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;element</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; ref = QName</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; maxOccurs =
(nonNegativeInteger | unbounded) : 1</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; minOccurs =
nonNegativeInteger : 1</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> {any attributes with non-schema namespace ...}
&gt;</td>
</tr>
</tbody>
</table>
</div>
<p><b>Schema mapping</b></p>
<p>Element references are mapped into element references in the
[XPath/XQuery] type system.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;element</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; ref =
<em>QName</em></td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <a href=
"#prod-formal-OccursAttributes"><em>OccursAttributes</em></a>
&#160;/&gt;</td>
</tr>
</tbody>
</table>
<font size="6">]</font><a href="#jd_map_content" class=
"judgment"><sub><font size=
"2">content(targetNCName)</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">element <em>QName</em>
<font size="6">[</font><a href=
"#prod-formal-OccursAttributes"><em>OccursAttributes</em></a><font size="6">]</font><a href="#jd_map_occurs"
class="judgment"><sub><font size="2">occurs</font></sub></a></td>
</tr>
</table>
</div>
</div>
<div class="div3">
<h4><a name="sec_group_ref" id="sec_group_ref"></a>D.10.2 Group
reference</h4>
<p><b>Schema component</b></p>
<p>Group reference particles are represented in XML by the
following structure.</p>
<div class="exampleInner">
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;group</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; ref = QName</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; maxOccurs =
(nonNegativeInteger | unbounded) : 1</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; minOccurs =
nonNegativeInteger : 1</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> {any attributes with non-schema namespace ...}
&gt;</td>
</tr>
</tbody>
</table>
</div>
<p><b>Schema mapping</b></p>
<p>Model group references are not currently handled by the
mapping.</p>
</div>
</div>
<div class="div2">
<h3><a name="sec_import_wildcards" id=
"sec_import_wildcards"></a>D.11 Wildcards</h3>
<div class="div3">
<h4><a name="sec_import_attribute_wildcards" id=
"sec_import_attribute_wildcards"></a>D.11.1 Attribute
wildcards</h4>
<p><b>Schema component</b></p>
<p>Attribute wildcards are represented in XML by the following
structure.</p>
<div class="exampleInner">
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;anyAttribute</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> id = ID</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ not handled
]&#160;&#160;</b> namespace = ((##any | ##other) | List of (anyURI
| (##targetNamespace | ##local)) ) : ##any</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; processContents =
(lax | skip | strict) : strict</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> {any attributes with non-schema namespace ...}
&gt;</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; Content:
(annotation?)</td>
</tr>
<tr>
<td>&#160;&#160;&lt;/anyAttribute&gt;</td>
</tr>
</tbody>
</table>
</div>
<p><b>Schema mapping</b></p>
<p>An attribute wildcard with a "skip" process content is mapped as
an attribute wildcard in the [XPath/XQuery] type system.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;anyAttribute</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; processContents =
"skip" &gt;</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160;
<em>annotation</em>?</td>
</tr>
<tr>
<td>&#160;&#160;&lt;/anyAttribute&gt;</td>
</tr>
</tbody>
</table>
<font size="6">]</font><a href="#jd_map_content" class=
"judgment"><sub><font size=
"2">content(targetNCName)</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">(attribute (*,
<a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>))*</td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;anyAttribute</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; processContents =
"lax" &gt;</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160;
<em>annotation</em>?</td>
</tr>
<tr>
<td>&#160;&#160;&lt;/anyAttribute&gt;</td>
</tr>
</tbody>
</table>
<font size="6">]</font><a href="#jd_map_content" class=
"judgment"><sub><font size=
"2">content(targetNCName)</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">attribute *</td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;anyAttribute</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; processContents =
"strict" &gt;</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160;
<em>annotation</em>?</td>
</tr>
<tr>
<td>&#160;&#160;&lt;/anyAttribute&gt;</td>
</tr>
</tbody>
</table>
<font size="6">]</font><a href="#jd_map_content" class=
"judgment"><sub><font size=
"2">content(targetNCName)</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">attribute *</td>
</tr>
</table>
</div>
<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&#160;</td>
</tr>
<tr>
<td colspan="2" align="left" valign="top">Namespace wildcards are
not handled by the mapping.</td>
</tr>
</table>
</div>
<div class="div3">
<h4><a name="sec_import_element_wildcards" id=
"sec_import_element_wildcards"></a>D.11.2 Element wildcards</h4>
<p><b>Schema component</b></p>
<p>Element wildcards are represented in XML by the following
structure.</p>
<div class="exampleInner">
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;any</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> id = ID</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; maxOccurs =
(nonNegativeInteger | unbounded) : 1</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; minOccurs =
nonNegativeInteger : 1</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ not handled
]&#160;&#160;</b> namespace = ((##any | ##other) | List of (anyURI
| (##targetNamespace | ##local)) ) : ##any</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; processContents =
(lax | skip | strict) : strict</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> {any attributes with non-schema namespace ...}
&gt;</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; Content:
(annotation?)</td>
</tr>
<tr>
<td>&#160;&#160;&lt;/any&gt;</td>
</tr>
</tbody>
</table>
</div>
<p><b>Schema mapping</b></p>
<p>An element wildcard with a "skip" process content is mapped as
an element wildcard in the [XPath/XQuery] type system.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;any</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <a href=
"#prod-formal-OccursAttributes"><em>OccursAttributes</em></a></td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; processContents =
"skip" &gt;</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160;
<em>annotation</em>?</td>
</tr>
<tr>
<td>&#160;&#160;&lt;/any&gt;</td>
</tr>
</tbody>
</table>
<font size="6">]</font><a href="#jd_map_content" class=
"judgment"><sub><font size=
"2">content(targetNCName)</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">( element (*, <a href=
"#dt-xs_untyped"><code>xs:untyped</code></a>) )<font size=
"6">[</font><a href=
"#prod-formal-OccursAttributes"><em>OccursAttributes</em></a><font size="6">]</font><a href="#jd_map_occurs"
class="judgment"><sub><font size="2">occurs</font></sub></a></td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;any</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <a href=
"#prod-formal-OccursAttributes"><em>OccursAttributes</em></a></td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; processContents =
"lax" &gt;</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160;
<em>annotation</em>?</td>
</tr>
<tr>
<td>&#160;&#160;&lt;/any&gt;</td>
</tr>
</tbody>
</table>
<font size="6">]</font><a href="#jd_map_content" class=
"judgment"><sub><font size=
"2">content(targetNCName)</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">( element (*,
<code>xs:anyType</code>) )<font size="6">[</font><a href=
"#prod-formal-OccursAttributes"><em>OccursAttributes</em></a><font size="6">]</font><a href="#jd_map_occurs"
class="judgment"><sub><font size="2">occurs</font></sub></a></td>
</tr>
</table>
</div>
<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&#160;</td>
</tr>
<tr>
<td colspan="2" align="left" valign="top">Element wildcards with a
"lax" or "strict" process content are not handled by the
mapping.</td>
</tr>
</table>
<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&#160;</td>
</tr>
<tr>
<td colspan="2" align="left" valign="top">Namespace wildcards are
not handled by the mapping.</td>
</tr>
</table>
</div>
</div>
<div class="div2">
<h3><a name="sec_import_identity" id="sec_import_identity"></a>D.12
Identity-constraint Definitions</h3>
<p>All identity-constraints definitions are ignored when mapping
into the [XPath/XQuery] type system.</p>
</div>
<div class="div2">
<h3><a name="sec_import_notation" id="sec_import_notation"></a>D.13
Notation Declarations</h3>
<p>All notation declarations are ignored when mapping into the
[XPath/XQuery] type system.</p>
</div>
<div class="div2">
<h3><a name="sec_import_annotation" id=
"sec_import_annotation"></a>D.14 Annotation</h3>
<p>All annotation are ignored when mapping into the [XPath/XQuery]
type system.</p>
</div>
<div class="div2">
<h3><a name="sec_import_simple_type" id=
"sec_import_simple_type"></a>D.15 Simple Type Definitions</h3>
<p><b>Schema component</b></p>
<p>A simple type is represented in XML by the following
structure.</p>
<div class="exampleInner">
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;simpleType</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> final = (#all | (list | union |
restriction))</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> id = ID</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; name = NCName</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> {any attributes with non-schema namespace ...}
&gt;</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; name = NCName</td>
</tr>
<tr>
<td>&#160;&#160;&lt;/simpleType&gt;</td>
</tr>
</tbody>
</table>
</div>
<p>Derivation by restriction inside a simple type is represented in
XML by the following structure.</p>
<div class="exampleInner">
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;restriction</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; base = QName</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> id = ID</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> {any attributes with non-schema namespace ...}
&gt;</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; Content:
(annotation?, (simpleType?, (minExclusive | minInclusive |
maxExclusive | maxInclusive | totalDigits | fractionDigits | length
| minLength | maxLength | enumeration | whiteSpace |
pattern)*)?)</td>
</tr>
<tr>
<td>&#160;&#160;&lt;/restriction&gt;</td>
</tr>
</tbody>
</table>
</div>
<p>Derivation by list inside a simple type is represented in XML by
the following structure.</p>
<div class="exampleInner">
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;list</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> id = ID</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; itemType =
QName</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> {any attributes with non-schema namespace ...}
&gt;</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; Content:
(annotation?, (simpleType?))</td>
</tr>
<tr>
<td>&#160;&#160;&lt;/list&gt;</td>
</tr>
</tbody>
</table>
</div>
<p>Derivation by union inside a simple type is represented in XML
by the following structure.</p>
<div class="exampleInner">
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;union</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> id = ID</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; memberTypes = List
of QName</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <b>[ ignored
]&#160;&#160;</b> {any attributes with non-schema namespace ...}
&gt;</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; Content:
(annotation?, (simpleType*))</td>
</tr>
<tr>
<td>&#160;&#160;&lt;/union&gt;</td>
</tr>
</tbody>
</table>
</div>
<div class="div3">
<h4><a name="sec_import_global_simple_type" id=
"sec_import_global_simple_type"></a>D.15.1 Global simple type
definition</h4>
<p>Schema import distinguishes between global simple types (which
are mapped to sort declarations) and local simple types (which are
mapped to type definitions).</p>
<p><b>Schema mapping</b></p>
<p>In the case of global simple types, the mapping rule which
applies is denoted by <font size="6">[</font><font size=
"6">]</font><a href="#jd_map_definition" class=
"judgment"><sub><font size=
"2">definition(targetNCName)</font></sub></a>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;simpleType</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; name =
<em>NCName</em> &gt;</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160;
<em>SimpleTypeContent</em></td>
</tr>
<tr>
<td>&#160;&#160;&lt;/simpleType&gt;</td>
</tr>
</tbody>
</table>
<font size="6">]</font><a href="#jd_map_definition" class=
"judgment"><sub><font size=
"2">definition(targetNCName)</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">define type
<em>target</em><em>NCName</em>:<em>NCName</em> <font size=
"6">[</font><em>SimpleTypeContent</em><font size=
"6">]</font><a href="#jd_map_simple_content" class=
"judgment"><sub><font size=
"2">simple_content(targetNCName)</font></sub></a></td>
</tr>
</table>
</div>
</div>
<div class="div3">
<h4><a name="sec_import_local_simple_type" id=
"sec_import_local_simple_type"></a>D.15.2 Local simple type
definition</h4>
<p><b>Schema mapping</b></p>
<p>In the case of global simple types, the mapping rule which
applies is denoted by <font size="6">[</font><font size=
"6">]</font><a href="#jd_map_content" class=
"judgment"><sub><font size=
"2">content(targetNCName)</font></sub></a>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;simpleType&gt;</td>
</tr>
<tr>
<td><em>SimpleTypeContent</em></td>
</tr>
<tr>
<td>&#160;&#160;&lt;/simpleType&gt;</td>
</tr>
</tbody>
</table>
<font size="6">]</font><a href="#jd_map_content" class=
"judgment"><sub><font size=
"2">content(targetNCName)</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font><em>SimpleTypeContent</em><font size=
"6">]</font><a href="#jd_map_simple_content" class=
"judgment"><sub><font size=
"2">simple_content(targetNCName)</font></sub></a></td>
</tr>
</table>
</div>
</div>
<div class="div3">
<h4><a name="sec_import_simple_type_content" id=
"sec_import_simple_type_content"></a>D.15.3 Simple type
content</h4>
<p><b>Notation</b></p>
<p id="jd_map_simple_content">The normalization rule <font size=
"6">[</font><font size="6">]</font><a href="#jd_map_simple_content"
class="judgment"><sub><font size=
"2">simple_content(targetNCName)</font></sub></a> maps a simple
type content to a type specifier and an optional occurrence
indicator.</p>
<p><b>Schema mapping</b></p>
<p>If the simple type is derived by restriction, it is mapped into
a simple type restriction in the [XPath/XQuery] type system. The
name of the base atomic type and attributes are mapped. Only the
minLength, maxLength, and length facets in the simple type
restriction are handled. All other properties of the simple-type
restriction are ignored.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;restriction</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; base =
<em>QName</em> &gt;</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160;
<em>simpleContentRestriction</em></td>
</tr>
<tr>
<td>&#160;&#160;&lt;/restriction&gt;</td>
</tr>
</tbody>
</table>
<font size="6">]</font><a href="#jd_map_simple_content" class=
"judgment"><sub><font size=
"2">simple_content(targetNCName)</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">restricts
<em>QName</em> { <em>QName</em> } <font size=
"6">[</font><em>simpleContentRestriction</em><font size=
"6">]</font><a href="#jd_map_occurs" class=
"judgment"><sub><font size="2">occurs</font></sub></a></td>
</tr>
</table>
</div>
<p>If the simple type is derived by list, and its content type does
not constrain the length of the list, it is mapped into a
zero-or-more repetition type into the [XPath/XQuery] type
system.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;list&gt;</td>
</tr>
<tr>
<td><em>SimpleType</em></td>
</tr>
<tr>
<td>&#160;&#160;&lt;/list&gt;</td>
</tr>
</tbody>
</table>
<font size="6">]</font><a href="#jd_map_simple_content" class=
"judgment"><sub><font size=
"2">simple_content(targetNCName)</font></sub></a> <a href=
"#doc-fs-Type"><em>Type</em></a> = <font size=
"6">[</font><em>SimpleType</em><font size="6">]</font><a href=
"#jd_map_content" class="judgment"><sub><font size=
"2">content(targetNCName)</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">{ <a href=
"#doc-fs-Type"><em>Type</em></a> * }</td>
</tr>
</table>
</div>
<p>If the simple type is derived by list, and its content type does
constrain the length of the list, then it is mapped into a
zero-or-more repetition type into the [XPath/XQuery] type
system.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;list&gt;</td>
</tr>
<tr>
<td><em>SimpleType</em></td>
</tr>
<tr>
<td>&#160;&#160;&lt;/list&gt;</td>
</tr>
</tbody>
</table>
<font size="6">]</font><a href="#jd_map_simple_content" class=
"judgment"><sub><font size=
"2">simple_content(targetNCName)</font></sub></a> <a href=
"#doc-fs-Type"><em>Type</em></a> <a href="#jd_quantifier" class=
"judgment">·</a> <em>OccurrenceIndicator</em> = <font size=
"6">[</font><em>SimpleType</em><font size="6">]</font><a href=
"#jd_map_content" class="judgment"><sub><font size=
"2">content(targetNCName)</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">{ <a href=
"#doc-fs-Type"><em>Type</em></a> <a href="#jd_quantifier" class=
"judgment">·</a> <em>OccurrenceIndicator</em> }</td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;list</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; itemType =
<em>QName</em> &#160;/&gt;</td>
</tr>
</tbody>
</table>
<font size="6">]</font><a href="#jd_map_simple_content" class=
"judgment"><sub><font size=
"2">simple_content(targetNCName)</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">{ <em>QName</em>*
}</td>
</tr>
</table>
</div>
<p>If the simple type is derived by union, it is mapped into a
union type into the [XPath/XQuery] type system.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;union&gt;</td>
</tr>
<tr>
<td><em>SimpleType</em><sub><font size="2">1</font></sub> ...
<em>SimpleType</em><sub><font size="2">n</font></sub></td>
</tr>
<tr>
<td>&#160;&#160;&lt;/union&gt;</td>
</tr>
</tbody>
</table>
<font size="6">]</font><a href="#jd_map_simple_content" class=
"judgment"><sub><font size=
"2">simple_content(targetNCName)</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">{ (<font size=
"6">[</font><em>SimpleType</em><font size="6">]</font><a href=
"#jd_map_content" class="judgment"><sub><font size=
"2">content(targetNCName)</font></sub></a> | ... | <font size=
"6">[</font><em>SimpleType</em><sub><font size=
"2">n</font></sub><font size="6">]</font><a href="#jd_map_content"
class="judgment"><sub><font size=
"2">content(targetNCName)</font></sub></a>) }</td>
</tr>
</table>
</div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr>
<td>&#160;</td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;"><font size=
"6">[</font>
<table summary="">
<tbody>
<tr>
<td>&#160;&#160;&lt;union</td>
</tr>
<tr>
<td>&#160;&#160;&#160;&#160;&#160;&#160;&#160; memberTypes =
<em>QName</em><sub><font size="2">1</font></sub> ...
<em>QName</em><sub><font size="2">n</font></sub> &#160;/&gt;</td>
</tr>
</tbody>
</table>
<font size="6">]</font><a href="#jd_map_simple_content" class=
"judgment"><sub><font size=
"2">simple_content(targetNCName)</font></sub></a></td>
</tr>
<tr>
<td align="center"><b>==</b></td>
</tr>
<tr>
<td align="center" style="margin-right:1cm;">{
<em>QName</em><sub><font size="2">1</font></sub> | ... |
<em>QName</em><sub><font size="2">n</font></sub> }</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="appendix_references" id="appendix_references"></a>E
References</h2>
<div class="div2">
<h3><a name="id-normative-references" id=
"id-normative-references"></a>E.1 Normative References</h3>
<dl>
<dt class="label"><span><a name="REC-xml" id=
"REC-xml"></a>XML</span></dt>
<dd>
<div>ERROR: NO REC-xml KNOWN!</div>
</dd>
<dt class="label"><span><a name="XMLNAMES11" id=
"XMLNAMES11"></a>XML Names 1.1</span></dt>
<dd>
<div>World Wide Web Consortium. <em>Namespaces in XML 1.1.</em> W3C
Recommendation. See <a href=
"http://www.w3.org/TR/xml-names11/">http://www.w3.org/TR/xml-names11/</a></div>
</dd>
<dt class="label"><span><a name="xmlschema-1" id=
"xmlschema-1"></a>Schema Part 1</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xmlschema-1/"><cite>XML Schema
Part 1: Structures Second Edition</cite></a>, David Beech, Henry S.
Thompson, Murray Maloney, and Noah Mendelsohn, Editors. World Wide
Web Consortium, 28&#160;Oct&#160;2004. This version is
http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/. The <a href=
"http://www.w3.org/TR/xmlschema-1/">latest version</a> is available
at http://www.w3.org/TR/xmlschema-1/.</div>
</dd>
<dt class="label"><span><a name="xmlschema-2" id=
"xmlschema-2"></a>Schema Part 2</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xmlschema-2/"><cite>XML Schema
Part 2: Datatypes Second Edition</cite></a>, Ashok Malhotra and
Paul V. Biron, Editors. World Wide Web Consortium,
28&#160;Oct&#160;2004. This version is
http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/. The <a href=
"http://www.w3.org/TR/xmlschema-2/">latest version</a> is available
at http://www.w3.org/TR/xmlschema-2/.</div>
</dd>
<dt class="label"><span><a name="xpath-datamodel-11" id=
"xpath-datamodel-11"></a>Data Model</span></dt>
<dd>
<div><a href=
"http://www.w3.org/TR/xpath-datamodel-11/"><cite>XQuery and XPath
Data Model (XDM) 1.1</cite></a>, Norman Walsh, John Snelson,
Editors. World Wide Web Consortium, 15 December 2009. This version
is http://www.w3.org/TR/2009/WD-xpath-datamodel-11-20091215/. The
<a href="http://www.w3.org/TR/xpath-datamodel-11/">latest
version</a> is available at
http://www.w3.org/TR/xpath-datamodel-11/.</div>
</dd>
<dt class="label"><span><a name="xslt-xquery-serialization-11" id=
"xslt-xquery-serialization-11"></a>Data Model Serialization
1.1</span></dt>
<dd>
<div><a href=
"http://www.w3.org/TR/xslt-xquery-serialization-11/"><cite>XSLT and
XQuery Serialization 1.1</cite></a>, Henry Zongaro, Editor. World
Wide Web Consortium, 15 December 2009. This version is
http://www.w3.org/TR/2009/WD-xslt-xquery-serialization-11-20091215/.
The <a href=
"http://www.w3.org/TR/xslt-xquery-serialization-11/">latest
version</a> is available at
http://www.w3.org/TR/xslt-xquery-serialization-11/.</div>
</dd>
<dt class="label"><span><a name="xquery-11" id=
"xquery-11"></a>XQuery 1.1: An XML Query Language</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xquery-11/"><cite>XQuery 1.1: An
XML Query Language</cite></a>, Jonathan Robie, Don Chamberlin,
Michael Dyck, John Snelson, Editors. World Wide Web Consortium, 15
December 2009. This version is
http://www.w3.org/TR/2009/WD-xquery-11-20091215/. The <a href=
"http://www.w3.org/TR/xquery/">latest version</a> is available at
http://www.w3.org/TR/xquery-11/.</div>
</dd>
<dt class="label"><span><a name="xpath-21" id="xpath-21"></a>XML
Path Language (XPath) 2.1</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xpath-21/"><cite>XML Path
Language (XPath) 2.1</cite></a>, Jonathan Robie, Don Chamberlin,
Michael Dyck, John Snelson, Editors. World Wide Web Consortium, 15
December 2009. This version is
http://www.w3.org/TR/2009/WD-xpath-21-20091215/. The <a href=
"http://www.w3.org/TR/xpath-21/">latest version</a> is available at
http://www.w3.org/TR/xpath-21/.</div>
</dd>
<dt class="label"><span><a name="xpath-functions-11" id=
"xpath-functions-11"></a>Functions and Operators 1.1</span></dt>
<dd>
<div><a href=
"http://www.w3.org/TR/xpath-functions-11/"><cite>XQuery and XPath
Functions and Operators 1.1</cite></a>, Michael Kay, Editor. World
Wide Web Consortium, 15 December 2009. This version is
http://www.w3.org/TR/2009/WD-xpath-functions-11-20091215/. The
<a href="http://www.w3.org/TR/xpath-functions-11/">latest
version</a> is available at
http://www.w3.org/TR/xpath-functions-11/.</div>
</dd>
</dl>
</div>
<div class="div2">
<h3><a name="id-non-normative-references" id=
"id-non-normative-references"></a>E.2 Non-normative References</h3>
<dl>
<dt class="label"><span><a name="xmlschema-0" id=
"xmlschema-0"></a>XML Schema Part 0</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xmlschema-0/"><cite>XML Schema
Part 0: Primer Second Edition</cite></a>, Priscilla Walmsley and
David C. Fallside, Editors. World Wide Web Consortium,
28&#160;Oct&#160;2004. This version is
http://www.w3.org/TR/2004/REC-xmlschema-0-20041028/. The <a href=
"http://www.w3.org/TR/xmlschema-0/">latest version</a> is available
at http://www.w3.org/TR/xmlschema-0/.</div>
</dd>
<dt class="label"><span><a name="xquery-11-requirements" id=
"xquery-11-requirements"></a>XQuery 1.1 Requirements</span></dt>
<dd>
<div><a href=
"http://www.w3.org/TR/xquery-11-requirements/"><cite>XQuery 1.1
Requirements</cite></a>, Daniel Engovatov, Jonathan Robie, Editors.
World Wide Web Consortium, 15&#160;December&#160;2009. This version
is http://www.w3.org/TR/2009/WD-xquery-11-requirements-20091215/.
The <a href="http://www.w3.org/TR/xquery-11-requirements">latest
version</a> is available at
http://www.w3.org/TR/xquery-11-requirements/.</div>
</dd>
<dt class="label"><span><a name="xpath-21-requirements" id=
"xpath-21-requirements"></a>XPath 2.1 Requirements</span></dt>
<dd>
<div>ERROR: NO xpath-21-requirements KNOWN!</div>
</dd>
</dl>
</div>
<div class="div2">
<h3><a name="id-background-references" id=
"id-background-references"></a>E.3 Background References</h3>
<dl>
<dt class="label"><span><a name="Languages" id=
"Languages"></a>Languages</span></dt>
<dd>
<div>Handbook of Formal Languages. G. Rozenberg and A. Salomaa,
editors. <em>Springer-Verlag</em>. 1997.</div>
</dd>
<dt class="label"><span><a name="TATA" id=
"TATA"></a>TATA</span></dt>
<dd>
<div>Tree Automata Techniques and Applications. H. Comon and M.
Dauchet and R. Gilleron and F. Jacquemard and D. Lugiez and S.
Tison and M. Tommasi. See <a href=
"http://www.grappa.univ-lille3.fr/tata/">http://www.grappa.univ-lille3.fr/tata/</a>.
1997.</div>
</dd>
</dl>
</div>
</div>
<div class="div1">
<h2><a name="sec_validation_judgments" id=
"sec_validation_judgments"></a>F Auxiliary Judgments for Validation
(Non-Normative)</h2>
<div class="div2">
<h3><a name="sec_validate" id="sec_validate"></a>F.1 Judgments for
the validate expression</h3>
<p>XQuery supports XML Schema validation using the validate
expression. This section gives a non-normative formal semantics of
XML Schema validation, solely for the purpose of specifying its
usage in XQuery.</p>
<p>Specifying XML Schema validation requires a fairly large number
of auxiliary judgments. There are two main judgments used to
describe the semantics of validation.</p>
<ul>
<li>
<p>The "erase" judgment takes a value and removes all type
information from it. This operation is necessary since, in XQuery,
validation can occur both on well-formed or already validated
documents.</p>
</li>
<li>
<p>The "annotate" operation takes an untyped value and a type and
either fails or succeeds by returning a new -validated- value.</p>
</li>
</ul>
<p>Before defining these two judgments, we first introduce the
auxiliary judgments used to describe specific parts of XML Schema's
semantics.</p>
<div class="div3">
<h4><a name="sec_type_resolution" id=
"sec_type_resolution"></a>F.1.1 Type resolution</h4>
<p><b>Notation</b></p>
<p id="jd_resolves_to">The judgments</p>
<div align="center"><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a> <a href=
"#jd_resolves_to" class="judgment"><b>resolves to</b></a> <a href=
"#doc-fs-TypeName"><em>TypeName</em></a> { <a href=
"#doc-fs-Type"><em>Type</em></a> }</div>
<p>and</p>
<div align="center"><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-TypeDerivation"><em>TypeDerivation</em></a> <a href=
"#jd_resolves_to" class="judgment"><b>resolves to</b></a> <a href=
"#doc-fs-TypeName"><em>TypeName</em></a> { <a href=
"#doc-fs-Type"><em>Type</em></a> }</div>
<p>hold when a type reference (resp. a type derivation) resolves to
the given type name and type content.</p>
<p><b>Semantics</b></p>
<p>Those judgments are specified by the following rules.</p>
<p>If the type is omitted, it is resolved as the empty sequence
type.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <span><a href=
"#doc-fs-Derivation"><em>Derivation</em></a>?</span> <span><a href=
"#doc-fs-OptDerivation"><em>OptDerivation</em></a></span> <a href=
"#doc-fs-OptMixed"><em>OptMixed</em></a> { empty } <a href=
"#jd_resolves_to" class="judgment"><b>resolves to</b></a> <a href=
"#doc-fs-TypeName"><em>TypeName</em></a> { <a href=
"#doc-fs-Type"><em>Type</em></a> }</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <span><a href=
"#doc-fs-Derivation"><em>Derivation</em></a>?</span> <span><a href=
"#doc-fs-OptDerivation"><em>OptDerivation</em></a></span> <a href=
"#doc-fs-OptMixed"><em>OptMixed</em></a> { } <a href=
"#jd_resolves_to" class="judgment"><b>resolves to</b></a> <a href=
"#doc-fs-TypeName"><em>TypeName</em></a> { <a href=
"#doc-fs-Type"><em>Type</em></a> }</td>
</tr>
</table>
<br /></div>
<p>In case of a type reference, then the type name is the name of
that type, and the type is taken by resolving the type declaration
of the global type.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-TypeName"><em>TypeName</em></a> <a href=
"#jd_elem_qname_expands_to" class="judgment"><b>of elem/type
expands to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_type_defn" class="env">typeDefn</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>) = define type
<a href="#doc-fs-TypeName"><em>TypeName</em></a> <a href=
"#doc-fs-TypeDerivation"><em>TypeDerivation</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-TypeDerivation"><em>TypeDerivation</em></a> <a href=
"#jd_resolves_to" class="judgment"><b>resolves to</b></a> <a href=
"#doc-fs-TypeName"><em>BaseTypeName</em></a> { <a href=
"#doc-fs-Type"><em>Type</em></a> }</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>of type <a href=
"#doc-fs-TypeName"><em>TypeName</em></a> <a href="#jd_resolves_to"
class="judgment"><b>resolves to</b></a> <a href=
"#doc-fs-TypeName"><em>TypeName</em></a> { <a href=
"#doc-fs-Type"><em>Type</em></a> }</td>
</tr>
</table>
<br /></div>
<p>In the above inference rule, note that <a href=
"#doc-fs-TypeName"><em>BaseTypeName</em></a> is the base type of
the type referred to. So this is indeed the original type name,
<a href="#doc-fs-TypeName"><em>TypeName</em></a>, which must be
returned, and eventually used to annotated the corresponding
element or attribute. However, the type needs to be obtained
through a second application of the <a href="#jd_resolves_to"
class="judgment"><b>resolves to</b></a> judgment.</p>
<p>If the type derivation is a restriction, then the type name is
the name of the base type, and the type is taken from the type
derivation.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-OptMixed"><em>OptMixed</em></a> <a href=
"#doc-fs-Type"><em>Type</em></a> <a href="#jd_adjusts_to" class=
"judgment"><b>adjusts to</b></a> <em>Adjusted</em><a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>restricts <a href=
"#doc-fs-TypeName"><em>TypeName</em></a> <a href=
"#doc-fs-OptMixed"><em>OptMixed</em></a> { <a href=
"#doc-fs-Type"><em>Type</em></a> } <a href="#jd_resolves_to" class=
"judgment"><b>resolves to</b></a> <a href=
"#doc-fs-TypeName"><em>TypeName</em></a> {
<em>Adjusted</em><a href="#doc-fs-Type"><em>Type</em></a> }</td>
</tr>
</table>
<br /></div>
<p>If the type derivation is an extension, then the type name is
the name of the base type, and the type is the base type extended
by the type in the type derivation.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b> <a href=
"#doc-fs-TypeName"><em>TypeName</em></a> <a href=
"#jd_elem_qname_expands_to" class="judgment"><b>of elem/type
expands to</b></a> <a href=
"#id-expanded-qnames"><em>expanded-QName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href=
"#xq_type_defn" class="env">typeDefn</a>(<a href=
"#id-expanded-qnames"><em>expanded-QName</em></a>) = define type
<a href="#doc-fs-TypeName"><em>TypeName</em></a> <span><a href=
"#doc-fs-Derivation"><em>Derivation</em></a>?</span> <span><a href=
"#doc-fs-OptDerivation"><em>OptDerivation</em></a></span> <a href=
"#doc-fs-OptMixed"><em>BaseOptMixed</em></a> {
<em>Base</em><a href="#doc-fs-Type"><em>Type</em></a>? }</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>Base</em><a href=
"#doc-fs-Type"><em>Type</em></a>? <a href="#jd_extended_by" class=
"judgment"><b>extended by</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a> <a href="#jd_extended_by" class=
"judgment"><b>is</b></a> <em>Extended</em><a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-OptMixed"><em>OptMixed</em></a> <em>Extended</em><a href=
"#doc-fs-Type"><em>Type</em></a> <a href="#jd_adjusts_to" class=
"judgment"><b>adjusts to</b></a> <em>Adjusted</em><a href=
"#doc-fs-Type"><em>Type</em></a></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>extends <a href=
"#doc-fs-TypeName"><em>TypeName</em></a> <a href=
"#doc-fs-OptMixed"><em>OptMixed</em></a> { <a href=
"#doc-fs-Type"><em>Type</em></a> } <a href="#jd_resolves_to" class=
"judgment"><b>resolves to</b></a> <a href=
"#doc-fs-TypeName"><em>TypeName</em></a> {
<em>Adjusted</em><a href="#doc-fs-Type"><em>Type</em></a> }</td>
</tr>
</table>
<br /></div>
</div>
<div class="div3">
<h4><a name="sec_interleaving" id="sec_interleaving"></a>F.1.2
Interleaving</h4>
<p><b>Notation</b></p>
<p id="jd_interleave">The judgment</p>
<div align="center"><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_interleave" class=
"judgment"><b>interleave</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_interleave" class=
"judgment"><b>yields</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">3</font></sub></div>
<p>holds if some interleaving of <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> and <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub> yields <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">3</font></sub>. Interleaving is non-deterministic; it is used
for processing all groups.</p>
<p><b>Semantics</b></p>
<p>This judgment is specified by the following rules.</p>
<p>Interleaving two empty sequences yields the empty sequence.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b>() <a href="#jd_interleave"
class="judgment"><b>interleave</b></a> () <a href="#jd_interleave"
class="judgment"><b>yields</b></a> ()</td>
</tr>
</table>
<br /></div>
<p>Otherwise, pick an item from the head of one of the sequences,
and recursively interleave the remainder.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_interleave" class=
"judgment"><b>interleave</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_interleave" class=
"judgment"><b>yields</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">3</font></sub></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Item"><em>Item</em></a>,<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_interleave" class=
"judgment"><b>interleave</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_interleave" class=
"judgment"><b>yields</b></a> <a href=
"#doc-fs-Item"><em>Item</em></a>,<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">3</font></sub></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_interleave" class=
"judgment"><b>interleave</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_interleave" class=
"judgment"><b>yields</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">3</font></sub></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_interleave" class=
"judgment"><b>interleave</b></a> <a href=
"#doc-fs-Item"><em>Item</em></a>,<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_interleave" class=
"judgment"><b>yields</b></a> <a href=
"#doc-fs-Item"><em>Item</em></a>,<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">3</font></sub></td>
</tr>
</table>
<br /></div>
</div>
<div class="div3">
<h4><a name="sec_jd_filter" id="sec_jd_filter"></a>F.1.3 Attribute
filtering</h4>
<p><b>Introduction</b></p>
<p>Finally, we introduce an auxiliary judgment which extracts the
value of a given attribute if it exists. This judgment is not used
in the semantics of step expressions, but in <a href=
"#sec_type_matching"><b>[8.3 Judgments for type matching]</b></a>,
and is based on the other filter judgments.</p>
<p><b>Notation</b></p>
<p id="jd_filter">The judgment</p>
<div align="center"><a href="#doc-fs-Value"><em>Value</em></a>
<a href="#jd_filter" class="judgment"><b>filter</b></a>
@<em>QName</em> <a href="#jd_filter" class=
"judgment"><b>=&gt;</b></a> <a href="#jd_filter" class=
"judgment"><b>absent</b></a></div>
<p>holds if there are no occurrences of the attribute
<em>QName</em> in <a href="#doc-fs-Value"><em>Value</em></a>. The
judgment</p>
<div align="center"><a href="#doc-fs-Value"><em>Value</em></a>
<a href="#jd_filter" class="judgment"><b>filter</b></a>
@<em>QName</em> <a href="#jd_filter" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a></div>
<p>holds if there is one occurrence of the attribute <em>QName</em>
in <a href="#doc-fs-Value"><em>Value</em></a>, and the value of
that attribute is <a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a>.</p>
<p><b>Semantics</b></p>
<p>The <a href="#jd_filter" class="judgment"><b>filter</b></a>
judgments are defined as follows.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><a href="#jd_axis" class=
"judgment"><b>axis</b></a> attribute:: <a href="#jd_axis" class=
"judgment"><b>of</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_axis" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><a href="#jd_test" class=
"judgment"><b>test</b></a> <em>QName</em> <a href="#jd_test" class=
"judgment"><b>with</b></a> attribute <a href="#jd_test" class=
"judgment"><b>of</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_test" class=
"judgment"><b>=&gt;</b></a> ()</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_filter" class=
"judgment"><b>filter</b></a> @<em>QName</em> <a href="#jd_filter"
class="judgment"><b>=&gt;</b></a> <a href="#jd_filter" class=
"judgment"><b>absent</b></a></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><a href="#jd_axis" class=
"judgment"><b>axis</b></a> attribute:: <a href="#jd_axis" class=
"judgment"><b>of</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_axis" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_dyn_env_def" class=
"env">dynEnv</a><b>&#160;|-&#160;</b><a href="#jd_test" class=
"judgment"><b>test</b></a> <em>QName</em> <a href="#jd_test" class=
"judgment"><b>with</b></a> attribute <a href="#jd_test" class=
"judgment"><b>of</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_test" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">3</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">3</font></sub> = attribute <em>QName</em> { <a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a> }</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_filter" class=
"judgment"><b>filter</b></a> @<em>QName</em> <a href="#jd_filter"
class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a></td>
</tr>
</table>
<br /></div>
</div>
<div class="div3">
<h4><a name="sec_erasure" id="sec_erasure"></a>F.1.4 Erasure</h4>
<div class="div4">
<h5><a name="sec_simply_erases" id="sec_simply_erases"></a>F.1.4.1
Simply erases</h5>
<p><b>Notation</b></p>
<p id="jd_simply_erases_to">To define erasure, an auxiliary
judgment is needed. The judgment</p>
<div align="center"><a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a> <a href=
"#jd_simply_erases_to" class="judgment"><b>simply erases to</b></a>
<em>String</em></div>
<p>holds when <a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a> erases to the string
<em>String</em>.</p>
<p><b>Semantics</b></p>
<p>This judgment is specified by the following rules.</p>
<p>The empty sequence erases to the empty string.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>() <a href="#jd_simply_erases_to" class="judgment"><b>simply
erases to</b></a> ""</td>
</tr>
</table>
<br /></div>
<p>The concatenation of two non-empty sequences of values erases to
the concatenation of their erasures with a separating space.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_simply_erases_to" class=
"judgment"><b>simply erases to</b></a>
<em>String</em><sub><font size="2">1</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size=
"2">1</font></sub> != ()</td>
</tr>
<tr align="center" valign="middle">
<td><a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_simply_erases_to" class=
"judgment"><b>simply erases to</b></a>
<em>String</em><sub><font size="2">2</font></sub></td>
</tr>
<tr align="center" valign="middle">
<td><a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size=
"2">2</font></sub> != ()</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size=
"2">1</font></sub>,<a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_simply_erases_to" class=
"judgment"><b>simply erases to</b></a>
<code>fn:concat</code>(<em>String</em><sub><font size=
"2">1</font></sub>," ",<em>String</em><sub><font size=
"2">2</font></sub>)</td>
</tr>
</table>
<br /></div>
<p>An atomic value erases to its string representation as an
instance of <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href=
"#doc-fs-AtomicValueContent"><em>AtomicValueContent</em></a> of
type <a href="#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a>
<a href="#jd_simply_erases_to" class="judgment"><b>simply erases
to</b></a> <em>dm:</em><code>string-value</code>(<a href=
"#doc-fs-AtomicValueContent"><em>AtomicValueContent</em></a>)</td>
</tr>
</table>
<br /></div>
</div>
<div class="div4">
<h5><a name="sec_erases" id="sec_erases"></a>F.1.4.2 Erases</h5>
<p><b>Notation</b></p>
<p id="jd_erases_to">The <a href="#jd_erases_to" class=
"judgment"><b>erases to</b></a> judgment is used in the definition
of the dynamic semantics of validation. The normative dynamic
semantics of validation is specified in <a href=
"http://www.w3.org/TR/xquery#id-validate">Section 3.13 Validate
Expressions</a><sup><small>XQ</small></sup>. The effect of the
validate expression is equivalent to:</p>
<ul>
<li>
<p>serialization of the data model, as described in <a href=
"#xslt-xquery-serialization-11">[Data Model Serialization 1.1]</a>,
followed by</p>
</li>
<li>
<p>validation of the serialized value into a Post-Schema Validated
Infoset, as described in <a href="#xmlschema-1">[Schema Part
1]</a>, followed by</p>
</li>
<li>
<p>construction of a new data model value, as described in <a href=
"#xpath-datamodel-11">[Data Model]</a>.</p>
</li>
</ul>
<p>Erasure is the formal equivalent of serialization followed by
construction of a new data model value in which all element nodes
are labeled with <a href=
"#dt-xs_untyped"><code>xs:untyped</code></a> and all attribute
nodes with <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>.</p>
<p>The judgment</p>
<div align="center"><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_erases_to" class=
"judgment"><b>erases to</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></div>
<p>holds when the erasure of <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> is <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub>.</p>
<p><b>Semantics</b></p>
<p>This judgment is specified by the following rules.</p>
<p>The empty sequence erases to itself.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>() <a href="#jd_erases_to" class="judgment"><b>erases
to</b></a> ()</td>
</tr>
</table>
<br /></div>
<p>The erasure of the concatenation of two values is the
concatenation of their erasure, so long as neither of the two
original values is simple.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_erases_to" class=
"judgment"><b>erases to</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>'&#160;&#160;&#160;&#160;<a href=
"#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> not a simple value</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_erases_to" class=
"judgment"><b>erases to</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub>'&#160;&#160;&#160;&#160;<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub> not a simple value</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>,<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_erases_to" class=
"judgment"><b>erases to</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>',<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub>'</td>
</tr>
</table>
<br /></div>
<p>The erasure of an element is an element that has the same name
and the type <a href="#dt-xs_untyped"><code>xs:untyped</code></a>
and the erasure of the original content.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_erases_to" class=
"judgment"><b>erases to</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>element <a href="#doc-fs-ElementName"><em>ElementName</em></a>
of type <a href="#doc-fs-TypeName"><em>TypeName</em></a> { <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> } <a href="#jd_erases_to" class=
"judgment"><b>erases to</b></a> element <a href=
"#doc-fs-ElementName"><em>ElementName</em></a> of type <a href=
"#dt-xs_untyped"><code>xs:untyped</code></a> { <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub> }</td>
</tr>
</table>
<br /></div>
<p>The erasure of an attribute is an attribute that has the same
name and the type <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> and the
simple erasure of the original content labeled with <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a> <a href=
"#jd_simply_erases_to" class="judgment"><b>simply erases to</b></a>
<em>String</em></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>attribute <a href=
"#doc-fs-AttributeName"><em>AttributeName</em></a> of type <a href=
"#doc-fs-TypeName"><em>TypeName</em></a> { <a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a> } <a href=
"#jd_erases_to" class="judgment"><b>erases to</b></a> attribute
<a href="#doc-fs-AttributeName"><em>AttributeName</em></a> of type
<a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> {
<em>String</em> of type <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> }</td>
</tr>
</table>
<br /></div>
<p>The erasure of a document is a document with the erasure of the
original content.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_erases_to" class=
"judgment"><b>erases to</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>document { <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> } <a href="#jd_erases_to" class=
"judgment"><b>erases to</b></a> document { <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub> }</td>
</tr>
</table>
<br /></div>
<p>The erasure of a text or comment or processing-instruction node
is itself.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>text { <em>String</em> } <a href="#jd_erases_to" class=
"judgment"><b>erases to</b></a> text { <em>String</em> }</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>comment { <em>String</em> } <a href="#jd_erases_to" class=
"judgment"><b>erases to</b></a> comment { <em>String</em> }</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td>processing-instruction <em>NCName</em> { <em>String</em> }
<a href="#jd_erases_to" class="judgment"><b>erases to</b></a>
processing-instruction <em>NCName</em> { <em>String</em> }</td>
</tr>
</table>
<br /></div>
<p>The erasure of a simple value is the corresponding text
node.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a> <a href=
"#jd_simply_erases_to" class="judgment"><b>simply erases to</b></a>
<em>String</em></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a> <a href=
"#jd_erases_to" class="judgment"><b>erases to</b></a> text {
<em>String</em> }</td>
</tr>
</table>
<br /></div>
</div>
</div>
<div class="div3">
<h4><a name="sec_jd_annotate" id="sec_jd_annotate"></a>F.1.5
Annotate</h4>
<p>The <a href="#jd_annotate_as" class="judgment"><b>annotate
as</b></a> judgment is used in the definition of the dynamic
semantics of validation. The normative dynamic semantics of
validation is specified in <a href=
"http://www.w3.org/TR/xquery#id-validate">Section 3.13 Validate
Expressions</a><sup><small>XQ</small></sup>. The effect of the
validate expression is equivalent to:</p>
<ul>
<li>
<p>serialization of the data model, as described in <a href=
"#xslt-xquery-serialization-11">[Data Model Serialization 1.1]</a>,
followed by</p>
</li>
<li>
<p>parsing of the serialized value into the Infoset</p>
</li>
<li>
<p>validation of the Infoset into a Post-Schema Validated Infoset,
as described in <a href="#xmlschema-1">[Schema Part 1]</a>,
followed by</p>
</li>
<li>
<p>construction of a new data model value, as described in <a href=
"#xpath-datamodel-11">[Data Model]</a>.</p>
</li>
</ul>
<p>Annotation is the formal equivalent of schema validation of an
Infoset value into the PSVI followed by construction of a new data
model value. Because the Formal Semantics is defined on data model
values, not the Infoset, annotation is applied to data model values
in which all element nodes are labeled with <a href=
"#dt-xs_untyped"><code>xs:untyped</code></a> and all attribute
nodes with <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> -- that
is, the result of erasure.</p>
<div class="div4">
<h5><a name="sec_simply_annotate" id=
"sec_simply_annotate"></a>F.1.5.1 Simply annotate</h5>
<p><b>Notation</b></p>
<p id="jd_cast_as">The judgment</p>
<div align="center"><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_cast_as" class=
"judgment"><b>simply annotate as</b></a> <em>SimpleType</em> (
<a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a> ) <a href=
"#jd_cast_as" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size=
"2">2</font></sub></div>
<p>holds if the result of casting the <a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size=
"2">1</font></sub> to <em>SimpleType</em> is <a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size=
"2">2</font></sub>.</p>
<p><b>Semantics</b></p>
<p>This judgment is specified by the following rules.</p>
<p>Simply annotating a simple value to a union type yields the
result of simply annotating the simple value to either the first or
second type in the union. Note that simply annotating to the second
type is attempted only if simply annotating to the first type
<em>fails</em>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_cast_as" class=
"judgment"><b>simply annotate as</b></a>
<em>SimpleType</em><sub><font size="2">1</font></sub> (<a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size=
"2">1</font></sub>) <a href="#jd_cast_as" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_cast_as" class=
"judgment"><b>simply annotate as</b></a>
<em>SimpleType</em><sub><font size=
"2">1</font></sub>|<em>SimpleType</em><sub><font size=
"2">2</font></sub> (<a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size=
"2">1</font></sub>) <a href="#jd_cast_as" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_not" class=
"judgment"><b>not</b></a>(<a href="#jd_cast_as" class=
"judgment"><b>simply annotate as</b></a>
<em>SimpleType</em><sub><font size="2">1</font></sub> (<a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size=
"2">1</font></sub>) <a href="#jd_cast_as" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size=
"2">2</font></sub>)</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_cast_as" class=
"judgment"><b>simply annotate as</b></a>
<em>SimpleType</em><sub><font size="2">2</font></sub> (<a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size=
"2">1</font></sub>) <a href="#jd_cast_as" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_cast_as" class=
"judgment"><b>simply annotate as</b></a>
<em>SimpleType</em><sub><font size=
"2">1</font></sub>|<em>SimpleType</em><sub><font size=
"2">2</font></sub> (<a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size=
"2">1</font></sub>) <a href="#jd_cast_as" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
<br /></div>
<p>The simple annotation rules for ?, +, * are similar.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_cast_as" class=
"judgment"><b>simply annotate as</b></a> <em>SimpleType</em>? ( ()
) <a href="#jd_cast_as" class="judgment"><b>=&gt;</b></a> ()</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_cast_as" class=
"judgment"><b>simply annotate as</b></a> <em>SimpleType</em>
(<a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size=
"2">1</font></sub>) <a href="#jd_cast_as" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_cast_as" class=
"judgment"><b>simply annotate as</b></a> <em>SimpleType</em>?
(<a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size=
"2">1</font></sub>) <a href="#jd_cast_as" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_cast_as" class=
"judgment"><b>simply annotate as</b></a> <em>SimpleType</em>* ( ()
) <a href="#jd_cast_as" class="judgment"><b>=&gt;</b></a> ()</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_cast_as" class=
"judgment"><b>simply annotate as</b></a> <em>SimpleType</em>
(<a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size=
"2">1</font></sub>) <a href="#jd_cast_as" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size=
"2">1</font></sub>'</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_cast_as" class=
"judgment"><b>simply annotate as</b></a> <em>SimpleType</em>*
(<a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size=
"2">2</font></sub>) <a href="#jd_cast_as" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size=
"2">2</font></sub>'</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_cast_as" class=
"judgment"><b>simply annotate as</b></a> <em>SimpleType</em>*
(<a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size=
"2">1</font></sub>,<a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size=
"2">2</font></sub>) <a href="#jd_cast_as" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size=
"2">1</font></sub>',<a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size=
"2">2</font></sub>'</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_cast_as" class=
"judgment"><b>simply annotate as</b></a> <em>SimpleType</em>
(<a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size=
"2">1</font></sub>) <a href="#jd_cast_as" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size=
"2">1</font></sub>'</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_cast_as" class=
"judgment"><b>simply annotate as</b></a> <em>SimpleType</em>*
(<a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size=
"2">2</font></sub>) <a href="#jd_cast_as" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size=
"2">2</font></sub>'</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_cast_as" class=
"judgment"><b>simply annotate as</b></a> <em>SimpleType</em>+
(<a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size=
"2">1</font></sub>,<a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size=
"2">2</font></sub>) <a href="#jd_cast_as" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size=
"2">1</font></sub>',<a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size=
"2">2</font></sub>'</td>
</tr>
</table>
<br /></div>
<p>Simply annotating an atomic value to <code>xs:string</code>
yields its string representation.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_cast_as" class=
"judgment"><b>simply annotate as</b></a> <code>xs:string</code>
(<a href="#doc-fs-AtomicValue"><em>AtomicValue</em></a>) <a href=
"#jd_cast_as" class="judgment"><b>=&gt;</b></a>
<em>dm:</em>string-value(<a href=
"#doc-fs-AtomicValue"><em>AtomicValue</em></a>)</td>
</tr>
</table>
<br /></div>
<p>Simply annotating an atomic value to <code>xs:decimal</code>
yields the decimal that results from parsing its string
representation.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_cast_as" class=
"judgment"><b>simply annotate as</b></a> <code>xs:decimal</code>
(<a href="#doc-fs-AtomicValue"><em>AtomicValue</em></a>) <a href=
"#jd_cast_as" class="judgment"><b>=&gt;</b></a>
<code>xs:decimal</code>(<em>dm:</em><code>string-value</code>(<a href="#doc-fs-AtomicValue"><em>AtomicValue</em></a>))</td>
</tr>
</table>
<br /></div>
<p>Similar rules are assumed for the rest of the 19 XML Schema
primitive types.</p>
</div>
<div class="div4">
<h5><a name="sec_nil_annotate" id="sec_nil_annotate"></a>F.1.5.2
Nil-annotate</h5>
<p><b>Notation</b></p>
<p id="jd_nil_annotate_as">The judgment</p>
<div align="center"><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_nil_annotate_as"
class="judgment"><b>nil-annotate as</b></a> <a href=
"#doc-fs-OptNillable"><em>OptNillable</em></a> <a href=
"#doc-fs-Type"><em>Type</em></a> ( <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> ) <a href="#jd_nil_annotate_as" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></div>
<p>holds if it is possible to annotate value <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> as if it had the nillable type <a href=
"#doc-fs-Type"><em>Type</em></a> and <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub> is the corresponding annotated value.</p>
<p><b>Semantics</b></p>
<p>This judgment is specified by the following rules.</p>
<p>If the type is not nillable, then the xsi:nil attribute must not
appear in the value, and it must be possible to annotate value
<a href="#doc-fs-Value"><em>Value</em></a> as if it had the type
<a href="#doc-fs-Type"><em>Type</em></a>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_filter" class=
"judgment"><b>filter</b></a> @xsi:nil <a href="#jd_filter" class=
"judgment"><b>=&gt;</b></a> <a href="#jd_filter" class=
"judgment"><b>absent</b></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_annotate_as"
class="judgment"><b>annotate as</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a> ( <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> ) <a href="#jd_annotate_as" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_nil_annotate_as"
class="judgment"><b>nil-annotate as</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a> ( <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> ) <a href="#jd_nil_annotate_as" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
<br /></div>
<p>If the type is nillable, and the xsi:nil attribute does not
appear or is false, then it must be possible to annotate value
<a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> as if it had the type <a href=
"#doc-fs-Type"><em>Type</em></a>.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_filter" class=
"judgment"><b>filter</b></a> @xsi:nil <a href="#jd_filter" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a> <a href=
"#jd_isin" class="judgment"><b>in</b></a> { (), false }</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_annotate_as"
class="judgment"><b>annotate as</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a> ( <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> ) <a href="#jd_annotate_as" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_nil_annotate_as"
class="judgment"><b>nil-annotate as</b></a> nillable <a href=
"#doc-fs-Type"><em>Type</em></a> ( <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> ) <a href="#jd_nil_annotate_as" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
<br /></div>
<p>If the type is nillable, and the xsi:nil attribute is true, then
it must be possible to annotate value <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> as if it had a type where the attributes in the
type are kept and the element content of the type is ignored.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_filter" class=
"judgment"><b>filter</b></a> @xsi:nil <a href="#jd_filter" class=
"judgment"><b>=&gt;</b></a> true</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_annotate_as"
class="judgment"><b>annotate as</b></a> <a href=
"#doc-fs-AttributeModel"><em>AttributeModel</em></a> ( <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> ) <a href="#jd_annotate_as" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_nil_annotate_as"
class="judgment"><b>nil-annotate as</b></a> nillable (<a href=
"#doc-fs-AttributeModel"><em>AttributeModel</em></a>, <a href=
"#doc-fs-ElementModel"><em>ElementModel</em></a>) ( <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> ) <a href="#jd_nil_annotate_as" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
<br /></div>
</div>
<div class="div4">
<h5><a name="sec_annotate" id="sec_annotate"></a>F.1.5.3
Annotate</h5>
<p id="jd_annotate_as">The <a href="#jd_annotate_as" class=
"judgment"><b>annotate as</b></a> judgment is used in the
definition of the dynamic semantics of validation. The normative
dynamic semantics of validation is specified in <a href=
"http://www.w3.org/TR/xquery#id-validate">Section 3.13 Validate
Expressions</a><sup><small>XQ</small></sup>. The effect of the
validate expression is equivalent to:</p>
<ul>
<li>
<p>serialization of the data model, as described in <a href=
"#xslt-xquery-serialization-11">[Data Model Serialization 1.1]</a>,
followed by</p>
</li>
<li>
<p>parsing of the serialized value into the Infoset</p>
</li>
<li>
<p>validation of the Infoset into a Post-Schema Validated Infoset,
as described in <a href="#xmlschema-1">[Schema Part 1]</a>,
followed by</p>
</li>
<li>
<p>construction of a new data model value, as described in <a href=
"#xpath-datamodel-11">[Data Model]</a>.</p>
</li>
</ul>
<p>Erasure is the formal equivalent of serialization followed by
construction of a new data model value in which all element nodes
are labeled with <a href=
"#dt-xs_untyped"><code>xs:untyped</code></a> and all attribute
nodes with <a href=
"#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>.</p>
<p><b>Notation</b></p>
<p>The judgment</p>
<div align="center"><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_annotate_as"
class="judgment"><b>annotate as</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a> ( <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> ) <a href="#jd_annotate_as" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></div>
<p>holds if it is possible to annotate value <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> as if it had type <a href=
"#doc-fs-Type"><em>Type</em></a> and <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub> is the corresponding annotated value.</p>
<p><b>Note</b></p>
<p>Assume an XML Infoset instance X1 is validated against an XML
Schema S, yielding PSVI instance X2. Then if X1 corresponds to
<a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> and S corresponds to <a href=
"#doc-fs-Type"><em>Type</em></a> and X2 corresponds to <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub>, the following should hold: <a href=
"#jd_annotate_as" class="judgment"><b>annotate as</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a> ( <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> ) <a href="#jd_annotate_as" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub>.</p>
<p><b>Semantics</b></p>
<p>This judgment is specified by the following rules.</p>
<p>Annotating the empty sequence as the empty type yields the empty
sequence.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_annotate_as"
class="judgment"><b>annotate as</b></a> empty (()) <a href=
"#jd_annotate_as" class="judgment"><b>=&gt;</b></a> ()</td>
</tr>
</table>
<br /></div>
<p>Annotating a concatenation of values as a concatenation of types
yields the concatenation of the annotated values.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_annotate_as"
class="judgment"><b>annotate as</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
(<a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>) <a href="#jd_annotate_as" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>'</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_annotate_as"
class="judgment"><b>annotate as</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
(<a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub>) <a href="#jd_annotate_as" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub>'</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_annotate_as"
class="judgment"><b>annotate as</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>,<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
(<a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>,<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub>) <a href="#jd_annotate_as" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>',<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub>'</td>
</tr>
</table>
<br /></div>
<p>Annotating a value as a choice type yields the result of
annotating the value as either the first or second type in the
choice.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_annotate_as"
class="judgment"><b>annotate as</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
(<a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>) <a href="#jd_annotate_as" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_annotate_as"
class="judgment"><b>annotate as</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>|<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
(<a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>) <a href="#jd_annotate_as" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_annotate_as"
class="judgment"><b>annotate as</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
(<a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>) <a href="#jd_annotate_as" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_annotate_as"
class="judgment"><b>annotate as</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">1</font></sub>|<a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
(<a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>) <a href="#jd_annotate_as" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
<br /></div>
<p>Annotating a value as an all group uses interleaving to
decompose the original value and recompose the annotated value.</p>
<table border="1" summary="Editorial note">
<tr>
<td align="left" valign="top" width="50%"><b>Editorial
note</b></td>
<td align="right" valign="top" width="50%">&#160;</td>
</tr>
<tr>
<td colspan="2" align="left" valign="top">Jerome and Phil: Note
that this may reorder the original sequence. Perhaps we should
disallow such reordering. Specifying that formally is not as easy
as we would like.</td>
</tr>
</table>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_annotate_as"
class="judgment"><b>annotate as</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
( <a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> ) <a href="#jd_annotate_as" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>'</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_annotate_as"
class="judgment"><b>annotate as</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
( <a href="#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub> ) <a href="#jd_annotate_as" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub>'</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub> <a href="#jd_interleave" class=
"judgment"><b>interleave</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub> <a href="#jd_interleave" class=
"judgment"><b>yields</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>' <a href="#jd_interleave" class=
"judgment"><b>interleave</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub>' <a href="#jd_interleave" class=
"judgment"><b>yields</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a>'</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_annotate_as"
class="judgment"><b>annotate as</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
&amp; <a href="#doc-fs-Type"><em>Type</em></a><sub><font size=
"2">2</font></sub> ( <a href="#doc-fs-Value"><em>Value</em></a> )
<a href="#jd_annotate_as" class="judgment"><b>=&gt;</b></a>
<a href="#doc-fs-Value"><em>Value</em></a>'</td>
</tr>
</table>
<br /></div>
<p>The annotation rules for ?, +, * are similar.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_annotate_as"
class="judgment"><b>annotate as</b></a> (<a href=
"#doc-fs-Type"><em>Type</em></a> | empty)(<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>) <a href="#jd_annotate_as" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_annotate_as"
class="judgment"><b>annotate as</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a>? (<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>) <a href="#jd_annotate_as" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_annotate_as"
class="judgment"><b>annotate as</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a> (<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>) <a href="#jd_annotate_as" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>'&#160;&#160;&#160;&#160;<a href=
"#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_annotate_as"
class="judgment"><b>annotate as</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a>* (<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub>) <a href="#jd_annotate_as" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub>'</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_annotate_as"
class="judgment"><b>annotate as</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a>+ (<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>,<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub>) <a href="#jd_annotate_as" class=
"judgment"><b>=&gt;</b></a> (<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>',<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub>')</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_annotate_as"
class="judgment"><b>annotate as</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a>* ( () ) <a href="#jd_annotate_as"
class="judgment"><b>=&gt;</b></a> ()</td>
</tr>
</table>
<br /></div>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_annotate_as"
class="judgment"><b>annotate as</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a> (<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>) <a href="#jd_annotate_as" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>'&#160;&#160;&#160;&#160;<a href=
"#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_annotate_as"
class="judgment"><b>annotate as</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a>* (<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub>) <a href="#jd_annotate_as" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub>'</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_annotate_as"
class="judgment"><b>annotate as</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a>* (<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>,<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub>) <a href="#jd_annotate_as" class=
"judgment"><b>=&gt;</b></a> (<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">1</font></sub>',<a href=
"#doc-fs-Value"><em>Value</em></a><sub><font size=
"2">2</font></sub>')</td>
</tr>
</table>
<br /></div>
<p>To annotate an element with no xsi:type attribute, first look up
the element type, next resolve the resulting type reference, then
annotate the value against the resolved type, and finally return a
new element with the name of the original element, the resolved
type name, and the annotated value.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#doc-fs-Value"><em>Value</em></a> <a href="#jd_filter"
class="judgment"><b>filter</b></a> @xsi:type <a href="#jd_filter"
class="judgment"><b>=&gt;</b></a> ()</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-ElementName"><em>ElementName</em></a> <a href="#jd_lookup"
class="judgment"><b>name lookup</b></a> <a href=
"#doc-fs-ElementType"><em>ElementType</em></a> <a href="#jd_lookup"
class="judgment"><b>yields</b></a> <a href=
"#doc-fs-OptNillable"><em>OptNillable</em></a> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a> <a href=
"#jd_resolves_to" class="judgment"><b>resolves to</b></a> <a href=
"#doc-fs-TypeName"><em>TypeName</em></a> { <a href=
"#doc-fs-Type"><em>Type</em></a> }</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_nil_annotate_as"
class="judgment"><b>nil-annotate as</b></a> <a href=
"#doc-fs-OptNillable"><em>OptNillable</em></a> <a href=
"#doc-fs-Type"><em>Type</em></a> (<a href=
"#doc-fs-Value"><em>Value</em></a>) <a href="#jd_nil_annotate_as"
class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a>'</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_annotate_as"
class="judgment"><b>annotate as</b></a> <a href=
"#doc-fs-ElementType"><em>ElementType</em></a> ( element <a href=
"#doc-fs-ElementName"><em>ElementName</em></a> of type
<code>xs:anyType</code> { <a href=
"#doc-fs-Value"><em>Value</em></a> } ) <a href="#jd_annotate_as"
class="judgment"><b>=&gt;</b></a> element <a href=
"#doc-fs-ElementName"><em>ElementName</em></a> of type <a href=
"#doc-fs-TypeName"><em>TypeName</em></a> { <a href=
"#doc-fs-Value"><em>Value</em></a>' }</td>
</tr>
</table>
<br /></div>
<p>To annotate an element with an xsi:type attribute, define a type
reference corresponding to the xsi:type. Look up the element type,
yielding a type reference, and check that the xsi:type reference
derives from this type reference. Resolve the xsi:type reference,
then annotate the value against the resolved type, and finally
return a new element with the name of the original element, the
resolved type name, and the annotated value.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#doc-fs-Value"><em>Value</em></a> <a href="#jd_filter"
class="judgment"><b>filter</b></a> @xsi:type <a href="#jd_filter"
class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-TypeName"><em>TypeName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><em>Xsi</em><a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a> = of type
<a href="#doc-fs-TypeName"><em>TypeName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-ElementName"><em>ElementName</em></a> <a href="#jd_lookup"
class="judgment"><b>name lookup</b></a> <a href=
"#doc-fs-ElementType"><em>ElementType</em></a> <a href="#jd_lookup"
class="judgment"><b>yields</b></a> <a href=
"#doc-fs-OptNillable"><em>OptNillable</em></a> of type <a href=
"#doc-fs-TypeName"><em>BaseTypeName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-TypeName"><em>TypeName</em></a> <a href="#jd_derives_from"
class="judgment"><b>derives from</b></a> <a href=
"#doc-fs-TypeName"><em>BaseTypeName</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><em>Xsi</em><a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a> <a href=
"#jd_resolves_to" class="judgment"><b>resolves to</b></a> <a href=
"#doc-fs-TypeName"><em>TypeName</em></a> { <a href=
"#doc-fs-Type"><em>Type</em></a> }</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_nil_annotate_as"
class="judgment"><b>nil-annotate as</b></a> <a href=
"#doc-fs-OptNillable"><em>OptNillable</em></a> <a href=
"#doc-fs-Type"><em>Type</em></a> (<a href=
"#doc-fs-Value"><em>Value</em></a>) <a href="#jd_nil_annotate_as"
class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a>'</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_annotate_as"
class="judgment"><b>annotate as</b></a> <a href=
"#doc-fs-ElementType"><em>ElementType</em></a> ( element <a href=
"#doc-fs-ElementName"><em>ElementName</em></a> of type
<code>xs:anyType</code> { <a href=
"#doc-fs-Value"><em>Value</em></a> } ) <a href="#jd_annotate_as"
class="judgment"><b>=&gt;</b></a> element <a href=
"#doc-fs-ElementName"><em>ElementName</em></a> of type <a href=
"#doc-fs-TypeName"><em>TypeName</em></a> { <a href=
"#doc-fs-Value"><em>Value</em></a>' }</td>
</tr>
</table>
<br /></div>
<p>The rule for attributes is similar to the first rule for
elements.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td>
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-AttributeName"><em>AttributeName</em></a> <a href=
"#jd_attribute_lookup" class="judgment"><b>name lookup</b></a>
<a href="#doc-fs-AttributeType"><em>AttributeType</em></a> <a href=
"#jd_attribute_lookup" class="judgment"><b>yields</b></a> <a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href=
"#doc-fs-TypeReference"><em>TypeReference</em></a> <a href=
"#jd_resolves_to" class="judgment"><b>resolves to</b></a> <a href=
"#doc-fs-TypeName"><em>TypeName</em></a> { <a href=
"#doc-fs-Type"><em>Type</em></a> }</td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_nil_annotate_as"
class="judgment"><b>nil-annotate as</b></a> <a href=
"#doc-fs-OptNillable"><em>OptNillable</em></a> <a href=
"#doc-fs-Type"><em>Type</em></a> (<a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size=
"2">1</font></sub>) <a href="#jd_nil_annotate_as" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size=
"2">2</font></sub></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_annotate_as"
class="judgment"><b>annotate as</b></a> <a href=
"#doc-fs-AttributeType"><em>AttributeType</em></a> ( attribute
<a href="#doc-fs-AttributeName"><em>AttributeName</em></a> of type
<code>xs:anySimpleType</code> { <a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size=
"2">1</font></sub> } ) <a href="#jd_annotate_as" class=
"judgment"><b>=&gt;</b></a> attribute <a href=
"#doc-fs-AttributeName"><em>AttributeName</em></a> of type <a href=
"#doc-fs-TypeName"><em>TypeName</em></a> { <a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size=
"2">2</font></sub> }</td>
</tr>
</table>
<br /></div>
<p>Annotating a document node yields a document with the annotation
of its contents.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_annotate_as"
class="judgment"><b>annotate as</b></a> <a href=
"#doc-fs-Type"><em>Type</em></a> (<a href=
"#doc-fs-Value"><em>Value</em></a>) <a href="#jd_annotate_as"
class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-Value"><em>Value</em></a>'</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_annotate_as"
class="judgment"><b>annotate as</b></a> document { <a href=
"#doc-fs-Type"><em>Type</em></a> } ( document { <a href=
"#doc-fs-Value"><em>Value</em></a> } ) <a href="#jd_annotate_as"
class="judgment"><b>=&gt;</b></a> document { <a href=
"#doc-fs-Value"><em>Value</em></a>' }</td>
</tr>
</table>
<br /></div>
<p>Annotating a text node as text yields itself.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td></td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_annotate_as"
class="judgment"><b>annotate as</b></a> text (text {
<em>String</em> }) <a href="#jd_annotate_as" class=
"judgment"><b>=&gt;</b></a> text { <em>String</em> }</td>
</tr>
</table>
<br /></div>
<p>Annotating a text nodes as a simple type is identical to
casting.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_cast_as" class=
"judgment"><b>simply annotate as</b></a> <em>SimpleType</em> (
<em>String</em> ) <a href="#jd_cast_as" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a>'</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_annotate_as"
class="judgment"><b>annotate as</b></a> <em>SimpleType</em> ( text
{ <em>String</em> } ) <a href="#jd_annotate_as" class=
"judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a>'</td>
</tr>
</table>
<br /></div>
<p>Annotating a simple value as a simple type is identical to
casting.</p>
<div align="center">
<table summary="" cellspacing="0" cellpadding="0">
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_cast_as" class=
"judgment"><b>simply annotate as</b></a> <em>SimpleType</em> (
<a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a> ) <a href=
"#jd_cast_as" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a>'</td>
</tr>
<tr>
<td>
<hr style="color:black" size="1" noshade="noshade" /></td>
</tr>
<tr align="center" valign="middle">
<td><a href="#xq_stat_env_def" class=
"env">statEnv</a><b>&#160;|-&#160;</b><a href="#jd_annotate_as"
class="judgment"><b>annotate as</b></a> <em>SimpleType</em> (
<a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a> ) <a href=
"#jd_annotate_as" class="judgment"><b>=&gt;</b></a> <a href=
"#doc-fs-SimpleValue"><em>SimpleValue</em></a>'</td>
</tr>
</table>
<br /></div>
</div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="id-fs-revisions-log" id="id-fs-revisions-log"></a>G
Revision Log (Non-Normative)</h2>
<p>This appendix lists the changes that have been made to this
specification since the publication of the Proposed Recommendation
Draft on 21 November 2006.</p>
<ol class="enumar">
<li>
<p>Fixed a number of typos and editorial issues throughout the
document.</p>
</li>
</ol>
</div>
</div>
</body>
</html>

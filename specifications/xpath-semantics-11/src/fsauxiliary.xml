<!-- *************************** Auxiliary judgments **************** -->

<div1 id="sec_auxiliary_judgments">
  <head>Auxiliary Judgments</head>

  <p>This section defines auxiliary judgments used in defining the
  formal semantics.  Many auxiliary judgments are used in both static
  typing and dynamic evaluation rules.  Those auxiliary judgments that
  are used in only the static or dynamic semantics are labeled as
  such.</p>

  <div2 id="sec_accessing_types">
    <head>Judgments for accessing types</head>

    <smintro>
      <p>This section defines several auxiliary judgments to access
      components of the &language; type system. The first two
      judgments (&jd_derives_from; and &jd_substitutes_for;) are used
      to access the type and element name hierarchies in an XML
      Schema. The other judgments (&jd_lookup;, &jd_static_lookup;,
      &jd_extended_by;, &jd_adjusts_to; and &jd_expands_to;) are used
      to lookup the meaning of element or attribute types from the
      schema. These judgments are used in many expressions, notably in
      the specification of type matching (See <specref
      ref="sec_type_matching"/>), validation (See <specref
      ref="sec_validate"/>), and the static semantics of step
      expressions (See <specref ref="sec_auxiliary_xpath"/>).</p>
    </smintro>

    <div3 id="jd_aux_derives_from">
      <head>Derives from</head>
    
      <smnotation>
        <p id="jd_derives_from">The judgment</p>
    
        <display>
          <clause>
          <environment>&xq_stat_env;</environment>
          <expression>&gr_TypeName1; &jd_derives_from; &gr_TypeName2;</expression>
          </clause>
        </display>
    
        <p>holds when &gr_TypeName1; derives from &gr_TypeName2;.
        This judgment formalizes the definition of the
        <code>derives-from</code> function in <xspecref spec="XQ"
        ref="id-sequencetype-matching"/>. </p>

      </smnotation>
    
      <smexample>
        <p>For example, assuming the extended XML Schema given in
        section <specref ref="sec_types_example"/>, then the following
        judgments hold.</p>

<eg><![CDATA[
  USAddress            derives from  xs:anyType
  NYCAddress           derives from  USAddress
  NYCAddress           derives from  xs:anyType
  xsd:positiveInteger  derives from  xsd:integer
  xsd:integer          derives from  xs:anySimpleType
  fs:anon3             derives from  xsd:positiveInteger
  fs:anon3             derives from  xsd:integer
  fs:anon3             derives from  xs:anySimpleType
  fs:anon3             derives from  xs:anyType
]]></eg>

      </smexample>

      <smnote>
        <p>Derivation is a partial order. It is reflexive and
        transitive by the definition below.</p>
      </smnote>

      <smrules>
        <p>This judgment is specified by the following rules.</p>

<!--    
        <p>Some rules have hypotheses that simply list a type,
        element, or attribute declaration.</p>
-->
 
        <p>Every type name derives from itself.</p>
    
      <infergr>
        <infer>
         <prejudge>
         </prejudge>
         <postjudge>
          <clause>
           <environment>&xq_stat_env;</environment>
           <expression>&gr_TypeName; &jd_derives_from; &gr_TypeName;</expression>
          </clause>
         </postjudge>
        </infer>
      </infergr>
    
      <p>Every type name derives from the type it is declared to
      derive from by extension or restriction.</p>
    
      <infergr>
        <infer>
         <prejudge>
         <multiclause>
          <clause>
           <environment>&xq_stat_env;</environment>
           <expression>
             &gr_TypeName; &jd_elem_qname_expands_to; &xd_qname;
           </expression>
          </clause>
         </multiclause>
         <multiclause>
          <clause>
           <expression>
             &xq_type_defn;(&xd_qname;) = define type &gr_TypeName;
             extends &gr_BaseTypeName; &gr_OptMixed; { &gr_Type; }
           </expression>
          </clause>
         </multiclause>
         </prejudge>
         <postjudge>
          <clause>
           <environment>&xq_stat_env;</environment>
             <expression>&gr_TypeName; &jd_derives_from; &gr_BaseTypeName;</expression>
          </clause>
         </postjudge>
        </infer>
      </infergr>
    
      <infergr>
        <infer>
         <prejudge>
         <multiclause>
          <clause>
           <environment>&xq_stat_env;</environment>
           <expression>
             &gr_TypeName; &jd_elem_qname_expands_to; &xd_qname;
           </expression>
          </clause>
         </multiclause>
         <multiclause>

          <clause>
           <expression>
             &xq_type_defn;(&xd_qname;) = define type &gr_TypeName;
             restricts &gr_BaseTypeName; &gr_OptMixed; { &gr_Type; }
           </expression>
          </clause>
</multiclause>
         </prejudge>
         <postjudge>
          <clause>
           <environment>&xq_stat_env;</environment>
             <expression>&gr_TypeName; &jd_derives_from; &gr_BaseTypeName;</expression>
          </clause>
         </postjudge>
        </infer>
      </infergr>

      <p>The above rules all require that the type names be defined in
      the static context, but &language; permits references to
      "unknown" type names, i.e., type names that are not defined in
      the static context.  An unknown type name might be encountered,
      if a module in which the given type name occurs does not import
      the schema in which the given type name is defined. In this
      case, an implementation is allowed (but is not required) to
      provide an implementation-dependent mechanism for determining
      whether the unknown type name is the same as or derived by
      restriction from the expected type name.  The following rule
      formalizes this implementation dependent mechanism.</p>

      <infergr>
        <infer>
         <prejudge>
<multiclause>
          <clause>
           <expression>
             "The implementation is able to determine that
&gr_TypeName1; is derived by
restriction from &gr_TypeName2;."
           </expression>
          </clause>
</multiclause>
         </prejudge>
         <postjudge>
          <clause>
           <environment>&xq_stat_env;</environment>
             <expression>&gr_TypeName1; &jd_derives_from; &gr_TypeName2;</expression>
          </clause>
         </postjudge>
        </infer>
      </infergr>
    
      <p>The derivation relation is transitive.</p>
    
      <infergr>
        <infer>
         <prejudge>
          <clause>
           <environment>&xq_stat_env;</environment>
           <expression>&gr_TypeName1; &jd_derives_from; &gr_TypeName2;</expression>
          </clause>
          <clause>
           <environment>&xq_stat_env;</environment>
           <expression>&gr_TypeName2; &jd_derives_from; &gr_TypeName3;</expression>
          </clause>
         </prejudge>
         <postjudge>
          <clause>
           <environment>&xq_stat_env;</environment>
           <expression>&gr_TypeName1; &jd_derives_from; &gr_TypeName3;</expression>
          </clause>
         </postjudge>
        </infer>
      </infergr>
    
      </smrules>
    </div3>
    
    <div3 id="sec_substitutes">
      <head>Substitutes for</head>

      <p>The substitutes judgment is used to know whether an element
      name is in the substitution group of another element name.</p>
    
      <smnotation>
        <p id="jd_substitutes_for">The judgment</p>
    
        <display>
          <clause>
          <environment>&xq_stat_env;</environment>
          <expression>&gr_ElementName1; &jd_substitutes_for;
          &gr_ElementName2;</expression>
          </clause>
        </display>
    
        <p>holds when &gr_ElementName1; substitutes for
        &gr_ElementName2;.</p>
      </smnotation>

      <smexample>
        <p>For example, assuming the extended XML Schema given in
        section <specref ref="sec_types_example"/>, then the following
        judgments hold.</p>

<eg><![CDATA[
  usaddress  substitutes for  address
  nyaddress  substitutes for  usaddress
  nyaddress  substitutes for  address
]]></eg>
      </smexample>
    
      <smnote>
        <p>Substitution is a partial order.  It is reflexive and
        transitive by the definition below.  It is asymmetric because
        no cycles are allowed in substitution groups.</p>
      </smnote>
    
      <smrules>
        <p>The substitutes judgment for element names is specified by
        the following rules.</p>
    
        <p>Every element name substitutes for itself.</p>
    
        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>&gr_ElementName; &jd_substitutes_for; &gr_ElementName;</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>Every element name substitutes for the element it is
        declared to substitute for.</p>

        <infergr>
          <infer>
           <prejudge>
         <multiclause>
          <clause>
           <environment>&xq_stat_env;</environment>
           <expression>
             &gr_ElementName; &jd_elem_qname_expands_to; &xd_qname;
           </expression>
          </clause>
         </multiclause>
         <multiclause>
            <clause>
             <expression>
               &xq_elem_decl;(&xd_qname;) =
                 define element &gr_ElementName;
                   substitutes for &gr_BaseElementName; &gr_OptNillable; &gr_TypeReference;
             </expression>
            </clause>
         </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>&gr_ElementName; &jd_substitutes_for; &gr_BaseElementName;</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>
    
        <p>Substitution is transitive.</p>
    
        <infergr>
          <infer>
           <prejudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>&gr_ElementName1; &jd_substitutes_for; &gr_ElementName2;</expression>
            </clause>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>&gr_ElementName1; &jd_substitutes_for; &gr_ElementName3;</expression>
            </clause>
           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>&gr_ElementName1; &jd_substitutes_for; &gr_ElementName3;</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>
      </smrules>
    
    </div3>

    <div3 id="sec_element_lookup">
      <head>Element and attribute name lookup (Dynamic)</head>

      <p>The &jd_lookup; judgment is used in the definition of the
      &jd_matches; judgment, which takes a value and a type and
      determines whether the value matches, or is an instance of, the
      given type.  Both &jd_lookup; and &jd_matches; are used in the
      dynamic semantics. </p>

      <p>The &jd_lookup; judgment takes an element(attribute) name
      (derived from a node value) and an element(attribute) type and
      if the element(attribute) name matches the corresponding name in
      the element(attribute) type, the judgment yields the type's
      corresponding type reference and for elements, its nillable
      property.</p>

      <smnotation>
        <p id="jd_lookup">The judgment</p>

        <display>
          <clause>
          <environment>&xq_stat_env;</environment>
          <expression>&gr_ElementName; &jd_lookup; &gr_ElementType;
          &jd_lookup_yields; &gr_OptNillable;
          &gr_TypeReference;</expression>
          </clause>
        </display>

        <p>holds when the given element name matches the given element
        type and requires that the element be nillable as indicated
        and have the given type reference.</p>

      </smnotation>

      <smexample>
        <p>For example, assuming the extended XML Schema given in
        section <specref ref="sec_types_example"/>, then the following
        judgments hold.</p>

<eg><![CDATA[
  comment    name lookup element comment                          yields of type xsd:string
  size       name lookup element size nillable of type xs:integer yields nillable of type xsd:string
  apt        name lookup element apt                              yields of type fs:anon3
  nycaddress name lookup element address                          yields of type NYCAddress
]]></eg>

        <p>Note that when the element name is in a substitution group,
        the name lookup returns the type name corresponding to the
        original element name (here the type <code>NYCAddress</code>
        for the element <code>nycaddress</code>, instead of
        <code>Address</code> for the element
        <code>address</code>).</p>
      </smexample>

      <smrules>
        <p>This judgment is specified by the following rules.</p>

        <p>If the element type is a reference to a global element,
        then name lookup yields the type reference in the element
        declaration for the given element name.  The given element
        name must be in the substitution group of the global
        element.</p>

        <infergr>
          <infer>
           <prejudge>
            <multiclause>
             <clause>
              <environment>&xq_stat_env;</environment>
              <expression>&gr_ElementName1; &jd_substitutes_for; &gr_ElementName2;</expression>
             </clause>
            </multiclause>
         <multiclause>
          <clause>
           <environment>&xq_stat_env;</environment>
           <expression>
             &gr_ElementName1; &jd_elem_qname_expands_to; &xd_qname1;
           </expression>
          </clause>
         </multiclause>
            <multiclause>
             <clause>
              <expression>
                &xq_elem_decl;(&xd_qname1;) =
                  define element &gr_ElementName1;
                    &gr_OptSubstitution; &gr_OptNillable; &gr_TypeReference;
              </expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>&gr_ElementName1; &jd_lookup; element
             &gr_ElementName2; &jd_lookup_yields; &gr_OptNillable;
             &gr_TypeReference;</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>If the given element name matches the element name in the
        element type, and the element type contains a type reference,
        then name lookup yields that type reference.</p>

        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>&gr_ElementName; &jd_lookup; element
             &gr_ElementName; &gr_OptNillable; &gr_TypeReference;
             &jd_lookup_yields; &gr_OptNillable;
             &gr_TypeReference;</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>If the element type has no element name but contains a type
        reference, then name lookup yields the type reference.</p>

        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>&gr_ElementName; &jd_lookup; element<phrase diff='add' at='E023'> *</phrase>
             &gr_TypeReference; &jd_lookup_yields;
             &gr_TypeReference;</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>If the element type has no element name and no type
        reference, then name lookup yields &xs_anyType;.</p>

        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>&gr_ElementName; &jd_lookup; element<phrase diff='add' at='E023'> *</phrase>
             &jd_lookup_yields; of type &xs_anyType;</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

      </smrules>     

      <smnotation>
        <p id="jd_attribute_lookup">The judgment</p>

        <display>
          <clause>
          <environment>&xq_stat_env;</environment>
          <expression>&gr_AttributeName; &jd_attribute_lookup;
          &gr_AttributeType; &jd_attribute_lookup_yields;
          &gr_TypeReference;</expression>
          </clause>
        </display>

        <p>holds when matching an attribute with the given attribute
        name against the given attribute type matches the type
        reference.</p>
      </smnotation>

      <smexample>
        <p>For example, assuming the extended XML Schema given in
        section <specref ref="sec_types_example"/>, then the following
        judgments hold.</p>

<eg><![CDATA[
  orderDate  name lookup  attribute orderDate of type xsd:date  yields  of type xsd:date?
  orderDate  name lookup  attribute of type xsd:date            yields  of type xsd:date?
]]></eg>
      </smexample>

      <smrules>
        <p>This judgment is specified by the following rules.</p>

        <p>If the attribute type is a reference to a global attribute,
        then name lookup yields the type reference in the attribute
        declaration for the given attribute name.</p>

        <infergr>
          <infer>
           <prejudge>
	    <multiclause>
             <clause>
             <environment>&xq_stat_env;</environment>
      <expression>&gr_AttributeName; &jd_attr_qname_expands_to; &xd_qname;</expression>
             </clause>
	    </multiclause>
            <multiclause>
             <clause>
              <expression>
                &xq_attr_decl;(&xd_qname;) =
                  define attribute &gr_AttributeName;
                    &gr_TypeReference;
              </expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>&gr_AttributeName; &jd_attribute_lookup;
             attribute &gr_AttributeName; &jd_attribute_lookup_yields;
             &gr_TypeReference;</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>If the given attribute name matches the attribute name in
        the attribute type, and the attribute type contains a type
        reference, then name lookup yields that type reference.</p>

        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>&gr_AttributeName; &jd_attribute_lookup;
             attribute &gr_AttributeName; &gr_TypeReference;
             &jd_attribute_lookup_yields;
             &gr_TypeReference;</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>If the attribute type has no attribute name but contains a
        type reference, then name lookup yields the type
        reference.</p>

        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>&gr_AttributeName; &jd_attribute_lookup;
             attribute<phrase diff='add' at='E023'> *</phrase> &gr_TypeReference; &jd_attribute_lookup_yields;
             &gr_TypeReference;</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>If the attribute type has no attribute name and no type
        reference, then name lookup yields &xs_anySimpleType;.</p>

        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>&gr_AttributeName; &jd_attribute_lookup;
             attribute<phrase diff='add' at='E023'> *</phrase> &jd_attribute_lookup_yields; of type
             &xs_anySimpleType;</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

      </smrules>     

    </div3>

    <div3 id="jd_aux_static_lookup">
      <head>Element and attribute type lookup (Static)</head>

      <p>The type lookup judgments are used to obtain the
      appropriate type reference for an attribute or element.</p>

      <smnotation>
        <p id="jd_static_lookup">The judgment</p>

        <display>
          <clause>
          <environment>&xq_stat_env;</environment>
          <expression>&gr_ElementType; &jd_static_lookup; &gr_OptNillable;
          &gr_TypeReference;</expression>
          </clause>
        </display>

        <p>holds when the element type is optionally nillable and has
        the given type reference.</p>

      </smnotation>

      <smrules>     
        <p>The element type lookup judgments are specified by the
        following rules.</p>

        <p>A reference to a global element yields the type reference
        in the global element declaration with the given element
        name.</p>

        <infergr>
          <infer>
           <prejudge>
         <multiclause>
          <clause>
           <environment>&xq_stat_env;</environment>
           <expression>
             &gr_ElementName; &jd_elem_qname_expands_to; &xd_qname;
           </expression>
          </clause>
         </multiclause>
            <multiclause>
             <clause>
              <expression>
                &xq_elem_decl;(&xd_qname;) = define element
                  &gr_ElementName; &gr_OptSubstitution; &gr_OptNillable;
                  &gr_TypeReference;
              </expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>element &gr_ElementName; &jd_static_lookup;
             &gr_OptNillable; &gr_TypeReference;</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>In the case of a local element type, type lookup yields the
        corresponding type reference.</p>

        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>element &gr_ElementName; &gr_OptNillable;
             &gr_TypeReference; &jd_static_lookup; &gr_OptNillable;
             &gr_TypeReference;</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>If the element type has no element name but contains a type
        reference, then type lookup yields that type reference.</p>

        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>element<phrase diff='add' at='E023'> *</phrase> &gr_OptNillable; &gr_TypeReference;
             &jd_static_lookup; &gr_TypeReference;</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>If the element type has no element name and no type
        reference, then lookup yields &xs_anyType;.</p>

        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>element<phrase diff='add' at='E023'> *</phrase> &jd_static_lookup; of type
             &xs_anyType;</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

      </smrules>     

      <smnotation>
        <p id="jd_attribute_static_lookup">The judgment</p>

        <display>
          <clause>
          <environment>&xq_stat_env;</environment>
          <expression>&gr_AttributeType; &jd_attribute_static_lookup;
          &gr_TypeReference;</expression>
          </clause>
        </display>

        <p>holds when the attribute type has the  given type reference.</p>
      </smnotation>

      <smrules>
        <p>This judgment is specified by the following rules.</p>

        <p>A reference to a global attribute yields the type reference in
        the global attribute declaration with the given attribute name.</p>

        <infergr>
          <infer>
           <prejudge>
	    <multiclause>
             <clause>
             <environment>&xq_stat_env;</environment>
      <expression>&gr_AttributeName; &jd_attr_qname_expands_to; &xd_qname;</expression>
             </clause>
	    </multiclause>
            <multiclause>
             <clause>
              <expression>
                &xq_attr_decl;(&xd_qname;) =
                  define attribute &gr_AttributeName;
                    &gr_TypeReference;
              </expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>attribute &gr_AttributeName; 
             &jd_attribute_static_lookup;
             &gr_TypeReference;</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

       <p>If the attribute name is not defined, i.e., it is not declared
       in the in-scope schema definitions, then the attribute's
       default type is &xs_untypedAtomic;.</p>

        <infergr>
          <infer>
           <prejudge>
	    <multiclause>
             <clause>
             <environment>&xq_stat_env;</environment>
      <expression>&gr_AttributeName; &jd_attr_qname_expands_to; &xd_qname;</expression>
             </clause>
	    </multiclause>
            <multiclause>
             <clause>
              <expression>
                &xq_attr_decl;(&xd_qname;) undefined
              </expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>attribute &gr_AttributeName;
             &jd_attribute_static_lookup;
             of type &xs_untypedAtomic;</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>In the case of a local attribute type, type lookup yields
        the corresponding type reference.</p>

        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>attribute &gr_AttributeName;
             &gr_TypeReference; &jd_attribute_static_lookup;
             &gr_TypeReference;</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>If the attribute type has no attribute name but contains a
        type reference, then type lookup yields the type
        reference.</p>

        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>attribute<phrase diff='add' at='E023'> *</phrase> &gr_TypeReference; 
             &jd_attribute_static_lookup;
             &gr_TypeReference;</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>If the attribute type has no attribute name and no type
        reference, then type lookup yields &xs_anySimpleType;.</p>

        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>attribute<phrase diff='add' at='E023'> *</phrase> &jd_attribute_static_lookup; of
             type &xs_anySimpleType;</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

      </smrules>     

    </div3>

    <div3 id="sec_extension">
      <head>Extension</head>

      <smnotation>

        <p id="jd_extended_by">The judgment</p>

        <display>
          <clause>
          <environment>&xq_stat_env;</environment>
          <expression>&gr_Type1; &jd_extended_by; &gr_Type2; &jd_extended_by_is; &gr_Type;</expression>
          </clause>
        </display>

        <p>holds when the result of extending &gr_Type1; by &gr_Type2;
        is &gr_Type;.  This judgment is used in the definition of type
        expansion <specref ref="sec_type_expansion"/>, which expands a
        type to include the union of all types derived from the given
        type, </p>
      </smnotation>

      <smrules>
        <p>This judgment is specified by the following rules.</p>

        <infergr>
          <infer>
           <prejudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>&gr_Type1; = &gr_AttributeModel1; , &gr_ElementModel1;</expression>
            </clause>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>&gr_Type2; = &gr_AttributeModel2; , &gr_ElementModel2;</expression>
            </clause>
           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>&gr_Type1; &jd_extended_by; &gr_Type2; &jd_extended_by_is;
                 (&gr_AttributeModel1; &amp; &gr_AttributeModel2;) , &gr_ElementModel1; , &gr_ElementModel2;</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>
      </smrules>
    </div3>


    <div3 id="sec_mixed">
      <head>Mixed content</head>

      <smnotation>
        <p id="jd_mixes_to">The judgment</p>

        <display>
          <clause>
          <environment>&xq_stat_env;</environment>
          <expression>&gr_Type1; &jd_mixes_to; &gr_Type2;</expression>
          </clause>
        </display>

        <p>holds when the result of creating a mixed content from
        &gr_Type1; is &gr_Type2;.</p>
      </smnotation>

      <smrules>
        <p>This judgment is specified by the following rule, which
        interleaves the element content with a sequence of text nodes
        and adds a union of &xs_anyAtomicType; values.  The
        &xs_anyAtomicType; sequence is required because it is
        possible to derive an element containing only atomic values
        from an element that is mixed.</p>

        <infergr>
          <infer>
           <prejudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>&gr_Type; = &gr_AttributeModel; , &gr_ElementModel;</expression>
            </clause>
           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>&gr_Type; &jd_mixes_to; &gr_AttributeModel; , (
             &gr_ElementModel; &amp; text* | &xs_anyAtomicType; *)</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

      </smrules>

    </div3>

    <div3 id="sec_adjustment">
      <head>Type adjustment</head>

      <p>In the &language; type system, a complex-type declaration
      does not include the implicit attributes and nodes that may be
      included in the type.  Type adjustment takes a complex type and
      adjusts it to include implicit attributes and nodes.  In
      particular, type adjustment:

      <ulist>
      <item><p>adds the four (optional) built-in attributes xsi:type,
        xsi:nil, xsi:schemaLocation, or
        xsi:noNamespaceSchemaLocation,</p>
      </item>
      <item><p>interleaves the type with a sequence of comments and
        processing-instructions, and </p></item> <item><p>if the
        complex type is mixed, interleaves the type with a sequence of
        text nodes and &xs_anyAtomicType;.</p></item>
      </ulist>
      </p>

      <smnotation>
        <p id="jd_adjusts_to">The judgment</p>

        <display>
          <clause>
          <environment>&xq_stat_env;</environment>
          <expression>&gr_OptMixed; &gr_Type1; &jd_adjusts_to; &gr_Type2;</expression>
          </clause>
        </display>

        <p>holds when the second type is the same as the first after
        the first has been adjusted as described above.  </p>
      </smnotation>

      <smrules>     
        <p>This judgment is specified by the following rules.</p>

        <p>If the type is flagged as mixed, then mix the type and
        extend it by the built-in attributes.</p>

        <infergr>
          <infer>
           <prejudge>
            <multiclause>
             <clause>
              <environment>&xq_stat_env;</environment>
              <expression>&gr_Type1; &jd_mixes_to; &gr_Type2;</expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <environment>&xq_stat_env;</environment>
              <expression>&gr_Type2; &jd_extended_by; &BuiltInAttributes; &jd_extended_by_is; &gr_Type3;</expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <environment>&xq_stat_env;</environment>
              <expression>&gr_Type4; = &gr_Type3; &amp;
              <code>processing-instruction<phrase diff='add' at='E022'>*</phrase>*</code> &amp;
              <code>comment*</code></expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>mixed &gr_Type1; &jd_adjusts_to; &gr_Type4;</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>Otherwise, just extend the type by the built-in
        attributes.</p>

        <infergr>
          <infer>
           <prejudge>
            <multiclause>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>&gr_Type1; &jd_extended_by; &BuiltInAttributes; &jd_extended_by_is; &gr_Type2;</expression>
            </clause>
            </multiclause>
            <multiclause>
             <clause>
              <environment>&xq_stat_env;</environment>
              <expression>&gr_Type3; = &gr_Type2; &amp;
              <code>processing-instruction<phrase diff='add' at='E022'>*</phrase>*</code> &amp;
              <code>comment*</code></expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>&gr_Type1; &jd_adjusts_to; &gr_Type3;</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

      </smrules>
    </div3>

    <div3 id="sec_built_in_attributes">
      <head>Builtin attributes</head>

      <p>Schema defines four built-in attributes that can appear on
      any element in the document without being explicitly declared in
      the schema. Those four attributes need to be added inside
      content models when doing matching. The four built-in attributes
      of Schema are declared as follows.</p>

<eg><![CDATA[
  define attribute xsi:type of type xs:QName]]>&E042_semi;<![CDATA[
  define attribute xsi:nil of type xs:boolean]]>&E042_semi;<![CDATA[
  define attribute xsi:schemaLocation of type fs:anon]]>&E042_semi;<![CDATA[
  define type fs:anon1 { xs:anyURI* }]]>&E042_semi;<![CDATA[
  define attribute xsi:noNamespaceSchemaLocation of type xs:anyURI]]>&E042_semi;<![CDATA[
]]></eg>

       <p>For convenience, a type that is an all group of the four
       built-in XML Schema attributes is defined.</p>

<eg><![CDATA[
  BuiltInAttributes =
      attribute xsi:type ?
    & attribute xsi:nil ?
    & attribute xsi:schemaLocation ?
    & attribute xsi:noNamespaceSchemaLocation ?
]]></eg>

    </div3>

    <div3 id="sec_type_expansion">
      <head>Type expansion</head>

      <p>The &jd_expands_to; judgment is one of the most important
      static judgments.  It is used in the static semantics of the
      child axis <specref ref="sec_static_axis_judge"/>, which is used
      in the definition of many other rules that extract element types
      from an arbitrary content type.</p>

      <p>The judgment takes a type name and computes the union of all
      types derived from the given type.  If the type is nillable, it
      also makes sure the content model allows the empty sequence.  If
      the type is mixed, it also adjusts the type to include the mixed
      content model.  The judgment depends on the
      &jd_union_interpretation; judgment to recursively compute all
      derived types.</p>

      <smnotation>
        <p id="jd_expands_to">The judgment</p>

        <display>
          <clause>
          <environment>&xq_stat_env;</environment>
          <expression>&gr_TypeSpecifier; &jd_expands_to; &gr_Type;</expression>
          </clause>
        </display>

        <p>holds when expanding the type specifier results in the
        given type.</p>
      </smnotation>

      <smrules>
        <p>This judgment is specified by the following rules.</p>

        <p>If the type is nillable, then it expands into an optional
        type.</p>

        <infergr>
          <infer>
           <prejudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>&gr_TypeReference; &jd_expands_to;
             &gr_Type;</expression>
            </clause>
           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>nillable &gr_TypeReference; &jd_expands_to;
             &gr_Type;?</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>The type definition for the type reference is contained in
        its expansion.</p>

        <infergr>
          <infer>
           <prejudge>
            <multiclause>
          <clause>
           <environment>&xq_stat_env;</environment>
           <expression>
             &gr_TypeName; &jd_elem_qname_expands_to; &xd_qname;
           </expression>
          </clause>
            </multiclause>

            <multiclause>
            <clause>
             <expression>
               &xq_type_defn;(&xd_qname;) = define type
               &gr_TypeName; extends &gr_BaseTypeName; &gr_OptMixed; {
               &gr_Type1; }
             </expression>
            </clause>
            </multiclause>

            <multiclause>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>
            &gr_Type2; &jd_union_is; &gr_Type1; &jd_union_interpretation; &gr_TypeName;
             </expression></clause>
            </multiclause>

            <multiclause>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>&gr_OptMixed; &gr_Type2; &jd_adjusts_to; &gr_Type3;</expression>
            </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>of type &gr_TypeName; &jd_expands_to; &gr_Type3;</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>In case the type is &xs_untyped;, the type does not need to
        be adjusted as is required for other XML Schema types. See the
        corresponding definition in <specref
        ref="id-predefined-types"/>.</p>

        <infergr>
          <infer>
           <prejudge>
            <multiclause>
             <clause>
              <environment>&xq_stat_env;</environment>
              <expression>
                &xs_untyped; &jd_elem_qname_expands_to; &xd_qname;
              </expression>
             </clause>
            </multiclause>
            <multiclause>
            <clause>
             <expression>
               &xq_type_defn;(&xd_qname;) = define type
               &xs_untyped; extends &xs_anyType; {
               &gr_Type1; }
             </expression>
            </clause>
            </multiclause>

           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>of type &xs_untyped; &jd_expands_to; &gr_Type1;</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

      </smrules>     
    </div3>

    <div3 id="sec_union_interpretation">
      <head>Union interpretation of derived types</head>

      <smnotation>
        <p id="jd_union_interpretation">The judgment</p>

        <display>
          <clause>
          <environment>&xq_stat_env;</environment>
          <expression>&gr_Type2; &jd_union_is; &gr_Type1;
          &jd_union_interpretation; 
          &gr_TypeName;</expression>
          </clause>
        </display>

        <p>holds when the type &gr_Type2; is the expansion of the type
        name &gr_TypeName; with definition &gr_Type1; to include all
        types derived by extension and restriction from the given type
        name.  This rule is recursive, because each type name itself
        may have other type names that are derived from it.  The
        recursive rules traverse the entire derivation tree,
        identifying every type name derived from the original type
        name.</p>
      </smnotation>

      <smrules>
        <p>This judgment is specified by the following rules.</p>

        <infergr>
         <infer>
          <prejudge>
            <multiclause>
            <clause>
            <expression>
            <emph>No type derives from &gr_TypeName0;</emph>
            </expression>
            </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
          <environment>&xq_stat_env;</environment>
          <expression>&gr_Type0; &jd_union_is; &gr_Type0;
          &jd_union_interpretation; 
          &gr_TypeName0;</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <infergr>
          <infer>
           <prejudge>
<!-- First, the type names immediately derived by restriction -->
<multiclause>
<clause>
<expression>
               &xq_type_defn;(&xd_qname;<subscript>R,1</subscript>) = define type
               &gr_TypeNameR1; restricts &gr_TypeName0; &gr_OptMixed;<subscript>R,1</subscript> {
               &gr_TypeR1; }
</expression>
</clause>
</multiclause>

<multiclause>
<clause>
<expression>&middot; &middot; &middot;
</expression>
</clause>
</multiclause>

<multiclause>
<clause>
<expression>
               &xq_type_defn;(&xd_qname;<subscript>R,n</subscript>) = define type
               &gr_TypeNameRn; restricts &gr_TypeName0; &gr_OptMixed;<subscript>R,n</subscript> {
               &gr_TypeRn; }
</expression>
</clause>
</multiclause>

<!-- Second, the union interpretation of all the type names immediately derived by restriction -->
<multiclause>
<clause>
<environment>&xq_stat_env;</environment>
<expression>
&gr_TypeR1p; &jd_union_is; &gr_TypeR1; &jd_union_interpretation; &gr_TypeNameR1; 
</expression>
</clause>
</multiclause>
<multiclause>
<clause>
<expression>&middot; &middot; &middot;
</expression>
</clause>
</multiclause>
<multiclause>
<clause>
<environment>&xq_stat_env;</environment>
<expression>
&gr_TypeRnp; &jd_union_is; &gr_TypeRn; &jd_union_interpretation; &gr_TypeNameRn; 
</expression>
</clause>
</multiclause>

<!-- Third, all type names immediately derived by extension -->
<multiclause>
<clause>
<expression>
               &xq_type_defn;(&xd_qname;<subscript>E,1</subscript>) = define type
               &gr_TypeNameE1; extends &gr_TypeName0; &gr_OptMixed;<subscript>E,1</subscript> {
               &gr_TypeE1; }
</expression>
</clause>
</multiclause>

<multiclause>
<clause>
<expression>&middot; &middot; &middot;
</expression>
</clause>
</multiclause>

<multiclause>
<clause>
<expression>
               &xq_type_defn;(&xd_qname;<subscript>E,m</subscript>) = define type
               &gr_TypeNameEm; extends &gr_TypeName0; &gr_OptMixed;<subscript>E,m</subscript> {
               &gr_TypeEm; }
</expression>
</clause>
</multiclause>
<!-- Fourth, the union interpretation of all the type names immediately derived by extension -->

<multiclause>
<clause>
<environment>&xq_stat_env;</environment>
<expression>
&gr_TypeE1p; &jd_union_is; &gr_TypeE1; &jd_union_interpretation; &gr_TypeNameE1; 
</expression>
</clause>
</multiclause>
<multiclause>
<clause>
<expression>&middot; &middot; &middot;
</expression>
</clause>
</multiclause>
<multiclause>
<clause>
<environment>&xq_stat_env;</environment>
<expression>
&gr_TypeEmp; &jd_union_is; &gr_TypeEm; &jd_union_interpretation; &gr_TypeNameEm; 
</expression>
</clause>
</multiclause>

<!-- Finally, the entire type -->
<multiclause>
<clause>
<expression>
&gr_Type1; = &gr_TypeR1p; | &middot; &middot; &middot; | &gr_TypeRnp;
| &gr_Type0; | (&gr_Type0;, &gr_TypeE1p; ) | &middot; &middot; &middot; | (&gr_Type0;,&gr_TypeEmp;)
</expression>
</clause>
</multiclause>
           </prejudge>
           <postjudge>
            <clause>
          <environment>&xq_stat_env;</environment>
          <expression>&gr_Type1; &jd_union_is; &gr_Type0;
          &jd_union_interpretation; 
          &gr_TypeName0;</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

<smexamples>

  <p>Note that this expansion does not enforce the <term>unique
  particule attribution</term> property specified by XML Schema in
  the resulting content models. Implementations may want to implement
  an equivalent alternative expansion that enforces that property.
  For example, expanding type <code>T1</code> below yields the
  following type that is not one-deterministic:</p>

<eg><![CDATA[
define type T1 { element a }
define type T2 extends T1 { element b }

(element a | element a, element b) is (element a) extended with union interpretation of T1
]]></eg>

<p>An implementation might want to infer the equivalent content model
that verifies the <term>unique particule attribution</term> property of
XML Schema:</p>

<eg><![CDATA[
(element a, (() | element b)) is (element a) extended with union interpretation of T1
]]></eg>
</smexamples>

      </smrules>

    </div3>
  </div2>

  <div2 id="sec_auxiliary_xpath">
    <head>Judgments for step expressions and filtering</head>

    <smintro>
      <p>Step expressions are one of the elementary operations in
      &language;. Steps select nodes reachable from the root of an XML tree.
      Defining the semantics of step expressions requires a
      detailed analysis of all the possible cases of axis and node
      tests.</p>

      <p>This section introduces auxiliary judgments used to define
      the semantics of step expressions.  The &jd_principal; judgment
      (<specref ref="sec_jd_principal"/>) captures the notion of
      <emph>principal node kind</emph> in XPath.  The Axis judgments
      (<specref ref="sec_axis_judge"/>) define the static and dynamic
      semantics of all axes, and the Node Test judgments (<specref
      ref="sec_test_judge"/>) define the static and dynamic semantics
      of all node tests.  The &jd_filter; judgment accesses the value
      of an attribute and is used in the definition of validation
      (<specref ref="sec_validation_judgments"/>).</p>
    </smintro>

    <div3 id="sec_jd_principal">
      <head>Principal Node Kind</head>

      <smnotation>
        <p>The following auxiliary grammar production describes
        principal node kinds (See &xq_xpath;).</p>
      
        <scrap>
          <head>PrincipalNodeKind</head>
        
          <prodrecap ref="PrincipalNodeKind" id="PrincipalNodeKind" orig="formal"/>
        </scrap>

      </smnotation>

      <smnotation>
        <p id="jd_principal">The judgment</p>
      
       <display>
        <clause>
         <expression>&gr_Axis; &jd_principal;
         &gr_PrincipalNodeKind;</expression>
        </clause>
       </display>
      
        <p>holds when &gr_PrincipalNodeKind; is the principal node
        kind for &gr_Axis;.</p>

      </smnotation>

      <smexample>
        <p>For example, the following judgments hold.</p>

<eg><![CDATA[
  child::       principal  element
  descendant::  principal  element
  preceding::   principal  element
  attribute::   principal  attribute
  namespace::   principal  namespace
]]></eg>

      </smexample>

      <smrules>
        <p>This judgment is specified by the following rules.</p>

        <p>The principal node type for the attribute axis is
        attribute.</p>

        <infergr>
         <infer>
          <postjudge>
           <clause>
            <expression><code>attribute::</code> &jd_principal; attribute</expression>
           </clause>
          </postjudge>
         </infer>
        </infergr>

        <p>The principal node type for the namespace axis is
        namespace.</p>

        <infergr>
         <infer>
          <postjudge>
           <clause>
            <expression><code>namespace::</code> &jd_principal; namespace</expression>
           </clause>
          </postjudge>
         </infer>
        </infergr>

        <p>The principal node type for all other axis is element.</p>

        <infergr>
         <infer>
          <prejudge>
           <clause><expression>&gr_Axis; != <code>attribute::</code></expression></clause>
           <clause><expression>&gr_Axis; != <code>namespace::</code></expression></clause>
          </prejudge>
          <postjudge>
           <clause>
            <expression>&gr_Axis; &jd_principal; element</expression>
           </clause>
          </postjudge>
         </infer>
        </infergr>

      </smrules>

    </div3>

    <div3 id="sec_axis_judge">
      <head>Auxiliary judgments for axes</head>

      <div4 id="sec_static_axis_judge">
        <head>Static semantics of axes</head>

        <smnotation>
          <p id="jd_axis_type">The following judgment</p>

          <display>
           <clause>
            <environment>&xq_stat_env;</environment>
            <expression>
             &jd_axis_type; &gr_Axis; &jd_axis_type_of; &gr_Type1;
             &jd_axis_type_is; &gr_Type2;
            </expression>
           </clause>
          </display>

          <p>holds when applying the axis &gr_Axis; on type &gr_Type1;
          yields the type &gr_Type2;.</p>

          <p id="jd_has_element_content">The following two judgments are used
          in the definition of &jd_axis_type;.  The judgment</p>

          <display>
           <clause>
            <environment>&xq_stat_env;</environment>
            <expression>
             &gr_Type1; &jd_has_element_content; &gr_Type2; 
            </expression>
           </clause>
          </display>

          <p>only applies to a type that is a valid element content
          type and holds when &gr_Type1; has the content type
          &gr_Type2;.  The judgment separates the attribute types from
          the other node or atomic-valued types of the element content type
          and yields the non-attribute types.</p>

          <p id="jd_has_attribute_content">The judgment</p>

          <display>
           <clause>
            <environment>&xq_stat_env;</environment>
            <expression>
             &gr_Type1; &jd_has_attribute_content; &gr_Type2; 
            </expression>
           </clause>
          </display>

          <p>only applies to a type that is a valid element content
          type and holds when &gr_Type1; has attribute types
          &gr_Type2;.  The judgment yields the attribute types of
          the element content type.</p>
        </smnotation>

        <smexample>
          <p>For example, the following judgments hold.</p>

<eg><![CDATA[
  axis child::      of  element of type xs:string   :  text
  axis child::      of  element items of type Items :  element item of type fs:anon1*

  axis child::      of  element purchaseOrder       : 
    element shipTo of type USAddress,
    element billTo of type USAddress,
    element ipo:comment?,
    element items of type Items

  axis attribute::  of  element of type xs:string   :  empty

    attribute partNum of type SKU,
    element item of type fs:anon1*
  has-node-content
    element item of type fs:anon1*

    attribute partNum of type SKU,
    element item of type fs:anon1*
  has-attribute-content
    attribute partNum of type SKU

    (attribute partNum of type SKU,
     element item of type fs:anon1*) |
    (attribute orderDate of type xs:date?,
     element shipTo of type USAddress,
     element billTo of type USAddress,
     element comment?,
     element items of type Items)
  has-node-content
    (element item of type fs:anon1*) |
    (element shipTo of type USAddress,
     element billTo of type USAddress,
     element comment?,
     element items of type Items)

    (attribute partNum of type SKU,
     element item of type fs:anon1*) |
    (attribute orderDate of type xs:date?,
     element shipTo of type USAddress,
     element billTo of type USAddress,
     element comment?,
     element items of type Items)
  has-attribute-content
    (attribute partNum of type SKU) |
    (attribute orderDate of type xs:date?)
]]></eg>
        </smexample>

    <div5 id="sec_inference_axis">
      <head>Inference rules for all axes</head>
        <smrules>
          <p>The following rules compute the type of the axis
          expression when applied to each item type in the content
          model.</p>

         <infergr> 
          <infer>
           <prejudge>
            <multiclause>
             <clause><environment>&xq_stat_env;</environment>
             <expression>
              &jd_axis_type; &gr_Axis; &jd_axis_type_of; &gr_Type1;
              &jd_axis_type_is; &gr_Type2;</expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause><environment>&xq_stat_env;</environment>
             <expression>
              &jd_axis_type; &gr_Axis; &jd_axis_type_of; &gr_Type1; &gr_Occurrence;
              &jd_axis_type_is; &gr_Type2; &gr_Occurrence;
             </expression>
            </clause>
           </postjudge>
          </infer>
         </infergr>
     
         <infergr> 
          <infer>
           <prejudge>
            <multiclause>
             <clause><environment>&xq_stat_env;</environment>
             <expression>
              &jd_axis_type; &gr_Axis; &jd_axis_type_of; &gr_Type1;
              &jd_axis_type_is; &gr_Type3;</expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause><environment>&xq_stat_env;</environment> <expression>
              &jd_axis_type; &gr_Axis; &jd_axis_type_of; &gr_Type2;
              &jd_axis_type_is; &gr_Type4;</expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause><environment>&xq_stat_env;</environment>
             <expression>
              &jd_axis_type; &gr_Axis; &jd_axis_type_of; &gr_Type1;&amp;&gr_Type2;
              &jd_axis_type_is; &gr_Type3;&amp;&gr_Type4;
             </expression>
            </clause>
           </postjudge>
          </infer>
         </infergr>
     
         <infergr> 
          <infer>
           <prejudge>
            <multiclause>
             <clause><environment>&xq_stat_env;</environment>
             <expression>
              &jd_axis_type; &gr_Axis; &jd_axis_type_of; &gr_Type1;
              &jd_axis_type_is; &gr_Type3;</expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause><environment>&xq_stat_env;</environment> <expression>
              &jd_axis_type; &gr_Axis; &jd_axis_type_of; &gr_Type2;
              &jd_axis_type_is; &gr_Type4;</expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause><environment>&xq_stat_env;</environment>
             <expression>
              &jd_axis_type; &gr_Axis; &jd_axis_type_of; &gr_Type1;,&gr_Type2;
              &jd_axis_type_is; &gr_Type3;,&gr_Type4;
             </expression>
            </clause>
           </postjudge>
          </infer>
         </infergr>
     
         <infergr> 
          <infer>
           <prejudge>
            <multiclause>
             <clause><environment>&xq_stat_env;</environment>
             <expression>
              &jd_axis_type; &gr_Axis; &jd_axis_type_of; &gr_Type1;
              &jd_axis_type_is; &gr_Type3;</expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause><environment>&xq_stat_env;</environment> <expression>
              &jd_axis_type; &gr_Axis; &jd_axis_type_of; &gr_Type2;
              &jd_axis_type_is; &gr_Type4;</expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause><environment>&xq_stat_env;</environment>
             <expression>
              &jd_axis_type; &gr_Axis; &jd_axis_type_of; &gr_Type1;|&gr_Type2;
              &jd_axis_type_is; &gr_Type3;|&gr_Type4;
             </expression>
            </clause>
           </postjudge>
          </infer>
         </infergr>
     
         <infergr>
          <infer>
           <prejudge>
             <clause><expression>&nbsp;&nbsp;</expression></clause>
           </prejudge>
           <postjudge>
             <clause><environment>&xq_stat_env;</environment>
             <expression>
              &jd_axis_type; &gr_Axis; &jd_axis_type_of; none &jd_axis_type_is; none
             </expression>
            </clause>
           </postjudge>
          </infer>
         </infergr>
     
         <infergr>
          <infer>
           <prejudge>
             <clause><expression>&nbsp;&nbsp;</expression></clause>
           </prejudge>
           <postjudge>
             <clause><environment>&xq_stat_env;</environment>
             <expression>
              &jd_axis_type; &gr_Axis; &jd_axis_type_of; &xt_empty; &jd_axis_type_is; &xt_empty;
             </expression>
            </clause>
           </postjudge>
          </infer>
         </infergr>

         <p>The rules in the following subsections specify how to
         compute the type of each axis applied to an item type.</p>

      </smrules>
    </div5>
    <div5 id="sec_inference_self"><head>Inference rules for the <code>self</code> axis</head>
      <smrules>

         <p>Applying the self axis to a node type results in the same
         node type.</p>

	 <infergr>
	   <infer>
	     <prejudge>
	     </prejudge>
	     <postjudge>
	       <clause><environment>&xq_stat_env;</environment>
	         <expression>
	           &jd_axis_type; <code>self::</code> &jd_axis_type_of;
	           &gr_NodeType; &jd_axis_type_is;
	           &gr_NodeType;
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

      </smrules>
    </div5>
    <div5 id="sec_inference_child"><head>Inference rules for the <code>child</code> axis</head>
      <smrules>

         <p>In the case of an element type, the static type of the
         child axis is obtained by type lookup and expansion of the
         resulting type.  Note that the &jd_expands_to; judgment
         yields the type that corresponds to a given type name.
         Because the meaning of a type name includes the definitions
         of <emph>all</emph> type names derived by extension and
         restriction from the given type name, &jd_expands_to; yields
         the <emph>union</emph> of all the type definitions of all
         type names derived from the input type name.  Each type in
         the union contains the complete definition of the type name,
         i.e., it includes built-in attributes and, if necessary,
         processing-instruction, comment, and text types.</p>

         <p>After type expansion, the judgment
         &jd_has_element_content; is applied to each type in the
         union.  The resulting type is the union of all non-attribute
         types in the expanded type.</p>

	 <infergr>
	   <infer>
	     <prejudge>
              <multiclause>
               <clause>
                <environment>&xq_stat_env;</environment>
                <expression>&gr_ElementType;
                &jd_static_lookup; &gr_OptNillable;
                &gr_TypeReference;</expression>
               </clause>
              </multiclause>
              <multiclause>
               <clause><environment>&xq_stat_env;</environment>
                <expression>
                  &gr_OptNillable; &gr_TypeReference;
                  &jd_expands_to; &gr_Type1; | &middot; &middot;
                  &middot; | &gr_Typen; 
                </expression>
               </clause>
              </multiclause>
              <multiclause>
               <clause><environment>&xq_stat_env;</environment>
                <expression>
                  &gr_Type1; &jd_has_element_content; &gr_Type1;' 
                </expression>
               </clause>
              </multiclause>
              <multiclause>
               <clause>
                <expression>
&middot; &middot; &middot; 
                </expression>
               </clause>
              </multiclause>
              <multiclause>
               <clause><environment>&xq_stat_env;</environment>
                <expression>
                  &gr_Typen; &jd_has_element_content; &gr_Typen;' 
                </expression>
               </clause>
              </multiclause>
	     </prejudge>
	     <postjudge>
	       <clause><environment>&xq_stat_env;</environment>
	         <expression>
	               &jd_axis_type; <code>child::</code>
	               &jd_axis_type_of; &gr_ElementType;
	               &jd_axis_type_is; &gr_Type1;' | ... | &gr_Typen;'
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

         <p>If the type is a sequence of attributes, then the content
         type is &xt_empty;.</p>

	 <infergr>
	   <infer>
	     <prejudge>
              <multiclause>
               <clause>
                <environment>&xq_stat_env;</environment>
                <expression>&gr_Type; &jd_subtype_of; attribute<phrase diff='add' at='E023'>*</phrase>*</expression>
               </clause>
              </multiclause>
	     </prejudge>
	     <postjudge>
	       <clause><environment>&xq_stat_env;</environment>
	         <expression>
	               &gr_Type; &jd_has_element_content; &xt_empty;
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

         <p>If the type is attributes followed by a simple type, the
         content type is zero-or-one text nodes.  The resulting type
         is optional since an expression returning the empty sequence
         results in no text node being constructed.</p>

	 <infergr>
	   <infer>
	     <prejudge>
              <multiclause>
               <clause>
                <expression>&gr_Type; = &gr_Type1;, &gr_Type2;</expression>
               </clause>
              </multiclause>
              <multiclause>
               <clause>
                <environment>&xq_stat_env;</environment>
                <expression>&gr_Type1; &jd_subtype_of;
                attribute<phrase diff='add' at='E023'>*</phrase>*
                </expression>
               </clause>
              </multiclause>
              <multiclause>
               <clause>
                <environment>&xq_stat_env;</environment>
                <expression>&gr_Type2; &jd_subtype_of;
                &xs_anyAtomicType;*
                </expression>
               </clause>
              </multiclause>
	     </prejudge>
	     <postjudge>
	       <clause><environment>&xq_stat_env;</environment>
	         <expression>
                   &gr_Type; &jd_has_element_content; text? 
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

         <p>In the case of an element type with complex content type,
         the content type is simply the non-attribute part of the
         complex content type.</p>

	 <infergr>
	   <infer>
	     <prejudge>
              <multiclause>
               <clause>
                <expression>&gr_Type; = &gr_Type1;, &gr_Type2;</expression>
               </clause>
              </multiclause>
              <multiclause>
               <clause>
                <environment>&xq_stat_env;</environment>
                <expression>&gr_Type1; &jd_subtype_of;
                attribute<phrase diff='add' at='E023'>*</phrase>*
                </expression>
               </clause>
              </multiclause>
              <multiclause>
               <clause>
                <environment>&xq_stat_env;</environment>
                <expression>&gr_Type2; &jd_subtype_of; &gr_ElementModel;*</expression>
               </clause>
              </multiclause>
	     </prejudge>
	     <postjudge>
	       <clause><environment>&xq_stat_env;</environment>
	         <expression>
	               &gr_Type; &jd_has_element_content; &gr_Type2; 
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

         <p>In the case of an attribute type, the static type of the
         child axis is empty.</p>

	 <infergr>
	   <infer>
	     <prejudge>
	     </prejudge>
	     <postjudge>
	       <clause><environment>&xq_stat_env;</environment>
	         <expression>
	               &jd_axis_type; <code>child::</code> &jd_axis_type_of;
	               &gr_AttributeType; &jd_axis_type_is; &xt_empty;
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

         <p>In the case of a text node type, the static type of the child
         axis is empty.</p>

	 <infergr>
	   <infer>
	     <prejudge>
	     </prejudge>
	     <postjudge>
	       <clause><environment>&xq_stat_env;</environment>
	         <expression>
	               &jd_axis_type; <code>child::</code> &jd_axis_type_of; text
	               &jd_axis_type_is; &xt_empty;
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

         <p>In the case of a comment node type, the static type of the child
         axis is empty.</p>

	 <infergr>
	   <infer>
	     <prejudge>
	     </prejudge>
	     <postjudge>
	       <clause><environment>&xq_stat_env;</environment>
	         <expression>
	               &jd_axis_type; <code>child::</code>
	               &jd_axis_type_of; comment
	               &jd_axis_type_is; &xt_empty;
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

         <p>In the case of a processing-instruction node type, the
         static type of the child axis is empty.</p>

	 <infergr>
	   <infer>
	     <prejudge>
	     </prejudge>
	     <postjudge>
	       <clause><environment>&xq_stat_env;</environment>
	         <expression>
	               &jd_axis_type; <code>child::</code>
	               &jd_axis_type_of; processing-instruction<phrase diff='add' at='E022'>*</phrase>
	               &jd_axis_type_is; &xt_empty;
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

         <p>In case of a document node type, the static type of the
         child axis is the type of the document node content,
         interleaved with a sequence of comments and
         processing-instructions.</p>

	 <infergr>
	   <infer>
	     <prejudge>
	     </prejudge>
	     <postjudge>
	       <clause><environment>&xq_stat_env;</environment>
	         <expression>
	               &jd_axis_type; <code>child::</code>
	               &jd_axis_type_of; document { &gr_Type; }
	               &jd_axis_type_is; &gr_Type; &amp;
	               processing-instruction<phrase diff='add' at='E022'>*</phrase>* &amp; comment*
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

      </smrules>
    </div5>
    <div5 id="sec_inference_attribute">
      <head>Inference rules for the <code>attribute</code> axis</head>
      <smrules>

         <p>The static type for the attribute axis is computed in a
         similar way as the static type for the child axis.  As above,
         the &jd_expands_to; judgment may yield a union type.  After
         type expansion, the judgment &jd_has_attribute_content; is
         applied to each type in the union.</p>

	 <infergr>
	   <infer>
	     <prejudge>
              <multiclause>
               <clause>
                <environment>&xq_stat_env;</environment>
                <expression>&gr_ElementType; 
                &jd_static_lookup; &gr_OptNillable;
                &gr_TypeReference;</expression>
               </clause>
              </multiclause>
              <multiclause>
               <clause><environment>&xq_stat_env;</environment>
                <expression>
                  &gr_OptNillable; &gr_TypeReference;
                  &jd_expands_to; &gr_Type1; | &middot; &middot;
                  &middot; | &gr_Typen; 
                </expression>
               </clause>
              </multiclause>
              <multiclause>
               <clause><environment>&xq_stat_env;</environment>
                <expression>
                  &gr_Type1; &jd_has_attribute_content; &gr_Type1;'
                </expression>
               </clause>
              </multiclause>
              <multiclause>
               <clause>
                <expression>
&middot; &middot; &middot; 
                </expression>
               </clause>
              </multiclause>
              <multiclause>
               <clause><environment>&xq_stat_env;</environment>
                <expression>
                  &gr_Typen; &jd_has_attribute_content; &gr_Typen;'
                </expression>
               </clause>
              </multiclause>
	     </prejudge>
	     <postjudge>
	       <clause><environment>&xq_stat_env;</environment>
	         <expression>
	               &jd_axis_type; <code>attribute::</code>
	               &jd_axis_type_of; &gr_ElementType;
	               &jd_axis_type_is; &gr_Type1;' | ... | &gr_Typen;'
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

         <p>When applied to an element type,
         &jd_has_attribute_content; yields the type of the element's
         content that are attributes.</p>

	 <infergr>
	   <infer>
	     <prejudge>
              <multiclause>
               <clause>
                <expression>
                  &gr_Type; = (&gr_Type1;, &gr_Type2;)
                </expression>
               </clause>
              </multiclause>
              <multiclause>
               <clause>
                <environment>&xq_stat_env;</environment>
                <expression>&gr_Type1; &jd_subtype_of;
                attribute<phrase diff='add' at='E023'>*</phrase>*
                </expression>
               </clause>
              </multiclause>
              <multiclause>
               <clause>
                <environment>&xq_stat_env;</environment>
                <expression>&gr_Type2; &jd_subtype_of; &gr_ElementModel;* | &xs_anyAtomicType;*</expression>
               </clause>
              </multiclause>
	     </prejudge>
	     <postjudge>
	       <clause><environment>&xq_stat_env;</environment>
	         <expression>
	               &gr_Type; &jd_has_attribute_content; &gr_Type1;
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

         <p>In case of an attribute type, the static type of the
         attribute axis is empty.</p>

	 <infergr>
	   <infer>
	     <prejudge>
	     </prejudge>
	     <postjudge>
	       <clause><environment>&xq_stat_env;</environment>
	         <expression>
	               &jd_axis_type; <code>attribute::</code> &jd_axis_type_of;
	               &gr_AttributeType; &jd_axis_type_is; &xt_empty;
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

         <p>In case of a text node type, the static type of the
         attribute axis is empty.</p>

	 <infergr>
	   <infer>
	     <prejudge>
	     </prejudge>
	     <postjudge>
	       <clause><environment>&xq_stat_env;</environment>
	         <expression>
	               &jd_axis_type; <code>attribute::</code>
	               &jd_axis_type_of; text &jd_axis_type_is; &xt_empty;
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

         <p>In case of a comment node type, the static type of the
         attribute axis is empty.</p>

	 <infergr>
	   <infer>
	     <prejudge>
	     </prejudge>
	     <postjudge>
	       <clause><environment>&xq_stat_env;</environment>
	         <expression>
	               &jd_axis_type; <code>attribute::</code>
	               &jd_axis_type_of; comment &jd_axis_type_is;
	               &xt_empty;
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

         <p>In case of a processing-instruction node type, the static type of the
         attribute axis is empty.</p>

	 <infergr>
	   <infer>
	     <prejudge>
	     </prejudge>
	     <postjudge>
	       <clause><environment>&xq_stat_env;</environment>
	         <expression>
	               &jd_axis_type; <code>attribute::</code>
	               &jd_axis_type_of; processing-instruction<phrase diff='add' at='E022'> *</phrase>
	               &jd_axis_type_is; &xt_empty;
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

         <p>In case of a document node type, the static type of the
         attribute axis is the empty.</p>

	 <infergr>
	   <infer>
	     <prejudge>
	     </prejudge>
	     <postjudge>
	       <clause><environment>&xq_stat_env;</environment>
	         <expression>
	               &jd_axis_type; <code>attribute::</code>
	               &jd_axis_type_of; document { &gr_Type; }
	               &jd_axis_type_is; &xt_empty;
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

      </smrules>
    </div5>
    <div5 id="sec_inference_parent"><head>Inference rules for the <code>parent</code> axis</head>
      <smrules>

         <p>The type for the parent of an element type, a text node
         type, a PI node type, or a comment node type is either an
         element, a document, or empty.</p>

	 <infergr>
	   <infer>
	     <prejudge>
	     </prejudge>
	     <postjudge>
	       <clause><environment>&xq_stat_env;</environment>
	         <expression>
	               &jd_axis_type; <code>parent::</code>
	               &jd_axis_type_of; element<phrase diff='add' at='E023'> *</phrase> &jd_axis_type_is;
	               (element<phrase diff='add' at='E023'> *</phrase> | document)?
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

	 <infergr>
	   <infer>
	     <prejudge>
	     </prejudge>
	     <postjudge>
	       <clause><environment>&xq_stat_env;</environment>
	         <expression>
	               &jd_axis_type; <code>parent::</code>
	               &jd_axis_type_of; text &jd_axis_type_is;
	               (element<phrase diff='add' at='E023'> *</phrase> | document)?
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

	 <infergr>
	   <infer>
	     <prejudge>
	     </prejudge>
	     <postjudge>
	       <clause><environment>&xq_stat_env;</environment>
	         <expression>
	               &jd_axis_type; <code>parent::</code>
	               &jd_axis_type_of; processing-instruction<phrase diff='add' at='E022'> *</phrase>
	               &jd_axis_type_is; (element<phrase diff='add' at='E023'> *</phrase> | document)?
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

	 <infergr>
	   <infer>
	     <prejudge>
	     </prejudge>
	     <postjudge>
	       <clause><environment>&xq_stat_env;</environment>
	         <expression>
	               &jd_axis_type; <code>parent::</code>
	               &jd_axis_type_of; comment &jd_axis_type_is;
	               (element<phrase diff='add' at='E023'> *</phrase> | document)?
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

         <p>The type for the parent of an attribute node is an
         element or empty.</p>

	 <infergr>
	   <infer>
	     <prejudge>
	     </prejudge>
	     <postjudge>
	       <clause><environment>&xq_stat_env;</environment>
	         <expression>
	               &jd_axis_type; <code>parent::</code>
	               &jd_axis_type_of; &gr_AttributeType;
	               &jd_axis_type_is; element<phrase diff='add' at='E023'> *</phrase>?
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

         <p>The type for the parent of a document node type is always
         empty.</p>

	 <infergr>
	   <infer>
	     <prejudge>
	     </prejudge>
	     <postjudge>
	       <clause><environment>&xq_stat_env;</environment>
	         <expression>
	               &jd_axis_type; <code>parent::</code>
	               &jd_axis_type_of; &gr_DocumentType;
	               &jd_axis_type_is; &xt_empty;
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

      </smrules>
    </div5>
    <div5 id="sec_inference_namespace"><head>Inference rules for the <code>namespace</code> axis</head>
      <smrules>

         <p>The type for the namespace axis is always empty.</p>

	 <infergr>
	   <infer>
	     <prejudge>
	     </prejudge>
	     <postjudge>
	       <clause><environment>&xq_stat_env;</environment>
	         <expression>
	               &jd_axis_type; <code>namespace::</code>
	               &jd_axis_type_of; &gr_NodeType;
	               &jd_axis_type_is; &xt_empty;
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

      </smrules>
    </div5>
    <div5 id="sec_inference_descendant"><head>Inference rules for the <code>descendant</code> axis</head>
      <smrules>

         <p>The types for the descendant axis is obtained as the
         closure of the type of the child axis. This is expressed by
         the following inference rule.</p>

	 <infergr>
	   <infer>
	     <prejudge>
	       <multiclause>
	         <clause><environment>&xq_stat_env;</environment>
                   <expression>
                   &jd_axis_type; <code>child::</code>
                   &jd_axis_type_of; &gr_Type;
                   &jd_axis_type_is; &gr_Type1; </expression>
	         </clause>
	       </multiclause>
	       <multiclause>
	         <clause><environment>&xq_stat_env;</environment>
                   <expression>
                   &jd_axis_type; <code>child::</code>
                   &jd_axis_type_of; &jd_prime;(&gr_Type1;)
                   &jd_axis_type_is; &gr_Type2; </expression>
	         </clause>
	       </multiclause>
	       <multiclause>
	         <clause>
                   <expression>...</expression>
	         </clause>
	       </multiclause>
	       <multiclause>
	         <clause><environment>&xq_stat_env;</environment>
                   <expression>
                   &jd_axis_type; <code>child::</code>
                   &jd_axis_type_of; &jd_prime;(&gr_Typen;)
                   &jd_axis_type_is; &gr_Typenp1; </expression>
	         </clause>
	       </multiclause>
	       <multiclause>
	         <clause><environment>&xq_stat_env;</environment>
                   <expression>
                     &jd_prime;(&gr_Typenp1;) &jd_subtype_of; &jd_prime;(&gr_Type1;) | ... | &jd_prime;(&gr_Typen;) </expression>
	         </clause>
	       </multiclause>
	     </prejudge>
	     <postjudge>
	       <clause><environment>&xq_stat_env;</environment>
	         <expression>
                   &jd_axis_type; <code>descendant::</code>
                   &jd_axis_type_of; &gr_Type;
                   &jd_axis_type_is;
                   (&jd_prime;(&gr_Type1;) | ... |
                   &jd_prime;(&gr_Typen;))*
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

         <smnote>
           <p>Note that the last premise in the above rule 
           terminates the recursion. The rule computes the n-th
           type &gr_Typen; such that applying the child axis one more
           time does not add any new item type to the union. This
           condition is guaranteed to hold at some point, because the
           number of item types is bounded by all of the item types
           defined in the in-scope schema definitions.</p>
         </smnote>

      </smrules>
    </div5>
    <div5 id="sec_inference_descendant_of_self"><head>Inference rules for the <code>descendant-or-self</code> axis</head>
      <smrules>

         <p>The type for the descendant-or-self axis is the union of
         the type for the self axis and for the descendant axis.</p>

	 <infergr>
	   <infer>
	     <prejudge>
	       <multiclause>
	         <clause><environment>&xq_stat_env;</environment>
                   <expression>
                   &jd_axis_type; <code>descendant::</code>
                   &jd_axis_type_of; &gr_Type1;
                   &jd_axis_type_is; &gr_Type2; </expression>
	         </clause>
	       </multiclause>
	     </prejudge>
	     <postjudge>
	       <clause><environment>&xq_stat_env;</environment>
	         <expression>
                   &jd_axis_type; <code>descendant-or-self::</code>
                   &jd_axis_type_of; &gr_Type1;
                   &jd_axis_type_is; (&jd_prime;(&gr_Type1;) | &jd_prime;(&gr_Type2;))*
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

      </smrules>
    </div5>
    <div5 id="sec_inference_ancestor"><head>Inference rules for the <code>ancestor</code> axis</head>
      <smrules>

         <p>The type for the ancestor axis is computed similarly as
         for the descendant axis.</p>

	 <infergr>
	   <infer>
	     <postjudge>
	       <clause><environment>&xq_stat_env;</environment>
	         <expression>
	               &jd_axis_type; <code>ancestor::</code> &jd_axis_type_of;
	               &gr_NodeType; &jd_axis_type_is;
	               (element<phrase diff='add' at='E023'> *</phrase> | document)*
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

         <p>Note that this rule will always result in the type
         <code>(element<phrase diff='add' at='E023'> *</phrase> | document)*</code> type, but this formulation
         is preferred for consistency, and in case the static typing
         for the parent axis gets improved in a future version.</p>

	 <infergr>
	   <infer>
	     <prejudge>
	       <multiclause>
	         <clause><environment>&xq_stat_env;</environment>
                   <expression>
                   &jd_axis_type; <code>parent::</code>
                   &jd_axis_type_of; &gr_Type;
                   &jd_axis_type_is; &gr_Type1; </expression>
	         </clause>
	       </multiclause>
	       <multiclause>
	         <clause><environment>&xq_stat_env;</environment>
                   <expression>
                   &jd_axis_type; <code>parent::</code>
                   &jd_axis_type_of; &jd_prime;(&gr_Type1;)
                   &jd_axis_type_is; &gr_Type2; </expression>
	         </clause>
	       </multiclause>
	       <multiclause>
	         <clause>
                   <expression>...</expression>
	         </clause>
	       </multiclause>
	       <multiclause>
	         <clause><environment>&xq_stat_env;</environment>
                   <expression>
                   &jd_axis_type; <code>parent::</code>
                   &jd_axis_type_of; &jd_prime;(&gr_Typen;)
                   &jd_axis_type_is; &gr_Typenp1; </expression>
	         </clause>
	       </multiclause>
	       <multiclause>
	         <clause><environment>&xq_stat_env;</environment>
                   <expression>
                     &jd_prime;(&gr_Typenp1;) &jd_subtype_of; &jd_prime;(&gr_Type1;) | ... | &jd_prime;(&gr_Typen;) </expression>
	         </clause>
	       </multiclause>
	     </prejudge>
	     <postjudge>
	       <clause><environment>&xq_stat_env;</environment>
	         <expression>
                   &jd_axis_type; <code>ancestor::</code>
                   &jd_axis_type_of; &gr_Type;
                   &jd_axis_type_is;
                   (&jd_prime;(&gr_Type1;) | ... |
                   &jd_prime;(&gr_Typen;))*
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

      </smrules>
    </div5>
    <div5 id="sec_inference_ancestor_of_self"><head>Inference rules for the <code>ancestor-or-self</code> axis</head>
      <smrules>

         <p>The type for the ancestor-or-self axis is the union of the
         type for the self axis and for the ancestor axis.</p>

	 <infergr>
	   <infer>
	     <prejudge>
	       <multiclause>
	         <clause><environment>&xq_stat_env;</environment>
                   <expression>
                   &jd_axis_type; <code>ancestor::</code>
                   &jd_axis_type_of; &gr_Type1;
                   &jd_axis_type_is; &gr_Type2; </expression>
	         </clause>
	       </multiclause>
	     </prejudge>
	     <postjudge>
	       <clause><environment>&xq_stat_env;</environment>
	         <expression>
                   &jd_axis_type; <code>ancestor-or-self::</code>
                   &jd_axis_type_of; &gr_Type1;
                   &jd_axis_type_is; (&jd_prime;(&gr_Type1;) | &jd_prime;(&gr_Type2;))*
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>
        </smrules>
    </div5>
      </div4>

      <div4 id="sec_dyn_axes">
        <head>Dynamic semantics of axes</head>

        <smnotation>
          <p id="jd_axis">The following judgment</p>
          <display>
           <clause>
            <environment>&xq_dyn_env;</environment>
            <expression>
             &jd_axis; &gr_Axis; &jd_axis_of; &gr_Value1; &jd_axis_arrow; &gr_Value2;
            </expression>
           </clause>
          </display>
     
          <p>holds when applying the axis &gr_Axis; on &gr_Value1;
          yields &gr_Value2;:</p>
    
        </smnotation>

        <smexample>
          <p>For example, the following judgments hold.</p>

<eg><![CDATA[
  axis child::      of    element sizes { text { "1 2 3" } }  =>  text { "1 2 3" }

  axis attribute::  of
     element weight of type xs:integer {
       attribute xsi:type of type xs:QName {
         "xs:integer" of type xs:QName
       },
       42 of type xs:integer
     }
  => attribute xsi:type of type xs:QName {
       "xs:integer" of type xs:QName
     }

  
]]></eg>
        </smexample>

        <smrules>
          <p>This judgment is specified by the following rules.</p>

          <p>The first set of rules are used to process the axis
          judgment on each individual item in the input sequence.</p>
     
          <infergr>
           <infer>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_axis; &gr_Axis; &jd_axis_of; () &jd_axis_arrow; ()
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment>
               <expression>
                &jd_axis; &gr_Axis; &jd_axis_of; &gr_Value1;
                &jd_axis_arrow; &gr_Value3;
               </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment>
               <expression>
                &jd_axis; &gr_Axis; &jd_axis_of; &gr_Value2;
                &jd_axis_arrow; &gr_Value4;
               </expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_axis; &gr_Axis; &jd_axis_of;
               &gr_Value1;,&gr_Value2;
               &jd_axis_arrow;
               &gr_Value3;,&gr_Value4;
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <p>The following rules specifies how the value filter
          judgment is applied on each Axis.</p>

          <p>The self axis just returns the context node.</p>

          <infergr>
            <infer>
              <prejudge>
              </prejudge>
              <postjudge>
                <clause><environment>&xq_dyn_env;</environment>
                  <expression>
                    &jd_axis; <code>self::</code> &jd_axis_of; &gr_NodeValue;
                    &jd_axis_arrow; &gr_NodeValue;
                  </expression>
                </clause>
              </postjudge>
            </infer>
          </infergr>

          <p>The child, parent, attribute and namespace axis are
          specified as follows.</p>

          <infergr>
           <infer>
            <prejudge>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_axis; <code> child::</code> &jd_axis_of; element
               &gr_ElementName; { &gr_AttributeValue;,&gr_ElementValue; } &jd_axis_arrow;
               &gr_ElementValue;
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
     
          <infergr>
           <infer>
            <prejudge>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_axis; <code>attribute::</code> &jd_axis_of;
               element &gr_ElementName; {
               &gr_AttributeValue;,&gr_ElementValue; }
               &jd_axis_arrow; &gr_AttributeValue;
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
     
          <infergr>
           <infer>
            <prejudge>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_axis; <code>parent::</code> &jd_axis_of; &gr_NodeValue;
               &jd_axis_arrow; <emph>dm:</emph>parent(&gr_NodeValue;)
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <p>The descendant, descendant-or-self, ancestor, and
          ancestor-or-self axis are implemented through recursive
          application of the children and parent filters.</p>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment> <expression>
               &jd_axis; <code>child::</code> &jd_axis_of; &gr_NodeValue;
               &jd_axis_arrow; &gr_Value1;
               </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment>
               <expression>&jd_axis; <code>descendant::</code> &jd_axis_of;
               &gr_Value1; &jd_axis_arrow;
               &gr_Value2; </expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_axis; <code>descendant::</code> &jd_axis_of; &gr_NodeValue;
               &jd_axis_arrow; &gr_Value1;, &gr_Value2;
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
     
          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment> <expression>
               &jd_axis; <code>self::</code> &jd_axis_of; &gr_NodeValue;
               &jd_axis_arrow; &gr_Value1;
               </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment> <expression>
               &jd_axis; <code>descendant::</code> &jd_axis_of;
               &gr_Value1; &jd_axis_arrow;
               &gr_Value2; </expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_axis; <code>descendant-or-self::</code> &jd_axis_of;
               &gr_NodeValue; &jd_axis_arrow; &gr_Value1;,
               &gr_Value2;
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
     
          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment> <expression>
               &jd_axis; <code>parent::</code> &jd_axis_of; &gr_NodeValue;
               &jd_axis_arrow; &gr_Value1;
               </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment> <expression>
               &jd_axis; <code>ancestor::</code> &jd_axis_of;
               &gr_Value1; &jd_axis_arrow;
               &gr_Value2; </expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_axis; <code>ancestor::</code> &jd_axis_of; &gr_NodeValue;
               &jd_axis_arrow;
               &gr_Value1;, &gr_Value2;
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
     
          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment> <expression>
               &jd_axis; <code>self::</code> &jd_axis_of; &gr_NodeValue;
               &jd_axis_arrow; &gr_Value1;
               </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment>
               <expression>&jd_axis; <code> ancestor::</code> &jd_axis_of;
               &gr_Value1; &jd_axis_arrow;
               &gr_Value2; </expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_axis; <code>ancestor-or-self::</code> &jd_axis_of; &gr_NodeValue;
               &jd_axis_arrow;
               &gr_Value1;, &gr_Value2;
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

<!--

MFF: sibling and preceding and following axes are normalized away.


          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment> <expression>
               &fn_root;(&gr_NodeValue;) &jd_yields; &gr_NodeValue1;
               </expression>
              </clause>
              <clause><environment>&xq_dyn_env;</environment> <expression>
               &fn_nodeequal;(&gr_NodeValue;, &gr_NodeValue1;) &jd_yields; false
               </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment>
               <expression>&jd_axis; <code> descendant-or-self::</code> &jd_axis_of;
               &gr_NodeValue1; &jd_axis_arrow;
               &gr_Value1; </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment>
               <expression>&gr_Value1; &jd_node_before; &gr_NodeValue;
               &jd_yields; &gr_Value2; </expression>
              </clause>
             </multiclause>

            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_axis; <code>preceding::</code> &jd_axis_of; &gr_NodeValue;
               &jd_axis_arrow; &gr_Value2;
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment> <expression>
               &fn_root;(&gr_NodeValue;) &jd_yields; &gr_NodeValue1;
               </expression>
              </clause>
              <clause><environment>&xq_dyn_env;</environment> <expression>
               &fn_nodeequal;(&gr_NodeValue;, &gr_NodeValue1;) &jd_yields; false
               </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment>
               <expression>&jd_axis; <code> descendant-or-self::</code> &jd_axis_of;
               &gr_NodeValue1; &jd_axis_arrow;
               &gr_Value1; </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment>
               <expression>&gr_Value1; &jd_node_after; &gr_NodeValue;
               &jd_yields; &gr_Value2; </expression>
              </clause>
             </multiclause>

            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_axis; <code>following::</code> &jd_axis_of; &gr_NodeValue;
               &jd_axis_arrow; &gr_Value2;
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment> <expression>
               &fn_root;(&gr_NodeValue;) &jd_yields; &gr_NodeValue1;
               </expression>
              </clause>
              <clause><environment>&xq_dyn_env;</environment> <expression>
               &fn_nodeequal;(&gr_NodeValue;, &gr_NodeValue1;) &jd_yields; true
               </expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_axis; (<code>following::</code> or
               <code>preceding::</code>) &jd_axis_of; &gr_NodeValue;
               &jd_axis_arrow; ()
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment> <expression>
               &jd_axis; <code>parent::</code> &jd_axis_of; &gr_NodeValue;
               &jd_axis_arrow; &gr_NodeValue1;
               </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment>
               <expression>&jd_axis; <code> child::</code> &jd_axis_of;
               &gr_NodeValue1; &jd_axis_arrow;
               &gr_Value1; </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment>
               <expression>&gr_Value1; &jd_node_before; &gr_NodeValue;
               &jd_yields; &gr_Value2; </expression>
              </clause>
             </multiclause>

            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_axis; <code>preceding-sibling::</code> &jd_axis_of; &gr_NodeValue;
               &jd_axis_arrow; &gr_Value2;
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment> <expression>
               &jd_axis; <code>parent::</code> &jd_axis_of; &gr_NodeValue;
               &jd_axis_arrow; &gr_NodeValue1;
               </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment>
               <expression>&jd_axis; <code> child::</code> &jd_axis_of;
               &gr_NodeValue1; &jd_axis_arrow;
               &gr_Value1; </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment>
               <expression>&gr_Value1; &jd_node_after; &gr_NodeValue;
               &jd_yields; &gr_Value2; </expression>
              </clause>
             </multiclause>

            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_axis; <code>following-sibling::</code> &jd_axis_of; &gr_NodeValue;
               &jd_axis_arrow; &gr_Value2;
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment> <expression>
               &jd_axis; <code>parent::</code> &jd_axis_of; &gr_NodeValue;
               &jd_axis_arrow; ()
               </expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_axis; (<code>following-sibling::</code>
               or <code>preceding-sibling::</code>) &jd_axis_of; &gr_NodeValue;
               &jd_axis_arrow; ()
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
-->

          <p>In all the other cases, the axis application results in
          an empty sequence, and the following judgment holds.</p>

          <display diff='del' at='E034'>
           <clause><environment>&xq_dyn_env;</environment>
            <expression>
             &jd_axis; &gr_Axis; &jd_axis_of; &gr_NodeValue;
             &jd_axis_arrow; ()
            </expression>
           </clause>
          </display>
          <infergr diff='add' at='E034'>
            <infer>
              <prejudge>
                <clause>
                  <expression><emph>Otherwise</emph></expression>
                </clause>
              </prejudge>
              <postjudge>
                <clause>
                  <environment>&xq_dyn_env;</environment>
                  <expression>
                    &jd_axis; &gr_Axis; &jd_axis_of; &gr_NodeValue;
                    &jd_axis_arrow; ()
                  </expression>
                </clause>
              </postjudge>
            </infer>
          </infergr>

         </smrules>
      </div4>

    </div3>

    <div3 id="sec_test_judge">
      <head>Auxiliary judgments for node tests</head>

      <p>A node test may be a name test or a kind test.  In the static
      and dynamic semantics, we begin with name tests, followed by
      kind tests. </p>

      <div4 id="sec_sem_node_tests">
        <head>Static semantics of node tests</head>

        <smnotation>
          <p id="jd_test_type">The following judgment</p>

          <display>
           <clause>
            <environment>&xq_stat_env;</environment>
            <expression>
             &jd_test_type; &gr_NodeTest; &jd_test_type_with;
             &gr_PrincipalNodeKind; &jd_test_type_of; &gr_Type1;
             &jd_test_type_is; &gr_Type2;
            </expression>
           </clause>
          </display>

          <p>holds when applying the node test &gr_NodeTest; on the
          type &gr_Type1; in the context of the given principal node
          kind, yields the type &gr_Type2;.</p>

        </smnotation>

        <smexample>
          <p>For example, assuming the extended XML Schema given in
          section <specref ref="sec_types_example"/>, then the
          following judgments hold.</p>

<eg><![CDATA[
  test shipTo with element of
    element shipTo of type USAddress,
    element billTo of type USAddress,
    element ipo:comment?,
    element items of type Items
  : element shipTo of type USAddress
]]></eg>
        </smexample>

        <smrules>
          <p>This judgment is specified by the following rules.</p>

          <p>The first set of rules is similar to that for axes, and
          are used to process the content each individual item type in
          the input content model.</p>
     
         <infergr>
          <infer>
            <prejudge>
             <clause><environment>&xq_stat_env;</environment>
             <expression>
              &jd_test_type; &gr_NodeTest; &jd_test_type_with;
              &gr_PrincipalNodeKind; &jd_test_type_of; &gr_Type1;
              &jd_test_type_is;  &gr_Type2;
             </expression>
             </clause>
           </prejudge>
           <postjudge>
             <clause><environment>&xq_stat_env;</environment>
             <expression>
              &jd_test_type; &gr_NodeTest; &jd_test_type_with;
              &gr_PrincipalNodeKind; &jd_test_type_of; &gr_Type1; &gr_Occurrence;
              &jd_test_type_is;  &gr_Type2; &gr_Occurrence;
             </expression>
            </clause>
           </postjudge>
          </infer>
         </infergr>

<!-- T1 & T2 -->
         <infergr>
          <infer>
<prejudge>
<multiclause>
             <clause><environment>&xq_stat_env;</environment>
             <expression>
              &jd_test_type; &gr_NodeTest; &jd_test_type_with;
              &gr_PrincipalNodeKind; &jd_test_type_of; &gr_Type1;
              &jd_test_type_is;  &gr_Type3;
             </expression>
</clause>
</multiclause>
<multiclause>
             <clause><environment>&xq_stat_env;</environment>
             <expression>
              &jd_test_type; &gr_NodeTest; &jd_test_type_with;
              &gr_PrincipalNodeKind; &jd_test_type_of; &gr_Type2;
              &jd_test_type_is;  &gr_Type4;
             </expression>
</clause>
</multiclause>
</prejudge>
           <postjudge>
             <clause><environment>&xq_stat_env;</environment>
             <expression>
              &jd_test_type; &gr_NodeTest; &jd_test_type_with;
              &gr_PrincipalNodeKind; &jd_test_type_of; &gr_Type1;
              &amp; &gr_Type2;
              &jd_test_type_is;  &gr_Type3; &amp; &gr_Type4; 
             </expression>
            </clause>
           </postjudge>
          </infer>
         </infergr>

<!-- T1 , T2 -->
         <infergr>
          <infer>
<prejudge>
<multiclause>
             <clause><environment>&xq_stat_env;</environment>
             <expression>
              &jd_test_type; &gr_NodeTest; &jd_test_type_with;
              &gr_PrincipalNodeKind; &jd_test_type_of; &gr_Type1;
              &jd_test_type_is;  &gr_Type3;
             </expression>
</clause>
</multiclause>
<multiclause>
             <clause><environment>&xq_stat_env;</environment>
             <expression>
              &jd_test_type; &gr_NodeTest; &jd_test_type_with;
              &gr_PrincipalNodeKind; &jd_test_type_of; &gr_Type2;
              &jd_test_type_is;  &gr_Type4;
             </expression>
</clause>
</multiclause>
</prejudge>
           <postjudge>
             <clause><environment>&xq_stat_env;</environment>
             <expression>
              &jd_test_type; &gr_NodeTest; &jd_test_type_with;
              &gr_PrincipalNodeKind; &jd_test_type_of; &gr_Type1; , &gr_Type2;
              &jd_test_type_is;  &gr_Type3; , &gr_Type4; 
             </expression>
            </clause>
           </postjudge>
          </infer>
         </infergr>


         <infergr> 
          <infer>
           <prejudge>
            <multiclause>
             <clause><environment>&xq_stat_env;</environment>
             <expression>
              &jd_test_type; &gr_NodeTest; &jd_test_type_with;
              &gr_PrincipalNodeKind; &jd_test_type_of; &gr_Type1;
              &jd_test_type_is; &gr_Type3;
             </expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause><environment>&xq_stat_env;</environment> <expression>
              &jd_test_type; &gr_NodeTest; &jd_test_type_with;
              &gr_PrincipalNodeKind; &jd_test_type_of; &gr_Type2;
              &jd_test_type_is; &gr_Type4;
              </expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause><environment>&xq_stat_env;</environment>
             <expression>
              &jd_test_type; &gr_NodeTest; &jd_test_type_with;
              &gr_PrincipalNodeKind; &jd_test_type_of; &gr_Type1;|&gr_Type2;
              &jd_test_type_is; &gr_Type3;|&gr_Type4;
             </expression>
            </clause>
           </postjudge>
          </infer>
         </infergr>

         <infergr>
          <infer>
           <prejudge>
             <clause><expression>&nbsp;&nbsp;</expression></clause>
           </prejudge>
           <postjudge>
             <clause><environment>&xq_stat_env;</environment>
             <expression>
              &jd_test_type; &gr_NodeTest; &jd_test_type_with;
              &gr_PrincipalNodeKind; &jd_test_type_of; none
              &jd_test_type_is; none
             </expression>
            </clause>
           </postjudge>
          </infer>
         </infergr>
     
         <infergr>
          <infer>
           <prejudge>
             <clause><expression>&nbsp;&nbsp;</expression></clause>
           </prejudge>
           <postjudge>
             <clause><environment>&xq_stat_env;</environment>
             <expression>
              &jd_test_type; &gr_NodeTest; &jd_test_type_with;
              &gr_PrincipalNodeKind; &jd_test_type_of; empty
              &jd_test_type_is; empty
             </expression>
            </clause>
           </postjudge>
          </infer>
         </infergr>
        </smrules>

      <p>The following rules specify how the test judgment apply to
      node tests in the context of a principal node kind.  We start
      with name tests followed by kind tests.</p>

    <div5 id="sec_sem_name_tests">
      <head>Name Tests</head>

      <p>Name tests on elements and attributes always compute the most
      specific type possible. For example, if <code>$v</code> is bound
      to an element with a computed name, the type of <code>$v</code>
      is <code>element</code>. The static type computed for the
      expression <code>$v/self::foo</code> is <code>element foo of
      type xs:anyType</code>, which makes use of <code>foo</code> in
      the name test to compute a more specific type.  Also note that
      each case of name matching restricts the principal node kind
      appropriately.</p>

      <!-- Name tests of the form QName -->

        <!-- rule #1 in REC -->
         <infergr>
          <infer>
           <prejudge>
            <multiclause>
             <clause>
           <environment>&xq_stat_env;</environment>
           <expression>
             &gr_QName1; &jd_elem_qname_expands_to; &xd_qname;
           </expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
           <environment>&xq_stat_env;</environment>
           <expression>
             &gr_QName2; &jd_elem_qname_expands_to; &xd_qname;
           </expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>&jd_test_type; &gr_QName2;
             &jd_test_type_with; element &jd_test_type_of; element
             &gr_QName1; &gr_OptTypeSpecifier; &jd_test_type_is;
             element &gr_QName1; &gr_OptTypeSpecifier; </expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <infergr diff='add' at='E018:13'>
          <infer>
            <prejudge>
              <multiclause>
                <clause>
                  <environment>&xq_stat_env;</environment>
                  <expression>
                    &gr_QName1; &jd_elem_qname_expands_to; &xd_qname1;
                  </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>&xq_stat_env;</environment>
                  <expression>
                    &gr_QName2; &jd_elem_qname_expands_to; &xd_qname2;
                  </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <expression>
                    &jd_not;( &xd_qname1; = &xd_qname2; )
                  </expression>
                </clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <multiclause>
                <clause>
                  <environment>&xq_stat_env;</environment>
                  <expression>
                    &jd_test_type; &gr_QName2;
                    &jd_test_type_with; element
                    &jd_test_type_of; element &gr_QName1; &gr_OptTypeSpecifier1;
                    &jd_test_type_is; empty
                  </expression>
                </clause>
              </multiclause>
            </postjudge>
          </infer>
        </infergr>

        <!-- rule #2 in REC -->
        <infergr>
         <infer>
          <prejudge>
          </prejudge>
          <postjudge>
           <clause>
            <environment>&xq_stat_env;</environment>
            <expression>
             &jd_test_type; &gr_QName2; &jd_test_type_with;
             element &jd_test_type_of; element
             <code>*</code> &gr_OptTypeSpecifier;
             &jd_test_type_is; element &gr_QName2;
             &gr_OptTypeSpecifier;
             <phrase diff='add' at='E018:2'>?</phrase>
            </expression>
           </clause>
          </postjudge>
         </infer>
     </infergr>

        <!-- rule #3 in REC -->
     <infergr diff='del' at='E018:27'>
         <infer>
          <postjudge>
           <clause>
            <environment>&xq_stat_env;</environment>
            <expression>
             &jd_test_type; &gr_QName2; &jd_test_type_with; element
             &jd_test_type_of; element &gr_OptTypeSpecifier; &jd_test_type_is;
             element &gr_QName2; &gr_OptTypeSpecifier;
            </expression>
           </clause>
          </postjudge>
         </infer>
     </infergr>
      
      <!-- Name tests of the form *:LocalPart -->

        <!-- rule #4 in REC -->
     <infergr>
         <infer>
          <prejudge>
            <multiclause>
             <clause>
           <environment>&xq_stat_env;</environment>
           <expression>
             &gr_QName1; &jd_elem_qname_expands_to; &xd_qname1;
           </expression>
             </clause>
            </multiclause>
           <multiclause diff='del' at='E018:9'>
             <clause>
             <expression>&xq_ns_env;(&gr_Prefix1;) = (&gr_NamespaceKind;,&gr_URI;)</expression>
             </clause>
           </multiclause>
           <multiclause diff='del' at='E018:9'>
            <clause><expression>&fn_getnamespaceuri;(&xd_qname1;) = &gr_URI;</expression></clause>
           </multiclause>
            <multiclause>
           <clause><expression>&gr_LocalPart2; = &fn_getlocalname;( &xd_qname1; )</expression></clause>
            </multiclause>
          </prejudge>
          <postjudge>
           <clause>
            <environment>&xq_stat_env;</environment>
            <expression>
             &jd_test_type; <code>*:</code>&gr_LocalPart2;
             &jd_test_type_with; element
             &jd_test_type_of; element
             &gr_QName1; &gr_OptTypeSpecifier;
             &jd_test_type_is; element
             &gr_QName1; &gr_OptTypeSpecifier;
            </expression>
           </clause>
          </postjudge>
         </infer>
     </infergr>

        <infergr diff='add' at='E018:14'>
          <infer>
            <prejudge>
              <multiclause>
                <clause>
                  <environment>&xq_stat_env;</environment>
                  <expression>
                    &gr_QName1; &jd_elem_qname_expands_to; &xd_qname1;
                  </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <expression>
                    &fn_getlocalname;(&xd_qname1;) = &gr_LocalPart1;
                  </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <expression>
                    &jd_not;( &gr_LocalPart1; = &gr_LocalPart2; )
                  </expression>
                </clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <multiclause>
                <clause>
                  <environment>&xq_stat_env;</environment>
                  <expression>
                    &jd_test_type; *:&gr_LocalPart2;
                    &jd_test_type_with; element
                    &jd_test_type_of; element &gr_QName1; &gr_OptTypeSpecifier1;
                    &jd_test_type_is; empty
                  </expression>
                </clause>
              </multiclause>
            </postjudge>
          </infer>
        </infergr>

        <!-- rule #5 in REC -->
     <infergr>
         <infer>
          <postjudge>
           <clause>
            <environment>&xq_stat_env;</environment>
            <expression>
             &jd_test_type; <code>*:</code>&gr_LocalPart2;
             &jd_test_type_with; element
             &jd_test_type_of; element * &gr_OptTypeSpecifier;
             &jd_test_type_is; element
             <phrase diff='chg' at='E018:3'>*</phrase>
             &gr_OptTypeSpecifier;
             <phrase diff='add' at='E018:3'>?</phrase>
            </expression>
           </clause>
          </postjudge>
         </infer>

      <!-- Name tests of the form Prefix:* -->

        <!-- rule #6 in REC -->
         <infer>
          <prejudge>
            <multiclause>
             <clause>
           <environment>&xq_stat_env;</environment>
           <expression>
             &gr_QName1; &jd_elem_qname_expands_to; &xd_qname1;
           </expression>
             </clause>
            </multiclause>
           <multiclause>
             <clause>
             <expression>&xq_ns_env;(<phrase diff='chg' at='E018:10'>&gr_Prefix2;</phrase>) = (&gr_NamespaceKind;,&gr_URI;)</expression>
             </clause>
           </multiclause>
           <multiclause>
            <clause><expression>&fn_getnamespaceuri;(&xd_qname1;) = &gr_URI;</expression></clause>
           </multiclause>
          </prejudge>
          <postjudge>
           <clause>
            <environment>&xq_stat_env;</environment>
            <expression>
             &jd_test_type; &gr_Prefix2;:*
             &jd_test_type_with; element
             &jd_test_type_of; element
             &gr_QName1; &gr_OptTypeSpecifier;
             &jd_test_type_is; element
             &gr_QName1; &gr_OptTypeSpecifier;
            </expression>
           </clause>
          </postjudge>
         </infer>
     </infergr>

        <infergr diff='add' at='E018:15'>
          <infer>
            <prejudge>
              <multiclause>
                <clause>
                  <environment>&xq_stat_env;</environment>
                  <expression>
                    &gr_QName1; &jd_elem_qname_expands_to; &xd_qname1;
                  </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <expression>
                    &fn_getnamespaceuri;(&xd_qname1;) = &gr_URI1;
                  </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <expression>
                    &xq_ns_env;(&gr_Prefix2;) = (&gr_NamespaceKind;,&gr_URI2;)
                  </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <expression>
                    &jd_not;( &gr_URI1; = &gr_URI2; )
                  </expression>
                </clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <multiclause>
                <clause>
                  <environment>&xq_stat_env;</environment>
                  <expression>
                    &jd_test_type; &gr_Prefix2;:*
                    &jd_test_type_with; element
                    &jd_test_type_of; element &gr_QName1; &gr_OptTypeSpecifier1;
                    &jd_test_type_is; empty 
                  </expression>
                </clause>
              </multiclause>
            </postjudge>
          </infer>
        </infergr>

        <!-- rule #7 in REC -->
     <infergr>
         <infer>
          <postjudge>
           <clause>
            <environment>&xq_stat_env;</environment>
            <expression>
             &jd_test_type; &gr_Prefix2;<code>:*</code>
             &jd_test_type_with; element
             &jd_test_type_of; element * &gr_OptTypeSpecifier; &jd_test_type_is;
             element
             <phrase diff='chg' at='E018:4'>*</phrase>
             &gr_OptTypeSpecifier;
             <phrase diff='add' at='E018:4'>?</phrase>
            </expression>
           </clause>
          </postjudge>
         </infer>
     </infergr>

      <!-- Name tests of the form * -->

        <!-- rule #8 in REC -->
     <infergr>
         <infer>
          <postjudge>
           <clause>
            <environment>&xq_stat_env;</environment>
            <expression>
             &jd_test_type; <code>*</code>
             &jd_test_type_with; element
             &jd_test_type_of;
             <phrase diff='chg' at='E018:21'>&gr_ElementType;</phrase> &jd_test_type_is;
             <phrase diff='chg' at='E018:21'>&gr_ElementType;</phrase>
            </expression>
           </clause>
          </postjudge>
         </infer>
     </infergr>

      <!-- Name tests in general -->

        <infergr diff='add' at='E018:24'>
          <infer>
            <prejudge>
              <clause>
                <expression>
                  &jd_not;( &gr_Type; is an element type )
                </expression>
              </clause>
            </prejudge>
            <postjudge>
              <clause>
                <environment>&xq_stat_env;</environment>
                <expression>
                  &jd_test_type; &gr_NameTest;
                  &jd_test_type_with; element
                  &jd_test_type_of; &gr_Type;
                  &jd_test_type_is; empty
                </expression>
              </clause>
            </postjudge>
          </infer>
        </infergr>

     <p>Similar static typing rules apply to the attribute name
     tests:</p>

      <!-- Name tests of the form QName -->

        <!-- rule #9 in REC -->
     <infergr>
      <infer>
       <prejudge>
        <multiclause>
         <clause>
           <environment>&xq_stat_env;</environment>
           <expression>
             &gr_QName1; &jd_attr_qname_expands_to; &xd_qname;
           </expression>
         </clause>
        </multiclause>
        <multiclause>
         <clause>
           <environment>&xq_stat_env;</environment>
           <expression>
             &gr_QName2; &jd_attr_qname_expands_to; &xd_qname;
           </expression>
         </clause>
        </multiclause>
       </prejudge>
       <postjudge>
        <clause>
         <environment>&xq_stat_env;</environment>
         <expression>
          &jd_test_type; &gr_QName2;
          &jd_test_type_with; attribute
          &jd_test_type_of; attribute
          &gr_QName1; &gr_OptTypeReference;
          &jd_test_type_is; attribute
          &gr_QName1; &gr_OptTypeReference;
         </expression>
        </clause>
       </postjudge>
      </infer>
     </infergr>

        <infergr diff='add' at='E018:16'>
          <infer>
            <prejudge>
              <multiclause>
                <clause>
                  <environment>&xq_stat_env;</environment>
                  <expression>
                    &gr_QName1; &jd_attr_qname_expands_to; &xd_qname1;
                  </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>&xq_stat_env;</environment>
                  <expression>
                    &gr_QName2; &jd_attr_qname_expands_to; &xd_qname2;
                  </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <expression>
                    &jd_not;( &xd_qname1; = &xd_qname2; )
                  </expression>
                </clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <multiclause>
                <clause>
                  <environment>&xq_stat_env;</environment>
                  <expression>
                    &jd_test_type; &gr_QName2;
                    &jd_test_type_with; attribute
                    &jd_test_type_of; attribute &gr_QName1; &gr_OptTypeReference;
                    &jd_test_type_is; empty
                  </expression>
                </clause>
              </multiclause>
            </postjudge>
          </infer>
        </infergr>

        <!-- rule #10 in REC -->
     <infergr>
      <infer>
       <prejudge>
       </prejudge>
       <postjudge>
        <clause>
         <environment>&xq_stat_env;</environment>
         <expression>
          &jd_test_type; &gr_QName2;
          &jd_test_type_with; attribute
          &jd_test_type_of; attribute
          <code>*</code> &gr_OptTypeReference;
          &jd_test_type_is; attribute
          &gr_QName2; &gr_OptTypeReference;
          <phrase diff='add' at='E018:5'>?</phrase>
         </expression>
        </clause>
       </postjudge>
      </infer>
     </infergr>
      
        <!-- rule #11 in REC -->
     <infergr diff='del' at='E018:28'>
      <infer>
       <postjudge>
        <clause>
         <environment>&xq_stat_env;</environment>
         <expression>
          &jd_test_type; &gr_QName2;
          &jd_test_type_with; attribute
          &jd_test_type_of; attribute &gr_OptTypeReference;
          &jd_test_type_is; attribute
          &gr_QName2; &gr_OptTypeReference;
         </expression>
        </clause>
       </postjudge>
      </infer>
     </infergr>

      <!-- Name tests of the form *:LocalPart -->

        <!-- rule #12 in REC -->
     <infergr>
      <infer>
       <prejudge>
        <multiclause>
         <clause>
           <environment>&xq_stat_env;</environment>
           <expression>
             &gr_QName1; &jd_attr_qname_expands_to; &xd_qname1;
           </expression>
         </clause>
        </multiclause>
        <multiclause>
        <clause><expression>&fn_getlocalname;( &xd_qname1; ) = &gr_LocalPart2;</expression></clause>
        </multiclause>
       </prejudge>
       <postjudge>
        <clause>
         <environment>&xq_stat_env;</environment>
         <expression>
          &jd_test_type; <code>*:</code>&gr_LocalPart2;
          &jd_test_type_with; attribute
          &jd_test_type_of; attribute
          &gr_QName1; &gr_OptTypeReference;
          &jd_test_type_is; attribute
          &gr_QName1; &gr_OptTypeReference;
         </expression>
        </clause>
       </postjudge>
      </infer>
     </infergr>

        <infergr diff='add' at='E018:17'>
          <infer>
            <prejudge>
              <multiclause>
                <clause>
                  <environment>&xq_stat_env;</environment>
                  <expression>
                    &gr_QName1; &jd_attr_qname_expands_to; &xd_qname1;
                  </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <expression>
                    &fn_getlocalname;(&xd_qname1;) = &gr_LocalPart1;
                  </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <expression>
                    &jd_not;( &gr_LocalPart1; = &gr_LocalPart2; )
                  </expression>
                </clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <multiclause>
                <clause>
                  <environment>&xq_stat_env;</environment>
                  <expression>
                    &jd_test_type; *:&gr_LocalPart2;
                    &jd_test_type_with; attribute
                    &jd_test_type_of; attribute &gr_QName1; &gr_OptTypeReference;
                    &jd_test_type_is; empty
                  </expression>
                </clause>
              </multiclause>
            </postjudge>
          </infer>
        </infergr>

        <!-- rule #13 in REC -->
     <infergr>
      <infer>
       <postjudge>
        <clause>
         <environment>&xq_stat_env;</environment>
         <expression>
          &jd_test_type; <code>*:</code>&gr_LocalPart2;
          &jd_test_type_with; attribute
          &jd_test_type_of; attribute * &gr_OptTypeReference;
          &jd_test_type_is; attribute
          <phrase diff='chg' at='E018:6'>*</phrase>
          &gr_OptTypeReference;
          <phrase diff='add' at='E018:6'>?</phrase>
         </expression>
        </clause>
       </postjudge>
      </infer>
     </infergr>  

      <!-- Name tests of the form Prefix:* -->

        <!-- rule #14 in REC -->
     <infergr>
      <infer>
       <prejudge>
           <multiclause>
             <clause>
             <expression>&xq_ns_env;(&gr_Prefix2;) = (&gr_NamespaceKind;,&gr_URI;)</expression>
             </clause>
           </multiclause>
         <multiclause>
          <clause>
           <environment>&xq_stat_env;</environment>
           <expression>
             &gr_QName1; <phrase diff='chg' at='E018:11'>&jd_attr_qname_expands_to;</phrase> &xd_qname1;
           </expression>
          </clause>
         </multiclause>
           <multiclause>
            <clause><expression>&fn_getnamespaceuri;(&xd_qname1;) = &gr_URI;</expression></clause>
           </multiclause>
       </prejudge>
       <postjudge>
        <clause>
         <environment>&xq_stat_env;</environment>
         <expression>
          &jd_test_type; &gr_Prefix2;<code>:*</code>
          &jd_test_type_with; attribute
          &jd_test_type_of; attribute
          &gr_QName1; &gr_OptTypeReference;
          &jd_test_type_is; attribute
          &gr_QName1; &gr_OptTypeReference;
         </expression>
        </clause>
       </postjudge>
      </infer>
     </infergr>

        <infergr diff='add' at='E018:18'>
          <infer>
            <prejudge>
              <multiclause>
                <clause>
                  <environment>&xq_stat_env;</environment>
                  <expression>
                    &gr_QName1; &jd_attr_qname_expands_to; &xd_qname1;
                  </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <expression>
                    &fn_getnamespaceuri;(&xd_qname1;) = &gr_URI1;
                  </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <expression>
                    &xq_ns_env;(&gr_Prefix2;) = (&gr_NamespaceKind;,&gr_URI2;)
                  </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <expression>
                    &jd_not;( &gr_URI1; = &gr_URI2; )
                  </expression>
                </clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <multiclause>
                <clause>
                  <environment>&xq_stat_env;</environment>
                  <expression>
                    &jd_test_type; &gr_Prefix2;:*
                    &jd_test_type_with; attribute
                    &jd_test_type_of; attribute &gr_QName1; &gr_OptTypeReference;
                    &jd_test_type_is; empty 
                  </expression>
                </clause>
              </multiclause>
            </postjudge>
          </infer>
        </infergr>

        <!-- rule #15 in REC -->
     <infergr>
      <infer>
       <postjudge>
        <clause>
         <environment>&xq_stat_env;</environment>
         <expression>
          &jd_test_type; &gr_Prefix2;<code>:*</code>
          &jd_test_type_with; attribute
          &jd_test_type_of; attribute * &gr_OptTypeReference;
          &jd_test_type_is; attribute
          <phrase diff='chg' at='E018:7'>*</phrase>
          &gr_OptTypeReference;
          <phrase diff='add' at='E018:7'>?</phrase>
         </expression>
        </clause>
       </postjudge>
      </infer>
     </infergr>

      <!-- Name tests of the form * -->

        <!-- rule #16 in REC -->
     <infergr>
      <infer>
       <postjudge>
        <clause>
         <environment>&xq_stat_env;</environment>
         <expression>
          &jd_test_type; <code>*</code> &jd_test_type_with; attribute
          &jd_test_type_of; <phrase diff='chg' at='E018:22'>&gr_AttributeType;</phrase>
          &jd_test_type_is; <phrase diff='chg' at='E018:22'>&gr_AttributeType;</phrase>
         </expression>
        </clause>
       </postjudge>
      </infer>
     </infergr> 

      <!-- Name tests in general -->

        <infergr diff='add' at='E018:25'>
          <infer>
            <prejudge>
              <clause>
                <expression>
                  &jd_not;( &gr_Type; is an attribute type )
                </expression>
              </clause>
            </prejudge>
            <postjudge>
              <clause>
                <environment>&xq_stat_env;</environment>
                <expression>
                  &jd_test_type; &gr_NameTest;
                  &jd_test_type_with; attribute
                  &jd_test_type_of; &gr_Type;
                  &jd_test_type_is; empty
                </expression>
              </clause>
            </postjudge>
          </infer>
        </infergr>

        <!-- rule #17 in REC -->
          <p diff='del' at='E018:19'>Lastly, if none of the above rules holds, then the type
          of the input expression is empty.</p>

          <infergr diff='del' at='E018:19'>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression>&gr_ElementNameOrWildcard1; = &gr_NameTest;</expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
               <expression>&gr_TypeSpecifier1; = of type &xs_anyType;</expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment>&xq_stat_env;</environment>
               <expression>&jd_not;(element &gr_ElementNameOrWildcard1;
               &gr_TypeSpecifier1; &jd_subtype_of; element &gr_ElementNameOrWildcard2; &gr_TypeSpecifier2;)
               </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment>&xq_stat_env;</environment>
               <expression>&jd_not;(element &gr_ElementNameOrWildcard2;
               &gr_TypeSpecifier2; &jd_subtype_of; element &gr_ElementNameOrWildcard1; &gr_TypeSpecifier1;)
               </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment>&xq_stat_env;</environment>
              <expression>&gr_TypeSpecifier1; &jd_expands_to;
              &gr_Type1;</expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment>&xq_stat_env;</environment>
              <expression>&gr_TypeSpecifier2; &jd_expands_to;
              &gr_Type2; </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment>&xq_stat_env;</environment>
               <expression>&jd_not;(&gr_Type1; &jd_subtype_of;
               &gr_Type2;)
               </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment>&xq_stat_env;</environment>
               <expression>&jd_not;(&gr_Type2; &jd_subtype_of;
               &gr_Type1;)
               </expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_stat_env;</environment>
              <expression>
               &jd_test_type; &gr_NameTest;
               &jd_test_type_with; element
               &jd_test_type_of; element &gr_ElementNameOrWildcard2; &gr_TypeSpecifier2;
               &jd_test_type_is; empty
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

      </div5>

<div5 id="sec_sem_kind_tests">
  <head>Kind Tests</head>

    <p>All the rules for typing the document, element, and attribute
    kind tests are similar.  First, the document, element, or
    attribute test is normalized to the equivalent document, element,
    or attribute type by applying the <map></map>&jd_map_sequencetype;
    normalization rule to the kind test.</p>

    <p>After normalization of the kind test as an XQuery type, that
    type is compared to the expression's inferred type. If the latter
    is a subtype of the former other, then the kind test yields the
    smaller type.</p>

    <p><b><emph>Document kind test</emph></b></p>

    <smrules>
      <p>If the type of the expression is a subtype of the document
      kind test, then we are guaranteed that during evaluation, the
      expression's value will always match the document kind test, and
      therefore the type of the entire expression is the type of the
      input expression.</p>

      <infergr>
       <infer>
        <prejudge>
         <multiclause>
          <clause>
           <expression><map>&gr_DocumentTest;</map>&jd_map_sequencetype;
            = &gr_DocumentType;</expression>
          </clause>
         </multiclause>
         <multiclause>
          <clause>
          <environment>&xq_stat_env;</environment>
           <expression>&gr_Type1; &jd_subtype_of; &gr_DocumentType;</expression>
          </clause>
         </multiclause>
        </prejudge>
        <postjudge>
         <clause><environment>&xq_stat_env;</environment>
          <expression>
           &jd_test_type; &gr_DocumentTest;
           &jd_test_type_with; element
           &jd_test_type_of; &gr_Type1; 
           &jd_test_type_is; &gr_Type1; 
          </expression>
         </clause>
        </postjudge>
       </infer>
      </infergr>

      <p>Conversely, if the type of the document kind test is a
      subtype of the expression, then during evaluation, the
      expression's value may or may not match the document kind test,
      and therefore the type of the entire expression is zero-or-one
      of the type of the document kind test. </p>

      <infergr>
       <infer>
        <prejudge>
         <multiclause>
          <clause>
           <expression><map>&gr_DocumentTest;</map>&jd_map_sequencetype;
            = &gr_DocumentType;</expression>
          </clause>
         </multiclause>
         <multiclause>
          <clause>
          <environment>&xq_stat_env;</environment>
           <expression>&gr_DocumentType; &jd_subtype_of; &gr_Type1;</expression>
          </clause>
         </multiclause>
        </prejudge>
        <postjudge>
         <clause><environment>&xq_stat_env;</environment>
          <expression>
           &jd_test_type; &gr_DocumentTest;
           &jd_test_type_with; element
           &jd_test_type_of; &gr_Type1; 
           &jd_test_type_is; &gr_DocumentType;?
          </expression>
         </clause>
        </postjudge>
       </infer>
      </infergr>

      <p>If the types of the expression and document kind test are
      unrelated, then we apply the kind test rule recursively on the
      element types, which may yield a non-empty type.</p>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><map>document-node (&gr_ElementTest;)</map>&jd_map_sequencetype;
                = &gr_DocumentType;</expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment>&xq_stat_env;</environment>
               <expression>&jd_not;(&gr_Type1; &jd_subtype_of;
               &gr_DocumentType;)</expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment>&xq_stat_env;</environment>
               <expression>&jd_not;(&gr_DocumentType; &jd_subtype_of;
               &gr_Type1;)</expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment>&xq_stat_env;</environment>
               <expression>&jd_test_type; &gr_ElementTest;
               &jd_test_type_with; element
               &jd_test_of;  &gr_Type1; 
               &jd_test_type_is; &gr_Type2;
               </expression>
              </clause>
              <clause>
               <environment>&xq_stat_env;</environment>
               <expression>
                &jd_not;(&gr_Type2; &jd_subtype_of; &xt_empty;)
               </expression>
              </clause>
             </multiclause>

            </prejudge>
            <postjudge>
             <clause><environment>&xq_stat_env;</environment>
              <expression>
               &jd_test_type; document-node (&gr_ElementTest;)
               &jd_test_type_with; element
               &jd_test_of; document { &gr_Type1; }
               &jd_test_type_is; document { &gr_Type2; }
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <p>If there is no non-empty type, then the kind test yields
          the empty type.</p>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><map>document-node (&gr_ElementTest;)</map>&jd_map_sequencetype;
                = &gr_DocumentType;</expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment>&xq_stat_env;</environment>
               <expression>&jd_not;(&gr_Type1; &jd_subtype_of;
               &gr_DocumentType;)</expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment>&xq_stat_env;</environment>
               <expression>&jd_not;(&gr_DocumentType; &jd_subtype_of;
               &gr_Type1;)</expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment>&xq_stat_env;</environment>
               <expression>&jd_test_type; &gr_ElementTest;
               &jd_test_type_with; element
               &jd_test_of;  &gr_Type1; 
               &jd_test_type_is; &gr_Type2;
               </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause><environment>&xq_stat_env;</environment>
                <expression>&gr_Type2; &jd_subtype_of; &xt_empty;</expression></clause>
             </multiclause>

            </prejudge>
            <postjudge>
             <clause><environment>&xq_stat_env;</environment>
              <expression>
               &jd_test_type; document-node (&gr_ElementTest;)
               &jd_test_type_with; element
               &jd_test_of; document { &gr_Type1; }
               &jd_test_type_is; empty
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
        </smrules>     

     <p><b><emph>Element kind test</emph></b></p>

        <smrules>
     <p>The rules for the element kind test are similar to those for
     the document kind test.</p> <p>If the type of the expression is a
     subtype of the element kind test, then we are guaranteed that
     during evaluation, the expression's element value will always
     match the element kind test, and therefore the type of the entire
     expression is the type of the input expression.</p>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><map>&gr_ElementTest;</map>&jd_map_sequencetype;
                = &gr_ElementType;</expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment>&xq_stat_env;</environment>
               <expression>&gr_Type1; &jd_subtype_of; &gr_ElementType;</expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_stat_env;</environment>
              <expression>
               &jd_test_type; &gr_ElementTest;
               &jd_test_type_with; element
               &jd_test_type_of; &gr_Type1; 
               &jd_test_type_is; &gr_Type1; 
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <p>Conversely, if the type of the element kind test is a
          subtype of the expression, then during evaluation, the
          expression's element value may or may not match the element
          kind test, and therefore the type of the entire expression
          is zero-or-one of the type of the element kind test. </p>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><map>&gr_ElementTest;</map>&jd_map_sequencetype;
                = &gr_ElementType;</expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment>&xq_stat_env;</environment>
               <expression>&gr_ElementType; &jd_subtype_of; &gr_Type1;</expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_stat_env;</environment>
              <expression>
               &jd_test_type; &gr_ElementTest;
               &jd_test_type_with; element
               &jd_test_type_of; &gr_Type1; 
               &jd_test_type_is; &gr_ElementType;?
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <p>If the types of the expression and element kind test are
          unrelated (i.e., neither type is a subtype of the other),
          then we must compare the structure of the type of the
          element test with the type of the element expression, as an
          element type or test may contain wildcards.</p>

          <p>In the first case, the element kind test contains an
          element name and a type name and the input expression's type
          contains only a type name.  If the input expression's
          content type is a subtype of the element kind test's content
          type, then the type of the entire expression is zero-or-one
          of an element with the given name and the input expression's
          content type.</p>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><map>&gr_ElementTest;</map>&jd_map_sequencetype;
                = element &gr_ElementName1; &gr_TypeSpecifier1;</expression>
              </clause>
              <clause>
              <environment>&xq_stat_env;</environment>
              <expression>&gr_TypeSpecifier1; &jd_expands_to;
              &gr_Type1; </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment>&xq_stat_env;</environment>
              <expression>&gr_TypeSpecifier2; &jd_expands_to;
              &gr_Type2; </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment>&xq_stat_env;</environment>
               <expression> &gr_Type2; &jd_subtype_of; &gr_Type1;</expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_stat_env;</environment>
              <expression>
               &jd_test_type; &gr_ElementTest;
               &jd_test_type_with; element
               &jd_test_type_of; element<phrase diff='add' at='E023'> *</phrase> &gr_TypeSpecifier2;
               &jd_test_type_is; element &gr_ElementName1;
               &gr_TypeSpecifier2;? 
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <p>In the second case, the structure of the input types is
          reversed: The input expression's type contains an element
          name and a type name and the element kind test's type
          contains only a type name.  If the element kind test's
          content type is a subtype of the input expression's content
          type, then the type of the entire expression is zero-or-one
          of an element with the given name and the element kind
          test's content type.</p>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><map>&gr_ElementTest;</map>&jd_map_sequencetype;
                = element<phrase diff='add' at='E023'> *</phrase> &gr_TypeSpecifier1;</expression>
              </clause>
              <clause>
              <environment>&xq_stat_env;</environment>
              <expression>&gr_TypeSpecifier1; &jd_expands_to;
              &gr_Type1; </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment>&xq_stat_env;</environment>
              <expression>&gr_TypeSpecifier2; &jd_expands_to;
              &gr_Type2; </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment>&xq_stat_env;</environment>
               <expression> &gr_Type1; &jd_subtype_of; &gr_Type2;</expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_stat_env;</environment>
              <expression>
               &jd_test_type; &gr_ElementTest;
               &jd_test_type_with; element
               &jd_test_type_of; element &gr_ElementName2; &gr_TypeSpecifier2;
               &jd_test_type_is; element &gr_ElementName2;
               &gr_TypeSpecifier1;? 
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <p>Lastly, if none of the above rules holds, then the type
          of the input expression is empty.</p>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><map>&gr_ElementTest;</map>&jd_map_sequencetype;
                = element &gr_ElementNameOrWildcard1; &gr_TypeSpecifier1;</expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment>&xq_stat_env;</environment>
               <expression>&jd_not;(element &gr_ElementNameOrWildcard1;
               &gr_TypeSpecifier1; &jd_subtype_of; element &gr_ElementNameOrWildcard2; &gr_TypeSpecifier2;)
</expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment>&xq_stat_env;</environment>
               <expression>&jd_not;(element &gr_ElementNameOrWildcard2;
               &gr_TypeSpecifier2; &jd_subtype_of; element &gr_ElementNameOrWildcard1; &gr_TypeSpecifier1;)
</expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment>&xq_stat_env;</environment>
              <expression>&gr_TypeSpecifier1; &jd_expands_to;
              &gr_Type1; </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment>&xq_stat_env;</environment>
              <expression>&gr_TypeSpecifier2; &jd_expands_to;
              &gr_Type2; </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment>&xq_stat_env;</environment>
               <expression>&jd_not;(&gr_Type1; &jd_subtype_of;
               &gr_Type2;)
</expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment>&xq_stat_env;</environment>
               <expression>&jd_not;(&gr_Type2; &jd_subtype_of;
               &gr_Type1;)
</expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_stat_env;</environment>
              <expression>
               &jd_test_type; &gr_ElementTest;
               &jd_test_type_with; element
               &jd_test_type_of; element &gr_ElementNameOrWildcard2; &gr_TypeSpecifier2;
               &jd_test_type_is; empty
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
        </smrules>     

     <p><b><emph>Attribute kind test</emph></b></p>

        <smrules>
     <p>The rules for the attribute kind test are isomorphic to those
     for element kind test.</p> <p>If the type of the expression is a
     subtype of the attribute kind test, then we are guaranteed that
     during evaluation, the expression's attribute value will always
     match the attribute kind test, and therefore the type of the
     entire expression is the type of the input expression.</p>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><map>&gr_AttributeTest;</map>&jd_map_sequencetype;
                = &gr_AttributeType;</expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment>&xq_stat_env;</environment>
               <expression>&gr_Type1; &jd_subtype_of; &gr_AttributeType;</expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_stat_env;</environment>
              <expression>
               &jd_test_type; &gr_AttributeTest;
               &jd_test_type_with; attribute
               &jd_test_type_of; &gr_Type1; 
               &jd_test_type_is; &gr_Type1; 
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <p>Conversely, if the type of the attribute kind test is a
          subtype of the expression, then during evaluation, the
          expression's attribute value may or may not match the
          attribute kind test, and therefore the type of the entire
          expression is zero-or-one of the type of the attribute kind
          test. </p>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><map>&gr_AttributeTest;</map>&jd_map_sequencetype;
                = &gr_AttributeType;</expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment>&xq_stat_env;</environment>
               <expression>&gr_AttributeType; &jd_subtype_of; &gr_Type1;</expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_stat_env;</environment>
              <expression>
               &jd_test_type; &gr_AttributeTest;
               &jd_test_type_with; attribute
               &jd_test_type_of; &gr_Type1; 
               &jd_test_type_is; &gr_AttributeType;?
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <p>If the types of the expression and attribute kind test
          are unrelated (i.e., neither type is a subtype of the
          other), then we must compare the structure of the type of
          the attribute test with the type of the attribute
          expression, as an attribute type or test may contain
          wildcards.</p>

          <p>In the first case, the attribute kind test contains an
          attribute name and a type name and the input expression's
          type contains only a type name.  If the input expression's
          content type is a subtype of the attribute kind test's
          content type, then the type of the entire expression is
          zero-or-one of an attribute with the given name and the
          input expression's content type.</p>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><map>&gr_AttributeTest;</map>&jd_map_sequencetype;
                = attribute &gr_AttributeName1; &gr_TypeReference1;</expression>
              </clause>
              <clause>
              <environment>&xq_stat_env;</environment>
              <expression>&gr_TypeReference1; &jd_expands_to;
              &gr_Type1; </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment>&xq_stat_env;</environment>
              <expression>&gr_TypeReference2; &jd_expands_to;
              &gr_Type2; </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment>&xq_stat_env;</environment>
               <expression> &gr_Type2; &jd_subtype_of; &gr_Type1;</expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_stat_env;</environment>
              <expression>
               &jd_test_type; &gr_AttributeTest;
               &jd_test_type_with; attribute
               &jd_test_type_of; attribute<phrase diff='add' at='E023'> *</phrase> &gr_TypeReference2;
               &jd_test_type_is; attribute &gr_AttributeName1;
               &gr_TypeReference2;? 
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <p>In the second case, the structure of the input types is
          reversed: The input expression's type contains an attribute
          name and a type name and the attribute kind test's type
          contains only a type name.  If the attribute kind test's
          content type is a subtype of the input expression's content
          type, then the type of the entire expression is zero-or-one
          of an attribute with the given name and the attribute kind
          test's content type.</p>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><map>&gr_AttributeTest;</map>&jd_map_sequencetype;
                = attribute<phrase diff='add' at='E023'> *</phrase> &gr_TypeReference1;</expression>
              </clause>
              <clause>
              <environment>&xq_stat_env;</environment>
              <expression>&gr_TypeReference1; &jd_expands_to;
              &gr_Type1; </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment>&xq_stat_env;</environment>
              <expression>&gr_TypeReference2; &jd_expands_to;
              &gr_Type2; </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment>&xq_stat_env;</environment>
               <expression> &gr_Type1; &jd_subtype_of; &gr_Type2;</expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_stat_env;</environment>
              <expression>
               &jd_test_type; &gr_AttributeTest;
               &jd_test_type_with; attribute
               &jd_test_type_of; attribute &gr_AttributeName2; &gr_TypeReference2;
               &jd_test_type_is; attribute &gr_AttributeName2;
               &gr_TypeReference1;? 
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <p>Lastly, if none of the above rules holds, then the type
          of the input expression is empty.</p>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><map>&gr_AttributeTest;</map>&jd_map_sequencetype;
                = attribute &gr_AttributeNameOrWildcard1; &gr_TypeReference1;</expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment>&xq_stat_env;</environment>
               <expression>&jd_not;(attribute &gr_AttributeNameOrWildcard1;
               &gr_TypeReference1; &jd_subtype_of; attribute &gr_AttributeNameOrWildcard2; &gr_TypeReference2;)
               </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment>&xq_stat_env;</environment>
               <expression>&jd_not;(attribute &gr_AttributeNameOrWildcard2;
               &gr_TypeReference2; &jd_subtype_of; attribute &gr_AttributeNameOrWildcard1; &gr_TypeReference1;)
               </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment>&xq_stat_env;</environment>
              <expression>&gr_TypeReference1; &jd_expands_to;
              &gr_Type1; </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment>&xq_stat_env;</environment>
              <expression>&gr_TypeReference2; &jd_expands_to;
              &gr_Type2; </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment>&xq_stat_env;</environment>
               <expression>&jd_not;(&gr_Type1; &jd_subtype_of;
               &gr_Type2;)
               </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment>&xq_stat_env;</environment>
               <expression>&jd_not;(&gr_Type2; &jd_subtype_of;
               &gr_Type1;)
               </expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_stat_env;</environment>
              <expression>
               &jd_test_type; &gr_AttributeTest;
               &jd_test_type_with; attribute
               &jd_test_type_of; attribute &gr_AttributeNameOrWildcard2; &gr_TypeReference2;
               &jd_test_type_is; empty
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
        </smrules>     

     <p><b><emph>Processing instruction, comment, and text kind
     tests</emph></b></p>

     <smrules>
     <infergr diff='chg' at='E022'>
      <infer>
       <prejudge>
         <clause>
           <expression><map>&gr_PITest;</map>&jd_map_sequencetype; = processing-instruction *</expression>
         </clause>
       </prejudge>
       <postjudge>
        <clause><environment>&xq_stat_env;</environment>
         <expression>
          &jd_test_type; 
          &gr_PITest;
          &jd_test_type_with; &gr_PrincipalNodeKind;
          &jd_test_type_of; &gr_ProcessingInstructionType;
          &jd_test_type_is; &gr_ProcessingInstructionType;
         </expression>
        </clause>
       </postjudge>
      </infer>
     </infergr>

     <p>A processing-instruction node test with a string
     literal or NCName matches a processing instruction whose target
     has the given name.  <phrase diff='del' at='E022'>Since target matching cannot be checked
     statically, the static type of the node test is zero-or-one
     processing instruction.</phrase></p>

     <infergr diff='chg' at='E022'>
      <infer>
       <prejudge>
         <clause>
           <expression><map>&gr_PITest;</map>&jd_map_sequencetype; = processing-instruction &gr_NCName;</expression>
         </clause>
       </prejudge>
       <postjudge>
        <clause><environment>&xq_stat_env;</environment>
         <expression>
          &jd_test_type;
          &gr_PITest;
          &jd_test_type_with; &gr_PrincipalNodeKind;
          &jd_test_type_of; processing-instruction &gr_NCName;
          &jd_test_type_is; processing-instruction &gr_NCName;
         </expression>
        </clause>
       </postjudge>
      </infer>
     </infergr>

     <infergr diff='chg' at='E022'>
      <infer>
       <prejudge>
         <clause>
           <expression><map>&gr_PITest;</map>&jd_map_sequencetype; = processing-instruction &gr_NCName;</expression>
         </clause>
       </prejudge>
       <postjudge>
        <clause><environment>&xq_stat_env;</environment>
         <expression>
          &jd_test_type;
          &gr_PITest;
          &jd_test_type_with; &gr_PrincipalNodeKind;
          &jd_test_type_of; processing-instruction *
          &jd_test_type_is; processing-instruction &gr_NCName; ?
         </expression>
        </clause>
       </postjudge>
      </infer>
     </infergr>

     <infergr>
      <infer>
       <postjudge>
        <clause><environment>&xq_stat_env;</environment>
         <expression>
          &jd_test_type; <code>comment()</code>
          &jd_test_type_with; &gr_PrincipalNodeKind;
          &jd_test_type_of; comment &jd_test_type_is;
          comment
         </expression>
        </clause>
       </postjudge>
      </infer>
     </infergr>

     <infergr>
      <infer>
       <postjudge>
        <clause><environment>&xq_stat_env;</environment>
         <expression>
          &jd_test_type; <code>text()</code>
          &jd_test_type_with; &gr_PrincipalNodeKind;
          &jd_test_type_of; text &jd_test_type_is; text
         </expression>
        </clause>
       </postjudge>
      </infer>
     </infergr>

     <infergr>
      <infer>
       <postjudge>
        <clause><environment>&xq_stat_env;</environment>
         <expression>
          &jd_test_type; <code>node()</code>
          &jd_test_type_with; &gr_PrincipalNodeKind;
          &jd_test_type_of;
          &gr_NodeType; &jd_test_type_is; &gr_NodeType;
         </expression>
        </clause>
       </postjudge>
      </infer>
     </infergr>

          <p>If none of the above rules applies then the node test
          returns the empty sequence, and the following dynamic rule
          is applied:</p>
          
          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><emph>Otherwise</emph></expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_stat_env;</environment>
              <expression>
       &jd_test_type; &gr_NodeTest;
       &jd_test_type_with; &gr_PrincipalNodeKind;
       &jd_test_type_of;
       &gr_NodeType; &jd_test_type_is; &xt_empty;
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
     </smrules>
      </div5>

    </div4>

    <div4 id="sec_dyn_node_tests">
      <head>Dynamic semantics of node tests</head>

      <smnotation>
        <p id="jd_test">The following judgment</p>
        <display>
         <clause>
          <environment>&xq_dyn_env;</environment>
          <expression>
           &jd_test; &gr_NodeTest; &jd_test_with;
           &gr_PrincipalNodeKind; &jd_test_of; &gr_Value1; &jd_test_arrow; &gr_Value2;
          </expression>
         </clause>
        </display>
     
        <p>holds when applying the node test &gr_NodeTest; on
        &gr_Value1; in the context of the &gr_PrincipalNodeKind;
        yields &gr_Value2;:</p>
      </smnotation>
    
      <smexample>
        <p>For example, the following judgments hold.</p>

<eg><![CDATA[
  test node()  with element  of    text { "1 2 3" }  => text { "1 2 3" }
  test size    with element  of    text { "1 2 3" }  => ()

  test foo:*   with element  of
     (element foo:a of type xs:int { 1 },
      element foo:a of type xs:int { 2 },
      element bar:b of type xs:int { 3 },
      element bar:c of type xs:int { 4 },
      element foo:d of type xs:int { 5 })
  => (element foo:a of type xs:int { 1 },
      element foo:a of type xs:int { 2 },
      (),
      (),
      element foo:d of type xs:int { 5 })
]]></eg>
      </smexample>

      <smnote>
        <p>The last example illustrates how a test judgment operates
        on a sequence of nodes, applying the test on each node in the
        sequence individually, while preserving the structure of the
        sequence.</p>
      </smnote>

      <smrules>
        <p>This judgment is specified by the following rules.</p>

        <p>The first set of rules are similar to those for axes, and
        are used to process the test judgment on each individual item
        in the input sequence.</p>
     
          <infergr>
           <infer>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_test; &gr_NodeTest; &jd_test_with;
             &gr_PrincipalNodeKind; &jd_test_of; () &jd_test_arrow; ()
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment>
               <expression>
                &jd_test; &gr_NodeTest; &jd_test_with;
             &gr_PrincipalNodeKind; &jd_test_of; &gr_Value1; &jd_test_arrow; &gr_Value3;
               </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment>
               <expression>
                &jd_test; &gr_NodeTest; &jd_test_with;
             &gr_PrincipalNodeKind; &jd_test_of; &gr_Value2; &jd_test_arrow; &gr_Value4;
               </expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
             &jd_test; &gr_NodeTest; &jd_test_with; &gr_PrincipalNodeKind;
             &jd_test_of; &gr_Value1;,&gr_Value2; &jd_test_arrow;
             &gr_Value3;,&gr_Value4;
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
        </smrules>

      <div5 id="sec_dyn_sem_name_tests">
        <head>Name Tests</head>

        <p>The following rules specify how the value filter judgment
        is applied on a name test in the context of a principal node
        kind.</p>

        <smrules>
          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression>&dm_nodekind;( &gr_NodeValue; ) = &gr_PrincipalNodeKind;</expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
               <expression>&fn_name;( &gr_NodeValue; ) = &xd_qname;</expression>
              </clause>
             </multiclause>
           <multiclause>
             <clause>
             <expression>&xq_ns_env;(&gr_Prefix;) = (&gr_NamespaceKind;,&gr_URI;)</expression>
             </clause>
           </multiclause>
           <multiclause>
            <clause><expression>&fn_getnamespaceuri;(&xd_qname;) = &gr_URI;</expression></clause>
           </multiclause>
             <multiclause>
              <clause>
               <expression>&fn_getlocalname;( &xd_qname; ) = &gr_LocalPart;
               </expression>
              </clause>
             </multiclause>

            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_test; &gr_Prefix;:&gr_LocalPart;
               &jd_test_with; &gr_PrincipalNodeKind;
               &jd_test_of; &gr_NodeValue; &jd_test_arrow; &gr_NodeValue;
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression>&dm_nodekind;( &gr_NodeValue; ) = &gr_PrincipalNodeKind;</expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_test; <code>*</code>
               &jd_test_with; &gr_PrincipalNodeKind;
               &jd_test_of; &gr_NodeValue;
               &jd_test_arrow; &gr_NodeValue;
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
     
          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression>&dm_nodekind;( &gr_NodeValue; ) = &gr_PrincipalNodeKind;</expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
               <expression>&fn_name; ( &gr_NodeValue; ) = &xd_qname;</expression>
              </clause>
             </multiclause>
           <multiclause>
             <clause>
             <expression>&xq_ns_env;(&gr_Prefix;) = (&gr_NamespaceKind;,&gr_URI;)</expression>
             </clause>
           </multiclause>
           <multiclause>
            <clause><expression>&fn_getnamespaceuri;(&xd_qname;) = &gr_URI;</expression></clause>
           </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_test; &gr_Prefix;<code>:*</code>
               &jd_test_with; &gr_PrincipalNodeKind;
               &jd_test_of; &gr_NodeValue; &jd_test_arrow; &gr_NodeValue;
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
     
          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression>&dm_nodekind;( &gr_NodeValue; ) = &gr_PrincipalNodeKind;</expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
               <expression>&fn_name; ( &gr_NodeValue; ) = &xd_qname;</expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
               <expression>&fn_getlocalname; ( &xd_qname; ) = &gr_LocalPart;</expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_test; <code>*:</code>&gr_LocalPart;
               &jd_test_with; &gr_PrincipalNodeKind;
               &jd_test_of; &gr_NodeValue; &jd_test_arrow; &gr_NodeValue;
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
        </smrules>
      </div5>     

      <div5 id="sec_dyn_kind_tests">
        <head>Kind Tests</head>

        <p>All the rules for evaluating the document, element, and
        attribute kind tests are similar.  First, the document,
        element, or attribute test is normalized to the equivalent
        document, element, or attribute type by applying the
        <map></map>&jd_map_sequencetype; normalization rule.  As
        explained in <specref ref="id-sequencetype"/>, SequenceTypes
        are normalized to XQuery types whenever a dynamic evaluation
        or static typing rule requires the corresponding type. The
        reason for this deviation from the processing model is that
        the result of SequenceType normalization is not part of the
        &language; core syntax.</p>

        <p>After normalization of the SequenceType to an XQuery type,
        the document, element, or attribute value is simply matched
        against the XQuery type.  If the value matches the type, then
        the judgment yields the value, otherwise the judgment yields
        the empty sequence.</p>

        <p><b><emph>Document kind test</emph></b></p>   

        <smrules>
          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><map>&gr_DocumentTest;</map>&jd_map_sequencetype;
                = &gr_DocumentType;</expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment>&xq_stat_env;</environment>
               <expression>&gr_DocumentValue; &jd_matches; &gr_DocumentType;</expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_test; &gr_DocumentTest;
               &jd_test_with; element
               &jd_test_of; &gr_DocumentValue; &jd_test_arrow; &gr_DocumentValue;
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><map>&gr_DocumentTest;</map>&jd_map_sequencetype;
                = &gr_DocumentType;</expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment>&xq_stat_env;</environment>
               <expression>&jd_not;(&gr_DocumentValue; &jd_matches; &gr_DocumentType;)</expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_test; &gr_DocumentTest;
               &jd_test_with; element
               &jd_test_of; &gr_DocumentValue; &jd_test_arrow; ()
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
        </smrules>     

        <p><b><emph>Element kind test</emph></b></p>

        <smrules>
          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><map>&gr_ElementTest;</map>&jd_map_sequencetype;
                = &gr_ElementType;</expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment>&xq_stat_env;</environment>
               <expression>&gr_ElementValue; &jd_matches; &gr_ElementType;</expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_test; &gr_ElementTest;
               &jd_test_with; element
               &jd_test_of; &gr_ElementValue; &jd_test_arrow; &gr_ElementValue;
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><map>&gr_ElementTest;</map>&jd_map_sequencetype;
                = &gr_ElementType;</expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment>&xq_stat_env;</environment>
               <expression>&jd_not;(&gr_ElementValue; &jd_matches; &gr_ElementType;)</expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_test; &gr_ElementTest;
               &jd_test_with; element
               &jd_test_of; &gr_ElementValue; &jd_test_arrow; ()
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
        </smrules>     

        <p><b><emph>Attribute kind test</emph></b></p>

        <smrules>
          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><map>&gr_AttributeTest;</map>&jd_map_sequencetype;
                = &gr_AttributeType;</expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment>&xq_stat_env;</environment>
               <expression>&gr_AttributeValue; &jd_matches; &gr_AttributeType;</expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_test; &gr_AttributeTest;
               &jd_test_with; attribute
               &jd_test_of; &gr_AttributeValue; &jd_test_arrow; &gr_AttributeValue;
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><map>&gr_AttributeTest;</map>&jd_map_sequencetype;
                = &gr_AttributeType;</expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment>&xq_stat_env;</environment>
               <expression>&jd_not;(&gr_AttributeValue; &jd_matches; &gr_AttributeType;)</expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_test; &gr_AttributeTest;
               &jd_test_with; attribute
               &jd_test_of; &gr_AttributeValue; &jd_test_arrow; ()
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
        </smrules>     

        <p><b><emph>Processing instruction, comment, and text kind
        tests</emph></b></p>

        <smrules>
          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression>&dm_nodekind; ( &gr_NodeValue; ) = "processing-instruction"</expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_test; <code>processing-instruction()</code>
               &jd_test_with; &gr_PrincipalNodeKind;
               &jd_test_of; &gr_NodeValue; &jd_test_arrow; &gr_NodeValue;
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
     
          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression>&dm_nodekind; ( &gr_NodeValue; ) = "processing-instruction"</expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
               <expression>&fn_name; ( &gr_NodeValue; ) = &xd_qname;</expression>
              </clause>
             </multiclause>
 	     <multiclause>
 	       <clause>
               <environment>&xq_dyn_env;</environment>
 	       <expression>&gr_StringLiteral; &jd_has_atomic_value; &gr_String;
 	       </expression>
 	       </clause>
 	     </multiclause>
             <multiclause>
              <clause>
               <expression>&fn_getlocalname; ( &xd_qname; ) = &gr_String;</expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_test; <code>processing-instruction(</code> &gr_StringLiteral; <code>)</code>
               &jd_test_with; &gr_PrincipalNodeKind;
               &jd_test_of; &gr_NodeValue; &jd_test_arrow; &gr_NodeValue;
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression>&jd_not;(&dm_nodekind; ( &gr_NodeValue; ) = "processing-instruction")</expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_test; <code>processing-instruction()</code>
               &jd_test_with; &gr_PrincipalNodeKind;
               &jd_test_of; &gr_NodeValue; &jd_test_arrow; ()
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
     
          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression>&dm_nodekind; ( &gr_NodeValue; ) = "comment"</expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_test; <code>comment()</code>
               &jd_test_with; &gr_PrincipalNodeKind;
               &jd_test_of; &gr_NodeValue; &jd_test_arrow; &gr_NodeValue;
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
     
          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression>&jd_not;(&dm_nodekind; ( &gr_NodeValue; ) = "comment")</expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_test; <code>comment()</code>
               &jd_test_with; &gr_PrincipalNodeKind;
               &jd_test_of; &gr_NodeValue; &jd_test_arrow; ()
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
     
          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression>&dm_nodekind; ( &gr_NodeValue; ) = "text"</expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_test; <code>text()</code>
               &jd_test_with; &gr_PrincipalNodeKind;
               &jd_test_of; &gr_NodeValue; &jd_test_arrow; &gr_NodeValue;
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression>&jd_not;(&dm_nodekind; ( &gr_NodeValue; ) = "text")</expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_test; <code>text()</code>
               &jd_test_with; &gr_PrincipalNodeKind;
               &jd_test_of; &gr_NodeValue; &jd_test_arrow; ()
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <p>The <code>node()</code> node test is true for all
          nodes. Therefore, the following rule does not have any
          precondition (remember that an empty upper part in the rule
          indicates that the rule is always true).</p>
     
          <infergr>
           <infer>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_test; <code>node()</code>
               &jd_test_with; &gr_PrincipalNodeKind;
               &jd_test_of; &gr_NodeValue; &jd_test_arrow; &gr_NodeValue;
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <p>If none of the above rules applies then the node test
          returns the empty sequence, and the following dynamic rule
          is applied:</p>
          
          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><emph>Otherwise</emph></expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_test; &gr_NodeTest;
                 &jd_test_with; &gr_PrincipalNodeKind;
               &jd_test_of; &gr_NodeValue; &jd_test_arrow; ()
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
        </smrules>
       </div5>
      </div4>
    </div3>


  </div2>

  <div2 id="sec_type_matching">
    <head>Judgments for type matching</head>

    <smintro>
      <p>XQuery supports type declarations on variable bindings, and
      several operations on types (<code>typeswitch</code>,
      <code>instance of</code>, etc). This section describes judgments
      used for the specification of the semantics of those
      operations.</p>

      <ulist>
        <item>
          <p>The <quote>match</quote> judgment specifies formally type
          matching. It takes as input a value and a type and either
          succeeds or fails. It is used in matching parameters against
          function signatures, type declarations, and matching values
          against cases in <quote>typeswitch</quote>. An informal
          description of type matching is given in <xspecref spec="XQ"
          ref="id-sequencetype-matching"/>.</p>
        </item>
        <item>
          <p>The <quote>subtyping</quote> judgment takes two types and
          succeeds if all values matching the first type also match
          the second. It is used to define the static semantics of
          operations using type matching.</p>
        </item>
      </ulist>
  
    </smintro>

    <div3 id="sec_matches">
      <head>Matches</head>

      <smnotation>
        <p id="jd_matches">The judgment</p>

        <display>
          <clause>
          <environment>&xq_stat_env;</environment>
          <expression>&gr_Value; &jd_matches; &gr_Type;</expression>
          </clause>
        </display>

        <p>holds when the given value matches the given type.</p>
      </smnotation>

      <smexample>
        <p>For example, assuming the extended XML Schema given in
        section <specref ref="sec_types_example"/>, then the following
        judgments hold.</p>

<eg><![CDATA[
  element comment of type xsd:string { "This is not important" }
    matches
  element comment of type xsd:string

  (element apt of type fs:anon3 { 2510 },
   element apt of type fs:anon3 { 2511 })
    matches
  element apt+

  ()
    matches
  element usaddress?

  element usaddress of type USAddress {
    element name of type xsd:string { "The Archive" },
    element street of type xsd:string { "Christopher Street" },
    element city of type xsd:string { "New York" },
    element state of type xsd:string { "NY" },
    element zip of type xsd:decimal { 10210 }
  }
    matches
  element usaddress?
]]></eg>
      </smexample>

      <smrules>

       <p>We start by giving the inference rules for matching an
        item value with an item type.</p>

        <p>An atomic value matches an atomic type if its <xtermref
        spec="XQ" ref="dt-type-annotation"/> derives from the atomic
        type.  The value itself is ignored -- this is checked as part
        of validation.</p>

        <infergr>
          <infer>
           <prejudge>
             <clause>
              <environment>&xq_stat_env;</environment>
              <expression>&gr_AtomicTypeName1; &jd_derives_from;
              &gr_AtomicTypeName2;</expression>
             </clause>
           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>&gr_AtomicValueContent; of type &gr_AtomicTypeName1; &jd_matches; &gr_AtomicTypeName2;</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>A text node matches text.</p>

        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>text { &gr_String; } &jd_matches; text</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>A comment node matches comment.</p>

        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>comment { &gr_String; } &jd_matches; comment</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>A processing-instruction node matches <phrase diff='chg' at='E022'>the general processing-instruction type,
        and also the particular processing-instruction type that shares its PITarget.</phrase></p>

        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>processing-instruction &gr_NCName; { &gr_String; } &jd_matches; processing-instruction<phrase diff='add' at='E022'> *</phrase></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <infergr diff='add' at='E022'>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>processing-instruction &gr_NCName; { &gr_String; } &jd_matches; processing-instruction &gr_NCName;</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>A document node matches a document type if the node's
        content matches the document type's corresponding content
        type.</p>

        <infergr>
          <infer>
           <prejudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression> &gr_Value; &jd_matches; &gr_Type;
             </expression>
            </clause>
           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>document { &gr_Value; } &jd_matches; document { &gr_Type; }</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>The rules for matching an element value with an element
        type are more complicated.  When an element value is not
        nilled, the element matches an element type if the element
        name and the element type resolve to some type name, and the
        element value's <xtermref spec="XQ" ref="dt-type-annotation"/>
        is derived from the resolved type name.  Note that there is no
        need to check structural constraints on the value since those
        have been checked during XML Schema validation and the value
        is assumed to be consistent with its <xtermref spec="XQ"
        ref="dt-type-annotation"/>.</p>

        <infergr>
          <infer>
           <prejudge>
            <multiclause>
             <clause>
              <environment>&xq_stat_env;</environment>
              <expression>&gr_ElementName; &jd_lookup;
              &gr_ElementType; &jd_lookup_yields; &gr_OptNillable; of
              type &gr_BaseTypeName;</expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <environment>&xq_stat_env;</environment>
              <expression>&gr_TypeName; &jd_derives_from;
              &gr_BaseTypeName;</expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <expression>&gr_Value1; &jd_filter; @xsi:nil
              &jd_filter_arrow; &gr_SimpleValue;</expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <expression>&gr_SimpleValue; &jd_isin; { (), false }</expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>element &gr_ElementName; of type
             &gr_TypeName; { &gr_Value; } &jd_matches;
             &gr_ElementType;</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <smnote>
          <p>Type matching uses the name lookup judgment defined in
          <specref ref="sec_element_lookup"/>.</p>
        </smnote>

        <p>In the case the element has been nilled, that is there
        exists and xsi:nil attribute set to true in the element value,
        the following rule checks that the type is nillable. </p>

        <infergr>
          <infer>
           <prejudge>
            <multiclause>
             <clause>
              <environment>&xq_stat_env;</environment>
              <expression>&gr_ElementName; &jd_lookup;
              &gr_ElementType; &jd_lookup_yields; nillable of type
              &gr_BaseTypeName;</expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <environment>&xq_stat_env;</environment>
              <expression>&gr_TypeName; &jd_derives_from;
              &gr_BaseTypeName;</expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <expression>&gr_Value; &jd_filter; @xsi:nil
              &jd_filter_arrow; true</expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>element &gr_ElementName; of type
             &gr_TypeName; { &gr_Value; } &jd_matches;
             &gr_ElementType;</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>The rule for attributes is similar, but does not require
        the check for the xsi:nil attribute.</p>

        <infergr>
          <infer>
           <prejudge>
            <multiclause>
             <clause>
              <environment>&xq_stat_env;</environment>
              <expression>&gr_AttributeName; &jd_attribute_lookup;
              &gr_AttributeType; &jd_attribute_lookup_yields; of type
              &gr_BaseTypeName;</expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <environment>&xq_stat_env;</environment>
              <expression>&gr_TypeName; &jd_derives_from;
              &gr_BaseTypeName;</expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>attribute &gr_AttributeName; of type
             &gr_TypeName; { &gr_SimpleValue; } &jd_matches;
             &gr_AttributeType;</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>A type can also be a sequence of items, in that case the
        matching rules also need to check whether the constraints
        described by the type as a regular expression hold. This is
        specified by the following rules.</p>

        <p>The empty sequence matches the empty sequence type.</p>

        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>() &jd_matches; &xt_empty;</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>If two values match two types, then their sequence matches
        the corresponding sequence type.</p>

        <infergr>
          <infer>
           <prejudge>
            <multiclause>
             <clause>
              <environment>&xq_stat_env;</environment>
              <expression>&gr_Value1; &jd_matches; &gr_Type1;</expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <environment>&xq_stat_env;</environment>
              <expression>&gr_Value2; &jd_matches; &gr_Type2;</expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>&gr_Value1;,&gr_Value2; &jd_matches; &gr_Type1;,&gr_Type2;</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>If a value matches a type, then it also matches a choice
        type where that type is one of the choices.</p>

        <infergr>
          <infer>
           <prejudge>
             <clause>
              <environment>&xq_stat_env;</environment>
              <expression>&gr_Value; &jd_matches; &gr_Type1;</expression>
             </clause>
           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>&gr_Value; &jd_matches; &gr_Type1;|&gr_Type2;</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <infergr>
          <infer>
           <prejudge>
            <multiclause>
             <clause>
              <environment>&xq_stat_env;</environment>
              <expression>&gr_Value; &jd_matches; &gr_Type2;</expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>&gr_Value; &jd_matches; &gr_Type1;|&gr_Type2;</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>If two values match two types, then their interleaving
        matches the corresponding all group.</p>

        <infergr>
          <infer>
           <prejudge>
            <multiclause>
             <clause>
              <environment>&xq_stat_env;</environment>
              <expression>&gr_Value1; &jd_matches;
              &gr_Type1;</expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <environment>&xq_stat_env;</environment>
              <expression>&gr_Value2; &jd_matches;
              &gr_Type2;</expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <environment>&xq_stat_env;</environment>
              <expression>&gr_Value1; &jd_interleave; &gr_Value2;
              &jd_interleave_yields; &gr_Value;</expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>&gr_Value; &jd_matches; &gr_Type1; &amp;
             &gr_Type2;</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>An optional type matches a value of that type or the empty
        sequence.</p>

        <infergr>
          <infer>
           <prejudge>
             <clause>
              <environment>&xq_stat_env;</environment>
              <expression>&gr_Value; &jd_matches;
              (&gr_Type; | empty)</expression>
             </clause>
           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>&gr_Value; &jd_matches; &gr_Type;?</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>The following rules are used to match a value against a
        sequence of zero (or one) or more types.</p>

        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>() &jd_matches; &gr_Type;*</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <infergr>
          <infer>
           <prejudge>
             <clause>
              <environment>&xq_stat_env;</environment>
              <expression>&gr_Value1; &jd_matches; &gr_Type;</expression>
             </clause>
             <clause>
              <environment>&xq_stat_env;</environment>
              <expression>&gr_Value2; &jd_matches; &gr_Type;*</expression>
             </clause>
           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>&gr_Value1;, &gr_Value2; &jd_matches; &gr_Type;*</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <infergr>
          <infer>
           <prejudge>
             <clause>
              <environment>&xq_stat_env;</environment>
              <expression>&gr_Value1; &jd_matches; &gr_Type;</expression>
             </clause>
             <clause>
              <environment>&xq_stat_env;</environment>
              <expression>&gr_Value2; &jd_matches; &gr_Type;*</expression>
             </clause>
           </prejudge>
           <postjudge>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>&gr_Value1;, &gr_Value2; &jd_matches; &gr_Type;+</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

      </smrules>

      <smnote>
        <p>The above definition of type matching, although complete
        and precise, does not give a simple means to
        <emph>compute</emph> type matching. Notably, some of the above
        rules can be non-deterministic (e.g., the rule for matching of
        choice or repetition).</p>

        <p>The structural component of the &language; type system can
        be modeled by regular expressions. Regular expressions can be
        implemented by means of finite state automata. Computing type
        matching then is equivalent to check if a given sequence of
        items is <emph>recognized</emph> by its corresponding finite
        state automata. Finite state automata and their relationships
        to regular expressions have been extensively studied and
        documented in computer-science literature. The interested reader can
        consult the relevant literature, for instance <bibref
        ref="Languages"/>, or <bibref ref="TATA"/>.</p>
      </smnote>
    </div3>

    <div3 id="sec_subtyping">
      <head>Subtyping (&lt;:)</head>

      <smintro>
        <p>This section defines the semantics of subtyping in
        &language;. Subtyping is used during static type analysis, in
        typeswitch, treat and assert expressions, and to check the
        correctness of function applications.</p>

        <p>Note that intuitive relationships between types. For
        instance, that (&gr_Type;,()) is equivalent to &gr_Type; can
        be deduced using the subtyping judgment (and algorithm)
        described here.</p>
      </smintro>

      <smnotation>
        <p id="jd_subtype_of">The judgment</p>
      
        <display>
          <clause>
          <environment>&xq_stat_env;</environment>
          <expression>&gr_Type1; &jd_subtype_of; &gr_Type2;</expression>
          </clause>
        </display>
      
        <p>holds if the first type is a subtype of the second.</p>
      </smnotation>

      <smrules>
        <p>This judgment is true if and only if, for every value
        &gr_Value;, if &gr_Value; &jd_matches; &gr_Type1; holds, then
        &gr_Value; &jd_matches; &gr_Type2; also holds.</p>
      </smrules>
  
      <smnote>
        <p>It is easy to see that the subtype relation &jd_subtype_of;
        is a partial order, i.e. it is <term>reflexive</term>:</p>
  
        <clause>
          <environment> &xq_stat_env; </environment>
          <expression>
            &gr_Type; &jd_subtype_of; &gr_Type;
          </expression>
        </clause>
  
        <p>and it is <term>transitive</term>: if,</p>
  
        <clause><environment> &xq_stat_env; </environment>
          <expression>
            &gr_Type1; &jd_subtype_of; &gr_Type2;
          </expression>
        </clause>
  
        <p>and,</p>
  
        <clause><environment> &xq_stat_env; </environment>
          <expression>
            &gr_Type2; &jd_subtype_of; &gr_Type3;
          </expression>
        </clause>
  
        <p>then,</p>
  
        <clause><environment> &xq_stat_env; </environment>
          <expression>
            &gr_Type1; &jd_subtype_of; &gr_Type3;
          </expression>
        </clause>

        <p>Finally, two types are equal if each is a subtype of the
        other, that is: </p>

        <clause><environment> &xq_stat_env; </environment>
          <expression>
            &gr_Type1; &jd_subtype_of; &gr_Type2;
          </expression>
        </clause>
  
        <p>and,</p>
  
        <clause><environment> &xq_stat_env; </environment>
          <expression>
            &gr_Type2; &jd_subtype_of; &gr_Type1;
          </expression>
        </clause>
  
        <p>then,</p>
  
        <clause><environment> &xq_stat_env; </environment>
          <expression>
            &gr_Type1; = &gr_Type2;
          </expression>
        </clause>

      </smnote>

      <smnote>
        <p>The above definition, although complete and precise, does
        not give a simple means to <emph>compute</emph>
        subtyping. Notably the definition above refers to values,
        which are not available at static type checking time.</p>

        <p>The structural component of the &language; type system can
        be modeled by regular expressions. Regular expressions can be
        implemented by means of finite state automata. Computing
        subtyping between two types can then be done by computing if
        <emph>inclusion</emph> holds between their corresponding
        finite state automata.</p>
    
        <p>Finite state automata and how to compute operations on
        those automata, such as inclusion, emptiness or intersection,
        have been extensively studied and documented in the
        literature. The interested reader can consult the relevant
        literature on tree grammars, for instance <bibref
        ref="Languages"/>, or <bibref ref="TATA"/>.</p>
      </smnote>

    </div3>

  </div2>

  <div2 id="sec_factor">
    <head>Judgments for FLWOR and other expressions on sequences</head>

    <smintro>
      <p>Some &language; operations work on sequences of items. For
      instance, &for-name; expressions iterate over a sequence of
      items and the &fn_unordered; function can return all items in a
      sequence in any order, etc.</p>

      <p>Static typing for those operations needs to infer a type
      acceptable for <emph>all</emph> the items in the sequence. This
      sometimes requires approximating the type known for each item
      individually.</p>

    </smintro>
    
    <smexample>

      <p>Assume the variable <code>$shipTo</code> is bound to the
      shipTo element</p>

<eg><![CDATA[
    <shipTo country="US">
        <name>Alice Smith</name>
        <street>123 Maple Street</street>
        <city>Mill Valley</city>
        <state>CA</state>
        <zip>90952</zip>
    </shipTo>
]]></eg>

      <p>and has type</p>

<eg><![CDATA[
   element shipTo of type USAddress
]]></eg>

      <p>The following query orders all children of the shipTo element
      by alphabetical order of their content.</p>

<eg><![CDATA[
   for $x in $shipTo/*
   order by $x/text()
   return $x
]]></eg>

      <p>resulting in the sequence</p>

<eg><![CDATA[
    (<street>123 Maple Street</street>,
     <zip>90952</zip>,
     <name>Alice Smith</name>,
     <state>CA</state>,
     <city>Mill Valley</city>)
]]></eg>

      <p>This operation iterates over the elements in the input
      sequence returned by the expression <code>$shipTo/*</code>,
      whose type is the content of a type USAddress.</p>

<eg><![CDATA[
    (element name of type xsd:string,
     element street of type xsd:string,
     element city of type xsd:string,
     element state of type xsd:string,
     element zip of type xsd:decimal)
]]></eg>

      <p>During static typing, one must give a type to the variable
      <code>$x</code> which corresponds to the type of each element in
      the sequence. Since each item is of a different type, one must
      find an item type which is valid for all cases in the
      sequence. This can be done by using a choice for the variable
      <code>$x</code>, as follows</p>

<eg><![CDATA[
    (element name of type xsd:string |
     element street of type xsd:string |
     element city of type xsd:string |
     element state of type xsd:string |
     element zip of type xsd:decimal)
]]></eg>

      <p>This type indicates that the type of the variable can be of
      any of the item types in the input sequence.</p>

      <p>The static inference also needs to approximate the number of
      occurrences of items in the sequence. In this example, there is
      at least one item and more than one, so the closest occurrence
      indicator is <code>+</code> for one or more items.</p>

      <p>The static inference for this example finally results in the
      following type.</p>

<eg><![CDATA[
    (element name of type xsd:string |
     element street of type xsd:string |
     element city of type xsd:string |
     element state of type xsd:string |
     element zip of type xsd:decimal)+
]]></eg>

      <p><termdef term="prime type" id="term-prime-type">A <term><phrase diff='chg' at='E015'>prime
      type</phrase></term> is a choice of item types<phrase diff='chg' at='E015'>.</phrase></termdef> This section
      defines two functions on types that compute the prime type of an
      arbitrary type, and approximate the occurrence of items in an
      arbitrary type.  These type functions are used in the static
      semantics of many expressions, including <quote>for</quote>,
      <quote>some</quote>, and <quote>every</quote> expressions, and
      many functions, including <quote>fn:unordered</quote> and
      <phrase diff='del' at='E053'><quote>fn:distinct</quote></phrase>
      <phrase diff='add' at='E053'><quote>fn:distinct-values</quote></phrase>.</p>

    </smexample>

    <smnotation>
      <p>A choice of item types is called a <emph>prime type</emph>,
      as described by the following grammar production.</p>
      
      <scrap>
        <head>Prime Types</head>
        <prodrecap ref="PrimeType" id="PrimeType" orig="formal"/>
      </scrap>
  
    </smnotation>
    
    <smnotation>
      <p id="jd_prime">The type function &jd_prime;(&gr_Type;)
      extracts all item types from the type &gr_Type;, and combines
      them into a choice.</p>

      <p id="jd_quantifier">The function &jd_quantifier;(&gr_Type;)
      approximates the possible number of items in &gr_Type; with the
      occurrence indicators supported by the &language; type system
      (<code>?, +, *</code>).</p>

      <p>For interim results, the auxiliary occurrence
      indicator <code>1</code> denotes  exactly one occurrence.</p>
    </smnotation>

    <smrules>
      <p>The &jd_prime; function is defined by induction as
      follows.</p>
    
      <table summary="" role="figure">
        <col align="left"/>
        <col align="center"/>
        <col align="left"/>
        <tbody>
        <tr><td>&jd_prime;(&gr_FormalItemType;)</td>
            <td>&sp2;=&sp2;</td>
            <td>&gr_FormalItemType;</td>
        </tr>
        <tr><td>&jd_prime;(&xt_empty;)</td>
            <td>&sp2;=&sp2;</td>
            <td>&xt_none;</td>
        </tr>
          <tr><td>&jd_prime;(&xt_none;)</td>
            <td>&sp2;=&sp2;</td>
            <td>&xt_none;</td>
        </tr>
        <tr><td>&jd_prime;(&gr_Type1; , &gr_Type2;)</td>
            <td>&sp2;=&sp2;</td>
            <td>&jd_prime;(&gr_Type1;) | &jd_prime;(&gr_Type2;)</td>
        </tr>
        <tr><td>&jd_prime;(&gr_Type1; &amp; &gr_Type2;)</td>
            <td>&sp2;=&sp2;</td>
            <td>&jd_prime;(&gr_Type1;) | &jd_prime;(&gr_Type2;)</td>
        </tr>
        <tr><td>&jd_prime;(&gr_Type1; | &gr_Type2;)</td>
            <td>&sp2;=&sp2;</td>
            <td>&jd_prime;(&gr_Type1;) | &jd_prime;(&gr_Type2;)</td>
        </tr>
        <tr><td>&jd_prime;(&gr_Type;?)</td>
            <td>&sp2;=&sp2;</td>
            <td>&jd_prime;(&gr_Type;)</td>
        </tr>
        <tr><td>&jd_prime;(&gr_Type;*)</td>
            <td>&sp2;=&sp2;</td>
            <td>&jd_prime;(&gr_Type;)</td>
        </tr>
        <tr><td>&jd_prime;(&gr_Type;+)</td>
            <td>&sp2;=&sp2;</td>
            <td>&jd_prime;(&gr_Type;)</td>
        </tr>
        </tbody>
      </table>

    </smrules>

    <smrules>
      <p>The &jd_quantifier; function is defined by induction as
      follows.</p>
      
      <table summary="" role="figure">
        <col align="left"/>
        <col align="center"/>
        <col align="left"/>
        <tbody>
        <tr><td>&jd_quantifier;(&gr_FormalItemType;)</td>
            <td>&sp2;=&sp2;</td>
            <td>1</td>
        </tr>
        <tr><td>&jd_quantifier;(&xt_empty;)</td>
            <td>&sp2;=&sp2;</td>
            <td>?</td>
        </tr>
          <tr><td>&jd_quantifier;(&xt_none;)</td>
            <td>&sp2;=&sp2;</td>
            <td>1</td>
        </tr>
        <tr><td>&jd_quantifier;(&gr_Type1; , &gr_Type2;)</td>
            <td>&sp2;=&sp2;</td>
            <td>&jd_quantifier;(&gr_Type1;) , &jd_quantifier;(&gr_Type2;)</td>
        </tr>
        <tr><td>&jd_quantifier;(&gr_Type1; &amp; &gr_Type2;)</td>
            <td>&sp2;=&sp2;</td>
            <td>&jd_quantifier;(&gr_Type1;) , &jd_quantifier;(&gr_Type2;)</td>
        </tr>
        <tr><td>&jd_quantifier;(&gr_Type1; | &gr_Type2;)</td>
            <td>&sp2;=&sp2;</td>
            <td>&jd_quantifier;(&gr_Type1;) | &jd_quantifier;(&gr_Type2;)</td>
        </tr>
        <tr><td>&jd_quantifier;(&gr_Type;?)</td>
            <td>&sp2;=&sp2;</td>
            <td>&jd_quantifier;(&gr_Type;) &type_occurs_product; ?</td>
        </tr>
        <tr><td>&jd_quantifier;(&gr_Type;*)</td>
            <td>&sp2;=&sp2;</td>
            <td>&jd_quantifier;(&gr_Type;) &type_occurs_product; *</td>
        </tr>
        <tr><td>&jd_quantifier;(&gr_Type;+)</td>
            <td>&sp2;=&sp2;</td>
            <td>&jd_quantifier;(&gr_Type;) &type_occurs_product; +</td>
        </tr>
        </tbody>
      </table>
      
      <p>This definition uses the sum (&gr_Occurrence1; ,
      &gr_Occurrence2;), the choice (&gr_Occurrence1; |
      &gr_Occurrence2;), and the product (&gr_Occurrence1; &type_occurs_product;
      &gr_Occurrence2;) of two occurrence indicators &gr_Occurrence1;,
      &gr_Occurrence2;, which are defined by the following tables.</p>
      
      <table summary="" role="figure">
        <tbody>
        <tr>
        <td>
        <table summary="" border="1">
        <tbody>
<!--        <tr><td>&sp1;,&sp1;</td><td>&sp1;0&sp1;</td><td>&sp1;1&sp1;</td><td>&sp1;?&sp1;</td><td>&sp1;+&sp1;</td><td>&sp1;*&sp1;</td></tr> -->
        <tr><td>&sp1;,&sp1;</td><td>&sp1;1&sp1;</td><td>&sp1;?&sp1;</td><td>&sp1;+&sp1;</td><td>&sp1;*&sp1;</td></tr>
<!--        <tr><td>&sp1;0&sp1;</td><td>&sp1;0&sp1;</td><td>&sp1;1&sp1;</td><td>&sp1;?&sp1;</td><td>&sp1;+&sp1;</td><td>&sp1;*&sp1;</td></tr>-->
        <tr><td>&sp1;1&sp1;</td><td>&sp1;+&sp1;</td><td>&sp1;+&sp1;</td><td>&sp1;+&sp1;</td><td>&sp1;+&sp1;</td></tr>
        <tr><td>&sp1;?&sp1;</td><td>&sp1;+&sp1;</td><td>&sp1;*&sp1;</td><td>&sp1;+&sp1;</td><td>&sp1;*&sp1;</td></tr>
        <tr><td>&sp1;+&sp1;</td><td>&sp1;+&sp1;</td><td>&sp1;+&sp1;</td><td>&sp1;+&sp1;</td><td>&sp1;+&sp1;</td></tr>
        <tr><td>&sp1;*&sp1;</td><td>&sp1;+&sp1;</td><td>&sp1;*&sp1;</td><td>&sp1;+&sp1;</td><td>&sp1;*&sp1;</td></tr>
        </tbody>
        </table>
        </td>
        <td>&sp4;</td>
        <td>
        <table summary="" border="1">
        <tbody>
<!--        <tr><td>&sp1;|&sp1;</td><td>&sp1;0&sp1;</td><td>&sp1;1&sp1;</td><td>&sp1;?&sp1;</td><td>&sp1;+&sp1;</td><td>&sp1;*&sp1;</td></tr>-->
        <tr><td>&sp1;|&sp1;</td><td>&sp1;1&sp1;</td><td>&sp1;?&sp1;</td><td>&sp1;+&sp1;</td><td>&sp1;*&sp1;</td></tr>
<!--        <tr><td>&sp1;0&sp1;</td><td>&sp1;0&sp1;</td><td>&sp1;?&sp1;</td><td>&sp1;?&sp1;</td><td>&sp1;*&sp1;</td><td>&sp1;*&sp1;</td></tr>-->
        <tr><td>&sp1;1&sp1;</td><td>&sp1;1&sp1;</td><td>&sp1;?&sp1;</td><td>&sp1;+&sp1;</td><td>&sp1;*&sp1;</td></tr>
        <tr><td>&sp1;?&sp1;</td><td>&sp1;?&sp1;</td><td>&sp1;?&sp1;</td><td>&sp1;*&sp1;</td><td>&sp1;*&sp1;</td></tr>
        <tr><td>&sp1;+&sp1;</td><td>&sp1;+&sp1;</td><td>&sp1;*&sp1;</td><td>&sp1;+&sp1;</td><td>&sp1;*&sp1;</td></tr>
        <tr><td>&sp1;*&sp1;</td><td>&sp1;*&sp1;</td><td>&sp1;*&sp1;</td><td>&sp1;*&sp1;</td><td>&sp1;*&sp1;</td></tr>
        </tbody>
        </table>
        </td>
        <td>&sp4;</td>
        <td>
        <table summary="" border="1">
        <tbody>
<!--        <tr><td>&sp1;&middot;&sp1;</td><td>&sp1;0&sp1;</td><td>&sp1;1&sp1;</td><td>&sp1;?&sp1;</td><td>&sp1;+&sp1;</td><td>&sp1;*&sp1;</td></tr> -->
        <tr><td>&sp1;&middot;&sp1;</td><td>&sp1;1&sp1;</td><td>&sp1;?&sp1;</td><td>&sp1;+&sp1;</td><td>&sp1;*&sp1;</td></tr>
<!--        <tr><td>&sp1;0&sp1;</td><td>&sp1;0&sp1;</td><td>&sp1;0&sp1;</td><td>&sp1;0&sp1;</td><td>&sp1;0&sp1;</td><td>&sp1;0&sp1;</td></tr> -->
        <tr><td>&sp1;1&sp1;</td><td>&sp1;1&sp1;</td><td>&sp1;?&sp1;</td><td>&sp1;+&sp1;</td><td>&sp1;*&sp1;</td></tr>
        <tr><td>&sp1;?&sp1;</td><td>&sp1;?&sp1;</td><td>&sp1;?&sp1;</td><td>&sp1;*&sp1;</td><td>&sp1;*&sp1;</td></tr>
        <tr><td>&sp1;+&sp1;</td><td>&sp1;+&sp1;</td><td>&sp1;*&sp1;</td><td>&sp1;+&sp1;</td><td>&sp1;*&sp1;</td></tr>
        <tr><td>&sp1;*&sp1;</td><td>&sp1;*&sp1;</td><td>&sp1;*&sp1;</td><td>&sp1;*&sp1;</td><td>&sp1;*&sp1;</td></tr>
        </tbody>
        </table>
        </td>
        </tr>
        </tbody>
      </table>
      
    </smrules>

    <smexamples>
      <p>For example, here are the result of applying &jd_prime; and
      &jd_quantifier; on a few simple types.</p>

<eg><![CDATA[
  prime(element a+)                         = element a
  prime(element a | empty)                  = element a
  prime(element a?,element b?)              = element a | element b
  prime(element a | element b+, element c*) = element a | element b | element c

  quantifier(element a+)                         = +
  quantifier(element a | empty)                  = ?
  quantifier(element a?,element b?)              = *
  quantifier(element a | element b+, element d*) = +
]]></eg>

      <p>Note that the last occurrence indicator should be '+', since
      the regular expression is such that there must be at least one
      element in the sequence (this element being an 'a' element or a
      'b' element).</p>
    </smexamples>

    <smnote>
      <p>Note that &jd_prime;(&gr_Type;) &middot;
      &jd_quantifier;(&gr_Type;) is always a super type of the
      original type &gr_Type; I.e.,
      <phrase diff='del' at='E054'>
      &jd_prime;(&gr_Type;) &middot; &jd_quantifier;(&gr_Type;) &jd_subtype_of; &gr_Type;
      </phrase>
      <phrase diff='add' at='E054'>
      &gr_Type; &jd_subtype_of; &jd_prime;(&gr_Type;) &middot; &jd_quantifier;(&gr_Type;)
      </phrase>
      always
      holds. Therefore, it is appropriate to used it as an
      approximation for the type of an expression. This property is
      required for the soundness of the static type analysis.</p>

    </smnote>

    <smrules>
      <p>Finally, a type &gr_Type; and an occurrence indicator can be
      combined back together to yield a new type with the &middot;
      operation, as follows.</p>
    
      <table summary="" role="figure">
        <col align="left"/>
        <col align="center"/>
        <col align="left"/>
        <tbody>
        <tr><td>&gr_Type; &type_occurs_product; 1</td>
            <td>&sp2;=&sp2;</td>
            <td>&gr_Type;</td>
        </tr>
        <tr><td>&gr_Type; &type_occurs_product; ?</td>
              <td>&sp2;=&sp2;</td>
              <td>&gr_Type;?</td>
        </tr>
        <tr><td>&gr_Type; &type_occurs_product; +</td>
              <td>&sp2;=&sp2;</td>
              <td>&gr_Type;+</td>
          </tr>
          <tr><td>&gr_Type; &type_occurs_product; *</td>
              <td>&sp2;=&sp2;</td>
              <td>&gr_Type;*</td>
          </tr>
        </tbody>
      </table>
    
    </smrules>

  </div2>

  <div2 id="sec_promotion_judgments">
    <head>Judgments for function calls</head>

    <smintro>
      <p>Function calls can perform type promotion between atomic
      types. This section introduces judgments which describe type
      promotion for the purpose of the dynamic and static semantics.
      These promotion rules include promoting &xs_untypedAtomic; to any
      other type.</p>
    </smintro>

    <div3 id="sec_promotion"><head>Type promotion</head>
    <smnotation>
      <p id="jd_can_be_promoted_to">The judgment</p>

      <display>
          <clause>
             <environment>&xq_stat_env;</environment>
             <expression>&gr_Type1; &jd_can_be_promoted_to; &gr_Type2;</expression>
          </clause>
      </display>
    
      <p>holds if type &gr_Type1; can be promoted to type
      &gr_Type2;.</p>
    
    </smnotation>

    <smexample>
      <p>For example, the following judgments hold:</p>

<eg><![CDATA[
  xs:integer  can be promoted to  xs:integer
  xs:decimal  can be promoted to  xs:float
  xs:integer  can be promoted to  xs:float
  xs:float    can be promoted to  xs:double
]]></eg>
    </smexample>

    <smrules>
      <p>This judgment is specified by the following rules.</p>

      <p>&xs_decimal; can be promoted to &xs_float;:</p>

      <infergr>
       <infer>
        <prejudge>
        </prejudge>
        <postjudge>
         <multiclause>
          <clause><environment>&xq_stat_env;</environment>
           <expression>
             &xs_decimal; &jd_can_be_promoted_to; &xs_float;
           </expression>
          </clause>
         </multiclause>
        </postjudge>
       </infer>
      </infergr>

      <p>&xs_float; can be promoted to &xs_double;:</p>

      <infergr>
       <infer>
        <prejudge>
        </prejudge>
        <postjudge>
         <multiclause>
          <clause><environment>&xq_stat_env;</environment>
           <expression>
             &xs_float; &jd_can_be_promoted_to; &xs_double;
           </expression>
          </clause>
         </multiclause>
        </postjudge>
       </infer>
      </infergr>

      <p diff='add' at='E010'>&xs_anyURI; can be promoted to &xs_string;:</p>

      <infergr diff='add' at='E010'>
       <infer>
        <prejudge>
        </prejudge>
        <postjudge>
         <multiclause>
          <clause><environment>&xq_stat_env;</environment>
           <expression>
             &xs_anyURI; &jd_can_be_promoted_to; &xs_string;
           </expression>
          </clause>
         </multiclause>
        </postjudge>
       </infer>
      </infergr>

      <p>&xs_untypedAtomic; can be promoted to any atomic type:</p>

      <infergr>
       <infer>
        <prejudge>
         <multiclause>
          <clause><environment>&xq_stat_env;</environment>
           <expression>
             &gr_Type; &jd_subtype_of; &xs_anyAtomicType;
           </expression>
          </clause>
         </multiclause>
        </prejudge>
        <postjudge>
         <multiclause>
          <clause><environment>&xq_stat_env;</environment>
           <expression>
             &xs_untypedAtomic; &jd_can_be_promoted_to; &gr_Type;
           </expression>
          </clause>
         </multiclause>
        </postjudge>
       </infer>
      </infergr>

      <p>A type can be promoted to itself or to any type of which it
      is a subtype:</p>

      <infergr>
       <infer>
        <prejudge>
        </prejudge>
        <postjudge>
         <multiclause>
          <clause><environment>&xq_stat_env;</environment>
           <expression>
             &gr_Type; &jd_can_be_promoted_to; &gr_Type;
           </expression>
          </clause>
         </multiclause>
        </postjudge>
       </infer>
      </infergr>

      <infergr>
       <infer>
        <prejudge>
         <clause>
           <environment> &xq_stat_env; </environment>
           <expression>
             &gr_Type; &jd_subtype_of; &gr_Type1;
           </expression>
         </clause>
        </prejudge>
        <postjudge>
         <multiclause>
          <clause><environment>&xq_stat_env;</environment>
           <expression>
             &gr_Type; &jd_can_be_promoted_to; &gr_Type1;
           </expression>
          </clause>
         </multiclause>
        </postjudge>
       </infer>
      </infergr>

      <p>Type promotion is transitive:</p>

      <infergr>
       <infer>
        <prejudge>
          <clause><environment>&xq_stat_env;</environment>
           <expression>
             &gr_Type1; &jd_can_be_promoted_to; &gr_Type2;
           </expression>
          </clause>
          <clause><environment>&xq_stat_env;</environment>
           <expression>
             &gr_Type2; &jd_can_be_promoted_to; &gr_Type3;
           </expression>
          </clause>
        </prejudge>
        <postjudge>
         <multiclause>
          <clause><environment>&xq_stat_env;</environment>
           <expression>
             &gr_Type1; &jd_can_be_promoted_to; &gr_Type3;
           </expression>
          </clause>
         </multiclause>
        </postjudge>
       </infer>
      </infergr>

      <p>Finally, type promotion distributes over occurrence and union
      constructors.</p>

      <infergr>
        <infer>
          <prejudge>
            <clause><environment>&xq_stat_env;</environment>
              <expression>
                &jd_prime;(&gr_Type1;) &jd_can_be_promoted_to; &jd_prime;(&gr_Type2;)
              </expression>
            </clause>
            <clause>
              <expression>
                &jd_quantifier;(&gr_Type1;) &lt;= &jd_quantifier;(&gr_Type2;)
              </expression>
            </clause>
          </prejudge>
          <postjudge>
            <multiclause>
              <clause><environment>&xq_stat_env;</environment>
                <expression>
                  &gr_Type1; &jd_can_be_promoted_to; &gr_Type2;
                </expression>
              </clause>
            </multiclause>
          </postjudge>
        </infer>

        <infer>
          <prejudge>
            <clause><environment>&xq_stat_env;</environment>
              <expression>
                &gr_Type1; &jd_can_be_promoted_to; &gr_Type;
              </expression>
            </clause>
            <clause>
             <environment>&xq_stat_env;</environment>
             <expression>
                &gr_Type2; &jd_can_be_promoted_to; &gr_Type;
              </expression>
            </clause>
          </prejudge>
          <postjudge>
            <multiclause>
              <clause><environment>&xq_stat_env;</environment>
                <expression>
                  (&gr_Type1; | &gr_Type2;) &jd_can_be_promoted_to; &gr_Type;
                </expression>
              </clause>
            </multiclause>
          </postjudge>
        </infer>
      </infergr>
    </smrules>

    <p>where the <quote>&lt;=</quote> operator for occurrence
      indicators denotes set inclusion of the subsets of the allowed
      occurrences.</p>

    <smnotation>
      <p id="jd_promotes_to">The judgment</p>

      <display>
          <clause>
        <environment>&xq_stat_env;</environment>
        <expression>&gr_Value1; &jd_promotes_against; &gr_Type2;
        &jd_promotes_to; &gr_Value2;</expression>
          </clause>
      </display>
    
      <p>holds if value &gr_Value1; can be promoted to the value
      &gr_Value2; against the type &gr_Type2;.</p>

    </smnotation>

    <smexample>
      <p>For example, the following judgments hold</p>

<eg><![CDATA[
  1     of type xs:integer  against  xs:integer  promotes to  1     of type xs:integer
  1     of type xs:integer  against  xs:decimal  promotes to  1     of type xs:integer
  1     of type xs:integer  against  xs:float    promotes to  1.0e0 of type xs:float
  1.0e0 of type xs:float    against  xs:double   promotes to  1.0e0 of type xs:double
]]></eg>

       <p>Note that type promotion changes the value, and only occurs
       if the input value does not match the target type.</p>
    </smexample>

    <smrules>
      <p>This judgment is specified by the following rules.</p>

      <p>If the value matches the target type, then it is promoted to
      itself</p>

      <infergr>
       <infer>
        <prejudge>
         <multiclause>
          <clause>
           <environment>&xq_stat_env;</environment>
           <expression>&gr_Value; &jd_matches; &gr_Type;</expression>
          </clause>
         </multiclause>
        </prejudge>
        <postjudge>
         <multiclause>
          <clause><environment>&xq_stat_env;</environment>
           <expression>
            &gr_Value; &jd_promotes_against; &gr_Type; &jd_promotes_to; &gr_Value;
           </expression>
          </clause>
         </multiclause>
        </postjudge>
       </infer>
      </infergr>

      <p>If the value does not match the target type, but is an atomic
      value and it matches a type which can be promoted to the target
      type, then the value is cast to the target type.</p>

      <infergr>
       <infer>
        <prejudge>
         <multiclause>
          <clause><environment>&xq_stat_env;</environment>
           <expression>
             &gr_AtomicValue1; &jd_matches; &gr_AtomicType1;
           </expression>
          </clause>
         </multiclause>
         <multiclause>
          <clause><environment>&xq_stat_env;</environment>
           <expression>
             &gr_AtomicType1; &jd_can_be_promoted_to; &gr_AtomicType2;
           </expression>
          </clause>
         </multiclause>
         <multiclause>
          <clause>
           <expression>
             &gr_AtomicType1; != &gr_AtomicType2;
           </expression>
          </clause>
         </multiclause>
         <multiclause>
           <clause>
           <expression>&gr_AtomicValue1; &jd_cast_value_to; &gr_AtomicType2;
           &jd_cast_value_to_arrow; &gr_AtomicValue2;</expression>
           </clause>
         </multiclause>
        </prejudge>
        <postjudge>
         <multiclause>
          <clause><environment>&xq_stat_env;</environment>
           <expression>
             &gr_AtomicValue1; &jd_promotes_against; &gr_AtomicType2; &jd_promotes_to; &gr_AtomicValue2;
           </expression>
          </clause>
         </multiclause>
        </postjudge>
       </infer>
      </infergr>
    </smrules>

   </div3>

  </div2>

  <div2 id="sec_validation_mode">
    <head>Judgments for validation modes and contexts</head>

    <div3 id="jd_aux_context_is"><head>Elements in validation mode</head>
    <smnotation>

      <p>A validation mode may occur explicitly in a validate
      expression <specref ref="sec_validate_expr"/>. The following
      &jd_with_mode; judgment resolves an element name within a given
      validation mode to the type that the element name denotes. The
      judgment is used in the semantics of the validate expression and
      in sequence type.</p>

      <p id="jd_in_validation_context">The judgment</p>

        <display>
          <clause>
          <environment>&xq_stat_env;</environment>
          <expression>&gr_ElementNameOrWildcard; &jd_with_mode; &gr_ValidationMode; &jd_context_resolves; &gr_Type;</expression>
          </clause>
        </display>
        <p>holds when the possibly optional element name resolves to
        the given type in the given validation mode.</p>
    </smnotation>

    <smrules>
      <p>We start with the rules for the global validation
      context.</p>

      <p>If no element name is present, the global validation context
      resolves to the union of all element types that are globally
      declared.</p>

      <infergr>
        <infer>
         <prejudge>
         <multiclause>
          <clause>
           <environment>&xq_stat_env;</environment>
           <expression>
             &gr_ElementName1; &jd_elem_qname_expands_to; &xd_qname1;
           </expression>
          </clause>
         </multiclause>
<multiclause><clause><expression>...</expression></clause></multiclause>
         <multiclause>
          <clause>
           <environment>&xq_stat_env;</environment>
           <expression>
             &gr_ElementNamen; &jd_elem_qname_expands_to; &xd_qnamen;
           </expression>
          </clause>
         </multiclause>

<multiclause>
<clause>
<expression>
&xq_elem_decl;(&xd_qname1;) = define element &gr_ElementName1; &gr_OptSubstitution1; &gr_OptNillable1; &gr_TypeReference1; </expression>
</clause>
</multiclause>
<multiclause><clause><expression>...</expression></clause></multiclause>
<multiclause>
<clause>
<expression>
&xq_elem_decl;(&xd_qnamen;) = define element &gr_ElementNamen; &gr_OptSubstitutionn; &gr_OptNillablen; &gr_TypeReferencen; </expression>
</clause>
</multiclause>
         </prejudge>
         <postjudge>
          <clause>
           <environment>&xq_stat_env;</environment>
          <expression><phrase diff='add' at='E023'>* </phrase>&jd_with_mode; &gr_ValidationMode;
          &jd_context_resolves; (element &gr_ElementName1; | ... |
          element &gr_ElementNamen;)</expression>
          </clause>
         </postjudge>
        </infer>
      </infergr>

      <p>If the element name is globally declared in the schema, it
      resolves to the element type of the corresponding global element
      declaration, independently of the validation mode.</p>

      <infergr>
        <infer>
         <prejudge>
         <multiclause>
          <clause>
           <environment>&xq_stat_env;</environment>
           <expression>
             &gr_ElementName; &jd_elem_qname_expands_to; &xd_qname;
           </expression>
          </clause>
         </multiclause>
<multiclause>
<clause>
<expression>
&xq_elem_decl;(&xd_qname;) = define element &gr_ElementName; &gr_OptSubstitution; &gr_OptNillable; &gr_TypeReference;</expression>
          </clause>
          </multiclause>
         </prejudge>
         <postjudge>
          <clause>
           <environment>&xq_stat_env;</environment>
          <expression>&gr_ElementName; &jd_with_mode;
          &gr_ValidationMode; &jd_context_resolves; element &gr_ElementName;</expression>
          </clause>
         </postjudge>
        </infer>
      </infergr>

      <p>If an element name is not globally defined and the validation
      mode is lax, then the element name resolves to the element type
      with the given element name with any content type.</p>

      <infergr>
        <infer>
         <prejudge>
         <multiclause>
          <clause>
           <environment>&xq_stat_env;</environment>
           <expression>
             &gr_ElementName; &jd_elem_qname_expands_to; &xd_qname;
           </expression>
          </clause>
         </multiclause>
<multiclause>
<clause>
<expression>
&xq_elem_decl;(&xd_qname;) undefined </expression>
          </clause>
          </multiclause>
         </prejudge>
         <postjudge>
          <clause>
           <environment>&xq_stat_env;</environment>
          <expression>&gr_ElementName; &jd_with_mode; lax
          &jd_context_resolves; element &gr_ElementName; of type &xs_anyType;</expression>
          </clause>
         </postjudge>
        </infer>
      </infergr>

     </smrules>
    </div3>

  </div2>
</div1>


<!--  Keep this comment at the end of the file
Local variables:
mode: xml
sgml-indent-step:2
indent-tabs-mode:nil
sgml-parent-document:("XPathXQuerySemantics.xml" "body" "div1")
End:
-->

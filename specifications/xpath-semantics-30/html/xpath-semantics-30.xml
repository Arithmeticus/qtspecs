<!--XSLT Processor: SAXON 9.1.0.5 from Saxonica SAXON 9.1.0.5--><spec xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax" id="spec-top" w3c-doctype="wd"><!-- W3C header, disclaimers and abstracts --><header id="spec-header"><title>XQuery and XPath Formal Semantics 3.0</title><version/><w3c-designation>WD-xpath-semantics-30</w3c-designation><!--  <w3c-doctype>W3C Internal Draft</w3c-doctype> --><w3c-doctype>W3C Working Draft</w3c-doctype><pubdate><day>31</day><month>December</month><year>2008</year></pubdate><publoc>
    <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2008/WD-xpath-semantics-30-20081231/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2008/WD-xpath-semantics-30-20081231/</loc>
  </publoc><altlocs><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2008/WD-xpath-semantics-30-20081231/xpath-semantics-30.xml" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML</loc><!--* <loc href="&url.this;diff-from-20061121.html">Recent revisions</loc> *--></altlocs><latestloc>
    <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/xpath-semantics-30/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xpath-semantics-30/</loc>
  </latestloc><prevlocs>
    <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2007/REC-xquery-semantics-20070123/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2007/REC-xquery-semantics-20070123/</loc>
  </prevlocs><authlist><author><name>Michael Dyck (XML Query WG)</name><affiliation>(self)</affiliation><email xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:jmdyck@ibiblio.org" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">jmdyck@ibiblio.org</email></author></authlist><!--   <errataloc 
href="http://www.w3.org/XML/2009/qt-errata/xquery-semantics-errata.html" 
xlink:type="simple"/> --><translationloc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2003/03/Translations/byTechnology?technology=xpath-semantics" xlink:type="simple"/><!--* Common status section for QT specs.
    * Use is currently not required, but it simplifies things.
    * 
    * Revisions:
    * 2007-01-15 : CMSMcQ : made file, to simplify publication of Rec.
    * 2008-02-15 : JimMelton : cloned from MSM's REC-only material
                     to generalize for all stages
    *--><status id="status"><!-- ************************************************************************** --><!-- * All Status sections must start with the standard boilerplate paragraph * --><!-- *   This entity is defined in status-entities.dtd                        * --><!-- ************************************************************************** --><p><emph>This section describes the status of this
         document at the time of its publication.
         Other documents may supersede this document.
         A list of current W3C publications and the latest
         revision of this technical report can be found in the
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">W3C technical reports index</loc>
         at http://www.w3.org/TR/.</emph></p><!-- ************************************************************************** --><!-- * QT publishes suites of documents, which must be described in the       * --><!--     Status section of each document within such a suite.                 * --><!-- *   This entity is defined in the host document.                         * --><!-- ************************************************************************** --><p>This is one document
in a set of seven documents that are being progressed to
Recommendation together (XQuery 3.0, XQueryX 3.0, XSLT 3.0,
Data Model 3.0, Functions and Operators 3.0,
Serialization 3.0, XPath 3.0). </p><!-- ************************************************************************** --><!-- * There is a lot of detailed customization based on the document stage   * --><!-- *   This entity is defined in the host document.                         * --><!-- ************************************************************************** --><p>This is a <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2005/10/Process-20051014/tr.html#first-wd" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">First Public Working Draft</loc> as described in the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2005/10/Process-20051014/tr.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Process Document</loc>. 
It was developed by the W3C <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/Query/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML Query Working Group</loc>,
which is part of the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/Activity" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML Activity</loc>.
The Working Groups expect to advance this specification to <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2005/10/Process-20051014/tr.html#RecsW3C" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Recommendation</loc> Status.</p><!-- ************************************************************************** --><!-- * CR documents must cite features at risk                                * --><!-- *   This entity is defined in the host document.                         * --><!-- ************************************************************************** --><!-- ************************************************************************** --><!-- * Every Status section must have a customized paragraph                  * --><!-- *   This entity is defined completely in the host document.              * --><!-- ************************************************************************** --><p>This is the first public Working Draft of XQuery and XPath Formal Semantics 3.0 (XDM).
                               It is intended to be fully 'upwards compatible' with
                               <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/xpath-datamodel" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XQuery 1.0
                               and Xpath 2.0 Data Model (XDM)</loc>.  Failures to achieve that goal will be
                               corrected in future versions of the Working Drafts of this document.</p><!-- ************************************************************************** --><!-- * CR docs should, and PR docs must, have a pointer to an implementation  * --><!-- *   report.  We also want to point to the test suite.                    * --><!-- *   This entity is defined in the host document.                         * --><!-- ************************************************************************** --><p>No implementation report currently exists.
However, a Test Suite for [XPath/XQuery] is under development.</p><!-- ************************************************************************** --><!-- * The Status section should point to a changelog                         * --><!-- *   This entity is defined in the host document.                         * --><!-- ************************************************************************** --><p>This document incorporates changes made against the final Recommendation
                        of <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/xquery-semantics" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XQuery 1.0 and XPath 2.0 Formal Semantics</loc>
                        dated 23 January 2007. 
                        Changes to this document since the publication of the Recommendation
                        are detailed in <specref ref="id-fs-revisions-log"/>.</p><!-- ************************************************************************** --><!-- * The Status section must tell readers where to send comments            * --><!-- *   This entity is defined in status-entities.dtd                        * --><!-- ************************************************************************** --><p>Please report errors in this document using W3C's
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Bugs/Public/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public Bugzilla system</loc>
         (instructions can be found at
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/2005/04/qt-bugzilla" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/XML/2005/04/qt-bugzilla</loc>).
         If access to that system is not feasible, you may send your comments
         to the W3C XSLT/XPath/XQuery public comments mailing list,
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:public-qt-comments@w3.org" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public-qt-comments@w3.org</loc>.
         It will be very helpful if you include the string 
         “[FS30]”
         in the subject line of your report, whether made in Bugzilla or in email.
         Please use multiple Bugzilla entries (or, if necessary, multiple email messages)
         if you have more than one comment to make.
         Archives of the comments and responses are available at
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://lists.w3.org/Archives/Public/public-qt-comments/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://lists.w3.org/Archives/Public/public-qt-comments/</loc>. </p><!-- ************************************************************************** --><!-- Status sections must state the stability (not stable, or REC) of the document --><!-- *   This entity is defined in the host document.                         * --><!-- ************************************************************************** --><p>Publication as a Working Draft
does not imply endorsement by the W3C Membership. 
This is a draft document and may be updated, replaced or obsoleted
by other documents at any time. 
It is inappropriate to cite this document as other than work in progress.</p><!-- ************************************************************************** --><!-- * Finally, all Status sections must end with the appropriate IPR para    * --><!-- *   This entity is defined in status-entities.dtd                        * --><!-- ************************************************************************** --><p>This document was produced by groups operating under the
   <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Consortium/Patent-Policy-20040205/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">5 February 2004
   W3C Patent Policy</loc>.
   W3C maintains a <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2004/01/pp-impl/18797/status#disclosures" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public list of any 
   patent disclosures</loc> made in connection with the deliverables of the 
   XML Query Working Group and also maintains a <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2004/01/pp-impl/19552/status#disclosures" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public list of any patent 
   disclosures</loc> made in connection with the deliverables of the XSL 
   Working Group; those pages also include instructions for
   disclosing a patent.
   An individual who has actual knowledge of a patent which the individual believes
   contains
   <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Essential Claim(s)</loc>
   must disclose the information in accordance with
   <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">section 6 of the W3C Patent Policy</loc>. </p></status><abstract><p>This document defines formally the semantics of <phrase role="xquery">XQuery 3.0 <bibref ref="xquery-30"/></phrase> <phrase role="shared">and</phrase> <phrase role="xpath">XPath 3.0
    <bibref ref="xpath-30"/></phrase>.</p></abstract><langusage><language id="EN">English</language><language id="ebnf">EBNF</language></langusage><revisiondesc><p>JS January 2005. Major revision, aligning the Formal Semantics
    with decisions taken up to October 2004.</p><p>JS April 22/2003: Revised version implementing decisions from
    the December 2002 and March 2003 f2f meetings.</p><p>JS November 4/2002: Revised version implementing decisions from
    the September 2002 f2f meeting in North Carolina.</p><p>JS July 26/2002: Revised version which implements most of the
    recent decisions of the XML Query and XSLT working groups. Notably
    implements semantics of element constructors.</p><p>JS June 15/2002: Revised version which fixes many problems
    pointed out by reviewers. Revised version of Sections 4.3 and
    4.13.</p><p>JS May 05/2002: New major revision which integrates named
    typing, mapping from XML Schema and the semantics of XPath
    2.0.</p><p>JS March 22/2002: Most of the document is new. This is the
    basis for the new Formal Semantics of XPath 2.0 and XQuery
    1.0. The current version is up to date and aligned with the
    December 2002 XQuery 1.0 and XPath 2.0 working drafts.</p><p>JS January 2002: Comprehensive editorial rewrite. Update to
    align the formal semantics with the new [XPath/XQuery] language
    document. Update to align the formal semantics with the new
    <bibref ref="xpath-functions-30"/> document. Update to align the formal semantics with
    XML Schema.</p><p>DD August 2001: Comprehensive editorial rewrite.  Introduced
    new section <specref ref="sec_preliminaries"/> with new text and
    amalgamated material that was previously spread over the entire
    document.  Merged previously separate static, dynamic, and core
    rewrite sections into a single section.  Switched to the type
    system and syntax as defined Jérôme's presentation
    from the last face-to-face. Text is marked according to various
    properties:</p><slist><sitem role="newtext">Substantially new text.</sitem><sitem role="iffy">Text that seems likely to be somewhat controversial.</sitem><sitem role="missing">Areas where there is known to be missing text.</sitem><sitem role="notdone">Old text, dropped into position, but not yet incorporated.</sitem></slist><p>MF June 06/2001: Added FS-Issue-0099</p><p>PF, MF May 31/2001: Added FS-Issue-0094, FS-Issue-0095, FS
     Issue-0096, FS-Issue-0097, FS-Issue-0098.
    </p><p>PF, MF May 28/2001: Large number of syntax errors and editorial
    fixes.</p><p>JS, May 11/2001: Large number of syntax errors and editorial
    fixes. Added FS-Issue-0092.</p><p>MF, Apr 30/2001: Resolved FS-Issue-0076.  Added FS-Issue-0089,
    FS-Issue-0090, FS-Issue-0091.</p><p>JS, Apr 21/2001: Populated Section 6: [XPath/XQuery] Mapping to the
    Core</p><p>PF, Apr 18/2001: (Re)introduced example on joins on unordered
    sequences in Section 2, a section on typing descendant-or-self in
    Section 4, and some new optimization rules for unordered().</p><p>MF, Apr 04/2001: Syntax overhaul through Sec 4.8 : changed all
    examples to [XPath/XQuery] syntax.</p><p>PF, Jan 30/2001: Simplified design for dealing with unordered
    collections along the lines presented at the F2F in Nov 2000.</p><p>MF, Jan 15/2000: Addressed many issues raised by Micheal
    Brundage.Added FS-Issue-0081, FS-Issue-0082, FSIssue-0083, FS
    Issue-0084, FS-Issue-0085, FS-Issue-0086 and FS-Issue-0087.
    Resolved FS-Issue-0038, FS-Issue-0062, FS-Issue-0066, and FS
    Issue-0071.
    </p><p>MF, Jan 5/2000: Added introductory paragraph on static and
    dynamic semantics and a section on dynamic/operational semantics.
    WARNING: This material has not been reviewed by Algebra editors
    yet.  Commented out unnecessary references.</p><p>MF, Dec 19/2000: Addendum to FS-Issue-0011.  Added FS
    Issue-0081.</p><p>MF, Dec 11/2000: Added sections on parent and dynamic and
    static casts, and on references and node identity.  Separated
    built-in functions and operators from core syntax and moved into
    own section.  Improved correspondence with data model (See
    accompanying release of data model document.)  Added Jerome's text
    on querying order.  Clarified that semantics of operators will be
    defined by joint task force.  Closed FS-Issue-0003; added FS
    Issue-0079.  Pending approval of group, can also close FS
    Issue-0062, FS-Issue-0071.</p><p>PF, Dec 11/2000: Introduced unordered forests, implying changes
    to Section 2 (example), Section 3 (expressions and amended type
    system), and Section 4 (amended type equivalences and type
    inference rules). Resolved related issues, and raised new issue
    "unordered types".</p><p>MF, Dec 9/2000: Added sections on PIs/comments and mixed
    content.  Added <code>nodes</code> and <code>string</code>
    built-in functions.  Changed <code>bag</code> operator to a
    built-in function.  Substituted ^ for &amp; for consistency.</p><p>PF, Dec 4/2000: Minor editorial corrections for W3C pubrules,
    some clean-up of associated stylesheets</p><p>PF, Nov 20/2000: Added abstract, status section from Paul, and
    Issue-0075 "Overloading user defined functions". Integrated Phil's
    motivation for the type system into the introduction.  Slightly
    edited (anonymized) some issues, and corrected some XML-stuff to
    generate valid HTML.</p><p>MF, Nov 16/2000: Corrected many typos.  Added Issue-0074
    "Operational semantics for expressions".</p><p>MF, Oct 23/2000: Major changes: Added support for attributes,
    namespaces, all-groups. Changed syntax (and semantics) of case,
    for, sort. Introduced new built-in and derived operators
    (children, data). Refined approach for wildcards. Introduced
    concrete syntax for special kinds of types (ContentType,
    ElementGroup, etc.). Adapted type inference rules to these
    changes, and introduced more specific type system for iteration by
    for. For more details see the resolutions around Sep/Oct 2000 in
    Issue list in Appendix B.</p><p>PF, Oct 22/2000: Discarded obsolete issue clustering.  Resolved
    some issues, amended some issue descriptions, and added some
    issues, see Issues List in Appendix B for details.</p><p>PF, MF: Oct 16/2000. WARNING. This document has not been
    thoroughly reviewed by the editorial team, and may thus contain a
    number of editorial inconsistencies.  The editorial team plans to
    correct them by about October 24. During this time the body of the
    document may undergo some changes. Nevertheless, the editorial
    team welcomes comments.</p><p>PF, Oct 15/2000: Major changes: substantial update of the
    issues list. Resolved some, added some, see Issues list in
    Appendix B for details.</p><p>PF, Aug 23/2000. Added Issue-0061 from Group 3 F2F in Redmond,
     added reference to I18N character doc.</p><p>MF, Aug 11/2000: Proofread, typographical and editorial
    corrections</p><p>PF, Aug 09/2000: Added more issues by LA-Team and I18N, added
    links to dtd, xml, and stylesheets.</p><p>PF, Aug 05/2000: Major changes: Added Appendix on Issues, moved
    issues list in Discussion to Appendix on Issues.</p><p>PF, July 21/2000: First version by Fernández,
    Siméon, Wadler. All copy-editing mistakes resulting from
    the transformation to the XML spec.dtd are due to me.</p><p>Fernández, Siméon, Wadler: June/July 2000:
    Original Version</p><p>Fankhauser, July 21 2000. Transformed original version to
    conform to XML spec.dtd</p><p>Fankhauser, August 05 2000. Made various editorial corrections
    (in particular whitespace-magic for mixed content...). Compiled
    list of issues for appendix. Merged Discussion Section with list
    of issues.</p><p>Fernandez, August 11 2000. Made various typographical
    corrections.</p></revisiondesc></header><body><!-- *********************************************************************
      Section 1. Introduction
     ********************************************************************* --><div1 id="introduction"><head>Introduction</head><p>This document defines the formal semantics of XQuery 3.0 and
  XPath 3.0. The present document is part of a set of documents that
  together define the XQuery 3.0 and XPath 3.0 languages:</p><ulist><item><p><bibref ref="xquery-30"/> introduces the XQuery 3.0 language, defines
      its capabilities from a user-centric view, and defines the
      language syntax.</p></item><item><p><bibref ref="xpath-30"/> introduces the XPath 3.0 language, defines its
      capabilities from a user-centric view, and defines the language
      syntax.</p></item><item><p><bibref ref="xpath-functions-30"/> lists the functions and operators defined for
      the [XPath/XQuery] language and specifies the required types of their 
      parameters and return value.  </p></item><item><p><bibref ref="xpath-datamodel-30"/> formally specifies the data model used by
      [XPath/XQuery] to represent the content of XML documents.  The
      [XPath/XQuery] language is formally defined by operations on this
      data model.</p></item><item><p><bibref ref="xslt-xquery-serialization-30"/> specifies how [XPath/XQuery] data
      model values are serialized into XML.</p></item></ulist><p>The scope and goals for the [XPath/XQuery] language are discussed in
  the charter of the W3C [XSL/XML Query] Working Groups and in the [XPath/XQuery]
  requirements <bibref ref="xpath-30-requirements"/>.</p><p>This document defines the semantics of [XPath/XQuery] by giving a
  precise formal meaning to each of the expressions of the [XPath/XQuery]
  specification in terms of the [XPath/XQuery] data model. This document
  assumes that the reader is already familiar with the [XPath/XQuery]
  language. This document defines the formal semantics for XPath 3.0
  only when the XPath 1.0 backward compatibility rules are not in
  effect.</p><p>Two important design aspects of [XPath/XQuery] are that it is
  <emph>functional</emph> and that it is <emph>typed</emph>. These two
  aspects play an important role in the [XPath/XQuery] Formal
  Semantics.</p><p><term>[XPath/XQuery] is a functional language</term>. [XPath/XQuery] is
  built from expressions, rather than statements. Every construct in
  the language (except for the XQuery query prolog) is an expression
  and expressions can be composed arbitrarily. The result of one
  expression can be used as the input to any other expression, as long
  as the type of the result of the former expression is compatible
  with the input type of the latter expression with which it is
  composed. Another characteristic of a functional language is that
  variables are always passed by value, and a variable's value cannot
  be modified through side effects.</p><p><term>[XPath/XQuery] is a typed language</term>. Types can be
  imported from one or more XML Schemas that describe the input
  documents and the output document, and the [XPath/XQuery] language can
  then perform operations based on these types. In addition,
  [XPath/XQuery] supports <emph>static type analysis</emph>.  Static type
  analysis infers the output type of an expression based on the type
  of its input expressions.  In addition to inferring the type of an
  expression for the user, static typing allows early detection of
  type errors, and can be used as the basis for certain classes of
  optimization. The [XPath/XQuery] type system captures most of the
  features of <bibref ref="xmlschema-1"/>, including global and local element and
  attribute declarations, complex and simple type definitions, named
  and anonymous types, derivation by restriction, extension, list and
  union, substitution groups, and wildcard types. It does not model
  uniqueness constraints and facet constraints on simple types.</p><p>This document is organized as follows. <specref ref="sec_preliminaries"/> introduces the notations used to define
  the [XPath/XQuery] Formal Semantics.  These include the formal notations
  for values in the [XPath/XQuery] data model and for types in XML Schema.
  The next three sections: <specref ref="id-basics"/>, <specref ref="id-expressions"/>, and <specref ref="id-query-prolog"/> have
  the same structure as the corresponding sections in the
  <bibref ref="xquery-30"/> and <bibref ref="xpath-30"/> documents.  This allows the reader to
  quickly find the formal definition of a particular language
  construct.  <specref ref="id-basics"/> defines the semantics for
  basic [XPath/XQuery] concepts, and <specref ref="id-expressions"/>
  defines the dynamic and static semantics of each [XPath/XQuery]
  expression.  <specref ref="id-query-prolog"/> defines the semantics
  of the [XPath/XQuery] prolog.

  <specref ref="sec_special_functions"/> defines the static semantics
  of several functions in <bibref ref="xpath-functions-30"/> and gives the dynamic and
  static semantics of several supporting functions used in this
  document.  The remaining sections, <specref ref="sec_auxiliary_judgments"/> and <specref ref="sec_importing_schema"/>, contain material that supports the
  formal semantics of [XPath/XQuery].  <specref ref="sec_auxiliary_judgments"/> defines formal judgments that relate
  data model values to types, that relate types to types, and that
  support the formal definition of validation.  These judgments are
  used in the definition of expressions in <specref ref="id-expressions"/>.

  Lastly, <specref ref="sec_importing_schema"/>, specifies how XML Schema documents are
  imported into the [XPath/XQuery] type system and relates XML Schema
  types to the [XPath/XQuery] type system.</p><div2 id="id-normativity"><head>Normative and Informative
  Sections</head><p>Certain aspects of language processing are described in this
  specification as <term>implementation-defined</term> or
  <term>implementation-dependent</term>.</p><ulist><item><p><termdef id="dt-implementation-defined" term="implementation       defined"><term>Implementation-defined</term> indicates an aspect
      that may differ between implementations, but must be specified
      by the implementor for each particular
      implementation.</termdef></p></item><item><p><termdef id="dt-implementation-dependent" term="implementation       dependent"><term>Implementation-dependent</term> indicates an
      aspect that may differ between implementations, is not specified
      by this or any W3C specification, and is not required to be
      specified by the implementor for any particular
      implementation.</termdef></p></item></ulist><p role="xpath">A language aspect described in this specification as
  <term>implementation-defined</term> or <term>implementation
  dependent</term> may be further constrained by the specifications of
  a host language in which XPath or XQuery is embedded.</p><p>This document contains the normative static semantics of
  [XPath/XQuery]. The static semantics rules in <specref ref="id-basics"/>, <specref ref="id-expressions"/>, <specref ref="id-query-prolog"/>, and <specref ref="sec_special_functions"/>
  are normative. <specref ref="static_context"/> is normative, because
  it defines the static context used in the static typing rules.
  <specref ref="sec_auxiliary_judgments"/> is normative, because it
  contains all the judgments necessary for defining SequenceType
  Matching.</p><p>The dynamic semantics of [XPath/XQuery] are normatively defined in
  <bibref ref="xquery-30"/> and <bibref ref="xpath-30"/>. In this document, the dynamic
  semantic rules in <specref ref="id-basics"/>, <specref ref="id-expressions"/>, and <specref ref="id-query-prolog"/>, the
  examples, and the material labeled as "Note" are provided for
  explanatory purposes and are not normative.</p><p>The mapping rules from XML Schema to the XQuery type system
  provided in <specref ref="sec_importing_schema"/>, and the formal
  semantics of XML Schema validation in <specref ref="sec_validation_judgments"/> are informative and do not handle
  every feature of XML Schema.</p></div2></div1><!-- ===================================================================== --><!--  Section 2. Preliminaries                                             --><!-- ===================================================================== --><div1 id="sec_preliminaries"><head>Preliminaries</head><p>This section provides the background necessary to understand the
  Formal Semantics, introduces the notations that are used, and
  explains its relationship to other documents.</p><div2 id="sec_intro"><head>Introduction to the Formal Semantics</head><p><term>Why a Formal Semantics?</term> The goal of the formal
    semantics is to complement the [XPath/XQuery] specification
    (<bibref ref="xquery-30"/> and <bibref ref="xpath-30"/>), by defining the meaning of
    [XPath/XQuery] expressions with mathematical rigor.</p><p>A rigorous formal semantics clarifies the intended meaning of
    the English specification, ensures that no corner cases are left
    out, and provides a reference for implementation.</p><p><term>Why use formal notations?</term> Rigor is achieved by the
    use of formal notations to represent [XPath/XQuery] objects such as
    expressions, XML values, and XML Schema types, and by the
    systematic definition of the relationships between those objects
    to reflect the meaning of the language.  In particular, the
    dynamic semantics relates [XPath/XQuery] expressions to the XML value
    to which they evaluate, and the static semantics relates
    [XPath/XQuery] expressions to the XML Schema type that is inferred for
    that expression.</p><p>The Formal Semantics uses several kinds of formal notations to
    define the relationships between [XPath/XQuery] expressions, XML
    values, and XML Schema types. This section introduces the
    notations for judgments, inference rules, and mapping rules as
    well as the notation for environments, which implement the dynamic
    and static contexts. The reader already familiar with these
    notations can skip this section and continue with <specref ref="sec_values"/>.</p><!-- ***************** Grammar productions    ****** --><div3 id="sec_grammar_notations"><head>Notations from grammar productions</head><p>Grammar productions are used to describe
      <quote>objects</quote> (values, types, [XPath/XQuery] expressions,
      etc.) manipulated by the Formal Semantics. The Formal Semantics
      makes use of several kinds of grammar productions: productions
      from the [XPath/XQuery] grammar itself, productions for a subset of
      the [XPath/XQuery] language called the XQuery Core which is used
      throughout this document, and other productions used for formal
      specification only such as for the XQuery type system.</p><p>XQuery grammar productions describe the XQuery language and
      expressions. XQuery productions are identified by a number,
      which corresponds to their number in the <bibref ref="xquery-30"/>
      document, and are marked with <quote>(XQuery)</quote>. For
      instance, the following production describes FLWOR expressions
      in XQuery.</p><scrap headstyle="show"><head>[For/FLWOR] Expressions</head><prodrecap ref="FLWORExpr11" orig="xquery" test="Example"/></scrap><p>For the purpose of this document, the differences between the
      XQuery 1.0 and the XPath 2.0 grammars are mostly irrelevant. By
      default, this document uses XQuery 1.0 grammar
      productions. Whenever the grammar for XPath 2.0 differs from the
      one for XQuery 1.0, the corresponding XPath 2.0 productions are
      also given. XPath productions are identified by a number, which
      corresponds to their number in <bibref ref="xpath-30"/>, and are marked with
      <quote>(XPath)</quote>. For instance, the following production
      describes for expressions in XPath.</p><scrap headstyle="show"><head>[For/FLWOR] Expressions</head><prodrecap ref="ForExpr" orig="xpath" test="Example"/></scrap><p>XQuery Core grammar productions describe the XQuery Core. The
      Core grammar is given in <specref ref="sec_core"/>. Core
      productions are identified by a number, which corresponds to
      their number in <specref ref="sec_core"/>, and are marked with
      <quote>(Core)</quote>. For instance, the following production
      describes the simpler form of the <quote>FLWOR</quote>
      expression in the XQuery Core.</p><scrap headstyle="show"><head>Core FLWOR Expressions</head><prodrecap ref="FLWORExpr10" orig="core" test="Example"/></scrap><p>The Formal Semantics manipulates <quote>objects</quote>
      (values, types, expressions, etc.)  for which there is no
      existing grammar production in the <bibref ref="xquery-30"/> document. In
      these cases, specific grammar productions are
      introduced. Notably, additional productions are used to describe
      values in the <bibref ref="xpath-datamodel-30"/>, and to describe the [XPath/XQuery]
      type system. Formal Semantics productions are identified by a
      number, and are marked by <quote>(Formal)</quote>. For instance,
      the following production describes global type definitions in
      the [XPath/XQuery] type system.</p><scrap headstyle="show"><head>Type Definitions</head><prodrecap ref="Definition" id="test-Definition" orig="formal" test="Example"/></scrap><p>Note that grammar productions that are specific to the Formal
      Semantics (i.e., marked with <quote>(Formal)</quote>) are not
      part of [XPath/XQuery]. They are not accessible to the user and are
      only used in the course of defining the languages'
      semantics.</p><p>Grammar non-terminals are used extensively in this document
      to represent objects in judgments (see the next section). As a
      convenience, non-terminals used in judgments link to the
      appropriate grammar production.</p></div3><!-- ***************** Judgments              ****** --><div3 id="sec_judgments"><head>Notations for judgments</head><p>The basic building block of the formal specification is
      called a <emph>judgment</emph>. A judgment expresses whether a
      property holds or not.</p><p>For example:</p><smnotation><p>The judgment</p><display>
          <clause><expression><emph>Object</emph> <term>is a positive
          integer</term></expression></clause>
        </display><p>holds if the object <emph>Object</emph> is a positive
        integer.</p></smnotation><p>A judgment may hold (if it is true) or not hold (if it is
      false). For instance '1 <term>is a positive integer</term>'
      holds and '-1 <term>is a positive integer</term>' does not
      hold.</p><smnotation><p>Here are two other example judgments.</p><p>The judgment</p><display>
          <clause><expression><emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a></expression></clause>
        </display><p>holds if the expression <emph>Expr</emph> yields (or evaluates to)
        the value <a href="#doc-fs-Value"><emph>Value</emph></a>.</p><p>The judgment</p><display>
        <clause><expression><emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause>
        </display><p>holds if the expression <emph>Expr</emph> has the type
        <a href="#doc-fs-Type"><emph>Type</emph></a>.</p><p>Most other judgments used in this document are short
        English sentences intended to reflect their meaning. For
        instance, the judgment</p><display>
        <clause><expression><emph>Axis</emph> <a href="#jd_principal" class="judgment"><term>has principal</term></a> <emph>PrincipalNodeKind</emph></expression></clause>
        </display><p>holds if <emph>PrincipalNodeKind</emph> is the principal node kind
        for the axis <emph>Axis</emph>.</p></smnotation><p>A judgment can contain <emph>symbols</emph> and
      <emph>patterns</emph>.</p><p>Symbols are purely syntactic and are used to write the
      judgment itself. Symbols are chosen to reflect a judgment's
      meaning, and are written in bold fonts. For example, '<term>is a
      positive integer</term>', '<term>=&gt;</term>' and
      '<term>:</term>' are symbols, the second and third of which
      should be read <quote>yields</quote>, and <quote>has
      type</quote> respectively.</p><p>Patterns are used to represent objects, constructed from a
      given grammar production. In patterns, italicized words usually
      correspond to non-terminals in the grammar. The name of those
      non-terminals is significant, and may be instantiated only to an
      <quote>object</quote> (a value, a type, an expression, etc.)
      that can be substituted legally for that non-terminal. For
      example, '<emph>Expr</emph>' is a pattern that stands for every
      [XPath/XQuery] expressions, '<emph>Expr</emph><subscript>1</subscript> + <emph>Expr</emph><subscript>2</subscript>' is a pattern
      that stands for every addition expression, 'element a {
      <a href="#doc-fs-Value"><emph>Value</emph></a> }' is a pattern that stands for every value in the
      [XPath/XQuery] data model that is an 'a' element.</p><p>Non-terminals in a pattern may appear with subscripts
      (e.g. <emph>Expr</emph><subscript>1</subscript>, <emph>Expr</emph><subscript>2</subscript>) to distinguish different instances
      of the same sort of pattern. In some cases, non-terminals in a
      pattern may have a name that is not exactly the name of that non
      terminal, but is based on it. For instance, a <a href="#doc-fs-TypeName"><emph>BaseTypeName</emph></a>
      is a pattern that stands for a type name, as would
      <a href="#doc-fs-TypeName"><emph>TypeName</emph></a>, or <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>2</subscript>. This usage is limited, and
      only occurs to improve the readability of some of the inference
      rules.</p><p>When <emph>instantiating</emph> the judgment, each pattern
      must be instantiated to an appropriate sort of
      <quote>object</quote> (value, type, expression, etc). For
      example, '3 <term>=&gt;</term> 3' and '$x+0 <term>=&gt;</term>
      3' are both instances of the judgment '<emph>Expr</emph>
      <term>=&gt;</term> <a href="#doc-fs-Value"><emph>Value</emph></a>'. Note that in the first
      judgment, '3' corresponds to both the expression '3' (on the
      left-hand side of the <term>=&gt;</term> symbol) and to the
      value '3' (on the right-hand side of the <term>=&gt;</term>
      symbol).</p><p id="jd_not">In some cases, inference rules may need to use
      the fact that a certain judgment <emph>does not</emph> hold.
      <expression><a href="#jd_not" class="judgment"><term>not</term></a>(<emph>Judgment</emph>)</expression> holds
      if and only if <emph>Judgment</emph> does not hold.</p><p id="jd_isin">In some cases, a pattern may be instantiated to
      a value within a finite set of pre-determined values. We may
      write that set of possible values using the <a href="#jd_isin" class="judgment"><term>in</term></a>
      judgment. For instance, the judgment</p><display>
          <clause><expression><emph>Color</emph> <a href="#jd_isin" class="judgment"><term>in</term></a> {
          <term>blue</term>, <term>green</term> }
          </expression></clause>
        </display><p>holds if the pattern <emph>Color</emph> has either the value
      <emph>blue</emph> or the value <emph>green</emph>.</p><p>In some cases, a judgment may use the <quote>=</quote> sign
      to indicate that a given value is equal to another value, or
      that a pattern is equal to a given value. For instance, the
      judgment</p><display>
          <clause><expression><emph>Color</emph> = <term>blue</term>
          </expression></clause>
        </display><p>holds if the pattern <emph>Color</emph> has the value
      <emph>blue</emph>.</p><p>An index to all the judgments used in this specification is
      provided in <specref ref="sec_indexes"/>.</p></div3><!-- ***************** Environments              ****** --><div3 id="sec_environments"><head>Notations for environments</head><p id="xq_environment">An environment component is a dictionary
      that maps a symbol (e.g., a function name or a variable name) to
      an <quote>object</quote> (e.g., a function body, a type, a
      value). One can access information in an environment component
      or update it.</p><p>If <quote>envComp</quote> is an environment component, then
      <quote>envComp(<emph>symbol</emph>)</quote> denotes the
      <quote>object</quote> to which <emph>symbol</emph> is mapped.
      The notation is intentionally similar to function application,
      because an environment component can be considered a function
      from the argument <emph>symbol</emph> to the
      <quote>object</quote> to which the <emph>symbol</emph> is
      mapped.</p><p>This document uses <emph>environments</emph> that group
      related environment components. If <quote>env</quote> is an
      environment containing the environment component
      <quote>envComp</quote>, that environment component is denoted
      <quote>env.envComp</quote>. The value that <emph>symbol</emph>
      is mapped to in that environment component is denoted
      <quote><expression>env.envComp(<emph>symbol</emph>)</expression></quote>.</p><p>The two main environments used in the Formal Semantics are: a
      dynamic environment (<a href="#xq_dyn_env_def" class="env">dynEnv</a>), which models the [XPath/XQuery]
      dynamic context, and a static environment (<a href="#xq_stat_env_def" class="env">statEnv</a>), which
      models the [XPath/XQuery] static context. Both are defined in
      <specref ref="sec_context"/>.</p><p>For example, <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a> denotes the dynamic environment
      component that maps variables to values and
      <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a>(<emph>Variable</emph>) denotes the value of the variable
      <emph>Variable</emph> in the dynamic context.</p><p>Environments are used in a judgment to capture some of the
      context in which the judgment is computed, and most judgments
      are computed assuming that some environment is given. This
      <emph>assumption</emph> is denoted by prefixing the judgment
      with <quote><expression>env</expression> |-</quote>. The
      <quote>|-</quote> symbol is called a
      <quote>turnstile</quote> and is used in almost all inference
      rules.</p><p>For instance, the judgment</p><display>
        <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
      	    <emph>Expr</emph> <term>=&gt;</term> <a href="#doc-fs-Value"><emph>Value</emph></a>
          </expression></clause>
      </display><p>is read as: Assuming the dynamic environment <a href="#xq_dyn_env_def" class="env">dynEnv</a>,
      the expression <emph>Expr</emph> yields the value <a href="#doc-fs-Value"><emph>Value</emph></a>.</p><p>Environments can be <emph>updated</emph>, using the following
      notation:</p><ulist><item><p>
            <quote><expression><update><environment>env.envComp</environment><expression><emph>symbol</emph> =&gt;
            <emph>object</emph></expression></update></expression></quote>
            denotes the new environment that is identical to
            <emph>env</emph> except that the environment component
            <emph>envComp</emph> has been updated to map
            <emph>symbol</emph> to <emph>object</emph>. The notation
            <expression><emph>symbol</emph> =&gt;
            <emph>object</emph></expression> indicates that
            <emph>symbol</emph> is mapped to <emph>object</emph> in
            the new environment.</p></item><item><p>In case the environment component contains only a
            constant value (e.g., the ordering mode which can only be
            either ordered or unordered), the following notation is
            used to set its value.
            <quote><expression><update><environment>env.envComp</environment><expression>
                    <emph>object</emph>
                  </expression></update></expression></quote>.</p></item><item><p>
            The following shorthand is also allowed:
            <quote><expression><update><environment>env.envComp</environment><expression>
                    <emph>symbol</emph><subscript>1</subscript>
                    =&gt;
                    <emph>object</emph><subscript>1</subscript>
                    ; ... ;
                    <emph>symbol</emph><subscript>n</subscript>
                    =&gt;
                    <emph>object</emph><subscript>n</subscript>
                  </expression></update></expression></quote> in which each symbol is
                mapped to a corresponding object in the new
                environment.</p><p>This notation is equivalent to nested updates, as in
            <quote>
              <expression>
                (env + envComp(
                <emph>symbol</emph><subscript>1</subscript>
                =&gt;
                <emph>object</emph><subscript>1</subscript>)
                + 
                ...
                ) + env(<emph>symbol</emph><subscript>n</subscript>
                =&gt;
                <emph>object</emph><subscript>n</subscript>)</expression></quote>.
          </p></item></ulist><p>Updating an environment creates a copy of the original
      environment and overrides any previous binding that might exist
      for the same name and the same component in that
      environment. Updating the environment is used to capture the
      <emph>scope</emph> of a symbol (e.g., for variables, namespace
      prefixes, etc). For instance, in the following expression</p><eg xml:space="preserve">
  let $x := 1 return
  let $x := $x + 2 return
  $x - 3
</eg><p>each let expression changes the dynamic context by binding a
      new variable to a new value. Each different context is
      represented by a different environment. The original
      environment, in which the expression <code>1</code> is
      evaluated, does not contain any binding for variable
      <code>$x</code>. This environment is updated a first time with a
      binding of variable <code>$x</code> to the value <code>1</code>,
      and this new environment is used for the evaluation of the
      expression <code>$x + 2</code>. Then this second environment is
      updated with a binding of variable <code>$x</code> to the value
      <code>3</code>, and this environment is used for the evaluation
      of the expression <code>$x - 3</code>.</p><p>Also, note that there are no operations to remove entries
      from environments. This is never necessary as updating an
      environment effectively creates a new extended copy of the
      original environment, leaving the original environment
      accessible wherever it is in scope along with the updated
      copy.</p></div3><!-- ***************** Inference rules ****** --><div3 id="sec_inference"><head>Notations for inference rules</head><p>Inference rules are used to specify how to infer whether a
      given judgment holds or not. Inference rules express the logical
      relation between judgments and describe how complex judgments
      can be concluded from simpler premise judgments. </p><p>A logical inference rule is written as a collection of
      <emph>premise</emph>s and a <emph>conclusion</emph>, written
      respectively above and below a dividing line, as follows:</p><infergr><infer><prejudge><clause><expression>
    	       <emph>premise</emph><subscript>1</subscript>
    	       ...
    	       <emph>premise</emph><subscript>n</subscript>
    	   </expression></clause></prejudge><postjudge><clause><expression>
    	       <emph>conclusion</emph>
    	   </expression></clause></postjudge></infer></infergr><p>All premises and the conclusion are judgments. From a logical
      point of view, an inference rule is a deduction that if the
      premises hold, then the conclusion holds as well. In that sense,
      the previous inference rule has a similar meaning as the
      following logical statement.</p><p>IF <emph>premise</emph><subscript>1</subscript></p><p>AND ...</p><p>AND <emph>premise</emph><subscript>n</subscript></p><p>THEN <emph>conclusion</emph></p><p>Here is a simple example of inference rule, which uses
      specific instances of the example judgment '<emph>Expr</emph>
      <term>=&gt;</term> <a href="#doc-fs-Value"><emph>Value</emph></a>' from above:</p><infergr><infer><prejudge><clause><expression>
    	       $x <term>=&gt;</term> 0
    	   </expression></clause><clause><expression>
    	       3 <term>=&gt;</term> 3
    	   </expression></clause></prejudge><postjudge><clause><expression>
    	       $x + 3 <term>=&gt;</term> 3
    	    </expression></clause></postjudge></infer></infergr><p>This inference rule expresses the following property:
      <emph>if</emph> the variable expression '$x' yields the value
      '0', <emph>and</emph> the literal expression '3' yields the
      value '3', <emph>then</emph> the expression '$x + 3' yields the
      value '3'.</p><p>An inference rule may have no premises above the line, which
      means that the expression below the line always holds. For
      instance:</p><infergr><infer><postjudge><clause><expression>
    	       3 <term>=&gt;</term> 3 
    	    </expression></clause></postjudge></infer></infergr><p>This inference rule expresses the following property:
      evaluating the literal expression '3' always yields the value
      '3'.</p><p>The two above rules are expressed in terms of specific
      expressions and values, but usually rules are more abstract.
      That is, the judgments are not fully instantiated. Here is a
      rule that says that for any variable $<emph>VarName</emph> that yields
      the integer value <emph>Integer</emph>, adding '0' yields the same
      integer value:</p><infergr><infer><prejudge><clause><expression>
                $<emph>VarName</emph> <term>=&gt;</term> <emph>Integer</emph>
             </expression></clause></prejudge><postjudge><clause><expression>
              $<emph>VarName</emph> + 0 <term>=&gt;</term> <emph>Integer</emph>
            </expression></clause></postjudge></infer></infergr><p>Each occurrence of a given pattern in a particular inference
      rule must be instantiated to the same <quote>object</quote>
      within the entire rule.  This means that, in the context of a
      particular instantiation of a rule, one can talk about
      <quote>the value of $<emph>VarName</emph></quote> instead of <quote diff="chg" at="E037">the value
      bound to the first (second, etc) occurrence of
      $<emph>VarName</emph></quote>.</p><p>Here is an example of a rule occurring later in this
      document.</p><infergr><infer><prejudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>Expr</emph><subscript>1</subscript> <term>:</term> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression></clause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>Expr</emph><subscript>2</subscript> <term>:</term> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>Expr</emph><subscript>1</subscript> , <emph>Expr</emph><subscript>2</subscript> <term>:</term> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression></clause></postjudge></infer></infergr><p>This rule is read as follows: if two expressions <emph>Expr</emph><subscript>1</subscript>
      and <emph>Expr</emph><subscript>2</subscript> are known to have the static types <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> and
      <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> (the two premises above the line), then it is the
      case that the sequence expression <quote><emph>Expr</emph><subscript>1</subscript> ,
      <emph>Expr</emph><subscript>2</subscript></quote> has the static type <quote><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,
      <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></quote>, which is the sequence of types <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
      and <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>. Note that this inference rule does not modify
      the static environment.</p><p>The following rule defines the static semantics of a
      <quote>let</quote> expression. The binding of the new variable
      is captured by an update to the varType component of the
      original static environment.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
    		  <emph>VarName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
    	   </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
    		  <emph>Expr</emph><subscript>1</subscript> <term>:</term> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
    	   </expression></clause><clause><environment>
    		  <update><environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a></environment><expression><a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> =&gt; <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression></update>
    		</environment><expression>
    		    <emph>Expr</emph><subscript>2</subscript> <term>:</term> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
    	  </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
    		  <code>let</code>
    		  <code>$</code><emph>VarName</emph> := <emph>Expr</emph><subscript>1</subscript>
    		  <code>return</code>
    		  <emph>Expr</emph><subscript>2</subscript> <term>:</term> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
    	  </expression></clause></postjudge></infer></infergr><p>This rule is read as follows: First, because the variable is
      a QName, it is first expanded into an expanded QName.  Second,
      the type <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> for the <quote>let</quote> input expression
      <emph>Expr</emph><subscript>1</subscript> is computed.  Then the <quote>let</quote> variable
      with expanded name, <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> with type <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> is added
      into the varType component of the static environment
      <a href="#xq_stat_env_def" class="env">statEnv</a>. Finally, the type <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> of <emph>Expr</emph><subscript>2</subscript> is
      computed in that new environment.</p><p>In some cases, ellipses may be used in inference rules to
      handle an arbitrary number of judgments. In those cases, some of
      the patterns may have indices as subscript. If the same index is
      used several times within the same rule, the number of judgment
      in each case must be the same. For instance, the following rule
      holds for any number of expressions, from <emph>Expr</emph><subscript>1</subscript> to
      <emph>Expr</emph><subscript>n</subscript>, with the same number of types <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> to
      <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>QName</emph>
                  <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                    <emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
                  </expression></clause></multiclause><multiclause><clause><expression>
                    ...
                  </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                    <emph>Expr</emph><subscript>n</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>
                  </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
                    <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,...,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
                  </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
                    <emph>QName</emph> (<emph>Expr</emph><subscript>1</subscript>,...,<emph>Expr</emph><subscript>n</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
                  </expression></clause></multiclause></postjudge></infer></infergr><p>This inference rule is equivalent to having an unbounded
        number of rules, the first of which has 1 judgment, the second
        of which has 2 judgments, etc. For instance, the above rule
        holds if and only if one of the following rules hold.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>QName</emph>
                  <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                    <emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
                  </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
                    <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
                  </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
                    <emph>QName</emph> (<emph>Expr</emph><subscript>1</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
                  </expression></clause></multiclause></postjudge></infer></infergr><p>or</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>QName</emph>
                  <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                    <emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
                  </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                    <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
                  </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
                    <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
                  </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
                    <emph>QName</emph> (<emph>Expr</emph><subscript>1</subscript>,<emph>Expr</emph><subscript>2</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
                  </expression></clause></multiclause></postjudge></infer></infergr><p>etc.</p><p>When ellipses are used, the value for the index always
        ranges from 1 to an arbitrary number n.</p></div3><div3 id="sec_together"><head>Putting it together</head><p>In isolation, each inference rule describes a fragment of the
      semantics for a given judgment. Put together, inference rules
      describe possible inferences that can be used to decide whether
      a particular judgment holds.</p><p>For a given judgment, if that judgment can be inferred to be
      true by applying any sequence of inferences based on premises
      which are known to be true, the inference succeeds. In most
      cases, the inference will proceed by proving intermediate
      judgments, following the consequences from one judgment to the
      next by applying successive inference rules.</p><p>Such inference is a mechanism which can be used to describe
      both static type analysis and dynamic evaluation. More
      specifically, performing static typing consists in proving that
      the following judgment holds for a given expression
      <emph>Expr</emph>.</p><display>
      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause>
      </display><p>If the judgment holds for a given type <a href="#doc-fs-Type"><emph>Type</emph></a>, this type
      is a possible static type for the expression. If there exists no
      type for which this judgment holds, then static typing
      fails and a static type error is returned to the user.</p><p>Consider the following expression.</p><eg xml:space="preserve">
  fn:count((1,2,3))
</eg><p>Using the static typing rules given for expressions in the
      rest of this document, one can deduce that the expression is of
      type <code>xs:integer</code> through the following inference.</p><eg xml:space="preserve">
  statEnv |- 1 : xs:integer  (from typing of literals)
  statEnv |- 2 : xs:integer  (from typing of literals)
  --------------------------------------------------- (sequence)
    statEnv |- 1,2 : xs:integer, xs:integer
    statEnv |- 3 : xs:integer
    ----------------------------------------------------- (sequence)
    statEnv |- 1,2,3 : xs:integer, xs:integer, xs:integer

    declare function fn:count($x as item()*) as xs:integer
    statEnv |- xs:integer,xs:integer,xs:integer &lt;: item()*
    ---------------------------------------------------------- (function call)
    statEnv |- fn:count((1,2,3)) : xs:integer
</eg><p>Conversly, consider the following expression.</p><eg xml:space="preserve">
  fn:nilled((1,2,3))
</eg><p>Using the static typing rules given for expressions in the rest
   of this document, one can apply inference rules up to the
   following point.</p><eg xml:space="preserve">
    ....
    ----------------------------------------------------- (sequence)
    statEnv |- 1,2,3 : xs:integer, xs:integer, xs:integer
</eg><p>However, there is no rule that can infer the type of
      <code>fn:nilled((1,2,3))</code>, because the static typing rules
      for function calls will only hold if the type of the function
      parameters is a subtype of the expected type. However, here
      <code>(xs:integer,xs:integer,xs:integer)</code> is not a node
      type, which is the expected type for the function
      <code>fn:nilled</code>.</p><p>Note that in some cases, the inference can only proceed
      through the appropriate changes to the environment. For
      instance, consider the following expression.</p><eg xml:space="preserve">
  let $x := 1 return ($x,$x)
</eg><p>Using the static typing rules given for expressions in the
      rest of this document, one can deduce that the expression is of
      type <code>(xs:integer,xs:integer)</code> through the following
      inference.</p><eg xml:space="preserve">
statEnv0.varType = ()

  -------------------------- (literal)
  statEnv0 |- 1 : xs:integer

statEnv1 = statEnv0 + varType($x =&gt; xs:integer)

     statEnv1.varType($x) = xs:integer
     --------------------------------- (variable reference)
     statEnv1 |- $x : xs:integer

     statEnv1.varType($x) = xs:integer
     --------------------------------- (variable reference)
     statEnv1 |- $x : xs:integer

     ------------------------------------------- (sequence)
     statEnv1 |- ($x,$x) : xs:integer,xs:integer

  -------------------------------------------------------------- (let)
  statEnv0 |- let $x := 1 return ($x,$x) : xs:integer,xs:integer
</eg><p>This example illustrates how each rule is applied to
      individual sub-expressions, and how the environment is used to
      maintain the relevant context information.</p></div3></div2><div2 id="sec_namespaces"><head>URIs, Namespaces, and Prefixes</head><p>The Formal Semantics does not formally specify the adjustment
    of relative URIs according to a base URI. All URIs used in this
    document are assumed to be absolute URIs.</p><p>The Formal Semantics uses the following namespace prefixes.</p><ulist><item><p><code>fn:</code> for functions and operators from the
      <bibref ref="xpath-functions-30"/> document.</p></item><item><p><code>xs:</code> for XML Schema components and
      built-in types.</p></item></ulist><p>These prefixes are assumed to be bound to the appropriate
    URIs.</p><p>In addition, the Formal Semantics uses the following special
    prefixes for specification purposes.</p><ulist><item><p><emph>dm:</emph> for accessors of the
      <bibref ref="xpath-datamodel-30"/>.</p></item><item><p><emph>op:</emph> for operators in
      <bibref ref="xpath-functions-30"/>.</p></item><item><p><emph>fs:</emph> for functions and types defined in
      the formal semantics.</p></item></ulist><p>These prefixes are always italicized to emphasize that the
    corresponding functions, variables, and types are abstract: they
    are not and cannot be made accessible in [XPath/XQuery]. None of these
    special prefixes are given an explicit URI, but they behave as if
    they had one for the purposes of namespace resolution.</p></div2><div2 id="sec_values"><head>XML Values</head><p>The [XPath/XQuery] language is defined over values of the
    [XPath/XQuery] data model. The [XPath/XQuery] data model is defined
    normatively in <bibref ref="xpath-datamodel-30"/>. We define the formal notation that
    is used in this document to describe and manipulate values in
    inference rules. Formal values are used for specification purposes
    only and are not exposed to the [XPath/XQuery] user.</p><p>This section gives the grammar for formal values, along with a
    summary of the corresponding data model properties. In the context
    of this document, all constraints on values that are specified in
    <bibref ref="xpath-datamodel-30"/> are assumed to hold.</p><div3 id="sec_data_model_overview"><head>Formal values</head><p>A value is a sequence of zero or more items.  An item is
      either an atomic value or a node.</p><p>An atomic value is a value in the value space of an atomic
      type, labeled with the name of that atomic type. An atomic type
      is either a primitive or derived atomic type according to XML
      Schema <bibref ref="xmlschema-2"/>, <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>, or
      <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>.</p><p>A node is either an element, an attribute, a document, a
      text, a comment, or a processing-instruction node.</p><p>Element nodes have a <xtermref spec="XQ" ref="dt-type-annotation"/> and contain a complex value or a
      simple value. Attribute nodes have a <xtermref spec="XQ" ref="dt-type-annotation"/> and contain a simple value. Text
      nodes always contain one string value of type
      <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>, therefore the corresponding type annotation
      is omitted in the formal notation of a text node. Document nodes
      do not have a type annotation and contain a sequence of element,
      text, comment, or processing-instruction nodes.</p><p>A simple value is a sequence of atomic values.</p><p>A complex value is a sequence of attribute nodes followed by
      a sequence of element, text, comment, or processing-instruction
      nodes.</p><p>A <xtermref spec="XQ" ref="dt-type-annotation"/> can be
      either the <emph>QName</emph> of a declared type or an anonymous
      type. An anonymous type corresponds to an XML Schema type for
      which the schema writer did not provide a name. Anonymous type
      names are not visible to the user, but are generated during
      schema validation and used to annotate nodes in the data
      model. By convention, anonymous type names are written using the
      <emph>fs:</emph> Formal Semantics prefix: <emph>fs:</emph>anon<subscript>0</subscript>,
      <emph>fs:</emph>anon<subscript>1</subscript>, etc.</p><p>Formal values are defined by the following grammar.</p><scrap headstyle="show"><head>Values</head><prodrecap ref="Value" id="Value" orig="formal"/><prodrecap ref="Item" id="Item" orig="formal"/><prodrecap ref="AtomicValue" id="AtomicValue" orig="formal"/><prodrecap ref="AtomicValueContent" id="AtomicValueContent" orig="formal"/><prodrecap ref="TypeAnnotation" id="TypeAnnotation" orig="formal"/><prodrecap ref="ElementValue" id="ElementValue" orig="formal"/><prodrecap ref="AttributeValue" id="AttributeValue" orig="formal"/><prodrecap ref="SimpleValue" id="SimpleValue" orig="formal"/><prodrecap ref="DocumentValue" id="DocumentValue" orig="formal"/><prodrecap ref="CommentValue" id="CommentValue" orig="formal"/><prodrecap ref="ProcessingInstructionValue" id="ProcessingInstructionValue" orig="formal"/><prodrecap ref="TextValue" id="TextValue" orig="formal"/><prodrecap ref="NodeValue" id="NodeValue" orig="formal"/><prodrecap ref="ElementName" id="fs-ElementName" orig="formal"/><prodrecap ref="AttributeName" id="fs-AttributeName" orig="formal"/><prodrecap ref="TypeName" id="formal-TypeName" orig="formal"/><prodrecap ref="NamespaceBindings" id="NamespaceBindings" orig="formal"/><prodrecap ref="NamespaceBinding" id="NamespaceBinding" orig="formal"/></scrap><smnotation><p>In the production for <a href="#doc-fs-AtomicValueContent"><emph>AtomicValueContent</emph></a>, each symbol
        in the right-hand side corresponds to one of the primitive
        datatypes. For example, <emph>String</emph> corresponds to
        <code>xs:string</code>, and <emph>Boolean</emph> corresponds to
        <code>xs:boolean</code>. (The mapping is obvious, except that
        <phrase diff="del" at="E038">"expanded-QName"</phrase>
        <phrase diff="add" at="E038"><a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></phrase>
        corresponds to <code>xs:QName</code><phrase diff="add" at="E038">.</phrase>) Although there are
        no explicit productions for these symbols, we assume that each
        is a non-terminal that derives a set of syntactic objects,
        each of which corresponds to a value in the value space of the
        corresponding datatype. For instance, the non-terminal
        <emph>String</emph> derives a set of syntactic objects, which appear
        in examples as <code>""</code>, <code>"a"</code>,
        <code>"John"</code>, etc.; each one corresponds to a string
        value in the <code>xs:string</code> value space. For familiarity, these
        objects have been given the same appearance as
        <emph>StringLiteral</emph>s from the XQuery and Core grammars;
        however, these are formal objects, with a distinct role in the
        <phrase diff="del" at="E038">FS</phrase>
        <phrase diff="add" at="E038">Formal Semantics</phrase>.</p></smnotation><p>Element (resp. attributes) without type annotations, are
      assumed to have the type annotation <code>xs:anyType</code>
      (resp. <code>xs:anySimpleType</code>). Atomic values without type
      annotations, are assumed to have a type annotation which is the
      base type for the corresponding value. For instance,
      <code>"Hello, World!"</code> is equivalent to <code>"Hello,
      World!" of type xs:string</code>.</p><p>Untyped elements (e.g., from well-formed documents) have the
      <xtermref spec="XQ" ref="dt-type-annotation"/> <a href="#dt-xs_untyped"><code>xs:untyped</code></a>,
      untyped attributes have the <xtermref spec="XQ" ref="dt-type-annotation"/> <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>, and untyped
      atomic values have the <xtermref spec="XQ" ref="dt-type-annotation"/> <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>.</p><p>An element has an optional <quote>nilled</quote> marker. This
      marker is present only if the element has been validated against
      an element type in the schema which is <quote>nillable</quote>,
      and the element has no content and an attribute
      <code>xsi:nil</code> set to <code>"true"</code>.</p><p>An element also has a sequence of namespace bindings, which
      are the set of in-scope namespaces for that element. Each
      namespace binding is a prefix, URI pair. Elements without
      namespace bindings are assumed to have an empty set of in-scope
      namespaces.</p><note role="xquery"><p>In <bibref ref="XPath"/>, the in-scope
      namespaces of an element node are represented by a collection of
      <term>namespace nodes</term> arranged on a <term>namespace
      axis</term>, which is optional and deprecated in <bibref ref="xpath-30"/>. XQuery does not support the namespace axis and
      does not represent namespace bindings in the form of
      nodes.</p></note></div3><div3 id="sec_example_values"><head>Examples of values</head><p><term>A well-formed document</term></p><eg xml:space="preserve">
  &lt;fact&gt;The cat weighs &lt;weight units="lbs"&gt;12&lt;/weight&gt; pounds.&lt;/fact&gt;
</eg><p>In the absence of a Schema, this document is represented
      as</p><eg xml:space="preserve">
  element fact of type xs:untyped {
    text { "The cat weighs " },
    element weight of type xs:untyped {
      attribute units of type xs:untypedAtomic {
        "lbs" of type xs:untypedAtomic
      }<phrase diff="add" at="E039">,</phrase>
      text { "12" }
    },
    text { " pounds." }
  }
</eg><p><term>A document before and after validation.</term></p><eg xml:space="preserve">
  &lt;weight xsi:type="xs:integer"&gt;42&lt;/weight&gt;
</eg><p>The formal model for values can represent values before and
      after validation. Before validation, this element is represented
      as:</p><eg xml:space="preserve">
  element weight of type xs:untyped {
    attribute xsi:type of type xs:untypedAtomic {
      "xs:integer" of type xs:untypedAtomic
    },
    text { "42" }
  }
</eg><p>After validation, this element is represented as:</p><eg xml:space="preserve">
  element weight of type xs:integer {
    attribute xsi:type of type xs:QName {
      "xs:integer" of type xs:QName
    },
    42 of type xs:integer
  }
</eg><p><term>An element with a list type</term></p><eg xml:space="preserve">
  &lt;sizes&gt;1 2 3&lt;/sizes&gt;
</eg><p>Before validation, this element is represented as:</p><eg xml:space="preserve">
  element sizes of type xs:untyped {
    text { "1 2 3" }
  }
</eg><p>Assume the following Schema.</p><eg xml:space="preserve">
  &lt;xs:element name="sizes" type="sizesType"/&gt;
  &lt;xs:simpleType name="sizesType"&gt;
    &lt;xs:list itemType="sizeType"/&gt;
  &lt;/xs:simpleType&gt;
  &lt;xs:simpleType name="sizeType"&gt;
    &lt;xs:restriction base="xs:integer"/&gt;
  &lt;/xs:simpleType&gt;
</eg><p>After validation against this Schema, the element is
      represented as:</p><eg xml:space="preserve">
  element sizes of type sizesType {
    1 of type sizeType,
    2 of type sizeType,
    3 of type sizeType
  }
</eg><p><term>An element with an anonymous type</term></p><eg xml:space="preserve">
  &lt;sizes&gt;1 2 3&lt;/sizes&gt;
</eg><p>Before validation, this element is represented as:</p><eg xml:space="preserve">
  element sizes of type xs:untyped {
    text { "1 2 3" }
  }
</eg><p>Assume the following Schema.</p><eg xml:space="preserve">
  &lt;xs:element name="sizes"&gt;
    &lt;xs:simpleType&gt;
      &lt;xs:list itemType="xs:integer"/&gt;
    &lt;/xs:simpleType&gt;
  &lt;/xs:element&gt;
</eg><p>After validation, this element is represented as:</p><eg xml:space="preserve">
  element sizes of type fs:anon1 {
    1 of type xs:integer,
    2 of type xs:integer,
    3 of type xs:integer
  }
</eg><p>where <emph>fs:</emph>anon<subscript>1</subscript> stands for the internal anonymous name
      generated by the system for the <code>sizes</code> element.</p><p><term>A nillable element with</term> <code>xsi:type</code> <term>set to
      true</term></p><eg xml:space="preserve">
  &lt;sizes xsi:nil="true"/&gt;
</eg><p>Before validation, this element is represented as:</p><eg xml:space="preserve">
  element sizes of type xs:untyped {
    attribute xsi:nil of type xs:untypedAtomic { "true" of type xs:untypedAtomic }
  }
</eg><p>Assume the following Schema.</p><eg xml:space="preserve">
  &lt;xs:element name="sizes" type="sizesType" nillable="true"/&gt;
</eg><p>After validation against this Schema, the element is
      represented as:</p><eg xml:space="preserve">
  element sizes nilled of type sizesType {
    attribute xsi:nil of type xs:boolean { true of type xs:boolean }
  }
</eg><p><term>An element with a union type</term></p><eg xml:space="preserve">
  &lt;sizes&gt;1 two 3 four&lt;/sizes&gt;
</eg><p>Before validation, this element is represented as:</p><eg xml:space="preserve">
  element sizes of type xs:untyped {
    text { "1 two 3 four" }
  }
</eg><p>Assume the following Schema:</p><eg xml:space="preserve">
  &lt;xs:element name="sizes" type="sizesType"/&gt;
  &lt;xs:simpleType name="sizesType"&gt;
    &lt;xs:list itemType="sizeType"/&gt;
  &lt;/xs:simpleType&gt;
  &lt;xs:simpleType name="sizeType"&gt;
    &lt;xs:union memberType="xs:integer xs:string"/&gt;
  &lt;/xs:simpleType&gt;
</eg><p>After validation against this Schema, the element is
      represented as:</p><eg xml:space="preserve">
  element sizes of type sizesType {
    1 of type xs:integer,
    "two" of type xs:string,
    3 of type xs:integer,
    "four" of type xs:string
  }
</eg></div3></div2><div2 id="sec_types"><head>The [XPath/XQuery] Type System</head><p>The [XPath/XQuery] type system is used in the specification of the
    dynamic and of the static semantics of [XPath/XQuery]. This section
    introduces formal notations for describing types.</p><div3 id="sec_schema"><head>XML Schema and the [XPath/XQuery] Type System</head><p>The [XPath/XQuery] type system is based on <bibref ref="xmlschema-1"/> and
      <bibref ref="xmlschema-2"/>.  <bibref ref="xmlschema-1"/> and <bibref ref="xmlschema-2"/> specify
      normatively the type information available in [XPath/XQuery].  We
      define the formal notation that is used in this document to
      describe and manipulate types in inference rules. Formal types
      are used for specification purposes only and are not exposed to
      the [XPath/XQuery] user.</p><p><term>Representation of content models.</term> For the
      purpose of static typing, the [XPath/XQuery] type system only
      describes minOccurs, maxOccurs, and minLength, maxLength on list
      types for the occurrences that correspond to the DTD operators
      <code>+</code>, <code>*</code>, and <code>?</code>. Choices are
      represented using the DTD operator <code>|</code>. <term>All
      groups</term> are represented using the interleaving operator
      (<code>&amp;</code>).</p><p><term>Representation of anonymous types.</term> To clarify
      the semantics, the [XPath/XQuery] type system makes all anonymous
      types explicit.</p><p><term>Representation of XML Schema simple type facets and
      identity constraints.</term> For simplicity, XML Schema simple
      type facets and identity constraints are not formally
      represented in the [XPath/XQuery] type system. However, an
      [XPath/XQuery] implementation supporting XML Schema import and
      validation must take simple type facets and identity constraints
      into account.</p><p>This document
      <phrase diff="del" at="E040">describe</phrase>
      <phrase diff="add" at="E040">describes</phrase>
      types in the [XPath/XQuery] types system,
      as well as the operations and properties over those types which
      are used to define the [XPath/XQuery] static typing feature. The two
      most important properties are whether a data
      <phrase diff="del" at="E040">instances</phrase>
      <phrase diff="add" at="E040">instance</phrase>
      matches a
      type, and whether a type is a subtype of another. Those
      properties are described in <specref ref="sec_type_matching"/>. This document does not describe all
      other possible properties over those types.</p><p>The mapping from XML Schema into the [XPath/XQuery] type system
      is given in <specref ref="sec_importing_schema"/>. The rest of
      this section is organized as follows. <specref ref="sec_item_types"/> describes item types, <specref ref="sec_content_models"/> describes content models, and
      <specref ref="sec_top_level_definitions"/>
      <phrase diff="del" at="E040">describe</phrase>
      <phrase diff="add" at="E040">describes</phrase>
      top-level
      type declarations.</p></div3><div3 id="sec_item_types"><head>Item types</head><p>An item type is either an atomic type, an element type, an
      attribute type, a document node type, a text node type, a
      comment node type, or a processing instruction type.  We
      distinguish between document nodes, attribute nodes, and nodes
      that can occur in element content (elements, comments,
      processing instructions, and text nodes), as we need to refer to
      element content types later in the formal semantics.</p><scrap headstyle="show"><head>Item Types</head><prodrecap ref="FormalItemType" id="FormalItemType" orig="formal"/><prodrecap ref="AtomicTypeName" id="AtomicTypeName" orig="formal"/><prodrecap ref="NodeType" id="NodeType" orig="formal"/><prodrecap ref="ElementContentType" id="ElementContentType" orig="formal"/><prodrecap ref="ElementType" id="ElementType" orig="formal"/><prodrecap ref="ElementNameOrWildcard" id="fs-ElementNameOrWildcard" orig="formal"/><prodrecap ref="AttributeNameOrWildcard" id="AttributeNameOrWildcard" orig="formal"/><prodrecap ref="OptTypeSpecifier" id="OptTypeSpecifier" orig="formal"/><prodrecap ref="TypeSpecifier" id="TypeSpecifier" orig="formal"/><prodrecap ref="AttributeType" id="AttributeType" orig="formal"/><prodrecap ref="OptNillable" id="OptNillable" orig="formal"/><prodrecap ref="Nillable" id="Nillable" orig="formal"/><prodrecap ref="OptTypeReference" id="OptTypeReference" orig="formal"/><prodrecap ref="TypeReference" id="TypeReference" orig="formal"/><prodrecap ref="ProcessingInstructionType" id="ProcessingInstructionType" orig="formal" diff="add" at="E022"/><prodrecap ref="PITargetOrWildcard" id="PITargetOrWildcard" orig="formal" diff="add" at="E022"/><prodrecap ref="DocumentType" id="DocumentType" orig="formal"/></scrap><p>An element or attribute type has a name or wildcard, and an
      optional type reference. A name alone corresponds to a reference
      to a global element or attribute declaration. A name with a type
      reference corresponds to a local element or attribute
      declaration. "element *" or "attribute *" alone refers to the
      wildcard types for any element or any attribute. In addition, an
      element type has an optional nillable flag that indicates
      whether the element can be nilled or not.</p><p>A document type has an optional content type. If no content
      type is given, then the type is treated as being the wildcard
      type for documents, i.e., a sequence of text and element
      nodes. For consistency with element nodes, PIs and comments are
      not indicated in that wildcard type, but may occur in
      instances.</p><smnote><p>Generic node types (e.g., <code>node()</code>) such as used
        in the SequenceType production, are interpreted in the type
        system as a union of the corresponding node types (e.g.,
        element,attribute,text,comment and processing-instruction
        nodes) and therefore do not appear in the grammar. The
        semantics of sequence types is described in <specref ref="id-sequencetype-matching"/>.</p></smnote><smexamples><p>The following is a text node type</p><eg xml:space="preserve">
  text
</eg><p>The following is a type for all elements</p><eg xml:space="preserve">
  element * of type xs:anyType
</eg><p>The following is a type for all elements of type string</p><eg xml:space="preserve">
  element * of type xs:string
</eg><p>The following is a type for a nillable element of type
        string and with name <code>size</code></p><eg xml:space="preserve">
  element size nillable of type xs:string
</eg><p>The following is a reference to a global attribute
        declaration</p><eg xml:space="preserve">
  attribute sizes
</eg><p>The following is a type for elements with anonymous type
        <emph>fs:</emph>anon<subscript>1</subscript>:</p><eg xml:space="preserve">
  element sizes of type fs:anon1
</eg></smexamples></div3><div3 id="sec_content_models"><head>Content models</head><p>Following XML Schema, types in [XPath/XQuery] are composed from
      item types by optional, one or more, zero or more, <term>all
      group</term>, <term>sequence</term>, <term>choice</term>, empty
      sequence (written <code>empty</code>), or empty choice (written
      <code>none</code>).</p><p>The type <code>empty</code> matches the empty sequence. The type
      <code>none</code> matches no values. <code>none</code> is the identity for
      choice, that is <expression>(<a href="#doc-fs-Type"><emph>Type</emph></a> | <code>none</code>) =
      <a href="#doc-fs-Type"><emph>Type</emph></a></expression>. The type <code>none</code> is the static type
      for <specref ref="sec_fnerror"/>.</p><scrap headstyle="show"><head>Types</head><prodrecap ref="Type" id="Type" orig="formal"/></scrap><p>The [XPath/XQuery] type system includes three binary operators on
      types: ",", "|" and "&amp;", corresponding respectively to
      sequence, choice and <term>all groups</term> in Schema. The
      [XPath/XQuery] type system includes three unary operators on types:
      "*", "+", and "?", corresponding respectively to zero or more
      instances of the type, one or more instances of the type, or an
      optional instance of the type.</p><p>The "&amp;" operator builds the <quote>interleaved
      product</quote> of two types. The type <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> &amp;
      <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> matches any sequence that is an interleaving of two
      sequences of items, <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> and <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>, with
      <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> matching <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> and <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> matching
      <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>. The interleaving of two sequences of items
      <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> and <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> is any sequence <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript> such
      that there is an ordered partition of <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript> into the two
      sub-sequences <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> and <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>. The interleaved
      product captures the semantics of <term>all groups</term> in XML
      Schema, but is more general as it applies to arbitrary
      types. <term>All groups</term> in XML Schema are restricted to
      apply only on global or local element declarations with
      minOccurs 0 or 1, and maxOccurs 1.</p><p>For example, consider the types <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> =
      <code>xs:integer</code>,<code>xs:integer</code>,<code>xs:integer</code> and <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> =
      <code>xs:string</code>,<code>xs:string</code>. <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <code>= (1,2,3)</code>
      matches the type <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> and <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> <code>=
      ("a","b")</code> matches the type <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>. Any of the
      following <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript> are interleavings of <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> and
      <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>, and therefore match the type (<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> &amp;
      <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>):</p><eg xml:space="preserve">
Value0 = (1,2,3,"a","b")
Value0 = (1,2,"a",3,"b")
Value0 = (1,2,"a","b",3)
Value0 = (1,"a",2,3,"b")
Value0 = (1,"a",2,"b",3)
Value0 = (1,"a","b",2,3)
Value0 = ("a",1,2,3,"b")
Value0 = ("a",1,2,"b",3)
Value0 = ("a",1,"b",2,3)
Value0 = ("a","b",1,2,3)
</eg><p><term>Types precedence order</term>. To improve readability
      when writing types, we assume the following precedence order
      between operators on types.</p><table summary="" border="1"><tbody><tr><th rowspan="1" colspan="1">#</th><th rowspan="1" colspan="1">Operator</th></tr><tr><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">| (choice)</td></tr><tr><td rowspan="1" colspan="1">2</td><td rowspan="1" colspan="1">&amp; (interleaving)</td></tr><tr><td rowspan="1" colspan="1">3</td><td rowspan="1" colspan="1">, (sequence)</td></tr><tr><td rowspan="1" colspan="1">4</td><td rowspan="1" colspan="1">*, +, ? (occurrence)</td></tr></tbody></table><p>Parenthesis can be used to enforce precedence. For
      instance</p><eg xml:space="preserve">
  xs:string | xs:integer, xs:float*
</eg><p>is equivalent to</p><eg xml:space="preserve">
  xs:string | (xs:integer, (xs:float*))
</eg><p>and a different precedence can be obtained by writing</p><eg xml:space="preserve">
  ((xs:string | xs:integer), xs:float)*
</eg><smexamples><p><term>A sequence of elements</term></p><p>The "," operator builds the <quote>sequence</quote> of two
        types. For example,</p><eg xml:space="preserve">
  element title of type xs:string, element year of type xs:integer
</eg><p>is a sequence of an element title of type string followed
        by an element year of type integer.</p><p><term>The union of two element types</term></p><p>The "|" operator builds the <quote>union</quote> of two
        types. For example,</p><eg xml:space="preserve">
  element editor of type xs:string | element bib:author
</eg><p>means either an element editor of type string, or a
        reference to the global element <code>bib:author</code>.</p><p><term>An all group of two elements</term></p><p>The "&amp;" operator builds the <quote>interleaved
        product</quote> of two types. For example,</p><eg xml:space="preserve">
  (element a &amp; element b) =
    element a, element b
  | element b, element a
</eg><p>which specifies that the <code>a</code> and <code>b</code>
        elements can occur in any order.</p><p><term>An empty type</term></p><p>The following type matches the empty sequence.</p><eg xml:space="preserve">
  empty
</eg><p><term>A sequence of zero or more elements</term></p><p>The following type matches zero or more elements each of
        which can be a <code>surgeon</code> or a
        <code>plumber</code>.</p><eg xml:space="preserve">
  (element surgeon | element plumber)*
</eg></smexamples><smnotation><p>The grammar for <a href="#doc-fs-Type"><emph>Type</emph></a>
        <phrase diff="del" at="E041">describe</phrase>
        <phrase diff="add" at="E041">described</phrase>
        above is general enough
        to capture
        <phrase diff="add" at="E041">the</phrase>
        type
        <phrase diff="del" at="E041">infered</phrase>
        <phrase diff="add" at="E041">inferred</phrase>
        for
        <phrase diff="add" at="E041">an</phrase>
        arbitrary expression<phrase diff="del" at="E041">, as well as
        to represent the content of an in <bibref ref="xmlschema-1"/></phrase>. In a few
        cases, inference rules rely on the fact that a given type is a
        type validly describing the content of an element. To capture
        those cases, we introduce the following auxiliary grammar
        productions to describe more precisely the attribute
        declarations and the content model for an element.</p><scrap headstyle="show"><head/><prodrecap id="AttributeModel" ref="AttributeModel" orig="formal" diff="chg" at="E041"/><prodrecap id="ElementModel" ref="ElementModel" orig="formal" diff="chg" at="E041"/></scrap></smnotation></div3><div3 id="sec_top_level_definitions"><head>Top level definitions</head><p>Top level definitions correspond to global element
      declarations, global attribute declarations and type definitions
      in XML Schema.</p><scrap headstyle="show"><head>Type Definitions</head><prodrecap ref="Definitions" id="Definitions" orig="formal" diff="chg" at="E042"/><prodrecap ref="Definition" id="Definition" orig="formal"/><prodrecap ref="OptSubstitution" id="OptSubstitution" orig="formal"/><prodrecap ref="Substitution" id="Substitution" orig="formal"/><prodrecap ref="TypeDerivation" id="TypeDerivation" orig="formal"/><prodrecap ref="ComplexTypeDerivation" id="ComplexTypeDerivation" orig="formal" diff="chg" at="E036"/><prodrecap ref="AtomicTypeDerivation" id="AtomicTypeDerivation" orig="formal"/><prodrecap ref="OptDerivation" id="OptDerivation" orig="formal" diff="add" at="E036"/><prodrecap ref="Derivation" id="Derivation" orig="formal"/><prodrecap ref="OptMixed" id="OptMixed" orig="formal"/><prodrecap ref="Mixed" id="Mixed" orig="formal"/></scrap><p>A type definition has a name (possibly anonymous) and a type
       derivation. In the case of a complex type, the derivation
       indicates whether it is derived by extension or restriction, its
       base type, and its content model, with an optional flag
       indicating if it has mixed content.</p><p>Note the type system allows recursive types, following the
       rules defined in <bibref ref="xmlschema-1"/>.</p><smexample><p>For instance, the following complex type</p><eg xml:space="preserve">
 &lt;complexType name="UKAddress"&gt;
   &lt;complexContent&gt;
     &lt;extension base="ipo:Address"&gt;
       &lt;sequence&gt;
         &lt;element name="postcode" type="ipo:UKPostcode"/&gt;
       &lt;/sequence&gt;
       &lt;attribute name="exportCode" type="positiveInteger" fixed="1"/&gt;
     &lt;/extension&gt;
   &lt;/complexContent&gt;
 &lt;/complexType&gt;
</eg><p>is represented as follows</p><eg diff="chg" at="E020" xml:space="preserve">
  define type UKAddress extends ipo:Address {
    attribute exportCode of type positiveInteger,
    element postcode of type ipo:UKPostcode
  };
</eg></smexample><smexample><p>In the case of simple types derived by union or list, the
       derivation is always a restriction from the base type
       <code>xs:anySimpleType</code>, and has a content which is a union of the
       member types, or a repetition of the item type. For instance,
       the two following simple type declarations</p><eg xml:space="preserve">
&lt;xsd:simpleType name="listOfMyIntType"&gt;
  &lt;xsd:list itemType="myInteger"/&gt;
&lt;/xsd:simpleType&gt;

&lt;xsd:simpleType name="zipUnion"&gt;
  &lt;xsd:union memberTypes="USState FrenchRegion"/&gt;
&lt;/xsd:simpleType&gt;
</eg><p>are represented as follows</p><eg xml:space="preserve">
define type listOfMyIntType restricts xs:anySimpleType {
  myInteger*
}<phrase diff="add" at="E042">;</phrase>

define type zipUnion restricts xs:anySimpleType {
  USState | FrenchRegion
}<phrase diff="add" at="E042">;</phrase>
</eg></smexample><smexample><p>In the case of an atomic type, it just indicates its base
       type. For instance, the following type definition</p><eg xml:space="preserve">
&lt;xsd:simpleType name="SKU"&gt;
 &lt;xsd:restriction base="xsd:string"&gt;
  &lt;xsd:pattern value="\d{3}-[A-Z]{2}"/&gt;
 &lt;/xsd:restriction&gt;
&lt;/xsd:simpleType&gt;
</eg><p>is represented as
       <phrase diff="del" at="E043">follow</phrase>
       <phrase diff="add" at="E043">follows</phrase>
       </p><eg xml:space="preserve">
  define type SKU restrict<phrase diff="add" at="E043">s</phrase> xsd:string;
</eg></smexample><smexample><p>When the type derivation is omitted, the type derives by
       restriction from <code>xs:anyType</code>. For instance<phrase diff="add" at="E042">,
       the following two type definitions are equivalent</phrase>:</p><eg xml:space="preserve">
  define type Bib { element book* }<phrase diff="add" at="E042">;</phrase><phrase diff="del" at="E042"> =</phrase>
  define type Bib restricts xs:anyType { element book* }<phrase diff="add" at="E042">;</phrase>
</eg></smexample><smexample><p>Empty content can be indicated with the explicit empty
       sequence, or omitted, as in:</p><eg xml:space="preserve">
  define type Bib { }<phrase diff="add" at="E042">;</phrase><phrase diff="del" at="E042"> =</phrase>
  define type Bib { empty }<phrase diff="add" at="E042">;</phrase>
</eg></smexample><p>Global element and attribute declarations always have a name
       and a reference to a (possibly anonymous) type.  A global
       element declaration also may declare a substitution group for
       the element and whether the element is nillable.</p><smexample diff="chg" at="E020"><p>A type declaration with one element <code>name</code> of type
         <code>xs:string</code> followed by one or more elements <code>street</code> of type
         <code>xs:string</code>.</p><eg diff="chg" at="E020" xml:space="preserve">
  define type Address {
    element name of type xs:string,
    element street of type xs:string+
  }
</eg></smexample><smexample><p>A type declaration with complex content derived by
         extension</p><eg diff="chg" at="E020" xml:space="preserve">
  define type USAddress extends Address {
    element zip of type xs:integer
  }
</eg></smexample><smexample><p>A type declaration with mixed content</p><eg xml:space="preserve">
  define type Section mixed {
    (element h1 of type xs:string |
     element p of type xs:string |
     element div of type Section)*
  }
</eg></smexample><smexample><p>A type declaration with simple content derived by
         restriction</p><eg xml:space="preserve">
  define type SKU restricts xs:string
</eg></smexample><smexample><p>An element declaration</p><eg xml:space="preserve">
  define element address of type Address
</eg></smexample><smexample><p>An element declaration with a substitution
         group</p><eg xml:space="preserve">
  define element usaddress substitutes for address of type USAddress
</eg></smexample><smexample><p>An element declaration which is nillable</p><eg xml:space="preserve">
  define element zip nillable of type xs:integer
</eg></smexample></div3><div3 id="sec_types_example"><head>Example of a complete Schema</head><p>Here is a schema describing purchase orders from
       <bibref ref="xmlschema-0"/>.</p><eg xml:space="preserve">
  &lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
  
   &lt;xsd:annotation&gt;
    &lt;xsd:documentation xml:lang="en"&gt;
     Purchase order schema for Example.com.
     Copyright 2000 Example.com. All rights reserved.
    &lt;/xsd:documentation&gt;
   &lt;/xsd:annotation&gt;
  
   &lt;xsd:element name="purchaseOrder" type="PurchaseOrderType"/&gt;
  
   &lt;xsd:element name="comment" type="xsd:string"/&gt;
  
   &lt;xsd:complexType name="PurchaseOrderType"&gt;
    &lt;xsd:sequence&gt;
     &lt;xsd:element name="shipTo" type="USAddress"/&gt;
     &lt;xsd:element name="billTo" type="USAddress"/&gt;
     &lt;xsd:element ref="comment" minOccurs="0"/&gt;
     &lt;xsd:element name="items"  type="Items"/&gt;
    &lt;/xsd:sequence&gt;
    &lt;xsd:attribute name="orderDate" type="xsd:date"/&gt;
   &lt;/xsd:complexType&gt;
  
   &lt;xsd:complexType name="USAddress"&gt;
    &lt;xsd:sequence&gt;
     &lt;xsd:element name="name"   type="xsd:string"/&gt;
     &lt;xsd:element name="street" type="xsd:string"/&gt;
     &lt;xsd:element name="city"   type="xsd:string"/&gt;
     &lt;xsd:element name="state"  type="xsd:string"/&gt;
     &lt;xsd:element name="zip"    type="xsd:decimal"/&gt;
    &lt;/xsd:sequence&gt;
    &lt;xsd:attribute name="country" type="xsd:NMTOKEN" fixed="US"/&gt;
   &lt;/xsd:complexType&gt;
  
   &lt;xsd:complexType name="Items"&gt;
    &lt;xsd:sequence&gt;
     &lt;xsd:element name="item" minOccurs="0" maxOccurs="unbounded"&gt;
      &lt;xsd:complexType&gt;
  	&lt;xsd:sequence&gt;
  	 &lt;xsd:element name="productName" type="xsd:string"/&gt;
  	 &lt;xsd:element name="quantity"&gt;
  	  &lt;xsd:simpleType&gt;
  	   &lt;xsd:restriction base="xsd:positiveInteger"&gt;
  	    &lt;xsd:maxExclusive value="100"/&gt;
  	   &lt;/xsd:restriction&gt;
  	  &lt;/xsd:simpleType&gt;
  	 &lt;/xsd:element&gt;
  	 &lt;xsd:element name="USPrice"  type="xsd:decimal"/&gt;
  	 &lt;xsd:element ref="comment"   minOccurs="0"/&gt;
  	 &lt;xsd:element name="shipDate" type="xsd:date" minOccurs="0"/&gt;
  	&lt;/xsd:sequence&gt;
  	&lt;xsd:attribute name="partNum" type="SKU" use="required"/&gt;
      &lt;/xsd:complexType&gt;
     &lt;/xsd:element&gt;
    &lt;/xsd:sequence&gt;
   &lt;/xsd:complexType&gt;
  
   &lt;!-- Stock Keeping Unit, a code for identifying products --&gt;
   &lt;xsd:simpleType name="SKU"&gt;
    &lt;xsd:restriction base="xsd:string"&gt;
     &lt;xsd:pattern value="\d{3}-[A-Z]{2}"/&gt;
    &lt;/xsd:restriction&gt;
   &lt;/xsd:simpleType&gt;
  
  &lt;/xsd:schema&gt;
</eg><p>Here is the mapping of the above schema into the [XPath/XQuery] type
system.</p><eg xml:space="preserve">
  declare namespace xsd = "http://www.w3.org/2001/XMLSchema";

  define element purchaseOrder of type PurchaseOrderType;
 
  define element comment of type xsd:string;
  
  define type PurchaseOrderType {
    attribute orderDate of type xsd:date?,
    element shipTo of type USAddress,
    element billTo of type USAddress,
    element comment?,
    element items of type Items
  };

  define type USAddress {
    attribute country of type xsd:NMTOKEN,
    element name of type xsd:string,
    element street of type xsd:string,
    element city of type xsd:string,
    element state of type xsd:string,
    element zip of type xsd:decimal
  };

  define type Items {
    attribute partNum of type SKU,
    element item of type fs:anon1*
  };

  define type fs:anon1 {
    element productName of type xsd:string,
    element quantity of type fs:anon2,
    element USPrice of type xsd:decimal,
    element comment?,
    element shipDate of type xsd:date?
  };

  define type fs:anon2 restricts xsd:positiveInteger;

  define type SKU restrict xsd:string;
</eg><p>Note that the two anonymous types in the <code>item</code>
      element declarations are mapping to types with names <emph>fs:</emph>anon<subscript>1</subscript>
      and <emph>fs:</emph>anon<subscript>2</subscript>.</p><p>The following additional definitions illustrate how more
      advanced XML Schema features (a complex type derived by
      extension, an anonymous simple type derived by restriction, and
      substitution groups) are represented in the [XPath/XQuery] type
      system.</p><eg xml:space="preserve">
  &lt;complexType name="NYCAddress"&gt;
    &lt;complexContent&gt;
     &lt;extension base="USAddress"&gt;
      &lt;sequence&gt;
       &lt;element ref="apt"/&gt;
      &lt;/sequence&gt;
     &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;

  &lt;element name="apt"&gt;
    &lt;xsd:simpleType&gt;
     &lt;xsd:restriction base="xsd:positiveInteger"&gt;
      &lt;xsd:maxExclusive value="10000"/&gt;
     &lt;/xsd:restriction&gt;
    &lt;/xsd:simpleType&gt;
  &lt;/element&gt;

  &lt;element name="usaddress" substitutionGroup="address" type="USAddress"/&gt;
  &lt;element name="nycaddress" substitutionGroup="usaddress" type="NYCAddress"/&gt;
</eg><p>The above definitions are mapped into the [XPath/XQuery] type system as
follows:</p><eg xml:space="preserve">
  define type NYCAddress extends USAddress {
    element apt
  }<phrase diff="add" at="E042">;</phrase>

  define element apt of type fs:anon3<phrase diff="add" at="E042">;</phrase>

  define type fs:anon3 restricts xsd:positiveInteger<phrase diff="add" at="E042">;</phrase>

  define element usaddress  substitutes for address of type USAddress<phrase diff="add" at="E042">;</phrase>
  define element nycaddress substitutes for usaddress of type NYCAddress<phrase diff="add" at="E042">;</phrase>
</eg></div3></div2><div2 id="sec_fando"><head>Functions and operators</head><p>The <bibref ref="xpath-functions-30"/> document defines built-in functions
    available in [XPath/XQuery]. A number of these functions are used to
    define the [XPath/XQuery] semantics; those functions are listed in
    <specref ref="sec_used_functions"/>.</p><p>Many functions in the <bibref ref="xpath-functions-30"/> document are
    <emph>generic</emph>: they perform operations on arbitrary
    components of the data model, e.g., any kind of node, or any
    sequence of items. For instance, the <code>fn:unordered</code>
    <phrase diff="add" at="E044">function</phrase>
    returns its input sequence in an implementation-dependent
    order. The signature of the <code>fn:unordered</code> function
    takes arbitrary items as input and output:</p><eg xml:space="preserve">
  fn:unordered($sourceSeq as item()*) as item()*
</eg><p>As defined, this signature provides little useful type
    information. For such functions, better type information can often
    be obtained by having the output type depend on the type of input
    parameters. For instance, if the function
    <code>fn:unordered</code> is applied on a sequence of
    <code>a</code> elements, the result is also a sequence of
    <code>a</code> elements.</p><p>In order to provide better static typing for those functions,
    specific static typing rules are given in <specref ref="sec_special_functions"/>.</p></div2></div1><!-- Keep this comment at the end of the file for Emacs' XML mode to work.
 Local variables:
 mode: xml
 sgml-indent-step:2
 indent-tabs-mode:nil
 sgml-parent-document:("XPathXQuerySemantics.xml" "body" "div1")
 End:
--><!-- *************************** &language; Semantics            **************** --><div1 id="id-basics"><head>Basics</head><p>The organization of this section parallels the organization of
  <xspecref spec="XQ" ref="id-basics"/>.</p><div2 id="sec_context"><head>Expression Context</head><smintro><p>The expression context for a given expression consists of all
      the information that can affect the result of the
      expression. This information is organized into the <emph>static
      context</emph> and the <emph>dynamic context</emph>.  This
      section specifies the environments that represent the context
      information used by [XPath/XQuery] expressions.</p></smintro><div3 id="static_context"><head>Static Context</head><smnotation><p>We introduce the following auxiliary grammar production to
        describe function signatures.</p><scrap diff="chg" at="E009" headstyle="show"><head/><prodrecap id="FunctionSig" ref="FunctionSig" orig="formal"/><prodrecap id="TypeList" ref="TypeList" orig="formal"/></scrap><p diff="add" at="E006">
          In the static (and dynamic) context,
          each function is uniquely identified by
          its expanded QName and its arity (number of parameters).
          We introduce the auxilliary symbol <emph>FunctionKey</emph> to
          encapsulate this combination.
        </p><scrap diff="add" at="E006" headstyle="show"><head/><prodrecap id="FunctionKey" ref="FunctionKey" orig="formal"/></scrap><p diff="add" at="E006">(<emph>Arity</emph> is understood to be a non-negative integer.)</p></smnotation><p id="xq_stat_env"><a href="#xq_stat_env_def" class="env">statEnv</a> denotes the environment
      available during static analysis.  Static analysis may extend
      parts of the static environment. The static environment is also
      available during dynamic evaluation.</p><p>If analysis of an expression relies on some component of the
      static context that has not been assigned a value, a static
      error is raised.</p><p id="xq_stat_env_def">The following environment components are
      part of the static environment:</p><table summary="" role="figure" cellpadding="5"><col width="10%" span="1"/><!-- empty column forces left indentation --><col width="15%" span="1"/><col width="65%" align="justify" span="1"/><col width="10%" span="1"/><!-- empty column forces right indentation --><tbody><tr><td rowspan="1" colspan="1"/><td id="xq_xpath_compat_flag" valign="top" rowspan="1" colspan="1"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_xpath_compat_flag" class="env">xpath1.0_compatibility</a></td><td rowspan="1" colspan="1">
             <table summary=""><tbody><tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_xpath_compat_flag" class="env">xpath1.0_compatibility</a> environment
               component designates the <term>XPath 1.0 compatibility
               flag</term> in the [XPath/XQuery] static context. It
               specifies whether the semantic rules for backward
               compatibility with XPath 1.0 are in effect. This
               document defines the formal semantics for XPath 2.0
               only when the XPath 1.0 backward compatibility rules
               are not in effect.</td></tr></tbody></table>
          </td><td rowspan="1" colspan="1"/></tr><tr><td rowspan="1" colspan="1"/><td id="xq_ns_env" valign="top" rowspan="1" colspan="1"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a></td><td rowspan="1" colspan="1">
            <table summary="" id="term_active"><tbody><tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a> environment component
                designates the <term>statically known
                namespaces</term> in the [XPath/XQuery] static
                context.</td></tr><tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a> environment component maps a
                namespace prefix (<emph>NCName</emph>) onto a <term>namespace
                kind</term> and a namespace URI (<emph>AnyURI</emph>), the null
                namespace (#NULL-NAMESPACE), or (#UNDECLARED). The
                namespace kind is either <term>passive</term> or
                <term>active</term>.  The namespace kind determines
                whether a namespace node is created for an element
                during element construction. The (#UNDECLARED) value
                may be used to indicate that the prefix has been
                undeclared, and may occur only if the implementation
                supports <bibref ref="XMLNAMES11"/>.</td></tr></tbody></table>
          </td><td rowspan="1" colspan="1"/></tr><tr><td rowspan="1" colspan="1"/><td id="xq_default_elem_ns_env" valign="top" rowspan="1" colspan="1"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_elem_ns_env" class="env">default_elem_namespace</a></td><td rowspan="1" colspan="1">
            <table summary=""><tbody><tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_elem_ns_env" class="env">default_elem_namespace</a> environment
                component designates the <term>default element/type
                namespace</term> in the [XPath/XQuery] static
                context.</td></tr><tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_elem_ns_env" class="env">default_elem_namespace</a> environment
                component contains a namespace URI (a <emph>AnyURI</emph>) or the
                null namespace (#NULL-NAMESPACE) and is used for any
                unprefixed QName appearing in a position where an
                element or type name is expected.</td></tr></tbody></table>
          </td><td rowspan="1" colspan="1"/></tr><tr><td rowspan="1" colspan="1"/><td id="xq_default_fn_ns_env" valign="top" rowspan="1" colspan="1"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_fn_ns_env" class="env">default_function_namespace</a></td><td rowspan="1" colspan="1">
            <table summary=""><tbody><tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_fn_ns_env" class="env">default_function_namespace</a> environment
                component designates the <term>default function
                namespace</term> in the [XPath/XQuery] static
                context.</td></tr><tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_fn_ns_env" class="env">default_function_namespace</a> environment
                component contains a namespace URI (a <emph>AnyURI</emph>) or the
                null namespace (#NULL-NAMESPACE) and is used for any
                unprefixed QName appearing as the function name in a
                function call.</td></tr></tbody></table>
          </td><td rowspan="1" colspan="1"/></tr><tr><td rowspan="1" colspan="1"/><td id="xq_type_defn" valign="top" rowspan="1" colspan="1"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a></td><td rowspan="1" colspan="1">
            <table summary=""><tbody><tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a> environment component
                designates the <term>in-scope schema types</term> in
                the [XPath/XQuery] static context.</td></tr><tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a> environment component maps
                expanded type names (expanded <a href="#doc-fs-TypeName"><emph>TypeName</emph></a>s) onto
                their type definition (<a href="#sec_top_level_definitions"><emph>Definition</emph></a>).  A type name
                may be globally declared or anonymous.</td></tr></tbody></table>
          </td><td rowspan="1" colspan="1"/></tr><tr><td rowspan="1" colspan="1"/><td id="xq_elem_decl" valign="top" rowspan="1" colspan="1"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_elem_decl" class="env">elemDecl</a></td><td rowspan="1" colspan="1">
            <table summary=""><tbody><tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_elem_decl" class="env">elemDecl</a> environment component
                designates the <term>in-scope element
                declarations</term> in the [XPath/XQuery] static
                context.</td></tr><tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_elem_decl" class="env">elemDecl</a> environment component maps
                expanded element names (expanded <a href="#doc-fs-ElementName"><emph>ElementName</emph></a>s)
                onto their declaration (<a href="#sec_top_level_definitions"><emph>Definition</emph></a>).</td></tr></tbody></table>
          </td><td rowspan="1" colspan="1"/></tr><tr><td rowspan="1" colspan="1"/><td id="xq_attr_decl" valign="top" rowspan="1" colspan="1"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_attr_decl" class="env">attrDecl</a></td><td rowspan="1" colspan="1">
            <table summary=""><tbody><tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_attr_decl" class="env">attrDecl</a> environment component
                designates the <term>in-scope attribute
                declarations</term> in the [XPath/XQuery] static
                context.</td></tr><tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_attr_decl" class="env">attrDecl</a> environment component maps
                expanded attribute names (expanded
                <a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a>s) onto their declaration
                (<a href="#sec_top_level_definitions"><emph>Definition</emph></a>).</td></tr></tbody></table>
          </td><td rowspan="1" colspan="1"/></tr><tr><td rowspan="1" colspan="1"/><td id="xq_type_env" valign="top" rowspan="1" colspan="1"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a></td><td rowspan="1" colspan="1">
            <table summary=""><tbody><tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a> environment component
                designates the <term>in-scope variables</term> in
                the [XPath/XQuery] static context.</td></tr><tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a> environment component maps
                expanded variable names (expanded <emph>VarName</emph>) to
                their static type (<a href="#doc-fs-Type"><emph>Type</emph></a>).</td></tr><tr><td rowspan="1" colspan="1">The <term>context item static type</term> in
                the [XPath/XQuery] static context is represented by the
                binding of the variable <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>dot</code></a> to its corresponding
                type in <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a>.</td></tr></tbody></table>
          </td><td rowspan="1" colspan="1"/></tr><tr><td rowspan="1" colspan="1"/><td id="xq_functy_env" valign="top" rowspan="1" colspan="1"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_functy_env" class="env">funcType</a></td><td rowspan="1" colspan="1">
            <table summary=""><tbody><tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_functy_env" class="env">funcType</a> environment component
                designates the <term>function signatures</term> in the
                [XPath/XQuery] static context.</td></tr><tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_functy_env" class="env">funcType</a> environment component
                stores the static type signatures of
                functions. Because [XPath/XQuery] allows multiple
                functions with the same name differing in the number
                of parameters, this environment component maps
                <phrase diff="chg" at="E006">a <emph>FunctionKey</emph> (an expanded <emph>QName</emph> and arity)</phrase>
                to a function
                signature <emph>FunctionSig</emph>.</td></tr></tbody></table>
          </td><td rowspan="1" colspan="1"/></tr><tr><td rowspan="1" colspan="1"/><td id="xq_collations_env" valign="top" rowspan="1" colspan="1"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_collations_env" class="env">collations</a></td><td rowspan="1" colspan="1">
            <table summary=""><tbody><tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_collations_env" class="env">collations</a> environment component
                designates the <term>statically known
                collations</term> in the [XPath/XQuery] static
                context.</td></tr><tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_collations_env" class="env">collations</a>
                environment component maps a unique namespace URI (a
                <emph>AnyURI</emph>) to a pair of functions: the first function
                takes a set of strings and returns a sequence
                containing those strings in sorted order; and the
                second function takes two strings, returns true if
                they are considered equal, and false if not.</td></tr></tbody></table>
          </td><td rowspan="1" colspan="1"/></tr><tr><td rowspan="1" colspan="1"/><td id="xq_default_collation_env" valign="top" rowspan="1" colspan="1"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_collation_env" class="env">defaultCollation</a></td><td rowspan="1" colspan="1">
            <table summary=""><tbody><tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_collation_env" class="env">defaultCollation</a> environment
                component designates the <term>default
                collation</term> in the [XPath/XQuery] static
                context.</td></tr><tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_collation_env" class="env">defaultCollation</a> environment
                component is a pair of functions as described in
                <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_collations_env" class="env">collations</a> above.</td></tr></tbody></table>
          </td><td rowspan="1" colspan="1"/></tr><tr><td rowspan="1" colspan="1"/><td id="xq_construction_mode_env" valign="top" rowspan="1" colspan="1"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_construction_mode_env" class="env">constructionMode</a></td><td rowspan="1" colspan="1">
            <table summary=""><tbody><tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_construction_mode_env" class="env">constructionMode</a> environment
                component designates the <term>construction
                mode</term> in the [XPath/XQuery] static
                context.</td></tr><tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_construction_mode_env" class="env">constructionMode</a> environment
                component is one of <term>preserve</term> or
                <term>strip</term>.  </td></tr></tbody></table>
          </td><td rowspan="1" colspan="1"/></tr><tr><td rowspan="1" colspan="1"/><td id="xq_ordering_mode_env" valign="top" rowspan="1" colspan="1"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ordering_mode_env" class="env">orderingMode</a></td><td rowspan="1" colspan="1">
            <table summary=""><tbody><tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ordering_mode_env" class="env">orderingMode</a> environment
                component designates the <term>ordering mode</term> in
                the [XPath/XQuery] static context.</td></tr><tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ordering_mode_env" class="env">orderingMode</a> environment
                component is one of <term>ordered</term> or
                <term>unordered</term>.</td></tr></tbody></table>
          </td><td rowspan="1" colspan="1"/></tr><tr><td rowspan="1" colspan="1"/><td id="xq_default_empty_order" valign="top" rowspan="1" colspan="1"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_empty_order" class="env">defaultEmptySequenceOrder</a></td><td rowspan="1" colspan="1">
            <table summary=""><tbody><tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_empty_order" class="env">defaultEmptySequenceOrder</a> environment
                component designates the <term>default order for empty
                sequences</term> in the [XPath/XQuery] static
                context.</td></tr><tr><td rowspan="1" colspan="1"> The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_empty_order" class="env">defaultEmptySequenceOrder</a> environment
                component controls whether an empty sequence is
                interpreted as the greatest value or as the least
                value during processing of an <code>order by</code>
                clause in a FLWOR expression. Its value may be
                <code>greatest</code> or <code>least</code>.</td></tr></tbody></table>
          </td><td rowspan="1" colspan="1"/></tr><tr><td rowspan="1" colspan="1"/><td id="xq_boundary_space" valign="top" rowspan="1" colspan="1"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_boundary_space" class="env">boundarySpace</a></td><td rowspan="1" colspan="1">
            <table summary=""><tbody><tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_boundary_space" class="env">boundarySpace</a> environment component
                designates the <term>boundary-space policy</term>
                in the [XPath/XQuery] static context.</td></tr><tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_boundary_space" class="env">boundarySpace</a> environment component
                controls the processing of boundary whitespace by
                element constructors. Its value may be
                <code>preserve</code> or <code>strip</code>.</td></tr></tbody></table>
          </td><td rowspan="1" colspan="1"/></tr><tr><td rowspan="1" colspan="1"/><td id="xq_copy_namespaces_mode" valign="top" rowspan="1" colspan="1"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_copy_namespaces_mode" class="env">copyNamespacesMode</a></td><td rowspan="1" colspan="1">
            <table summary=""><tbody><tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_copy_namespaces_mode" class="env">copyNamespacesMode</a> environment
                component designates the <term>copy-namespaces
                mode</term> in the [XPath/XQuery] static
                context.</td></tr><tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_copy_namespaces_mode" class="env">copyNamespacesMode</a> environment
                component controls the namespace bindings that are
                assigned when an existing element node is copied by an
                element constructor. Its value consists of two parts:
                <code>preserve</code> or <code>no-preserve</code>, and
                <code>inherit</code> or
                <code>no-inherit</code>.</td></tr></tbody></table>
          </td><td rowspan="1" colspan="1"/></tr><tr><td rowspan="1" colspan="1"/><td id="xq_base_uri_env" valign="top" rowspan="1" colspan="1"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_base_uri_env" class="env">baseURI</a></td><td rowspan="1" colspan="1">
            <table summary=""><tbody><tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_base_uri_env" class="env">baseURI</a> environment component
                designates the <term>base URI</term> in the [XPath/XQuery]
                static context.</td></tr><tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_base_uri_env" class="env">baseURI</a> environment component
                contains a unique namespace URI (a
                <emph>AnyURI</emph>).</td></tr></tbody></table>
          </td><td rowspan="1" colspan="1"/></tr><tr><td rowspan="1" colspan="1"/><td id="xq_doc_type_env" valign="top" rowspan="1" colspan="1"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_doc_type_env" class="env">docType</a></td><td rowspan="1" colspan="1">
            <table summary=""><tbody><tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_doc_type_env" class="env">docType</a> environment component
                designates the <term>statically known documents</term>
                in the [XPath/XQuery] static context.  It contains the
                static type for the input documents, and is used to
                provide the static type to the <code>fn:doc</code>
                function.</td></tr><tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_doc_type_env" class="env">docType</a> environment component
                contains bindings from input URIs (a <emph>AnyURI</emph>) to
                types (a <a href="#doc-fs-Type"><emph>Type</emph></a>).</td></tr></tbody></table>
          </td><td rowspan="1" colspan="1"/></tr><tr><td rowspan="1" colspan="1"/><td id="xq_collection_type_env" valign="top" rowspan="1" colspan="1"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_collection_type_env" class="env">collectionType</a></td><td rowspan="1" colspan="1">
            <table summary=""><tbody><tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_collection_type_env" class="env">collectionType</a> environment
                component designates the <term>statically known
                collections</term> in the [XPath/XQuery] static context.
                It contains the static type for the input collections,
                and is used to provide the static type to the
                <code>fn:collection</code> function.</td></tr><tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_collection_type_env" class="env">collectionType</a> environment
                component contains bindings from input URIs (a
                <emph>AnyURI</emph>) to types (a <a href="#doc-fs-Type"><emph>Type</emph></a>).</td></tr></tbody></table>
          </td><td rowspan="1" colspan="1"/></tr><tr><td rowspan="1" colspan="1"/><td id="xq_default_collection_type_env" valign="top" rowspan="1" colspan="1"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_collection_type_env" class="env">defaultCollectionType</a></td><td rowspan="1" colspan="1">
            <table summary=""><tbody><tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_collection_type_env" class="env">defaultCollectionType</a>
                environment component designates the <term>statically
                known default collection type</term> in the [XPath/XQuery]
                static context. It contains the static type for the
                default collection, and is used to provide the static
                type to the <code>fn:collection</code> function when called with
                no arguments.</td></tr><tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_collection_type_env" class="env">defaultCollectionType</a>
                environment component contains type (a
                <a href="#doc-fs-Type"><emph>Type</emph></a>).</td></tr></tbody></table>
          </td><td rowspan="1" colspan="1"/></tr></tbody></table><p>Note that the boundary-space behavior is not formally
      specified in this document.</p><p id="xq_default_stat_env">An initial environment is set up
      when [expression/query] processing begins, containing, for example,
      the function signatures of all built-in functions.  The initial
      values for the static context are defined in <xspecref spec="XQ" ref="id-xq-context-components"/> and <xspecref spec="XP" ref="id-xp-context-components"/> and is denoted by
      <a href="#xq_default_stat_env" class="env">statEnvDefault</a> in the Formal Semantics.</p><p>Here is an example that shows how the static environment is
      modified in response to a namespace definition.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>URILiteral</emph> <a href="#jd_has_atomic_value" class="judgment"><term>has atomic value</term></a> <emph>AnyURI</emph>
 	    </expression></clause></multiclause><multiclause><clause><environment>
              <update><environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a></environment><expression><emph>NCName</emph> =&gt; (passive, <emph>AnyURI</emph>)</expression></update>
            </environment><expression><emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><code>declare namespace</code> <emph>NCName</emph> = <emph>URILiteral</emph>; <emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause></postjudge></infer></infergr><p>This rule reads as follows: <quote>the phrase on the bottom
      (a namespace declaration in the query prolog followed by an
      expression) is well-typed (accepted by the static typing rules)
      within an environment <a href="#xq_stat_env_def" class="env">statEnv</a> <emph>if</emph> the
      expression above the line is well-typed in the environment
      obtained from <a href="#xq_stat_env_def" class="env">statEnv</a> by adding the namespace
      declaration</quote>.</p><p id="fs_activeNS">The helper function
      <a href="#fs_activeNS">fs:<code>active_ns</code></a>(<a href="#xq_stat_env_def" class="env">statEnv</a>) returns all the active in-scope
      namespaces in the given static environment.</p><p id="fs_ns_from_items">For each attribute and element node in
      <a href="#doc-fs-Value"><emph>Value</emph></a>, such that the node has name <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> in the
      namespace <emph>AnyURI</emph>, the helper function
      <a href="#fs_ns_from_items">fs:<code>get_static_ns_from_items</code></a>(<a href="#xq_stat_env_def" class="env">statEnv</a>, <a href="#doc-fs-Value"><emph>Value</emph></a>) returns the
      in-scope namespace that corresponds to <emph>AnyURI</emph>.  This is a
      reverse-lookup on <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a> by <emph>AnyURI</emph>.</p><div4 id="id-expanded-qnames"><head>Resolving QNames to Expanded QNames</head><p>A common use of the static environment is to expand a
      <emph>QName</emph> by looking up the URI that corresponds to the QName's
      namespace prefix in the <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a> environment component and by
      constructing an <xtermref spec="DM" ref="dt-expanded-qname"/>,
      which contains the URI and the QName's local part. Element and
      type names may be in the null namespace, that is, there is no
      URI associated with their namespace prefix.  The null namespace
      is denoted by the special value
      <code>#NULL-NAMESPACE</code>.</p><p>The auxiliary judgments below expand an element, type,
      attribute, variable, or function <emph>QName</emph> by looking up the
      namespace prefix in <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a> or, if the QName is unqualified,
      by using the appropriate default namespace. </p><smnotation><p id="jd_elem_qname_expands_to">The judgment</p><display>
          <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>QName</emph> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression></clause>
        </display><p>holds when the element or type QName expands to the 
        given expanded QName.</p><p id="jd_attr_qname_expands_to">The judgment</p><display>
          <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>QName</emph> <a href="#jd_attr_qname_expands_to" class="judgment"><term>of attr expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression></clause>
        </display><p>holds when the attribute QName expands to the 
        given expanded QName.</p><p>We use <emph>Variable</emph> to denote the expanded QNames of
        variables.</p><p id="jd_var_qname_expands_to">The judgment</p><display>
          <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>QName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a> <emph>Variable</emph></expression></clause>
        </display><p>holds when the variable QName expands to the 
        given expanded QName.</p><p id="jd_func_qname_expands_to">The judgment</p><display>
          <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>QName</emph> <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression></clause>
        </display><p>holds when the function QName expands to the 
        given expanded QName.</p></smnotation><smrules><p>Note that none of the inference rules can infer a resolved
      name in the case a given namespace prefix is bound to the
      (#UNDECLARED) value. As a result, namespace resolution will fail
      if the implementation supports <bibref ref="XMLNAMES11"/> and a
      given namespace prefix has been undeclared.</p><p>An element or type QName consisting of a prefix NCName and a
      local part NCName expands to the URI (or the null namespace)
      corresponding to that prefix and the local part.</p><infergr><infer><prejudge><clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a>(<emph>NCName</emph><subscript>1</subscript>) = (<a href="#xq_ns_env"><emph>NamespaceKind</emph></a>,<emph>AnyURI-or-#NULL-NAMESPACE</emph>)</expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>NCName</emph><subscript>1</subscript>:<emph>NCName</emph><subscript>2</subscript> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a>
           (<emph>AnyURI-or-#NULL-NAMESPACE</emph>, <emph>NCName</emph><subscript>2</subscript>)</expression></clause></postjudge></infer></infergr><p>An element or type QName consisting only of a local part
      NCName expands to the default element/type namespace and the
      local part.</p><infergr><infer><prejudge><clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_elem_ns_env" class="env">default_elem_namespace</a> = <emph>AnyURI-or-#NULL-NAMESPACE</emph></expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>NCName</emph> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a>
           (<emph>AnyURI-or-#NULL-NAMESPACE</emph>, <emph>NCName</emph>)</expression></clause></postjudge></infer></infergr><p>An attribute QName consisting of a prefix NCName and a local
      part NCName expands to the URI (or the null namespace)
      corresponding to the prefix and the local part.</p><infergr><infer><prejudge><clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a>(<emph>NCName</emph><subscript>1</subscript>) = (<a href="#xq_ns_env"><emph>NamespaceKind</emph></a>,<emph>AnyURI-or-#NULL-NAMESPACE</emph>)</expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>NCName</emph><subscript>1</subscript>:<emph>NCName</emph><subscript>2</subscript>
           <a href="#jd_attr_qname_expands_to" class="judgment"><term>of attr expands to</term></a> (<emph>AnyURI-or-#NULL-NAMESPACE</emph>, <emph>NCName</emph><subscript>2</subscript>)</expression></clause></postjudge></infer></infergr><p>An attribute QName consisting only of a local part NCName
      expands to the null namespace and the local part.</p><infergr><infer><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>NCName</emph> <a href="#jd_attr_qname_expands_to" class="judgment"><term>of attr expands to</term></a>
           (#NULL-NAMESPACE, <emph>NCName</emph>)</expression></clause></postjudge></infer></infergr><p>A variable QName consisting of a prefix NCName and a local
      part NCName expands to the URI that corresponds to the prefix
      and the local part.</p><infergr><infer><prejudge><clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a>(<emph>NCName</emph><subscript>1</subscript>) = (<a href="#xq_ns_env"><emph>NamespaceKind</emph></a>,<emph>AnyURI</emph>)</expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>NCName</emph><subscript>1</subscript>:<emph>NCName</emph><subscript>2</subscript>
           <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a> (<emph>AnyURI</emph>, <emph>NCName</emph><subscript>2</subscript>)</expression></clause></postjudge></infer></infergr><p>A variable QName consisting only of a local part NCName
      expands to the null namespace and the local part.</p><infergr><infer><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>NCName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
           (#NULL-NAMESPACE, <emph>NCName</emph>)</expression></clause></postjudge></infer></infergr><p>A function QName consisting of a prefix NCName and a local
      part NCName expands to the URI that corresponds to the prefix
      and the local part.</p><infergr><infer><prejudge><clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a>(<emph>NCName</emph><subscript>1</subscript>) = (<a href="#xq_ns_env"><emph>NamespaceKind</emph></a>,<emph>AnyURI</emph>)</expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>NCName</emph><subscript>1</subscript>:<emph>NCName</emph><subscript>2</subscript>
           <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> (<emph>AnyURI</emph>, <emph>NCName</emph><subscript>2</subscript>)</expression></clause></postjudge></infer></infergr><p>A function QName consisting only of a local part NCName
      expands to the default function namespace URI and the local
      part.</p><infergr><infer><prejudge><clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_fn_ns_env" class="env">default_function_namespace</a> = <emph>AnyURI</emph></expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>NCName</emph> <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a>
           (<emph>AnyURI</emph>, <emph>NCName</emph>)</expression></clause></postjudge></infer></infergr></smrules></div4></div3><div3 id="eval_context"><head>Dynamic Context</head><p id="xq_dyn_env_def"><a href="#xq_dyn_env_def" class="env">dynEnv</a> denotes the environment
      available during dynamic evaluation. Dynamic evaluation may
      extend parts of the dynamic environment.</p><p>If evaluation of an expression relies on some component of
      the dynamic context that has not been assigned a value, a
      dynamic error is raised.</p><p>The following environment components are part of the dynamic
      environment:</p><table summary="" role="figure" cellpadding="5"><col width="10%" span="1"/><!-- empty column forces left indentation --><col width="15%" span="1"/><col width="65%" align="justify" span="1"/><col width="10%" span="1"/><!-- empty column forces right indentation --><tbody><tr><td rowspan="1" colspan="1"/><td id="xq_val_env" valign="top" rowspan="1" colspan="1"><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></td><td rowspan="1" colspan="1">
           <table summary=""><tbody><tr><td rowspan="1" colspan="1">The <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a> environment component corresponds to the
            <term>variable values</term>, the <term>context
            item</term>, the <term>context position</term> and the
            <term>context size</term> in the [XPath/XQuery] evaluation
            context.</td></tr><tr><td rowspan="1" colspan="1">The dynamic value environment component maps an
            expanded variable name (expanded <emph>VarName</emph>) to the
            variable's value (<a href="#doc-fs-Value"><emph>Value</emph></a>) or to the value
            <code>#IMPORTED</code>(<emph>AnyURI</emph>), if the variable is
            defined in the imported module with namespace
            <emph>AnyURI</emph>.</td></tr></tbody></table>
          </td><td rowspan="1" colspan="1"/></tr><tr><td rowspan="1" colspan="1"/><td id="xq_func_env" valign="top" rowspan="1" colspan="1"><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_func_env" class="env">funcDefn</a></td><td rowspan="1" colspan="1">
            <table summary=""><tbody><tr><td rowspan="1" colspan="1">The <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_func_env" class="env">funcDefn</a> environment component corresponds to
               the <term>function implementations</term> (or
               definition) part of the [XPath/XQuery] dynamic
               context.</td></tr><tr><td rowspan="1" colspan="1">The <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_func_env" class="env">funcDefn</a> environment component maps
               <phrase diff="chg" at="E006">
               a <emph>FunctionKey</emph> (expanded function name and arity)
               </phrase>
               to the remainder of the
               corresponding function definition. If the function is
               defined in <bibref ref="xpath-functions-30"/>, the function definition is
               the value <code>#BUILT-IN</code>. If the function is
               externally defined, the function definition is the
               value <code>#EXTERNAL</code>. If the function is
               defined in the imported module with namespace <emph>AnyURI</emph>,
               the function definition is the value
               <code>#IMPORTED</code>(<emph>AnyURI</emph>). If the function is
               locally declared, the function definition is of the
               form <quote>(<emph>Expr</emph>, <emph>Variable</emph><subscript>1</subscript>,...,
               <emph>Variable</emph><subscript>n</subscript>)</quote>, where <emph>Expr</emph> is the
               function body and <emph>Variable</emph><subscript>1</subscript>, ..., <emph>Variable</emph><subscript>n</subscript>
               are the function parameters.</td></tr><tr><td rowspan="1" colspan="1"> The initial function environment component
               (<a href="#xq_default_dyn_env" class="env">dynEnvDefault</a>.funcDefn) maps the signatures of
               the internal functions defined in <specref ref="sec_operators"/> and the signatures of the
               functions defined in <bibref ref="xpath-functions-30"/> to
               <code>#BUILT-IN</code>.</td></tr></tbody></table>
          </td><td rowspan="1" colspan="1"/></tr><tr><td rowspan="1" colspan="1"/><td id="xq_date_time_env" valign="top" rowspan="1" colspan="1"><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_date_time_env" class="env">dateTime</a></td><td rowspan="1" colspan="1">
           <table summary=""><tbody><tr><td rowspan="1" colspan="1">The <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_date_time_env" class="env">dateTime</a> environment component corresponds to
            the <term>current dateTime</term> in the [XPath/XQuery]
            dynamic context.</td></tr></tbody></table>
          </td><td rowspan="1" colspan="1"/></tr><tr><td rowspan="1" colspan="1"/><td id="xq_timezone_env" valign="top" rowspan="1" colspan="1"><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_timezone_env" class="env">timezone</a></td><td rowspan="1" colspan="1">
           <table summary=""><tbody><tr><td rowspan="1" colspan="1">The <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_timezone_env" class="env">timezone</a> environment component corresponds to
            the <term>implicit timezone</term> in the [XPath/XQuery]
            dynamic context and is used by the timezone related
            functions in <bibref ref="xpath-functions-30"/>.</td></tr></tbody></table>
          </td><td rowspan="1" colspan="1"/></tr><tr><td rowspan="1" colspan="1"/><td id="xq_doc_value_env" valign="top" rowspan="1" colspan="1"><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_doc_value_env" class="env">docValue</a></td><td rowspan="1" colspan="1">
            <table summary=""><tbody><tr><td rowspan="1" colspan="1">The <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_doc_value_env" class="env">docValue</a> environment component corresponds
                to the <term>available documents</term> in the
                [XPath/XQuery] dynamic context.  It contains the document
                nodes corresponding to input documents, and is used to
                provide the dynamic value of the <code>fn:doc</code>
                function.</td></tr><tr><td rowspan="1" colspan="1">The <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_doc_value_env" class="env">docValue</a> environment component contains
                bindings from input URIs (a <emph>AnyURI</emph>) to documents (a
                <a href="#doc-fs-DocumentValue"><emph>DocumentValue</emph></a>).</td></tr></tbody></table>
          </td><td rowspan="1" colspan="1"/></tr><tr><td rowspan="1" colspan="1"/><td id="xq_collection_value_env" valign="top" rowspan="1" colspan="1"><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_collection_value_env" class="env">collectionValue</a></td><td rowspan="1" colspan="1">
            <table summary=""><tbody><tr><td rowspan="1" colspan="1">The <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_collection_value_env" class="env">collectionValue</a> environment component
                corresponds to the <term>available collections</term>
                in the [XPath/XQuery] dynamic context.  It contains the
                root nodes corresponding to the input collections, and
                is used to provide the dynamic value of the
                <code>fn:collection</code> function.</td></tr><tr><td rowspan="1" colspan="1">The <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_collection_value_env" class="env">collectionValue</a> environment component
                contains bindings from input URIs (a <emph>AnyURI</emph>) to
                a sequence of nodes.</td></tr></tbody></table>
          </td><td rowspan="1" colspan="1"/></tr><tr><td rowspan="1" colspan="1"/><td id="xq_default_collection_value_env" valign="top" rowspan="1" colspan="1"><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_default_collection_value_env" class="env">defaultCollectionValue</a></td><td rowspan="1" colspan="1">
            <table summary=""><tbody><tr><td rowspan="1" colspan="1">The <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_default_collection_value_env" class="env">defaultCollectionValue</a>
                environment component corresponds to the <term>default
                collection</term> in the [XPath/XQuery] dynamic context.
                It contains the sequence of nodes corresponding to the
                default collection, and is used to provide the dynamic
                value of the <code>fn:collection</code> function when called with
                no arguments.</td></tr><tr><td rowspan="1" colspan="1">The <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_default_collection_value_env" class="env">defaultCollectionValue</a>
                environment component contains a sequence of nodes.</td></tr></tbody></table>
          </td><td rowspan="1" colspan="1"/></tr></tbody></table><p id="xq_default_dyn_env">The initial values for the dynamic
      context are defined in <xspecref spec="XQ" ref="id-xq-context-components"/> and <xspecref spec="XP" ref="id-xp-context-components"/>. The corresponding initial
      dynamic environment is denoted by <a href="#xq_default_dyn_env" class="env">dynEnvDefault</a> in the
      Formal Semantics.</p><p id="fs_builtin_vars">The following Formal Semantics variables
      represent the <term>context item</term>, <term>context
      position</term>, and <term>context size</term> properties of the
      dynamic context:</p><table summary="" border="1"><tbody><tr><td rowspan="1" colspan="1">Built-in Variable  </td><td rowspan="1" colspan="1">Represents:</td></tr><tr><td rowspan="1" colspan="1"><a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>dot</code></a></td><td rowspan="1" colspan="1">context item</td></tr><tr><td rowspan="1" colspan="1"><a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>position</code></a></td><td rowspan="1" colspan="1">context position </td></tr><tr><td rowspan="1" colspan="1"><a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>last</code></a></td><td rowspan="1" colspan="1">context size</td></tr></tbody></table><p>Within this document, variables with the "fs" prefix are
      reserved for use in the formal specification. Values of
      <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>position</code></a> and <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>last</code></a> can be obtained by invoking the
      <code>fn:position</code> and <code>fn:last</code> functions, respectively. Note that
      the type for those variables is obtained as for any other
      variables. As expected the type of <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>position</code></a> and <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>last</code></a>
      is always <code>xs:integer</code> while the type of <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>dot</code></a> depends on the
      context in which it is being used.</p></div3></div2><div2 id="id-processing-model"><head>Processing Model</head><p>This section reviews the processing model for [XPath/XQuery]. The
    [XPath/XQuery] processing model is defined normatively in <xspecref spec="XQ" ref="id-processing-model"/>.  This section also explains
    how the main notations (normalization rules, static typing rules,
    and dynamic evaluation rules) relate to the phases in that
    processing model.</p><div3 id="id-fs-processing-model"><head>Processing model</head><p>The following figure depicts the [XPath/XQuery] processing
      model</p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="ProcMod-XQuery.gif" alt="Processing Model Overview" role="xquery" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p>Figure 1: Processing Model Overview</p><p>This processing model is not intended to describe an actual
      implementation, although a naive implementation might be based
      upon it. It does not prescribe an implementation technique, but
      any implementation should produce the same results as obtained
      by following this processing model and applying the rest of the
      Formal Semantics specification.</p><p>Query processing consists of two phases: a static analysis
      phase and a dynamic evaluation phase.  Static analysis is further
      divided into four sub-phases.   Typically, each phase consumes the result of
      the previous phase and generates output for the next phase. When
      processing query prologs, these phases may be mutually dependent
      (See <specref ref="id-query-prolog"/>).
      For       each processing phase, we point to the relevant notations
      introduced later in the document.</p><p><termdef id="dt-static-analysis" term="static analysis       phase">The <term>static analysis phase</term> depends on the
      expression itself and on the static context. The <term>static
      analysis phase</term> does not depend on input data (other than
      schemas).</termdef></p><p>The purpose of the static analysis phase is to detect errors,
      e.g., syntax errors or type errors, at compile time rather than
      at run-time. If no error occurs, the result of static analysis
      could be some compiled form of [expression/query], suitable for
      execution by a compiled-[expression/query] processor. Static analysis
      consists of the following sub-phases:</p><olist><item><p id="processing_parsing"><term>Parsing.</term> (Step SQ1
          in Figure 1). The grammar for the [XPath/XQuery] syntax is
          defined in <bibref ref="xquery-30"/>.  Parsing may generate syntax
          errors.  If no error occurs, an internal operation tree of
          the parsed query is created.</p></item><item><p id="processing_context"><term>Static Context
          Processing.</term> (Steps SQ2, SQ3, and SQ4 in Figure
          1). The static semantics of [expression/query] depends on the
          input static context. The input static context needs to be
          generated before the [expression/query] can be analysed. In
          XQuery, the input static context may be defined by the
          processing environment and by declarations in the Query
          Prolog (See <specref ref="id-query-prolog"/>). In XPath, the
          input static context is defined by the processing
          environment. The static context is denoted by
          <a href="#xq_stat_env_def" class="env">statEnv</a>. </p></item><item><p id="processing_normalization"><term>Normalization.</term>
          (Step SQ5 in Figure 1). To simplify the semantics
          specification, some normalization is performed on the
          [expression/query]. The [XPath/XQuery] language provides many powerful
          features that make [expression/query]s simpler to write and use,
          but are also redundant. For instance, a complex
          <code>for</code> expression might be rewritten as a
          composition of several simple <code>for</code>
          expressions. The language composed of these simpler
          [expression/query] is called the [XPath/XQuery] <emph>Core
          language</emph> and is described by a grammar which is a
          subset of the XQuery grammar. The grammar of the [XPath/XQuery]
          Core language is given in <specref ref="sec_core"/>.</p><p>During the normalization phase, each [XPath/XQuery]
          [expression/query] is mapped into its equivalent [expression/query] in
          the Core. (Note that this has nothing to do with Unicode
          Normalization, which works on character strings.)
          Normalization works by recursive application of the
          normalization rules over a given expression.</p><p>Specifically the normalization phase is defined in terms
          of the static part of the context (<a href="#xq_stat_env_def" class="env">statEnv</a>) and a
          [expression/query] (<emph>Expr</emph>) abstract syntax tree. Formal
          notations for the normalization phase are introduced in
          <specref ref="sec_normalization"/>.</p><p>After normalization, the full semantics is obtained by
          giving a semantics to the normalized Core [expression/query]. This
          is done during the last two phases.</p></item><item><p id="processing_static"><term>Static type analysis.</term>
          (Step SQ6 in Figure 1).  Static type analysis is optional.
          If this phase is not supported, then normalization is
          followed directly by dynamic evaluation.  </p><p>Static
          type analysis checks whether each [expression/query] is
          well-typed, and if so, determines its static type. Static
          type analysis is defined only for Core [expression/query]. Static
          type analysis works by recursive application of the static
          typing rules over a given expression.</p><p>If the [expression/query] is not well-typed, static type
          analysis yields a <emph>type error</emph>. For instance, a
          comparison between an integer value and a string value might
          be detected as an type error during the static type
          analysis. If static type analysis succeeds, it yields an
          abstract syntax tree where each sub-expression is associated
          with its static type.</p><p>More precisely, the static analysis phase is defined in
          terms of the static context (<a href="#xq_stat_env_def" class="env">statEnv</a>) and a Core
          [expression/query] (<emph>CoreExpr</emph>).  Formal notations for
          the static analysis phase are introduced in <specref ref="sec_static"/>.</p><p>Static typing does not imply that the content of XML
          documents must be rigidly fixed or even known in advance.
          The [XPath/XQuery] type system accommodates
          <quote>flexible</quote> types, such as elements that can
          contain any content.  Schema-less documents are handled in
          [XPath/XQuery] by associating a standard type with the document,
          such that it may include any legal XML content.</p></item></olist><p>If the static analysis phase succeeds, the dynamic evaluation
      phase (sometimes also called <quote>execution</quote>) evaluates
      a query on input document(s).</p><olist><item><p id="dyn_processing_context"><term>Dynamic Context
          Processing.</term> (Steps DQ2 and DQ3 in Figure 1).The
          dynamic semantics of [expression/query] depends on the dynamic
          input context. The dynamic input context needs to be
          generated before the [expression/query] can be evaluated. The
          dynamic input context may be defined by the processing
          environment and by statements in the Query Prolog (See
          <specref ref="id-query-prolog"/>). In XPath, the dynamic
          input context is defined by the processing environment. The
          static input context is denoted by <a href="#xq_dyn_env_def" class="env">dynEnv</a>.</p></item><item><p id="processing_dynamic"><term>Dynamic Evaluation.</term>
          (Steps DQ4 and DQ5 in Figure 1). This phase computes the
          value of an [expression/query].  The semantics of evaluation is
          defined only for Core [expression/query] terms. The formal
          description of evaluation works by recursive application of
          the dynamic evaluation rules over a given
          expression. Evaluation may result in a value OR a dynamic
          error, which may be a non-type error or a type error.  If
          static typing of an expression does not raise a type error,
          then dynamic evaluation of the same expression will not
          raise a type error (and thus dynamic type checking can be
          avoided when static typing is enabled). Dynamic evaluation
          may still raise a non-type error.</p><p>The dynamic evaluation phase is defined in terms of the
          static context (<a href="#xq_stat_env_def" class="env">statEnv</a>) and evaluation context
          (<a href="#xq_dyn_env_def" class="env">dynEnv</a>), and a Core [expression/query]
          (<emph>CoreExpr</emph>). Formal notations for the dynamic
          evaluation phase are introduced in <specref ref="sec_evaluation"/>.</p></item></olist><p>Static type analysis catches only certain classes of
      errors. For instance, it can detect a comparison operation
      applied between incompatible types (e.g., <code>xs:int</code>
      and <code>xs:date</code>). Some other classes of errors cannot
      be detected by the static analysis and are only detected at
      evaluation time. For instance, whether an arithmetic expression
      on 32 bit integers (<code>xs:int</code>) yields an out-of-bound
      value can only be detected at run-time by looking at the
      data.</p><p>While implementations are free to implement different
      processing models, the [XPath/XQuery] static semantics relies on the
      existence of a static type analysis phase that precedes any
      access to the input data.</p><p>The above processing phases are all internal to the
      [XPath/XQuery] processor. They do not deal with how the [XPath/XQuery]
      processor interacts with the outside world, notably how it
      accesses actual documents and types. A typical [expression/query]
      engine would support at least three other important processing
      phases:</p><olist><item><p><term>Schema Import Processing.</term> The [XPath/XQuery]
          type system is based on XML Schema. In order to perform
          dynamic or static typing, the [XPath/XQuery] processor needs to
          build type descriptions that correspond to the schema(s) of
          the input documents. This phase is achieved by mapping all
          schemas required by the [expression/query] into the [XPath/XQuery]
          type system. The XML Schema import phase is described in
          <specref ref="sec_importing_schema"/>.</p></item><item><p><term>Data Model Generation.</term> Expressions are
          evaluated on values in the <bibref ref="xpath-datamodel-30"/>. XML documents
          must be loaded into the <bibref ref="xpath-datamodel-30"/> before the evaluation
          phase. This is described in the <bibref ref="xpath-datamodel-30"/> and is not
          discussed further here.</p></item><item><p><term>Serialization.</term> Once the [expression/query] is
          evaluated, processors might want to serialize the result of
          the [expression/query] as actual XML documents. Serialization of
          data model instances is described in
          <bibref ref="xslt-xquery-serialization-30"/> and is not discussed further
          here.</p></item></olist><p>The parsing phase is not specified formally; the formal
      semantics does not define a formal model for the syntax trees,
      but uses the [XPath/XQuery] concrete syntax directly.  More details
      about parsing for XQuery 1.0 can be found in the <bibref ref="xquery-30"/>
      document and more details about parsing for XPath 2.0 can be
      found in the <bibref ref="xpath-30"/> document. No further discussion of
      parsing is included here.</p></div3><div3 id="sec_normalization"><head>Normalization mapping rules</head><p>Normalization is specified using <emph>mapping</emph> rules,
      which describe how a [XPath/XQuery] expression is rewritten into an
      expression in the [XPath/XQuery] Core. Mapping rules are also used
      in <specref ref="sec_importing_schema"/> to specify how XML
      Schemas are imported into the [XPath/XQuery] type system.</p><smnotation><p>Mapping rules are written using a square bracket notation,
          as follows:</p><mapping><xquery><expression> 
              <map><expression>Object</expression></map><subscript>Subscript</subscript>,
              <emph>premises</emph>
            </expression></xquery><core><expression>
              <emph>Mapped Object</emph>
            </expression></core></mapping><p>The original <quote>object</quote>, and an optional list of
        premises, is written above the <term>=</term> sign. The
        rewritten <quote>object</quote> is written beneath the
        <term>=</term> sign. The subscript is used to indicate what
        kind of <quote>object</quote> is mapped, and sometimes to pass
        some information between mapping rules. For instance, the
        mapping rule <map><emph>Expr</emph></map><a href="#jd_map_function_argument" class="judgment"><subscript>FunctionArgument(<emph>Type</emph>)</subscript></a> is
        used in the normalization of <specref ref="id-function-calls"/> and passes a sequence type as a
        parameter during normalization.</p><p>Since normalization is always applied in the presence of a 
        static context, the above rule is a shorthand for:</p><display>
         <infergr><infer><prejudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>premises</expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
              <map><expression>Object</expression></map>
              <subscript>Subscript</subscript>
              =
              Mapped Object
            </expression></clause></postjudge></infer></infergr>
        </display><p>Most normalization rules have no premises, so they are
        omitted.  The static environment is used in certain
        normalization rules (e.g. for normalization of function
        calls).  To keep the notation simpler, the static environment
        is not written in the normalization rules, but it is assumed
        to be available.</p><p id="jd_map_expr">The normalization rule that is used to map
        <quote>top-level</quote> expressions in the [XPath/XQuery] syntax
        into expressions in the [XPath/XQuery] Core is:</p><mapping><xquery><expression>
      	      <map><emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
      	    </expression></xquery><core><expression>
      	      <emph>CoreExpr</emph>
      	    </expression></core></mapping><p>which indicates that the expression <emph>Expr</emph> is normalized
        to the expression <emph>CoreExpr</emph> in the [XPath/XQuery] Core
        (with the implied <a href="#xq_stat_env_def" class="env">statEnv</a>). Note that <emph>Expr</emph> within
        the square brackets are the expression being normalized, while
        the <emph>Expr</emph> in the subscript indicate that this is the main
        normalization rule that applies to expressions. For instance,
        here is the normalization rule applied to the literal integer
        <code>1</code>.</p><mapping><xquery><expression>
      	      <map>1</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
      	    </expression></xquery><core><expression>1</expression></core></mapping><p>To simplify the specification in some cases, some further
        normalization may be used on the right-hand side of a
        normalization rule. For instance, the following normalization
        rules for the <code>/</code> operator applies normalization to
        the expanded expression on the right-hand side.</p><mapping><xquery><expression><map>/</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression></xquery><core><expression><map>(<code>fn:root</code>(self::node()) treat as document-node())</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression></core></mapping></smnotation><smexample><p>For instance, the following [expression/query]</p><eg xml:space="preserve">
    for $i in (1, 2),
        $j in (3, 4)
    return
      element pair { ($i,$j) }
</eg><p>is normalized to the Core expression</p><eg xml:space="preserve">
    for $i in (1, 2) return
      for $j in (3, 4) return
          element pair { ($i,$j) }<phrase diff="add" at="E045"> {}</phrase>
</eg><p>in which the <quote>FWLR</quote> expression is
        mapped into a composition of two simpler "for" expressions.</p></smexample></div3><div3 id="sec_static"><head>Static typing judgment</head><p>The static semantics is specified using <term>static typing
      rules</term>, which relate [XPath/XQuery] expressions to types and
      specify under what conditions an expression is well typed.</p><smnotation><p id="jd_has_type">The judgment</p><display>
        <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause>
        </display><p>holds when, in the static environment <a href="#xq_stat_env_def" class="env">statEnv</a>, the
        expression <emph>Expr</emph> has type <a href="#doc-fs-Type"><emph>Type</emph></a>.</p></smnotation><smexample><p>The result of static type inference is to associate a
        static type with every [expression/query], such that any evaluation
        of that [expression/query] is guaranteed to yield a value that
        belongs to that type.</p><p>For instance, the following expression.</p><eg xml:space="preserve">
   let $v := 3 return $v+5
</eg><p>has type <code>xs:integer</code>. This can be inferred as follows: the
        literal '3' has type integer, so the variable
        $v also has type integer. Since the sum of two integers is an
        integer, the complete expression has type integer.</p></smexample><smnote><p>The type of an expression is computed by inference. Static
        typing rules define for each kind of expression how to compute
        the type of the expression given the types of its
        sub-expressions.  Here is a simple example:</p><infergr><infer><prejudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression> <emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:boolean</code> </expression></clause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>   </expression></clause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression> <emph>Expr</emph><subscript>3</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript>    </expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
      	  <code>if</code> (<emph>Expr</emph><subscript>1</subscript>)
      	  <code>then</code> <emph>Expr</emph><subscript>2</subscript>
      	  <code>else</code> <emph>Expr</emph><subscript>3</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> ( <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> | <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript> )
      	    </expression></clause></postjudge></infer></infergr><p>This rule states that if the conditional expression of an
      	<quote>if</quote> expression has type boolean, then the type
      	of the entire expression is one of the two types of its
      	<quote>then</quote> and <quote>else</quote> clauses.  Note
      	that the resulting type is represented as a union:
      	'(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>|<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript>)'.</p><p>The part after the <term>|-</term> and before
        <term>:</term> in the judgment <emph>below</emph> the line
        corresponds to some [expression/query], for which a type is
        computed. If the [expression/query] has been parsed into an internal
        abstract syntax tree, this usually corresponds to some node in
        that tree. The judgment usually has patterns in it (here
        <emph>Expr</emph><subscript>1</subscript>, <emph>Expr</emph><subscript>2</subscript>, and <emph>Expr</emph><subscript>3</subscript>) that need to be
        matched against the children of the node in the abstract
        syntax tree. The judgments <emph>above</emph> the line
        indicate things that need to be computed to use this rule; in
        this case, the types of the condition expression and the two
        branches of the if-then-else expression.  Once those types are
        computed (by further applying static typing rules recursively
        to those sub-expressions), then the type of the expression
        below the line can be computed.  This example illustrates a
        general feature of the [XPath/XQuery] type system: the type of an
        expression depends only on the type of its sub-expressions.
        Static type inference is recursive, following the abstract
        syntax of the [expression/query].  At each point in the recursion,
        an inference rule whose conclusion has a structure that
        matches that of the premise in question is sought.  If all the
        premises of a rule cannot be satisfied, then the static type
        inference has failed for the given expression, and the
        [expression/query] is not well-typed.</p></smnote></div3><!-- ***************** Evaluation **************** --><div3 id="sec_evaluation"><head>Dynamic evaluation judgment</head><p>The dynamic, or operational, semantics is specified using
      <term>dynamic evaluation rules</term>, which relate [XPath/XQuery]
      expressions to values, and in some cases specify the order in
      which an [XPath/XQuery] expression is evaluated.</p><smnotation><p id="jd_yields">The judgment</p><display>
        <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a>; <a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a></expression></clause>
        </display><p>holds when, in the static environment <a href="#xq_stat_env_def" class="env">statEnv</a> and
        dynamic environment <a href="#xq_dyn_env_def" class="env">dynEnv</a>, the expression <emph>Expr</emph>
        yields the value <a href="#doc-fs-Value"><emph>Value</emph></a>.</p></smnotation><p>The static environment is used in certain cases (e.g. for
      type matching) during evaluation. To keep the notation simpler,
      the static environment is not written in the dynamic evaluation
      rules, but it is assumed to be available.</p><p>The inference rules used for dynamic evaluation, like those
      for static typing, follow a recursive structure, computing the
      value of expressions from the values of their
      sub-expressions.</p></div3></div2><div2 id="sec_errors"><head>Error Handling</head><p>Expressions can raise errors during static analysis or dynamic
    evaluation.  The <bibref ref="xpath-functions-30"/> <bibref ref="xquery-30"/>, and <bibref ref="xpath-30"/>
    specify the conditions under which an expression or operator
    raises an error.  The user may raise an error explicitly by
    calling the <code>fn:error</code> function, which takes an optional item as
    an argument.</p><p>This document does not describe formally the conditions under
    which dynamic errors are raised. Notably, it does not specify the
    error codes or the rules about errors and optimization, as
    described in <bibref ref="xquery-30"/>. Instead, this document
    describe the rules necessary to statically detect the subset of
    the [XPath/XQuery] dynamic errors known as <xtermref spec="XQ" ref="dt-type-error"/>.</p></div2><div2 id="id-important-concepts"><head>Concepts</head><p>[XPath/XQuery] is most generally used to process
    <term>documents</term>. The representation of a document is
    normatively defined in <bibref ref="xpath-datamodel-30"/>. The functions used to
    access documents and collections are normatively defined in
    <bibref ref="xpath-functions-30"/>. </p><div3 id="id-doc-order"><head>Document Order</head><p>Document order is defined in <bibref ref="xpath-datamodel-30"/>.</p></div3><div3 id="id-atomization"><head>Atomization</head><p>Atomization converts an item sequence into a sequence of
        atomic values and is implemented by the <code>fn:data</code> function.
        Atomization is applied to a value when the value is used in a
        context in which a sequence of atomic values is required.</p></div3><div3 id="id-ebv"><head>Effective Boolean Value</head><p>If a sequence of items is encountered where a boolean value
      is expected, the item sequence's effective boolean value is
      used. The <code>fn:boolean</code> function returns the effective boolean
      value of an item sequence.</p></div3><div3 id="id-input-sources"><head>Input Sources</head><p>[XPath/XQuery] has several functions that provide access to input
      data, described in <xspecref spec="XQ" ref="id-input-sources"/>. These functions are of particular
      importance because they provide a way in which an expression can
      reference a document or a collection of documents. The dynamic
      semantics of these input functions are described in more detail
      in <bibref ref="xpath-functions-30"/>.</p></div3><div3 id="id-uri-literals" role="xquery"><head>URI Literals</head><p>In certain places in the XQuery grammar, a statically known
      valid absolute URI is required. These places are denoted by the
      grammatical symbol <emph>URILiteral</emph>, and are treated as described
      in <bibref ref="xquery-30"/>.</p></div3></div2><div2 id="id-type-conversion"><head>Types</head><div3 id="id-predefined-types"><head>Predefined Schema Types</head><p>All the built-in types of XML Schema are recognized by
      [XPath/XQuery]. In addition, [XPath/XQuery] recognizes the predefined
      types <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>, <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> and <a href="#dt-xs_untyped"><code>xs:untyped</code></a>
      and the duration subtypes <a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a> and
      <a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      . The definition of those types in the
      [XPath/XQuery] type system is given below.</p><p><termdef id="dt-xs_anyType" term="xs:anyType"> The following
      type definition of <term><phrase><code>xs:anyType</code></phrase></term>
      reflects the semantics of the Ur type from Schema in the
      [XPath/XQuery] type system.</termdef></p><eg diff="chg" at="E022" xml:space="preserve">
  define type xs:anyType restricts xs:anyType {
    ( attribute * of type xs:anySimpleType )*,
    ( xs:anyAtomicType* | ( element * of type xs:anyType | text | comment | processing-instruction * )* )
  }
</eg><p><termdef id="dt-xs_anySimpleType" term="xs:anySimpleType">
      The following type definition of
      <term><phrase><code>xs:anySimpleType</code></phrase></term> reflects the
      semantics of the Ur simple type from Schema in the [XPath/XQuery]
      type system.</termdef></p><eg xml:space="preserve">
  define type xs:anySimpleType restricts xs:anyType {
    xs:anyAtomicType*
  }
</eg><p>The name of the Ur simple type is <code>xs:anySimpleType</code>. It is
      derived by restriction from <code>xs:anyType</code>, its content is a
      sequence any atomic types.</p><p><termdef id="dt-xs_anyAtomicType" term="xs:anyAtomicType"><phrase>The following type definition
      of <term><phrase><a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a></phrase></term> reflects
      the semantics of <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a> in the [XPath/XQuery] type
      system.</phrase></termdef></p><eg xml:space="preserve">
  define type xs:anyAtomicType restricts xs:anySimpleType {
    ( xs:string
    | xs:boolean
    | xs:decimal
    | xs:float
    | xs:double
    | xs:duration
    | xs:dateTime
    | xs:time
    | xs:date
    | xs:gYearMonth
    | xs:gYear
    | xs:gMonthDay
    | xs:gDay
    | xs:gMonth
    | xs:hexBinary
    | xs:base64Binary
    | xs:anyURI
    | xs:QName
    | xs:NOTATION
    | xs:untypedAtomic )
  }
</eg><p><termdef id="dt-primitive-types" term="primitive types"> The
      following type definitions of <term> the XML Schema primitive
      types</term> reflect the semantics of the primitive types from
      Schema in the [XPath/XQuery] type system.</termdef></p><eg xml:space="preserve">
  define type xs:string       restricts xs:anyAtomicType<phrase diff="add" at="E042">;</phrase>
  define type xs:boolean      restricts xs:anyAtomicType<phrase diff="add" at="E042">;</phrase>
  define type xs:decimal      restricts xs:anyAtomicType<phrase diff="add" at="E042">;</phrase>
  define type xs:float        restricts xs:anyAtomicType<phrase diff="add" at="E042">;</phrase>
  define type xs:double       restricts xs:anyAtomicType<phrase diff="add" at="E042">;</phrase>
  define type xs:duration     restricts xs:anyAtomicType<phrase diff="add" at="E042">;</phrase>
  define type xs:dateTime     restricts xs:anyAtomicType<phrase diff="add" at="E042">;</phrase>
  define type xs:time         restricts xs:anyAtomicType<phrase diff="add" at="E042">;</phrase>
  define type xs:date         restricts xs:anyAtomicType<phrase diff="add" at="E042">;</phrase>
  define type xs:gYearMonth   restricts xs:anyAtomicType<phrase diff="add" at="E042">;</phrase>
  define type xs:gYear        restricts xs:anyAtomicType<phrase diff="add" at="E042">;</phrase>
  define type xs:gMonthDay    restricts xs:anyAtomicType<phrase diff="add" at="E042">;</phrase>
  define type xs:gDay         restricts xs:anyAtomicType<phrase diff="add" at="E042">;</phrase>
  define type xs:gMonth       restricts xs:anyAtomicType<phrase diff="add" at="E042">;</phrase>
  define type xs:hexBinary    restricts xs:anyAtomicType<phrase diff="add" at="E042">;</phrase>
  define type xs:base64Binary restricts xs:anyAtomicType<phrase diff="add" at="E042">;</phrase>
  define type xs:anyURI       restricts xs:anyAtomicType<phrase diff="add" at="E042">;</phrase>
  define type xs:QName        restricts xs:anyAtomicType<phrase diff="add" at="E042">;</phrase>
  define type xs:NOTATION     restricts xs:anyAtomicType<phrase diff="add" at="E042">;</phrase>
</eg><p>All of those primitive types derive from
      <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>. Note that the value space of each atomic
      type (such as <code>xs:string</code>) does not appear. The value space for
      each type is built-in and is as defined in <bibref ref="xmlschema-2"/>.</p><p><termdef id="dt-xs_untypedAtomic" term="xs:untypedAtomic">The type
      <term><phrase><a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a></phrase></term> is defined as
      follows.</termdef></p><eg xml:space="preserve">
  define type xs:untypedAtomic restricts xs:anyAtomicType
</eg><p>Note that this rule does not indicate the value space of
      <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>. By definition, <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> has the
      same value space as <code>xs:string</code>.</p><p>The following example shows two atomic values. The first one
      is a value of type string containing "Database". The second one
      is an untyped atomic value containing "Database".</p><eg xml:space="preserve">
  "Databases" of type xs:string
  "Databases" of type xs:untypedAtomic
</eg><p><termdef id="dt-xs_untyped" term="xs:untyped">The type
      <term><phrase><a href="#dt-xs_untyped"><code>xs:untyped</code></a></phrase></term> is defined as
      follows.</termdef></p><eg diff="chg" at="E022" xml:space="preserve">
  define type xs:untyped restricts xs:anyType {
    attribute * of type xs:untypedAtomic*,
    ( element * of type xs:untyped | text | comment | processing-instruction * )*
  }
</eg><p><termdef id="dt-derived-types" term="derived types">The
      following type definitions of the <term>XML Schema derived
      types</term> reflect the semantics of the XML Schema types
      derived by restriction from another atomic type.</termdef></p><eg xml:space="preserve">
  define type xs:normalizedString   restricts xs:string<phrase diff="add" at="E042">;</phrase>
  define type xs:token              restricts xs:normalizedString<phrase diff="add" at="E042">;</phrase>
  define type xs:language           restricts xs:token<phrase diff="add" at="E042">;</phrase>
  define type xs:NMTOKEN            restricts xs:token<phrase diff="add" at="E042">;</phrase>
  define type xs:Name               restricts xs:token<phrase diff="add" at="E042">;</phrase>
  define type xs:NCName             restricts xs:Name<phrase diff="add" at="E042">;</phrase>
  define type xs:ID                 restricts xs:NCName<phrase diff="add" at="E042">;</phrase>
  define type xs:IDREF              restricts xs:NCName<phrase diff="add" at="E042">;</phrase>
  define type xs:ENTITY             restricts xs:NCName<phrase diff="add" at="E042">;</phrase>
  define type xs:integer            restricts xs:decimal<phrase diff="add" at="E042">;</phrase>
  define type xs:nonPositiveInteger restricts xs:integer<phrase diff="add" at="E042">;</phrase>
  define type xs:negativeInteger    restricts xs:nonPositiveInteger<phrase diff="add" at="E042">;</phrase>
  define type xs:long               restricts xs:integer<phrase diff="add" at="E042">;</phrase>
  define type xs:int                restricts xs:long<phrase diff="add" at="E042">;</phrase>
  define type xs:short              restricts xs:int<phrase diff="add" at="E042">;</phrase>
  define type xs:byte               restricts xs:short<phrase diff="add" at="E042">;</phrase>
  define type xs:nonNegativeInteger restricts xs:integer<phrase diff="add" at="E042">;</phrase>
  define type xs:unsignedLong       restricts xs:nonNegativeInteger<phrase diff="add" at="E042">;</phrase>
  define type xs:unsignedInt        restricts xs:unsignedLong<phrase diff="add" at="E042">;</phrase>
  define type xs:unsignedShort      restricts xs:unsignedInt<phrase diff="add" at="E042">;</phrase>
  define type xs:unsignedByte       restricts xs:unsignedShort<phrase diff="add" at="E042">;</phrase>
  define type xs:positiveInteger    restricts xs:nonNegativeInteger<phrase diff="add" at="E042">;</phrase>
</eg><p>Three XML Schema built-in derived types are derived by list,
      as follows. Note that those derive directly from
      <code>xs:anySimpleType</code>, since they are derived by list, and that
      their value space is defined using a <quote>one or more</quote>
      occurrence indicator.</p><eg xml:space="preserve">
  define type xs:NMTOKENS restricts xs:anySimpleType { xs:NMTOKEN+ }<phrase diff="add" at="E042">;</phrase>
  define type xs:IDREFS   restricts xs:anySimpleType { xs:IDREF+ }<phrase diff="add" at="E042">;</phrase>
  define type xs:ENTITIES restricts xs:anySimpleType { xs:ENTITY+ }<phrase diff="add" at="E042">;</phrase>
</eg><p>For example, here is an element whose content is of type
     <code>xs:IDREFS</code>.</p><eg xml:space="preserve">
  element a of type xs:IDREFS {
    "id1" of type xs:IDREF,
    "id2" of type xs:IDREF,
    "id3" of type xs:IDREF
  }
</eg><p>Note that the type name <code>xs:IDREFS</code> derives from
      <code>xs:anySimpleType</code>, but not from <code>xs:IDREF</code>. As a consequence,
      calling the following three XQuery functions with the element
      <code>a</code> as a parameter succeeds for <code>f1</code> and
      <code>f2</code>, but raises a type error for
      <code>f3</code>.</p><eg xml:space="preserve">
  declare function f1($x as element(*,xs:anySimpleType)) { $x }
  declare function f2($x as element(*,xs:IDREFS)) { $x }
  declare function f3($x as element(*,xs:IDREF)) { $x }
</eg><p><termdef id="dt-xs_durations" term="Totally ordered duration       types"><phrase>The <term>totally ordered duration types</term>,
      <a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a> and <a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      , are derived
      by restriction from <code>xs:duration</code>.</phrase></termdef></p><eg xml:space="preserve">
  define type xs:yearMonthDuration restricts xs:duration<phrase diff="add" at="E042">;</phrase>
  define type xs:dayTimeDuration   restricts xs:duration<phrase diff="add" at="E042">;</phrase>
</eg><p><termdef id="dt-fs_numeric" term="fs:numeric">In addition,
      the Formal Semantics uses the additional type <emph>fs:</emph><code>numeric</code>. This
      type is necessary for the specification of some of XPath type
      conversion rules.  It is defined as follows.</termdef></p><eg xml:space="preserve">
  define type fs:numeric restricts xs:anyAtomicType { xs:decimal | xs:float | xs:double }
</eg></div3><div3 id="id-typed-value"><head>Typed Value and String Value</head><p>The typed value of a node is computed by the <code>fn:data</code>
      function, and the string value of a node is computed by the
      <code>fn:string</code> function, defined in <bibref ref="xpath-functions-30"/>.
The normative definitions of typed value and string value are defined in <bibref ref="xpath-datamodel-30"/>.
</p></div3><div3 id="id-sequencetype"><head>SequenceType Syntax</head><smintro><p>Sequence types can be used in [XPath/XQuery] to refer to an XML
        Schema type. Sequence types are used to declare the types of
        function parameters and in several [XPath/XQuery] expressions.</p><p>The syntax of sequence types is described by the following
        grammar productions.</p><scrap headstyle="show"><head>SequenceType</head><prodrecap id="SequenceType" ref="SequenceType" orig="xquery"/><prodrecap id="ItemType" ref="ItemType" orig="xquery"/><prodrecap id="OccurrenceIndicator" ref="OccurrenceIndicator" orig="xquery"/><prodrecap id="AtomicType" ref="AtomicType" orig="xquery"/><prodrecap id="KindTest" ref="KindTest" orig="xquery"/><prodrecap id="DocumentTest" ref="DocumentTest" orig="xquery"/><prodrecap id="ElementTest" ref="ElementTest" orig="xquery"/><prodrecap id="SchemaElementTest" ref="SchemaElementTest" orig="xquery"/><prodrecap id="ElementDeclaration" ref="ElementDeclaration" orig="xquery"/><prodrecap id="AttributeTest" ref="AttributeTest" orig="xquery"/><prodrecap id="SchemaAttributeTest" ref="SchemaAttributeTest" orig="xquery"/><prodrecap id="AttributeDeclaration" ref="AttributeDeclaration" orig="xquery"/><prodrecap id="ElementNameOrWildcard" ref="ElementNameOrWildcard" orig="xquery"/><prodrecap id="ElementName" ref="ElementName" orig="xquery"/><prodrecap id="AttribNameOrWildcard" ref="AttribNameOrWildcard" orig="xquery"/><prodrecap id="AttributeName" ref="AttributeName" orig="xquery"/><prodrecap id="TypeName" ref="TypeName" orig="xquery"/><prodrecap id="PITest" ref="PITest" orig="xquery"/><prodrecap id="CommentTest" ref="CommentTest" orig="xquery"/><prodrecap id="TextTest" ref="TextTest" orig="xquery"/><prodrecap id="AnyKindTest" ref="AnyKindTest" orig="xquery"/></scrap><smcore><p>The Core grammar productions for sequence types are:</p><scrap headstyle="show"><head/><prodrecap id="core-SequenceType" ref="SequenceType" orig="core"/><prodrecap id="core-ItemType" ref="ItemType" orig="core"/><prodrecap id="core-OccurrenceIndicator" ref="OccurrenceIndicator" orig="core"/><prodrecap id="core-AtomicType" ref="AtomicType" orig="core"/><prodrecap id="core-KindTest" ref="KindTest" orig="core"/><prodrecap id="core-DocumentTest" ref="DocumentTest" orig="core"/><prodrecap id="core-ElementTest" ref="ElementTest" orig="core"/><prodrecap id="core-SchemaElementTest" ref="SchemaElementTest" orig="core"/><prodrecap id="core-ElementDeclaration" ref="ElementDeclaration" orig="core"/><prodrecap id="core-AttributeTest" ref="AttributeTest" orig="core"/><prodrecap id="core-SchemaAttributeTest" ref="SchemaAttributeTest" orig="core"/><prodrecap id="core-AttributeDeclaration" ref="AttributeDeclaration" orig="core"/><prodrecap id="core-ElementNameOrWildcard" ref="ElementNameOrWildcard" orig="core"/><prodrecap id="core-ElementName" ref="ElementName" orig="core"/><prodrecap id="core-AttribNameOrWildcard" ref="AttribNameOrWildcard" orig="core"/><prodrecap id="core-AttributeName" ref="AttributeName" orig="core"/><prodrecap id="core-TypeName" ref="TypeName" orig="core"/><prodrecap id="core-PITest" ref="PITest" orig="core"/><prodrecap id="core-CommentTest" ref="CommentTest" orig="core"/><prodrecap id="core-TextTest" ref="TextTest" orig="core"/><prodrecap id="core-AnyKindTest" ref="AnyKindTest" orig="core"/></scrap></smcore><p>The semantics of SequenceTypes is defined by means of
        normalization rules from SequenceTypes into types in the
        [XPath/XQuery] type system (See <specref ref="sec_types"/>).</p><p>However, the [XPath/XQuery] type system not being part of the
        [XPath/XQuery] syntax, the SequenceType syntax is still part of
        the [XPath/XQuery] Core. Normalization from SequenceTypes to types
        is not applied during the normalization phase but whenever a
        dynamic evaluation or static typing rule requires it.</p></smintro></div3><div3 id="id-sequencetype-matching"><head>SequenceType Matching</head><smintro><p>During processing of a query, it is sometimes necessary
          to determine whether a given value matches a type that was
          declared using the SequenceType syntax. This process is
          known as SequenceType matching, and is formally specified in
          <specref ref="sec_type_matching"/>.</p></smintro><smnotation><p id="jd_map_sequencetype">To define normalization of
          SequenceTypes to the [XPath/XQuery] type system, the following
          auxiliary mapping rule is used.</p><mapping><xquery><expression>
               <map><emph>SequenceType</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression></xquery><core><expression>
               <a href="#doc-fs-Type"><emph>Type</emph></a>
              </expression></core></mapping><p>specifies that <emph>SequenceType</emph> is mapped to a <a href="#doc-fs-Type"><emph>Type</emph></a>,
          in the [XPath/XQuery] type system.</p></smnotation><smnorm><p>OccurenceIndicators are left unchanged when normalizing
          SequenceTypes into [XPath/XQuery] types. Each kind of
          SequenceType component is normalized separately into the
          [XPath/XQuery] type system.</p><mapping><xquery><expression>
               <map><a href="#doc-core-ItemType"><emph>ItemType</emph></a> <emph>OccurrenceIndicator</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression></xquery><core><expression>
               <map><a href="#doc-core-ItemType"><emph>ItemType</emph></a></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a> <emph>OccurrenceIndicator</emph>
              </expression></core></mapping><p>The <quote>empty-sequence()</quote> sequence type is
            mapped to the empty type.</p><mapping><xquery><expression>
               <map>empty-sequence()</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression></xquery><core><expression>
               empty
              </expression></core></mapping><p>An atomic type is normalized to itself in the
            [XPath/XQuery] type system.</p><mapping><xquery><expression>
               <map><a href="#doc-core-AtomicType"><emph>AtomicType</emph></a></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression></xquery><core><expression>
               <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a>
              </expression></core></mapping><p>An <quote>element</quote> SequenceType without content
            or with a wildcard and no type name is normalized into a
            wildcard element type.</p><mapping><xquery><expression>
               <map>element()</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression></xquery><core><expression>
                element * of type <code>xs:anyType</code>
              </expression></core></mapping><mapping><xquery><expression>
               <map>element(*)</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression></xquery><core><expression>
                element * of type <code>xs:anyType</code>
              </expression></core></mapping><p>An <quote>element</quote> SequenceType with a wildcard
            and a type name is normalized into a wildcard element type
            with a corresponding type name. The presence of a
            <quote>?</quote> after the type name indicates a nillable
            element.</p><mapping><xquery><expression>
               <map>element(*,<a href="#doc-fs-TypeName"><emph>TypeName</emph></a>)</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression></xquery><core><expression>
                element * of type <a href="#doc-fs-TypeName"><emph>TypeName</emph></a>
              </expression></core></mapping><mapping><xquery><expression>
               <map>element(*,<a href="#doc-fs-TypeName"><emph>TypeName</emph></a>?)</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression></xquery><core><expression>
                element * nillable of type <a href="#doc-fs-TypeName"><emph>TypeName</emph></a>
              </expression></core></mapping><p>An <quote>element</quote> SequenceType with a name and
            a type name is normalized into an element type with a
            corresponding type name. The presence of a
            <quote>?</quote> after the type name indicates a nillable
            element.</p><mapping><xquery><expression>
               <map>element(<a href="#doc-fs-ElementName"><emph>ElementName</emph></a>,<a href="#doc-fs-TypeName"><emph>TypeName</emph></a>)</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression></xquery><core><expression>
                element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> of type <a href="#doc-fs-TypeName"><emph>TypeName</emph></a>
              </expression></core></mapping><mapping><xquery><expression>
               <map>element(<a href="#doc-fs-ElementName"><emph>ElementName</emph></a>,<a href="#doc-fs-TypeName"><emph>TypeName</emph></a>?)</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression></xquery><core><expression>
                element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> nillable of type <a href="#doc-fs-TypeName"><emph>TypeName</emph></a>
              </expression></core></mapping><p>An <quote>element</quote> SequenceType with only a name
            is normalized into a <emph>nillable</emph> element type
            with a corresponding name. The reason for the
            normalization to allow nillable elements is because the
            semantics of SequenceTypes in that case allows it to match
            every possible element with that names, regardless of its
            type or nilled property.</p><mapping><xquery><expression>
               <map>element(<a href="#doc-fs-ElementName"><emph>ElementName</emph></a>)</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression></xquery><core><expression>
                element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> nillable of type <code>xs:anyType</code>
              </expression></core></mapping><p>A <quote>schema-element</quote> SequenceType with an
            element declaration is normalized into a reference to the
            corresponding global element declaration.</p><mapping><xquery><expression>
               <map>schema-element(<a href="#doc-fs-ElementName"><emph>ElementName</emph></a>)</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression></xquery><core><expression>
                element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a>
              </expression></core></mapping><p>An <quote>attribute</quote> SequenceType without
            content or with a wildcard and no type name is normalized
            into a wildcard attribute type.</p><mapping><xquery><expression>
               <map>attribute()</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression></xquery><core><expression>
                attribute * of type <code>xs:anySimpleType</code> 
              </expression></core></mapping><mapping><xquery><expression>
               <map>attribute(*)</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression></xquery><core><expression>
                attribute * of type <code>xs:anySimpleType</code> 
              </expression></core></mapping><p>An <quote>attribute</quote> SequenceType with a
            wildcard and a type name is normalized into a wildcard
            attribute type with a corresponding type name.</p><mapping><xquery><expression>
               <map>attribute(*,<a href="#doc-fs-TypeName"><emph>TypeName</emph></a>)</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression></xquery><core><expression>
                attribute * of type <a href="#doc-fs-TypeName"><emph>TypeName</emph></a>
              </expression></core></mapping><p>An <quote>attribute</quote> SequenceType with a name
            and a type name is normalized into an attribute type with
            a corresponding type name.</p><mapping><xquery><expression>
               <map>attribute(<a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a>,<a href="#doc-fs-TypeName"><emph>TypeName</emph></a>)</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression></xquery><core><expression>
                attribute <a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a> of type <a href="#doc-fs-TypeName"><emph>TypeName</emph></a>
              </expression></core></mapping><p>A <quote>schema-attribute</quote> SequenceType with an
            attribute declaration is normalized into a reference to
            the corresponding global attribute declaration.</p><mapping><xquery><expression>
               <map>schema-attribute(<a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a>)</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression></xquery><core><expression>
                attribute <a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a>
              </expression></core></mapping><p>A <quote>document-node()</quote> sequence types is
            normalized into the corresponding document type.</p><mapping><xquery><expression>
               <map>document-node()</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression></xquery><core><expression>
                document { (element * of type <code>xs:anyType</code> | text | comment | processing-instruction<phrase diff="add" at="E022"> *</phrase> )* }
              </expression></core></mapping><p>A <quote>document-node</quote> sequence type with an
            element test (resp. a schema element test) is normalized
            into the corresponding document type, whose content is the
            normalization of the element test (resp. schema element
            test), interleaved with an arbitrary sequence of
            processing instruction, comment, and text nodes.</p><mapping><xquery><expression>
               <map>document-node(<emph>ElementTest</emph>)</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression></xquery><core><expression>
                document {
                <map><emph>ElementTest</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a> &amp;
                ( processing-instruction<phrase diff="add" at="E022"> *</phrase> | comment ) *}
              </expression></core></mapping><mapping><xquery><expression>
               <map>document-node(<emph>SchemaElementTest</emph>)</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression></xquery><core><expression>
                document {
                <map><emph>SchemaElementTest</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a> &amp;
                ( processing-instruction<phrase diff="add" at="E022"> *</phrase> | comment ) *}
              </expression></core></mapping><p>A <quote>processing-instruction()</quote> SequenceType
            is normalized into the corresponding
            processing-instruction type.</p><mapping><xquery><expression>
               <map>processing-instruction()</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression></xquery><core><expression>processing-instruction<phrase diff="add" at="E022"> *</phrase></expression></core></mapping><p diff="del" at="E022">The [XPath/XQuery] type system does not model the target of
            a processing-instruction, which is treated as a dynamic
            property. Therefore a
            <quote>processing-instruction</quote> SequenceType with a
            string or NCName parameter is normalized into an optional
            processing-instruction type.</p><mapping diff="del" at="E022"><xquery><expression>
               <map>processing-instruction(<emph>StringLiteral</emph>)</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression></xquery><core><expression>processing-instruction?</expression></core></mapping><mapping><xquery><expression>
               <map>processing-instruction(<emph>NCName</emph>)</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression></xquery><core><expression diff="chg" at="E022">processing-instruction <emph>NCName</emph></expression></core></mapping><!--
                <mapping> is transformed to a div with whitespace only at the top;
                <infergr> is transformed to a div with whitespace only at the bottom.
                Thus a <mapping> followed by an <infergr> transforms to two divs
                with no space in between.
                So add a para to separate them.
            --><p diff="add" at="E022">
            For backward compatibility with XPath 1.0,
            the PITarget of a PITest
            may also be expressed as a string literal.
            The following rule handles that case.
            </p><infergr diff="add" at="E022"><infer><prejudge><multiclause><clause><expression><emph>StringLiteral</emph> <a href="#jd_has_atomic_value" class="judgment"><term>has atomic value</term></a> <emph>String</emph></expression></clause></multiclause><multiclause><clause><expression><code>xs:NCName</code>(<emph>String</emph>) = <emph>NCName</emph> </expression></clause></multiclause></prejudge><postjudge><clause><expression>
                      <map>processing-instruction(<emph>StringLiteral</emph>)</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                      =
                      processing-instruction <emph>NCName</emph>
                    </expression></clause></postjudge></infer></infergr><p>A <quote>comment()</quote> SequenceType is normalized
            into the corresponding comment type.</p><mapping><xquery><expression>
               <map>comment()</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression></xquery><core><expression>comment</expression></core></mapping><p>A <quote>text()</quote> SequenceType is normalized into
            the corresponding text type.</p><mapping><xquery><expression>
               <map>text()</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression></xquery><core><expression>
                text
              </expression></core></mapping><p>The <quote>node()</quote> SequenceType denotes any
            node. It is normalized into a choice between the
            corresponding wildcard types for each kind of node.</p><mapping><xquery><expression>
               <map>node()</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression></xquery><core><expression>
                (element * of type <code>xs:anyType</code> | attribute * of type
                <code>xs:anySimpleType</code> | text | document { (element * of
                type <code>xs:anyType</code> | text | comment |
                processing-instruction<phrase diff="add" at="E022"> *</phrase>)* } | comment | processing-instruction<phrase diff="add" at="E022"> *</phrase>)
              </expression></core></mapping><p>The <quote>item()</quote> SequenceType denotes any node
            or atomic value. It is normalized into a choice between
            the corresponding wildcard types for each kind of nodes or
            atomic values.</p><mapping><xquery><expression>
               <map>item()</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression></xquery><core><expression>
                (element * of type <code>xs:anyType</code> | attribute * of type <code>xs:anySimpleType</code> | text | document { (element * of
                type <code>xs:anyType</code> | text | comment |
                processing-instruction<phrase diff="add" at="E022"> *</phrase>)* } | comment |
                processing-instruction<phrase diff="add" at="E022"> *</phrase> | <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a> )
              </expression></core></mapping></smnorm></div3></div2><div2 id="comments"><head>Comments</head><scrap headstyle="show"><head/><prodrecap id="Comment" ref="Comment" orig="xquery"/><prodrecap id="CommentContents" ref="CommentContents" orig="xquery"/></scrap><p>Comments are lexical constructs only, and have no effect on the
    meaning of the query, and therefore do not have any formal
    semantics.</p></div2><div2 id="xml-terminals"><head>XML-defined Terminals</head><p>The following terminals are defined by XML.</p><scrap headstyle="show"><head/><prodrecap id="XQueryDefinedLexemesForXML" ref="XQueryDefinedLexemesForXML" role="XQueryDefinedLexemesForXML" at="../xquery-semantics/temp-shared/xquery-grammar.xml" orig="xquery"/></scrap></div2></div1><div1 id="id-expressions"><head>Expressions</head><p>This section gives the semantics of all the [XPath/XQuery]
  expressions. The organization of this section parallels the
  organization of <xspecref spec="XQ" ref="id-expressions"/>.</p><scrap headstyle="show"><head/><prodrecap id="Expr" ref="Expr" orig="xquery"/><prodrecap id="ExprSingle" ref="ExprSingle" orig="xquery"/><prodrecap id="XPath" ref="XPath" orig="xpath" test="XPath"/></scrap><p>For each expression, a short description and the relevant grammar
  productions are given. The semantics of an expression includes the
  normalization, static analysis, and dynamic evaluation
  phases. Recall that normalization rules translate [XPath/XQuery] syntax
  into Core syntax. In the sections that contain normalization rules,
  the Core grammar productions into which the expression is normalized
  are also provided. After normalization, sections on static type
  inference and dynamic evaluation define the static type and dynamic
  value for the Core expression.</p><smcore><p>The Core grammar productions for expressions are:</p><scrap headstyle="show"><head/><prodrecap id="core-Expr" ref="Expr" orig="core"/><prodrecap id="core-ExprSingle" ref="ExprSingle" orig="core"/></scrap></smcore><smtype><p>During static analysis, it is a type error for an expression to have the empty
    type, except for the following expressions and function calls:

    <ulist><item><p>Empty parentheses <code>()</code>, which denote the
      empty sequence.</p></item><item><p>The <code>fn:data</code> function and all functions in the
      <emph>fs</emph> namespace applied to empty
      parentheses <code>()</code>.</p></item><item><p>Any function which returns the empty type.</p></item></ulist>

    The reason for these exceptions is that they are typically part of
    the result of normalizing a larger user-level expression and are
    used to capture the semantics of the user-level expression when
    applied to the empty sequence.</p><p>The rule below enforces the above constraints. It is a static
    type error, if the following conditions hold for a given
    expression <emph>Expr</emph>.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <code>empty</code></expression></clause></multiclause><multiclause><clause><expression><a href="#jd_not" class="judgment"><term>not</term></a>(<emph>Expr</emph> is the empty
              parentheses () or <code>fn:data</code> or any <emph>fs</emph>
              function applied to empty parentheses ())</expression></clause></multiclause></prejudge><postjudge><multiclause><clause><expression>A static type error is raised for expression <emph>Expr</emph></expression></clause></multiclause></postjudge></infer></infergr><p>In general, static type errors are raised whenever there
      <phrase diff="del" at="E046">is</phrase>
      <phrase diff="add" at="E046">are</phrase>
      no static typing rules which can compute the type of a given
      expression. This is the reason for the absence of a formal
      <phrase diff="del" at="E046">post-condition</phrase>
      <phrase diff="add" at="E046">conclusion</phrase>
      in this
      <phrase diff="del" at="E046">rules</phrase>
      <phrase diff="add" at="E046">rule</phrase>.
      There is indeed a rule that infers
      the type for expression <emph>Expr</emph>, however the inferred type is
      empty and still a static type error must be raised.</p><smexample><p>The above rule is useful in catching common mistakes, such
        as the misspelling of an element or attribute name or
        referencing of an element or attribute that does not
        exist. For instance, the following path expression</p><eg xml:space="preserve">  $x/title
</eg><p>raises a static type error if the type of variable
    <code>$x</code> does not include any
    <code>title</code> children elements.</p></smexample></smtype><!-- ***************** Primary expressions              ****** --><div2 id="id-primary-expressions"><head>Primary Expressions</head><p><term>Primary expressions</term> are the basic primitives of
    the language. They include literals, variables, function calls,
    and the parenthesized expressions.</p><scrap headstyle="show"><head>Primary Expressions</head><prodrecap id="PrimaryExpr" ref="PrimaryExpr" orig="xquery"/></scrap><smcore><p>The Core grammar production for primary expressions is:</p><scrap headstyle="show"><head>Primary Expressions</head><prodrecap id="core-PrimaryExpr" ref="PrimaryExpr" orig="core"/></scrap></smcore><div3 id="id-literals"><head>Literals</head><smintro><p>A <term>literal</term> is a direct syntactic representation
        of an atomic value.  [XPath/XQuery] supports two kinds of literals:
        string literals and numeric literals.</p></smintro><scrap headstyle="show"><head>Literals</head><prodrecap id="Literal" ref="Literal" orig="xquery"/><prodrecap id="NumericLiteral" ref="NumericLiteral" orig="xquery"/><prodrecap id="IntegerLiteral" ref="IntegerLiteral" orig="xquery"/><prodrecap id="DecimalLiteral" ref="DecimalLiteral" orig="xquery"/><prodrecap id="DoubleLiteral" ref="DoubleLiteral" orig="xquery"/><prodrecap id="StringLiteral" ref="StringLiteral" orig="xquery"/><prodrecap id="URILiteral" ref="URILiteral" orig="xquery"/><prodrecap id="PredefinedEntityRef" ref="PredefinedEntityRef" orig="xquery"/><prodrecap id="Digits" ref="Digits" orig="xquery"/></scrap><smcore><p>The Core grammar productions for literals are:</p><scrap headstyle="show"><head>Literals</head><prodrecap id="core-Literal" ref="Literal" orig="core"/><prodrecap id="core-NumericLiteral" ref="NumericLiteral" orig="core"/><prodrecap id="core-IntegerLiteral" ref="IntegerLiteral" orig="core"/><prodrecap id="core-DecimalLiteral" ref="DecimalLiteral" orig="core"/><prodrecap id="core-DoubleLiteral" ref="DoubleLiteral" orig="core"/><prodrecap id="core-StringLiteral" ref="StringLiteral" orig="core"/><prodrecap id="core-URILiteral" ref="URILiteral" orig="core"/><prodrecap id="core-Digits" ref="Digits" orig="core"/></scrap></smcore><smnotation><p>To define the dynamic semantics of literals, we introduce
         the following auxiliary judgments.</p><p id="jd_has_atomic_value">The judgment</p><display>
          <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>Literal</emph> <a href="#jd_has_atomic_value" class="judgment"><term>has atomic value</term></a> <a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a></expression></clause>
        </display><p>holds if the literal expression <emph>Literal</emph> corresponds
          to the value <a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a>. This judgment yields an
          atomic value, according to the rules described in <bibref ref="xquery-30"/>. Notably, this judgment deals with handling
          of literal overflows for numeric literals, and handling of
          character references, and predefined entity references for
          string literals.</p></smnotation><smnorm><p>Literals are left unchanged through normalization.</p><mapping><xquery><expression>
           <map><emph>IntegerLiteral</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
          </expression></xquery><core><expression>
            <emph>IntegerLiteral</emph>
          </expression></core></mapping><mapping><xquery><expression>
           <map><emph>DecimalLiteral</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
          </expression></xquery><core><expression>
            <emph>DecimalLiteral</emph>
          </expression></core></mapping><mapping><xquery><expression>
           <map><emph>DoubleLiteral</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
          </expression></xquery><core><expression>
            <emph>DoubleLiteral</emph>
          </expression></core></mapping><mapping><xquery><expression>
           <map><emph>StringLiteral</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
          </expression></xquery><core><expression>
            <emph>StringLiteral</emph>
          </expression></core></mapping></smnorm><smtype><p>The static type of a literal expression is its
        corresponding atomic type.</p><infergr><infer><postjudge><multiclause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>IntegerLiteral</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> xs:integer</expression></clause></multiclause></postjudge></infer></infergr><infergr><infer><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>DecimalLiteral</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> xs:decimal</expression></clause></multiclause></postjudge></infer></infergr><infergr><infer><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>DoubleLiteral</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> xs:double</expression></clause></multiclause></postjudge></infer></infergr><infergr><infer><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>StringLiteral</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> xs:string</expression></clause></multiclause></postjudge></infer></infergr></smtype><smeval><p>In the dynamic semantics, a literal is evaluated by
        constructing an atomic value in the data model, using the
        <a href="#jd_has_atomic_value" class="judgment"><term>has atomic value</term></a> judgment defined above.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>Literal</emph> <a href="#jd_has_atomic_value" class="judgment"><term>has atomic value</term></a> <a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a>
 	        </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment> <a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>Literal</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a></expression></clause></multiclause></postjudge></infer></infergr></smeval></div3><div3 id="id-variables"><head>Variable References</head><smintro><p>A <term>variable</term> evaluates to the value to which the
      variable's QName is bound in the <term>dynamic
      context</term>.</p></smintro><scrap headstyle="show"><head>Variable References</head><prodrecap id="VarRef" ref="VarRef" orig="xquery"/><prodrecap id="VarName" ref="VarName" orig="xquery"/></scrap><smcore><p>The Core grammar productions for variable references are:</p><scrap headstyle="show"><head>Primary Expressions</head><prodrecap id="core-VarRef" ref="VarRef" orig="core"/><prodrecap id="core-VarName" ref="VarName" orig="core"/></scrap></smcore><smnorm><p>Variable references are left unchanged through
      normalization.</p><mapping><xquery><expression>
         <map><a href="#prod-core-VarRef"><emph>VarRef</emph></a></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
        </expression></xquery><core><expression>
          <a href="#prod-core-VarRef"><emph>VarRef</emph></a>
        </expression></core></mapping></smnorm><smtype><p>In the static semantics, the type of a variable is simply its
      type in the static environment <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a>:</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>VarName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a> <emph>Variable</emph>
 	      </expression></clause></multiclause><multiclause><clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a>(<emph>Variable</emph>) = <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>$<emph>VarName</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause></multiclause></postjudge></infer></infergr><p>If the variable is not bound in the static environment, a
      static type error is raised.</p></smtype><smeval><p>In the dynamic semantics, a locally declared variable is
      evaluated by "looking up" its value in <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a>:</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>VarName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a> <emph>Variable</emph>
 	      </expression></clause></multiclause><multiclause><clause><expression><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a>(<emph>Variable</emph>) = <a href="#doc-fs-Value"><emph>Value</emph></a></expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>$<emph>VarName</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a></expression></clause></multiclause></postjudge></infer></infergr><p>In the dynamic semantics, a reference to a variable imported
      from a module is evaluated by accessing the dynamic context of
      the module in which the variable is declared.</p><p>The notation <emph>AnyURI</emph> <a href="#jd_module_dynEnv" class="judgment"><term>=&gt;</term><subscript>module_dynEnv</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript> is
      used to access a module context and is defined in <specref ref="id-module-declaration"/>.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>VarName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a> <emph>Variable</emph></expression></clause></multiclause><multiclause><clause><expression><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a>(<emph>Variable</emph>) = <code>#IMPORTED</code>(<emph>AnyURI</emph>)</expression></clause></multiclause><multiclause><clause><expression><emph>AnyURI</emph> <a href="#jd_module_dynEnv" class="judgment"><term>=&gt;</term><subscript>module_dynEnv</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><expression><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript>.<a href="#xq_val_env" class="env">varValue</a>(<emph>Variable</emph>) = <a href="#doc-fs-Value"><emph>Value</emph></a></expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>$<emph>VarName</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a></expression></clause></multiclause></postjudge></infer></infergr></smeval></div3><div3 id="id-paren-expressions"><head>Parenthesized Expressions</head><scrap headstyle="show"><head/><prodrecap id="ParenthesizedExpr" ref="ParenthesizedExpr" orig="xquery"/></scrap><smcore><p>The Core grammar production for parenthesized expressions is:</p><scrap headstyle="show"><head/><prodrecap id="core-ParenthesizedExpr" ref="ParenthesizedExpr" orig="core"/></scrap></smcore><p>Empty parentheses <code>()</code> always have the empty
    type. Remember that it is a static type error for most expressions
    other than <code>()</code> to have the empty type (see <specref ref="id-expressions"/> for the complete rule.)</p><smtype><infergr><infer><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>() <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>empty</code></expression></clause></multiclause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>( <emph>Expr</emph> ) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause></multiclause></postjudge></infer></infergr></smtype><smeval><p>Empty parentheses <code>()</code> evaluate to the empty
      sequence.</p><infergr><infer><postjudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>() <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> ()</expression></clause></multiclause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a></expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>( <emph>Expr</emph> ) <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a></expression></clause></multiclause></postjudge></infer></infergr></smeval></div3><div3 id="id-context-item-expression"><head>Context Item Expression</head><scrap headstyle="show"><head/><prodrecap id="ContextItemExpr" ref="ContextItemExpr" orig="xquery"/></scrap><smintro><p>A <term>context item expression</term> evaluates to
             the context item, which may be either a node or an atomic
             value.</p></smintro><smnorm><p>A context item expression is normalized to the built-in
           variable <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>dot</code></a>. Because it can only be bound through the
           external context or a path expression, there is no need for
           a specific static typing rule to enforce that its value is
           a singleton item.</p><mapping><xquery><expression><map>.</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression></xquery><core><expression><a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>dot</code></a></expression></core></mapping></smnorm></div3><div3 id="id-function-calls"><head>Function Calls</head><smintro><p>A function call consists of a QName followed by a
      parenthesized list of zero or more expressions.  In [XPath/XQuery],
      the actual argument to a function is called an
      <term>argument</term> and the formal argument of a function is
      called a <term>parameter</term>.  We use the same terminology
      here. </p><scrap headstyle="show"><head>Function Calls</head><prodrecap id="FunctionCall" ref="FunctionCall" orig="xquery"/></scrap><p>Because [XPath/XQuery] implicitly converts the values of function
      arguments, a normalization step is required.</p></smintro><smcore><p>The Core grammar production for function calls is:</p><scrap headstyle="show"><head>Function Calls</head><prodrecap id="core-FunctionCall" ref="FunctionCall" orig="core"/></scrap></smcore><smnotation><p id="jd_map_function_argument">Normalization of function calls
      uses an auxiliary mapping <map/><a href="#jd_map_function_argument" class="judgment"><subscript>FunctionArgument(<emph>Type</emph>)</subscript></a>
      used to insert conversions of function arguments that depend
      only on the expected <a href="#doc-fs-Type"><emph>Type</emph></a> of the corresponding
      parameters. It is defined as follows:</p><mapping><xquery><expression><map><emph>Expr</emph></map><a href="#jd_map_function_argument" class="judgment"><subscript>FunctionArgument(<emph>Type</emph>)</subscript></a></expression></xquery><core><expression><map><map><map><emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></map><a href="#jd_map_function_argument" class="judgment"><subscript>AtomizeAtomic(<emph>Type</emph>)</subscript></a></map><a href="#jd_map_function_argument" class="judgment"><subscript>Convert(<emph>Type</emph>)</subscript></a></expression></core></mapping><p>where</p><ulist><item><p><map><emph>Expr</emph></map><a href="#jd_map_function_argument" class="judgment"><subscript>AtomizeAtomic(<emph>Type</emph>)</subscript></a> denotes</p><table summary=""><tbody><tr><td rowspan="1" colspan="1">If
                  </td><td rowspan="1" colspan="1"><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>*</td></tr><tr><td rowspan="1" colspan="1">Then</td><td rowspan="1" colspan="1"><code>fn:data</code>(<emph>Expr</emph>)</td><td rowspan="1" colspan="1">  </td></tr><tr><td rowspan="1" colspan="1">Else</td><td rowspan="1" colspan="1"><emph>Expr</emph></td><td rowspan="1" colspan="1">  </td></tr></tbody></table><p>which specifies that if the function expects atomic
            parameters, then <code>fn:data</code> is called to obtain them.</p></item><item><p><map><emph>Expr</emph></map><a href="#jd_map_function_argument" class="judgment"><subscript>Convert(<emph>Type</emph>)</subscript></a> denotes</p><table summary=""><tbody><tr><td rowspan="1" colspan="1">If</td><td rowspan="1" colspan="1"><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>*</td></tr><tr><td rowspan="1" colspan="1">Then</td><td rowspan="1" colspan="1"><a href="#sec_convert_simple_operand"><emph>fs:</emph><code>convert-simple-operand</code></a>(<emph>Expr</emph>,<emph>PrototypicalValue</emph>)</td></tr><tr><td rowspan="1" colspan="1">Else</td><td rowspan="1" colspan="1"><emph>Expr</emph></td></tr></tbody></table><p>where <emph>PrototypicalValue</emph> is a built-in atomic
          value used to encode the expected atomic type (for instance
          the value <code>1.0</code> if the expected type is
          <code>xs:decimal</code>). A value is used here since [XPath/XQuery]
          expressions cannot operate directly on types. Which value is
          chosen does not have any impact on the actual semantics,
          only its actual atomic type matters.</p></item></ulist></smnotation><smnote><p>The <a href="#sec_convert_simple_operand"><emph>fs:</emph><code>convert-simple-operand</code></a> function takes a
        <emph>PrototypicalValue</emph>, which is a value of the target
        type, to ensure that conversion to base types is possible even
        though types are not first class objects in [XPath/XQuery]. Also,
        note that in the case of built-in functions where the expected
        type is specified as numeric, the prototypical value is a
        value of type <code>xs:double</code>.</p></smnote><smnorm><p>Each argument expression in a function call is normalized
        to its corresponding Core expression by applying
        <map/><a href="#jd_map_function_argument" class="judgment"><subscript>FunctionArgument(<emph>Type</emph>)</subscript></a>
        <phrase diff="del" at="E047">for each argument</phrase>
        <phrase diff="del" at="E047">
        with
        the expected <emph>SequenceType</emph> for the argument inserted.
        </phrase>
        <phrase diff="add" at="E047">
        where <a href="#doc-fs-Type"><emph>Type</emph></a> is the corresponding parameter type.
        </phrase>
        </p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>QName</emph> <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression></clause></multiclause><multiclause><clause diff="chg" at="E008"><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                <a href="#jd_not" class="judgment"><term>not</term></a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> <a href="#jd_denotes_a_constructor_function" class="judgment"><term>denotes a constructor function</term></a>)
              </expression></clause></multiclause><multiclause><clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_functy_env" class="env">funcType</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>,n) =
                  declare function <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, ..., <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>) as <a href="#doc-fs-Type"><emph>Type</emph></a>
                </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
              <map><emph>QName</emph> (<emph>Expr</emph><subscript>1</subscript>, ..., <emph>Expr</emph><subscript>n</subscript>)</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
              =
              <emph>QName</emph>
              ( <map><emph>Expr</emph><subscript>1</subscript></map><a href="#jd_map_function_argument" class="judgment"><subscript>FunctionArgument(<emph>Type</emph><subscript>1</subscript>)</subscript></a>, ...,
                <map><emph>Expr</emph><subscript>n</subscript></map><a href="#jd_map_function_argument" class="judgment"><subscript>FunctionArgument(<emph>Type</emph><subscript>n</subscript>)</subscript></a> )
            </expression></clause></postjudge></infer></infergr><mapping diff="del" at="E047"><xquery><expression>
              
            </expression></xquery><core><expression>
              <emph>QName</emph>
              ( <map><emph>Expr</emph><subscript>1</subscript></map><a href="#jd_map_function_argument" class="judgment"><subscript>FunctionArgument(<emph>Type</emph><subscript>1</subscript>)</subscript></a>, ...,
                <map><emph>Expr</emph><subscript>n</subscript></map><a href="#jd_map_function_argument" class="judgment"><subscript>FunctionArgument(<emph>Type</emph><subscript>n</subscript>)</subscript></a> )
            </expression></core></mapping><p>Note that this normalization rule depends on the function
        <phrase diff="del" at="E047">signatures,</phrase>
        <phrase diff="add" at="E047">signature (found in <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_functy_env" class="env">funcType</a>),</phrase>
        which is used to get the types of the function
        parameters
        <phrase diff="del" at="E047">(<emph>SequenceType</emph><subscript>1</subscript>,...,<emph>SequenceType</emph><subscript>n</subscript>)</phrase>
        <phrase diff="add" at="E047">(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, ..., <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>)</phrase>.
        <phrase diff="del" at="E047">
        For
        user-defined functions, the function signature can be obtained
        from the XQuery prolog where the function is declared.  For
        built-in functions, the signature is given in the
        <bibref ref="xpath-functions-30"/> document. For overloaded built-in functions,
        several signatures may exists, however, because they all
        correspond to sequences of atomic values, they all result in
        the same normalization.</phrase></p></smnorm><smtype><p>Different sets of static typing rules are used to type
        check function calls depending on which of the following
        categories
        <phrase diff="del" at="E048">the</phrase>
        <phrase diff="add" at="E048">they</phrase>
        belong to: overloaded internal functions,
        built-in functions with a specific static typing rule, and
        other built-in and user-defined functions.</p><p>The following two rules
        <phrase diff="del" at="E048">
        are common to all those categories,
        and are used to bootstrap type inference, by first looking-up
        the expanded QName for the function, then applying the
        appropriate set of static typing rules depending on the
        category in which the function is.
        </phrase>
        <phrase diff="add" at="E048">
        factor out the step
        (common to all those categories)
        of translating
        a type-inference judgment
        on syntactic objects (<emph>QName</emph> and <emph>Expr</emph><subscript>i</subscript>)
        into a type-inference judgment
        on semantic objects (<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> and <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>i</subscript>).
        </phrase>
        </p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>QName</emph>
                  <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
                    <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>() <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
                  </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
                    <emph>QName</emph>() <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
                  </expression></clause></multiclause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>QName</emph>
                  <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                    <emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
                  </expression></clause></multiclause><multiclause><clause><expression>
                    ...
                  </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                    <emph>Expr</emph><subscript>n</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>
                  </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
                    <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,...,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
                  </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
                    <emph>QName</emph> (<emph>Expr</emph><subscript>1</subscript>,...,<emph>Expr</emph><subscript>n</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
                  </expression></clause></multiclause></postjudge></infer></infergr><p>The following depends on the kind of function call.</p><olist><item><p>If the expanded QName for the function corresponds to
            one of the overloaded internal <emph>fs:</emph> functions
            listed in <specref ref="sec_operators"/>, the static
            typing rules in <specref ref="sec_operators"/> are
            applied.</p></item><item><p>If the expanded QName for the function corresponds to
            one of the built-in functions with a specialized static
            typing rule, listed in <specref ref="sec_special_functions"/>, the static typing rules in
            <specref ref="sec_special_functions"/> are applied.</p></item><item><p>Otherwise, the following general static typing
            rules are applied.</p></item></olist><p>
        <phrase diff="add" at="E048">
        Recall that <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_functy_env" class="env">funcType</a> contains
        at most one function signature
        for any given (function name, arity) pair.
        </phrase>
        The two following rules look up the function in the static
        environment and check that
        <phrase diff="del" at="E048">
        some signature for the function
        satisfies the following constraint: the type of each actual
        argument is a subtype of some type that
        </phrase>
        <phrase diff="add" at="E048">
        the type of each actual argument
        </phrase>
        can be promoted to the
        type of the corresponding function parameter.  In this case,
        the function call is well typed and the result type is the
        return type specified in the function's signature. </p><infergr><infer><prejudge><multiclause><clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_functy_env" class="env">funcType</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>,0) =
                    declare function <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>() as <a href="#doc-fs-Type"><emph>Type</emph></a>'
                  </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
                    <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>() <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>'
                  </expression></clause></multiclause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_functy_env" class="env">funcType</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>,n) =
                    declare function <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>', ..., <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>') as <a href="#doc-fs-Type"><emph>Type</emph></a>'
                  </expression></clause></multiclause><multiclause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>'</expression></clause></multiclause><multiclause><clause><expression>...</expression></clause></multiclause><multiclause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>'</expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
                    <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, ..., <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>'
                  </expression></clause></multiclause></postjudge></infer></infergr><p>The function body itself is not analyzed for each
        invocation: static typing of the function definition itself
        guarantees that the function body always returns a value of
        the declared return type.</p><p diff="del" at="E048">Notice that the static context contains at most one
        function declaration for each function. This is possible since
        the treatment of overloaded operators is done through a set of
        specific static typing rules which do not require access to
        the environment. See <specref ref="sec_operators"/>.</p></smtype><smnotation><p id="jd_function_with_types">The following auxiliary
        judgment</p><display>
         <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
           <a href="#jd_function_with_types" class="judgment"><term>function</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           <a href="#jd_function_with_types" class="judgment"><term>with types</term></a>
           <a href="#jd_function_with_types" class="judgment"><term>on values</term></a>
           <a href="#jd_function_with_types" class="judgment"><term>yields</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
          </expression></clause>
        </display><p>holds when applying the function with expanded QName
        <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> and no parameter yields the value <a href="#doc-fs-Value"><emph>Value</emph></a>.</p><display>
         <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
           <a href="#jd_function_with_types" class="judgment"><term>function</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           <a href="#jd_function_with_types" class="judgment"><term>with types</term></a> (<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,...,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>)
           <a href="#jd_function_with_types" class="judgment"><term>on values</term></a>
           (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>,...,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript>)
           <a href="#jd_function_with_types" class="judgment"><term>yields</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
          </expression></clause>
        </display><p>holds when applying the function with expanded QName
        <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>, and parameters of type (<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,...,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>)
        on the values (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>,...,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript>) yields the value
        <a href="#doc-fs-Value"><emph>Value</emph></a>.</p><p>That judgment is defined below for each kind of function
        (user-defined, built-in, external, and imported
        functions).</p></smnotation><smeval><p>The following rules apply to all the different kinds of
        functions using the previously defined judgment.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>QName</emph> <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression></clause></multiclause><multiclause><clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_functy_env" class="env">funcType</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><phrase diff="chg" at="E006">,0</phrase>) = <emph>FunctionSig</emph>
         </expression></clause></multiclause><multiclause><clause><expression>
          <emph>FunctionSig</emph>
          =
          declare function <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>() as <a href="#doc-fs-Type"><emph>Type</emph></a>
         </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
           <a href="#jd_function_with_types" class="judgment"><term>function</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           <a href="#jd_function_with_types" class="judgment"><term>with types</term></a>
           <a href="#jd_function_with_types" class="judgment"><term>on values</term></a>
           <a href="#jd_function_with_types" class="judgment"><term>yields</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
         </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_promotes_to" class="judgment"><term>against</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_promotes_to" class="judgment"><term>promotes to</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>'</expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a> </environment><expression>
          <emph>QName</emph>() <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>'
         </expression></clause></multiclause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
          <emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>
         </expression></clause></multiclause><multiclause><clause><expression>...</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
          <emph>Expr</emph><subscript>n</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript>
         </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>QName</emph> <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression></clause></multiclause><multiclause><clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_functy_env" class="env">funcType</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><phrase diff="chg" at="E006">,n</phrase>) = <emph>FunctionSig</emph>
         </expression></clause></multiclause><multiclause><clause><expression>
          <emph>FunctionSig</emph>
          =
          declare function <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, ..., <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>) as <a href="#doc-fs-Type"><emph>Type</emph></a>
         </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
          <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_promotes_to" class="judgment"><term>against</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_promotes_to" class="judgment"><term>promotes to</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>'
         </expression></clause></multiclause><multiclause><clause><expression>...</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
          <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript> <a href="#jd_promotes_to" class="judgment"><term>against</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript> <a href="#jd_promotes_to" class="judgment"><term>promotes to</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript>'
         </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
           <a href="#jd_function_with_types" class="judgment"><term>function</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           <a href="#jd_function_with_types" class="judgment"><term>with types</term></a> (<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,...,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>)
           <a href="#jd_function_with_types" class="judgment"><term>on values</term></a>
           (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>',...,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript>')
           <a href="#jd_function_with_types" class="judgment"><term>yields</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
         </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_promotes_to" class="judgment"><term>against</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_promotes_to" class="judgment"><term>promotes to</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>'</expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a> </environment><expression>
          <emph>QName</emph> ( <emph>Expr</emph><subscript>1</subscript>, ...,  <emph>Expr</emph><subscript>n</subscript> ) <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>'
         </expression></clause></multiclause></postjudge></infer></infergr><p>First the function name is expanded, and the expanded name is
    used to retrieve the function signature from the static
    environment. Then, the rule evaluates each function argument
    expression, and the resulting values are promoted according to the
    expected type for the function. The result of evaluating the
    function is obtained through the auxiliary judgment previously
    defined, and the resulting value is promoted according to the
    expected return type.</p><p>In case the function is a user defined function in a main
    module, the expression body is retrieved from the dynamic
    environment and used to compute the value of the function. The
    rule extends <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a> by binding each formal variable to its
    corresponding value, and evaluates the body of the function in the
    new environment. The resulting value is the value of the function
    call.</p><p>The notation <emph>AnyURI</emph> <a href="#jd_module_dynEnv" class="judgment"><term>=&gt;</term><subscript>module_dynEnv</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript> is used
    to access a module context and is defined in <specref ref="id-module-declaration"/>.</p><infergr><infer><prejudge><multiclause><clause><expression>
          <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_func_env" class="env">funcDefn</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><phrase diff="chg" at="E006">,0</phrase>)
          =
          (<emph>Expr</emph>)
         </expression></clause></multiclause><multiclause><clause><expression>#MAIN <a href="#jd_module_dynEnv" class="judgment"><term>=&gt;</term><subscript>module_dynEnv</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><environment>
           <phrase diff="del" at="E049"><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript>.<a href="#xq_val_env" class="env">varValue</a></phrase>
           <phrase diff="add" at="E049"><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript></phrase>
         </environment><expression><emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a> </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
           <a href="#jd_function_with_types" class="judgment"><term>function</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           <a href="#jd_function_with_types" class="judgment"><term>with types</term></a>
           <a href="#jd_function_with_types" class="judgment"><term>on values</term></a>
           <a href="#jd_function_with_types" class="judgment"><term>yields</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
         </expression></clause></multiclause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><expression>
          <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_func_env" class="env">funcDefn</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><phrase diff="chg" at="E006">,n</phrase>)
          =
          (<emph>Expr</emph>, <emph>Variable</emph><subscript>1</subscript>, ... , <emph>Variable</emph><subscript>n</subscript>)
         </expression></clause></multiclause><multiclause><clause><expression>#MAIN <a href="#jd_module_dynEnv" class="judgment"><term>=&gt;</term><subscript>module_dynEnv</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><environment>
          <update><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript>.<a href="#xq_val_env" class="env">varValue</a></environment><expression>
            <emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>;
            ...;
            <emph>Variable</emph><subscript>n</subscript> =&gt; <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript></expression></update>
         </environment><expression><emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a> </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
           <a href="#jd_function_with_types" class="judgment"><term>function</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           <a href="#jd_function_with_types" class="judgment"><term>with types</term></a> (<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,...,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>)
           <a href="#jd_function_with_types" class="judgment"><term>on values</term></a>
           (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>,...,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript>)
           <a href="#jd_function_with_types" class="judgment"><term>yields</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
         </expression></clause></multiclause></postjudge></infer></infergr><p>Note that the function body is evaluated in the dynamic
    environment containing the main module declarations.</p><p>The rule for evaluating
    <phrase diff="del" at="E049">an</phrase>
    <phrase diff="add" at="E049">a</phrase>
    function imported from a module is
    similar to that for evaluating a user-defined function in a main
    module, except that the function call is evaluated in the dynamic
    context of the module in which it is declared, and that the
    appropriate additional type matching must be performed.</p><infergr><infer><prejudge><multiclause><clause><expression>
          <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_func_env" class="env">funcDefn</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><phrase diff="chg" at="E006">,0</phrase>)
          = <code>#IMPORTED</code>(<emph>AnyURI</emph>)
         </expression></clause></multiclause><multiclause><clause><expression><emph>AnyURI</emph> <a href="#jd_module_statEnv" class="judgment"><term>=&gt;</term><subscript>module_statEnv</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><expression><emph>AnyURI</emph> <a href="#jd_module_dynEnv" class="judgment"><term>=&gt;</term><subscript>module_dynEnv</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript>.<a href="#xq_functy_env" class="env">funcType</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><phrase diff="chg" at="E006">,0</phrase>) = <emph>FunctionSig</emph>'
         </expression></clause></multiclause><multiclause><clause><expression>
          <emph>FunctionSig</emph>'
          =
          declare function <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>() as <a href="#doc-fs-Type"><emph>Type</emph></a>'
         </expression></clause></multiclause><multiclause><clause><expression>
          <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript>.<a href="#xq_func_env" class="env">funcDefn</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><phrase diff="chg" at="E006">,0</phrase>)
          =
          (<emph>Expr</emph>)
         </expression></clause></multiclause><multiclause><clause><environment>
           <phrase diff="del" at="E049"><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript>.<a href="#xq_val_env" class="env">varValue</a></phrase>
           <phrase diff="add" at="E049"><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript></phrase>
         </environment><expression><emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a> </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
          <a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>'
         </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
           <a href="#jd_function_with_types" class="judgment"><term>function</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           <a href="#jd_function_with_types" class="judgment"><term>with types</term></a>
           <a href="#jd_function_with_types" class="judgment"><term>on values</term></a>
           <a href="#jd_function_with_types" class="judgment"><term>yields</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
         </expression></clause></multiclause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><expression>
          <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_func_env" class="env">funcDefn</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><phrase diff="chg" at="E006">,n</phrase>)
          = <code>#IMPORTED</code>(<emph>AnyURI</emph>)
         </expression></clause></multiclause><multiclause><clause><expression><emph>AnyURI</emph> <a href="#jd_module_statEnv" class="judgment"><term>=&gt;</term><subscript>module_statEnv</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><expression><emph>AnyURI</emph> <a href="#jd_module_dynEnv" class="judgment"><term>=&gt;</term><subscript>module_dynEnv</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript>.<a href="#xq_functy_env" class="env">funcType</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><phrase diff="chg" at="E006">,n</phrase>) = <emph>FunctionSig</emph>'
         </expression></clause></multiclause><multiclause><clause><expression>
          <emph>FunctionSig</emph>'
          =
          declare function <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>', ..., <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>') as <a href="#doc-fs-Type"><emph>Type</emph></a>'
         </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
          <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>'
         </expression></clause></multiclause><multiclause><clause><expression>...</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
          <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>'
         </expression></clause></multiclause><multiclause><clause><expression>
          <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript>.<a href="#xq_func_env" class="env">funcDefn</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><phrase diff="chg" at="E006">,n</phrase>)
          =
          (<emph>Expr</emph>, <emph>Variable</emph><subscript>1</subscript>, ... , <emph>Variable</emph><subscript>n</subscript>)
         </expression></clause></multiclause><multiclause><clause><environment>
          <update><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript>.<a href="#xq_val_env" class="env">varValue</a></environment><expression>
            <emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>;
            ...;
            <emph>Variable</emph><subscript>n</subscript> =&gt; <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript></expression></update>
         </environment><expression><emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a> </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
          <a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>'
         </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
           <a href="#jd_function_with_types" class="judgment"><term>function</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           <a href="#jd_function_with_types" class="judgment"><term>with types</term></a> (<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,...,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>)
           <a href="#jd_function_with_types" class="judgment"><term>on values</term></a>
           (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>,...,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript>)
           <a href="#jd_function_with_types" class="judgment"><term>yields</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
         </expression></clause></multiclause></postjudge></infer></infergr><p>If the function is a built-in function (resp. special formal
    semantics function), the value returned by the function is the one
    specified in <bibref ref="xpath-functions-30"/> (resp.
    <phrase diff="del" at="E049"><specref ref="sec_special_functions"/></phrase>
    <phrase diff="add" at="E049"><specref ref="sec_special_fs_functions"/></phrase>
    <phrase diff="add" at="E049">or <specref ref="sec_operators"/></phrase>).</p><infergr><infer><prejudge><multiclause><clause><expression>
          <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_func_env" class="env">funcDefn</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><phrase diff="chg" at="E006">,0</phrase>)
          = <code>#BUILT-IN</code>
         </expression></clause></multiclause><multiclause><clause><expression>
           The built-in function <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> (See <bibref ref="xpath-functions-30"/> or
           <phrase diff="del" at="E049"><specref ref="sec_special_functions"/></phrase>
           <phrase diff="add" at="E049"><specref ref="sec_special_fs_functions"/></phrase>
           <phrase diff="add" at="E049">or <specref ref="sec_operators"/></phrase>)
           yields the value
           <a href="#doc-fs-Value"><emph>Value</emph></a>
          </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
           <a href="#jd_function_with_types" class="judgment"><term>function</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           <a href="#jd_function_with_types" class="judgment"><term>with types</term></a>
           <a href="#jd_function_with_types" class="judgment"><term>on values</term></a>
           <a href="#jd_function_with_types" class="judgment"><term>yields</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
         </expression></clause></multiclause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><expression>
          <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_func_env" class="env">funcDefn</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><phrase diff="chg" at="E006">,n</phrase>)
          = <code>#BUILT-IN</code>
         </expression></clause></multiclause><multiclause><clause><expression>
           The built-in function <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> (See <bibref ref="xpath-functions-30"/> or
           <phrase diff="del" at="E049"><specref ref="sec_special_functions"/></phrase>
           <phrase diff="add" at="E049"><specref ref="sec_special_fs_functions"/></phrase>
           <phrase diff="add" at="E049">or <specref ref="sec_operators"/></phrase>)
           applied to values
           (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>,...,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript>) yields the value <a href="#doc-fs-Value"><emph>Value</emph></a>
          </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
           <a href="#jd_function_with_types" class="judgment"><term>function</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           <a href="#jd_function_with_types" class="judgment"><term>with types</term></a> (<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,...,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>)
           <a href="#jd_function_with_types" class="judgment"><term>on values</term></a>
           (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>,...,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript>)
           <a href="#jd_function_with_types" class="judgment"><term>yields</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
         </expression></clause></multiclause></postjudge></infer></infergr><p>If the function is an external function, the value returned by
    the function is implementation-defined.</p><infergr><infer><prejudge><multiclause><clause><expression>
          <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_func_env" class="env">funcDefn</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><phrase diff="chg" at="E006">,0</phrase>) = <code>#EXTERNAL</code>
         </expression></clause></multiclause><multiclause><clause><expression>
           The external function <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> yields the value
           <a href="#doc-fs-Value"><emph>Value</emph></a>
          </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
           <a href="#jd_function_with_types" class="judgment"><term>function</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           <a href="#jd_function_with_types" class="judgment"><term>with types</term></a>
           <a href="#jd_function_with_types" class="judgment"><term>on values</term></a>
           <a href="#jd_function_with_types" class="judgment"><term>yields</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
         </expression></clause></multiclause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><expression>
          <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_func_env" class="env">funcDefn</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><phrase diff="chg" at="E006">,n</phrase>)
          = <code>#EXTERNAL</code>
         </expression></clause></multiclause><multiclause><clause><expression>
           The external function <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> applied to values
           (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>,...,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript>) yields the value <a href="#doc-fs-Value"><emph>Value</emph></a>
          </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
           <a href="#jd_function_with_types" class="judgment"><term>function</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           <a href="#jd_function_with_types" class="judgment"><term>with types</term></a> (<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,...,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>)
           <a href="#jd_function_with_types" class="judgment"><term>on values</term></a>
           (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>,...,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript>)
           <a href="#jd_function_with_types" class="judgment"><term>yields</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
         </expression></clause></multiclause></postjudge></infer></infergr></smeval></div3></div2><div2 id="id-path-expressions"><head>Path Expressions</head><smintro><p>Path expressions are used to locate nodes within a
      tree. There are two kinds of path expressions, absolute path
      expressions and relative path expressions. An absolute path
      expression is a rooted relative path expression. A relative path
      expression is composed of a sequence of steps.</p><scrap headstyle="show"><head>Path Expressions</head><prodrecap id="PathExpr" ref="PathExpr" orig="xquery"/><prodrecap id="RelativePathExpr" ref="RelativePathExpr" orig="xquery"/></scrap></smintro><smcore><p>PathExpr and RelativePathExpr are fully normalized, therefore
      they have no corresponding productions in the Core. The grammar
      for path expressions in the Core starts with the StepExpr
      production.</p></smcore><smnorm><p>Absolute path expressions are path expressions starting with
      the <code>/</code> or <code>//</code> symbols, indicating that
      the expression must be applied on the root node in the current
      context.  The root node in the current context is the greatest
      ancestor of the context node. The following two rules normalize
      absolute path expressions to relative ones. They use the
      <code>fn:root</code> function, which returns the greatest ancestor of its
      argument node. The treat expressions guarantee that the value
      bound to the context variable <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>dot</code></a> is a document node.</p><mapping><xquery><expression><map>/</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression></xquery><core><expression><map>(<code>fn:root</code>(self::node()) treat as document-node())</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression></core></mapping><mapping><xquery><expression><map>/ <emph>RelativePathExpr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression></xquery><core><expression><map>((<code>fn:root</code>(self::node())) treat as document-node()) /
         <emph>RelativePathExpr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression></core></mapping><mapping><xquery><expression><map>// <emph>RelativePathExpr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression></xquery><core><expression><map>((<code>fn:root</code>(self::node())) treat as document-node()) /
         <code>descendant-or-self::node()</code> /
         <emph>RelativePathExpr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression></core></mapping><mapping><xquery><expression><map><emph>RelativePathExpr</emph> // <emph>StepExpr</emph> </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression></xquery><core><expression><map><emph>RelativePathExpr</emph> / descendant-or-self::node() / <emph>StepExpr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
          </expression></core></mapping><p>A composite relative path expression (using <code>/</code>)
      is normalized into a <code>for</code> expression by
      concatenating the sequences obtained by mapping each node of the
      left-hand side in document order to the sequence it generates on
      the right-hand side.  The call to the <a href="#sec_distinct_docorder"><emph>fs:</emph><code>distinct-doc-order</code></a>
      function ensures that the result is in document order without
      duplicates.  The dynamic context is defined by binding the
      <code>$</code><emph>fs:</emph><code>dot</code>,
      <code>$</code><emph>fs:</emph><code>sequence</code>,
      <code>$</code><emph>fs:</emph><code>position</code> and
      <code>$</code><emph>fs:</emph><code>last</code> variables.</p><p>Note that sorting by document order enforces the restriction
      that input and output sequences contains only nodes, and that
      the last step in a path expression may actually return atomic
      values.</p><mapping><xquery><expression><map><emph>RelativePathExpr</emph> / <emph>StepExpr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression></xquery><core><expression>
         <table summary=""><tbody><tr><td rowspan="1" colspan="1"><a href="#sec_apply_ordering_mode"><emph>fs:</emph><code>apply-ordering-mode</code></a> (</td></tr><tr><td rowspan="1" colspan="1"><a href="#sec_distinct_docorder_or_atomic_sequence"><emph>fs:</emph><code>distinct-doc-order-or-atomic-sequence</code></a> (</td></tr><tr><td diff="chg" at="E021" rowspan="1" colspan="1">  let <code>$</code><emph>fs:</emph><code>sequence</code> := <a href="#sec_node_sequence"><emph>fs:</emph><code>node-sequence</code></a>( <map><emph>RelativePathExpr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> ) return</td></tr><tr><td rowspan="1" colspan="1">  let <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>last</code></a> := fn:count(<code>$</code><emph>fs:</emph><code>sequence</code>)   return</td></tr><tr><td rowspan="1" colspan="1">  for <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>dot</code></a> at <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>position</code></a> in <code>$</code><emph>fs:</emph><code>sequence</code> return</td></tr><tr><td rowspan="1" colspan="1">    <map><emph>StepExpr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></td></tr><tr><td rowspan="1" colspan="1">))</td></tr></tbody></table>
        </expression></core></mapping></smnorm><div3 id="id-axis-steps"><head>Steps</head><p>Note that this section uses some auxiliary judgments which
      are defined in <specref ref="sec_auxiliary_xpath"/>.</p><smintro><scrap headstyle="show"><head>Steps</head><prodrecap id="StepExpr" ref="StepExpr" orig="xquery"/><prodrecap id="AxisStep" ref="AxisStep" orig="xquery"/><prodrecap id="ForwardStep" ref="ForwardStep" orig="xquery"/><prodrecap id="ReverseStep" ref="ReverseStep" orig="xquery"/><prodrecap id="PredicateList" ref="PredicateList" orig="xquery"/></scrap></smintro><smcore><p>The Core grammar productions for XPath steps are:</p><scrap headstyle="show"><head>Steps</head><prodrecap id="core-StepExpr" ref="StepExpr" orig="core"/><prodrecap id="core-AxisStep" ref="AxisStep" orig="core"/><prodrecap id="core-ForwardStep" ref="ForwardStep" orig="core"/><prodrecap id="core-ReverseStep" ref="ReverseStep" orig="core"/></scrap></smcore><smnote><p>Step expressions can be followed by
        predicates. Normalization of predicates uses the following
        auxiliary mapping rule: <map/><a href="#jd_map_predicates" class="judgment"><subscript>Predicates</subscript></a>, which
        is specified in <specref ref="id-predicates"/>. Normalization
        for step expressions also uses the following auxiliary mapping
        rule: <map/><a href="#jd_map_axis" class="judgment"><subscript>Axis</subscript></a>, which is specified in <specref ref="sec_axes"/>.</p></smnote><smnorm><p>Normalization of predicates need to distinguish between
        forward steps, reverse steps, and primary expressions.</p><p>As explained in the [XPath/XQuery] document, applying a step in
        XPath changes the focus (or context). The change of focus is
        made explicit by the normalization rule below, which binds the
        variable <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>dot</code></a> to the node currently being processed, and
        the variable <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>position</code></a> to the position (i.e., the position
        within the input sequence) of that node.</p><p>There are two sets of normalization rules for Predicates.
        The first set of rules apply when the predicate is a numeric
        literal or the expression <code>last()</code>.  The second set
        of rules apply to all predicate expressions other than numeric
        literals and the expression <code>last()</code>.  In the first
        case, the normalization rules provides a more precise static
        type than if the general rules were applied.</p><p>When the predicate expression is a numeric literal or the
        <code>fn:last</code> function, the following normalization rules
        apply.</p><mapping><xquery><expression><map><emph>ForwardStep</emph> <emph>PredicateList</emph> [
            <emph>NumericLiteral</emph> ]</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression></xquery><core><expression>
              <table summary=""><tbody><tr><td rowspan="1" colspan="1">let <code>$</code><emph>fs:</emph><code>sequence</code> :=
                <a href="#sec_apply_ordering_mode"><emph>fs:</emph><code>apply-ordering-mode</code></a>(<a href="#sec_distinct_docorder"><emph>fs:</emph><code>distinct-doc-order</code></a>( <map><emph>ForwardStep</emph>
                <emph>PredicateList</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> )) return</td></tr><tr><td rowspan="1" colspan="1"><phrase diff="chg" at="E024"><a href="#sec_item_at"><emph>fs:</emph><code>item-at</code></a></phrase>(<code>$</code><emph>fs:</emph><code>sequence</code>,<emph>NumericLiteral</emph><phrase diff="del" at="E024">,1</phrase>)</td></tr></tbody></table>
            </expression></core></mapping><mapping><xquery><expression><map><emph>ForwardStep</emph> <emph>PredicateList</emph> [
            <code>fn:last</code>() ]</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression></xquery><core><expression>
              <table summary=""><tbody><tr><td rowspan="1" colspan="1">let <code>$</code><emph>fs:</emph><code>sequence</code> :=
                <a href="#sec_apply_ordering_mode"><emph>fs:</emph><code>apply-ordering-mode</code></a>(<a href="#sec_distinct_docorder"><emph>fs:</emph><code>distinct-doc-order</code></a>( <map><emph>ForwardStep</emph>
                <emph>PredicateList</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> )) return</td></tr><tr><td rowspan="1" colspan="1">let <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>last</code></a> := <code>fn:count</code>(<code>$</code><emph>fs:</emph><code>sequence</code>) return</td></tr><tr><td rowspan="1" colspan="1"><phrase diff="chg" at="E024"><a href="#sec_item_at"><emph>fs:</emph><code>item-at</code></a></phrase>(<code>$</code><emph>fs:</emph><code>sequence</code>,<a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>last</code></a><phrase diff="del" at="E024">,1</phrase>)</td></tr></tbody></table>
            </expression></core></mapping><p>When predicates are applied on a reverse step, the position
        variable is bound in reverse document order. </p><mapping><xquery><expression><map><emph>ReverseStep</emph> <emph>PredicateList</emph> [
            <emph>NumericLiteral</emph> ]</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression></xquery><core><expression>
             <table summary=""><tbody><tr><td rowspan="1" colspan="1">let <code>$</code><emph>fs:</emph><code>sequence</code> :=
                <a href="#sec_apply_ordering_mode"><emph>fs:</emph><code>apply-ordering-mode</code></a>(<a href="#sec_distinct_docorder"><emph>fs:</emph><code>distinct-doc-order</code></a>( <map><emph>ReverseStep</emph> <emph>PredicateList</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> )) return</td></tr><tr><td rowspan="1" colspan="1">let <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>last</code></a> := fn:count(<code>$</code><emph>fs:</emph><code>sequence</code>) return</td></tr><tr><td rowspan="1" colspan="1">let <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>position</code></a> := <emph>fs:</emph><code>plus</code>(1, <emph>fs:</emph><code>minus</code>(<a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>last</code></a>,<emph>NumericLiteral</emph>)) return</td></tr><tr><td rowspan="1" colspan="1">  <phrase diff="chg" at="E024"><a href="#sec_item_at"><emph>fs:</emph><code>item-at</code></a></phrase>(<code>$</code><emph>fs:</emph><code>sequence</code>,<a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>position</code></a><phrase diff="del" at="E024">,1</phrase>)</td></tr></tbody></table>
           </expression></core></mapping><p>When the step is a reverse axis, then the last item in the
        context sequence is the first in document order.</p><mapping><xquery><expression><map><emph>ReverseStep</emph> <emph>PredicateList</emph> [
            <code>fn:last</code>() ]</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression></xquery><core><expression>
             <table summary=""><tbody><tr><td rowspan="1" colspan="1">let <code>$</code><emph>fs:</emph><code>sequence</code> :=
                <a href="#sec_apply_ordering_mode"><emph>fs:</emph><code>apply-ordering-mode</code></a>(<a href="#sec_distinct_docorder"><emph>fs:</emph><code>distinct-doc-order</code></a>( <map><emph>ReverseStep</emph> <emph>PredicateList</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> )) return</td></tr><tr><td rowspan="1" colspan="1">  <phrase diff="chg" at="E024"><a href="#sec_item_at"><emph>fs:</emph><code>item-at</code></a></phrase>(<code>$</code><emph>fs:</emph><code>sequence</code>,1<phrase diff="del" at="E024">,1</phrase>)</td></tr></tbody></table>
           </expression></core></mapping><p>The normalization rules above all use the function
        <phrase diff="chg" at="E024"><a href="#sec_item_at"><emph>fs:</emph><code>item-at</code></a></phrase> to select a particular item.  The static
        typing rules for this function are defined in <phrase diff="chg" at="E024"><specref ref="sec_item_at"/></phrase>.</p><p>When predicates are applied on a forward step, the input
        sequence is first sorted in document order and duplicates are
        removed. The context is changed by binding the <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>dot</code></a>
        variable to each node in document order.</p><mapping><xquery><expression><map><emph>ForwardStep</emph> <emph>PredicateList</emph> [
            <emph>Expr</emph> ]</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression></xquery><core><expression>
              <table summary=""><tbody><tr><td rowspan="1" colspan="1">let <code>$</code><emph>fs:</emph><code>sequence</code> :=
                <a href="#sec_apply_ordering_mode"><emph>fs:</emph><code>apply-ordering-mode</code></a>(<a href="#sec_distinct_docorder"><emph>fs:</emph><code>distinct-doc-order</code></a>( <map><emph>ForwardStep</emph>
                <emph>PredicateList</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> )) return</td></tr><tr><td rowspan="1" colspan="1">let <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>last</code></a> := fn:count(<code>$</code><emph>fs:</emph><code>sequence</code>) return</td></tr><tr><td rowspan="1" colspan="1">for <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>dot</code></a> at <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>position</code></a> in <code>$</code><emph>fs:</emph><code>sequence</code> return</td></tr><tr><td rowspan="1" colspan="1">   if (<map><emph>Expr</emph></map><a href="#jd_map_predicates" class="judgment"><subscript>Predicates</subscript></a>) then <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>dot</code></a> else ()</td></tr></tbody></table>
            </expression></core></mapping><p>When predicates are applied on a reverse step, the input
        sequence is first sorted in document order and duplicates are
        removed. The context is changed by binding the <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>dot</code></a>
        variable to each node in document order. </p><mapping><xquery><expression><map><emph>ReverseStep</emph> <emph>PredicateList</emph> [
            <emph>Expr</emph> ]</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression></xquery><core><expression>
             <table summary=""><tbody><tr><td rowspan="1" colspan="1">let <code>$</code><emph>fs:</emph><code>sequence</code> := <a href="#sec_apply_ordering_mode"><emph>fs:</emph><code>apply-ordering-mode</code></a>(<a href="#sec_distinct_docorder"><emph>fs:</emph><code>distinct-doc-order</code></a>(
               <map><emph>ReverseStep</emph> <emph>PredicateList</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> )) return</td></tr><tr><td rowspan="1" colspan="1">let <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>last</code></a> := fn:count(<code>$</code><emph>fs:</emph><code>sequence</code>) return</td></tr><tr><td rowspan="1" colspan="1">for <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>dot</code></a> at $<emph>fs:</emph>new in <code>$</code><emph>fs:</emph><code>sequence</code> return</td></tr><tr><td rowspan="1" colspan="1">let <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>position</code></a> := <emph>fs:</emph><code>plus</code>(1,<emph>fs:</emph><code>minus</code>(<a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>last</code></a>,$<emph>fs:</emph>new)) return </td></tr><tr><td rowspan="1" colspan="1">  if (<map><emph>Expr</emph></map><a href="#jd_map_predicates" class="judgment"><subscript>Predicates</subscript></a>)
                            then <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>dot</code></a> else ()</td></tr></tbody></table>
           </expression></core></mapping><p>Finally, a stand-alone forward or reverse step is
        normalized by the auxiliary normalization rule for
        <emph>Axis</emph>.</p><mapping><xquery><expression><map><emph>ForwardStep</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression></xquery><core><expression><a href="#sec_apply_ordering_mode"><emph>fs:</emph><code>apply-ordering-mode</code></a>(<map><emph>ForwardStep</emph></map><a href="#jd_map_axis" class="judgment"><subscript>Axis</subscript></a>)</expression></core></mapping><mapping><xquery><expression><map><emph>ReverseStep</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression></xquery><core><expression><a href="#sec_apply_ordering_mode"><emph>fs:</emph><code>apply-ordering-mode</code></a>(<map><emph>ReverseStep</emph></map><a href="#jd_map_axis" class="judgment"><subscript>Axis</subscript></a>)</expression></core></mapping></smnorm><smtype><p>The static semantics of an <emph>Axis</emph> <emph>NodeTest</emph> pair is
        obtained by retrieving the type of the context node, and
        applying the two filters (the <emph>Axis</emph>, and then the
        <emph>NodeTest</emph> with a <emph>PrincipalNodeKind</emph>) on the
        result.</p><infergr><infer><prejudge><multiclause><clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a>((<code>FS-URI</code>,<quote><code>dot</code></quote>)) = <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <map>node()</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
              <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_axis_type" class="judgment"><term>:</term></a>
              <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
             </expression></clause></multiclause><multiclause><clause><expression><emph>Axis</emph> <a href="#jd_principal" class="judgment"><term>has principal</term></a> <emph>PrincipalNodeKind</emph></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
              <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test_type" class="judgment"><term>with</term></a>
              <emph>PrincipalNodeKind</emph> <a href="#jd_test_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
              <a href="#jd_test_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript>
             </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <emph>Axis</emph> <emph>NodeTest</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript>
            </expression></clause></postjudge></infer></infergr><smnote><p>Note that the second judgment in the rule requires that
          the context item be a node, guaranteeing that a type error
          is raised when the context item is an atomic value.</p></smnote></smtype><smeval><p>The dynamic semantics of an <emph>Axis</emph> <emph>NodeTest</emph> pair is
        obtained by retrieving the context node, and applying the two
        filters (<emph>Axis</emph>, then <emph>NodeTest</emph>) on the result. The
        application of each filter is expressed through several
        auxiliary judgments (<a href="#jd_axis" class="judgment"><term>of</term></a>, <a href="#jd_principal" class="judgment"><term>has principal</term></a>, and
        <a href="#jd_test" class="judgment"><term>test</term></a>), as follows.</p><infergr><infer><prejudge><multiclause><clause><expression><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a>(
             <phrase diff="del" at="E050"><a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>dot</code></a></phrase>
             <phrase diff="add" at="E050">(<code>FS-URI</code>,<quote><code>dot</code></quote>)</phrase>
             ) = <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <map>node()</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
              <a href="#jd_axis" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis" class="judgment"><term>of</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>
              <a href="#jd_axis" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>
             </expression></clause></multiclause><multiclause><clause><expression><emph>Axis</emph> <a href="#jd_principal" class="judgment"><term>has principal</term></a> <emph>PrincipalNodeKind</emph></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
              <a href="#jd_test" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test" class="judgment"><term>with</term></a> <emph>PrincipalNodeKind</emph>
              <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> <a href="#jd_test" class="judgment"><term>=&gt;</term></a>
              <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>3</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
             <emph>Axis</emph> <emph>NodeTest</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#sec_distinct_docorder"><emph>fs:</emph><code>distinct-doc-order</code></a>(<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>3</subscript>)
            </expression></clause></postjudge></infer></infergr><smnote><p>Note that the second judgment in the rule guarantees that
          the context item is bound to a node.</p></smnote></smeval><div4 id="sec_axes"><head>Axes</head><smintro><p>The XQuery grammar for forward and reverse axis is as
          follows.</p><scrap headstyle="show"><head>Axes</head><prodrecap id="ForwardAxis" ref="ForwardAxis" orig="xquery"/><prodrecap id="ReverseAxis" ref="ReverseAxis" orig="xquery"/></scrap><p>In the case of XPath, forward axis also contain the
          <code>namespace::</code> axis.</p><scrap headstyle="show"><head>Axes</head><prodrecap ref="ForwardAxis" orig="xpath" test="XPath"/></scrap></smintro><smcore><p>The Core grammar productions for XPath axis are:</p><scrap headstyle="show"><head>Axes</head><prodrecap id="core-ForwardAxis" ref="ForwardAxis" orig="core"/><prodrecap id="core-ReverseAxis" ref="ReverseAxis" orig="core"/></scrap></smcore><smnotation><p>We introduce the following auxiliary grammar production to
        describe all axis.</p><scrap headstyle="show"><head/><prodrecap id="Axis" ref="Axis" orig="formal"/></scrap></smnotation><smnotation><p id="jd_map_axis">The normalization of axes uses the
          following auxiliary mapping rule:
          <map/><a href="#jd_map_axis" class="judgment"><subscript>Axis</subscript></a>.</p></smnotation><smnorm><p>The normalization for all axes is specified as
          follows.</p><p>The semantics of the following(-sibling) and
          preceding(-sibling) axes are expressed by mapping them to
          Core expressions. All other axes are part of the Core and
          therefore are left unchanged through normalization.</p><mapping><xquery><expression><map><code>following-sibling::</code>
              <emph>NodeTest</emph></map><a href="#jd_map_axis" class="judgment"><subscript>Axis</subscript></a></expression></xquery><core><expression><map>let $e := . return $e/parent::node()/child:: <emph>NodeTest</emph> [.&gt;&gt;$e]</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression></core></mapping><mapping><xquery><expression><map><code>following::</code>
            <emph>NodeTest</emph></map><a href="#jd_map_axis" class="judgment"><subscript>Axis</subscript></a></expression></xquery><core><expression><map><code>ancestor-or-self::node()/following-sibling::node()/descendant-or-self::</code><emph>NodeTest</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression></core></mapping><p>All other forward axes are part of the Core [XPath/XQuery]
          and handled by the normalization rules below:</p><mapping><xquery><expression><map><code>child::</code> <emph>NodeTest</emph></map><a href="#jd_map_axis" class="judgment"><subscript>Axis</subscript></a></expression></xquery><core><expression><code>child::</code> <emph>NodeTest</emph></expression></core></mapping><mapping><xquery><expression><map><code>attribute::</code> <emph>NodeTest</emph></map><a href="#jd_map_axis" class="judgment"><subscript>Axis</subscript></a></expression></xquery><core><expression><code>attribute::</code> <emph>NodeTest</emph></expression></core></mapping><mapping><xquery><expression><map><code>self::</code> <emph>NodeTest</emph></map><a href="#jd_map_axis" class="judgment"><subscript>Axis</subscript></a></expression></xquery><core><expression><code>self::</code> <emph>NodeTest</emph></expression></core></mapping><mapping><xquery><expression><map><code>descendant::</code> <emph>NodeTest</emph></map><a href="#jd_map_axis" class="judgment"><subscript>Axis</subscript></a></expression></xquery><core><expression><code>descendant::</code> <emph>NodeTest</emph></expression></core></mapping><mapping><xquery><expression><map><code>descendant-or-self::</code> <emph>NodeTest</emph></map><a href="#jd_map_axis" class="judgment"><subscript>Axis</subscript></a></expression></xquery><core><expression><code>descendant-or-self::</code> <emph>NodeTest</emph></expression></core></mapping><mapping><xquery><expression><map><code>namespace::</code> <emph>NodeTest</emph></map><a href="#jd_map_axis" class="judgment"><subscript>Axis</subscript></a></expression></xquery><core><expression><code>namespace::</code> <emph>NodeTest</emph></expression></core></mapping><p>Reverse axes:</p><mapping><xquery><expression><map><code>preceding-sibling::</code> <emph>NodeTest</emph></map><a href="#jd_map_axis" class="judgment"><subscript>Axis</subscript></a></expression></xquery><core><expression><map>let $e := . return $e/parent::node()/child:: <emph>NodeTest</emph> [.&lt;&lt;$e]</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression></core></mapping><mapping><xquery><expression><map><code>preceding::</code> <emph>NodeTest</emph></map><a href="#jd_map_axis" class="judgment"><subscript>Axis</subscript></a></expression></xquery><core><expression><map><code>ancestor-or-self::node()/preceding-sibling::node()/descendant-or-self::</code><emph>NodeTest</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression></core></mapping><p>All other reverse axes are part of the Core [XPath/XQuery]
          and handled by the normalization rules below:</p><mapping><xquery><expression><map><code>parent::</code> <emph>NodeTest</emph></map><a href="#jd_map_axis" class="judgment"><subscript>Axis</subscript></a></expression></xquery><core><expression><code>parent::</code> <emph>NodeTest</emph></expression></core></mapping><mapping><xquery><expression><map><code>ancestor::</code> <emph>NodeTest</emph></map><a href="#jd_map_axis" class="judgment"><subscript>Axis</subscript></a></expression></xquery><core><expression><code>ancestor::</code> <emph>NodeTest</emph></expression></core></mapping><mapping><xquery><expression><map><code>ancestor-or-self::</code> <emph>NodeTest</emph></map><a href="#jd_map_axis" class="judgment"><subscript>Axis</subscript></a></expression></xquery><core><expression><code>ancestor-or-self::</code> <emph>NodeTest</emph></expression></core></mapping></smnorm></div4><div4 id="node-tests"><head>Node Tests</head><smintro><p>A node test is a condition applied on the nodes selected
          by an axis step. Node tests are described by the following
          grammar productions.</p><scrap headstyle="show"><head>Node Tests</head><prodrecap id="NodeTest" ref="NodeTest" orig="xquery"/><prodrecap id="NameTest" ref="NameTest" orig="xquery"/><prodrecap id="Wildcard" ref="Wildcard" orig="xquery"/></scrap></smintro><smcore><p>The Core grammar productions for node tests are:</p><scrap headstyle="show"><head>Node Tests</head><prodrecap id="core-NodeTest" ref="NodeTest" orig="core"/><prodrecap id="core-NameTest" ref="NameTest" orig="core"/><prodrecap id="core-Wildcard" ref="Wildcard" orig="core"/></scrap></smcore><smnotation><p>For convenience, we will use the grammar non-terminals
          <emph>Prefix</emph>, and <emph>LocalPart</emph>, both of which are
          <emph>NCName</emph>s, in some of the inference rules. They are
          defined by the following grammar productions.</p><scrap headstyle="show"><head>Prefix and LocalPart</head><prodrecap id="Prefix" ref="Prefix" orig="formal"/><prodrecap id="LocalPart" ref="LocalPart" orig="formal"/></scrap></smnotation></div4></div3><div3 id="id-predicates"><head>Predicates</head><smintro><p>A predicate consists of an expression, called a <term>predicate
        expression</term>, enclosed in square brackets.</p><scrap headstyle="show"><head/><prodrecap id="Predicate" ref="Predicate" orig="xquery"/></scrap></smintro><smnotation><p id="jd_map_predicates">Normalization of predicates uses the
        following auxiliary mapping rule:
        <map/><a href="#jd_map_predicates" class="judgment"><subscript>Predicates</subscript></a>.</p></smnotation><smnorm><p>Predicates in path expressions are normalized with a
        special mapping rule:</p><mapping><xquery><expression><map><emph>Expr</emph></map><a href="#jd_map_predicates" class="judgment"><subscript>Predicates</subscript></a></expression></xquery><core><expression>
              <table summary=""><tbody><tr><td rowspan="1" colspan="1">typeswitch (<map><emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)</td></tr><tr><td rowspan="1" colspan="1">  case $v as <emph>fs:</emph><code>numeric</code> return <emph>op:</emph>numeric-equal($v, <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>position</code></a>)</td></tr><tr><td rowspan="1" colspan="1">  default $v return <code>fn:boolean</code>($v)</td></tr></tbody></table>
            </expression></core></mapping><p>Note that the semantics of predicates whose input
        expression returns a numeric value also work if that value is
        not an integer. In those cases the
        <code>op:numeric-equal</code> returns false when compared to a
        position. For example, the expression <code>//a[3.4]</code>
        always returns the empty sequence.</p></smnorm></div3><div3 id="unabbrev"><head>Unabbreviated Syntax</head><p>The corresponding Section in the [XPath/XQuery] document just
      contains examples.</p></div3><div3 id="abbrev"><head>Abbreviated Syntax</head><scrap headstyle="show"><head>Abbreviated Syntax</head><prodrecap id="AbbrevForwardStep" ref="AbbrevForwardStep" orig="xquery"/><prodrecap id="AbbrevReverseStep" ref="AbbrevReverseStep" orig="xquery"/></scrap><smnorm><p>Here are normalization rules for the abbreviated
        syntax.</p><mapping><xquery><expression><map>..</map><a href="#jd_map_axis" class="judgment"><subscript>Axis</subscript></a></expression></xquery><core><expression>parent::node()</expression></core></mapping><mapping><xquery><expression><map>@<emph>NodeTest</emph></map><a href="#jd_map_axis" class="judgment"><subscript>Axis</subscript></a></expression></xquery><core><expression>attribute::<emph>NodeTest</emph></expression></core></mapping><mapping><xquery><expression><map><emph>NodeTest</emph></map><a href="#jd_map_axis" class="judgment"><subscript>Axis</subscript></a></expression></xquery><core><expression>child::<emph>NodeTest</emph></expression></core></mapping></smnorm></div3></div2><div2 id="id-sequence-expressions"><head>Sequence Expressions</head><smintro><p>[XPath/XQuery] supports operators to construct and combine
      sequences.  A <term>sequence</term> is an ordered collection of
      zero or more items. An <term>item</term> is either an atomic
      value or a node.</p></smintro><div3 id="sec_constructing_sequences"><head>Constructing Sequences</head><scrap headstyle="show"><head>Constructing Sequences</head><prodrecap ref="Expr" orig="xquery"/><prodrecap id="RangeExpr" ref="RangeExpr" orig="xquery"/></scrap><smcore><p>The Core grammar production for sequence expressions is:</p><scrap headstyle="show"><head>Core Sequence Expressions</head><prodrecap ref="Expr" orig="core"/></scrap></smcore><smnorm><p>A sequence expression is normalized into a sequence of
        normalized single expressions:</p><mapping><xquery><expression>
              <map><emph>Expr</emph><subscript>1</subscript> , <emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
            </expression></xquery><core><expression>
              <map><emph>Expr</emph><subscript>1</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>, <map><emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
            </expression></core></mapping></smnorm><smtype><p><!--The static semantics of the sequence expression follows.-->
        The type of the sequence expression is the sequence over the
        types of the individual expressions.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression></clause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><emph>Expr</emph><subscript>1</subscript> , <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression></clause></multiclause></postjudge></infer></infergr></smtype><smeval><p><!-- The dynamic semantics of the sequence expression follows.-->
        Each expression in the sequence is evaluated and the resulting
        values are concatenated into one sequence.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript></expression></clause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>Expr</emph><subscript>1</subscript>, <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a>
                <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>, <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression></clause></multiclause></postjudge></infer></infergr></smeval><smnorm><p>The range operator is normalized to the <emph>fs:</emph><code>to</code>
        function.</p><mapping><xquery><expression>
             <map><emph>Expr</emph><subscript>1</subscript> <code>to</code> <emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
            </expression></xquery><core><expression>
              <emph>fs:</emph><code>to</code>((<map><emph>Expr</emph><subscript>1</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>),(<map><emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>))
            </expression></core></mapping></smnorm><smtype><p>The static semantics of the <emph>fs:</emph><code>to</code> function is defined in
        <specref ref="sec_fs_to"/>.</p></smtype><smeval><p>The dynamic semantics of the <emph>fs:</emph><code>to</code> function is defined in
        <specref ref="sec_fs_to"/>.</p></smeval></div3><div3 id="sec_filter_exprs"><head>Filter Expressions</head><smintro><scrap headstyle="show"><head>Filter Expression</head><prodrecap id="FilterExpr" ref="FilterExpr" orig="xquery"/></scrap></smintro><smcore><p>There are no Core grammar productions for filter
        expressions as they are normalized to other Core
        expressions. </p></smcore><smnorm><p>When a predicate with a numeric literal or the
        <code>last()</code> expression is applied on a primary
        expression, it is normalized using the <phrase diff="chg" at="E024"><a href="#sec_item_at"><emph>fs:</emph><code>item-at</code></a></phrase>
        function. This results in a more precise static type for those
        cases.</p><mapping><xquery><expression><map><emph>PrimaryExpr</emph> <emph>PredicateList</emph> [ <emph>NumericLiteral</emph> ]</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression></xquery><core><expression>
              <table summary=""><tbody><tr><td rowspan="1" colspan="1">let <code>$</code><emph>fs:</emph><code>sequence</code> := <map><emph>PrimaryExpr</emph> <emph>PredicateList</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> return</td></tr><tr><td rowspan="1" colspan="1"><phrase diff="chg" at="E024"><a href="#sec_item_at"><emph>fs:</emph><code>item-at</code></a></phrase>(<code>$</code><emph>fs:</emph><code>sequence</code>,<emph>NumericLiteral</emph><phrase diff="del" at="E024">,1</phrase>)</td></tr></tbody></table>
            </expression></core></mapping><mapping><xquery><expression><map><emph>PrimaryExpr</emph> <emph>PredicateList</emph> [ fn:last() ]</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression></xquery><core><expression>
              <table summary=""><tbody><tr><td rowspan="1" colspan="1">let <code>$</code><emph>fs:</emph><code>sequence</code> := <map><emph>PrimaryExpr</emph> <emph>PredicateList</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> return</td></tr><tr><td diff="add" at="E019" rowspan="1" colspan="1">let <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>last</code></a> := fn:count(<code>$</code><emph>fs:</emph><code>sequence</code>) return</td></tr><tr><td rowspan="1" colspan="1"><phrase diff="chg" at="E024"><a href="#sec_item_at"><emph>fs:</emph><code>item-at</code></a></phrase>(<code>$</code><emph>fs:</emph><code>sequence</code>,<a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>last</code></a><phrase diff="del" at="E024">,1</phrase>)</td></tr></tbody></table>
            </expression></core></mapping><p>In the general case, when a predicate is applied on a
        primary expression, it is normalized to a FLWOR expression as
        follows. The input sequence is processed in sequence order and
        the context item is bound to each item in the input
        sequence.</p><mapping><xquery><expression><map><emph>PrimaryExpr</emph> <emph>PredicateList</emph> [ <emph>Expr</emph> ]</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression></xquery><core><expression>
              <table summary=""><tbody><tr><td rowspan="1" colspan="1">let <code>$</code><emph>fs:</emph><code>sequence</code> := <map><emph>PrimaryExpr</emph> <emph>PredicateList</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> return</td></tr><tr><td rowspan="1" colspan="1">let <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>last</code></a> := fn:count(<code>$</code><emph>fs:</emph><code>sequence</code>) return</td></tr><tr><td rowspan="1" colspan="1">for <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>dot</code></a> at <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>position</code></a> in <code>$</code><emph>fs:</emph><code>sequence</code> return</td></tr><tr><td rowspan="1" colspan="1">   if (<map><emph>Expr</emph></map><a href="#jd_map_predicates" class="judgment"><subscript>Predicates</subscript></a>) then <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>dot</code></a> else ()</td></tr></tbody></table>
            </expression></core></mapping></smnorm><smtype><p>There are no additional static typing rules for filter
      expressions.</p></smtype><smeval><p>There are no additional dynamic evaluation rules for filter
      expressions.</p></smeval></div3><div3 id="sec_combining_sequences"><head>Combining Node Sequences</head><p>[XPath/XQuery] provides several operators for combining
      sequences of nodes.</p><scrap headstyle="show"><head>Combining Sequences</head><prodrecap id="UnionExpr" ref="UnionExpr" orig="xquery"/><prodrecap id="IntersectExceptExpr" ref="IntersectExceptExpr" orig="xquery"/></scrap><smnotation><p id="jd_map_sequenceop">The union, intersect, and except
      expressions are normalized into function calls to the
      appropriate functions. The mapping function
      <map/><a href="#jd_map_sequenceop" class="judgment"><subscript>SequenceOp</subscript></a> is defined by the following
      table:</p><table summary="" border="1"><tbody><tr><td rowspan="1" colspan="1">SequenceOp</td><td rowspan="1" colspan="1"><map><emph>SequenceOp</emph></map><a href="#jd_map_sequenceop" class="judgment"><subscript>SequenceOp</subscript></a></td></tr><tr><td rowspan="1" colspan="1">"union"</td><td rowspan="1" colspan="1"><emph>op:</emph>union</td></tr><tr><td rowspan="1" colspan="1">"|"</td><td rowspan="1" colspan="1"><emph>op:</emph>union</td></tr><tr><td rowspan="1" colspan="1">"intersect"</td><td rowspan="1" colspan="1"><emph>op:</emph>intersect</td></tr><tr><td rowspan="1" colspan="1">"except"</td><td rowspan="1" colspan="1"><emph>op:</emph>except</td></tr></tbody></table></smnotation><smnorm><p>Operators for combining node sequences are normalized as
      follows.</p><mapping><xquery><expression>
        <map><emph>Expr</emph><subscript>1</subscript> <emph>SequenceOp</emph> <emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
        </expression></xquery><core><expression>
        <a href="#sec_apply_ordering_mode"><emph>fs:</emph><code>apply-ordering-mode</code></a> (<map><emph>SequenceOp</emph></map><a href="#jd_map_sequenceop" class="judgment"><subscript>SequenceOp</subscript></a> (
        <map><emph>Expr</emph><subscript>1</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>, <map><emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> ))
        </expression></core></mapping></smnorm><smtype><p>The static semantics of the operators that combine sequences
      are defined in <specref ref="sec_op_union_intersect_except"/>.</p></smtype><smeval><p>The dynamic semantics for function calls is given in <specref ref="id-function-calls"/>.</p></smeval></div3></div2><div2 id="sec_arithmetic"><head>Arithmetic Expressions</head><p>[XPath/XQuery] provides arithmetic operators for addition,
    subtraction, multiplication, division, and modulus, in their usual
    binary and unary forms.</p><scrap headstyle="show"><head>Arithmetic Expressions</head><prodrecap id="AdditiveExpr" ref="AdditiveExpr" orig="xquery"/><prodrecap id="MultiplicativeExpr" ref="MultiplicativeExpr" orig="xquery"/><prodrecap id="UnaryExpr" ref="UnaryExpr" orig="xquery"/><prodrecap id="ValueExpr" ref="ValueExpr" orig="xquery"/></scrap><smcore><p>The Core grammar production for arithmetic expressions
      is:</p><scrap headstyle="show"><head/><prodrecap id="core-ValueExpr" ref="ValueExpr" orig="core"/></scrap></smcore><smnotation><p id="jd_map_arithop">The mapping function
      <map/><a href="#jd_map_arithop" class="judgment"><subscript>ArithOp</subscript></a> is defined by the following
      table:</p><table summary="" border="1"><tbody><tr><td rowspan="1" colspan="1"><emph>ArithOp</emph></td><td rowspan="1" colspan="1"><map><emph>ArithOp</emph></map><a href="#jd_map_arithop" class="judgment"><subscript>ArithOp</subscript></a></td></tr><tr><td rowspan="1" colspan="1">"+"</td><td rowspan="1" colspan="1"><emph>fs:</emph><code>plus</code></td></tr><tr><td rowspan="1" colspan="1">"-"</td><td rowspan="1" colspan="1"><emph>fs:</emph><code>minus</code></td></tr><tr><td rowspan="1" colspan="1">"*"</td><td rowspan="1" colspan="1"><emph>fs:</emph><code>times</code></td></tr><tr><td rowspan="1" colspan="1">"div"</td><td rowspan="1" colspan="1"><emph>fs:</emph><code>div</code></td></tr><tr><td rowspan="1" colspan="1">"mod"</td><td rowspan="1" colspan="1"><emph>fs:</emph><code>mod</code></td></tr></tbody></table></smnotation><smcore><p>There are no Core grammar productions for arithmetic
    expressions as they are normalized to other Core expressions. </p></smcore><smnorm><p>The normalization rules for all the arithmetic operators
     except <code>idiv</code> first atomize each argument by applying
     <code>fn:data</code> and then apply the internal function
     <a href="#sec_convert_operand"><emph>fs:</emph><code>convert-operand</code></a> to each argument.  If the first argument to
     this function has type <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>, then the first
     argument is cast to a double, otherwise it is returned unchanged.
     The overloaded internal function corresponding to the arithmetic
     operator is then applied to the two converted arguments.  The
     table above maps the operators to the corresponding internal
     function.  The mapping from the overloaded internal functions to
     the corresponding non-overloaded function is given in <specref ref="sec_operators"/>.</p><mapping><xquery><expression>
      <map><emph>Expr</emph><subscript>1</subscript> <emph>ArithOp</emph>  <emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
     </expression></xquery><core><expression>
      <table summary=""><tbody><tr><td rowspan="1" colspan="1"><map><emph>ArithOp</emph></map><a href="#jd_map_arithop" class="judgment"><subscript>ArithOp</subscript></a>
          (</td><td rowspan="1" colspan="1"><a href="#sec_convert_operand"><emph>fs:</emph><code>convert-operand</code></a>(<code>fn:data</code>((<map><emph>Expr</emph><subscript>1</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)), 1.0E0),
         </td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"><a href="#sec_convert_operand"><emph>fs:</emph><code>convert-operand</code></a>(<code>fn:data</code>((<map><emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)), 1.0E0))
         </td></tr></tbody></table>
     </expression></core></mapping><p>The normalization rules for the <code>idiv</code> operator are similar,
   but instead of casting arguments with type <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> to
   <code>xs:double</code>, they are cast to <code>xs:integer</code>.</p><mapping><xquery><expression>
      <map><emph>Expr</emph><subscript>1</subscript> <code>idiv</code>  <emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
     </expression></xquery><core><expression>
      <table summary=""><tbody><tr valign="baseline"><td rowspan="1" colspan="1"><emph>fs:</emph><code>idiv</code>
          (</td><td rowspan="1" colspan="1"><a href="#sec_convert_operand"><emph>fs:</emph><code>convert-operand</code></a>(<code>fn:data</code>((<map><emph>Expr</emph><subscript>1</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)), 1),
         </td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"><a href="#sec_convert_operand"><emph>fs:</emph><code>convert-operand</code></a>(<code>fn:data</code>((<map><emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)), 1))
         </td></tr></tbody></table>
     </expression></core></mapping><p>The unary operators are mapped similarly.</p><mapping><xquery><expression>
      <map><code>+</code> <emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
     </expression></xquery><core><expression>
            <emph>fs:</emph><code>unary-plus</code>(<a href="#sec_convert_operand"><emph>fs:</emph><code>convert-operand</code></a>(<code>fn:data</code>((<map><emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)), 1.0E0))
     </expression></core></mapping><mapping><xquery><expression>
      <map><code>-</code> <emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
     </expression></xquery><core><expression>
        <emph>fs:</emph><code>unary-minus</code>(<a href="#sec_convert_operand"><emph>fs:</emph><code>convert-operand</code></a>(<code>fn:data</code>((<map><emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)), 1.0E0))
     </expression></core></mapping></smnorm><smtype><p>The static semantics for function calls is given in <specref ref="id-function-calls"/>. The mapping from the overloaded internal
  functions to the corresponding non-overloaded function is given in
  <specref ref="sec_operators"/>.</p></smtype><smeval><p>The dynamic semantics for function calls is given in <specref ref="id-function-calls"/>. The mapping from the overloaded internal
  functions to the corresponding non-overloaded function is given in
  <specref ref="sec_operators"/>.</p></smeval></div2><div2 id="sec_comparisons"><head>Comparison Expressions</head><smintro><p>Comparison expressions allow two values to be
      compared. [XPath/XQuery] provides three kinds of comparison
      expressions, called value comparisons, general comparisons, and
      node comparisons.</p><scrap headstyle="show"><head>Comparison Expressions</head><prodrecap id="ComparisonExpr" ref="ComparisonExpr" orig="xquery"/><prodrecap id="ValueComp" ref="ValueComp" orig="xquery"/><prodrecap id="GeneralComp" ref="GeneralComp" orig="xquery"/><prodrecap id="NodeComp" ref="NodeComp" orig="xquery"/></scrap></smintro><div3 id="sec_value_comparisons"><head>Value Comparisons</head><smnotation><p id="jd_map_valuecomp">The mapping function
      <map/><a href="#jd_map_valuecomp" class="judgment"><subscript>ValueComp</subscript></a> is defined by the following
      table:</p><table summary="" border="1"><tbody><tr><td rowspan="1" colspan="1">ValueComp</td><td rowspan="1" colspan="1"><map>ValueComp</map><a href="#jd_map_valuecomp" class="judgment"><subscript>ValueComp</subscript></a></td></tr><tr><td rowspan="1" colspan="1">"<code>eq</code>"</td><td rowspan="1" colspan="1"><emph>fs:</emph>eq</td></tr><tr><td rowspan="1" colspan="1">"<code>ne</code>"</td><td rowspan="1" colspan="1"><emph>fs:</emph>ne</td></tr><tr><td rowspan="1" colspan="1">"<code>lt</code>"</td><td rowspan="1" colspan="1"><emph>fs:</emph>lt</td></tr><tr><td rowspan="1" colspan="1">"<code>le</code>"</td><td rowspan="1" colspan="1"><emph>fs:</emph>le</td></tr><tr><td rowspan="1" colspan="1">"<code>gt</code>"</td><td rowspan="1" colspan="1"><emph>fs:</emph>gt</td></tr><tr><td rowspan="1" colspan="1">"<code>ge</code>"</td><td rowspan="1" colspan="1"><emph>fs:</emph>ge</td></tr></tbody></table></smnotation><smcore><p>There are no Core grammar productions for value comparisons
      as they are normalized to other Core expressions. </p></smcore><smnorm><p>The normalization rules for the value comparison operators
      first atomize each argument by applying <code>fn:data</code> and then apply
      the internal function <a href="#sec_convert_operand"><emph>fs:</emph><code>convert-operand</code></a> defined in <specref ref="sec_convert_operand"/>.  If the first argument to this
      function has type <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>, then the first argument is
      cast to a string, otherwise it is returned unchanged.  The
      overloaded internal function corresponding to the value
      comparison operator is then applied to the two converted
      arguments.  The table above maps the value operators to the
      corresponding internal function.  The mapping from the
      overloaded internal functions to the corresponding
      non-overloaded function is given in <specref ref="sec_operators"/>.</p><mapping><xquery><expression>
         <map><emph>Expr</emph><subscript>1</subscript> <emph>ValueComp</emph>  <emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
        </expression></xquery><core><expression>
         <table summary=""><tbody><tr><td rowspan="1" colspan="1"><map><emph>ValueComp</emph></map><a href="#jd_map_valuecomp" class="judgment"><subscript>ValueComp</subscript></a>
             (</td><td rowspan="1" colspan="1"><a href="#sec_convert_operand"><emph>fs:</emph><code>convert-operand</code></a>(<code>fn:data</code>((<map><emph>Expr</emph><subscript>1</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)), "string"),
            </td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"><a href="#sec_convert_operand"><emph>fs:</emph><code>convert-operand</code></a>(<code>fn:data</code>((<map><emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)), "string") )
            </td></tr></tbody></table>
        </expression></core></mapping></smnorm><smtype><p>The static semantics for function calls is given in <specref ref="id-function-calls"/>.  The comparison functions all have
      return type <code>xs:boolean</code>, as specified in <bibref ref="xpath-functions-30"/>. </p></smtype><smeval><p>The dynamic semantics for function calls is given in <specref ref="id-function-calls"/>.</p></smeval></div3><div3 id="sec_general_comparisons"><head>General Comparisons</head><smintro><p>General comparisons are defined by adding existential
      semantics to value comparisons. The operands of a general
      comparison may be sequences of any length. The result of a
      general comparison is always <code>true</code> or
      <code>false</code>.</p></smintro><smnotation><p id="jd_map_generalcomp">The function
      <map/><a href="#jd_map_generalcomp" class="judgment"><subscript>GeneralComp</subscript></a> is defined by the following
      table:</p><table summary="" border="1"><tbody><tr><td rowspan="1" colspan="1"><emph>GeneralComp</emph></td><td rowspan="1" colspan="1"><map><emph>GeneralComp</emph></map><a href="#jd_map_generalcomp" class="judgment"><subscript>GeneralComp</subscript></a></td></tr><tr><td rowspan="1" colspan="1">"<code>=</code>"</td><td rowspan="1" colspan="1"><emph>fs:</emph>eq</td></tr><tr><td rowspan="1" colspan="1">"<code>!=</code>"</td><td rowspan="1" colspan="1"><emph>fs:</emph>ne</td></tr><tr><td rowspan="1" colspan="1">"<code>&lt;</code>"</td><td rowspan="1" colspan="1"><emph>fs:</emph>lt</td></tr><tr><td rowspan="1" colspan="1">"<code>&lt;=</code>"</td><td rowspan="1" colspan="1"><emph>fs:</emph>le</td></tr><tr><td rowspan="1" colspan="1">"<code>&gt;</code>"</td><td rowspan="1" colspan="1"><emph>fs:</emph>gt</td></tr><tr><td rowspan="1" colspan="1">"<code>&gt;=</code>"</td><td rowspan="1" colspan="1"><emph>fs:</emph>ge</td></tr></tbody></table></smnotation><smcore><p>There are no Core grammar productions for general comparisons
      as they are normalized to existentially quantified Core
      expressions.</p></smcore><smnorm><p>The normalization rule for a general comparison expression
      first atomizes each argument by applying <code>fn:data</code>,
      <phrase diff="del" at="E055">
      and then
      applies the existentially quantified <emph>SomeExpr</emph> expression to
      each sequence.  The internal function <a href="#sec_convert_operand"><emph>fs:</emph><code>convert-operand</code></a> is
      applied to each pair of atomic values.
      If the first argument to
      this function has type <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>, then the first
      argument is cast to type of the second argument.  If the second
      argument has type <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>, the first argument is cast
      to a string.
      </phrase>
      <phrase diff="add" at="E055">
      resulting in two sequences of atomic values.
      Two nested <code>some</code> expressions then examine
      (potentially) every pair of values
      (one value from each sequence).
      For each pair, the internal function <a href="#sec_convert_operand"><emph>fs:</emph><code>convert-operand</code></a> is called twice;
      if either of the two values is of type <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>,
      one of the calls will cast it to a type determined by the other value.
      </phrase>
      The overloaded internal function corresponding to
      the general comparison operator is then applied to the two
      converted values.</p><mapping><xquery><expression>
                <map><emph>Expr</emph><subscript>1</subscript> <emph>GeneralComp</emph> <emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
              </expression></xquery><core><expression>
                <table summary=""><tbody><tr><td rowspan="1" colspan="1">some $v1 in <code>fn:data</code>((<map><emph>Expr</emph><subscript>1</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)) satisfies</td></tr><tr><td rowspan="1" colspan="1">some $v2 in <code>fn:data</code>((<map><emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)) satisfies</td></tr><tr><td rowspan="1" colspan="1">let $u1 := <a href="#sec_convert_operand"><emph>fs:</emph><code>convert-operand</code></a>($v1, $v2) return </td></tr><tr><td rowspan="1" colspan="1">let $u2 := <a href="#sec_convert_operand"><emph>fs:</emph><code>convert-operand</code></a>($v2, $v1) return </td></tr><tr><td rowspan="1" colspan="1"><map><emph>GeneralComp</emph></map><a href="#jd_map_generalcomp" class="judgment"><subscript>GeneralComp</subscript></a> ($u1, $u2)</td></tr></tbody></table>
              </expression></core></mapping></smnorm></div3><div3 id="sec_node-comparisons"><head>Node Comparisons</head><smcore><p>There are no Core grammar productions for node comparisons as
  they are normalized to other Core expressions.</p></smcore><smnorm><p>The normalization rules for node comparisons map each argument
  expression and then apply the internal function corresponding to the
  node comparison operator. The internal function are defined in
  <specref ref="sec_operators"/>.</p><mapping><xquery><expression>
<map><emph>Expr</emph><subscript>1</subscript> <code>is</code> <emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
</expression></xquery><core><expression>
       <table summary=""><tbody><tr><td rowspan="1" colspan="1">   <emph>fs:</emph><code>is-same-node</code>((<map><emph>Expr</emph><subscript>1</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>), (<map><emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>))</td></tr></tbody></table>
     </expression></core></mapping><mapping><xquery><expression>
<map><emph>Expr</emph><subscript>1</subscript> &lt;&lt; <emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
</expression></xquery><core><expression>
       <table summary=""><tbody><tr><td rowspan="1" colspan="1"><emph>fs:</emph><code>node-before</code>((<map><emph>Expr</emph><subscript>1</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>), (<map><emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>))</td></tr></tbody></table>
</expression></core></mapping><mapping><xquery><expression>
<map><emph>Expr</emph><subscript>1</subscript> &gt;&gt; <emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
</expression></xquery><core><expression>
       <table summary=""><tbody><tr><td rowspan="1" colspan="1"><emph>fs:</emph><code>node-after</code>((<map><emph>Expr</emph><subscript>1</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>), (<map><emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>))</td></tr></tbody></table>
</expression></core></mapping></smnorm><smtype><p>The static semantics for the internal functions are defined in
  <specref ref="sec_operators"/>. </p></smtype><smeval><p>The dynamic semantics for internal function is defined in
  <specref ref="sec_operators"/>.</p></smeval></div3></div2><div2 id="id-logical-expressions"><head>Logical Expressions</head><smintro><p>A <term>logical expression</term> is either an
      <term>and-expression</term> or an
      <term>or-expression</term>. The value of a logical expression is
      always one of the boolean values: <code>true</code> or
      <code>false</code>.</p></smintro><scrap headstyle="show"><head>Logical Expressions</head><prodrecap ref="OrExpr" id="OrExpr" orig="xquery"/><prodrecap ref="AndExpr" id="AndExpr" orig="xquery"/></scrap><smcore><p>The Core grammar productions for logical expressions are:</p><scrap headstyle="show"><head>Core Logical Expressions</head><prodrecap ref="OrExpr" id="core-OrExpr" orig="core"/><prodrecap ref="AndExpr" id="core-AndExpr" orig="core"/></scrap></smcore><smnorm><p>The normalization rules for "<code>and</code>" and "<code>or</code>" first
      get the effective boolean value of each argument, then apply the
      appropriate Core operator.</p><mapping><xquery><expression>
      <map><emph>Expr</emph><subscript>1</subscript> <code>and</code> <emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
     </expression></xquery><core><expression>
      <code>fn:boolean</code>((<map><emph>Expr</emph><subscript>1</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)) <code>and</code> <code>fn:boolean</code>((<map><emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>))
     </expression></core></mapping><mapping><xquery><expression>
      <map><emph>Expr</emph><subscript>1</subscript> <code>or</code> <emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
     </expression></xquery><core><expression>
      <code>fn:boolean</code>((<map><emph>Expr</emph><subscript>1</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)) <code>or</code> <code>fn:boolean</code>((<map><emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>))
     </expression></core></mapping></smnorm><smtype><p>The logical expressions require that each subexpression have
type <code>xs:boolean</code>.  The result type is also <code>xs:boolean</code>.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:boolean</code></expression></clause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><emph>Expr</emph><subscript>n</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:boolean</code></expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><emph>Expr</emph><subscript>1</subscript> <code>and</code> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:boolean</code></expression></clause></multiclause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:boolean</code></expression></clause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><emph>Expr</emph><subscript>n</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:boolean</code></expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><emph>Expr</emph><subscript>1</subscript> <code>or</code> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:boolean</code></expression></clause></multiclause></postjudge></infer></infergr></smtype><smeval><p>The dynamic semantics of logical expressions is
non-deterministic.   This non-determinism permits implementations to use
short-circuit evaluation strategies when evaluating logical expressions. In the expression, <emph>Expr</emph><subscript>1</subscript> <code>and</code> <emph>Expr</emph><subscript>2</subscript>,
if either expression raises an error or evaluates to false, the entire
expression may raise an error or evaluate to false. 
In the expression, <emph>Expr</emph><subscript>1</subscript> <code>or</code> <emph>Expr</emph><subscript>2</subscript>,
if either expression raises an error or evaluates to true, the entire
expression may raise an error or evaluate to true. </p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a> </environment><expression><emph>Expr</emph><subscript>i</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> false</expression></clause></multiclause><multiclause><clause><expression>i <a href="#jd_isin" class="judgment"><term>in</term></a> { 1,2 }</expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a> </environment><expression><emph>Expr</emph><subscript>1</subscript> <code>and</code> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a>
                false</expression></clause></multiclause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a> </environment><expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> true</expression></clause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a> </environment><expression><emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> true</expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a> </environment><expression><emph>Expr</emph><subscript>1</subscript> <code>and</code> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a>
                true</expression></clause></multiclause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a> </environment><expression><emph>Expr</emph><subscript>i</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> true</expression></clause></multiclause><multiclause><clause><expression>i <a href="#jd_isin" class="judgment"><term>in</term></a> { 1,2 }</expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a> </environment><expression><emph>Expr</emph><subscript>1</subscript> <code>or</code> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a>
                true</expression></clause></multiclause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a> </environment><expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> false</expression></clause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a> </environment><expression><emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> false</expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a> </environment><expression><emph>Expr</emph><subscript>1</subscript> <code>or</code> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a>
                false</expression></clause></multiclause></postjudge></infer></infergr></smeval></div2><div2 id="sec_constructors"><head>Constructors</head><p>[XPath/XQuery] supports two forms of constructors. <term>Direct
    constructors</term> support literal XML syntax for elements,
    attributes, text nodes, processing-instructions and
    comments. <term>Computed constructors</term> can be used to
    construct elements, attributes, text nodes,
    processing-instructions, comments, and document nodes.  All direct
    constructors are normalized into computed constructors, i.e.,
    there are no direct-constructor expressions in the Core.</p><scrap headstyle="show"><head>Constructors</head><prodrecap id="Constructor" ref="Constructor" orig="xquery"/><prodrecap id="DirectConstructor" ref="DirectConstructor" orig="xquery"/><prodrecap id="DirElemConstructor" ref="DirElemConstructor" orig="xquery"/><prodrecap id="DirElemContent" ref="DirElemContent" orig="xquery"/><prodrecap id="ElementContentChar" ref="ElementContentChar" orig="xquery"/><prodrecap id="CommonContent" ref="CommonContent" orig="xquery"/><prodrecap id="CDataSection" ref="CDataSection" orig="xquery"/><prodrecap id="CDataSectionContents" ref="CDataSectionContents" orig="xquery"/><prodrecap id="DirAttributeList" ref="DirAttributeList" orig="xquery"/><prodrecap id="DirAttributeValue" ref="DirAttributeValue" orig="xquery"/><prodrecap id="QuotAttrValueContent" ref="QuotAttrValueContent" orig="xquery"/><prodrecap id="AposAttrValueContent" ref="AposAttrValueContent" orig="xquery"/><prodrecap id="QuotAttrContentChar" ref="QuotAttrContentChar" orig="xquery"/><prodrecap id="AposAttrContentChar" ref="AposAttrContentChar" orig="xquery"/><prodrecap id="EscapeQuot" ref="EscapeQuot" orig="xquery"/><prodrecap id="EscapeApos" ref="EscapeApos" orig="xquery"/><prodrecap id="EnclosedExpr" ref="EnclosedExpr" orig="xquery"/></scrap><smcore><p>The Core grammar productions for constructors are:</p><scrap headstyle="show"><head>Constructors</head><prodrecap id="core-Constructor" ref="Constructor" orig="core"/><prodrecap id="core-ComputedConstructor" ref="ComputedConstructor" orig="core"/><prodrecap id="core-EnclosedExpr" ref="EnclosedExpr" orig="core"/></scrap><p>There are no Core grammar productions for direct XML element
      or attribute constructors as they are normalized to computed
      constructors.</p></smcore><div3 id="id_element_constructor"><head>Direct Element Constructors</head><smintro><p>The static and dynamic semantics of the direct forms of
      element and attribute constructors are specified
      <phrase diff="del" at="E052">on</phrase>
      <phrase diff="add" at="E052">in terms of</phrase>
      the
      equivalent computed element and attribute constructors.</p></smintro><smnotation><p id="jd_map_element_content">The auxiliary mapping rules
      <map/><a href="#jd_map_element_content" class="judgment"><subscript>ElementContent</subscript></a>,
      <map/><a href="#jd_map_element_content" class="judgment"><subscript>ElementContentUnit</subscript></a>,
      <map/><a href="#jd_map_element_content" class="judgment"><subscript>PartitionIntoUnits</subscript></a>, and
      <map/><a href="#jd_map_element_content" class="judgment"><subscript>DirCharsUnit<phrase diff="del" at="E052">s</phrase></subscript></a> are defined in this section and
      are used for the normalization of the content of direct element
      constructors.</p></smnotation><smnotation><p>An element-content unit is either
      <phrase diff="add" at="E052">a <a href="#doc-fs-DirCharsUnit"><emph>DirCharsUnit</emph></a> (</phrase>
      a maximal contiguous
      sequence of literal characters
      <phrase diff="del" at="E052">(including</phrase>
      <phrase diff="add" at="E052">, CDataSections,</phrase>
      character references,
      escaped braces, and predefined entity references), an enclosed
      expression, a direct element constructor, an XML comment, or an
      XML processing instruction. We use the following auxiliary
      grammar productions to describe element-content units.</p><scrap headstyle="show"><head/><prodrecap id="ElementContentUnit" ref="ElementContentUnit" orig="formal"/><prodrecap id="DirCharsUnit" ref="DirCharsUnit" orig="formal"/></scrap><p>We use the auxiliary normalization rule <map>
      <emph>DirElemContent</emph>* </map><a href="#jd_map_element_content" class="judgment"><subscript>PartitionIntoUnits</subscript></a> to
      restructure the original element content, <emph>DirElemContent</emph>*,
      into the appropriate sequence of element-content units. This
      normalization rule is not specified formally.</p><p>Here are three direct element constructors, each of which
      contains one element-content unit:</p><eg xml:space="preserve">
&lt;date&gt;{ xs:date("2003-03-18") }&lt;/date&gt;

&lt;name&gt;Dizzy Gillespie&lt;/name&gt;

&lt;comment&gt;&lt;!-- Just a comment --&gt;&lt;/comment&gt;
</eg><p>The first contains one enclosed expression, the second
     contains one contiguous sequence of characters, and the third
     contains one XML comment.</p><p>After boundary whitespace is stripped, the next example
     contains six element-content units: </p><eg xml:space="preserve">
&lt;address&gt;
  &lt;!-- Dizzy's address --&gt;
  { 123 }-0A &lt;street&gt;Roosevelt Ave.&lt;/street&gt; Flushing, NY { 11368 }
&lt;/address&gt;
</eg><p>It contains an XML comment, followed by an enclosed expression
     that contains the integer 123, a contiguous sequence of
     characters ("-0A "), a direct XML element constructor, a
     contiguous sequence of characters (" Flushing, NY "), and an
     enclosed expression that contains the integer 11368. Evaluation
     of that constructor will result in the following element.</p><eg xml:space="preserve">
&lt;address&gt;&lt;!-- Dizzy's address --&gt;123-0A &lt;street&gt;Roosevelt Ave.&lt;/street&gt; Flushing, NY 11368&lt;/address&gt;
</eg></smnotation><smnorm><p>We start by giving the rules for the two forms of direct XML
      element constructors.  Note that the direct attribute
      constructors are normalized twice: the
      <map/><a href="#jd_map_namespace_attr" class="judgment"><subscript>NamespaceAttrs</subscript></a> normalizes the
      namespace-declaration attributes and
      <map/><a href="#jd_map_attribute" class="judgment"><subscript>Attribute</subscript></a> normalizes all other attributes
      that are not namespace-declaration attributes. </p><mapping><xquery><expression><map> &lt; <emph>QName</emph> <emph>DirAttributeList</emph> &gt;
          <emph>DirElemContent</emph>* &lt;/ <emph>QName</emph> S? &gt;
          </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression></xquery><core><expression>element <emph>QName</emph> { <map>
          <emph>DirAttributeList</emph> </map><a href="#jd_map_attribute" class="judgment"><subscript>Attribute</subscript></a> , <map>
          <map> <emph>DirElemContent</emph>* </map><a href="#jd_map_element_content" class="judgment"><subscript>PartitionIntoUnits</subscript></a>
          </map><a href="#jd_map_element_content" class="judgment"><subscript>ElementContent</subscript></a> } { <map>
          <emph>DirAttributeList</emph> </map><a href="#jd_map_namespace_attr" class="judgment"><subscript>NamespaceAttrs</subscript></a> }
        </expression></core></mapping><mapping><xquery><expression><map> &lt; <emph>QName</emph> <emph>DirAttributeList</emph> /&gt;
          </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression></xquery><core><expression>element <emph>QName</emph> { <map>
        <emph>DirAttributeList</emph> </map><a href="#jd_map_attribute" class="judgment"><subscript>Attribute</subscript></a> } { <map>
          <emph>DirAttributeList</emph> </map><a href="#jd_map_namespace_attr" class="judgment"><subscript>NamespaceAttrs</subscript></a> }
        </expression></core></mapping><p>We can now give the rules for normalizing a direct element
      constructor's content.
      <phrase diff="del" at="E011">
      We distinguish between direct element
      constructors that contain only one element-content unit and
      those that contain more than one element-content unit.
      </phrase></p><p>Adjacent element-content units
      <phrase diff="del" at="E052">are convenient because they</phrase>
      permit arbitrary interleaving of text and atomic data.  During
      evaluation, atomic values are converted to text nodes containing
      the string representations of the atomic values, and then
      adjacent text nodes are concatenated together.  In the example
      at the beginning of this section, the integer 123 is converted
      to a string and concatenated with "-0A" and the result is a
      single text node containing "123-0A".</p><p>Below are two examples of normalization for element
      constructors.</p><eg xml:space="preserve">
&lt;date&gt;{ xs:date("2003-03-18") }&lt;/date&gt;
 =
element date { 
  fs:item-sequence-to-node-sequence(
    xs:date("2003-03-18")
  )
}<phrase diff="add" at="E052"> {}</phrase>

&lt;address&gt;
  &lt;!-- Dizzy's address --&gt;
  { 123 }-0A &lt;street&gt;Roosevelt Ave.&lt;/street&gt; Flushing, NY { 11368 }
&lt;/address&gt;
 =
element address {
  fs:item-sequence-to-node-sequence(
    comment { " Dizzy's address "},
    123, 
    text { "-0A "}, 
    element street {"Roosevelt Ave."}<phrase diff="add" at="E052"> {}</phrase>,
    text { " Flushing, NY "  },
    11368
  )
}<phrase diff="add" at="E052"> {}</phrase>
</eg><p>We normalize each unit individually and construct a sequence of
    the normalized results<phrase diff="del" at="E029"> interleaved with empty text nodes.  The
    empty text nodes guarantee that the results of evaluating
    consecutive element-content units can be distinguished.  Then we
    apply the function <a href="#sec_items_to_nodes"><emph>fs:</emph><code>item-sequence-to-node-sequence</code></a>.  <xspecref spec="XQ" ref="id-element-constructor"/> specifies the rules for converting
    a sequence of atomic values and nodes into a sequence of nodes
    before element construction.  The Formal Semantics function
    <a href="#sec_items_to_nodes"><emph>fs:</emph><code>item-sequence-to-node-sequence</code></a> implements these conversion rules</phrase>.</p><mapping diff="del" at="E011"><xquery><expression><map><a href="#doc-fs-ElementContentUnit"><emph>ElementContentUnit</emph></a><subscript>1</subscript></map><a href="#jd_map_element_content" class="judgment"><subscript>ElementContent</subscript></a></expression></xquery><core><expression><a href="#sec_items_to_nodes"><emph>fs:</emph><code>item-sequence-to-node-sequence</code></a>((<map> <a href="#doc-fs-ElementContentUnit"><emph>ElementContentUnit</emph></a><subscript>1</subscript></map><a href="#jd_map_element_content" class="judgment"><subscript>ElementContentUnit</subscript></a>))
          </expression></core></mapping><mapping><xquery><expression><map><a href="#doc-fs-ElementContentUnit"><emph>ElementContentUnit</emph></a><subscript>1</subscript>, ...,  <a href="#doc-fs-ElementContentUnit"><emph>ElementContentUnit</emph></a><subscript>n</subscript></map><a href="#jd_map_element_content" class="judgment"><subscript>ElementContent</subscript></a></expression></xquery><core><expression>
            <phrase diff="del" at="E029"><a href="#sec_items_to_nodes"><emph>fs:</emph><code>item-sequence-to-node-sequence</code></a>((</phrase>
            <map> <a href="#doc-fs-ElementContentUnit"><emph>ElementContentUnit</emph></a><subscript>1</subscript> </map><a href="#jd_map_element_content" class="judgment"><subscript>ElementContentUnit</subscript></a> ,
            <phrase diff="del" at="E029">text { "" },</phrase>
            ...,
            <phrase diff="del" at="E029">text { "" },</phrase>
            <map> <a href="#doc-fs-ElementContentUnit"><emph>ElementContentUnit</emph></a><subscript>n</subscript></map><a href="#jd_map_element_content" class="judgment"><subscript>ElementContentUnit</subscript></a>
            <phrase diff="del" at="E029">))</phrase>
          </expression></core></mapping><p diff="add" at="E011">
      (Note that this rule should be understood to cover
      the degenerate cases of n=0 and n=1,
      where the element constructor's content
      consists of zero or one element-content units.)
    </p><p diff="del" at="E029">We must distinguish between the results of consecutive
    element-content units, because the rule for converting sequences
    of atomic values into strings applies to sequences within distinct
    enclosed expressions.  The empty text nodes are eliminated during
    evaluation of <a href="#sec_items_to_nodes"><emph>fs:</emph><code>item-sequence-to-node-sequence</code></a> when consecutive text
    nodes are coalesced into a single text node.  The text node
    guarantees that a whitespace character will not be inserted
    between atomic values computed by distinct enclosed expressions.
    For example, here is an expression, its normalization, and the
    resulting XML value:</p><eg diff="del" at="E029" xml:space="preserve">
&lt;example&gt;{ 1 }{ 2 }&lt;/example&gt;
 =
element example { fs:item-sequence-to-node-sequence ((1, text {""}, 2)) }
 ==&gt;
&lt;example&gt;12&lt;/example&gt;
</eg><p diff="del" at="E029">In the absence of the empty text node, the expression would
      evaluate to the following incorrect value:</p><eg diff="del" at="E029" xml:space="preserve">
&lt;example&gt;{ 1 }{ 2 }&lt;/example&gt;
 (incorrect normalization) =
element example { fs:item-sequence-to-node-sequence ((1, 2)) }
 (incorrect value) ==&gt;
&lt;example&gt;1 2&lt;/example&gt;
</eg><p>Next, we give the normalization rules for each
      element-content unit. The normalization rule for a contiguous
      sequence of characters assumes that the significant whitespace
      characters in element constructors have been preserved, as
      described in <specref ref="sec_whitespace"/>.</p><p>The following normalization rule takes
      <phrase diff="del" at="E052">the longest consecutive sequence</phrase>
      <phrase diff="add" at="E052">a maximal contiguous sequence</phrase>
      of individual characters that include
      literal characters,
      <phrase diff="add" at="E052">CDataSections,</phrase>
      escaped curly braces, character references,
      and predefined entity references and normalizes the character
      sequence as a text node containing the string of characters.</p><mapping><xquery><expression><map><a href="#doc-fs-DirCharsUnit"><emph>DirCharsUnit</emph></a></map><a href="#jd_map_element_content" class="judgment"><subscript>ElementContentUnit</subscript></a></expression></xquery><core><expression>text { <map> <a href="#doc-fs-DirCharsUnit"><emph>DirCharsUnit</emph></a>
       </map><a href="#jd_map_element_content" class="judgment"><subscript>DirCharsUnit<phrase diff="del" at="E052">s</phrase></subscript></a> }</expression></core></mapping><p>The application of <map/><a href="#jd_map_element_content" class="judgment"><subscript>DirCharsUnit<phrase diff="del" at="E052">s</phrase></subscript></a> to
    <a href="#doc-fs-DirCharsUnit"><emph>DirCharsUnit</emph></a> is defined informally. It produces a string
    literal corresponding to the content of the <a href="#doc-fs-DirCharsUnit"><emph>DirCharsUnit</emph></a>, in
    <phrase diff="add" at="E052">which</phrase>
    boundary whitespace is processed
    <phrase diff="add" at="E052">as specified in <xspecref spec="XQ" ref="id-whitespace"/>,</phrase>
    and non-literal characters
    (CharRefs, PredefinedEntityRefs, CDataSections, and
    escaped-braces) are resolved according to the rules in <xspecref spec="XQ" ref="id-content"/>.</p><p>XML processing instructions and comments in element content are
    normalized by applying the standard normalization rules for
    expressions, which appear in <specref ref="sec_other_constructors"/>.</p><mapping><xquery><expression><map><emph>DirPIConstructor</emph></map><a href="#jd_map_element_content" class="judgment"><subscript>ElementContentUnit</subscript></a></expression></xquery><core><expression><map><emph>DirPIConstructor</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression></core></mapping><mapping><xquery><expression><map><emph>DirCommentConstructor</emph></map><a href="#jd_map_element_content" class="judgment"><subscript>ElementContentUnit</subscript></a></expression></xquery><core><expression><map><emph>DirCommentConstructor</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression></core></mapping><p>A direct element constructor is normalized using the
    normalization rule for expressions.</p><mapping><xquery><expression><map><emph>DirElemConstructor</emph></map><a href="#jd_map_element_content" class="judgment"><subscript>ElementContentUnit</subscript></a></expression></xquery><core><expression><map><emph>DirElemConstructor</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression></core></mapping><p>An enclosed expression in element content is normalized
    <phrase diff="del" at="E029">by
    normalizing each individual expression in its expression sequence
    and then constructing a sequence of the normalized values:
    </phrase>
    <phrase diff="add" at="E029">
    into a call to the function <a href="#sec_items_to_nodes"><emph>fs:</emph><code>item-sequence-to-node-sequence</code></a>,
    which implements various rules for converting
    a sequence of atomic values and nodes
    into a sequence of nodes before element construction.
    </phrase></p><mapping><xquery><expression><map>
            {
            <phrase diff="del" at="E029"><emph>Expr</emph><subscript>1</subscript>, ..., <emph>Expr</emph><subscript>n</subscript></phrase>
            <phrase diff="add" at="E029"><emph>Expr</emph></phrase>
            }
          </map><a href="#jd_map_element_content" class="judgment"><subscript>ElementContentUnit</subscript></a></expression></xquery><core><expression>
            <phrase diff="del" at="E029">
            <map> <emph>Expr</emph><subscript>1</subscript> </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> , ..., <map> <emph>Expr</emph><subscript>n</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
            </phrase>
            <phrase diff="add" at="E029">
            <a href="#sec_items_to_nodes"><emph>fs:</emph><code>item-sequence-to-node-sequence</code></a>(( <map><emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> ))
            </phrase>
          </expression></core></mapping></smnorm><smtype><p>There are no additional static typing rules for direct XML
        element or attribute constructors.</p></smtype><smeval><p>There are no additional dynamic evaluation rules for direct
        XML element or attribute constructors.</p></smeval><div4 id="sec_direct_attributes"><head>Attributes</head><p>Like direct element constructors, direct attribute
        constructors are normalized to computed attribute
        constructors.</p><smnotation><p id="jd_map_attr_content">The auxiliary mapping rules
        <map/><a href="#jd_map_attribute" class="judgment"><subscript>Attribute</subscript></a>,
        <phrase diff="add" at="E001">
        <map/><a href="#jd_map_dir_attribute_value" class="judgment"><subscript>DirAttributeValue</subscript></a>,
        </phrase>
        <map/><a href="#jd_map_attr_content" class="judgment"><subscript>AttributeContent</subscript></a>,
        <map/><a href="#jd_map_attr_content" class="judgment"><subscript>AttributeContentUnit</subscript></a>,
        and
        <phrase diff="add" at="E001">
        <map/><a href="#jd_map_attribute_chars_unit" class="judgment"><subscript>AttributeCharsUnit</subscript></a>,
        </phrase>
        are defined in
        this section and are used for the normalization of direct
        attribute constructors.</p><p>We use the following grammar productions to represent
        <emph>AttributeContentUnit</emph>s, i.e., the expressions used to
        compute the content of an attribute.</p><scrap diff="chg" at="E001" headstyle="show"><head/><prodrecap id="AttributeContentUnits" ref="AttributeContentUnits" orig="formal"/><prodrecap id="AttributeContentUnit" ref="AttributeContentUnit" orig="formal"/><prodrecap id="AttributeCharsUnit" ref="AttributeCharsUnit" orig="formal"/></scrap><p diff="add" at="E001">
      An <emph>AttributeCharsUnit</emph> is required to be maximal,
      i.e., it must extend as far as possible in both directions.
      In other words, an <emph>AttributeContentUnits</emph>
      must not contain two adjacent <emph>AttributeCharsUnit</emph>s.
      </p></smnotation><smnorm><p id="sec_attribute_normalization">Direct attributes may
        contain namespace-declaration attributes.  The normalization
        rules in this section ignore namespace-declaration attributes
        -- they are handled by the normalization rules in <specref ref="sec_namespace_attrs"/>.</p><p>A <emph>DirAttributeList</emph> is normalized by the following
        rule, which maps each of the individual attribute-value
        expressions in the attribute list and constructs a sequence of
        the normalized values.</p><mapping><xquery><expression>
      <map><table summary=""><tbody><tr><td rowspan="1" colspan="1">
          <emph>QName</emph><subscript>1</subscript> S? = S? <a href="#doc-xquery-DirAttributeValue"><emph>DirAttributeValue</emph></a><subscript>1</subscript>
      </td></tr><tr><td rowspan="1" colspan="1">
          ...
      </td></tr><tr><td rowspan="1" colspan="1">
          <emph>QName</emph><subscript>n</subscript> S? = S? <a href="#doc-xquery-DirAttributeValue"><emph>DirAttributeValue</emph></a><subscript>n</subscript>
      </td></tr></tbody></table></map><a href="#jd_map_attribute" class="judgment"><subscript>Attribute</subscript></a>
        </expression></xquery><core><expression>
      <table summary=""><tbody><tr><td rowspan="1" colspan="1">
        (<map><emph>QName</emph><subscript>1</subscript> S? = S? <a href="#doc-xquery-DirAttributeValue"><emph>DirAttributeValue</emph></a><subscript>1</subscript> </map><a href="#jd_map_attribute" class="judgment"><subscript>Attribute</subscript></a>
      </td></tr><tr><td rowspan="1" colspan="1">
         ..., 
      </td></tr><tr><td rowspan="1" colspan="1">
        <map><emph>QName</emph><subscript>n</subscript> S? = S? <a href="#doc-xquery-DirAttributeValue"><emph>DirAttributeValue</emph></a><subscript>n</subscript></map><a href="#jd_map_attribute" class="judgment"><subscript>Attribute</subscript></a>)
      </td></tr></tbody></table>
      </expression></core></mapping><p id="jd_map_attribute">Namespace-declaration attributes, i.e.,
      those attributes whose prefix is <code>xmlns</code> are ignored
      by mapping them to the empty sequence.</p><mapping><xquery><expression>
<table summary=""><tbody><tr><td rowspan="1" colspan="1">
      <map><emph>Prefix</emph>:<emph>LocalPart</emph> S? = S?
      <a href="#doc-xquery-DirAttributeValue"><emph>DirAttributeValue</emph></a></map><a href="#jd_map_attribute" class="judgment"><subscript>Attribute</subscript></a>
</td></tr><tr><td rowspan="1" colspan="1">
      (<emph>Prefix</emph> = <code>xmlns</code>)
</td></tr></tbody></table>
        </expression></xquery><core><expression>
        ()
      </expression></core></mapping><p>All attributes that are not namespace-declaration attributes
      are mapped to computed attribute constructors.</p><mapping><xquery><expression>
<table summary=""><tbody><tr><td rowspan="1" colspan="1">
      <map><emph>Prefix</emph>:<emph>LocalPart</emph> S? = S?
      <phrase diff="chg" at="E001"><a href="#doc-xquery-DirAttributeValue"><emph>DirAttributeValue</emph></a></phrase></map><a href="#jd_map_attribute" class="judgment"><subscript>Attribute</subscript></a>
</td></tr><tr><td rowspan="1" colspan="1">
      <a href="#jd_not" class="judgment"><term>not</term></a>(<emph>Prefix</emph> = <code>xmlns</code>)
</td></tr></tbody></table>
        </expression></xquery><core><expression>
        attribute <emph>Prefix</emph>:<emph>LocalPart</emph>
        {
          <map>
            <phrase diff="chg" at="E001"><map><a href="#doc-xquery-DirAttributeValue"><emph>DirAttributeValue</emph></a></map><a href="#jd_map_dir_attribute_value" class="judgment"><subscript>DirAttributeValue</subscript></a></phrase>
          </map><a href="#jd_map_attr_content" class="judgment"><subscript>AttributeContent</subscript></a>
        }
      </expression></core></mapping><p id="jd_map_dir_attribute_value" diff="add" at="E001">
        The effect of
        <map><a href="#doc-xquery-DirAttributeValue"><emph>DirAttributeValue</emph></a></map><a href="#jd_map_dir_attribute_value" class="judgment"><subscript>DirAttributeValue</subscript></a>
        is not specified formally;
        informally, it partitions the content of <a href="#doc-xquery-DirAttributeValue"><emph>DirAttributeValue</emph></a>
        into a sequence of <emph>AttributeContentUnit</emph>s,
        each of which is either
        an enclosed expression (<emph>EnclosedExpr</emph>)
        or
        a maximal run of character content (<emph>AttributeCharsUnit</emph>).
        These content units are then normalized via <map/><a href="#jd_map_attr_content" class="judgment"><subscript>AttributeContent</subscript></a>,
        which is defined below.
      </p><p diff="del" at="E011">As with literal XML elements, we need to distinguish between
      direct attribute constructors that contain one attribute-content
      unit and those that contain multiple attribute-content units,
      because the rule for converting sequences of atomic values into
      strings is applied to sequences within distinct enclosed
      expressions.  If the direct attribute constructor contains
      exactly one attribute-content unit, we simply normalize that
      unit by applying the normalization rule for attribute content
      units:</p><mapping diff="del" at="E011"><xquery><expression><map> <emph>AttributeContentUnit</emph><subscript>1</subscript>
          </map><a href="#jd_map_attr_content" class="judgment"><subscript>AttributeContent</subscript></a></expression></xquery><core><expression>
          <map><emph>AttributeContentUnit</emph><subscript>1</subscript></map><a href="#jd_map_attr_content" class="judgment"><subscript>AttributeContentUnit</subscript></a>
        </expression></core></mapping><p>
      <phrase diff="chg" at="E011">
      To apply <map/><a href="#jd_map_attr_content" class="judgment"><subscript>AttributeContent</subscript></a> to zero or more attribute-content units,
      </phrase>
      we normalize each unit individually and
      construct a sequence of the normalized results<phrase diff="del" at="E031"> interleaved with
      empty text nodes.  The empty text nodes guarantee that the
      results of evaluating consecutive attribute-content units can be
      distinguished</phrase>.  Then we apply the function
      <phrase diff="del" at="E031">
      <a href="#sec_item_seq_to_untypedAtomic"><emph>fs:</emph><code>item-sequence-to-untypedAtomic</code></a>, which applies the appropriate
      conversion rules to the normalized attribute content:
      </phrase>
      <phrase diff="add" at="E031">
      <code>fn:string-join</code>, which will concatenate the values of the normalized units.
      </phrase>
      </p><mapping><xquery><expression><map> <emph>AttributeContentUnit</emph><subscript>1</subscript> ...
          <emph>AttributeContentUnit</emph><subscript>n</subscript>
          </map><a href="#jd_map_attr_content" class="judgment"><subscript>AttributeContent</subscript></a></expression></xquery><core><expression>
          <phrase diff="del" at="E031"><a href="#sec_item_seq_to_untypedAtomic"><emph>fs:</emph><code>item-sequence-to-untypedAtomic</code></a></phrase>
          <phrase diff="add" at="E031">fn:string-join</phrase>
          ((<map> <emph>AttributeContentUnit</emph><subscript>1</subscript>
          </map><a href="#jd_map_attr_content" class="judgment"><subscript>AttributeContentUnit</subscript></a> ,
          <phrase diff="del" at="E031">text { "" },</phrase>
          ...,
          <phrase diff="del" at="E031">text {""},</phrase>
          <map>
          <emph>AttributeContentUnit</emph><subscript>n</subscript></map><a href="#jd_map_attr_content" class="judgment"><subscript>AttributeContentUnit</subscript></a>)
          <phrase diff="add" at="E031">, ''</phrase>
          )
        </expression></core></mapping><p diff="add" at="E011">
        (Note that this rule should be understood to cover
        the degenerate cases of n=0 and n=1,
        where the attribute constructor's content
        consists of zero or one attribute-content units.)
      </p><p diff="del" at="E001">Literal characters, escaped curly braces, character
      references, and predefined entity references in attribute
      content are treated as in element content.  In addition, the
      normalization rule for characters in attributes assumes:</p><olist diff="del" at="E001"><item><p>that an escaped single or double quote is converted
        to an individual single or double quote.</p></item></olist><p diff="del" at="E001">The following normalization rules take the longest
      consecutive sequence of individual characters that include
      literal characters, escaped curly braces, escaped quotes,
      character references, predefined entity references, and escaped
      single and double quotes and normalizes the character sequence
      as a string. </p><mapping diff="del" at="E001"><xquery><expression><map>( <emph>Char</emph> | <emph>CharRef</emph> |
          <emph>EscapeQuot</emph> | <emph>EscapeApos</emph> | <emph>PredefinedEntityRef</emph>
          ) +</map><a href="#jd_map_attr_content" class="judgment"><subscript>AttributeContentUnit</subscript></a></expression></xquery><core><expression><code>fn:codepoints-to-string</code>(( <emph>Char</emph> | <emph>CharRef</emph> |
          <emph>EscapeQuot</emph> | <emph>EscapeApos</emph> | <emph>PredefinedEntityRef</emph>
          )+)</expression></core></mapping><p diff="add" at="E001">
      The next two rules specify the normalization of each attribute-content unit
      via <map/><a href="#jd_map_attr_content" class="judgment"><subscript>AttributeContentUnit</subscript></a>.
      </p><p diff="add" at="E001">
      We normalize an <emph>AttributeCharsUnit</emph>
        (i.e., a maximal run of attribute-content characters, including
        literal characters,
        character references,
        predefined entity references,
        escaped curly braces,
        and escaped single and double quotes)
      by converting it into a string literal.
      </p><mapping diff="add" at="E001"><xquery><expression>
            <map>
              <phrase diff="chg" at="E001"><emph>AttributeCharsUnit</emph></phrase>
            </map><a href="#jd_map_attr_content" class="judgment"><subscript>AttributeContentUnit</subscript></a>
          </expression></xquery><core><expression diff="chg" at="E001">
            <map>
              <emph>AttributeCharsUnit</emph>
            </map><a href="#jd_map_attribute_chars_unit" class="judgment"><subscript>AttributeCharsUnit</subscript></a>
          </expression></core></mapping><p id="jd_map_attribute_chars_unit" diff="add" at="E001">
        The effect of <map><emph>AttributeCharsUnit</emph></map><a href="#jd_map_attribute_chars_unit" class="judgment"><subscript>AttributeCharsUnit</subscript></a>
        is not specified formally;
        informally, it
        unescapes any escaped braces or quotes,
        performs attribute value normalization
        as specified in <xspecref spec="XQ" ref="id-attributes"/>,
        and then represents the resulting string value
        as a string literal.
      </p><p>We normalize an enclosed expression
      <phrase diff="del" at="E031">
      by normalizing each
      individual expression in its expression sequence and then
      constructing a sequence of the normalized values:
      </phrase>
      <phrase diff="add" at="E031">
      into a call to the function <a href="#sec_item_seq_to_string"><emph>fs:</emph><code>item-sequence-to-string</code></a>,
      which implements various rules
      for converting a sequence of atomic values and nodes
      into a string.
      </phrase>
      </p><mapping><xquery><expression><map> {
          <phrase diff="del" at="E031"><emph>Expr</emph><subscript>1</subscript>, ..., <emph>Expr</emph><subscript>n</subscript></phrase>
          <phrase diff="add" at="E031"><emph>Expr</emph></phrase>
          }
          </map><a href="#jd_map_attr_content" class="judgment"><subscript>AttributeContentUnit</subscript></a></expression></xquery><core><expression>
          <phrase diff="del" at="E031">(<map> <emph>Expr</emph><subscript>1</subscript> </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> , ..., <map> <emph>Expr</emph><subscript>n</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)</phrase>
          <phrase diff="add" at="E031"><a href="#sec_item_seq_to_string"><emph>fs:</emph><code>item-sequence-to-string</code></a>(( <map> <emph>Expr</emph> </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> ))</phrase>
        </expression></core></mapping></smnorm></div4><div4 id="sec_namespace_attrs"><head>Namespace Declaration Attributes</head><smnotation><p id="jd_map_namespace_attr">The auxiliary mapping rules
        <map/><a href="#jd_map_namespace_attr" class="judgment"><subscript>NamespaceAttr</subscript></a>, and
        <map/><a href="#jd_map_namespace_attr" class="judgment"><subscript>NamespaceAttrs</subscript></a> are defined in this
        section and are used for the normalization of namespace
        declaration attributes.</p></smnotation><smnorm><p>Some direct attributes may be namespace-declaration
        attributes.  The normalization rules for namespace-declaration
        attributes ignore all non-namespace attributes -- they are
        handled by the normalization rules in <specref ref="sec_direct_attributes"/>.</p><p>A <emph>DirAttributeList</emph> containing namespace-declaration
        attributes is normalized by the following rule, which maps
        each of the individual namespace-declaration attributes in the
        attribute list and constructs a sequence of the normalized
        namespace attribute values.</p><mapping><xquery><expression>
      <map><table summary=""><tbody><tr><td rowspan="1" colspan="1">
          <emph>QName</emph><subscript>1</subscript> S? = S? <a href="#doc-xquery-DirAttributeValue"><emph>DirAttributeValue</emph></a><subscript>1</subscript>
      </td></tr><tr><td rowspan="1" colspan="1">
          ...
      </td></tr><tr><td rowspan="1" colspan="1">
          <emph>QName</emph><subscript>n</subscript> S? = S? <a href="#doc-xquery-DirAttributeValue"><emph>DirAttributeValue</emph></a><subscript>n</subscript>
      </td></tr></tbody></table></map><a href="#jd_map_namespace_attr" class="judgment"><subscript>NamespaceAttrs</subscript></a>
        </expression></xquery><core><expression>
      <table summary=""><tbody><tr><td rowspan="1" colspan="1">
        (<map><emph>QName</emph><subscript>1</subscript> S? = S? <a href="#doc-xquery-DirAttributeValue"><emph>DirAttributeValue</emph></a><subscript>1</subscript></map><a href="#jd_map_namespace_attr" class="judgment"><subscript>NamespaceAttr</subscript></a>
      </td></tr><tr><td rowspan="1" colspan="1">
         ..., 
      </td></tr><tr><td rowspan="1" colspan="1">
        <map><emph>QName</emph><subscript>n</subscript> S? = S? <a href="#doc-xquery-DirAttributeValue"><emph>DirAttributeValue</emph></a><subscript>n</subscript></map><a href="#jd_map_namespace_attr" class="judgment"><subscript>NamespaceAttr</subscript></a>)
      </td></tr></tbody></table>
      </expression></core></mapping><p>Attributes whose prefix is not <code>xmlns</code> are ignored
      by mapping them to the empty sequence.</p><mapping><xquery><expression>
<table summary=""><tbody><tr><td rowspan="1" colspan="1">
      <map><emph>Prefix</emph>:<emph>LocalPart</emph> S? = S? <a href="#doc-xquery-DirAttributeValue"><emph>DirAttributeValue</emph></a></map><a href="#jd_map_namespace_attr" class="judgment"><subscript>NamespaceAttr</subscript></a>
</td></tr><tr><td rowspan="1" colspan="1">
      <a href="#jd_not" class="judgment"><term>not</term></a>(<emph>Prefix</emph> = <code>xmlns</code>)
</td></tr></tbody></table>
</expression></xquery><core><expression>
        ()
      </expression></core></mapping><p>Namespace-declaration attributes are normalized to local
      namespace declarations (<phrase diff="chg" at="E002"><a href="#doc-core-LocalNamespaceDecl"><emph>LocalNamespaceDecl</emph></a></phrase>). The content of
      such attributes must be defined with a URI literal.</p><mapping><xquery><expression>
<table summary=""><tbody><tr><td rowspan="1" colspan="1">
      <map><emph>Prefix</emph>:<emph>LocalPart</emph> S? = S? " <emph>URILiteral</emph> "</map><a href="#jd_map_namespace_attr" class="judgment"><subscript>NamespaceAttr</subscript></a>
</td></tr><tr><td rowspan="1" colspan="1">
      (<emph>Prefix</emph> = <code>xmlns</code>)
</td></tr></tbody></table>
        </expression></xquery><core><expression>
        namespace <emph>LocalPart</emph> { <emph>URILiteral</emph> }
      </expression></core></mapping></smnorm></div4><div4 id="sec_content"><head>Content</head><p>The rules for normalizing element content are given above in
<specref ref="id_element_constructor"/>.</p></div4><div4 id="sec_whitespace"><head>Boundary Whitespace</head><p><xspecref spec="XQ" ref="id-whitespace"/> describes how
      whitespace is processed in element constructors depending on the
      value of the <code>boundary-space</code> declaration in the
      query prolog. The Formal Semantics assumes that the rules for
      handling whitespace are applied by the (informally defined)
      auxiliary rule <map/><a href="#jd_map_element_content" class="judgment"><subscript>DirCharsUnit<phrase diff="del" at="E052">s</phrase></subscript></a>.</p></div4></div3><!-- ***************** PI and Comments       ****** --><div3 id="sec_other_constructors"><head>Other Direct Constructors</head><scrap headstyle="show"><head>Other Constructors</head><prodrecap id="DirPIConstructor" ref="DirPIConstructor" orig="xquery"/><prodrecap id="DirPIContents" ref="DirPIContents" orig="xquery"/><prodrecap id="DirCommentConstructor" ref="DirCommentConstructor" orig="xquery"/><prodrecap id="DirCommentContents" ref="DirCommentContents" orig="xquery"/></scrap><smnotation><p id="jd_map_characters">The auxiliary mapping rule
      <map/><a href="#jd_map_characters" class="judgment"><subscript>Characters</subscript></a> is defined in this section and
      used for the normalization of direct PI and comment
      constructors.</p><p><map><emph>Char</emph>*</map><a href="#jd_map_characters" class="judgment"><subscript>Characters</subscript></a> takes the character
      content of a PI or comment constructor and yields a
      corresponding <emph>StringLiteral</emph>.</p></smnotation><smnorm><p>A literal XML processing instruction is normalized into a
      computed processing-instruction constructor; its character
      content is converted to a string using the auxiliary mapping
      rule <map/><a href="#jd_map_characters" class="judgment"><subscript>Characters</subscript></a>.</p><mapping><xquery><expression>
      <map>&lt;? <emph>NCName</emph> <emph>DirPIContents</emph> ?&gt;</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
     </expression></xquery><core><expression>
      <map>processing-instruction <emph>NCName</emph> { <map><emph>DirPIContents</emph></map><a href="#jd_map_characters" class="judgment"><subscript>Characters</subscript></a> }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
     </expression></core></mapping><p>A literal XML comment is normalized into a computed comment
    constructor; its character content is converted to a string using
    the auxiliary mapping rule <map/><a href="#jd_map_characters" class="judgment"><subscript>Characters</subscript></a>.</p><mapping><xquery><expression>
     <map>&lt;!-- <emph>DirCommentContents</emph> --&gt;</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
    </expression></xquery><core><expression>
     <map>comment { <map><emph>DirCommentContents</emph></map><a href="#jd_map_characters" class="judgment"><subscript>Characters</subscript></a> }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
    </expression></core></mapping></smnorm><smtype><p>There are no additional static typing rules for direct
      processing-instruction or comment constructors.</p></smtype><smeval><p>There are no additional dynamic evaluation rules for direct
      processing-instruction or comment constructors.</p></smeval></div3><div3 id="sec_computedConstructors"><head>Computed Constructors</head><scrap headstyle="show"><head>Computed Constructors</head><prodrecap id="ComputedConstructor" ref="ComputedConstructor" orig="xquery"/></scrap><div4 id="sec_comp_elem_constructor"><head>Computed Element Constructors</head><smintro><p>This section describes the semantics of computed
    element constructors. Remember that direct element constructors
    are normalized into computed element constructors. This document
    does not formally specify how namespaces are copied. The semantics
    of namespaces copying in element constructors can be found in
    <bibref ref="xquery-30"/>.</p></smintro><scrap headstyle="show"><head/><prodrecap id="CompElemConstructor" ref="CompElemConstructor" orig="xquery"/><prodrecap id="ContentExpr" ref="ContentExpr" orig="xquery"/></scrap><!--
    <smnotation>
      <p id="jd_split_namespaces">Local namespace declarations may
      occur explicitly in a computed element constructor or may be the
      result of normalizing namespace-declaration attributes contained
      in direct element constructors.  For local element declarations
      that occur explicitly in a query, the immediately enclosing
      expression of the local namespace declaration
      (<phrase diff='chg' at='E002'>&gr_LocalNamespaceDecl;</phrase>) must be a computed element constructor;
      otherwise, as specified in &language;, a static error is
      raised.</p>
    </smnotation>
--><smcore><p>The Core grammar productions for computed element
      constructors are:</p><scrap diff="chg" at="E002" headstyle="show"><head>Computed Element Constructors</head><prodrecap id="core-CompElemConstructor" ref="CompElemConstructor" orig="core"/><prodrecap id="core-ContentExpr" ref="ContentExpr" orig="core"/><prodrecap id="LocalNamespaceDecls" ref="LocalNamespaceDecls" orig="core"/><prodrecap id="LocalNamespaceDecl" ref="LocalNamespaceDecl" orig="core"/></scrap></smcore><smnorm><p>If the content expression is missing, the computed element
      constructor is normalized as if its content expression was the
      empty sequence.</p><mapping><xquery><expression>
         <map>element <emph>QName</emph> { }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
        </expression></xquery><core><expression>
         <map>element <emph>QName</emph> { () }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
        </expression></core></mapping><p>Computed element constructors are normalized using the
      <a href="#sec_items_to_nodes"><emph>fs:</emph><code>item-sequence-to-node-sequence</code></a> function over their content
      expression.</p><mapping><xquery><expression>
         <map>element <emph>QName</emph> { <emph>Expr</emph> }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
        </expression></xquery><core><expression>
         element <emph>QName</emph> { <a href="#sec_items_to_nodes"><emph>fs:</emph><code>item-sequence-to-node-sequence</code></a>((<map><emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)) }<phrase diff="add" at="E003"> {}</phrase>
        </expression></core></mapping><p>When the name of the element is also computed, the
      normalization rule applies atomization to the name
      expression.</p><mapping><xquery><expression>
         <map>element { <emph>Expr</emph><subscript>1</subscript> } { <emph>Expr</emph><subscript>2</subscript> }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
        </expression></xquery><core><expression>
          element { <code>fn:data</code>((<map><emph>Expr</emph><subscript>1</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)) }{ <a href="#sec_items_to_nodes"><emph>fs:</emph><code>item-sequence-to-node-sequence</code></a>((<map><emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)) }<phrase diff="add" at="E003"> {}</phrase>
        </expression></core></mapping></smnorm><smnotation><p id="jd_add_namespace_bindings">The following auxiliary
      judgment adds a sequence of namespace bindings to the static
      context.</p><display>
          <clause><expression><a href="#jd_add_namespace_bindings" class="judgment"><term>add namespace bindings</term></a>
          <phrase diff="chg" at="E002"><a href="#doc-core-LocalNamespaceDecls"><emph>LocalNamespaceDecls</emph></a></phrase> <a href="#jd_add_namespace_bindings" class="judgment"><term>to</term></a>
          <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> <a href="#jd_add_namespace_bindings" class="judgment"><term>yields</term></a>
          <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></expression></clause>
        </display><p>This judgment is defined as follows.</p><infergr><infer><prejudge/><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
                    <a href="#jd_add_namespace_bindings" class="judgment"><term>add namespace bindings</term></a> <a href="#jd_add_namespace_bindings" class="judgment"><term>to</term></a>
          <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>0</subscript> <a href="#jd_add_namespace_bindings" class="judgment"><term>yields</term></a>
          <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>0</subscript>
                  </expression></clause></multiclause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><expression><phrase diff="chg" at="E002"><a href="#doc-core-LocalNamespaceDecl"><emph>LocalNamespaceDecl</emph></a><subscript>1</subscript></phrase> = namespace <emph>LocalPart</emph><subscript>1</subscript> { <emph>URILiteral</emph><subscript>1</subscript> }</expression></clause></multiclause><multiclause><clause><expression>
                    ...
                  </expression></clause></multiclause><multiclause><clause><expression><phrase diff="chg" at="E002"><a href="#doc-core-LocalNamespaceDecl"><emph>LocalNamespaceDecl</emph></a><subscript>n</subscript></phrase> = namespace <emph>LocalPart</emph><subscript>n</subscript> { <emph>URILiteral</emph><subscript>n</subscript> }</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_default_dyn_env" class="env">dynEnvDefault</a></environment><expression><emph>URILiteral</emph><subscript>1</subscript> <a href="#jd_has_atomic_value" class="judgment"><term>has atomic value</term></a> <emph>AnyURI</emph>
 	    </expression></clause></multiclause><multiclause><clause><expression>
                ...
              </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_default_dyn_env" class="env">dynEnvDefault</a></environment><expression><emph>URILiteral</emph><subscript>1</subscript> <a href="#jd_has_atomic_value" class="judgment"><term>has atomic value</term></a> <emph>AnyURI</emph>
 	    </expression></clause></multiclause><multiclause><clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript>.<a href="#xq_ns_env" class="env">namespace</a> =
              <update><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>0</subscript>.<a href="#xq_ns_env" class="env">namespace</a></environment><expression><emph>LocalPart</emph><subscript>1</subscript> =&gt; (passive, <emph>AnyURI</emph><subscript>1</subscript>)</expression></update></expression></clause></multiclause><multiclause><clause><expression>
                    ...
                  </expression></clause></multiclause><multiclause><clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>n</subscript>.<a href="#xq_ns_env" class="env">namespace</a> =
              <update><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>n-1</subscript>.<a href="#xq_ns_env" class="env">namespace</a></environment><expression><emph>LocalPart</emph><subscript>n</subscript> =&gt; (passive, <emph>AnyURI</emph><subscript>n</subscript>)</expression></update></expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
                    <a href="#jd_add_namespace_bindings" class="judgment"><term>add namespace bindings</term></a>
          <phrase diff="chg" at="E002"><a href="#doc-core-LocalNamespaceDecl"><emph>LocalNamespaceDecl</emph></a><subscript>1</subscript> ... <a href="#doc-core-LocalNamespaceDecl"><emph>LocalNamespaceDecl</emph></a><subscript>n</subscript></phrase> <a href="#jd_add_namespace_bindings" class="judgment"><term>to</term></a>
          <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>0</subscript> <a href="#jd_add_namespace_bindings" class="judgment"><term>yields</term></a>
          <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>n</subscript>
                  </expression></clause></multiclause></postjudge></infer></infergr></smnotation><smtype><p>The normalization rules of direct element and attribute
      constructors leave us with only the computed forms of
      constructors. The static semantics for constructors is defined
      on all the computed forms. The computed element constructor
      itself has two forms: one in which the element name is a literal
      <emph>QName</emph>, and the other in which the element name is a
      computed expression.</p><p>A computed element constructor creates a new element with
      either the <xtermref spec="XQ" ref="dt-type-annotation"/>
      <a href="#dt-xs_untyped"><code>xs:untyped</code></a> (in strip construction mode), or with the <xtermref spec="XQ" ref="dt-type-annotation"/> <code>xs:anyType</code> (in preserve
      construction mode). The content expression must return a
      <phrase diff="chg" at="E012">
      sequence of nodes with attribute nodes at the beginning.
      </phrase>
      </p><infergr><infer><prejudge><multiclause><clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_construction_mode_env" class="env">constructionMode</a> = preserve</expression></clause></multiclause><multiclause><clause><expression><a href="#jd_add_namespace_bindings" class="judgment"><term>add namespace bindings</term></a>
               <phrase diff="chg" at="E002"><a href="#doc-core-LocalNamespaceDecls"><emph>LocalNamespaceDecls</emph></a></phrase> <a href="#jd_add_namespace_bindings" class="judgment"><term>to</term></a>
               <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> <a href="#jd_add_namespace_bindings" class="judgment"><term>yields</term></a>
               <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></environment><expression><emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause></multiclause><multiclause><clause diff="chg" at="E012"><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
              attribute<phrase diff="add" at="E023"> *</phrase>*, (element<phrase diff="add" at="E023"> *</phrase> | text | comment | processing-instruction<phrase diff="add" at="E022"> *</phrase>) * </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></environment><expression> element <emph>QName</emph> {
	            <emph>Expr</emph> } { <phrase diff="chg" at="E002"><a href="#doc-core-LocalNamespaceDecls"><emph>LocalNamespaceDecls</emph></a></phrase> }
	            <a href="#jd_has_type" class="judgment"><term>:</term></a> element <emph>QName</emph> of type <code>xs:anyType</code>
	      </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_construction_mode_env" class="env">constructionMode</a> = strip</expression></clause></multiclause><multiclause><clause><expression><a href="#jd_add_namespace_bindings" class="judgment"><term>add namespace bindings</term></a>
               <phrase diff="chg" at="E002"><a href="#doc-core-LocalNamespaceDecls"><emph>LocalNamespaceDecls</emph></a></phrase> <a href="#jd_add_namespace_bindings" class="judgment"><term>to</term></a>
               <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> <a href="#jd_add_namespace_bindings" class="judgment"><term>yields</term></a>
               <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></environment><expression><emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause></multiclause><multiclause><clause diff="chg" at="E012"><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
                      attribute<phrase diff="add" at="E023"> *</phrase>*, (element<phrase diff="add" at="E023"> *</phrase> | text | comment | processing-instruction<phrase diff="add" at="E022"> *</phrase>) * </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></environment><expression> element <emph>QName</emph> {
	            <emph>Expr</emph> } { <phrase diff="chg" at="E002"><a href="#doc-core-LocalNamespaceDecls"><emph>LocalNamespaceDecls</emph></a></phrase> }
	            <a href="#jd_has_type" class="judgment"><term>:</term></a> element <emph>QName</emph> of type <a href="#dt-xs_untyped"><code>xs:untyped</code></a>
	      </expression></clause></postjudge></infer></infergr><p>In case the element name is computed as well, the name
      expression must be of type <code>xs:QName</code>, <code>xs:string</code>, or
      <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>.</p><infergr><infer><prejudge><multiclause><clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_construction_mode_env" class="env">constructionMode</a> = preserve</expression></clause></multiclause><multiclause><clause><expression><a href="#jd_add_namespace_bindings" class="judgment"><term>add namespace bindings</term></a>
               <phrase diff="chg" at="E002"><a href="#doc-core-LocalNamespaceDecls"><emph>LocalNamespaceDecls</emph></a></phrase> <a href="#jd_add_namespace_bindings" class="judgment"><term>to</term></a>
               <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> <a href="#jd_add_namespace_bindings" class="judgment"><term>yields</term></a>
               <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></environment><expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
                      (<code>xs:QName</code> | <code>xs:string</code> | <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>) </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></environment><expression><emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression></clause></multiclause><multiclause><clause diff="chg" at="E012"><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
                      attribute<phrase diff="add" at="E023"> *</phrase>*, (element<phrase diff="add" at="E023"> *</phrase> | text | comment | processing-instruction<phrase diff="add" at="E022"> *</phrase>) * </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></environment><expression> element { <emph>Expr</emph><subscript>1</subscript> } { <emph>Expr</emph><subscript>2</subscript> }
	            { <phrase diff="chg" at="E002"><a href="#doc-core-LocalNamespaceDecls"><emph>LocalNamespaceDecls</emph></a></phrase> }
	            <a href="#jd_has_type" class="judgment"><term>:</term></a> element<phrase diff="add" at="E023"> *</phrase> of type <code>xs:anyType</code>
	      </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_construction_mode_env" class="env">constructionMode</a> = strip</expression></clause></multiclause><multiclause><clause><expression><a href="#jd_add_namespace_bindings" class="judgment"><term>add namespace bindings</term></a>
               <phrase diff="chg" at="E002"><a href="#doc-core-LocalNamespaceDecls"><emph>LocalNamespaceDecls</emph></a></phrase> <a href="#jd_add_namespace_bindings" class="judgment"><term>to</term></a>
               <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> <a href="#jd_add_namespace_bindings" class="judgment"><term>yields</term></a>
               <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></environment><expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
                      (<code>xs:QName</code> | <code>xs:string</code> | <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>) </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></environment><expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression></clause></multiclause><multiclause><clause diff="chg" at="E012"><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
                      attribute<phrase diff="add" at="E023"> *</phrase>*, (element<phrase diff="add" at="E023"> *</phrase> | text | comment | processing-instruction<phrase diff="add" at="E022"> *</phrase>) * </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></environment><expression> element { <emph>Expr</emph><subscript>1</subscript> } { <emph>Expr</emph><subscript>2</subscript> }
	            { <phrase diff="chg" at="E002"><a href="#doc-core-LocalNamespaceDecls"><emph>LocalNamespaceDecls</emph></a></phrase> }
	            <a href="#jd_has_type" class="judgment"><term>:</term></a> element<phrase diff="add" at="E023"> *</phrase> of type <a href="#dt-xs_untyped"><code>xs:untyped</code></a>
	      </expression></clause></postjudge></infer></infergr></smtype><smnotation diff="add" at="E029"><p id="jd_with_text_nodes_processed_is">
       The following auxiliary judgment
       is used in the dynamic semantics of node constructors.
       </p><display>
         <clause><expression>
             <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript> <a href="#jd_with_text_nodes_processed_is" class="judgment"><term>with text nodes processed is</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>
           </expression></clause>
       </display><p>
       This judgment is informally defined to hold when
       <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> is obtained by applying the following modifications to <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript>:
       </p><ulist><item><p>
         Adjacent text nodes in <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript> are merged into a single text node
         by concatenating their contents, with no intervening blanks.
         </p></item><item><p>
         After concatenation, any text node whose content is a zero-length string
         is deleted from the sequence.
         </p></item></ulist></smnotation><smeval><p>The following rules take a computed element constructor
       expression and construct an element node.  The dynamic
       semantics for computed element constructors is the most complex
       of all expressions in XQuery.  Here is how to read the rule
       below.</p><p>
       <phrase diff="chg" at="E003"> First, the constructor's</phrase>
       local namespace declarations are evaluated, yielding a
       sequence of namespace bindings.  The static environment is
       extended to include the new namespace bindings, which are all
       <a href="#term_active">active</a>.  In <xspecref spec="XQ" ref="id-namespaces"/>, it is implementation-defined whether
       undeclaration of namespace prefixes (by setting the namespace
       prefix to the zero-length string) in an element constructor is
       supported.  In the dynamic semantics below, we assume all local
       namespace declarations declare a binding of a prefix to a
       URI.</p><p>Second, the expression is evaluated,
       <phrase diff="del" at="E029">
       and the resulting value <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript>
       </phrase>
       <phrase diff="add" at="E029">
       and its value's text nodes are processed. The resulting sequence
       </phrase>
       must match zero-or-more attributes followed by
       zero-or-more element, text, processing-instruction or comment
       nodes.</p><p>Third, the namespace bindings are concatenated with the list
       of active namespaces in the namespace environment <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a>
       and the namespaces corresponding to the element's name and all
       attributes names.  The resulting sequence is the sequence of
       namespace bindings for the element.</p><infergr><infer><prejudge><multiclause><clause><expression><emph>Expr</emph> = <emph>Expr</emph><subscript>0</subscript> </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>n</subscript>; <a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression> <emph>Expr</emph><subscript>0</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript> </expression></clause></multiclause><multiclause diff="add" at="E029"><clause><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript> <a href="#jd_with_text_nodes_processed_is" class="judgment"><term>with text nodes processed is</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
                 <phrase diff="del" at="E029"><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript></phrase>
                 <phrase diff="add" at="E029"><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript></phrase>
                 <a href="#jd_matches" class="judgment"><term>matches</term></a> (attribute<phrase diff="add" at="E023">*</phrase>*, (element<phrase diff="add" at="E023"> *</phrase> | text | processing-instruction<phrase diff="add" at="E022"> *</phrase> | comment)*)
                 </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a>; <a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
		     element <emph>QName</emph> { <emph>Expr</emph> }<phrase diff="add" at="E003"> {}</phrase> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a>
		     element <emph>QName</emph> of type <code>xs:anyType</code> {
		     <phrase diff="del" at="E029"><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript></phrase>
		     <phrase diff="add" at="E029"><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript></phrase>
                     } { }
	       </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><expression> <emph>Expr</emph> = <phrase diff="chg" at="E003"><emph>Expr</emph><subscript>0</subscript></phrase> </expression></clause></multiclause><multiclause diff="add" at="E003"><clause><expression> <a href="#doc-core-LocalNamespaceDecls"><emph>LocalNamespaceDecls</emph></a> = <a href="#doc-core-LocalNamespaceDecl"><emph>LocalNamespaceDecl</emph></a><subscript>1</subscript> ... <a href="#doc-core-LocalNamespaceDecl"><emph>LocalNamespaceDecl</emph></a><subscript>n</subscript></expression></clause></multiclause><multiclause diff="add" at="E003"><clause><expression> <a href="#doc-core-LocalNamespaceDecl"><emph>LocalNamespaceDecl</emph></a><subscript>1</subscript> = namespace <emph>NCName</emph><subscript>1</subscript> { <emph>URILiteral</emph><subscript>1</subscript> }</expression></clause></multiclause><multiclause diff="add" at="E003"><clause><expression>...</expression></clause></multiclause><multiclause diff="add" at="E003"><clause><expression> <a href="#doc-core-LocalNamespaceDecl"><emph>LocalNamespaceDecl</emph></a><subscript>n</subscript> = namespace <emph>NCName</emph><subscript>n</subscript> { <emph>URILiteral</emph><subscript>n</subscript> }</expression></clause></multiclause><multiclause diff="add" at="E003"><clause><environment><a href="#xq_default_dyn_env" class="env">dynEnvDefault</a></environment><expression><emph>URILiteral</emph><subscript>1</subscript> <a href="#jd_has_atomic_value" class="judgment"><term>has atomic value</term></a> <emph>AnyURI</emph><subscript>1</subscript></expression></clause></multiclause><multiclause diff="add" at="E003"><clause><expression>...</expression></clause></multiclause><multiclause diff="add" at="E003"><clause><environment><a href="#xq_default_dyn_env" class="env">dynEnvDefault</a></environment><expression><emph>URILiteral</emph><subscript>n</subscript> <a href="#jd_has_atomic_value" class="judgment"><term>has atomic value</term></a> <emph>AnyURI</emph><subscript>n</subscript></expression></clause></multiclause><multiclause><clause><expression><a href="#doc-fs-NamespaceBinding"><emph>NamespaceBinding</emph></a><subscript>1</subscript> = namespace <emph>NCName</emph><subscript>1</subscript> { <emph>AnyURI</emph><subscript>1</subscript> }</expression></clause></multiclause><multiclause><clause><expression>...</expression></clause></multiclause><multiclause><clause><expression><a href="#doc-fs-NamespaceBinding"><emph>NamespaceBinding</emph></a><subscript>n</subscript> = namespace  <emph>NCName</emph><subscript>n</subscript> { <emph>AnyURI</emph><subscript>n</subscript> }</expression></clause></multiclause><multiclause><clause><expression>
              <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> = 
              <update><environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a></environment><expression><emph>NCName</emph><subscript>1</subscript> =&gt; (active, <emph>AnyURI</emph><subscript>1</subscript>)</expression></update>
            </expression></clause></multiclause><multiclause><clause><expression>...</expression></clause></multiclause><multiclause><clause><expression>
              <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>n</subscript> = 
              <update><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>n-1</subscript>.<a href="#xq_ns_env" class="env">namespace</a></environment><expression><emph>NCName</emph><subscript>n</subscript> =&gt; (active, <emph>AnyURI</emph><subscript>n</subscript>)</expression></update>
            </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>n</subscript>; <a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>Expr</emph><subscript>0</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript> </expression></clause></multiclause><multiclause diff="add" at="E029"><clause><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript> <a href="#jd_with_text_nodes_processed_is" class="judgment"><term>with text nodes processed is</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
                   <phrase diff="del" at="E029"><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript></phrase>
                   <phrase diff="add" at="E029"><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript></phrase>
                   <a href="#jd_matches" class="judgment"><term>matches</term></a> (attribute<phrase diff="add" at="E023">*</phrase>*, (element<phrase diff="add" at="E023"> *</phrase> | text | processing-instruction<phrase diff="add" at="E022"> *</phrase> | comment)*)
                 </expression></clause></multiclause><multiclause><clause><expression><a href="#doc-fs-NamespaceBindings"><emph>NamespaceBindings</emph></a> = 
		 <a href="#doc-fs-NamespaceBinding"><emph>NamespaceBinding</emph></a><subscript>1</subscript>,
		 ..., <a href="#doc-fs-NamespaceBinding"><emph>NamespaceBinding</emph></a><subscript>n</subscript>,
		 <a href="#fs_activeNS">fs:<code>active_ns</code></a>(<a href="#xq_stat_env_def" class="env">statEnv</a>),
		 <a href="#fs_ns_from_items">fs:<code>get_static_ns_from_items</code></a>(<a href="#xq_stat_env_def" class="env">statEnv</a>,
                 <phrase diff="del" at="E029"><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript></phrase>
                 <phrase diff="add" at="E029"><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript></phrase>
                 )</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a>; <a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
		     element <emph>QName</emph> { <emph>Expr</emph> }<phrase diff="add" at="E003"> { <a href="#doc-core-LocalNamespaceDecls"><emph>LocalNamespaceDecls</emph></a> }</phrase> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a>
		     element <emph>QName</emph> of type <code>xs:anyType</code> {
		     <phrase diff="del" at="E029"><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript></phrase>
		     <phrase diff="add" at="E029"><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript></phrase>
                     } { <a href="#doc-fs-NamespaceBindings"><emph>NamespaceBindings</emph></a> }
	       </expression></clause></postjudge></infer></infergr><p>The dynamic evaluation of an element constructor with a
       computed name is similar.  There is one additional rule that
       checks that the value of the element's name expression matches
       <code>xs:QName</code>.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript>
		 </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <code>xs:QName</code>
		 </expression></clause></multiclause><multiclause><clause><expression><emph>QName</emph> = <code>fn:prefix-from-QName</code>(<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript>)<code>:</code><code>fn:local-name-from-QName</code>(<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript>)</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
		     element <emph>QName</emph> { <emph>Expr</emph><subscript>2</subscript> }<phrase diff="add" at="E003"> { <a href="#doc-core-LocalNamespaceDecls"><emph>LocalNamespaceDecls</emph></a> }</phrase> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
	       </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
		     element { <emph>Expr</emph><subscript>1</subscript> } { <emph>Expr</emph><subscript>2</subscript> } <phrase diff="add" at="E003">{ <a href="#doc-core-LocalNamespaceDecls"><emph>LocalNamespaceDecls</emph></a> }</phrase> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
	       </expression></clause></postjudge></infer></infergr></smeval></div4><div4 id="sec_attribute_constructor"><head>Computed Attribute Constructors</head><scrap headstyle="show"><head/><prodrecap id="CompAttrConstructor" ref="CompAttrConstructor" orig="xquery"/></scrap><smcore><p>The Core grammar production for computed attribute
        constructors is:</p><scrap headstyle="show"><head>Computed Attribute Constructors</head><prodrecap id="core-CompAttrConstructor" ref="CompAttrConstructor" orig="core"/></scrap></smcore><smnorm><p>Computed attribute constructors are normalized by mapping
        their name and content expression in a similar way as computed
        element constructors. The normalization rule uses the
        <phrase diff="del" at="E031"><a href="#sec_item_seq_to_untypedAtomic"><emph>fs:</emph><code>item-sequence-to-untypedAtomic</code></a></phrase>
        <phrase diff="add" at="E031"><a href="#sec_item_seq_to_string"><emph>fs:</emph><code>item-sequence-to-string</code></a></phrase>
        function.</p><mapping><xquery><expression>
           <map>attribute <emph>QName</emph> { }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
          </expression></xquery><core><expression>
           <map>attribute <emph>QName</emph> { () }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
          </expression></core></mapping><mapping><xquery><expression>
           <map>attribute <emph>QName</emph> { <emph>Expr</emph> }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
          </expression></xquery><core><expression>attribute <emph>QName</emph> { 
            <phrase diff="del" at="E031"><a href="#sec_item_seq_to_untypedAtomic"><emph>fs:</emph><code>item-sequence-to-untypedAtomic</code></a></phrase>
            <phrase diff="add" at="E031"><a href="#sec_item_seq_to_string"><emph>fs:</emph><code>item-sequence-to-string</code></a></phrase>
            ((<map><emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)) }
          </expression></core></mapping><mapping><xquery><expression>
           <map>attribute { <emph>Expr</emph><subscript>1</subscript> } { <emph>Expr</emph><subscript>2</subscript> }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
          </expression></xquery><core><expression>
            attribute { <code>fn:data</code>((<map><emph>Expr</emph><subscript>1</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)) } { 
            <phrase diff="del" at="E031"><a href="#sec_item_seq_to_untypedAtomic"><emph>fs:</emph><code>item-sequence-to-untypedAtomic</code></a></phrase>
            <phrase diff="add" at="E031"><a href="#sec_item_seq_to_string"><emph>fs:</emph><code>item-sequence-to-string</code></a></phrase>
            ((<map><emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)) }
          </expression></core></mapping></smnorm><smtype><p>The normalization rules for direct attribute constructors
      leave us with only the computed form of the attribute
      constructors.  Like in a computed element constructor, a
      computed attribute constructor has two forms: one in which the
      attribute name is a literal <emph>QName</emph>, and the other in which
      the attribute name is a computed expression.</p><p>In the case of attribute constructors, the <xtermref spec="XQ" ref="dt-type-annotation"/> is always
      <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression> <emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause></multiclause><multiclause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> 
                  <phrase diff="del" at="E031"><a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a></phrase>
                  <phrase diff="add" at="E031"><code>xs:string</code></phrase>
                </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression> attribute <emph>QName</emph> { <emph>Expr</emph> } <a href="#jd_has_type" class="judgment"><term>:</term></a> attribute <emph>QName</emph> of type <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>
	      </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression> <emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
                      (<code>xs:QName</code> | <code>xs:string</code> | <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>) </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> 
                        <phrase diff="del" at="E031"><a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a></phrase>
                        <phrase diff="add" at="E031"><code>xs:string</code></phrase>
                      </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression> attribute { <emph>Expr</emph><subscript>1</subscript> } { <emph>Expr</emph><subscript>2</subscript> }
	            <a href="#jd_has_type" class="judgment"><term>:</term></a> attribute<phrase diff="add" at="E023"> *</phrase> of type <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>
	      </expression></clause></postjudge></infer></infergr></smtype><smeval><p>The following rules take a computed attribute constructor
       expression and construct an attribute node.  The rules are
       similar to those rules for element constructors.  First, the
       attribute's name is expanded into a qualified name.  Second,
       <phrase diff="chg" at="E011">the
       content expression is evaluated in the
       dynamic environment.</phrase> <phrase diff="del" at="E011">Recall from <specref ref="sec_attribute_constructor"/> that during normalization, we
       do not convert the content of direct attribute constructors
       that contain one attribute-content unit.  This guarantees that
       useful type information is preserved for static analysis.
       Since the conversion function <a href="#sec_item_seq_to_untypedAtomic"><emph>fs:</emph><code>item-sequence-to-untypedAtomic</code></a>
       was not applied to all attribute constructors during
       normalization, we have to apply it at evaluation time.  (As
       before, it is possible to elide the application of
       <a href="#sec_item_seq_to_untypedAtomic"><emph>fs:</emph><code>item-sequence-to-untypedAtomic</code></a> injected during normalization
       and the application injected during evaluation.)</phrase></p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><phrase diff="chg" at="E011"><emph>Expr</emph></phrase> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a> </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
		     attribute <emph>QName</emph> { <emph>Expr</emph> } <a href="#jd_yields" class="judgment"><term>=&gt;</term></a>
		     attribute <emph>QName</emph> of type <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> { <a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a> }
	       </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression> <emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>
		 </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <code>xs:QName</code>
		 </expression></clause></multiclause><multiclause><clause><expression><emph>QName</emph><subscript>1</subscript> = <code>fn:prefix-from-QName</code>(<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>)<code>:</code><code>fn:local-name-from-QName</code>(<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>)</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression> <phrase diff="chg" at="E011"><emph>Expr</emph><subscript>2</subscript></phrase> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a><subscript>2</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
		 attribute { <emph>Expr</emph><subscript>1</subscript> } { <emph>Expr</emph><subscript>2</subscript> } <a href="#jd_yields" class="judgment"><term>=&gt;</term></a>
		 attribute <emph>QName</emph><subscript>1</subscript> of type <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> { <a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a><subscript>2</subscript> }
	       </expression></clause></postjudge></infer></infergr></smeval></div4><div4 id="sec_documentConstructors"><head>Document Node Constructors</head><scrap headstyle="show"><head/><prodrecap id="CompDocConstructor" ref="CompDocConstructor" orig="xquery"/></scrap><smcore><p>The Core grammar production for a computed document
      constructor is:</p><scrap headstyle="show"><head>Core computed document constructor</head><prodrecap id="core-CompDocConstructor" ref="CompDocConstructor" orig="core"/></scrap></smcore><smnorm><p>A document node constructor contains an expression, which
      must evaluate to a sequence of element, text, comment, or
      processing-instruction nodes.  <xspecref spec="XQ" ref="id-documentConstructors"/> specifies the rules for
      converting a sequence of atomic values and nodes into a sequence
      of nodes before document construction.  The built-in function
      <phrase diff="del" at="E029"><specref ref="sec_items_to_nodes_doc"/></phrase>
      <phrase diff="add" at="E029"><a href="#sec_items_to_nodes"><emph>fs:</emph><code>item-sequence-to-node-sequence</code></a></phrase>
      implements
      <phrase diff="add" at="E029">most of</phrase>
      this
      conversion.</p><mapping><xquery><expression>
         <map>document { <emph>Expr</emph> }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
        </expression></xquery><core><expression>
          document {
          <phrase diff="del" at="E029"><a href="#sec_items_to_nodes"><emph>fs:</emph><code>item-sequence-to-node-sequence-doc</code></a></phrase>
          <phrase diff="add" at="E029"><a href="#sec_items_to_nodes"><emph>fs:</emph><code>item-sequence-to-node-sequence</code></a></phrase>
          ((<map><emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)) }
        </expression></core></mapping></smnorm><smtype><p><phrase diff="del" at="E029">The static typing rule does not need to check that the type
      of the argument expression is a sequence of element, text,
      processing-instruction, and comment nodes, as it is already
      checked by the <a href="#sec_items_to_nodes"><emph>fs:</emph><code>item-sequence-to-node-sequence-doc</code></a> introduced during
      normalization.</phrase> The type of the entire expression is the most
      general <code>document</code> type, because the document
      constructor erases all <xtermref spec="XQ" ref="dt-type-annotation"/> on its content nodes.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
		  <emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
		</expression></clause></multiclause><multiclause diff="add" at="E029"><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> (element*|text|processing-instruction*|comment)*</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
		  document { <emph>Expr</emph> } <a href="#jd_has_type" class="judgment"><term>:</term></a> document { <a href="#doc-fs-Type"><emph>Type</emph></a> }
		</expression></clause></postjudge></infer></infergr></smtype><smeval><p>The dynamic semantics checks that the argument expression
      evaluates to a value that is a sequence of element, text,
      processing-instruction, or comment nodes. The entire expression
      evaluates to a new document node value. If the construction mode
      is set to <code>strip</code>, the <xtermref spec="XQ" ref="dt-type-annotation"/> for all the nodes in content of a
      document node are erased.</p><infergr><infer><prejudge><multiclause><clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_construction_mode_env" class="env">constructionMode</a> = preserve</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
		      <emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a>
                      <phrase diff="del" at="E029"><a href="#doc-fs-Value"><emph>Value</emph></a></phrase>
                      <phrase diff="add" at="E029"><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript></phrase>
		</expression></clause></multiclause><multiclause diff="add" at="E029"><clause><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_with_text_nodes_processed_is" class="judgment"><term>with text nodes processed is</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
		      <phrase diff="del" at="E029"><a href="#doc-fs-Value"><emph>Value</emph></a></phrase>
		      <phrase diff="add" at="E029"><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></phrase>
                      <a href="#jd_matches" class="judgment"><term>matches</term></a> (element<phrase diff="add" at="E023"> *</phrase> | text | processing-instruction<phrase diff="add" at="E022"> *</phrase> | comment)* 
		</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
		      document { <emph>Expr</emph> } <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> document {
                      <phrase diff="del" at="E029"><a href="#doc-fs-Value"><emph>Value</emph></a></phrase>
                      <phrase diff="add" at="E029"><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></phrase>
                      }
		</expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_construction_mode_env" class="env">constructionMode</a> = strip</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
		      <emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>
		</expression></clause></multiclause><multiclause><clause><expression>
   	          <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_erases_to" class="judgment"><term>erases to</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> 
		</expression></clause></multiclause><multiclause diff="add" at="E029"><clause><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> <a href="#jd_with_text_nodes_processed_is" class="judgment"><term>with text nodes processed is</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>3</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
		      <phrase diff="del" at="E029"><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></phrase>
		      <phrase diff="add" at="E029"><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>3</subscript></phrase>
                      <a href="#jd_matches" class="judgment"><term>matches</term></a> (element<phrase diff="add" at="E023"> *</phrase> | text | processing-instruction<phrase diff="add" at="E022"> *</phrase> | comment)* 
		</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
		      document { <emph>Expr</emph> } <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> document {
                      <phrase diff="del" at="E029"><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></phrase>
                      <phrase diff="add" at="E029"><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>3</subscript></phrase>
                      }
		</expression></clause></postjudge></infer></infergr></smeval></div4><div4 id="sec_textConstructors"><head>Text Node Constructors</head><scrap headstyle="show"><head/><prodrecap id="CompTextConstructor" ref="CompTextConstructor" orig="xquery"/></scrap><smcore><p>The Core grammar production for a computed text constructor
      is:</p><scrap headstyle="show"><head/><prodrecap id="core-CompTextConstructor" ref="CompTextConstructor" orig="core"/></scrap></smcore><smnorm><p>A text node constructor contains an expression, which must
      evaluate to an <code>xs:string</code> value. <xspecref spec="XQ" ref="id-textConstructors"/> specifies the rules for converting a
      sequence of atomic values into a string prior to construction of
      a text node.  Each node is replaced by its string value. For
      each adjacent sequence of one or more atomic values returned by
      an enclosed expression, a untyped atomic value is constructed,
      containing the canonical lexical representation of all the
      atomic values, with a single blank character inserted between
      adjacent values.  As formal specification of these conversion
      rules is not instructive,
      <phrase diff="del" at="E030"><specref ref="sec_item_seq_to_untypedAtomic"/></phrase>
      <phrase diff="add" at="E030">the <a href="#sec_item_seq_to_untypedAtomic_text"><emph>fs:</emph><code>item-sequence-to-untypedAtomic-text</code></a> function</phrase>
      implements this
      conversion.</p><mapping><xquery><expression>
         <map>text { <emph>Expr</emph> }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
        </expression></xquery><core><expression>
         text {
         (<a href="#sec_item_seq_to_untypedAtomic_text"><emph>fs:</emph><code>item-sequence-to-untypedAtomic-text</code></a>(<code>fn:data</code>((<map><emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>))))
         cast as <code>xs:string</code>? }
        </expression></core></mapping></smnorm><smtype><p>The static semantics checks that the argument expression has
      type <code>xs:string</code> or <code>empty</code>. The type of the entire
      expression is an optional text node type, as the text node
      constructor returns the empty sequence if its argument is the
      empty sequence.</p><infergr><infer><prejudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
		      <emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:string</code>?
		</expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
		      text { <emph>Expr</emph> } <a href="#jd_has_type" class="judgment"><term>:</term></a> text?
		</expression></clause></postjudge></infer></infergr></smtype><smeval><p>If the argument expression returns the empty sequence, the
      text node constructor returns the empty sequence.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
                  <emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <code>()</code>
		</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
		  text { <emph>Expr</emph> } <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <code>()</code>
		</expression></clause></postjudge></infer></infergr><p>If the argument expression returns a value of type
      <code>xs:string</code>, the text node constructor returns a text node with
      that string as content.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
                  <emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a> 
		</expression></clause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
		  <a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <code>xs:string</code> 
		</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
		  text { <emph>Expr</emph> } <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> text { <a href="#doc-fs-Value"><emph>Value</emph></a> }
		</expression></clause></postjudge></infer></infergr></smeval></div4><div4 id="sec_computed-pis"><head>Computed Processing Instruction Constructors</head><scrap headstyle="show"><head/><prodrecap id="CompPIConstructor" ref="CompPIConstructor" orig="xquery"/></scrap><smcore><p>The Core grammar production for computed
      processing-instruction constructors is:</p><scrap headstyle="show"><head/><prodrecap id="core-CompPIConstructor" ref="CompPIConstructor" orig="core"/></scrap></smcore><smnorm><p>Computed processing-instruction constructors are normalized
      by mapping their name and content expression in the same way
      that computed element and attribute constructors are
      normalized.</p><mapping><xquery><expression>
         <map>processing-instruction  <emph>NCName</emph> { }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
        </expression></xquery><core><expression>
         <map>processing-instruction  <emph>NCName</emph> { () }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
        </expression></core></mapping><mapping><xquery><expression>
         <map>processing-instruction  <emph>NCName</emph> { <emph>Expr</emph> }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
        </expression></xquery><core><expression>processing-instruction <emph>NCName</emph> { <a href="#sec_item_seq_to_untypedAtomic_PI"><emph>fs:</emph><code>item-sequence-to-untypedAtomic-PI</code></a>((<map><emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)) } 
        </expression></core></mapping><mapping><xquery><expression>
         <map>processing-instruction  { <emph>Expr</emph><subscript>1</subscript> } { <emph>Expr</emph><subscript>2</subscript> }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
        </expression></xquery><core><expression>
         processing-instruction  { <code>fn:data</code>((<map><emph>Expr</emph><subscript>1</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)) } { <a href="#sec_item_seq_to_untypedAtomic_PI"><emph>fs:</emph><code>item-sequence-to-untypedAtomic-PI</code></a>((<map><emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)) }
        </expression></core></mapping></smnorm><smtype><p>The static typing rules for processing-instruction
      constructors are straightforward.</p><infergr><infer><prejudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
		      <emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> 
		</expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
		      processing-instruction  <emph>NCName</emph> { <emph>Expr</emph> }
		      <a href="#jd_has_type" class="judgment"><term>:</term></a> processing-instruction <phrase diff="chg" at="E022"><emph>NCName</emph></phrase>
		</expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
	      <emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> (<code>xs:NCName</code> | <code>xs:string</code> | <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>)
		</expression></clause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
	      <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> 
		</expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
		      processing-instruction  { <emph>Expr</emph><subscript>1</subscript> } { <emph>Expr</emph><subscript>2</subscript> }
		      <a href="#jd_has_type" class="judgment"><term>:</term></a> processing-instruction<phrase diff="add" at="E022"> *</phrase>
		</expression></clause></postjudge></infer></infergr></smtype><smeval><p>The dynamic evaluation rules for computed
      processing-instructions are straightforward.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
	      <emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
		</expression></clause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
	      <a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>
		</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
	      processing-instruction  <emph>NCName</emph> { <emph>Expr</emph> }
	      <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> processing-instruction <emph>NCName</emph> { <a href="#doc-fs-Value"><emph>Value</emph></a> }
		</expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
		      <emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>
		</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
		      <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> (<code>xs:NCName</code> | <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> | <code>xs:string</code>)
		</expression></clause></multiclause><multiclause><clause><expression>
		      <code>xs:NCName</code>(<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>) = <emph>NCName</emph><subscript>1</subscript>
		</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
		      <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>
		</expression></clause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
		      <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> 
		</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
		      processing-instruction  { <emph>Expr</emph><subscript>1</subscript> } { <emph>Expr</emph><subscript>2</subscript> }
		      <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> processing-instruction <emph>NCName</emph><subscript>1</subscript> { <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> }
		</expression></clause></postjudge></infer></infergr></smeval></div4><div4 id="sec_computed-comments"><head>Computed Comment Constructors</head><scrap headstyle="show"><head/><prodrecap id="CompCommentConstructor" ref="CompCommentConstructor" orig="xquery"/></scrap><smcore><p>The Core grammar production for computed comment constructors
      is:</p><scrap headstyle="show"><head/><prodrecap id="core-CompCommentConstructor" ref="CompCommentConstructor" orig="core"/></scrap></smcore><smnorm><p>Computed comment constructors are normalized by mapping their
      content expression.</p><mapping><xquery><expression>
         <map>comment { <emph>Expr</emph> }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
        </expression></xquery><core><expression>comment { (<a href="#sec_item_seq_to_untypedAtomic_comment"><emph>fs:</emph><code>item-sequence-to-untypedAtomic-comment</code></a>((<map><emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>))) cast as <code>xs:string</code> } 
        </expression></core></mapping></smnorm><smtype><p>The static typing rule for computed comment constructors is
        straightforward.</p><infergr><infer><prejudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
		      <emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:string</code> 
		</expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
		      comment { <emph>Expr</emph> }
		      <a href="#jd_has_type" class="judgment"><term>:</term></a> comment
		</expression></clause></postjudge></infer></infergr></smtype><smeval><p>
The dynamic evaluation rule for computed comment constructors is
straightforward. 
</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
		      <emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a> 
		</expression></clause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
		      <a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <code>xs:string</code> 
		</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
		      comment { <emph>Expr</emph> }
		      <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> comment { <a href="#doc-fs-Value"><emph>Value</emph></a> }
		</expression></clause></postjudge></infer></infergr></smeval></div4></div3><div3 id="id-ns-nodes-on-elements"><head>In-scope Namespaces of a Constructed Element</head><p>The effect of in-scope namespaces on constructed elements is
      specified in <specref ref="id_element_constructor"/> and
      <specref ref="sec_comp_elem_constructor"/>. </p></div3></div2><div2 id="sec_for-expressions"><head>[For/FLWOR] Expressions</head><smintro><p>[XPath/XQuery] provides [For/FLWOR] expressions for iteration, for
      binding variables to intermediate results, and filtering bound
      variables according to a predicate.</p><p>A <emph>FLWORExpr</emph> in XQuery 1.0 consists of a sequence of
      <emph>ForClause</emph>s and <emph>LetClause</emph>s, followed by an optional
      <emph>WhereClause</emph>, followed by an optional <emph>OrderByClause</emph>, as
      described by the following grammar productions. Each variable
      binding is preceded by an optional type declaration which
      specify the type expected for the variable.</p><p>The dynamic semantics of the ordering mode in FLWOR
      expressions is not specified formally, as it would require the
      introduction of tuples, which are not supported in the
      [XPath/XQuery] data model.</p><scrap headstyle="show"><head>[For/FLWOR] Expressions</head><prodrecap id="FLWORExpr" ref="FLWORExpr11" orig="xquery"/><prodrecap id="ForClause" ref="ForClause" orig="xquery"/><prodrecap id="LetClause" ref="LetClause" orig="xquery"/><prodrecap id="TypeDeclaration" ref="TypeDeclaration" orig="xquery"/><prodrecap id="PositionalVar" ref="PositionalVar" orig="xquery"/><prodrecap id="WhereClause" ref="WhereClause" orig="xquery"/><prodrecap id="OrderByClause" ref="OrderByClause" orig="xquery"/><prodrecap id="OrderSpecList" ref="OrderSpecList" orig="xquery"/><prodrecap id="OrderSpec" ref="OrderSpec" orig="xquery"/><prodrecap id="OrderModifier" ref="OrderModifier" orig="xquery"/><prodrecap id="ForExpr" ref="ForExpr" orig="xpath" test="XPath"/><prodrecap id="SimpleForClause" ref="SimpleForClause" orig="xpath" test="XPath"/></scrap></smintro><smcore><p>The Core grammar productions for FLWOR expressions are:</p><scrap headstyle="show"><head>For Expressions</head><prodrecap ref="FLWORExpr10" id="core-ForExpr" orig="core"/><prodrecap ref="ForClause" id="core-ForClause" orig="core"/><prodrecap ref="LetClause" id="core-LetClause" orig="core"/><prodrecap ref="PositionalVar" id="core-PositionalVar" orig="core"/><prodrecap ref="TypeDeclaration" id="core-TypeDeclaration" orig="core"/><prodrecap ref="OrderByClause" id="core-OrderByClause" orig="core"/><prodrecap ref="OrderSpecList" id="core-OrderSpecList" orig="core"/><prodrecap ref="OrderSpec" id="core-OrderSpec" orig="core"/><prodrecap ref="OrderModifier" id="core-OrderModifier" orig="core"/></scrap></smcore><div3 id="sec_flwor-expressions"><head>FLWOR expressions</head><smnotation><p>For convenience, we introduce the following auxiliary
        grammar productions to represent optional type declarations
        and positional variables in For and Let clauses.</p><scrap headstyle="show"><head/><prodrecap id="OptTypeDeclaration" ref="OptTypeDeclaration" orig="formal"/><prodrecap id="OptPositionalVar" ref="OptPositionalVar" orig="formal"/></scrap></smnotation><smnotation><p>To facilitate the specification of normalization, we also
        introduce the following auxiliary grammar productions as an
        alternative grammar for FLWOR expressions.</p><scrap headstyle="show"><head/><prodrecap id="FormalFLWORClause" ref="FormalFLWORClause" orig="formal"/><prodrecap id="FormalReturnClause" ref="FormalReturnClause" orig="formal"/><prodrecap id="FormalFLWORExpr" ref="FormalFLWORExpr" orig="formal"/></scrap></smnotation><smnorm><p>Full FLWOR expressions are normalized to nested Core FLWOR
    	expressions with a single for or let clause. Note that some of
    	the normalization rules below accept ungrammatical FLWOR
    	expressions such as "where <emph>Expr</emph><subscript>1</subscript> return <emph>Expr</emph><subscript>2</subscript>". This
    	does not matter, as normalization is always applied on parsed
    	[XPath/XQuery] expressions, and such ungrammatical FLWOR
    	expressions would be rejected by the parser beforehand.</p><p>Normalized FLWOR expressions restrict a For and Let clause
        to bind only one variable. Otherwise, the Core FLWOR
        expression is the same as the XQuery FLWOR expression. The
        first normalization rule is applied on a full [For/FLWOR]
        expression, splitting it at the clause level, then applying
        further normalization on each separate clause.</p><mapping><xquery><expression>
	   <map>
            <table summary=""><tbody><tr><td rowspan="1" colspan="1">
	    for $<emph>VarName</emph><subscript>1</subscript> <emph>OptTypeDeclaration</emph><subscript>1</subscript>
	    <emph>OptPositionalVar</emph><subscript>1</subscript> in <emph>Expr</emph><subscript>1</subscript>, </td></tr><tr><td rowspan="1" colspan="1">···,</td></tr><tr><td rowspan="1" colspan="1">$<emph>VarName</emph><subscript>n</subscript> <emph>OptTypeDeclaration</emph><subscript>n</subscript>
	    <emph>OptPositionalVar</emph><subscript>n</subscript> in <emph>Expr</emph><subscript>n</subscript></td></tr><tr><td rowspan="1" colspan="1"><emph>FormalReturnClause</emph></td></tr></tbody></table>
	   </map>
           <a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
          </expression></xquery><core><expression>
	   <table summary=""><tbody><tr><td rowspan="1" colspan="1"> for $<emph>VarName</emph><subscript>1</subscript> <emph>OptTypeDeclaration</emph><subscript>1</subscript> <emph>OptPositionalVar</emph><subscript>1</subscript> in <map><emph>Expr</emph><subscript>1</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> return</td></tr><tr><td rowspan="1" colspan="1">  ···</td></tr><tr><td rowspan="1" colspan="1">     for $<emph>VarName</emph><subscript>n</subscript> <emph>OptTypeDeclaration</emph><subscript>n</subscript>
              <emph>OptPositionalVar</emph><subscript>n</subscript>
              in <map> <emph>Expr</emph><subscript>n</subscript> </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> return</td></tr><tr><td rowspan="1" colspan="1"><map><emph>FormalReturnClause</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></td></tr></tbody></table>
	  </expression></core></mapping><p>Likewise, a <emph>LetClause</emph> clause is normalized to nested
        let expressions, each of which binds one variable:</p><mapping><xquery><expression>
	   <map>
<table summary=""><tbody><tr><td rowspan="1" colspan="1">let $<emph>VarName</emph><subscript>1</subscript> <emph>OptTypeDeclaration</emph><subscript>1</subscript> := <emph>Expr</emph><subscript>1</subscript>,</td></tr><tr><td rowspan="1" colspan="1">···,</td></tr><tr><td rowspan="1" colspan="1">$<emph>VarName</emph><subscript>n</subscript> <emph>OptTypeDeclaration</emph><subscript>n</subscript> := <emph>Expr</emph><subscript>n</subscript></td></tr><tr><td rowspan="1" colspan="1"><emph>FormalReturnClause</emph></td></tr></tbody></table></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
  	  </expression></xquery><core><expression>
	   <table summary=""><tbody><tr><td rowspan="1" colspan="1">let $<emph>VarName</emph><subscript>1</subscript> <emph>OptTypeDeclaration</emph><subscript>1</subscript> := <map><emph>Expr</emph><subscript>1</subscript> </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> return</td></tr><tr><td rowspan="1" colspan="1">  ···</td></tr><tr><td rowspan="1" colspan="1">    let $<emph>VarName</emph><subscript>n</subscript> <emph>OptTypeDeclaration</emph><subscript>n</subscript> := <map><emph>Expr</emph><subscript>n</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> return</td></tr><tr><td rowspan="1" colspan="1"><map><emph>FormalReturnClause</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></td></tr></tbody></table>
	  </expression></core></mapping><p>A <emph>WhereClause</emph> is normalized to an <emph>IfExpr</emph>, with
        the else-branch returning the empty sequence:</p><mapping><xquery><expression>
	   <map> where <emph>Expr</emph><subscript>1</subscript> <emph>FormalReturnClause</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
	  </expression></xquery><core><expression>
	   if ( <phrase diff="chg" at="E028">fn:boolean(( <map><emph>Expr</emph><subscript>1</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> ))</phrase> ) then <map><emph>FormalReturnClause</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> else ()
	  </expression></core></mapping><p>The order by clause is normalized using the auxiliary
        mapping rule <map/><a href="#jd_map_orderspeclist" class="judgment"><subscript>OrderSpecList</subscript></a> which is
        defined in <specref ref="id_orderby_clause"/>.</p><mapping><xquery><expression>
	   <map> stable? order by <emph>OrderSpecList</emph> <emph>FormalReturnClause</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
	  </expression></xquery><core><expression>
	    <map><emph>OrderSpecList</emph></map><a href="#jd_map_orderspeclist" class="judgment"><subscript>OrderSpecList</subscript></a> return <map><emph>FormalReturnClause</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
	  </expression></core></mapping><p>Finally, a stand-alone return clause is normalized into the
        corresponding expression. Recall that <code>return</code>
        keywords are introduced in the previous rule after the
        normalization of each clause.</p><mapping><xquery><expression>
	   <map> return <emph>Expr</emph> </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
	  </expression></xquery><core><expression>
	   <map> <emph>Expr</emph> </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
	  </expression></core></mapping></smnorm><smexample><p>The following simple example illustrates how a
        <emph>FLWORExpr</emph> is normalized. The <code>for</code> expression
        in the example below is used to iterate over two collections,
        binding variables <code>$i</code> and <code>$j</code> to items
        in these collections. It uses a <code>let</code> clause to
        bind the local variable <code>$k</code> to the sum of both
        numbers, and a <code>where</code> clause to select only those
        numbers that have a sum equal to or greater than the integer
        <code>5</code>.</p><eg xml:space="preserve">  for $i as xs:integer in (1, 2),
      $j in (3, 4)
  let $k := $i + $j
  where $k &gt;= 5
  return
    &lt;tuple&gt;
       &lt;i&gt; { $i } &lt;/i&gt;
       &lt;j&gt; { $j } &lt;/j&gt;
    &lt;/tuple&gt;
</eg><p>By the first set of rules, this is normalized to (except
        for the operators and element constructor which are not
        treated here):</p><eg xml:space="preserve">  for $i as xs:integer in (1, 2) return
    for $j in (3, 4) return
      let $k := $i + $j return
        if ($k &gt;= 5) then 
          &lt;tuple&gt;
            &lt;i&gt; { $i } &lt;/i&gt;
            &lt;j&gt; { $j } &lt;/j&gt;
          &lt;/tuple&gt;
        else
          ()
</eg><p>For each binding of <code>$i</code> to an item in the
        sequence <code>(1 , 2)</code> the inner <code>for</code>
        expression iterates over the sequence <code>(3 , 4)</code> to
        produce tuples ordered by the ordering of the outer sequence
        and then by the ordering of the inner sequence. This Core
        expression eventually results in the following document
        fragment:</p><eg xml:space="preserve">
  (&lt;tuple&gt;
      &lt;i&gt;1&lt;/i&gt;
      &lt;j&gt;4&lt;/j&gt;
   &lt;/tuple&gt;,
   &lt;tuple&gt;
      &lt;i&gt;2&lt;/i&gt;
      &lt;j&gt;3&lt;/j&gt;
   &lt;/tuple&gt;,
   &lt;tuple&gt;
      &lt;i&gt;2&lt;/i&gt;
      &lt;j&gt;4&lt;/j&gt;
   &lt;/tuple&gt;)
</eg></smexample></div3><div3 id="id-for-expression"><head>For expression</head><smtype><p>A single <code>for</code> expression is typed as follows:
        First <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> of the iteration expression <emph>Expr</emph><subscript>1</subscript> is
        inferred. Then the <termref def="term-prime-type">prime
        type</termref> of <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>), is
        computed. This is a union over all item types in <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
        (See <specref ref="sec_factor"/>). With the variable component
        of the static environment <a href="#xq_stat_env_def" class="env">statEnv</a> extended with
        $<emph>VarName</emph><subscript>1</subscript> as type <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>), the type
        <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> of <emph>Expr</emph><subscript>2</subscript> is inferred. Because the
        <code>for</code> expression iterates over the result of
        <emph>Expr</emph><subscript>1</subscript>, the final type of the iteration is <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
        multiplied with the possible number of items in <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
        (one, <code>?</code>, <code>*</code>, or <code>+</code>).
        This number is determined by the auxiliary type-function
        <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>). Operations between quantifiers
        and types, such as <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_quantifier" class="judgment">·</a>
        <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>), used in the following rule, are
        defined in <specref ref="sec_factor"/>.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>VarName</emph><subscript>1</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a> <emph>Variable</emph><subscript>1</subscript>
 	      </expression></clause></multiclause><multiclause><clause><environment>
                    <update><environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a></environment><expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)</expression></update>
                  </environment><expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>for $<emph>VarName</emph><subscript>1</subscript> in <emph>Expr</emph><subscript>1</subscript> return
                    <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)
                </expression></clause></postjudge></infer></infergr><p>When a positional variable <emph>Variable</emph><subscript>pos</subscript> is present, the
        static environment is also extended with the positional
        variable typed as an <code>xs:integer</code>.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>VarName</emph><subscript>1</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a> <emph>Variable</emph><subscript>1</subscript>
 	      </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>VarName</emph><subscript>pos</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a> <emph>Variable</emph><subscript>pos</subscript>
 	      </expression></clause></multiclause><multiclause><clause><environment>
                    <update><environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a></environment><expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>);</expression><expression><emph>Variable</emph><subscript>pos</subscript> =&gt; <code>xs:integer</code></expression></update>
                  </environment><expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>for $<emph>VarName</emph><subscript>1</subscript> at $<emph>VarName</emph><subscript>pos</subscript> in <emph>Expr</emph><subscript>1</subscript> return
                    <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)
                </expression></clause></postjudge></infer></infergr><p>When a type declaration is present, the static semantics
        also checks that the type of the input expression is a subtype
        of the declared type and extends the static environment by
        typing $<emph>VarName</emph><subscript>1</subscript> with type <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>. This semantics is
        specified by the following static typing rule.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><expression>
                   <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> = <map> <emph>SequenceType</emph> </map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                </expression></clause></multiclause><multiclause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>VarName</emph><subscript>1</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a> <emph>Variable</emph><subscript>1</subscript>
 	      </expression></clause></multiclause><multiclause><clause><environment>
                    <update><environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a></environment><expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript></expression></update>
                  </environment><expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>for $<emph>VarName</emph><subscript>1</subscript> as <emph>SequenceType</emph> in <emph>Expr</emph><subscript>1</subscript> return
                    <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)
                </expression></clause></postjudge></infer></infergr><p>The last rule handles For expressions that contain a type
        declaration and a positional variable.  When the positional
        variable is present, the static environment is also extended
        with the positional variable typed as an integer.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><expression>
                   <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> = <map> <emph>SequenceType</emph> </map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                </expression></clause></multiclause><multiclause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>VarName</emph><subscript>1</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a> <emph>Variable</emph><subscript>1</subscript>
 	      </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>VarName</emph><subscript>pos</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a> <emph>Variable</emph><subscript>pos</subscript>
 	      </expression></clause></multiclause><multiclause><clause><environment>
                    <update><environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a></environment><expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>; </expression><expression><emph>Variable</emph><subscript>pos</subscript> =&gt; <code>xs:integer</code></expression></update>
                  </environment><expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>for $<emph>VarName</emph><subscript>1</subscript> as <emph>SequenceType</emph> at $<emph>VarName</emph><subscript>pos</subscript> in <emph>Expr</emph><subscript>1</subscript> return
                    <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)
                </expression></clause></postjudge></infer></infergr></smtype><smexample><p>For example, if <code>$example</code> is bound to the
        sequence <code>10.0, 1.0E1, 10</code> of type
        <code>xs:decimal, xs:float, xs:integer</code>, then the query</p><eg xml:space="preserve">  for $s in $example
  return $s * 2</eg><p>is typed as follows:</p><eg xml:space="preserve">  (1) prime(xs:decimal, xs:float, xs:integer) =
      xs:decimal | xs:float | xs:integer
  (2) quantifier(xs:decimal, xs:float, xs:integer) = +
  (3) $s : xs:decimal | xs:float | xs:integer
  (4) $s * 2 : 
      xs:decimal | xs:float | xs:integer
  (5) result-type :
      ( xs:decimal | xs:float | xs:integer ) +
</eg><p>This result-type is not the most specific type possible. It
        does not take into account the order of elements in the input
        type, and it ignores the individual and overall number of
        elements in the input type. The most specific type possible
        is: <code>xs:decimal, xs:float, xs:integer</code>.  However,
        inferring such a specific type for arbitrary input types and
        arbitrary return clauses requires significantly more complex
        static typing rules. In addition, if put into the context of
        an element, the specific type violates the "unique particle
        attribution" restriction of XML schema, which requires that an
        element must have a unique content model within a particular
        context.</p></smexample><smeval><p>The evaluation of a <code>for</code> expression
        distinguishes two cases: If the iteration expression
        <emph>Expr</emph><subscript>1</subscript> evaluates to the empty sequence, then the entire
        expression evaluates to the empty sequence:</p><infergr><infer><prejudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> ()</expression></clause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>for $<emph>VarName</emph><subscript>1</subscript> <emph>OptTypeDeclaration</emph> <emph>OptPositionalVar</emph> in <emph>Expr</emph><subscript>1</subscript> return <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> ()
 		</expression></clause></postjudge></infer></infergr><p>Otherwise, the iteration expression <emph>Expr</emph><subscript>1</subscript> is evaluated
        to produce the sequence <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript>, ..., <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript>.
        For each item <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>i</subscript> in this sequence, the body of the
        <code>for</code> expression <emph>Expr</emph><subscript>2</subscript> is evaluated in the
        dynamic environment <a href="#xq_dyn_env_def" class="env">dynEnv</a> extended with $<emph>VarName</emph><subscript>1</subscript>
        bound to <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>i</subscript>. This produces values <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>i</subscript>,
        ..., <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript> which are concatenated to produce the result
        sequence. </p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression> 
                      <emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript> ,..., <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript>
                  </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment><expression><emph>VarName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph></expression></clause></multiclause><multiclause><clause><environment>
                    <update><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment><expression><emph>Variable</emph> =&gt; <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript></expression></update>
                  </environment><expression><emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><expression>···</expression></clause></multiclause><multiclause><clause><environment>
                    <update><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment><expression><emph>Variable</emph> =&gt; <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript></expression></update>
                  </environment><expression><emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
                  for $<emph>VarName</emph> in <emph>Expr</emph><subscript>1</subscript> return <emph>Expr</emph><subscript>2</subscript> 
                  <a href="#jd_yields" class="judgment"><term>=&gt;</term></a>
                  <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> ,..., <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript>
                </expression></clause></postjudge></infer></infergr><p>The following rule is the same as the rule above, but
        includes the optional positional variable $<emph>VarName</emph><subscript>pos</subscript>.
        If present, $<emph>VarName</emph><subscript>pos</subscript> is bound to the position of the
        item in the input sequence, i.e., the value
        <emph>i</emph>.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression> 
                      <emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript> ,..., <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript>
                  </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment><expression><emph>VarName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph></expression></clause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment><expression><emph>VarName</emph><subscript>pos</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph><subscript>pos</subscript></expression></clause></multiclause><multiclause><clause><environment>
                    <update><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment><expression><emph>Variable</emph> =&gt; <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript>; </expression><expression><emph>Variable</emph><subscript>pos</subscript> =&gt; 1</expression></update>
                  </environment><expression><emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><expression>···</expression></clause></multiclause><multiclause><clause><environment>
                    <update><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment><expression><emph>Variable</emph> =&gt; <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript>; </expression><expression><emph>Variable</emph><subscript>pos</subscript> =&gt; n</expression></update>
                  </environment><expression><emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
                  for $<emph>VarName</emph> at $<emph>VarName</emph><subscript>pos</subscript> in <emph>Expr</emph><subscript>1</subscript> return <emph>Expr</emph><subscript>2</subscript> 
                  <a href="#jd_yields" class="judgment"><term>=&gt;</term></a>
                  <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> ,..., <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript>
                </expression></clause></postjudge></infer></infergr><p>When a type declaration is present, the dynamic semantics
        also checks that each item in the result of evaluating
        <emph>Expr</emph><subscript>1</subscript> matches the declared type.  This semantics is
        specified by the following dynamic evaluation rule.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression> 
                      <emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript> ,..., <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript>
                  </expression></clause></multiclause><multiclause><clause><expression>
                   <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> = <map> <emph>SequenceType</emph> </map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                </expression></clause></multiclause><multiclause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
                   <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript>  <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>
                </expression></clause></multiclause><multiclause><clause><expression>···</expression></clause></multiclause><multiclause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
                   <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript>  <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>
                </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment><expression><emph>VarName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph></expression></clause></multiclause><multiclause><clause><environment>
                    <update><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment><expression><emph>Variable</emph> =&gt; <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript></expression></update>
                  </environment><expression><emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><expression>···</expression></clause></multiclause><multiclause><clause><environment>
                    <update><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment><expression><emph>Variable</emph> =&gt; <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript></expression></update>
                  </environment><expression><emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
                  for $<emph>VarName</emph> as <emph>SequenceType</emph> in <emph>Expr</emph><subscript>1</subscript>
                  return <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a>
                  <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> ,..., <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript>
                </expression></clause></postjudge></infer></infergr><p>The last rule covers a <code>for</code> expression that
        contains a type declaration and a positional variable.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression> 
                      <emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript> ,..., <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript>
                  </expression></clause></multiclause><multiclause><clause><expression>
                   <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> = <map> <emph>SequenceType</emph> </map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                </expression></clause></multiclause><multiclause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
                   <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript>  <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>
                </expression></clause></multiclause><multiclause><clause><expression>···</expression></clause></multiclause><multiclause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
                   <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript>  <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>
                </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment><expression><emph>VarName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment><expression><emph>VarName</emph><subscript>pos</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph><subscript>pos</subscript></expression></clause></multiclause><multiclause><clause><environment>
                    <update><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment><expression><emph>Variable</emph> =&gt; <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript>; </expression><expression><emph>Variable</emph><subscript>pos</subscript> =&gt; 1</expression></update>
                  </environment><expression><emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><expression>···</expression></clause></multiclause><multiclause><clause><environment>
                    <update><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment><expression><emph>Variable</emph> =&gt; <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript>; </expression><expression><emph>Variable</emph><subscript>pos</subscript> =&gt; n</expression></update>
                  </environment><expression><emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
                  for $<emph>VarName</emph> as <emph>SequenceType</emph> at $<emph>VarName</emph><subscript>pos</subscript>  in <emph>Expr</emph><subscript>1</subscript>
                  return <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a>
                  <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> ,..., <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript>
                </expression></clause></postjudge></infer></infergr><p>Note that this definition allows
      <emph>non-deterministic</emph> evaluation of the resulting
      sequence, since the preconditions in the above rule can be
      evaluated in any order.</p></smeval><smexample><p>Note that if the expression in the <code>return</code> clause 
        results in a sequence, sequences are never nested in the
        [XPath/XQuery] data model. For instance, in the following for
        expression:</p><eg xml:space="preserve">  
  for $i in (1,2)
    return (&lt;i&gt; {$i} &lt;/i&gt;, &lt;negi&gt; {-$i} &lt;/negi&gt;)
</eg><p>each iteration in the <code>for</code> results in a sequence of two
        elements, which are then concatenated and flattened in the
        resulting sequence:</p><eg xml:space="preserve">  
  (&lt;i&gt;1&lt;/i&gt;,
   &lt;negi&gt;-1&lt;/negi&gt;,
   &lt;i&gt;2&lt;/i&gt;,
   &lt;negi&gt;-2&lt;/negi&gt;)
</eg></smexample></div3><div3 id="sec_lets"><head>Let Expression</head><smtype><p>A <code>let</code> expression extends the static
        environment <a href="#xq_stat_env_def" class="env">statEnv</a> with <emph>Variable</emph><subscript>1</subscript> of type
        <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> inferred from <emph>Expr</emph><subscript>1</subscript>, and infers the type of
        <emph>Expr</emph><subscript>2</subscript> in the extended environment to produce the result
        type <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression> <emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> </expression></clause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment><expression><emph>VarName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph></expression></clause><clause><environment>
                        <update><environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a></environment><expression><emph>Variable</emph> =&gt; <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression></update>
                      </environment><expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>let $<emph>VarName</emph> :=  <emph>Expr</emph><subscript>1</subscript>
 		    return <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
                      </expression></clause></postjudge></infer></infergr><p>When a type declaration is present, the static semantics
        also checks that the type of the input expression is a subtype
        of the declared type and extends the static environment by
        typing <emph>Variable</emph><subscript>1</subscript> with type <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>.  This semantics is
        specified by the following static typing rule.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression> <emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> </expression></clause></multiclause><multiclause><clause><expression>
                   <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> = <map> <emph>SequenceType</emph> </map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                </expression></clause></multiclause><multiclause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment><expression><emph>VarName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph></expression></clause><clause><environment>
                    <update><environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a></environment><expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> </expression></update>
                  </environment><expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>let $<emph>VarName</emph><subscript>1</subscript> as <emph>SequenceType</emph> :=  <emph>Expr</emph><subscript>1</subscript>
 	      return <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
                </expression></clause></postjudge></infer></infergr></smtype><smeval><p>A <code>let</code> expression extends the dynamic environment
        <a href="#xq_dyn_env_def" class="env">dynEnv</a> with <emph>Variable</emph> bound to <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> returned by
        <emph>Expr</emph><subscript>1</subscript>, and evaluates <emph>Expr</emph><subscript>2</subscript> in the extended
        environment to produce <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment><expression><emph>VarName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph></expression></clause><clause><environment>
                    <update><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment><expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript></expression></update>
                  </environment><expression><emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>let $<emph>VarName</emph><subscript>1</subscript> := <emph>Expr</emph><subscript>1</subscript> return
                    <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>
                </expression></clause></postjudge></infer></infergr><p>When a type declaration is present, the dynamic semantics
        also checks that the result of evaluating <emph>Expr</emph><subscript>1</subscript> matches
        the declared type. This semantics is specified as the
        following dynamic evaluation rule.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><expression>
                   <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> = <map> <emph>SequenceType</emph> </map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                </expression></clause></multiclause><multiclause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
                   <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>  <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>
                </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment><expression><emph>VarName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph></expression></clause><clause><environment>
                    <update><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment><expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript></expression></update>
                  </environment><expression><emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>let $<emph>VarName</emph><subscript>1</subscript> as <emph>SequenceType</emph> := <emph>Expr</emph><subscript>1</subscript> return
                    <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>
                </expression></clause></postjudge></infer></infergr></smeval><smexample><p>Note the use of the environments to define the scope of
        each variable. For instance, in the following nested
        <code>let</code> expression:</p><eg xml:space="preserve">  let $k := 5 return
    let $k := $k + 1 return
      $k+1
</eg><p>the outermost <code>let</code> expression binds variable 
        <code>$k</code> to the
        integer <code>5</code> in the environment, then the expression
        <code>$k+1</code> is computed, yielding value <code>6</code>, to 
        which the second variable <code>$k</code> is bound. 
        The expression then results in 
        the final integer <code>7</code>.</p></smexample></div3><div3 id="id_orderby_clause"><head>Order By and Return Clauses</head><smintro><p>The dynamic semantics of the <emph>OrderByClause</emph> is not
        specified formally, as doing so would require the introduction
        of tuples, which are not supported in the [XPath/XQuery] data
        model. The dynamic semantics of the order-by clause can be
        found in <xspecref spec="XQ" ref="id-orderby-return"/>.</p><p>Although an <emph>OrderByClause</emph> does not affect the type of
        a <emph>FLWORExpr</emph> expression, it must still undergo static
        analysis, in case this raises a static error. The static
        semantics of a <emph>FLWORExpr</emph> expression with an
        <emph>OrderByClause</emph> is equivalent to the static semantics of an
        equivalent <emph>FLWORExpr</emph> in which the <emph>OrderByClause</emph> is
        replaced by a call to the <code>gt</code> comparison over the
        corresponding <emph>OrderSpec</emph> expression(s).</p></smintro><smnotation><p id="jd_map_orderspeclist">To define normalization of
        OrderBy, the following auxiliary mapping rule is used.</p><mapping><xquery><expression>
             <map><emph>OrderSpecList</emph></map><a href="#jd_map_orderspeclist" class="judgment"><subscript>OrderSpecList</subscript></a>
            </expression></xquery><core><expression>
             <emph>LetClause</emph> ... <emph>LetClause</emph>
            </expression></core></mapping><p>This rules specifies that <emph>OrderSpecList</emph> is mapped to a
        sequence of <emph>LetClause</emph>s.</p></smnotation><smnorm><p>Proper static typing for FLWOR expressions with an
        <emph>OrderByClause</emph> is obtained by normalizing the
        <emph>OrderByClause</emph> to a Let clause, nested For expressions,
        and atomization, then by applying the standard static typing
        rules for those expressions. Note that if evaluated
        dynamically, the normalization of <emph>OrderByClause</emph> given
        here does not express the required sorting semantics. Notably,
        the normalization rule introduces the <code>gt</code>
        operation which is used implicitely in the semantics of order
        by.</p><p>Each <emph>OrderSpec</emph> is normalized by the following
        rules.</p><mapping><xquery><expression>
               <map><emph>OrderSpec</emph><subscript>1</subscript> ... <emph>OrderSpec</emph><subscript>n</subscript></map><a href="#jd_map_orderspeclist" class="judgment"><subscript>OrderSpecList</subscript></a>
              </expression></xquery><core><expression>
               <map><emph>OrderSpec</emph><subscript>1</subscript></map><a href="#jd_map_orderspeclist" class="judgment"><subscript>OrderSpecList</subscript></a>, ...
               <map><emph>OrderSpec</emph><subscript>n</subscript></map><a href="#jd_map_orderspeclist" class="judgment"><subscript>OrderSpecList</subscript></a>
              </expression></core></mapping><mapping><xquery><expression>
           <map><emph>Expr</emph> <emph>OrderModifier</emph></map><a href="#jd_map_orderspeclist" class="judgment"><subscript>OrderSpecList</subscript></a>
	  </expression></xquery><core><expression>
            <table summary=""><tbody><tr><td rowspan="1" colspan="1">let $<emph>fs:</emph>new<subscript>0</subscript> := </td></tr><tr><td rowspan="1" colspan="1">   let $<emph>fs:</emph>new<subscript>1</subscript> := <map><emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> return</td></tr><tr><td rowspan="1" colspan="1">   for $<emph>fs:</emph>new<subscript>2</subscript> in $<emph>fs:</emph>new<subscript>1</subscript> return</td></tr><tr><td rowspan="1" colspan="1">   for $<emph>fs:</emph>new<subscript>3</subscript> in $<emph>fs:</emph>new<subscript>1</subscript> return</td></tr><tr><td rowspan="1" colspan="1">     <map>$<emph>fs:</emph>new<subscript>2</subscript> gt $<emph>fs:</emph>new<subscript>3</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></td></tr><tr><td rowspan="1" colspan="1"><map><emph>OrderSpecList</emph></map><a href="#jd_map_orderspeclist" class="judgment"><subscript>OrderSpecList</subscript></a></td></tr></tbody></table>
	  </expression></core></mapping></smnorm></div3></div2><div2 id="sec_unordered-expressions"><head>Ordered and Unordered Expressions</head><smintro><p>The purpose of <code>ordered</code> and
      <code>unordered</code> expressions is to set the ordering mode
      in the static context to <code>ordered</code> or
      <code>unordered</code> for a certain region in a query. The
      specified ordering mode applies to the expression nested inside
      the curly braces.</p><scrap headstyle="show"><head/><prodrecap id="OrderedExpr" ref="OrderedExpr" orig="xquery"/><prodrecap id="UnorderedExpr" ref="UnorderedExpr" orig="xquery"/></scrap></smintro><smcore><p>The Core grammar productions for ordered/unordered
      expressions are:</p><scrap headstyle="show"><head/><prodrecap id="core-OrderedExpr" ref="OrderedExpr" orig="core"/><prodrecap id="core-UnorderedExpr" ref="UnorderedExpr" orig="core"/></scrap></smcore><smnorm><p><emph>OrderedExpr</emph> (resp. <emph>UnorderedExpr</emph>) expressions are
      normalized to <emph>OrderedExpr</emph> (resp. <emph>UnorderedExpr</emph>)
      expressions in the [XPath/XQuery] Core.</p><mapping><xquery><expression><map>ordered { <emph>Expr</emph> }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression></xquery><core><expression>ordered { <map><emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> }</expression></core></mapping><mapping><xquery><expression><map>unordered { <emph>Expr</emph> }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression></xquery><core><expression>unordered { <map><emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> }</expression></core></mapping></smnorm><smtype><p><emph>OrderedExpr</emph> and <emph>UnorderedExpr</emph> expressions set the
     ordering mode in the static context to <code>ordered</code> or
     <code>unordered</code>.</p><infergr><infer><prejudge><multiclause><clause><expression>
             <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> =
             <update><environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ordering_mode_env" class="env">orderingMode</a></environment><expression><code>ordered</code></expression></update>
           </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></environment><expression>
             <emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
           </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
          ordered { <emph>Expr</emph> } <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
         </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><expression>
             <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> =
             <update><environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ordering_mode_env" class="env">orderingMode</a></environment><expression><code>unordered</code></expression></update>
           </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></environment><expression>
             <emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
           </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
          unordered { <emph>Expr</emph> } <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
         </expression></clause></postjudge></infer></infergr></smtype><smeval><p><emph>OrderedExpr</emph> and <emph>UnorderedExpr</emph> expressions only have
     an effect on the static context. The effect on the evaluation of
     its subexpression(s) is captured using the
     <a href="#sec_apply_ordering_mode"><emph>fs:</emph><code>apply-ordering-mode</code></a> function, which introduced during
     normalization of axis steps, <code>union</code>,
     <code>intersect</code>, and <code>except</code> expressions, and
     FLWOR expressions that have no <code>order by</code> clause.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
             <emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
           </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
          ordered { <emph>Expr</emph> } <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
         </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
             <emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
           </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
          unordered { <emph>Expr</emph> } <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
         </expression></clause></postjudge></infer></infergr></smeval></div2><div2 id="sec_conditionals"><head>Conditional Expressions</head><smintro><p>A conditional expression supports conditional evaluation of
      one of two expressions.</p><scrap headstyle="show"><head>Conditional Expression</head><prodrecap id="IfExpr" ref="IfExpr" orig="xquery"/></scrap></smintro><smcore><p>The Core grammar production for the conditional expression
      is:</p><scrap headstyle="show"><head>Core Conditional Expression</head><prodrecap ref="IfExpr" orig="core" id="core-IfExpr"/></scrap></smcore><smnorm><p>Conditional expressions are normalized as follows.</p><mapping><xquery><expression>
            <map>if (<emph>Expr</emph><subscript>1</subscript>) then <emph>Expr</emph><subscript>2</subscript> else <emph>Expr</emph><subscript>3</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
          </expression></xquery><core><expression>
          <table summary=""><tbody><tr><td rowspan="1" colspan="1">    if (<code>fn:boolean</code>((<map> <emph>Expr</emph><subscript>1</subscript> </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>))) then <map><emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> else <map><emph>Expr</emph><subscript>3</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></td></tr></tbody></table>
          </expression></core></mapping></smnorm><smtype><infergr><infer><prejudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a>  <code>xs:boolean</code> </expression></clause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> </expression></clause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>Expr</emph><subscript>3</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript> </expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression> <code>if</code> (<emph>Expr</emph><subscript>1</subscript>) <code>then </code>
                     <emph>Expr</emph><subscript>2</subscript>  <code>else </code> <emph>Expr</emph><subscript>3</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a>
                     (<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> | <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript>)
            </expression></clause></postjudge></infer></infergr></smtype><smeval><p>If the conditional's boolean expression <emph>Expr</emph><subscript>1</subscript> evaluates
      to true, <emph>Expr</emph><subscript>2</subscript> is evaluated and its value is produced.  If
      the conditional's boolean expression evaluates to false,
      <emph>Expr</emph><subscript>3</subscript> is evaluated and its value is produced.  Note that
      the existence of two separate dynamic evaluation rules ensures
      that only one branch of the conditional is evaluated.</p><infergr><infer><prejudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> true</expression></clause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression></clause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>if (<emph>Expr</emph><subscript>1</subscript>) then <emph>Expr</emph><subscript>2</subscript> else <emph>Expr</emph><subscript>3</subscript>  <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> 
            </expression></clause></postjudge></infer><infer><prejudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> false</expression></clause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>Expr</emph><subscript>3</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>3</subscript> </expression></clause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>if (<emph>Expr</emph><subscript>1</subscript>) then <emph>Expr</emph><subscript>2</subscript> 
                        else <emph>Expr</emph><subscript>3</subscript>  <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>3</subscript>
            </expression></clause></postjudge></infer></infergr></smeval></div2><div2 id="id-quantified-expressions"><head>Quantified Expressions</head><smintro><p>[XPath/XQuery] defines two quantification expressions:</p><scrap headstyle="show"><head>Quantified Expression</head><prodrecap id="QuantifiedExpr" ref="QuantifiedExpr" orig="xquery"/><prodrecap ref="QuantifiedExpr" orig="xpath" test="XPath"/></scrap></smintro><smcore><p>The Core grammar production for quantified expressions
      is:</p><scrap headstyle="show"><head/><prodrecap ref="QuantifiedExpr" id="core-QuantifiedExpr" orig="core"/></scrap></smcore><smnorm><p>The quantified expressions are normalized into nested Core
      quantified expressions, each of which binds one variable.</p><mapping><xquery><expression>
          <map>some $<emph>VarName</emph><subscript>1</subscript> in <emph>Expr</emph><subscript>1</subscript>, ..., $<emph>VarName</emph><subscript>n</subscript> in
          <emph>Expr</emph><subscript>n</subscript> satisfies <emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
        </expression></xquery><core><expression>
          <table summary=""><tbody><tr><td rowspan="1" colspan="1"> some $<emph>VarName</emph><subscript>1</subscript> in <map><emph>Expr</emph><subscript>1</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> satisfies</td></tr><tr><td rowspan="1" colspan="1">    some $<emph>VarName</emph><subscript>2</subscript> in <map><emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> satisfies</td></tr><tr><td rowspan="1" colspan="1">          ...</td></tr><tr><td rowspan="1" colspan="1">      some $<emph>VarName</emph><subscript>n</subscript> in <map><emph>Expr</emph><subscript>n</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> satisfies</td></tr><tr><td rowspan="1" colspan="1">      <code>fn:boolean</code>((<map><emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)) </td></tr></tbody></table>
        </expression></core></mapping><mapping><xquery><expression>
          <map>every $<emph>VarName</emph><subscript>1</subscript> in <emph>Expr</emph><subscript>1</subscript>, ..., $<emph>VarName</emph><subscript>n</subscript> in
          <emph>Expr</emph><subscript>n</subscript> satisfies <emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
        </expression></xquery><core><expression>
          <table summary=""><tbody><tr><td rowspan="1" colspan="1"> every $<emph>VarName</emph><subscript>1</subscript> in <map><emph>Expr</emph><subscript>1</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>  satisfies</td></tr><tr><td rowspan="1" colspan="1">    every $<emph>VarName</emph><subscript>2</subscript> in <map><emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> satisfies</td></tr><tr><td rowspan="1" colspan="1">          ...</td></tr><tr><td rowspan="1" colspan="1">      every $<emph>VarName</emph><subscript>n</subscript> in <map><emph>Expr</emph><subscript>n</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> satisfies</td></tr><tr><td rowspan="1" colspan="1">      <code>fn:boolean</code>((<map><emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)) </td></tr></tbody></table>
        </expression></core></mapping></smnorm><smtype><p>The static semantics of the quantified expressions uses the
      notion of <termref def="term-prime-type">prime
      type</termref>. These rules are similar to those for
      <code>for</code> expressions in <specref ref="id-for-expression"/>.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment><expression><emph>VarName</emph><subscript>1</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a> <emph>Variable</emph><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><environment>
                    <update><environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a></environment><expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)</expression></update>
                  </environment><expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:boolean</code> </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>some $<emph>VarName</emph><subscript>1</subscript> in <emph>Expr</emph><subscript>1</subscript> satisfies
                <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:boolean</code> </expression></clause></postjudge></infer></infergr><p>The next rule is for <emph>SomeExpr</emph> with the optional
            type declaration.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><expression>
                   <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> = <map> <emph>SequenceType</emph> </map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                </expression></clause></multiclause><multiclause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment><expression><emph>VarName</emph><subscript>1</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a> <emph>Variable</emph><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><environment>
                    <update><environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a></environment><expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript></expression></update>
                  </environment><expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:boolean</code> </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>some $<emph>VarName</emph><subscript>1</subscript> as <emph>SequenceType</emph> in <emph>Expr</emph><subscript>1</subscript> satisfies
                <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:boolean</code> </expression></clause></postjudge></infer></infergr><p>The next rule is for <emph>EveryExpr</emph> without the
            optional type declaration.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment><expression><emph>VarName</emph><subscript>1</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><environment>
                    <update><environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a></environment><expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)</expression></update>
                  </environment><expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:boolean</code> </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>every $<emph>VarName</emph><subscript>1</subscript> in <emph>Expr</emph><subscript>1</subscript>
                satisfies <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:boolean</code> </expression></clause></postjudge></infer></infergr><p>The next rule is for <emph>EveryExpr</emph> with the optional
            type declaration.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><expression>
                   <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> = <map> <emph>SequenceType</emph> </map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                </expression></clause></multiclause><multiclause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment><expression><emph>VarName</emph><subscript>1</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><environment>
                    <update><environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a></environment><expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript></expression></update>
                  </environment><expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:boolean</code> </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>every $<emph>VarName</emph><subscript>1</subscript> as <emph>SequenceType</emph> in <emph>Expr</emph><subscript>1</subscript>
                satisfies <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:boolean</code> </expression></clause></postjudge></infer></infergr></smtype><smeval><p>If its input expression returns the empty sequence, the
            <emph>SomeExpr</emph> expression returns false.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> ()</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>some $<emph>VarName</emph><subscript>1</subscript>
                <emph>OptTypeDeclaration</emph> in <emph>Expr</emph><subscript>1</subscript> satisfies
                <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> false </expression></clause></postjudge></infer></infergr><p>The <emph>SomeExpr</emph> expression yields true if any
            evaluation of the satisfies expression yields true. The
            <emph>SomeExpr</emph> expression yields false if every evaluation
            of the satisfies expression is false.  A quantified
            expression may raise an error if any evaluation of the
            satisfies expression raises an error.  The dynamic
            semantics of quantified expressions is non-deterministic.
            This non-determinism permits implementations to use
            short-circuit evaluation strategies when evaluating
            quantified expressions.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript>, ..., <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript> </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment><expression><emph>VarName</emph><subscript>1</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><environment>
                    <update><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment><expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>i</subscript></expression></update>
                  </environment><expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> true </expression></clause></multiclause><multiclause><clause><expression>
                   i <a href="#jd_isin" class="judgment"><term>in</term></a> { 1,...,n }
                 </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>some $<emph>VarName</emph><subscript>1</subscript> in <emph>Expr</emph><subscript>1</subscript> satisfies
                <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> true </expression></clause></postjudge></infer></infergr><p>The next rule is for <emph>SomeExpr</emph> with the optional
            type declaration, in which some evaluation of the
            satisfies expression yields true.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript>,
                  ..., <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript> </expression></clause></multiclause><multiclause><clause><expression>
                   <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> = <map> <emph>SequenceType</emph> </map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                </expression></clause></multiclause><multiclause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
                   <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>i</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>
                </expression></clause></multiclause><multiclause><clause><expression>
                   i <a href="#jd_isin" class="judgment"><term>in</term></a> { 1,...,n }
                 </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment><expression><emph>VarName</emph><subscript>1</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><environment>
                    <update><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment><expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>i</subscript></expression></update>
                  </environment><expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> true </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>some $<emph>VarName</emph><subscript>1</subscript> as <emph>SequenceType</emph> in <emph>Expr</emph><subscript>1</subscript> satisfies
                <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> true </expression></clause></postjudge></infer></infergr><p>The next rule is for <emph>SomeExpr</emph> without the optional
            type declaration, in which all evaluations of the
            satisfies expression yield false.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript>,
                  ..., <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript> </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment><expression><emph>VarName</emph><subscript>1</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><environment>
                    <update><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment><expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript></expression></update>
                  </environment><expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> false </expression></clause></multiclause><multiclause><clause><expression>...</expression></clause></multiclause><multiclause><clause><environment>
                    <update><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment><expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript></expression></update>
                  </environment><expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> false </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>some $<emph>VarName</emph><subscript>1</subscript> in <emph>Expr</emph><subscript>1</subscript> satisfies
                <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> false </expression></clause></postjudge></infer></infergr><p>The next rule is for <emph>SomeExpr</emph> with the optional
            type declaration, in which all evaluations of the
            satisfies expression yield false.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript>,
                  ..., <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript> </expression></clause></multiclause><multiclause><clause><expression>
                   <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> = <map> <emph>SequenceType</emph> </map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment><expression><emph>VarName</emph><subscript>1</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><environment>
                    <update><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment><expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript></expression></update>
                  </environment><expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> false </expression></clause></multiclause><multiclause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
                   <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>
                </expression></clause></multiclause><multiclause><clause><expression>...</expression></clause></multiclause><multiclause><clause><environment>
                    <update><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment><expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript></expression></update>
                  </environment><expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> false </expression></clause></multiclause><multiclause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
                   <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>
                </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>some $<emph>VarName</emph><subscript>1</subscript> as <emph>SequenceType</emph> in <emph>Expr</emph><subscript>1</subscript> satisfies
                <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> false </expression></clause></postjudge></infer></infergr><p>If its input expression returns the empty sequence, the
            <emph>EveryExpr</emph> expression returns true.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> ()</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>every $<emph>VarName</emph><subscript>1</subscript>
                <emph>OptTypeDeclaration</emph> in <emph>Expr</emph><subscript>1</subscript> satisfies
                <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> true </expression></clause></postjudge></infer></infergr><p>The <emph>EveryExpr</emph> expression yields false if any
            evaluation of the satisfies expression yields false.  The
            <emph>EveryExpr</emph> expression yields true if every evaluation
            of the satisfies expression is true.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript>,
                  ..., <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript> </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment><expression><emph>VarName</emph><subscript>1</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><environment>
                    <update><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment><expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>i</subscript></expression></update>
                  </environment><expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> false </expression></clause></multiclause><multiclause><clause><expression>
                   i <a href="#jd_isin" class="judgment"><term>in</term></a> { 1,...,n }
                 </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>every $<emph>VarName</emph><subscript>1</subscript> in <emph>Expr</emph><subscript>1</subscript> satisfies
                <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> false </expression></clause></postjudge></infer></infergr><p>The next rule is for <emph>EveryExpr</emph> with the optional
            type declaration, in which some evaluation of the
            satisfies expression yields false.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript>,
                  ..., <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript> </expression></clause></multiclause><multiclause><clause><expression>
                   <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> = <map> <emph>SequenceType</emph> </map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                </expression></clause></multiclause><multiclause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
                   <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>i</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>
                </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment><expression><emph>VarName</emph><subscript>1</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><environment>
                    <update><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment><expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>i</subscript></expression></update>
                  </environment><expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> false </expression></clause></multiclause><multiclause><clause><expression>
                   i <a href="#jd_isin" class="judgment"><term>in</term></a> { 1,...,n }
                 </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>every $<emph>VarName</emph><subscript>1</subscript> as <emph>SequenceType</emph> in <emph>Expr</emph><subscript>1</subscript> satisfies
                <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> false </expression></clause></postjudge></infer></infergr><p>The next rule is for <emph>EveryExpr</emph> in which all
            evaluations of the satisfies expression yield true.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript>,
                  ..., <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript> </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment><expression><emph>VarName</emph><subscript>1</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><environment>
                    <update><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment><expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript></expression></update>
                  </environment><expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> true </expression></clause></multiclause><multiclause><clause><expression>...</expression></clause></multiclause><multiclause><clause><environment>
                    <update><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment><expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript></expression></update>
                  </environment><expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> true </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>every $<emph>VarName</emph><subscript>1</subscript> in <emph>Expr</emph><subscript>1</subscript> satisfies
                <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> true </expression></clause></postjudge></infer></infergr><p>The next rule is for <emph>EveryExpr</emph> with the optional
            type declaration in which all evaluations of the satisfies
            expression yield true.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript>,
                  ..., <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript> </expression></clause></multiclause><multiclause><clause><expression>
                   <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> = <map> <emph>SequenceType</emph> </map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment><expression><emph>VarName</emph><subscript>1</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><environment>
                    <update><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment><expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript></expression></update>
                  </environment><expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> true </expression></clause></multiclause><multiclause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
                   <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>
                </expression></clause></multiclause><multiclause><clause><expression>...</expression></clause></multiclause><multiclause><clause><environment>
                    <update><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment><expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript></expression></update>
                  </environment><expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> true </expression></clause></multiclause><multiclause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
                   <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>
                </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>every $<emph>VarName</emph><subscript>1</subscript> as <emph>SequenceType</emph> in <emph>Expr</emph><subscript>1</subscript> satisfies
                <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> true </expression></clause></postjudge></infer></infergr></smeval></div2><div2 id="sec_sequencetype-matching"><head>Expressions on SequenceTypes</head><!-- Corresponds to XQuery Section 2.13 - Allocated to Jerome --><smintro><p>Some of the expressions relying on the SequenceTypes syntax
      are called expressions on SequenceTypes. The syntax of
      SequenceTypes is described in <specref ref="id-sequencetype"/>.</p></smintro><div3 id="sec_instance-of"><head>Instance Of</head><scrap headstyle="show"><head>SequenceType expressions</head><prodrecap id="InstanceofExpr" ref="InstanceofExpr" orig="xquery"/></scrap><smintro><p>The SequenceType expression <quote><emph>Expr</emph> instance of
        <emph>SequenceType</emph></quote> is true if and only if the result of
        evaluating expression <emph>Expr</emph> is an instance of the type
        referred to by <emph>SequenceType</emph>.</p></smintro><smnorm><p>An <emph>InstanceofExpr</emph> expression is normalized into a
          <emph>TypeswitchExpr</emph> expression. Note that the following
          normalization rule uses a variable $<emph>fs:</emph>new, which is a
          newly created variable which must not conflict with any
          variables already in scope. This variable is necessary to
          comply with the syntax of typeswitch expressions in the Core
          [XPath/XQuery], but is never used.</p><mapping><xquery><expression><map><emph>Expr</emph> instance of <emph>SequenceType</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression></xquery><core><expression>
           <table summary=""><tbody><tr><td rowspan="1" colspan="1">typeswitch (<map> <emph>Expr</emph> </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)</td></tr><tr><td rowspan="1" colspan="1">  case $<emph>fs:</emph>new as <emph>SequenceType</emph> return <code>fn:true</code>() </td></tr><tr><td rowspan="1" colspan="1">  default $<emph>fs:</emph>new return <code>fn:false</code>()</td></tr></tbody></table>
          </expression></core></mapping></smnorm></div3><div3 id="sec_typeswitch"><head>Typeswitch</head><scrap headstyle="show"><head>SequenceType expressions</head><prodrecap id="TypeswitchExpr" ref="TypeswitchExpr" orig="xquery"/><prodrecap id="CaseClause" ref="CaseClause" orig="xquery"/></scrap><smintro><p>The <term>typeswitch</term> expression chooses one of
          several expressions to evaluate based on the dynamic type of
          an input value.</p><p>Each branch of a typeswitch expression may have an
          optional $<emph>VarName</emph>, which is bound to the value of the
          input expression. One reason for using a variable on one of
          the branches is that it is assigned a type specific for that
          branch. This variable is optional in [XPath/XQuery] but made
          mandatory in the [XPath/XQuery] Core.</p></smintro><smcore><p>The Core grammar productions for <code>typeswitch</code>
          are:</p><scrap headstyle="show"><head/><prodrecap id="core-TypeswitchExpr" ref="TypeswitchExpr" orig="core"/><prodrecap id="core-CaseClause" ref="CaseClause" orig="core"/></scrap></smcore><smnotation><p>For convenience, we introduce the following auxiliary
          grammar production.</p><scrap headstyle="show"><head/><prodrecap id="OptVarName" ref="OptVarName" orig="formal"/></scrap></smnotation><smnotation><p id="jd_map_case">To define normalization of case clauses
          to the [XPath/XQuery] Core, the following auxiliary mapping
          rules are used.</p><mapping><xquery><expression>
               <map><emph>CaseClause</emph></map><a href="#jd_map_case" class="judgment"><subscript>Case</subscript></a>
              </expression></xquery><core><expression>
               <emph>CaseClause</emph>
              </expression></core></mapping><p>specifies that <emph>CaseClause</emph> is mapped to <emph>CaseClause</emph>,
          in the [XPath/XQuery] Core.</p></smnotation><smnorm><p>Normalization of a typeswitch expression guarantees that
          every branch has an associated $<emph>VarName</emph>.  The following
          normalization rules add newly created variables that must
          not conflict with any variables already in scope.</p><mapping><xquery><expression>
             <map>
                 case <emph>SequenceType</emph> return <emph>Expr</emph>
             </map><a href="#jd_map_case" class="judgment"><subscript>Case</subscript></a>
            </expression></xquery><core><expression>
                case $<emph>fs:</emph>new<subscript>1</subscript> as <emph>SequenceType</emph> return <map> <emph>Expr</emph> </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
            </expression></core></mapping><mapping><xquery><expression>
             <map>
                 case $<emph>VarName</emph> as <emph>SequenceType</emph> return
             <emph>Expr</emph> </map><a href="#jd_map_case" class="judgment"><subscript>Case</subscript></a>
            </expression></xquery><core><expression>
                case $<emph>VarName</emph> as <emph>SequenceType</emph> return <map> <emph>Expr</emph> </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
            </expression></core></mapping><mapping><xquery><expression>
             <map>
              default return <emph>Expr</emph>
             </map><a href="#jd_map_case" class="judgment"><subscript>Case</subscript></a>
            </expression></xquery><core><expression>
              default $<emph>fs:</emph>new<subscript>1</subscript> return <map> <emph>Expr</emph> </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
            </expression></core></mapping><mapping><xquery><expression>
             <map>
              default $<emph>VarName</emph> return <emph>Expr</emph>
             </map><a href="#jd_map_case" class="judgment"><subscript>Case</subscript></a>
            </expression></xquery><core><expression>
              default $<emph>VarName</emph> return <map> <emph>Expr</emph> </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
            </expression></core></mapping><mapping><xquery><expression>
             <map>
              <table summary=""><tbody><tr><td rowspan="1" colspan="1">typeswitch ( <emph>Expr</emph><subscript>0</subscript>  ) </td></tr><tr><td rowspan="1" colspan="1">  <emph>CaseClause</emph><subscript>1</subscript> </td></tr><tr><td rowspan="1" colspan="1">    ···</td></tr><tr><td rowspan="1" colspan="1">  <emph>CaseClause</emph><subscript>n</subscript> </td></tr><tr><td rowspan="1" colspan="1">  default <emph>OptVarName</emph> return <emph>Expr</emph><subscript>n+1</subscript></td></tr></tbody></table>
             </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
            </expression></xquery><core><expression>
             <table summary=""><tbody><tr><td rowspan="1" colspan="1">typeswitch ( <map> <emph>Expr</emph><subscript>0</subscript> </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> )</td></tr><tr><td rowspan="1" colspan="1"><map><emph>CaseClause</emph><subscript>1</subscript></map><a href="#jd_map_case" class="judgment"><subscript>Case</subscript></a></td></tr><tr><td rowspan="1" colspan="1">    ···</td></tr><tr><td rowspan="1" colspan="1"><map><emph>CaseClause</emph><subscript>n</subscript></map><a href="#jd_map_case" class="judgment"><subscript>Case</subscript></a></td></tr><tr><td rowspan="1" colspan="1"><map>  default <emph>OptVarName</emph> return <emph>Expr</emph><subscript>n+1</subscript> </map><a href="#jd_map_case" class="judgment"><subscript>Case</subscript></a></td></tr></tbody></table>
            </expression></core></mapping></smnorm><smnotation><p>For convenience, we use the following auxiliary grammar
          productions to denote case clauses in a typeswitch.</p><scrap headstyle="show"><head>FormalCaseClauses</head><prodrecap id="FormalCaseClauses" ref="FormalCaseClauses" orig="formal"/><prodrecap id="FormalCaseClause" ref="FormalCaseClause" orig="formal"/><prodrecap id="FormalDefaultCaseClause" ref="FormalDefaultCaseClause" orig="formal"/></scrap><p id="jd_type_case">The following judgments</p><display>
             <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_type_case" class="judgment"><term>case</term></a> <emph>FormalCaseClause</emph> <a href="#jd_type_case" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause>
          </display><display>
             <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_type_case" class="judgment"><term>case</term></a> <emph>FormalDefaultCaseClause</emph> <a href="#jd_type_case" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause>
          </display><p>is used in the static semantics of typeswitch. It
          indicates that under the static environment <a href="#xq_stat_env_def" class="env">statEnv</a>,
          and with the input type of the typeswitch being <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,
          the given case clause yields the type <a href="#doc-fs-Type"><emph>Type</emph></a>.</p><p id="jd_against">The following judgment</p><display>
           <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_against" class="judgment"><term>against</term></a> <emph>FormalCaseClauses</emph> <a href="#jd_against" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression></clause>
        </display><p>is used in the dynamic semantics of typeswitch. It
          indicates that under the dynamic environment <a href="#xq_dyn_env_def" class="env">dynEnv</a>,
          with the input value of the typeswitch being <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>,
          the given case clauses yield the value <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>.</p></smnotation><smtype><p>The static typing rules for the typeswitch expression are
          simple.  Each case clause and the default clause of the
          typeswitch is typed independently. The type of the entire
          typeswitch expression is the union of the types of all the
          clauses.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>Expr</emph><subscript>0</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>
                      <a href="#jd_type_case" class="judgment"><term>case</term></a> case $<emph>VarName</emph><subscript>1</subscript> as <emph>SequenceType</emph><subscript>1</subscript> return <emph>Expr</emph><subscript>1</subscript>
                      <a href="#jd_type_case" class="judgment"><term>:</term></a>
                      <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><expression>    ···</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>
                      <a href="#jd_type_case" class="judgment"><term>case</term></a> case $<emph>VarName</emph><subscript>n</subscript> as <emph>SequenceType</emph><subscript>n</subscript> return <emph>Expr</emph><subscript>n</subscript>
                      <a href="#jd_type_case" class="judgment"><term>:</term></a>
                      <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>
                      <a href="#jd_type_case" class="judgment"><term>case</term></a> default $<emph>VarName</emph><subscript>n+1</subscript> return <emph>Expr</emph><subscript>n</subscript>
                      <a href="#jd_type_case" class="judgment"><term>:</term></a>
                      <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n+1</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
               <table summary=""><tbody><tr><td rowspan="1" colspan="1">
                      <table summary=""><tbody><tr><td rowspan="1" colspan="1">(typeswitch (<emph>Expr</emph><subscript>0</subscript>)</td></tr><tr><td rowspan="1" colspan="1">  case $<emph>VarName</emph><subscript>1</subscript> as <emph>SequenceType</emph><subscript>1</subscript> return <emph>Expr</emph><subscript>1</subscript></td></tr><tr><td rowspan="1" colspan="1">    ···</td></tr><tr><td rowspan="1" colspan="1">  case $<emph>VarName</emph><subscript>n</subscript> as <emph>SequenceType</emph><subscript>n</subscript> return <emph>Expr</emph><subscript>n</subscript></td></tr><tr><td rowspan="1" colspan="1">  default $<emph>VarName</emph><subscript>n+1</subscript> return <emph>Expr</emph><subscript>n+1</subscript>)</td></tr></tbody></table>
                    </td></tr></tbody></table>
                <a href="#jd_has_type" class="judgment"><term>:</term></a> (<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> | ... | <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n+1</subscript>)
              </expression></clause></postjudge></infer></infergr><p>To type one case clause, the case variable is assigned
          the type of the case clause <emph>Case</emph><a href="#doc-fs-Type"><emph>Type</emph></a> and the body of
          the clause is typed in the extended environment.  Thus, the
          type of a case clause is independent of the type of the
          input expression.</p><infergr><infer><prejudge><multiclause><clause><expression>
                <emph>Case</emph><a href="#doc-fs-Type"><emph>Type</emph></a> = <map> <emph>SequenceType</emph>
                </map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>VarName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph></expression></clause></multiclause><multiclause><clause><environment><update><environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a></environment><expression><emph>Variable</emph> =&gt;
                       <emph>Case</emph><a href="#doc-fs-Type"><emph>Type</emph></a> </expression></update></environment><expression><emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
              <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> <a href="#jd_type_case" class="judgment"><term>case</term></a> case $<emph>VarName</emph> as
              <emph>SequenceType</emph> return <emph>Expr</emph> <a href="#jd_type_case" class="judgment"><term>:</term></a>  <a href="#doc-fs-Type"><emph>Type</emph></a>
              </expression></clause></postjudge></infer></infergr><p>To type the default clause, the variable is assigned the
          type of the input expression and the body of the default
          clause is typed in the extended environment.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>VarName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a> <emph>Variable</emph>
 	      </expression></clause></multiclause><multiclause><clause><environment><update><environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a></environment><expression><emph>Variable</emph> =&gt;
                       <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> </expression></update></environment><expression><emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
              <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> <a href="#jd_type_case" class="judgment"><term>case</term></a> default $<emph>VarName</emph> 
              return <emph>Expr</emph> <a href="#jd_type_case" class="judgment"><term>:</term></a>  <a href="#doc-fs-Type"><emph>Type</emph></a>
              </expression></clause></postjudge></infer></infergr></smtype><smeval><p>The evaluation of a typeswitch proceeds as
          follows. First, the input expression is evaluated, yielding
          an input value.  The <term>effective case</term> is the
          first <code>case</code> clause such that the input value
          matches the SequenceType in the <code>case</code> clause.
          The <code>return</code> clause of the effective case is
          evaluated and the value of the <code>return</code>
          expression is the value of the typeswitch expression.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript> <a href="#jd_against" class="judgment"><term>against</term></a> <emph>FormalCaseClauses</emph> <a href="#jd_against" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>typeswitch (<emph>Expr</emph>) <emph>FormalCaseClauses</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript></expression></clause></postjudge></infer></infergr><p>If the value matches the sequence type, the following
          rule applies: It extends the dynamic environment by binding
          the variable <emph>Variable</emph> to <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript> and evaluates the
          body of the <code>return</code> clause.</p><infergr><infer><prejudge><multiclause><clause><expression>
                 <emph>Case</emph><a href="#doc-fs-Type"><emph>Type</emph></a> = <map> <emph>SequenceType</emph> </map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
               </expression></clause></multiclause><multiclause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <emph>Case</emph><a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment><expression><emph>VarName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph></expression></clause></multiclause><multiclause><clause><environment>
                   <update><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment><expression><emph>Variable</emph> =&gt; <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript></expression></update>
                 </environment><expression>
                   <emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>
                 </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
                     <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript> <a href="#jd_against" class="judgment"><term>against</term></a> case $<emph>VarName</emph> as
                     <emph>SequenceType</emph> return <emph>Expr</emph> <emph>FormalCaseClauses</emph>
                     <a href="#jd_against" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>
                     </expression></clause></postjudge></infer></infergr><p>If the value does not match the sequence type, the
          current case is not evaluated, and the remaining case
          clauses are evaluated in order by applying the inference
          rule recursively.</p><infergr><infer><prejudge><multiclause><clause><expression>
                <emph>Case</emph><a href="#doc-fs-Type"><emph>Type</emph></a> = <map> <emph>SequenceType</emph> </map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression></clause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><a href="#jd_not" class="judgment"><term>not</term></a>(<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <emph>Case</emph><a href="#doc-fs-Type"><emph>Type</emph></a>)</expression></clause><clause><environment> <a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript> <a href="#jd_against" class="judgment"><term>against</term></a>
                     <emph>FormalCaseClauses</emph> <a href="#jd_against" class="judgment"><term>=&gt;</term></a>
                     <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript> <a href="#jd_against" class="judgment"><term>against</term></a> case
                     $<emph>VarName</emph> as <emph>SequenceType</emph> return <emph>Expr</emph>
                     <emph>FormalCaseClauses</emph> <a href="#jd_against" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>
                     </expression></clause></postjudge></infer></infergr><p>The last rule states that the <code>default</code> branch
          of a typeswitch expression always evaluates to the value of
          its <code>return</code> clause.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment><expression><emph>VarName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph></expression></clause></multiclause><multiclause><clause><environment><update><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment><expression><emph>Variable</emph> =&gt; <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript></expression></update></environment><expression><emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript> <a href="#jd_against" class="judgment"><term>against</term></a> default
                    $<emph>VarName</emph> return <emph>Expr</emph> <a href="#jd_against" class="judgment"><term>=&gt;</term></a>
                    <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript></expression></clause></postjudge></infer></infergr></smeval></div3><div3 id="sec_cast"><head>Cast</head><smintro><p>The <code>cast</code> expression can be used to convert a
          value to a specific datatype. It changes both the type and
          value of the result of an expression, and can only be
          applied to an atomic value.</p></smintro><scrap headstyle="show"><head/><prodrecap id="CastExpr" ref="CastExpr" orig="xquery"/><prodrecap id="SingleType" ref="SingleType" orig="xquery"/></scrap><smcore><p>The Core grammar productions for <code>cast</code>
          expressions are:</p><scrap headstyle="show"><head/><prodrecap id="core-CastExpr" ref="CastExpr" orig="core"/><prodrecap id="core-SingleType" ref="SingleType" orig="core"/></scrap></smcore><smnorm><p>The normalization of cast applies atomization to its
          argument. The type declaration asserts that the result is a
          single atomic value.  The second normalization rule applies
          when the target type is optional.</p><mapping><xquery><expression><map><emph>Expr</emph> cast as <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a> </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression></xquery><core><expression>
             <table summary=""><tbody><tr><td rowspan="1" colspan="1">let $v as <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a> := <code>fn:data</code>((<map> <emph>Expr</emph> </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)) return</td></tr><tr><td rowspan="1" colspan="1">  $v cast as <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a> </td></tr></tbody></table>
            </expression></core></mapping><mapping><xquery><expression><map><emph>Expr</emph> cast as <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a>? </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression></xquery><core><expression>
             <table summary=""><tbody><tr><td rowspan="1" colspan="1">let $v as <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>? := <code>fn:data</code>((<map> <emph>Expr</emph> </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)) return</td></tr><tr><td rowspan="1" colspan="1">  typeswitch ($v)</td></tr><tr><td rowspan="1" colspan="1">    case $<emph>fs:</emph>new as empty-sequence() return ()</td></tr><tr><td rowspan="1" colspan="1">    default $<emph>fs:</emph>new return $v cast as <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a> </td></tr></tbody></table>
            </expression></core></mapping></smnorm><smtype><p>The static typing rule of <code>cast</code> expression is
          as follows. The type of a Core <code>cast</code> expression
          is always the target type. Note that a <code>cast</code>
          expression can fail at run-time if the given value cannot be
          cast to the target type.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>Expr</emph> cast as <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a></expression></clause></postjudge></infer></infergr></smtype><smnotation><p>The dynamic semantics of <code>cast</code> expressions is
          defined in <xspecref spec="FO" ref="casting"/>. The
          semantics of cast expressions depends on the type of the
          input value and on the target type. For any source and
          target primitive types, the <emph>casting table</emph> in
          <xspecref spec="FO" ref="casting"/> indicates whether the
          cast from the source type to the target type is permitted.
          When a cast is permitted, the detailed dynamic evaluation
          rules for cast in <xspecref spec="FO" ref="casting"/> are
          applied. We refer to those rules using an auxiliary judgment
          defined as follows.</p><p id="jd_cast_value_to">The judgment</p><display>
            <clause><expression><a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a><subscript>1</subscript> <a href="#jd_cast_value_to" class="judgment"><term>cast value to type</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a>
            <a href="#jd_cast_value_to" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a><subscript>2</subscript></expression></clause>
          </display><p>holds if <a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a><subscript>1</subscript> can be cast to type
          <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a>, resulting in the new value
          <a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a><subscript>2</subscript> according to the rules in <xspecref spec="FO" ref="casting"/>.</p></smnotation><smeval><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
                 <emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a><subscript>1</subscript>
               </expression></clause></multiclause><multiclause><clause><expression><a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a><subscript>1</subscript> <a href="#jd_cast_value_to" class="judgment"><term>cast value to type</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a>
              <a href="#jd_cast_value_to" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a><subscript>2</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>Expr</emph> cast as <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a><subscript>2</subscript></expression></clause></postjudge></infer></infergr></smeval></div3><div3 id="sec_castable"><head>Castable</head><scrap headstyle="show"><head/><prodrecap id="CastableExpr" ref="CastableExpr" orig="xquery"/></scrap><p>Castable expressions check whether a value can be cast to a
        given type.</p><smcore><p>The Core grammar production for castable is:</p><scrap headstyle="show"><head/><prodrecap ref="CastableExpr" id="core-CastableExpr" orig="core"/></scrap></smcore><smnorm><p>The normalization of castable simply maps its expression
          argument.</p><mapping diff="del" at="E032"><xquery><expression><map><emph>Expr</emph> castable as <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression></xquery><core><expression>
             <table summary=""><tbody><tr><td rowspan="1" colspan="1">let $v as <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a> := <code>fn:data</code>((<map> <emph>Expr</emph> </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)) return</td></tr><tr><td rowspan="1" colspan="1">$v castable as <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a></td></tr></tbody></table>
            </expression></core></mapping><mapping diff="del" at="E032"><xquery><expression><map><emph>Expr</emph> castable as <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a>?</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression></xquery><core><expression>
             <table summary=""><tbody><tr><td rowspan="1" colspan="1">let $v as <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>? := <code>fn:data</code>((<map> <emph>Expr</emph> </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)) return</td></tr><tr><td rowspan="1" colspan="1">$v castable as <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a>?</td></tr></tbody></table>
            </expression></core></mapping><mapping diff="add" at="E032"><xquery><expression>
                <map><emph>Expr</emph> castable as <emph>SingleType</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
              </expression></xquery><core><expression>
                ( <map><emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> ) castable as <emph>SingleType</emph>
              </expression></core></mapping></smnorm><smtype><p>The type of a Core <code>castable</code> expression is
          always a boolean.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>Expr</emph> castable as <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:boolean</code></expression></clause></postjudge></infer></infergr></smtype><smnotation diff="add" at="E032"><p id="jd_can_be_cast_to">The auxiliary judgment:</p><display>
            <clause><expression>
                <a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_can_be_cast_to" class="judgment"><term>can be cast to</term></a> <emph>SingleType</emph>
              </expression></clause>
          </display><p>
          holds when <a href="#doc-fs-Value"><emph>Value</emph></a> can be atomized and cast to <emph>SingleType</emph>.
          Its definition depends on the <a href="#jd_cast_value_to" class="judgment"><term>cast value to type</term></a> judgment.
          </p><infergr><infer><prejudge/><postjudge><multiclause><clause><expression>() <a href="#jd_can_be_cast_to" class="judgment"><term>can be cast to</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a>?</expression></clause></multiclause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><expression><a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_can_be_cast_to" class="judgment"><term>can be cast to</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a></expression></clause></multiclause></prejudge><postjudge><multiclause><clause><expression><a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_can_be_cast_to" class="judgment"><term>can be cast to</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a>?</expression></clause></multiclause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><expression>fn:data(<a href="#doc-fs-Value"><emph>Value</emph></a>) = <a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><expression>
                      <a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a><subscript>1</subscript>
                      <a href="#jd_cast_value_to" class="judgment"><term>cast value to type</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a>
                      <a href="#jd_cast_value_to" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a><subscript>2</subscript>
                    </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><expression><a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_can_be_cast_to" class="judgment"><term>can be cast to</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a></expression></clause></multiclause></postjudge></infer></infergr></smnotation><smeval><p>
          <phrase diff="del" at="E032">If casting succeeds,</phrase>
          <phrase diff="add" at="E032">If the value of the operand expression can be cast to the given type,</phrase>
          then the <code>castable</code>
          expression evaluates to true.</p><infergr><infer><prejudge><multiclause diff="del" at="E032"><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>Expr</emph> cast as <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression></clause></multiclause><multiclause diff="add" at="E032"><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a></expression></clause></multiclause><multiclause diff="add" at="E032"><clause><expression><a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_can_be_cast_to" class="judgment"><term>can be cast to</term></a> <emph>SingleType</emph></expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>Expr</emph> castable as
                        <phrase diff="del" at="E032"><a href="#doc-core-AtomicType"><emph>AtomicType</emph></a></phrase>
                        <phrase diff="add" at="E032"><emph>SingleType</emph></phrase>
                      <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> true</expression></clause></multiclause></postjudge></infer></infergr><p>Otherwise, 'castable as' evaluates to false.</p><infergr><infer><prejudge><multiclause diff="del" at="E032"><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><a href="#jd_not" class="judgment"><term>not</term></a>(<emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>)</expression></clause></multiclause><multiclause diff="add" at="E032"><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a></expression></clause></multiclause><multiclause diff="add" at="E032"><clause><expression><a href="#jd_not" class="judgment"><term>not</term></a>(<a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_can_be_cast_to" class="judgment"><term>can be cast to</term></a> <emph>SingleType</emph>)</expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
                        <phrase diff="del" at="E032"><emph>Expr</emph><subscript>1</subscript></phrase>
                        <phrase diff="add" at="E032"><emph>Expr</emph></phrase>
                        castable as
                        <phrase diff="del" at="E032"><a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>2</subscript></phrase>
                        <phrase diff="add" at="E032"><emph>SingleType</emph></phrase>
                        <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> false</expression></clause></multiclause></postjudge></infer></infergr></smeval></div3><div3 id="sec_constructor-functions"><head>Constructor Functions</head><p>Constructor functions provide an alternative syntax for
        casting.</p><smnotation diff="add" at="E008"><p id="jd_denotes_a_constructor_function">
            Calls to constructor functions
            are normalized differently from other function calls,
            so we introduce an auxiliary judgment
            to detect whether the function being called
            is a constructor function.
          </p><display>
            <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> <a href="#jd_denotes_a_constructor_function" class="judgment"><term>denotes a constructor function</term></a>
              </expression></clause>
          </display><p>
            This judgment holds when the expanded function name
            maps to an atomic type in the in-scope schema types.
          </p><infergr><infer><prejudge><multiclause><clause><expression>
                      <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>) = define type <emph>QName</emph> <a href="#doc-fs-AtomicTypeDerivation"><emph>AtomicTypeDerivation</emph></a>
                    </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                    <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> <a href="#jd_denotes_a_constructor_function" class="judgment"><term>denotes a constructor function</term></a>
                  </expression></clause></postjudge></infer></infergr></smnotation><smnorm><p>Constructor functions for atomic types are normalized to
          explicit <code>cast as</code> expressions. Note that the
          following normalization rule requires to resolve the name of
          the function call and <phrase diff="chg" at="E008">confirm that it
          denotes a constructor function</phrase> in the static context.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>QName</emph> <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression></clause></multiclause><multiclause><clause diff="chg" at="E008"><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> <a href="#jd_denotes_a_constructor_function" class="judgment"><term>denotes a constructor function</term></a>
              </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
              <map><emph>QName</emph>(<emph>ExprSingle</emph><subscript>1</subscript>)</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
              =
              <map><emph>ExprSingle</emph><subscript>1</subscript> cast as <emph>QName</emph>?</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
            </expression></clause></postjudge></infer></infergr></smnorm></div3><div3 id="sec_treat"><head>Treat</head><scrap headstyle="show"><head/><prodrecap id="TreatExpr" ref="TreatExpr" orig="xquery"/></scrap><smintro><p>The expression <quote><emph>Expr</emph> treat as
            <emph>SequenceType</emph></quote>, can be used to change the
            static type of the result of an expression without
            changing its value.  The treat-as expression raises a
            dynamic error if the dynamic type of the input value does
            not match the specified type.</p></smintro><smnorm><p>Treat as expressions are normalized to typeswitch
            expressions. Note that the following normalization rule
            uses a variable $<emph>fs:</emph>new, which is a newly created
            variable that does not conflict with any variables already
            in scope.</p><mapping><xquery><expression><map><emph>Expr</emph> treat as <emph>SequenceType</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression></xquery><core><expression>
               <table summary=""><tbody><tr><td rowspan="1" colspan="1">typeswitch (<map> <emph>Expr</emph> </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)</td></tr><tr><td rowspan="1" colspan="1">  case $<emph>fs:</emph>new as <emph>SequenceType</emph> return $<emph>fs:</emph>new</td></tr><tr><td rowspan="1" colspan="1">  default $<emph>fs:</emph>new return <code>fn:error</code>()</td></tr></tbody></table>
              </expression></core></mapping></smnorm></div3></div2><div2 id="sec_validate_expr"><head>Validate Expressions</head><scrap headstyle="show"><head/><prodrecap id="ValidateExpr" ref="ValidateExpr" orig="xquery"/><prodrecap id="ValidationMode" ref="ValidationMode" orig="xquery"/></scrap><smcore><p>The Core grammar productions for validate are:</p><scrap headstyle="show"><head/><prodrecap id="core-ValidateExpr" ref="ValidateExpr" orig="core"/><prodrecap id="core-ValidationMode" ref="ValidationMode" orig="core"/></scrap></smcore><p>A <code>validate</code> expression validates its argument
      with respect to the <term>in-scope schema definitions</term>,
      using the schema validation process described in
      <bibref ref="xmlschema-1"/>. The argument to a validate expression must be
      either an element or a document node. Validation replaces all
      nodes with new nodes that have their own identity, the <xtermref spec="XQ" ref="dt-type-annotation"/>, and default values created
      during the validation process.</p><smnorm><p>A validate expression with no validation mode is normalized
        into a validate expression with the validation mode set to
        strict.</p><mapping><xquery><expression>
          <map>validate { <emph>Expr</emph> }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
        </expression></xquery><core><expression>
          validate strict { <map><emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> }
        </expression></core></mapping><mapping><xquery><expression>
          <map>validate <emph>ValidationMode</emph> { <emph>Expr</emph> }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
        </expression></xquery><core><expression>
          validate <emph>ValidationMode</emph> { <map><emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> }
        </expression></core></mapping></smnorm><smtype><p>Static typing of the validate operation is defined by the
        following rule.  Note the use of a subtyping check to ensure
        that the type of the expression to validate is either an
        element or a well-formed document node (i.e., with only one
        root element and no text nodes).  The type of the expression
        to validate may be a union of more than one element type.  We
        apply the <a href="#jd_in_validation_context" class="judgment"><term>with mode</term></a> judgment to each element type to
        determine the meaning of that element type with the given
        validation mode, which yields a new element type.  The result
        type is the union over all new element types.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> (element<phrase diff="add" at="E023"> *</phrase> | document { <a href="#doc-fs-ElementType"><emph>ElementType</emph></a> })</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) =  <a href="#doc-fs-ElementType"><emph>ElementType</emph></a><subscript>1</subscript> |
            ... | <a href="#doc-fs-ElementType"><emph>ElementType</emph></a><subscript>n</subscript> </expression></clause></multiclause><multiclause><clause><expression><a href="#doc-fs-ElementType"><emph>ElementType</emph></a><subscript>1</subscript> = element <a href="#doc-xquery-ElementNameOrWildcard"><emph>ElementNameOrWildcard</emph></a><subscript>1</subscript> <a href="#doc-fs-OptTypeSpecifier"><emph>OptTypeSpecifier</emph></a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><expression>···</expression></clause></multiclause><multiclause><clause><expression><a href="#doc-fs-ElementType"><emph>ElementType</emph></a><subscript>n</subscript> = element <a href="#doc-xquery-ElementNameOrWildcard"><emph>ElementNameOrWildcard</emph></a><subscript>n</subscript>  <a href="#doc-fs-OptTypeSpecifier"><emph>OptTypeSpecifier</emph></a><subscript>n</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-xquery-ElementNameOrWildcard"><emph>ElementNameOrWildcard</emph></a><subscript>1</subscript> <a href="#jd_in_validation_context" class="judgment"><term>with mode</term></a> <emph>ValidationMode</emph> 
             <a href="#jd_in_validation_context" class="judgment"><term>resolves to</term></a> <a href="#doc-fs-ElementType"><emph>ElementType</emph></a><subscript>1</subscript> </expression></clause></multiclause><multiclause><clause><expression>···</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-xquery-ElementNameOrWildcard"><emph>ElementNameOrWildcard</emph></a><subscript>n</subscript> <a href="#jd_in_validation_context" class="judgment"><term>with mode</term></a> <emph>ValidationMode</emph> 
             <a href="#jd_in_validation_context" class="judgment"><term>resolves to</term></a> <a href="#doc-fs-ElementType"><emph>ElementType</emph></a><subscript>n</subscript> </expression></clause></multiclause><multiclause><clause><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> = <a href="#doc-fs-ElementType"><emph>ElementType</emph></a><subscript>1</subscript> | ... | <a href="#doc-fs-ElementType"><emph>ElementType</emph></a><subscript>n</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>validate <emph>ValidationMode</emph> { <emph>Expr</emph> } <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
                   </expression></clause></postjudge></infer></infergr></smtype><div3 id="sec_validating_element"><head>Validating an Element Node</head><smeval><p>The normative dynamic semantics of validation is specified
        in <xspecref spec="XQ" ref="id-validate"/>.  The effect of
        validation of a data model value is equivalent to:

        <ulist><item><p>serialization of the data model, as described in
          <bibref ref="xslt-xquery-serialization-30"/>, followed by</p></item><item><p>validation of the serialized value into a Post-Schema
          Validated Infoset, as described in <bibref ref="xmlschema-1"/>, followed by</p></item><item><p>construction of a new data model value, as described in
          <bibref ref="xpath-datamodel-30"/>.</p></item></ulist>
        </p><p>The above steps are expressed formally by the "erasure" and
        "annotation" judgments.  Formally, validation removes existing
        type annotations from nodes ("erasure"), and it re-validates
        the corresponding data model instance, possibly adding new
        type annotations to nodes ("annotation"). Both erasure and
        annotation are described formally in <specref ref="sec_validation_judgments"/>. Indeed, the conjunction of
        erasure and annotation provides a formal model for a large
        part of actual schema validation. The semantics of the
        <code>validate</code> expression is specified as follows.</p><p>In the first premise below, the expression to validate is
        evaluated. The resulting value must be an element or document
        node. The second premise constructs a new value in which all
        existing type annotations have been erased. The third premise
        determines the element type that corresponds to the element
        node's name in the given validation mode. The last premise
        validates erased element node with the type against which it
        is validated, using the <a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> judgment, yielding
        the final validated element.</p><infergr><infer><prejudge><multiclause><clause><environment>
               <a href="#xq_stat_env_def" class="env">statEnv</a>; <a href="#xq_dyn_env_def" class="env">dynEnv</a>
             </environment><expression>
               <emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-ElementValue"><emph>ElementValue</emph></a><subscript>1</subscript>
             </expression></clause></multiclause><multiclause><clause><expression><a href="#doc-fs-ElementValue"><emph>ElementValue</emph></a><subscript>1</subscript> <a href="#jd_erases_to" class="judgment"><term>erases to</term></a> <a href="#doc-fs-ElementValue"><emph>ElementValue</emph></a><subscript>2</subscript> 
            </expression></clause></multiclause><multiclause><clause><expression>
            <a href="#doc-fs-ElementValue"><emph>ElementValue</emph></a><subscript>2</subscript> = element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>2</subscript> of type <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>2</subscript> { <a href="#doc-fs-Value"><emph>Value</emph></a> }
</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>2</subscript> <a href="#jd_in_validation_context" class="judgment"><term>with mode</term></a> <emph>ValidationMode</emph> 
             <a href="#jd_in_validation_context" class="judgment"><term>resolves to</term></a> <a href="#doc-fs-ElementType"><emph>ElementType</emph></a><subscript>2</subscript> </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-ElementType"><emph>ElementType</emph></a><subscript>2</subscript> ( <a href="#doc-fs-ElementValue"><emph>ElementValue</emph></a><subscript>2</subscript>) <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a>
             <a href="#doc-fs-ElementValue"><emph>ElementValue</emph></a><subscript>3</subscript> </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>validate <emph>ValidationMode</emph> { <emph>Expr</emph> } <a href="#jd_yields" class="judgment"><term>=&gt;</term></a>
                   <a href="#doc-fs-ElementValue"><emph>ElementValue</emph></a><subscript>3</subscript> 
                   </expression></clause></postjudge></infer></infergr></smeval></div3><div3 id="sec_validating_document"><head>Validating a Document Node</head><p>The rule for validating a document node is similar to that
      for validating an element node.</p><smeval><infergr><infer><prejudge><multiclause><clause><environment>
               <a href="#xq_stat_env_def" class="env">statEnv</a>; <a href="#xq_dyn_env_def" class="env">dynEnv</a>
             </environment><expression>
               <emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> document { <a href="#doc-fs-ElementValue"><emph>ElementValue</emph></a><subscript>1</subscript> }
             </expression></clause></multiclause><multiclause><clause><expression>document { <a href="#doc-fs-ElementValue"><emph>ElementValue</emph></a><subscript>1</subscript> } <a href="#jd_erases_to" class="judgment"><term>erases to</term></a>
            document { <a href="#doc-fs-ElementValue"><emph>ElementValue</emph></a><subscript>2</subscript> }</expression></clause></multiclause><multiclause><clause><expression>
            <a href="#doc-fs-ElementValue"><emph>ElementValue</emph></a><subscript>2</subscript> = element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>2</subscript> of type <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>2</subscript> { <a href="#doc-fs-Value"><emph>Value</emph></a> }
</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>2</subscript> <a href="#jd_in_validation_context" class="judgment"><term>with mode</term></a>
            <emph>ValidationMode</emph> <a href="#jd_in_validation_context" class="judgment"><term>resolves to</term></a>
            <a href="#doc-fs-ElementType"><emph>ElementType</emph></a><subscript>2</subscript> </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> document { <a href="#doc-fs-ElementType"><emph>ElementType</emph></a><subscript>2</subscript> } (document { <a href="#doc-fs-ElementValue"><emph>ElementValue</emph></a><subscript>2</subscript> }) <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a>
            document { <a href="#doc-fs-ElementValue"><emph>ElementValue</emph></a><subscript>3</subscript> }</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>validate <emph>ValidationMode</emph> { <emph>Expr</emph> } <a href="#jd_yields" class="judgment"><term>=&gt;</term></a>
                   document { <a href="#doc-fs-ElementValue"><emph>ElementValue</emph></a><subscript>3</subscript> }
                   </expression></clause></postjudge></infer></infergr></smeval></div3></div2><div2 id="id-extension-expressions" role="xquery"><head>Extension Expressions</head><smintro><p>An extension expression is an expression whose semantics are
     implementation-defined. An extension expression consists of one
     or more pragmas, followed by an expression enclosed in curly
     braces.</p><scrap headstyle="show"><head/><prodrecap id="ExtensionExpr" ref="ExtensionExpr" orig="xquery"/><prodrecap id="Pragma" ref="Pragma" orig="xquery"/><prodrecap id="PragmaContents" ref="PragmaContents" orig="xquery"/></scrap></smintro><smcore><p>The Core grammar productions for ExtensionExpr are:</p><scrap headstyle="show"><head/><prodrecap id="core-ExtensionExpr" ref="ExtensionExpr" orig="core"/><prodrecap id="core-Pragma" ref="Pragma" orig="core"/><prodrecap id="core-PragmaContents" ref="PragmaContents" orig="core"/></scrap></smcore><smnorm><p>Extension expressions are normalized as extension expressions
      in the [XPath/XQuery] Core.</p><mapping><xquery><expression><map><emph>Pragma</emph>+ { <emph>Expr</emph> }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression></xquery><core><expression><emph>Pragma</emph>+ { <map><emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> }</expression></core></mapping><p>If the extension expression does not contain any expression,
      this is normalized into an extension expression with a call to
      the <code>fn:error</code> function.</p><mapping><xquery><expression><map><emph>Pragma</emph>+ { }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression></xquery><core><expression><emph>Pragma</emph>+ { <code>fn:error</code>() }</expression></core></mapping></smnorm><smtype><p>If at least one of the pragmas is recognized, the static
     semantics are implementation-defined.</p><p>If none of the pragmas is recognized, the static semantics
     are the same as for the input expression. In both cases, the
     static typing must be applied on the input expression, possibly
     raising the corresponding type errors.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
           </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             A <emph>Pragma</emph> is recognized, yielding the
             implementation-defined static type <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>.
           </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
          <emph>Pragma</emph>+ { <emph>Expr</emph> } <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
         </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
           </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             No <emph>Pragma</emph> is recognized.
           </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
          <emph>Pragma</emph>+ { <emph>Expr</emph> } <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
         </expression></clause></postjudge></infer></infergr></smtype><smeval><p>The QName of a pragma must resolve to a namespace URI and
     local name, using the statically known namespaces. If at least
     one of the pragmas is recognized, the dynamic semantics is
     implementation-defined.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
             Some <emph>Pragma</emph> are recognized, yielding the
             implementation-defined value <a href="#doc-fs-Value"><emph>Value</emph></a>.
           </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
          <emph>Pragma</emph>+ { <emph>Expr</emph> } <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
         </expression></clause></postjudge></infer></infergr><p>If none of the pragmas is recognized, the dynamic semantics of
     an <emph>ExtensionExpr</emph> are the same as evaluating the given
     expression.</p><infergr><infer><prejudge><multiclause><clause><expression>
             No <emph>Pragma</emph> is recognized.
           </expression></clause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
             <emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
           </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
          <emph>Pragma</emph>+ { <emph>Expr</emph> } <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
         </expression></clause></postjudge></infer></infergr></smeval></div2></div1><!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-indent-step:2
indent-tabs-mode:nil
sgml-parent-document:("XPathXQuerySemantics.xml" "body" "div1")
End:
--><div1 id="id-query-prolog"><head>Modules and Prologs</head><p>The organization of this section parallels the organization of
  <xspecref spec="XQ" ref="id-query-prolog"/>.</p><smintro><p>XQuery supports modules as defined in <xspecref spec="XQ" ref="id-query-prolog"/>.  A <xtermref spec="XQ" ref="dt-main-module"/> contains a <xtermref spec="XQ" ref="dt-prolog"/> followed by a <xtermref spec="XQ" ref="dt-queryBody"/>.  A query has exactly one main module. In a
    main module, the <xtermref spec="XQ" ref="dt-queryBody"/> can be
    evaluated, and its value is the result of the query. A <xtermref spec="XQ" ref="dt-library-module"/> contains a module declaration
    followed by a <xtermref spec="XQ" ref="dt-prolog"/>.</p><p>The Prolog is a sequence of declarations that affect query
    processing. The Prolog can be used, for example, to declare
    namespace prefixes, import types from XML Schemas, and declare
    functions and variables.  Namespace declarations and schema
    imports always precede function and variable declarations, as
    specified by the following grammar productions.</p><scrap headstyle="show"><head>Query Module</head><prodrecap id="Module" ref="Module" orig="xquery"/><prodrecap id="MainModule" ref="MainModule" orig="xquery"/><prodrecap id="LibraryModule" ref="LibraryModule" orig="xquery"/><prodrecap id="Prolog" ref="Prolog" orig="xquery"/><prodrecap id="Setter" ref="Setter" orig="xquery"/><prodrecap id="Import" ref="Import" orig="xquery"/><prodrecap id="Separator" ref="Separator" orig="xquery"/><prodrecap id="QueryBody" ref="QueryBody" orig="xquery"/></scrap><p>Function declarations are globally scoped, that is, the use of
    a function name in a function call may precede declaration of the
    function.  Variable declarations are lexically scoped, i.e.,
    variable declarations must precede variable uses.</p></smintro><smcore><p>The module declarations and prolog are processed as part of
     the static and dynamic context processing. In addition,
     normalization of prolog declarations is performed into a
     simplified formal grammar given below. As a result, the XQuery
     core does not need to include the prolog and module
     declarations. The entry point for the core grammar is the
     <emph>Expr</emph> non-terminal, as given in <specref ref="id-expressions"/>.</p><!--
    <scrap>
      <head>Query Module</head>
      <prodrecap id="core-Module"          ref="Module"          orig="core"/>
      <prodrecap id="core-MainModule"      ref="MainModule"      orig="core"/>
      <prodrecap id="core-LibraryModule"   ref="LibraryModule"   orig="core"/>
      <prodrecap id="core-Prolog"          ref="Prolog"          orig="core"/>
      <prodrecap id="core-Setter"          ref="Setter"          orig="core"/>
      <prodrecap id="core-Import"          ref="Import"          orig="core"/>
      <prodrecap id="core-QueryBody"       ref="QueryBody"       orig="core"/>
    </scrap>
--></smcore><smnotation><p>Modules are identified and can be imported using a target
    namespace (a URI). In [XPath/XQuery], the process by which a module is
    obtained from a given target namespace is implementation
    defined. In this specification, we use the following auxiliary
    judgment to model that implementation defined process.</p><p id="jd_is_target_namespace_of_modules">The judgment:</p><display>
      <clause><expression><emph>AnyURI</emph> <a href="#jd_is_target_namespace_of_modules" class="judgment"><term>is target namespace of modules</term></a>
        <emph>Module</emph><subscript>1</subscript> ... <emph>Module</emph><subscript>n</subscript>
        </expression></clause>
    </display><p>holds if <emph>Module</emph><subscript>1</subscript> ... <emph>Module</emph><subscript>n</subscript> are the modules
    associated to the target namespace <emph>AnyURI</emph>, and such as
    <emph>Module</emph><subscript>i</subscript> does not depend directly, or transitively on any
    module after it. (See <bibref ref="xquery-30"/> for the formal
    definition of whether a module directly depends on another)</p></smnotation><smnotation><p>The XQuery Prolog requires that declarations appear in a
    particular order.  In the Formal Semantics, it is simpler to
    assume the declarations can appear in any order, as it does not
    change their semantics -- we simply assume that an XQuery parser
    has enforced the required order.</p><p>The Prolog contains a variety of declarations that specify the
    initial static and dynamic context of the query.  The following
    formal grammar productions represent any Prolog declaration.</p><scrap headstyle="show"><head>Prolog Declarations</head><prodrecap id="PrologDeclList" ref="PrologDeclList" orig="formal"/><prodrecap id="PrologDecl" ref="PrologDecl" orig="formal"/></scrap><p id="jd_map_prolog">The function <map/><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a>
    takes a prolog declaration and maps it into its equivalent
    declaration in the Core grammar.</p><mapping><xquery><expression>
       <map><emph>PrologDecl</emph><subscript>1</subscript></map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a>
      </expression></xquery><core><expression>
       <emph>PrologDecl</emph><subscript>2</subscript>
      </expression></core></mapping><p id="jd_yields_context">The following auxiliary judgments are
    applied when statically processing the declarations in the prolog.
    The effect of the judgment is to process each prolog declaration
    in order, constructing a new static environment from the static
    environment constructed from previous prolog declarations.</p><p>The judgment:</p><display>
      <clause><environment><emph>AnyURI</emph> ; <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></environment><expression><emph>PrologDeclList</emph> <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a>
        <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript> <a href="#jd_yields_context" class="judgment"><term>with</term></a> <emph>PrologDeclList</emph><subscript>1</subscript>
        </expression></clause>
    </display><p>holds if for the given module with namespace <emph>AnyURI</emph>, and
    under the static environment <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript>, the sequence of
    prolog declarations <emph>PrologDeclList</emph> yields the static
    environment <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript> and the normalized sequence of prolog
    declarations in the Core grammar.</p><p>The judgment:</p><display>
      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></environment><expression><emph>PrologDecl</emph> <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></expression></clause>
    </display><p>holds if under the static environment <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript>, the
    single prolog declaration <emph>PrologDecl</emph> yields the new static
    environment <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript>.</p></smnotation><smnotation><p>Because functions can be mutually referential, function
    signatures must be defined in the static environment before static
    type analysis is applied to the function bodies. The following
    judgment is used to extend the static environment with the
    appropriate function signatures. That judgment is used when
    computing the static context for a given module before applying
    static context processing.</p><p id="jd_yields_sigs">The judgment:</p><display>
      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></environment><expression><emph>PrologDeclList</emph> <a href="#jd_yields_sigs" class="judgment"><term>=&gt;</term><subscript>sigs</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></expression></clause>
    </display><p>holds if extending the static environment <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> with
    the function signatures declared in <emph>PrologDeclList</emph> yields the
    new static environment <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript>.</p><p> This judgment is defined as follows. In case there is no
    declaration, the static environment is returned unchanged.</p><infergr><infer><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_yields_sigs" class="judgment"><term>=&gt;</term><subscript>sigs</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a></expression></clause></postjudge></infer></infergr><p>If the case of a namespace declaration, the static context is
    extended with the corresponding namespace binding.</p><infergr><infer><prejudge><multiclause><clause><expression><emph>PrologDecl</emph> = <emph>NamespaceDecl</emph> or <emph>PrologDecl</emph> = <emph>DefaultNamespaceDecl</emph></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>PrologDecl</emph> <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></environment><expression><emph>PrologDeclList</emph> <a href="#jd_yields_sigs" class="judgment"><term>=&gt;</term><subscript>sigs</subscript></a>
              <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>PrologDecl</emph> ; <emph>PrologDeclList</emph>
              <a href="#jd_yields_sigs" class="judgment"><term>=&gt;</term><subscript>sigs</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></expression></clause></postjudge></infer></infergr><p>If the case of a function declaration, the static context is
    extended with the corresponding signature.</p><infergr><infer><prejudge><multiclause><clause><expression><emph>PrologDecl</emph> = <emph>FunctionDecl</emph></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>PrologDecl</emph> <a href="#jd_yields_sigs" class="judgment"><term>=&gt;</term><subscript>sigs</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></environment><expression><emph>PrologDeclList</emph> <a href="#jd_yields_sigs" class="judgment"><term>=&gt;</term><subscript>sigs</subscript></a>
              <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>PrologDecl</emph> ; <emph>PrologDeclList</emph>
              <a href="#jd_yields_sigs" class="judgment"><term>=&gt;</term><subscript>sigs</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><expression><emph>FunctionDecl</emph> = declare function
                <emph>QName</emph> ( $<emph>VarName</emph><subscript>1</subscript> as <emph>SequenceType</emph><subscript>1</subscript>,
                ..., $<emph>VarName</emph><subscript>n</subscript> as <emph>SequenceType</emph><subscript>n</subscript>) as <emph>SequenceType</emph><subscript>r</subscript> (<emph>EnclosedExpr</emph> | external)</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>QName</emph> <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression></clause></multiclause><multiclause><clause><expression><map><emph>SequenceType</emph><subscript>1</subscript></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                        = <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><expression>...</expression></clause></multiclause><multiclause><clause><expression><map><emph>SequenceType</emph><subscript>n</subscript></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                        = <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript></expression></clause></multiclause><multiclause><clause><expression><map><emph>SequenceType</emph><subscript>r</subscript></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                        = <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>r</subscript></expression></clause></multiclause><multiclause><clause><expression>
          <emph>FunctionSig</emph>
          =
          declare function <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, ..., <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>) as <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>r</subscript>
         </expression></clause></multiclause><multiclause><clause><expression>
                <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> =
                    <update><environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_functy_env" class="env">funcType</a></environment><expression><a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><phrase diff="add" at="E006">,n</phrase> =&gt; <emph>FunctionSig</emph></expression></update>
                </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
              <emph>FunctionDecl</emph> <a href="#jd_yields_sigs" class="judgment"><term>=&gt;</term><subscript>sigs</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript>
  	     </expression></clause></postjudge></infer></infergr><p>For all other kinds of declarations, the static context is left
    unchanged.</p><infergr><infer><prejudge><multiclause><clause><expression><a href="#jd_not" class="judgment"><term>not</term></a>(<emph>PrologDecl</emph> = <emph>FunctionDecl</emph>)
            and <a href="#jd_not" class="judgment"><term>not</term></a>(<emph>PrologDecl</emph> = <emph>NamespaceDecl</emph>) and <a href="#jd_not" class="judgment"><term>not</term></a>(<emph>PrologDecl</emph>
            = <emph>DefaultNamespaceDecl</emph>)</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>PrologDecl</emph> ; <emph>PrologDeclList</emph>
              <a href="#jd_yields_sigs" class="judgment"><term>=&gt;</term><subscript>sigs</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a></expression></clause></postjudge></infer></infergr><p>In case of a function declaration, the static context is
    extended with the corresponding function signature.</p></smnotation><smcontext><p>Prolog declarations are processed in the order they are
    encountered.  The normalization of a prolog declaration
    <emph>PrologDecl</emph> depends on the static context processing of all
    previous prolog declarations.  In turn, static context processing
    of <emph>PrologDecl</emph> depends on the normalization of the
    <emph>PrologDecl</emph>.  For example, because variables are lexically
    scoped, the normalization and static context processing of a
    variable declaration depends on the normalization and static
    context processing of all previous variable declarations.
    Therefore, the normalization phase and static context processing
    are interleaved, with normalization preceding static context
    processing for each prolog declaration.</p><p>The following inference rules express this dependency.  The
    first rule specifies that for an empty sequence of prolog
    declarations, the initial static environment is left
    unchanged.</p><infergr><infer><postjudge><clause><environment><emph>AnyURI</emph> ; <a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a> <a href="#jd_yields_context" class="judgment"><term>with</term></a></expression></clause></postjudge></infer></infergr><p>The next two rules interleaves normalization and static context
    processing. The result of static context processing and
    normalization is a static context and the normalized prolog
    declarations. In case the declaration is a module import, the URI
    for the current module is passed to the static context processing
    rule. This allows to avoid self-import, which is handled globally
    (See rules for building the context for module declarations in
    <specref ref="id-module-declaration"/>).</p><infergr><infer><prejudge><multiclause><clause><expression><a href="#jd_not" class="judgment"><term>not</term></a>(<emph>PrologDecl</emph> = <emph>ModuleImport</emph>)</expression></clause></multiclause><multiclause><clause><expression><map><emph>PrologDecl</emph></map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a>
              <phrase diff="chg" at="E007">=</phrase> <emph>PrologDecl</emph><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>PrologDecl</emph><subscript>1</subscript> <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><environment><emph>AnyURI</emph> ; <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></environment><expression><emph>PrologDeclList</emph> <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a>
              <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript> <a href="#jd_yields_context" class="judgment"><term>with</term></a> <emph>PrologDeclList</emph><subscript>1</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><emph>AnyURI</emph> ; <a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>PrologDecl</emph> ; <emph>PrologDeclList</emph>
              <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript> <a href="#jd_yields_context" class="judgment"><term>with</term></a>
              <emph>PrologDecl</emph><subscript>1</subscript> ; <emph>PrologDeclList</emph><subscript>1</subscript></expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><expression><emph>PrologDecl</emph> = <emph>ModuleImport</emph></expression></clause></multiclause><multiclause><clause><expression><map><emph>PrologDecl</emph></map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a>
              <phrase diff="chg" at="E007">=</phrase> <emph>PrologDecl</emph><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><environment><emph>AnyURI</emph> ; <a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>PrologDecl</emph><subscript>1</subscript> <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><environment><emph>AnyURI</emph> ; <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></environment><expression><emph>PrologDeclList</emph> <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a>
              <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript> <a href="#jd_yields_context" class="judgment"><term>with</term></a> <emph>PrologDeclList</emph><subscript>1</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><emph>AnyURI</emph> ; <a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>PrologDecl</emph> ; <emph>PrologDeclList</emph>
              <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript> <a href="#jd_yields_context" class="judgment"><term>with</term></a>
              <emph>PrologDecl</emph><subscript>1</subscript> ; <emph>PrologDeclList</emph><subscript>1</subscript></expression></clause></postjudge></infer></infergr></smcontext><smtype><p>Static typing of a main module follows context processing and
    normalization.  Context processing and normalization of a main
    module applies the rules above to the prolog, then using the
    resulting static environment <a href="#xq_stat_env_def" class="env">statEnv</a>, the query body is
    normalized into a Core expression, and the static typing rules are
    applied to this Core expression.</p><infergr><infer><prejudge><multiclause><clause><environment><emph>AnyURI</emph> ; <a href="#xq_default_stat_env" class="env">statEnvDefault</a></environment><expression><emph>PrologDeclList</emph> <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a>
         <a href="#xq_stat_env_def" class="env">statEnv</a> <a href="#jd_yields_context" class="judgment"><term>with</term></a> <emph>PrologDeclList</emph><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><map><emph>QueryBody</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> <phrase diff="chg" at="E007">=</phrase> <emph>Expr</emph><subscript>2</subscript> </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause></multiclause></prejudge><postjudge><clause><expression><emph>PrologDeclList</emph> <emph>QueryBody</emph>
           <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause></postjudge></infer></infergr></smtype><smnotation><p id="jd_yields_dyn_context">Similarly, the judgment:</p><display>
      <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript></environment><expression><emph>PrologDeclList</emph> <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a>
        <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>2</subscript></expression></clause>
    </display><p>holds if under the dynamic environment <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript>, the
    sequence of prolog declarations <emph>PrologDeclList</emph> yields the
    dynamic environment <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>2</subscript>.</p><p>The judgment:</p><display>
      <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>PrologDecl</emph> <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript></expression></clause>
    </display><p>holds if under the dynamic environment <a href="#xq_dyn_env_def" class="env">dynEnv</a>, the single
    prolog declaration <emph>PrologDecl</emph> yields the new dynamic
    environment <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript>.</p></smnotation><smdyncontext><p>The rules for initializing the dynamic context are as follows.
    The first rule specifies that for an empty sequence of prolog
    declarations, the dynamic environment is left unchanged.</p><infergr><infer><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a></expression></clause></postjudge></infer></infergr><p>The second rule simply computes the dynamic environment by
    processing the prolog declarations in order.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>PrologDecl</emph> <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript></environment><expression><emph>PrologDeclList</emph> <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>2</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>PrologDecl</emph> ; <emph>PrologDeclList</emph> <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>2</subscript></expression></clause></postjudge></infer></infergr></smdyncontext><smeval><p>Dynamic evaluation of a main module applies the rules for
    dynamic-context processing to the prolog declarations, then using
    the resulting dynamic environment <a href="#xq_dyn_env_def" class="env">dynEnv</a>, the dynamic
    evaluation rules are applied to the normalized query body.</p><infergr><infer><prejudge><multiclause><clause diff="chg" at="E007"><environment>#MAIN ; <a href="#xq_default_stat_env" class="env">statEnvDefault</a></environment><expression>
                <emph>PrologDeclList</emph> <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a>
                <a href="#jd_yields_context" class="judgment"><term>with</term></a> <emph>PrologDeclList</emph><subscript>1</subscript>
              </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><map><emph>QueryBody</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> <phrase diff="chg" at="E007">=</phrase> <emph>Expr</emph><subscript>2</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_default_dyn_env" class="env">dynEnvDefault</a></environment><expression><phrase diff="chg" at="E007"><emph>PrologDeclList</emph><subscript>1</subscript></phrase> <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a>
             <a href="#xq_dyn_env_def" class="env">dynEnv</a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a></expression></clause></multiclause></prejudge><postjudge><multiclause><clause><expression><emph>PrologDeclList</emph> <emph>QueryBody</emph>
              <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a></expression></clause></multiclause></postjudge></infer></infergr></smeval><smnotation><p id="jd_module_statEnv">We define a new judgment that maps a
    module's target namespace (or a main module) to the corresponding
    module's static environment:</p><display>
     <clause><expression>(<emph>AnyURI</emph> | #MAIN) <a href="#jd_module_statEnv" class="judgment"><term>=&gt;</term><subscript>module_statEnv</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a></expression></clause>
    </display><p id="jd_module_dynEnv">We also define a new judgment that maps a
    module's target namespace (or a main module) to the corresponding
    module's dynamic environment:</p><display>
     <clause><expression>(<emph>AnyURI</emph> | #MAIN) <a href="#jd_module_dynEnv" class="judgment"><term>=&gt;</term><subscript>module_dynEnv</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a></expression></clause>
    </display><p>For a main module, those judgments are defined as follows.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_default_stat_env" class="env">statEnvDefault</a></environment><expression><emph>PrologDeclList</emph> <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a></expression></clause></multiclause></prejudge><postjudge><multiclause><clause><expression>#MAIN <a href="#jd_module_statEnv" class="judgment"><term>=&gt;</term><subscript>module_statEnv</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a></expression></clause></multiclause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_default_dyn_env" class="env">dynEnvDefault</a></environment><expression><emph>PrologDeclList</emph> <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a></expression></clause></multiclause></prejudge><postjudge><multiclause><clause><expression>#MAIN <a href="#jd_module_dynEnv" class="judgment"><term>=&gt;</term><subscript>module_dynEnv</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a></expression></clause></multiclause></postjudge></infer></infergr><p>For a library module, those judgments are defined in <specref ref="id-module-imports"/>.</p></smnotation><div2 id="sec_version-declaration"><head>Version Declaration</head><scrap headstyle="show"><head/><prodrecap id="VersionDecl" ref="VersionDecl" orig="xquery"/></scrap><smintro><p>A version declaration specifies the applicable XQuery syntax
      and semantics for a module.  An XQuery implementation must raise
      a static error when processing a query labeled with a version
      that the implementation does not support.  This document applies
      to XQuery 1.0 only and does not specify this static error
      formally. Verifying whether the proper version declaration is
      used is not formally specified.</p></smintro><!--
    <smcore>
      <p>The core grammar production for version declarations is:</p>

      <scrap><head></head>
    	<prodrecap id="core-VersionDecl" ref="VersionDecl" orig="core"/>
      </scrap>
    </smcore>

    <smnorm>
      <p>Version declaration are left unchanged through
      normalization.</p>

      <mapping>
       <xquery>
        <expression>
         <map>&gr_VersionDecl;</map>&jd_map_prolog;
        </expression>
       </xquery>
       <core>
        <expression>
          &gr_VersionDecl;
        </expression>
       </core>
      </mapping>
    </smnorm>
--></div2><div2 id="id-module-declaration"><head>Module Declaration</head><smintro><scrap headstyle="show"><head/><prodrecap id="ModuleDecl" ref="ModuleDecl" orig="xquery"/></scrap><p>We assume that the static-context processing and
      dynamic-context processing described in <specref ref="id-query-prolog"/> are applied to all library modules
      <emph>before</emph> the normalization, static context
      processing, and dynamic context processing of the main module.
      That is, at the time an "import module" declaration is
      processed, we assume that the static and dynamic context of the
      imported module is already available.  This assumption does not
      require or assume separate compilation of modules.  An
      implementation might process all or some imported modules
      statically (i.e., before the importing module is identified) or
      dynamically (i.e., when the importing module is identified and
      processed).</p></smintro><smcore><p>The core grammar production for module declarations is:</p><scrap headstyle="show"><head/><prodrecap id="core-ModuleDecl" ref="ModuleDecl" orig="core"/><prodrecap id="core-Separator" ref="Separator" orig="core"/></scrap></smcore><smnorm><p>Module declarations are left unchanged through
      normalization.</p><mapping><xquery><expression>
         <map><emph>ModuleDecl</emph></map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a>
        </expression></xquery><core><expression>
          <emph>ModuleDecl</emph>
        </expression></core></mapping></smnorm><smcontext><p>The effect of a module declaration is to apply the static
      context processing rules defined in <specref ref="id-query-prolog"/> to the module's prolog.  The resulting
      static context is then available to any importing module.</p><p>The module declaration extends the prolog with a namespace
      declaration that binds the module's prefix to its target
      namespace (a URI), then computes the static context for the
      complete module.</p><infergr><infer><prejudge><multiclause><clause><expression><emph>AnyURI</emph> <a href="#jd_is_target_namespace_of_modules" class="judgment"><term>is target namespace of modules</term></a> <emph>Module</emph><subscript>1</subscript> ... <emph>Module</emph><subscript>n</subscript>
      	        </expression></clause></multiclause><multiclause><clause><expression><emph>Module</emph><subscript>1</subscript> = module namespace <emph>NCName</emph><subscript>1</subscript> = <emph>URILiteral</emph>; <emph>PrologDeclList</emph><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><expression>...</expression></clause></multiclause><multiclause><clause><expression><emph>Module</emph><subscript>1</subscript> = module namespace <emph>NCName</emph><subscript>1</subscript> = <emph>URILiteral</emph>; <emph>PrologDeclList</emph><subscript>n</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>URILiteral</emph> <a href="#jd_has_atomic_value" class="judgment"><term>has atomic value</term></a> <emph>AnyURI</emph>
 	      </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_default_stat_env" class="env">statEnvDefault</a></environment><expression><emph>PrologDeclList</emph><subscript>1</subscript> ... <emph>PrologDeclList</emph><subscript>n</subscript> 
 	      <a href="#jd_yields_sigs" class="judgment"><term>=&gt;</term><subscript>sigs</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>0</subscript></expression></clause></multiclause><multiclause><clause><environment><emph>AnyURI</emph> ; <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>0</subscript></environment><expression>declare namespace <emph>NCName</emph> =
                    <emph>URILiteral</emph>; <emph>PrologDeclList</emph><subscript>1</subscript>
 	      <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> <a href="#jd_yields_context" class="judgment"><term>with</term></a> <emph>PrologDeclList</emph></expression></clause></multiclause><multiclause><clause><expression>...</expression></clause></multiclause><multiclause><clause><environment><emph>AnyURI</emph> ; <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>n-1</subscript></environment><expression>declare namespace <emph>NCName</emph> =
                    <emph>URILiteral</emph>; <emph>PrologDeclList</emph><subscript>n</subscript>
 	      <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>n</subscript> <a href="#jd_yields_context" class="judgment"><term>with</term></a> <emph>PrologDeclList</emph></expression></clause></multiclause></prejudge><postjudge><multiclause><clause><expression><emph>AnyURI</emph> <a href="#jd_module_statEnv" class="judgment"><term>=&gt;</term><subscript>module_statEnv</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>n</subscript></expression></clause></multiclause></postjudge></infer></infergr><p>Note that the rule above and the rules for static context
      processing of an "import module" declaration in <specref ref="id-module-imports"/> are mutually recursive.</p></smcontext><smdyncontext><p>The dynamic context processing of a module declaration is
      similar to that of static processing.  The module declaration
      extends the prolog with a namespace declaration that binds the
      module's prefix to its target namespace (a URI), then computes
      the dynamic context for the complete module.</p><infergr><infer><prejudge><multiclause><clause><expression><emph>AnyURI</emph>
      	        <a href="#jd_is_target_namespace_of_modules" class="judgment"><term>is target namespace of modules</term></a> <emph>Module</emph><subscript>1</subscript> ... <emph>Module</emph><subscript>n</subscript>
      	        </expression></clause></multiclause><multiclause><clause><expression><emph>Module</emph><subscript>1</subscript> = module namespace <emph>NCName</emph> = <emph>URILiteral</emph>; <emph>PrologDeclList</emph><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><expression>...</expression></clause></multiclause><multiclause><clause><expression><emph>Module</emph><subscript>n</subscript> = module namespace <emph>NCName</emph> = <emph>URILiteral</emph>; <emph>PrologDeclList</emph><subscript>n</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>URILiteral</emph> <a href="#jd_has_atomic_value" class="judgment"><term>has atomic value</term></a> <emph>AnyURI</emph>
 	      </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_default_dyn_env" class="env">dynEnvDefault</a></environment><expression>declare namespace <emph>NCName</emph> =
                    <emph>URILiteral</emph>; <emph>PrologDeclList</emph><subscript>1</subscript> <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><expression>...</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>n-1</subscript></environment><expression>declare namespace <emph>NCName</emph> =
                    <emph>URILiteral</emph>; <emph>PrologDeclList</emph><subscript>n</subscript> <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>n</subscript></expression></clause></multiclause></prejudge><postjudge><multiclause><clause><expression><emph>AnyURI</emph> <a href="#jd_module_dynEnv" class="judgment"><term>=&gt;</term><subscript>module_dynEnv</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>n</subscript></expression></clause></multiclause></postjudge></infer></infergr><p>Note that the rule above and the rules for dynamic context
      processing of an "import module" declaration in <specref ref="id-module-imports"/> are mutually recursive.</p></smdyncontext></div2><div2 id="sec_boundary-space-decls"><head>Boundary-space Declaration</head><scrap headstyle="show"><head/><prodrecap id="BoundarySpaceDecl" ref="BoundarySpaceDecl" orig="xquery"/></scrap><p>The semantics of a boundary-space declaration is not specified
    formally.</p></div2><div2 id="sec_default-collation-declaration"><head>Default Collation Declaration</head><scrap headstyle="show"><head/><prodrecap id="DefaultCollationDecl" ref="DefaultCollationDecl" orig="xquery"/></scrap><smcore><p>The core grammar production for default collation declarations is:</p><scrap headstyle="show"><head/><prodrecap id="core-DefaultCollationDecl" ref="DefaultCollationDecl" orig="core"/></scrap></smcore><smnorm><p>Default collation declarations are left unchanged through
      normalization.</p><mapping><xquery><expression>
         <map><emph>DefaultCollationDecl</emph></map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a>
        </expression></xquery><core><expression>
          <emph>DefaultCollationDecl</emph>
        </expression></core></mapping></smnorm><smcontext><p>The default collation declaration updates the collations
      environment component within the static environment.  The
      collations environment component is used by several functions in
      <bibref ref="xpath-functions-30"/>, but is not used in the Formal Semantics.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>URILiteral</emph> <a href="#jd_has_atomic_value" class="judgment"><term>has atomic value</term></a> <emph>AnyURI</emph>
 	    </expression></clause></multiclause><multiclause><clause><expression>
                    <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_collations_env" class="env">collations</a>(<emph>AnyURI</emph>) = <emph>Collation</emph>
                </expression></clause></multiclause><multiclause><clause><expression>
                  <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> =
                    <update><environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_collation_env" class="env">defaultCollation</a></environment><expression><emph>Collation</emph></expression></update>
                </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>declare default collation <emph>URILiteral</emph> <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression></clause></multiclause></postjudge></infer></infergr></smcontext><smdyncontext><p>The default collation declaration does not affect the dynamic
      context.</p><infergr><infer><prejudge/><postjudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>declare default collation <emph>URILiteral</emph> <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a></expression></clause></multiclause></postjudge></infer></infergr></smdyncontext></div2><div2 id="sec_base-uri-decl"><head>Base URI Declaration</head><scrap headstyle="show"><head/><prodrecap id="BaseURIDecl" ref="BaseURIDecl" orig="xquery"/></scrap><smcore><p>The core grammar production for base uri declarations is:</p><scrap headstyle="show"><head/><prodrecap id="core-BaseURIDecl" ref="BaseURIDecl" orig="core"/></scrap></smcore><smnorm><p>Base URI declarations are left unchanged through
    normalization.</p><mapping><xquery><expression>
       <map><emph>BaseURIDecl</emph></map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a>
      </expression></xquery><core><expression>
        <emph>BaseURIDecl</emph>
      </expression></core></mapping></smnorm><smcontext><p>A base URI declaration specifies the base URI property of the
    static context, which is used when resolving relative URIs within
    a module.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>URILiteral</emph> <a href="#jd_has_atomic_value" class="judgment"><term>has atomic value</term></a> <emph>AnyURI</emph>
 	    </expression></clause></multiclause><multiclause><clause><expression>
                    <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> =
                    <update><environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_base_uri_env" class="env">baseURI</a></environment><expression><emph>AnyURI</emph></expression></update>
</expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
declare base-uri <emph>URILiteral</emph> <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript>
</expression></clause></multiclause></postjudge></infer></infergr></smcontext><smdyncontext><p>The base URI declaration does not affect the dynamic
context. </p><infergr><infer><prejudge/><postjudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>declare base-uri <emph>URILiteral</emph>  <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a></expression></clause></multiclause></postjudge></infer></infergr></smdyncontext></div2><div2 id="sec_validation_decl"><head>Construction Declaration</head><scrap headstyle="show"><head/><prodrecap id="ConstructionDecl" ref="ConstructionDecl" orig="xquery"/></scrap><smcore><p>The core grammar production for construction declarations is:</p><scrap headstyle="show"><head/><prodrecap id="core-ConstructionDecl" ref="ConstructionDecl" orig="core"/></scrap></smcore><smnotation><p>For convenience, we introduce the following auxiliary
      grammar production.</p><scrap headstyle="show"><head>Constr Mode</head><prodrecap id="ConstructionMode" ref="ConstructionMode" orig="formal"/></scrap></smnotation><smnorm><p>Construction declarations are left unchanged through
      normalization.</p><mapping><xquery><expression>
         <map><emph>ConstructionDecl</emph></map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a>
        </expression></xquery><core><expression>
          <emph>ConstructionDecl</emph>
        </expression></core></mapping></smnorm><smcontext><p>The construction declaration modifies the construction mode
      in the static context.</p><infergr><infer><prejudge><clause><expression>
                  <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> =
                    <update><environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_construction_mode_env" class="env">constructionMode</a></environment><expression>
                      <emph>ConstructionMode</emph></expression></update>
                </expression></clause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>declare construction <emph>ConstructionMode</emph>
                <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression></clause></multiclause></postjudge></infer></infergr></smcontext><smdyncontext><p>The construction declaration does not have any effect on the dynamic
context.</p><infergr><infer><prejudge/><postjudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>declare construction <emph>ConstructionMode</emph> <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a></expression></clause></multiclause></postjudge></infer></infergr></smdyncontext></div2><div2 id="id-default-ordering-decl"><head>Ordering Mode Declaration</head><scrap headstyle="show"><head/><prodrecap id="OrderingModeDecl" ref="OrderingModeDecl" orig="xquery"/></scrap><smcore><p>The core grammar production for ordering mode declarations is:</p><scrap headstyle="show"><head/><prodrecap id="core-OrderingModeDecl" ref="OrderingModeDecl" orig="core"/></scrap></smcore><smnorm><p>Ordering mode declarations are left unchanged through
      normalization.</p><mapping><xquery><expression>
         <map><emph>OrderingModeDecl</emph></map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a>
        </expression></xquery><core><expression>
          <emph>OrderingModeDecl</emph>
        </expression></core></mapping></smnorm><smcontext><p>The ordering mode declaration does not have any effect on the
      static context.</p><infergr><infer><prejudge/><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>OrderingModeDecl</emph> <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a></expression></clause></multiclause></postjudge></infer></infergr></smcontext><smdyncontext><p>The ordering mode declaration does not have any effect on the
      dynamic context.</p><infergr><infer><prejudge/><postjudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>OrderingModeDecl</emph> <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a></expression></clause></multiclause></postjudge></infer></infergr></smdyncontext></div2><div2 id="id-empty-order-decl"><head>Empty Order Declaration</head><scrap headstyle="show"><head/><prodrecap id="EmptyOrderDecl" ref="EmptyOrderDecl" orig="xquery"/></scrap><smcore><p>The core grammar production for empty order declarations is:</p><scrap headstyle="show"><head/><prodrecap id="core-EmptyOrderDecl" ref="EmptyOrderDecl" orig="core"/></scrap></smcore><smnorm><p>Empty order declarations are left unchanged through
      normalization.</p><mapping><xquery><expression>
         <map><emph>EmptyOrderDecl</emph></map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a>
        </expression></xquery><core><expression>
          <emph>EmptyOrderDecl</emph>
        </expression></core></mapping></smnorm><smcontext><p>The empty order declaration does not have any effect on the
      static context.</p><infergr><infer><prejudge/><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>EmptyOrderDecl</emph> <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a></expression></clause></multiclause></postjudge></infer></infergr></smcontext><smdyncontext><p>The empty order declaration does not have any effect on the
      dynamic context.</p><infergr><infer><prejudge/><postjudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>EmptyOrderDecl</emph> <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a></expression></clause></multiclause></postjudge></infer></infergr></smdyncontext></div2><div2 id="id-copy-namespaces-decl"><head>Copy-Namespaces Declaration</head><scrap headstyle="show"><head/><prodrecap id="CopyNamespacesDecl" ref="CopyNamespacesDecl" orig="xquery"/><prodrecap id="PreserveMode" ref="PreserveMode" orig="xquery"/><prodrecap id="InheritMode" ref="InheritMode" orig="xquery"/></scrap><smcore><p>The core grammar productions for copy-namespaces declarations
      are:</p><scrap headstyle="show"><head/><prodrecap id="core-CopyNamespacesDecl" ref="CopyNamespacesDecl" orig="core"/><prodrecap id="core-PreserveMode" ref="PreserveMode" orig="core"/><prodrecap id="core-InheritMode" ref="InheritMode" orig="core"/></scrap></smcore><smnorm><p>Copy-namespace declarations are left unchanged through
      normalization.</p><mapping><xquery><expression>
         <map><emph>CopyNamespacesDecl</emph></map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a>
        </expression></xquery><core><expression>
          <emph>CopyNamespacesDecl</emph>
        </expression></core></mapping></smnorm><smcontext><p>The copy-namespace declaration does not have any effect on the
      static context.</p><infergr><infer><prejudge/><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>CopyNamespacesDecl</emph> <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a></expression></clause></multiclause></postjudge></infer></infergr></smcontext><smdyncontext><p>The copy-namespace declaration does not have any effect on
      the dynamic context.</p><infergr><infer><prejudge/><postjudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>CopyNamespacesDecl</emph> <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a></expression></clause></multiclause></postjudge></infer></infergr></smdyncontext></div2><div2 id="sec_schema_imports"><head>Schema Import</head><scrap headstyle="show"><head>Schema Imports</head><prodrecap id="SchemaImport" ref="SchemaImport" orig="xquery"/><prodrecap id="SchemaPrefix" ref="SchemaPrefix" orig="xquery"/></scrap><p>The semantics of Schema Import is described in terms of the
    [XPath/XQuery] type system. The process of converting an XML Schema
    into a sequence of type declarations is described in Section
    <specref ref="sec_importing_schema"/>.  This section describes how
    the resulting sequence of type declarations is added into the
    static context when the Prolog is processed.</p><smcore><p>The Core grammar productions for schema imports are:</p><scrap headstyle="show"><head>Schema Imports</head><prodrecap id="core-SchemaImport" ref="SchemaImport" orig="core"/><prodrecap id="core-SchemaPrefix" ref="SchemaPrefix" orig="core"/></scrap></smcore><smnorm><p>Schema imports are left unchanged through normalization.</p><mapping><xquery><expression>
         <map><emph>SchemaImport</emph></map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a>
        </expression></xquery><core><expression>
          <emph>SchemaImport</emph>
        </expression></core></mapping></smnorm><smnotation><p>For convenience, we introduce the following auxiliary
      grammar productions.</p><scrap headstyle="show"><head>Location Hints</head><prodrecap id="LocationHints" ref="LocationHints" orig="formal"/><prodrecap id="OptLocationHints" ref="OptLocationHints" orig="formal"/></scrap></smnotation><smnotation><p id="jd_yields_type_context">The following auxiliary judgments
      are used when processing schema imports.</p><p>The judgment:</p><display>
        <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></environment><expression><emph>Definitions</emph> <a href="#jd_yields_type_context" class="judgment"><term>=&gt;</term><subscript>type</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></expression></clause>
      </display><p>holds if under the static environment <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript>, the
      sequence of type definitions <emph>Definitions</emph> yields the new
      static environment <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript>.</p><p>The judgment:</p><display>
        <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></environment><expression><a href="#sec_top_level_definitions"><emph>Definition</emph></a> <a href="#jd_yields_type_context" class="judgment"><term>=&gt;</term><subscript>type</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></expression></clause>
      </display><p>holds if under the static environment <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript>, the
      single definition <a href="#sec_top_level_definitions"><emph>Definition</emph></a> yields the new static
      environment <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript>.</p></smnotation><smcontext><p>A schema imported into a query is first mapped into the
      [XPath/XQuery] type system, which yields a sequence of XQuery type
      definitions.  The rules for mapping the imported schema begin in
      <specref ref="sec_schema_as_a_whole"/>.  Each type definition in
      an imported schema is then added to the static environment.</p><infergr><infer><prejudge><multiclause><clause><expression><emph>Definitions</emph> = <map>schema
                <emph>URILiteral</emph> <emph>OptLocationHints</emph></map><a href="#jd_map_schema" class="judgment"><subscript>Schema</subscript></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>Definitions</emph> <a href="#jd_yields_type_context" class="judgment"><term>=&gt;</term><subscript>type</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>import schema <emph>URILiteral</emph> <emph>OptLocationHints</emph>
                <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression></clause></multiclause></postjudge></infer></infergr><p>The schema import declaration may also assign an element/type
      namespace prefix to the URI of the imported schema, or assign
      the default element namespace to the URI of the imported
      schema.</p><infergr><infer><prejudge><multiclause><clause><expression><emph>Definitions</emph> = <map>schema
                <emph>URILiteral</emph> <emph>OptLocationHints</emph></map><a href="#jd_map_schema" class="judgment"><subscript>Schema</subscript></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>Definitions</emph> <a href="#jd_yields_type_context" class="judgment"><term>=&gt;</term><subscript>type</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>URILiteral</emph> <a href="#jd_has_atomic_value" class="judgment"><term>has atomic value</term></a> <emph>AnyURI</emph>
 	    </expression></clause></multiclause><multiclause><clause><expression>
                    <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript> =
                    <update><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript>.<a href="#xq_ns_env" class="env">namespace</a></environment><expression><emph>NCName</emph> 
                      =&gt; (passive, <emph>AnyURI</emph>)</expression></update>
                </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>import schema namespace <emph>NCName</emph> =
                <emph>URILiteral</emph> <emph>OptLocationHints</emph>
                <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></expression></clause></multiclause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><expression><emph>Definitions</emph> = <map>schema
                <emph>URILiteral</emph> <emph>OptLocationHints</emph></map><a href="#jd_map_schema" class="judgment"><subscript>Schema</subscript></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>Definitions</emph> <a href="#jd_yields_type_context" class="judgment"><term>=&gt;</term><subscript>type</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>URILiteral</emph> <a href="#jd_has_atomic_value" class="judgment"><term>has atomic value</term></a> <emph>AnyURI</emph>
 	    </expression></clause></multiclause><multiclause><clause><expression>
                    <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript> =
                    <update><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript>.<a href="#xq_default_elem_ns_env" class="env">default_elem_namespace</a></environment><expression> <emph>AnyURI</emph></expression></update>
                </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>import schema default element namespace
                <emph>URILiteral</emph> <emph>OptLocationHints</emph>
                <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></expression></clause></multiclause></postjudge></infer></infergr><p>An empty sequence of type definitions yields the input
      environment.</p><infergr><infer><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_yields_type_context" class="judgment"><term>=&gt;</term><subscript>type</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a></expression></clause></multiclause></postjudge></infer></infergr><p>Each type definition is added into the static
      environment.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>Definitions</emph> <a href="#jd_yields_type_context" class="judgment"><term>=&gt;</term><subscript>type</subscript></a>
                <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></environment><expression><a href="#sec_top_level_definitions"><emph>Definition</emph></a><subscript>1</subscript> <a href="#jd_yields_type_context" class="judgment"><term>=&gt;</term><subscript>type</subscript></a>
        	<a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#sec_top_level_definitions"><emph>Definition</emph></a><subscript>1</subscript> <phrase diff="add" at="E042">;</phrase> <emph>Definitions</emph>
                <a href="#jd_yields_type_context" class="judgment"><term>=&gt;</term><subscript>type</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></expression></clause></multiclause></postjudge></infer></infergr><p>Each type, element, or attribute declaration is added
      respectively to the type, element and attribute declarations
      components of the static environment.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           </expression></clause></multiclause><multiclause><clause><expression>
                <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> =
                    <update><environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a></environment><expression><a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> =&gt; define type
                      <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> <a href="#doc-fs-TypeDerivation"><emph>TypeDerivation</emph></a> </expression></update>
                </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>define type <a href="#doc-fs-TypeName"><emph>TypeName</emph></a>
                <a href="#doc-fs-TypeDerivation"><emph>TypeDerivation</emph></a> <a href="#jd_yields_type_context" class="judgment"><term>=&gt;</term><subscript>type</subscript></a>
                <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression></clause></multiclause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           </expression></clause></multiclause><multiclause><clause><expression>
                <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> =
                    <update><environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_elem_decl" class="env">elemDecl</a></environment><expression><a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> =&gt; define
                      element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#doc-fs-OptSubstitution"><emph>OptSubstitution</emph></a>
                      <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a>  <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression></update>
                </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>define element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a>
                <a href="#doc-fs-OptSubstitution"><emph>OptSubstitution</emph></a> <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a>  <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a>
                <a href="#jd_yields_type_context" class="judgment"><term>=&gt;</term><subscript>type</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression></clause></multiclause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a> <a href="#jd_attr_qname_expands_to" class="judgment"><term>of attr expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           </expression></clause></multiclause><multiclause><clause><expression>
                <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> =
                    <update><environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_attr_decl" class="env">attrDecl</a></environment><expression><a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> =&gt; define
                      attribute <a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a>
                      <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression></update>
                </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>define attribute <a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a>
                <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a> <a href="#jd_yields_type_context" class="judgment"><term>=&gt;</term><subscript>type</subscript></a>
                <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression></clause></multiclause></postjudge></infer></infergr><p>Note that it is a static error to import two schemas that
      both define the same name in the same symbol space and in the
      same scope. That is multiple top-level definitions of the same
      type, element, or attribute name raises a static error.  For
      instance, a query may not import two schemas that include
      top-level element declarations for two elements with the same
      expanded name.</p></smcontext><smdyncontext><p>The schema import declarations do not affect the dynamic
      context.</p><infergr><infer><prejudge/><postjudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>SchemaImport</emph> <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a></expression></clause></multiclause></postjudge></infer></infergr></smdyncontext></div2><div2 id="id-module-imports"><head>Module Import</head><scrap headstyle="show"><head/><prodrecap id="ModuleImport" ref="ModuleImport" orig="xquery"/></scrap><smintro><p>The effect of an "import module" declaration is to extend the
      importing module's dynamic (and static) context with the global
      variables (and their types) and the functions (and their
      signatures) of the imported module.  Module import is not
      transitive, only the global variables and functions declared
      explicitly in the imported module are available in the importing
      module.  Also, module import does not import schemas, therefore
      the importing module must explicitly import any schemas on which
      the imported global variables or functions depend.</p></smintro><smcore><p>The core grammar production for module imports is:</p><scrap headstyle="show"><head>Module Import</head><prodrecap id="core-ModuleImport" ref="ModuleImport" orig="core"/></scrap></smcore><smnorm><p>Module imports are left unchanged through normalization.</p><mapping><xquery><expression>
         <map><emph>ModuleImport</emph></map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a>
        </expression></xquery><core><expression>
          <emph>ModuleImport</emph>
        </expression></core></mapping></smnorm><smnotation><p>The rules below depend on the following auxiliary functions
      which are used to import the proper fragment of the static
      context.</p><p id="fs_local_variables">The function
      <a href="#fs_local_variables"><emph>fs:</emph><code>local-variables</code></a>(<a href="#xq_stat_env_def" class="env">statEnv</a>, <emph>AnyURI</emph>) returns all the
      (<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>, <a href="#doc-fs-Type"><emph>Type</emph></a>) pairs in <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a> such that the URI
      part of the variable's expanded-QName equals the given URI, that
      is, the variables that are declared locally in the module with
      the given namespace URI.</p><p id="fs_local_functions">
      The function <a href="#fs_local_functions"><emph>fs:</emph><code>local-functions</code></a>(<a href="#xq_stat_env_def" class="env">statEnv</a>, <emph>AnyURI</emph>)
      returns all the
      <phrase diff="chg" at="E006">(<emph>FunctionKey</emph>, <emph>FunctionSig</emph>) pairs</phrase>
      in <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_functy_env" class="env">funcType</a> such that
      the URI part of the function's expanded-QName equals the given
      URI, that is, the function signatures that are declared locally
      in the module with the given namespace URI.</p></smnotation><smnotation><p>The following auxiliary judgments is used to extend a given
      static environment with the static environment from an imported
      module.</p><p id="jd_extended_with_static_environment">The judgment</p><display>
        <clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript>
        <a href="#jd_extended_with_static_environment" class="judgment"><term>extended with static environment</term></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript>
        <a href="#jd_extended_with_static_environment" class="judgment"><term>yields</term></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>3</subscript>
        <a href="#jd_extended_with_static_environment" class="judgment"><term>for uri</term></a> <emph>AnyURI</emph><subscript>1</subscript></expression></clause>
      </display><p>holds if extending the environment <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> with the
      environment <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript> yields the environment <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>3</subscript>
      under the given namespace uri <emph>AnyURI</emph>.</p><p>This judgment is defined as follows.</p><infergr><infer><prejudge><multiclause><clause><expression><a href="#fs_local_variables"><emph>fs:</emph><code>local-variables</code></a>(<a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript>, <emph>AnyURI</emph>) =
        (<emph>Variable</emph><subscript>1</subscript>,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) ... (<emph>Variable</emph><subscript>m</subscript>,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>m</subscript>)</expression></clause></multiclause><multiclause><clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>3</subscript> =
        <update><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript>.<a href="#xq_type_env" class="env">varType</a></environment><expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> ... ;
        <emph>Variable</emph><subscript>m</subscript> =&gt; <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>m</subscript></expression></update></expression></clause></multiclause><multiclause><clause><expression>
          <a href="#fs_local_functions"><emph>fs:</emph><code>local-functions</code></a>(<a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript>, <emph>AnyURI</emph>) =
          (<phrase diff="chg" at="E006"><emph>FunctionKey</emph><subscript>1</subscript></phrase>,<emph>FunctionSig</emph><subscript>1</subscript>) ...
          (<phrase diff="chg" at="E006"><emph>FunctionKey</emph><subscript>n</subscript></phrase>,<emph>FunctionSig</emph><subscript>n</subscript>)
        </expression></clause></multiclause><multiclause><clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>4</subscript> =
        <update><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>3</subscript>.<a href="#xq_functy_env" class="env">funcType</a></environment><expression>
          <phrase diff="chg" at="E006"><emph>FunctionKey</emph><subscript>1</subscript></phrase> =&gt; <emph>FunctionSig</emph><subscript>1</subscript>; ... ;
          <phrase diff="chg" at="E006"><emph>FunctionKey</emph><subscript>n</subscript></phrase> =&gt; <emph>FunctionSig</emph><subscript>n</subscript>
        </expression></update></expression></clause></multiclause></prejudge><postjudge><multiclause><clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript>
          <a href="#jd_extended_with_static_environment" class="judgment"><term>extended with static environment</term></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript>
          <a href="#jd_extended_with_static_environment" class="judgment"><term>yields</term></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>4</subscript>
          <a href="#jd_extended_with_static_environment" class="judgment"><term>for uri</term></a> <emph>AnyURI</emph><subscript>1</subscript></expression></clause></multiclause></postjudge></infer></infergr></smnotation><smnotation><p>The rules below depend on the following auxiliary
        judgments.</p><p id="jd_import_variables">
        The following rules add each variable explicitly declared in
        the imported module to the importing module's dynamic variable
        environment.</p><infergr><infer><prejudge/><postjudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript> ; <emph>AnyURI</emph></environment><expression><a href="#jd_import_variables" class="judgment"><term>=&gt;</term><subscript>import_variables</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript> </expression></clause></multiclause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><expression><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>2</subscript> = <update><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript>.<a href="#xq_val_env" class="env">varValue</a></environment><expression><a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript>
          =&gt;
          <code>#IMPORTED</code>(<emph>AnyURI</emph>)</expression></update></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>2</subscript> ; <emph>AnyURI</emph></environment><expression>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>2</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>), ···, (<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>n</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>)
        <a href="#jd_import_variables" class="judgment"><term>=&gt;</term><subscript>import_variables</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>3</subscript> </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript> ; <emph>AnyURI</emph></environment><expression>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>), ···, (<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>n</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>)
        <a href="#jd_import_variables" class="judgment"><term>=&gt;</term><subscript>import_variables</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>3</subscript> </expression></clause></multiclause></postjudge></infer></infergr><p id="jd_import_functions">The following rules add each
        function explicitly declared in the imported module to the
        importing module's dynamic function environment.</p><infergr><infer><prejudge/><postjudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript> ; <emph>AnyURI</emph></environment><expression><a href="#jd_import_functions" class="judgment"><term>=&gt;</term><subscript>import_functions</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript> </expression></clause></multiclause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><expression><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>2</subscript> =
          <update><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript>.<a href="#xq_func_env" class="env">funcDefn</a></environment><expression><phrase diff="chg" at="E006"><emph>FunctionKey</emph><subscript>1</subscript></phrase> =&gt;
          <code>#IMPORTED</code>(<emph>AnyURI</emph>)</expression></update></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>2</subscript> ; <emph>AnyURI</emph></environment><expression>
            <phrase diff="chg" at="E006">
            (<emph>FunctionKey</emph><subscript>2</subscript>,<emph>FunctionSig</emph><subscript>2</subscript>) ...
            (<emph>FunctionKey</emph><subscript>n</subscript>,<emph>FunctionSig</emph><subscript>n</subscript>)
            </phrase>
        <a href="#jd_import_functions" class="judgment"><term>=&gt;</term><subscript>import_functions</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>3</subscript> </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript> ; <emph>AnyURI</emph></environment><expression>
          <phrase diff="chg" at="E006">
          (<emph>FunctionKey</emph><subscript>1</subscript>,<emph>FunctionSig</emph><subscript>1</subscript>) ...
          (<emph>FunctionKey</emph><subscript>n</subscript>,<emph>FunctionSig</emph><subscript>n</subscript>)
          </phrase>
        <a href="#jd_import_functions" class="judgment"><term>=&gt;</term><subscript>import_functions</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>3</subscript> </expression></clause></multiclause></postjudge></infer></infergr></smnotation><smnotation><p>The following auxiliary judgments is used to extend a given
      dynamic environment with the dynamic environment from an
      imported module.</p><p id="jd_extended_with_dynamic_environment">The judgment</p><display>
          <clause><expression><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript>
          <a href="#jd_extended_with_dynamic_environment" class="judgment"><term>extended with dynamic environment</term></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>2</subscript>
          <a href="#jd_extended_with_dynamic_environment" class="judgment"><term>yields</term></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>3</subscript>
          <a href="#jd_extended_with_dynamic_environment" class="judgment"><term>for uri</term></a> <emph>AnyURI</emph></expression></clause>
        </display><p>holds if extending the dynamic environment <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript> with
      the dynamic environment <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>2</subscript> yields the dynamic
      environment <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>3</subscript> under the given namespace uri
      <emph>AnyURI</emph>.</p><p>This judgment is defined as follows.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript> ; <emph>AnyURI</emph></environment><expression><a href="#fs_local_variables"><emph>fs:</emph><code>local-variables</code></a>(<a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript>,
    	 <emph>AnyURI</emph>) <a href="#jd_import_variables" class="judgment"><term>=&gt;</term><subscript>import_variables</subscript></a>
    	 <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>3</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript> ; <emph>AnyURI</emph></environment><expression><a href="#fs_local_variables"><emph>fs:</emph><code>local-variables</code></a>(<a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript>,
    	 <emph>AnyURI</emph>) <a href="#jd_import_variables" class="judgment"><term>=&gt;</term><subscript>import_variables</subscript></a>
    	 <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>3</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>3</subscript> ; <emph>AnyURI</emph></environment><expression><a href="#fs_local_functions"><emph>fs:</emph><code>local-functions</code></a>(<a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript>,
    	 <emph>AnyURI</emph>) <a href="#jd_import_functions" class="judgment"><term>=&gt;</term><subscript>import_functions</subscript></a>
    	 <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>4</subscript></expression></clause></multiclause></prejudge><postjudge><multiclause><clause><expression><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript>
          <a href="#jd_extended_with_dynamic_environment" class="judgment"><term>extended with dynamic environment</term></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>2</subscript>
          <a href="#jd_extended_with_dynamic_environment" class="judgment"><term>yields</term></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>4</subscript>
          <a href="#jd_extended_with_dynamic_environment" class="judgment"><term>for uri</term></a> <emph>AnyURI</emph></expression></clause></multiclause></postjudge></infer></infergr></smnotation><smcontext><p>The first set of premises below "look up" the static contexts
      of all the imported modules, as defined in <specref ref="id-module-declaration"/>. The second set of premises extend
      the input static context with the global variables and function
      signatures declared in the imported static contexts.</p><infergr><infer><prejudge><multiclause><clause><expression><a href="#jd_not" class="judgment"><term>not</term></a>(<emph>AnyURI</emph><subscript>1</subscript> = <emph>AnyURI</emph>)</expression></clause></multiclause><multiclause><clause><expression><emph>AnyURI</emph><subscript>1</subscript> <a href="#jd_module_statEnv" class="judgment"><term>=&gt;</term><subscript>module_statEnv</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a>
          <a href="#jd_extended_with_static_environment" class="judgment"><term>extended with static environment</term></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript>
          <a href="#jd_extended_with_static_environment" class="judgment"><term>yields</term></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript>
          <a href="#jd_extended_with_static_environment" class="judgment"><term>for uri</term></a> <emph>AnyURI</emph><subscript>1</subscript></expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><emph>AnyURI</emph> ; <a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>import module <emph>AnyURI</emph><subscript>1</subscript> <emph>LocationHints</emph>? <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></expression></clause></multiclause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><expression><emph>AnyURI</emph><subscript>1</subscript> = <emph>AnyURI</emph></expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><emph>AnyURI</emph> ; <a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>import module <emph>AnyURI</emph><subscript>1</subscript> <emph>LocationHints</emph>? <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression></clause></multiclause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><expression><a href="#jd_not" class="judgment"><term>not</term></a>(<emph>AnyURI</emph><subscript>1</subscript> = <emph>AnyURI</emph>)</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>URILiteral</emph><subscript>1</subscript> <a href="#jd_has_atomic_value" class="judgment"><term>has atomic value</term></a> <emph>AnyURI</emph><subscript>1</subscript>
 	    </expression></clause></multiclause><multiclause><clause><expression><emph>AnyURI</emph><subscript>1</subscript> <a href="#jd_module_statEnv" class="judgment"><term>=&gt;</term><subscript>module_statEnv</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a>
          <a href="#jd_extended_with_static_environment" class="judgment"><term>extended with static environment</term></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript>
          <a href="#jd_extended_with_static_environment" class="judgment"><term>yields</term></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript>
          <a href="#jd_extended_with_static_environment" class="judgment"><term>for uri</term></a> <emph>AnyURI</emph><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><expression>
            <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>3</subscript> =
            <update><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript>.<a href="#xq_ns_env" class="env">namespace</a></environment><expression><emph>NCName</emph> 
              =&gt; (passive, <emph>AnyURI</emph>)</expression></update>
          </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>import module namespace <emph>NCName</emph> = <emph>URILiteral</emph><subscript>1</subscript> <emph>LocationHints</emph>? <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>3</subscript></expression></clause></multiclause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><expression><emph>AnyURI</emph><subscript>1</subscript> = <emph>AnyURI</emph></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>URILiteral</emph><subscript>1</subscript> <a href="#jd_has_atomic_value" class="judgment"><term>has atomic value</term></a> <emph>AnyURI</emph><subscript>1</subscript>
 	    </expression></clause></multiclause><multiclause><clause><expression>
            <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript> =
            <update><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript>.<a href="#xq_ns_env" class="env">namespace</a></environment><expression><emph>NCName</emph> 
              =&gt; (passive, <emph>AnyURI</emph>)</expression></update>
          </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>import module namespace <emph>NCName</emph> = <emph>URILiteral</emph><subscript>1</subscript> <emph>LocationHints</emph>? <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></expression></clause></multiclause></postjudge></infer></infergr><p>Note that the rules above and the rules for processing a
      library module in <specref ref="id-module-declaration"/> above
      are mutually recursive. It is possible to define the semantics
      in that way, since XQuery forbids the use of recursive
      modules.</p></smcontext><smdyncontext><p>During dynamic context processing, each variable and function
      name is mapped to the special value
      <code>#IMPORTED</code>(<emph>AnyURI</emph>) to indicate that the variable
      or function is defined in the imported module with the given
      URI.</p><p>The first set of premises below "look up" the dynamic
      contexts of all the imported modules, as defined in <specref ref="id-module-declaration"/>. The second set of premises extend
      the input dynamic context with the global variables and
      functions declared in the imported dynamic contexts.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>URILiteral</emph> <a href="#jd_has_atomic_value" class="judgment"><term>has atomic value</term></a> <emph>AnyURI</emph>
 	    </expression></clause></multiclause><multiclause><clause><expression><emph>AnyURI</emph> <a href="#jd_module_dynEnv" class="judgment"><term>=&gt;</term><subscript>module_dynEnv</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><expression>...</expression></clause></multiclause><multiclause><clause><expression><emph>AnyURI</emph> <a href="#jd_module_dynEnv" class="judgment"><term>=&gt;</term><subscript>module_dynEnv</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>n</subscript></expression></clause></multiclause><multiclause><clause><expression><a href="#xq_dyn_env_def" class="env">dynEnv</a>
          <a href="#jd_extended_with_dynamic_environment" class="judgment"><term>extended with dynamic environment</term></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript>
          <a href="#jd_extended_with_dynamic_environment" class="judgment"><term>yields</term></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript>'
          <a href="#jd_extended_with_dynamic_environment" class="judgment"><term>for uri</term></a> <emph>AnyURI</emph></expression></clause></multiclause><multiclause><clause><expression>...</expression></clause></multiclause><multiclause><clause><expression><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>n-1</subscript>
          <a href="#jd_extended_with_dynamic_environment" class="judgment"><term>extended with dynamic environment</term></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>n</subscript>
          <a href="#jd_extended_with_dynamic_environment" class="judgment"><term>yields</term></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>n</subscript>'
          <a href="#jd_extended_with_dynamic_environment" class="judgment"><term>for uri</term></a> <emph>AnyURI</emph></expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript></environment><expression>import module (namespace <emph>NCName</emph> =)? <emph>URILiteral</emph> <emph>LocationHints</emph>?
         <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a>  <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>n</subscript>'</expression></clause></multiclause></postjudge></infer></infergr><p>Note that the rule above and the rules for processing a library
  module in <specref ref="id-module-declaration"/> above are mutually
  recursive. It is possible to define the semantics in that way, since
  XQuery forbids the use of recursive modules.</p></smdyncontext></div2><div2 id="sec_namespace_decls"><head>Namespace Declaration</head><scrap headstyle="show"><head/><prodrecap id="NamespaceDecl" ref="NamespaceDecl" orig="xquery"/></scrap><smcore><p>The core grammar production for namespace declarations is:</p><scrap headstyle="show"><head/><prodrecap id="core-NamespaceDecl" ref="NamespaceDecl" orig="core"/></scrap></smcore><smnorm><p>Namespace declarations are left unchanged through
      normalization.</p><mapping><xquery><expression>
         <map><emph>NamespaceDecl</emph></map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a>
        </expression></xquery><core><expression>
          <emph>NamespaceDecl</emph>
        </expression></core></mapping></smnorm><smcontext><p>A namespace declaration adds a new (prefix,uri) binding in
      the namespace component of the static environment.  All
      namespace declarations in the prolog are <term>passive</term>
      declarations.  Namespace declaration attributes of element
      constructors are <term>active</term> declarations.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>URILiteral</emph> <a href="#jd_has_atomic_value" class="judgment"><term>has atomic value</term></a> <emph>AnyURI</emph>
 	    </expression></clause></multiclause><multiclause><clause><expression>
                   <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> =
                   <update><environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a></environment><expression><emph>NCName</emph> =&gt; (passive, <emph>AnyURI</emph>)</expression></update>
                </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>declare namespace <emph>NCName</emph> = <emph>URILiteral</emph> <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression></clause></multiclause></postjudge></infer></infergr><p>In case the <emph>URILiteral</emph> part of a namespace declaration
      is a zero-length string, the namespace prefix is marked as
      #UNDECLARED in the static context.</p><infergr><infer><prejudge><multiclause><clause><expression>
                   <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> =
                   <update><environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a></environment><expression><emph>NCName</emph> =&gt; (passive, #UNDECLARED)</expression></update>
                </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>declare namespace <emph>NCName</emph> = "" <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression></clause></multiclause></postjudge></infer></infergr></smcontext><smdyncontext><p>The namespace declaration does not affect the dynamic
      context.</p><infergr><infer><prejudge/><postjudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>declare namespace <emph>NCName</emph> = <emph>URILiteral</emph> <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a></expression></clause></multiclause></postjudge></infer></infergr></smdyncontext></div2><div2 id="sec_default_namespace_decls"><head>Default Namespace Declaration</head><scrap headstyle="show"><head/><prodrecap id="DefaultNamespaceDecl" ref="DefaultNamespaceDecl" orig="xquery"/></scrap><smcore><p>The core grammar production for default namespace
      declarations is:</p><scrap headstyle="show"><head/><prodrecap id="core-DefaultNamespaceDecl" ref="DefaultNamespaceDecl" orig="core"/></scrap></smcore><smnorm><p>Default namespace declarations are left unchanged through
      normalization.</p><mapping><xquery><expression>
         <map><emph>DefaultNamespaceDecl</emph></map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a>
        </expression></xquery><core><expression>
          <emph>DefaultNamespaceDecl</emph>
        </expression></core></mapping></smnorm><smcontext><p>A default element namespace declaration changes the default
      element namespace component of the static environment. If the
      URI literal is the zero-length string, the default element
      namespace is set to the null namespace. </p><infergr><infer><prejudge><clause><expression>
                  <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> =
                    <update><environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_elem_ns_env" class="env">default_elem_namespace</a></environment><expression>#NULL-NAMESPACE</expression></update>
                </expression></clause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>declare default element namespace "" <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression></clause></multiclause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><expression><a href="#jd_not" class="judgment"><term>not</term></a>(<emph>URILiteral</emph> = "")</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>URILiteral</emph> <a href="#jd_has_atomic_value" class="judgment"><term>has atomic value</term></a> <emph>AnyURI</emph>
 	     </expression></clause></multiclause><multiclause><clause><expression>
                <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> =
                  <update><environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_elem_ns_env" class="env">default_elem_namespace</a></environment><expression>
                    <emph>AnyURI</emph></expression></update>
              </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>declare default element namespace <emph>URILiteral</emph> <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression></clause></multiclause></postjudge></infer></infergr><p>A default function namespace declaration changes the default
      function namespace component of the static environment. If the
      URI literal is the zero-length string, the default function
      namespace is set to the null namespace.</p><infergr><infer><prejudge><clause><expression>
                  <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> =
                    <update><environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_fn_ns_env" class="env">default_function_namespace</a></environment><expression>#NULL-NAMESPACE</expression></update>
                </expression></clause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>declare default function namespace "" <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression></clause></multiclause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><expression><a href="#jd_not" class="judgment"><term>not</term></a>(<emph>URILiteral</emph> = "")</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>URILiteral</emph> <a href="#jd_has_atomic_value" class="judgment"><term>has atomic value</term></a> <emph>AnyURI</emph>
 	     </expression></clause></multiclause><multiclause><clause><expression>
                <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> =
                  <update><environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_fn_ns_env" class="env">default_function_namespace</a></environment><expression>
                    <emph>AnyURI</emph></expression></update>
              </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>declare default function namespace <emph>URILiteral</emph> <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression></clause></multiclause></postjudge></infer></infergr><p>Note that multiple declarations of the same namespace prefix
      in the Prolog result in a static error.  However, a declaration
      of a namespace in the Prolog can override a prefix that has been
      predeclared in the static context.</p></smcontext><smdyncontext><p>Default namespace declarations do not affect the dynamic
context. </p><infergr><infer><prejudge/><postjudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>DefaultNamespaceDecl</emph>  <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a></expression></clause></multiclause></postjudge></infer></infergr></smdyncontext></div2><div2 id="sec_variable-declarations"><head>Variable Declaration</head><scrap headstyle="show"><head/><prodrecap id="VarDecl" ref="VarDecl" orig="xquery"/></scrap><smcore><p>The core grammar production for variable declarations is:</p><scrap headstyle="show"><head/><prodrecap id="core-VarDecl" ref="VarDecl" orig="core"/></scrap></smcore><smnorm><p>Normalization of a variable declaration normalizes its
      initializing expression, if it is present.</p><mapping><xquery><expression><map>
  	   declare variable $<emph>VarName</emph> as <emph>SequenceType</emph> := <emph>Expr</emph>
  	 </map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a></expression></xquery><core><expression>
  	   declare variable $<emph>VarName</emph> as <emph>SequenceType</emph> :=
  	   <map><emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> 
  	 </expression></core></mapping><mapping><xquery><expression><map>
  	   declare variable $<emph>VarName</emph> := <emph>Expr</emph>
  	 </map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a></expression></xquery><core><expression>
  	   declare variable $<emph>VarName</emph> :=
  	   <map><emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> 
  	 </expression></core></mapping><p>If an external variable declaration does not have a type
      declaration it is treated as if the type declaration was
      <code>item()*</code>.</p><mapping><xquery><expression><map>
  	  declare variable $<emph>VarName</emph> external
  	</map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a></expression></xquery><core><expression>
  	  declare variable $<emph>VarName</emph> as item()* external
  	</expression></core></mapping><mapping><xquery><expression><map>
  	   declare variable $<emph>VarName</emph> as <emph>SequenceType</emph> external
  	 </map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a></expression></xquery><core><expression>
  	   declare variable $<emph>VarName</emph> as <emph>SequenceType</emph> external
  	 </expression></core></mapping></smnorm><smcontext><p>A variable declaration updates the variable component of the
      static context by associating the given variable with a static
      type.</p><p>If a variable declaration has an associated expression but
      does not have a type declaration, the static type of the
      variable is the static type of the expression.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                </environment><expression><emph>VarName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                <emph>Variable</emph></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                  <emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
                </expression></clause></multiclause><multiclause><clause><expression>
                  <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> =
                    <update><environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a></environment><expression>
                      <emph>Variable</emph> =&gt; <a href="#doc-fs-Type"><emph>Type</emph></a></expression></update>
                </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>declare variable $<emph>VarName</emph>
                := <emph>Expr</emph>
                <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression></clause></multiclause></postjudge></infer></infergr><p>If the variable declaration has an associated expression and
      has a type declaration, the static type of the variable is the
      specified type. The type of the expression must be a subtype of
      the declared type.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                </environment><expression><emph>VarName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                <emph>Variable</emph></expression></clause></multiclause><multiclause><clause><expression>
                  <a href="#doc-fs-Type"><emph>Type</emph></a> = <map><emph>SequenceType</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
  	       </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause></multiclause><multiclause><clause><expression>
                  <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> =
                    <update><environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a></environment><expression>
                      <emph>Variable</emph> =&gt; <a href="#doc-fs-Type"><emph>Type</emph></a></expression></update>
                </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>declare variable $<emph>VarName</emph>
                as <emph>SequenceType</emph> := <emph>Expr</emph>
                <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a>
                <phrase diff="del" at="E035"><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></phrase>
                <phrase diff="add" at="E035"><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></phrase>
                </expression></clause></multiclause></postjudge></infer></infergr><p>If the variable declaration is external and has a type
      declaration, the static type of the variable is the specified
      type.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                </environment><expression><emph>VarName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                <emph>Variable</emph></expression></clause></multiclause><multiclause><clause><expression>
                  <a href="#doc-fs-Type"><emph>Type</emph></a> = <map><emph>SequenceType</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                </expression></clause></multiclause><multiclause><clause><expression>
                  <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> =
                    <update><environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a></environment><expression>
                      <emph>Variable</emph> =&gt; <a href="#doc-fs-Type"><emph>Type</emph></a></expression></update>
                </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>declare variable $<emph>VarName</emph>
                as <emph>SequenceType</emph> external
                <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a>
                <phrase diff="del" at="E035"><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></phrase>
                <phrase diff="add" at="E035"><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></phrase>
                </expression></clause></multiclause></postjudge></infer></infergr></smcontext><smdyncontext><p>To evaluate a variable declaration, its associated expression
      is evaluated, and the dynamic context is updated with the
      variable bound to the resulting value.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>Expr</emph>
	    <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a> </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a>
              </environment><expression><emph>VarName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
              <emph>Variable</emph></expression></clause></multiclause><multiclause><clause><expression>
                 <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript> =
                   <update><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment><expression>
                     <emph>Variable</emph> =&gt; <a href="#doc-fs-Value"><emph>Value</emph></a></expression></update>
               </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>declare variable $<emph>VarName</emph> := <emph>Expr</emph>
                <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript></expression></clause></multiclause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>Expr</emph>
	    <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a> </expression></clause></multiclause><multiclause><clause><expression>
                <a href="#doc-fs-Type"><emph>Type</emph></a> = <map> <emph>SequenceType</emph> </map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
             </expression></clause></multiclause><multiclause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
                <a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
             </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a>
              </environment><expression><emph>VarName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
              <emph>Variable</emph></expression></clause></multiclause><multiclause><clause><expression>
                 <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript> =
                   <update><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment><expression>
                     <emph>Variable</emph> =&gt; <a href="#doc-fs-Value"><emph>Value</emph></a></expression></update>
               </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>declare variable $<emph>VarName</emph>
                as <emph>SequenceType</emph> := <emph>Expr</emph>
                <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript></expression></clause></multiclause></postjudge></infer></infergr><p>Dynamic evaluation does not apply to externally defined
      variables.  The dynamic environment must provide the values of
      external variables in the initial dynamic context
      (<a href="#xq_default_dyn_env" class="env">dynEnvDefault</a>).</p><infergr><infer><prejudge/><postjudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>declare variable $<emph>VarName</emph>
                as <emph>SequenceType</emph> external
                <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a></expression></clause></multiclause></postjudge></infer></infergr></smdyncontext></div2><div2 id="sec_FunctionDeclns"><head>Function Declaration</head><smintro><p>User-defined functions specify the name of the function, the
      names and types of the parameters, and the type of the
      result. The <term>function body</term> defines how the result of
      the function is computed from its parameters.</p><scrap headstyle="show"><head>Function declarations</head><prodrecap id="FunctionDecl" ref="FunctionDecl" orig="xquery"/><prodrecap id="ParamList" ref="ParamList" orig="xquery"/><prodrecap id="Param" ref="Param" orig="xquery"/></scrap></smintro><smcore><p>The core grammar productions for function declarations
      are:</p><scrap headstyle="show"><head>Function declarations</head><prodrecap id="core-FunctionDecl" ref="FunctionDecl" orig="core"/><prodrecap id="core-ParamList" ref="ParamList" orig="core"/><prodrecap id="core-Param" ref="Param" orig="core"/></scrap></smcore><smnotation><p id="jd_map_param">The following auxiliary mapping rule is
      used for the normalization of parameters in function
      declarations:
      <expression><map/><a href="#jd_map_param" class="judgment"><subscript>Param</subscript></a></expression>.</p><p>Parameters without a declared type are given the item()*
      sequence type.</p><mapping><xquery><expression>
           <map>$<emph>VarName</emph></map><a href="#jd_map_param" class="judgment"><subscript>Param</subscript></a>
         </expression></xquery><core><expression>
           $<emph>VarName</emph> as item()* 
         </expression></core></mapping><mapping><xquery><expression>
           <map>$<emph>VarName</emph> as <emph>SequenceType</emph> </map><a href="#jd_map_param" class="judgment"><subscript>Param</subscript></a>
         </expression></xquery><core><expression>
           $<emph>VarName</emph> as <emph>SequenceType</emph> 
         </expression></core></mapping><p>An empty parameter list is left unchanged.</p><mapping><xquery><expression>
           <map/><a href="#jd_map_param" class="judgment"><subscript>Param</subscript></a>
         </expression></xquery><core><expression>
         </expression></core></mapping><p>A parameter list is normalized by applying the normalization
      rule to each parameter.</p><mapping><xquery><expression>
           <map> <emph>Param</emph><subscript>1</subscript>, ..., <emph>Param</emph><subscript>n</subscript> </map><a href="#jd_map_param" class="judgment"><subscript>Param</subscript></a>
         </expression></xquery><core><expression>
           <map> <emph>Param</emph><subscript>1</subscript> </map><a href="#jd_map_param" class="judgment"><subscript>Param</subscript></a>, ..., <map> <emph>Param</emph><subscript>n</subscript> </map><a href="#jd_map_param" class="judgment"><subscript>Param</subscript></a>
         </expression></core></mapping></smnotation><smnorm><p>The parameter list and body of a user-defined function are
      all normalized into Core expressions.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>QName</emph> <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression></clause></multiclause><multiclause><clause><expression>
                  <a href="#doc-fs-Type"><emph>Type</emph></a> = <map><emph>SequenceType</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><map>
  	   declare function <emph>QName</emph> ( <emph>ParamList</emph>? ) as
  	   <emph>SequenceType</emph> { <emph>Expr</emph> }
  	 </map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a>
              =
         declare function <emph>QName</emph> (
  	   <map><emph>ParamList</emph>?</map><a href="#jd_map_param" class="judgment"><subscript>Param</subscript></a> )
  	   as <emph>SequenceType</emph>
  	   { <map><emph>Expr</emph></map><a href="#jd_map_function_argument" class="judgment"><subscript>FunctionArgument(<emph>Type</emph>)</subscript></a> }
            </expression></clause></postjudge></infer></infergr><p>If the return type of the function is not provided, it is
      given the <code>item()*</code> sequence type.</p><mapping><xquery><expression>
           <map>declare function <emph>QName</emph> ( <emph>ParamList</emph>?  )
  	   { <emph>Expr</emph> }</map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a>
         </expression></xquery><core><expression>
           <map>declare function <emph>QName</emph> ( <emph>ParamList</emph>?  ) as item()*
  	   { <emph>Expr</emph> }</map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a>
  	 </expression></core></mapping><p>Externally defined functions are normalized similarly.</p><mapping><xquery><expression><map>
  	   declare function <emph>QName</emph> ( <emph>ParamList</emph>? ) as
  	   <emph>SequenceType</emph> external</map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a></expression></xquery><core><expression>
  	   declare function <emph>QName</emph>(
  	   <map><emph>ParamList</emph>?</map><a href="#jd_map_param" class="judgment"><subscript>Param</subscript></a> )
  	   as <emph>SequenceType</emph> external
  	 </expression></core></mapping><mapping><xquery><expression>
           <map>declare function <emph>QName</emph> ( <emph>ParamList</emph>?  )
  	   external </map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a>
         </expression></xquery><core><expression>
           <map>declare function <emph>QName</emph> ( <emph>ParamList</emph>?  ) as item()*
  	   external </map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a>
  	 </expression></core></mapping></smnorm><smnotation><p>We use the following auxiliary judgment during static
       context processing and static type analysis of function
       declarations.</p><p id="jd_function_declaration">The judgment:</p><display>
         <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_function_declaration" class="judgment"><term>function declaration</term></a> <emph>FunctionDecl</emph>
           <a href="#jd_function_declaration" class="judgment"><term>with signature</term></a> <emph>FunctionSig</emph> <a href="#jd_function_declaration" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
           </expression></clause>
       </display><p>holds if the function declaration <emph>FunctionDecl</emph> with the
       signature <emph>FunctionSig</emph> has the type <a href="#doc-fs-Type"><emph>Type</emph></a>.</p></smnotation><smcontext><p>Static context processing accesses the function signature
      from the static context, and checks that the function
      declaration corresponds to the declared type.</p><infergr><infer><prejudge><multiclause><clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_functy_env" class="env">funcType</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>,n) = <emph>FunctionSig</emph>
               </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_function_declaration" class="judgment"><term>function declaration</term></a> <emph>FunctionDecl</emph>
               <a href="#jd_function_declaration" class="judgment"><term>with signature</term></a> <emph>FunctionSig</emph> <a href="#jd_function_declaration" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>r</subscript>
               </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
              <emph>FunctionDecl</emph> <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript>
  	     </expression></clause></postjudge></infer></infergr><p>Note that the static context processing is performing type
      checking of the function, as defined below. Note also that the
      type checking is done in the new environment in which the
      function declaration has been added which ensures that recursive
      calls are type-checked properly.</p></smcontext><smtype><p>The static typing rules for function bodies follow
      normalization and processing of the static context.  The static
      typing rules below construct a new environment in which each
      parameter has the given expected type, then the static type of
      the function's body is computed under the new environment.  The
      function body's type must be a subtype of the expected return
      type.  If static typing fails, a static type error is raised.
      Otherwise, static typing of the function has no other effect, as
      function signatures are already inside the static
      environment.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a></environment><expression><emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>r</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_function_declaration" class="judgment"><term>function declaration</term></a> declare function <emph>QName</emph> ()
  	      as <emph>SequenceType</emph><subscript>r</subscript>
  	      { <emph>Expr</emph> } <a href="#jd_function_declaration" class="judgment"><term>with signature</term></a>
  	      declare function <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>()
  	      as <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>r</subscript> <a href="#jd_function_declaration" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>r</subscript>
  	      </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment><expression><emph>VarName</emph><subscript>1</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><expression>...</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment><expression><emph>VarName</emph><subscript>n</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph><subscript>n</subscript></expression></clause></multiclause><multiclause><clause><environment>
  		  <update><environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a></environment><expression>
  		      <emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
  		      ;...;
  		      <emph>Variable</emph><subscript>n</subscript> =&gt; <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>
  		    </expression></update>
  		</environment><expression><emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>r</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_function_declaration" class="judgment"><term>function declaration</term></a> declare function <emph>QName</emph>
  		($<emph>VarName</emph><subscript>1</subscript> as  <emph>SequenceType</emph><subscript>1</subscript>, ···,
  	      $<emph>VarName</emph><subscript>n</subscript> as <emph>SequenceType</emph><subscript>n</subscript>)
  	      as <emph>SequenceType</emph><subscript>r</subscript>
  	      { <emph>Expr</emph> } <a href="#jd_function_declaration" class="judgment"><term>with signature</term></a>
  	      declare function <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, ..., <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>)
  	      as <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>r</subscript> <a href="#jd_function_declaration" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>r</subscript>
  	      </expression></clause></postjudge></infer></infergr><p>The bodies of external functions are not available and
      therefore cannot by type checked.  To ensure type soundness, the
      implementation must guarantee that the value returned by the
      external function matches the expected return type. </p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_function_declaration" class="judgment"><term>function declaration</term></a> declare function <emph>QName</emph> ()
  	      as <emph>SequenceType</emph><subscript>r</subscript>
  	      external <a href="#jd_function_declaration" class="judgment"><term>with signature</term></a>
  	      declare function <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>()
  	      as <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>r</subscript> <a href="#jd_function_declaration" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>r</subscript>
  	      </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment><expression><emph>VarName</emph><subscript>1</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><expression>...</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment><expression><emph>VarName</emph><subscript>n</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph><subscript>n</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_function_declaration" class="judgment"><term>function declaration</term></a> declare function <emph>QName</emph>
  		( $<emph>VarName</emph><subscript>1</subscript> as <emph>SequenceType</emph><subscript>1</subscript>, ···,
  	      $<emph>VarName</emph><subscript>n</subscript> as <emph>SequenceType</emph><subscript>n</subscript> )
  	      as <emph>SequenceType</emph><subscript>r</subscript>
  	      external <a href="#jd_function_declaration" class="judgment"><term>with signature</term></a>
  	      declare function <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, ..., <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>)
  	      as <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>r</subscript> <a href="#jd_function_declaration" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>r</subscript>
  	      </expression></clause></postjudge></infer></infergr></smtype><smdyncontext><p>A function declaration updates the dynamic context.  The
       function name with arity N is associated with the given
       function body.  The number of arguments is required, because
       XQuery permits overloading of function names as long as each
       function signature has a different number of arguments.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>QName</emph> <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression></clause></multiclause><multiclause><clause><expression>
                <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript> =
                    <update><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_func_env" class="env">funcDefn</a></environment><expression><a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><phrase diff="chg" at="E006">,0</phrase> =&gt; (<emph>Expr</emph>)</expression></update>
                </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>declare function <emph>QName</emph> ()
  	      as <emph>SequenceType</emph><subscript>r</subscript>
  	      { <emph>Expr</emph> } <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript>
  	      </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>QName</emph> <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>VarName</emph><subscript>1</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><expression>···</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment><expression><emph>VarName</emph><subscript>n</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph><subscript>n</subscript></expression></clause></multiclause><multiclause diff="del" at="E006"><clause><expression><map><emph>SequenceType</emph><subscript>1</subscript></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                        = <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression></clause></multiclause><multiclause diff="del" at="E006"><clause><expression>...</expression></clause></multiclause><multiclause diff="del" at="E006"><clause><expression><map><emph>SequenceType</emph><subscript>n</subscript></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                        = <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript></expression></clause></multiclause><multiclause><clause><expression>
                <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript> =
                    <update><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_func_env" class="env">funcDefn</a></environment><expression><a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><phrase diff="chg" at="E006">,n</phrase> =&gt; (
                      <emph>Expr</emph> , <emph>Variable</emph><subscript>1</subscript> , ···,
                      <emph>Variable</emph><subscript>n</subscript>)</expression></update>
                </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>declare function <emph>QName</emph>
  		( $<emph>VarName</emph><subscript>1</subscript> as <emph>SequenceType</emph><subscript>1</subscript>, ···,
  	      $<emph>VarName</emph><subscript>n</subscript>  as <emph>SequenceType</emph><subscript>n</subscript> )
  	      as <emph>SequenceType</emph><subscript>r</subscript>
  	      { <emph>Expr</emph> } <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript>
  	      </expression></clause></postjudge></infer></infergr><p>An external function declaration does not affect the dynamic
       environment. The implementation must support the declared
       external functions.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>declare function <emph>QName</emph>
  		( $<emph>VarName</emph><subscript>1</subscript> as <emph>SequenceType</emph><subscript>1</subscript>, ···,
  	      $<emph>VarName</emph><subscript>n</subscript> as <emph>SequenceType</emph><subscript>n</subscript> )
  	      as <emph>SequenceType</emph><subscript>r</subscript>
  	      external <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a>
  	      </expression></clause></postjudge></infer></infergr><p>The dynamic semantics of a function body are applied when
       the function is called, as described in <specref ref="id-function-calls"/>.</p></smdyncontext></div2><div2 id="id-option-declaration"><head>Option Declaration</head><scrap headstyle="show"><head/><prodrecap id="OptionDecl" ref="OptionDecl" orig="xquery"/></scrap><smcore><p>The core grammar production for option declarations is:</p><scrap headstyle="show"><head/><prodrecap id="core-OptionDecl" ref="OptionDecl" orig="core"/></scrap></smcore><smnorm><p>Option declarations are left unchanged through
      normalization.</p><mapping><xquery><expression>
         <map><emph>OptionDecl</emph></map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a>
        </expression></xquery><core><expression>
          <emph>OptionDecl</emph>
        </expression></core></mapping></smnorm><smcontext><p>An option declaration does not have any effect on the static
      context.</p><infergr><infer><prejudge/><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>OptionDecl</emph> <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a></expression></clause></multiclause></postjudge></infer></infergr></smcontext><smdyncontext><p>An option declaration does not have any effect on the dynamic
      context.</p><infergr><infer><prejudge/><postjudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>OptionDecl</emph> <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a></expression></clause></multiclause></postjudge></infer></infergr></smdyncontext></div2></div1><div1 id="id-xquery-conformance" role="xquery"><head>Conformance</head><p>The XQuery Formal Semantics is intended primarily as a component
  that can be used by <bibref ref="xquery-30"/>, or a host language of
  <bibref ref="xpath-30"/>. Therefore, the XQuery Formal Semantics
  relies on specifications that use it (such as [XPath 3.0], [XSLT
  3.0], and [XQuery 3.0]) to specify conformance criteria in their
  respective environments. Specifications that set conformance
  criteria for their use of the formal semantics must not relax the
  constraints expressed in this specification.</p><div2 id="id-static-typing-feature"><head>Static Typing Feature</head><p>This specification normatively defines the static typing
    feature which can be used in <bibref ref="xquery-30"/> or a host
    language of <bibref ref="xpath-30"/>. The static typing feature is
    specified using the static typing judgment introduced in <specref ref="sec_static"/>.</p><div3 id="id-static-extensions"><head>Static Typing Extensions</head><p>In some cases, the static typing rules are not very precise
      (see, for example, the type inference rules for the ancestor
      axes—parent, ancestor, and ancestor-or-self—and for
      the function <code>fn:root</code>). If an implementation
      supports a static typing extension, it must always provide a
      more precise type than the one defined in this
      specification.</p><p id="jd_has_type_extension">This constraint is formally
      expressed as follows. A static typing extension <emph>Expr</emph>
      <a href="#jd_has_type_extension" class="judgment"><term>:</term><subscript>ext</subscript></a> <a href="#doc-fs-Type"><emph>Type</emph></a> must be such that for every
      expression <emph>Expr</emph> the following holds.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a>' <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>Expr</emph> <a href="#jd_has_type_extension" class="judgment"><term>:</term><subscript>ext</subscript></a> <a href="#doc-fs-Type"><emph>Type</emph></a>'</expression></clause></multiclause></postjudge></infer></infergr><note><p>It is not recommended for a static typing extension to
      change the static typing behavior of expressions that specify a
      type explicitly (<code>treat as</code>, <code>cast as</code>,
      <code>typeswitch</code>, function parameters, and type
      declarations in variable bindings), since the purpose of those
      expressions is to impose a specific type.</p></note></div3></div2></div1><div1 id="sec_special_functions"><head>Additional Semantics of Functions</head><p>This section defines the auxiliary functions required to define
  the formal semantics of [XPath/XQuery], and gives special normalization
  and static typing rules for some functions in <bibref ref="xpath-functions-30"/>.</p><p>Remember from <specref ref="id-function-calls"/> that the
  following rules operate after namespace resolution for the function
  name, and directly over the input type of the parameters. In the
  rest of the section, we will use the following shortcuts notations
  for specific relevant URIs:</p><ulist><item><p><code>FN-URI</code> for functions from the <bibref ref="xpath-functions-30"/>
    document.</p></item><item><p><code>OP-URI</code> for operators from the <bibref ref="xpath-functions-30"/>
    document.</p></item><item><p><code>FS-URI</code> for formal semantics functions.</p></item></ulist><div2 id="sec_special_fs_functions"><head>Formal Semantics Functions</head><smintro><p>This section gives the definition and semantics of functions
      that are used in the formal semantics but are not in
      <bibref ref="xpath-functions-30"/>.  Their dynamic semantics are defined in the same
      informal style as in the <bibref ref="xpath-functions-30"/> document.  The static
      semantics of some formal-semantics functions require custom
      static typing rules.</p></smintro><div3 id="sec_convert_operand"><head><phrase>The <a href="#sec_convert_operand"><emph>fs:</emph><code>convert-operand</code></a> function</phrase></head><example role="signature"><proto name="convert-operand" return-type="xs:anyAtomicType ?" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" isStd="no"><arg name="actual" type="xs:anyAtomicType?"/><arg name="expected" type="xs:anyAtomicType"/></proto></example><p>The formal-semantics function <a href="#sec_convert_operand"><emph>fs:</emph><code>convert-operand</code></a> converts
      the operands of arithmetic and comparison operators as
      follows:</p><olist><item><p>If <code>$actual</code> is the empty sequence, returns the
          empty sequence.</p></item><item><p>If <code>$actual</code> is an instance of type
          <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>, then</p><olist><item><p>if <code>$expected</code> is an instance of type
              <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> or <code>xs:string</code>, returns
              <code>$actual</code> cast to <code>xs:string</code>;</p></item><item><p>if <code>$expected</code> is of numeric type, returns
              <code>$actual</code> cast to <code>xs:double</code></p></item><item><p>otherwise returns <code>$actual</code> cast to the
              type of <code>$expected</code>.</p></item></olist></item><item><p>Otherwise, returns <code>$actual</code>.</p></item></olist><smtype><p>No conversion is needed unless $actual is an instance of
        type <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>.</p><infergr><infer><prejudge><multiclause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
                    not(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>?)
                  </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                  <a href="#sec_convert_operand">(<code>FS-URI</code>,<quote><code>convert-operand</code></quote>)</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
                </expression></clause></postjudge></infer></infergr><p>Pairs of untyped atomic operands are converted to
        strings.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
                  <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> ?</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> (<a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>|<code>xs:string</code>)</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                  <a href="#sec_convert_operand">(<code>FS-URI</code>,<quote><code>convert-operand</code></quote>)</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a>
                  <code>xs:string</code> <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a> (<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)
                </expression></clause></postjudge></infer></infergr><p>When an untyped operand is paired with a numeric operand,
        it is converted to xs:double.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
                  <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> ?</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <emph>fs:</emph><code>numeric</code></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                  <a href="#sec_convert_operand">(<code>FS-URI</code>,<quote><code>convert-operand</code></quote>)</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a>
                  <code>xs:double</code> <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a> (<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)
                </expression></clause></postjudge></infer></infergr><p>Finally, an untyped atomic operand not dealt with by the
        above rules is converted to the type of the other operand.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
                  <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> ?</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
                  <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a></expression></clause></multiclause><multiclause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
                    <a href="#jd_not" class="judgment"><term>not</term></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> (<a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>|<code>xs:string</code>|<emph>fs:</emph><code>numeric</code>))
                  </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                  <a href="#sec_convert_operand">(<code>FS-URI</code>,<quote><code>convert-operand</code></quote>)</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a>
                  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)
                </expression></clause></postjudge></infer></infergr></smtype></div3><div3 id="sec_convert_simple_operand"><head><phrase>The <a href="#sec_convert_simple_operand"><emph>fs:</emph><code>convert-simple-operand</code></a> function</phrase></head><example role="signature"><proto name="convert-simple-operand" return-type="xs:anyAtomicType *" diff="chg" at="E004" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" isStd="no"><arg name="actual" type="xs:anyAtomicType *"/><arg name="expected" type="xs:anyAtomicType"/></proto></example><p>The formal-semantics function <a href="#sec_convert_simple_operand"><emph>fs:</emph><code>convert-simple-operand</code></a> is
      used to convert the value of the <code>$actual</code> argument
      such that it matches the type of the <code>$expected</code>
      argument (or matches a sequence of that type).</p><p>The dynamic semantics of this function are as follows:</p><ulist><item><p>For each item in <code>$actual</code> argument that is of
          type xs:untypedAtomic, that item is cast to the type of the
          <code>$expected</code> argument, and the resulting sequence
          is returned.</p></item></ulist><smtype><p>The following static typing rules correspond to the dynamic
        semantics rules given above.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a></expression></clause></multiclause><multiclause><clause><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript> =
                  <a href="#jd_convert_untypedAtomic" class="judgment"><term>convert_untypedAtomic</term></a>(<a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>), <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                  <a href="#sec_convert_simple_operand">(<code>FS-URI</code>,<quote><code>convert-simple-operand</code></quote>)</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)
                  <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript> <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)
                </expression></clause></postjudge></infer></infergr></smtype></div3><div3 id="sec_distinct_docorder"><head><phrase>The <a href="#sec_distinct_docorder"><emph>fs:</emph><code>distinct-doc-order</code></a> function</phrase></head><example role="signature"><proto name="distinct-doc-order" return-type="node *" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" isStd="no"><arg name="nodes" type="node *"/></proto></example><p>The <a href="#sec_distinct_docorder"><emph>fs:</emph><code>distinct-doc-order</code></a> function sorts its input sequence
      of nodes by document order
      and removes duplicates.</p><smtype><p>The <a href="#sec_distinct_docorder"><emph>fs:</emph><code>distinct-doc-order</code></a> function expects a sequence of
        nodes as input. The resulting type is computed using
        <a href="#jd_prime" class="judgment">prime</a> and <a href="#jd_quantifier" class="judgment">quantifier</a>, which are defined in <specref ref="sec_factor"/>.</p><infergr><infer><prejudge><multiclause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
                    <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> node*
                  </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#sec_distinct_docorder">(<code>FS-URI</code>,<quote><code>distinct-doc-order</code></quote>)</a> ( <a href="#doc-fs-Type"><emph>Type</emph></a>
			) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_quantifier" class="judgment">·</a>
			<a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)</expression></clause></multiclause></postjudge></infer></infergr></smtype></div3><div3 id="sec_distinct_docorder_or_atomic_sequence"><head><phrase>The <a href="#sec_distinct_docorder_or_atomic_sequence"><emph>fs:</emph><code>distinct-doc-order-or-atomic-sequence</code></a> function</phrase></head><example role="signature"><proto name="distinct-doc-order-or-atomic-sequence" return-type="item()*" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" isStd="no"><arg name="item" type="item()*"/></proto></example><p>The <a href="#sec_distinct_docorder_or_atomic_sequence"><emph>fs:</emph><code>distinct-doc-order-or-atomic-sequence</code></a> function operates
      on either an homogeneous sequence of nodes or an homogeneous
      sequence of atomic values. If the input is a sequence of nodes,
      is sorts those nodes by document order and removes duplicates,
      using the fs:distinct-doc-order function. If it is a sequence of
      atomic values, it returns it unchanged.</p><smtype><p>The <a href="#sec_distinct_docorder"><emph>fs:</emph><code>distinct-doc-order</code></a> function expects either a
        sequence of nodes as input or a sequence of atomic values. The
        resulting type is computed using <a href="#jd_prime" class="judgment">prime</a> and
        <a href="#jd_quantifier" class="judgment">quantifier</a>, which are defined in <specref ref="sec_factor"/>.</p><infergr><infer><prejudge><multiclause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
                    <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <map>node()</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>*
                  </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#sec_distinct_docorder_or_atomic_sequence">(<code>FS-URI</code>,<quote><code>distinct-doc-order-or-atomic-sequence</code></quote>)</a> ( <a href="#doc-fs-Type"><emph>Type</emph></a>
			) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_quantifier" class="judgment">·</a>
			<a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)</expression></clause></multiclause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
                    <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>*
                  </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#sec_distinct_docorder_or_atomic_sequence">(<code>FS-URI</code>,<quote><code>distinct-doc-order-or-atomic-sequence</code></quote>)</a> ( <a href="#doc-fs-Type"><emph>Type</emph></a>
			) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause></multiclause></postjudge></infer></infergr></smtype></div3><div3 id="sec_items_to_nodes"><head><phrase>The <a href="#sec_items_to_nodes"><emph>fs:</emph><code>item-sequence-to-node-sequence</code></a> function</phrase></head><example role="signature"><proto name="item-sequence-to-node-sequence" return-type="node()*" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" isStd="no"><arg name="items" type="item()*"/></proto></example><p>The <a href="#sec_items_to_nodes"><emph>fs:</emph><code>item-sequence-to-node-sequence</code></a> function converts a sequence of
      item values to nodes by applying the normative rules numbered
      <phrase diff="del" at="E029">
      <code>1</code>, <code>2</code>, <code>3</code> after the
      sentence <quote>Processing of the computed element constructor
      proceeds as follows:</quote> in <xspecref spec="XQ" ref="id-computedElements"/>.
      </phrase>
      <phrase diff="add" at="E029">
      <code>1e</code> and <code>2</code> in <xspecref spec="XQ" ref="id-content"/>
      (with the value bound to <code>$items</code> playing the role of "the value of an enclosed expression").
      </phrase>
      </p><p diff="add" at="E012">
        If the input sequence contains any attribute nodes,
        they must precede any other items<phrase diff="del" at="E029">,
        with the exception that text nodes are allowed throughout.
        This exception results in looser type checking,
        but it is necessitated by the possible presence of empty text nodes
        introduced by normalization of direct element constructors
        (see <specref ref="id_element_constructor"/>)</phrase>.
      </p><smtype><infergr diff="add" at="E029"><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                    <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
                    attribute**
                  </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                    <a href="#sec_items_to_nodes">(<code>FS-URI</code>,<quote><code>item-sequence-to-node-sequence</code></quote>)</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)
                    <a href="#jd_has_type" class="judgment"><term>:</term></a>
                    attribute**
                  </expression></clause></multiclause></postjudge></infer></infergr><infergr diff="add" at="E029"><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                    <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
                    (element*|text|processing-instruction*|comment|document|<a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>)*
                  </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                    <a href="#sec_items_to_nodes">(<code>FS-URI</code>,<quote><code>item-sequence-to-node-sequence</code></quote>)</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)
                    <a href="#jd_has_type" class="judgment"><term>:</term></a>
                    (element*|text|processing-instruction*|comment)*
                  </expression></clause></multiclause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
                        <phrase diff="del" at="E029">
                          <phrase diff="chg" at="E012">
                          (
                            attribute<phrase diff="add" at="E023">*</phrase>*,
                            (element<phrase diff="add" at="E023"> *</phrase>|document|processing-instruction<phrase diff="add" at="E022"> *</phrase>|comment|<code>xs:string</code>|<code>xs:float</code>|...|<code>xs:NOTATION</code>)*
                          ) &amp; text*
                          </phrase>
                        </phrase>
                        <phrase diff="add" at="E029"><!-- effectively back to pre-E012 state -->
                          attribute<phrase diff="add" at="E023">*</phrase>*,
                          (element<phrase diff="add" at="E023"> *</phrase>|text|processing-instruction<phrase diff="add" at="E022"> *</phrase>|comment|document|<a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>)*
                        </phrase>
                        </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#sec_items_to_nodes">(<code>FS-URI</code>,<quote><code>item-sequence-to-node-sequence</code></quote>)</a>
			(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_has_type" class="judgment"><term>:</term></a> attribute<phrase diff="add" at="E023">*</phrase>*, (element<phrase diff="add" at="E023"> *</phrase>|text|processing-instruction<phrase diff="add" at="E022"> *</phrase>|comment)*</expression></clause></multiclause></postjudge></infer></infergr></smtype></div3><div3 id="sec_items_to_nodes_doc" diff="del" at="E029"><head><phrase>The <a href="#sec_items_to_nodes"><emph>fs:</emph><code>item-sequence-to-node-sequence-doc</code></a> function</phrase></head><example role="signature"><proto name="item-sequence-to-node-sequence-doc" return-type="node()*" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" isStd="no"><arg name="items" type="item()*"/></proto></example><p>The <a href="#sec_items_to_nodes"><emph>fs:</emph><code>item-sequence-to-node-sequence-doc</code></a> function converts a
      sequence of item values to nodes by applying the normative rules
      numbered <code>1</code>, <code>2</code>, <code>3</code> after
      the sentence <quote>Processing of the document node constructor
      then proceeds as follows:</quote> in <xspecref spec="XQ" ref="id-documentConstructors"/>.</p><smtype><infergr><infer><prejudge><multiclause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
			(element<phrase diff="add" at="E023"> *</phrase>|document|text|processing-instruction<phrase diff="add" at="E022"> *</phrase>|comment|<code>xs:string</code>|<code>xs:float</code>|
			...|<code>xs:NOTATION</code>)*</expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#sec_items_to_nodes_doc">(<code>FS-URI</code>,<quote><code>item-sequence-to-node-sequence-doc</code></quote>)</a>
			(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_has_type" class="judgment"><term>:</term></a> (element<phrase diff="add" at="E023"> *</phrase>|text|processing-instruction<phrase diff="add" at="E022"> *</phrase>|comment)*</expression></clause></multiclause></postjudge></infer></infergr></smtype></div3><div3 id="sec_item_seq_to_string"><head><phrase>The 
        <phrase diff="del" at="E031" id="sec_item_seq_to_untypedAtomic"><a href="#sec_item_seq_to_untypedAtomic"><emph>fs:</emph><code>item-sequence-to-untypedAtomic</code></a></phrase>
        <phrase diff="add" at="E031"><a href="#sec_item_seq_to_string"><emph>fs:</emph><code>item-sequence-to-string</code></a></phrase>
        function</phrase></head><smintro><example role="signature"><proto name="item-sequence-to-untypedAtomic" return-type="xs:untypedAtomic" diff="del" at="E031" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" isStd="no"><arg name="items" type="item()*"/></proto><proto name="item-sequence-to-string" return-type="xs:string" diff="add" at="E031" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" isStd="no"><arg name="items" type="item()*"/></proto></example><p>The 
        <phrase diff="del" at="E031"><a href="#sec_item_seq_to_untypedAtomic"><emph>fs:</emph><code>item-sequence-to-untypedAtomic</code></a></phrase>
        <phrase diff="add" at="E031"><a href="#sec_item_seq_to_string"><emph>fs:</emph><code>item-sequence-to-string</code></a></phrase>
        function converts a
        sequence of item values to a string <phrase diff="del" at="E031">of type <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a></phrase>
        by applying the normative rules in <xspecref spec="XQ" ref="id-computedAttributes"/> for processing the content
        expression.</p></smintro><smeval><p>If the input of the 
        <phrase diff="del" at="E031"><a href="#sec_item_seq_to_untypedAtomic"><emph>fs:</emph><code>item-sequence-to-untypedAtomic</code></a></phrase>
        <phrase diff="add" at="E031"><a href="#sec_item_seq_to_string"><emph>fs:</emph><code>item-sequence-to-string</code></a></phrase>
        function
        is an empty sequence, it returns a zero-length
        string. Otherwise, each atomic value in the input sequence is
        cast into a string. The individual strings resulting from the
        previous step are merged into a single string by concatenating
        them with a single space character between each pair.</p></smeval><smtype><p>There are no special static typing rules for this
        function. Static type analysis for this function should be
        performed as for a built-in function declared with the given
        signature.</p></smtype></div3><div3 id="sec_item_seq_to_untypedAtomic_PI"><head><phrase>The <a href="#sec_item_seq_to_untypedAtomic_PI"><emph>fs:</emph><code>item-sequence-to-untypedAtomic-PI</code></a> function</phrase></head><smintro><example role="signature"><proto name="item-sequence-to-untypedAtomic-PI" return-type="xs:untypedAtomic" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" isStd="no"><arg name="items" type="item()*"/></proto></example><p>The <a href="#sec_item_seq_to_untypedAtomic_PI"><emph>fs:</emph><code>item-sequence-to-untypedAtomic-PI</code></a> function converts a
        sequence of item values to a string of type <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>
        by applying the normative rules in <xspecref spec="XQ" ref="id-computed-pis"/> for processing the content
        expression.</p></smintro><smeval><p>If the input is an empty sequence, the
        <a href="#sec_item_seq_to_untypedAtomic_PI"><emph>fs:</emph><code>item-sequence-to-untypedAtomic-PI</code></a> function returns a
        zero-length string. Otherwise, each atomic value in the input
        sequence is cast into a string. If any of the resulting
        strings contains the string "?&gt;", a dynamic error is
        raised. The individual strings resulting from the previous
        step are merged into a single string by concatenating them
        with a single space character between each pair. Leading
        whitespace is removed from the resulting string.</p></smeval><smtype><p>There are no special static typing rules for this
       function. Static type analysis for this function should be
       performed as for a built-in function declared with the given
       signature.</p></smtype></div3><div3 id="sec_item_seq_to_untypedAtomic_text"><head><phrase>The <a href="#sec_item_seq_to_untypedAtomic_text"><emph>fs:</emph><code>item-sequence-to-untypedAtomic-text</code></a> function</phrase></head><smintro><example role="signature"><proto name="item-sequence-to-untypedAtomic-text" return-type="xs:untypedAtomic?" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" isStd="no"><arg name="items" type="item()*"/></proto></example><p>The <a href="#sec_item_seq_to_untypedAtomic_text"><emph>fs:</emph><code>item-sequence-to-untypedAtomic-text</code></a> function converts a
        sequence of item values to a string of type
        <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>, or empty, by applying the rules in
        <xspecref spec="XQ" ref="id-textConstructors"/> for processing
        the content expression.</p></smintro><smeval><p>If the input is the empty sequence, the
        <a href="#sec_item_seq_to_untypedAtomic_text"><emph>fs:</emph><code>item-sequence-to-untypedAtomic-text</code></a> function returns the empty
        sequence. Otherwise, each atomic value in the input sequence
        is cast into a string. The individual strings resulting from
        the previous step are merged into a single string by
        concatenating them with a single space character between each
        pair.</p></smeval><smtype><p>There are no special static typing rules for this
        function. Static type analysis for this function should be
        performed as for a built-in function declared with the given
        signature.</p></smtype></div3><div3 id="sec_item_seq_to_untypedAtomic_comment"><head><phrase>The <a href="#sec_item_seq_to_untypedAtomic_comment"><emph>fs:</emph><code>item-sequence-to-untypedAtomic-comment</code></a> function</phrase></head><smintro><example role="signature"><proto name="item-sequence-to-untypedAtomic-comment" return-type="xs:untypedAtomic" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" isStd="no"><arg name="items" type="item()*"/></proto></example><p>The <a href="#sec_item_seq_to_untypedAtomic_comment"><emph>fs:</emph><code>item-sequence-to-untypedAtomic-comment</code></a> function
        converts a sequence of item values to a string of type
        <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> by applying the normative rules in
        <xspecref spec="XQ" ref="id-computed-comments"/> for
        processing the content expression.</p></smintro><smeval><p>If the input is the empty sequence, the
        <a href="#sec_item_seq_to_untypedAtomic_comment"><emph>fs:</emph><code>item-sequence-to-untypedAtomic-comment</code></a> function returns a
        zero-length string. Otherwise, each atomic value in the input
        sequence is cast into a string. The individual strings
        resulting from the previous step are merged into a single
        string by concatenating them with a single space character
        between each pair. It is a dynamic error if the result of the
        content expression of a computed comment constructor contains
        two adjacent hyphens or ends with a hyphen.</p></smeval><smtype><p>There are no special static typing rules for this
        function. Static type analysis for this function should be
        performed as for a built-in function declared with the given
        signature.</p></smtype></div3><div3 id="sec_apply_ordering_mode"><head><phrase>The <a href="#sec_apply_ordering_mode"><emph>fs:</emph><code>apply-ordering-mode</code></a>
      function</phrase></head><example role="signature"><proto name="apply-ordering-mode" return-type="item()*" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" isStd="no"><arg name="items" type="item()*"/></proto></example><smeval><p>If the <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ordering_mode_env" class="env">orderingMode</a> is set to ordered, the
        <a href="#sec_apply_ordering_mode"><emph>fs:</emph><code>apply-ordering-mode</code></a> function is the identity function,
        returning its input sequence in its original order.</p><infergr><infer><prejudge><clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ordering_mode_env" class="env">orderingMode</a> = <code>ordered</code></expression></clause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a> </environment><expression><emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a></expression></clause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a> </environment><expression><a href="#sec_apply_ordering_mode"><emph>fs:</emph><code>apply-ordering-mode</code></a>(<emph>Expr</emph>)
		      <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a></expression></clause></postjudge></infer></infergr><p>If the <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ordering_mode_env" class="env">orderingMode</a> is set to unordered, the
        <a href="#sec_apply_ordering_mode"><emph>fs:</emph><code>apply-ordering-mode</code></a> is equivalent to the <code>fn:unordered</code>
        function, returning the items from its input sequence in
        arbitrary order.</p><infergr><infer><prejudge><clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ordering_mode_env" class="env">orderingMode</a> = <code>unordered</code></expression></clause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a> </environment><expression><code>fn:unordered</code>(<emph>Expr</emph>) <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a></expression></clause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a> </environment><expression><a href="#sec_apply_ordering_mode"><emph>fs:</emph><code>apply-ordering-mode</code></a>(<emph>Expr</emph>)
		      <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a></expression></clause></postjudge></infer></infergr></smeval><smtype><p>If the ordering context is set to <code>ordered</code>, the
        static type of the input expression of the
        <a href="#sec_apply_ordering_mode"><emph>fs:</emph><code>apply-ordering-mode</code></a> function is left unchanged.</p><infergr><infer><prejudge><clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ordering_mode_env" class="env">orderingMode</a> = <code>ordered</code></expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><a href="#sec_apply_ordering_mode">(<code>FS-URI</code>,<quote><code>apply-ordering-mode</code></quote>)</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)
		     <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause></postjudge></infer></infergr><p>If the ordering context is set to <code>unordered</code>,
        the static type of the input expression of the
        <a href="#sec_apply_ordering_mode"><emph>fs:</emph><code>apply-ordering-mode</code></a> function is computed using the
        <a href="#jd_prime" class="judgment">prime</a> and <a href="#jd_quantifier" class="judgment">quantifier</a> judgments, as for the
        <code>fn:unordered</code> function.</p><infergr><infer><prejudge><clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ordering_mode_env" class="env">orderingMode</a> = <code>unordered</code></expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><a href="#sec_apply_ordering_mode">(<code>FS-URI</code>,<quote><code>apply-ordering-mode</code></quote>)</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)
		     <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_quantifier" class="judgment">·</a>
		     <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)</expression></clause></postjudge></infer></infergr></smtype></div3><div3 id="sec_fs_to"><head>The <emph>fs:</emph><code>to</code> function</head><example role="signature"><proto name="to" return-type="xs:integer*" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" isStd="no"><arg name="firstval" type="xs:integer?"/><arg name="lastval" type="xs:integer?"/></proto></example><p>The formal semantics function <emph>fs:</emph><code>to</code> is a wrapper function
      for the <code>op:to</code> operator, taking the semantics of the range
      expression over empty sequences into account.</p><smeval><p>If one of the input parameters for <emph>fs:</emph><code>to</code> is the empty
        sequence, the function returns the empty sequence, otherwise
        it returns the result of calling the <code>op:to</code> operator. This
        semantics is equivalent to the following user-defined
        function.</p><eg xml:space="preserve">
declare function fs:to($firstval as xs:integer?, $lastval as xs:integer?) as xs:integer* {
  if (fn:empty($firstval) or fn:empty($lastval)
  then ()
  else op:to($firstval,$lastval)
};
</eg></smeval><smtype><p>The static type of <emph>fs:</emph><code>to</code> does not require any additional
        static typing rule, and is typed as a function call based on
        the above signature.</p></smtype></div3><div3 id="sec_node_sequence" diff="add" at="E021"><head><phrase>The <a href="#sec_node_sequence"><emph>fs:</emph><code>node-sequence</code></a> function</phrase></head><example role="signature"><proto name="node-sequence" return-type="node()*" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" isStd="no"><arg name="nodes" type="node()*"/></proto></example><p>
      If the input is a (possibly empty) sequence of nodes,
      <a href="#sec_node_sequence"><emph>fs:</emph><code>node-sequence</code></a> simply returns that sequence.
      Otherwise, it raises a type error.
      </p><smtype><p>
        The static type of a call to <a href="#sec_node_sequence"><emph>fs:</emph><code>node-sequence</code></a>
        is that of its argument,
        as long as that type is a subtype of <code>node()*</code>.
        </p><infergr><infer><prejudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                  <a href="#doc-fs-Type"><emph>Type</emph></a>
                  <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
                  <map>node()*</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                </expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                  <a href="#sec_node_sequence">(<code>FS-URI</code>,<quote><code>node-sequence</code></quote>)</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)
		  <a href="#jd_has_type" class="judgment"><term>:</term></a>
                  <a href="#doc-fs-Type"><emph>Type</emph></a>
                </expression></clause></postjudge></infer></infergr></smtype></div3><div3 id="sec_item_at" diff="add" at="E024"><head><phrase>The <a href="#sec_item_at"><emph>fs:</emph><code>item-at</code></a> function</phrase></head><example role="signature"><proto name="item-at" return-type="item()?" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no" isStd="no"><arg name="sourceSeq" type="item()*"/><arg name="loc" type="xs:double"/></proto></example><p>
      The <a href="#sec_item_at"><emph>fs:</emph><code>item-at</code></a> function returns the item at a specified position in a sequence.
      </p><smeval><p>
        If <code>$loc</code> is numeric-equal to
        the position of some item in <code>$sourceSeq</code>,
        that item is returned.
        (This implies that <code>$sourceSeq</code> is non-empty,
        and <code>$loc</code> is numeric-equal to an integer between 1 and <code>n</code> inclusive,
        where <code>n</code> is the number of items in <code>$sourceSeq</code>.)
        </p><p>
        Otherwise, the empty sequence is returned.
        </p><p>
        The function is roughly equivalent to the following user-defined function.
        </p><eg xml:space="preserve">
  declare function fs:item-at(
      $sourceSeq as item()*,
      $loc as xs:double) as item()?
  {
      if ($loc mod 1 eq 0) then
          fn:subsequence($sourceSeq,$loc,1)
      else
          ()
  };
</eg></smeval><smtype><p>
        The static typing rules for invocations of <a href="#sec_item_at"><emph>fs:</emph><code>item-at</code></a>
        depend on the syntactic form of the second argument.
        If it is the IntegerLiteral 1,
        then we can be relatively precise about the resulting type.
        </p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>QName</emph> <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> <a href="#sec_item_at">(<code>FS-URI</code>,<quote><code>item-at</code></quote>)</a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><expression><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) <a href="#jd_isin" class="judgment"><term>in</term></a> { 1, + }</expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>QName</emph>(<emph>Expr</emph><subscript>1</subscript>, 1) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)</expression></clause></multiclause></postjudge></infer></infergr><p>
        Otherwise, the following less precise rule is used.
        </p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>QName</emph> <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> <a href="#sec_item_at">(<code>FS-URI</code>,<quote><code>item-at</code></quote>)</a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>QName</emph>(<emph>Expr</emph><subscript>1</subscript>, <emph>Expr</emph><subscript>2</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) ?</expression></clause></multiclause></postjudge></infer></infergr><p>
        (Since invocations of <a href="#sec_item_at"><emph>fs:</emph><code>item-at</code></a>
        arise only as the result of particular normalization rules,
        <emph>Expr2</emph> in the above rule
        must be either <code>$fs:last</code>, <code>$fs:position</code>, or a NumericLiteral.
        Thus, there is no need to check its type.)
        </p></smtype></div3></div2><div2 id="function_rules"><head>Standard functions with specific static typing rules</head><smintro><p>This section gives special normalization and static typing
      rules for functions in <bibref ref="xpath-functions-30"/> for which the standard
      normalization or static typing rules are not appropriate. All
      functions that are not mentioned behave as described in Section
      <specref ref="id-function-calls"/>. When given, the static
      typing rules in this section always give more precise type
      information than the generic rule based on the function's
      signature.</p></smintro><div3 id="sec_fn_last"><head>The <code>fn:last</code> context function</head><p>As explained in <specref ref="eval_context"/>, the
      <code>fn:last()</code> context function is modeled using the
      Formal Semantics variable <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>last</code></a>. For that function the
      following static typing and dynamic evaluation rules apply.</p><smtype><infergr><infer><prejudge><multiclause><clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a>((<code>FS-URI</code>,<quote><code>last</code></quote>)) = <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                  (<code>FN-URI</code>,<quote><code>last</code></quote>)() <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
                </expression></clause></postjudge></infer></infergr></smtype><smeval><infergr><infer><prejudge><multiclause><clause><expression><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a>((<code>FS-URI</code>,<quote><code>last</code></quote>)) = <a href="#doc-fs-Value"><emph>Value</emph></a></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
                  <a href="#jd_function_with_types" class="judgment"><term>function</term></a> (<code>FN-URI</code>,<quote><code>last</code></quote>)<phrase diff="del" at="E013">()</phrase> <a href="#jd_function_with_types" class="judgment"><term>with types</term></a>
           <a href="#jd_function_with_types" class="judgment"><term>on values</term></a>
           <a href="#jd_function_with_types" class="judgment"><term>yields</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
                </expression></clause></postjudge></infer></infergr></smeval></div3><div3 id="sec_fn_position"><head>The <code>fn:position</code> context function</head><p>As explained in <specref ref="eval_context"/>, the
      <code>fn:position()</code> context function is modeled using the
      Formal Semantics variable <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>position</code></a>. For that function the
      following static typing and dynamic evaluation rules apply.</p><smtype><infergr><infer><prejudge><multiclause><clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a>((<code>FS-URI</code>,<quote><code>position</code></quote>)) = <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                  (<code>FN-URI</code>,<quote><code>position</code></quote>)() <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
                </expression></clause></postjudge></infer></infergr></smtype><smeval><infergr><infer><prejudge><multiclause><clause><expression><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a>((<code>FS-URI</code>,<quote><code>position</code></quote>)) = <a href="#doc-fs-Value"><emph>Value</emph></a></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
                  <a href="#jd_function_with_types" class="judgment"><term>function</term></a> (<code>FN-URI</code>,<quote><code>position</code></quote>)<phrase diff="del" at="E013">()</phrase> <a href="#jd_function_with_types" class="judgment"><term>with types</term></a>
           <a href="#jd_function_with_types" class="judgment"><term>on values</term></a>
           <a href="#jd_function_with_types" class="judgment"><term>yields</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
                </expression></clause></postjudge></infer></infergr></smeval></div3><div3 id="sec_fn_abs_ceil_floor_round"><head><phrase>The <code>fn:abs</code>, <code>fn:ceiling</code>, <code>fn:floor</code>,
      <code>fn:round</code>, and <code>fn:round-half-to-even</code> functions</phrase></head><smtype diff="del" at="E033"><p>The static typing rules for the <code>fn:abs</code>, <code>fn:ceiling</code>,
        <code>fn:floor</code>, <code>fn:round</code>, and <code>fn:round-half-to-even</code> functions promote
        their input type to the (least) base primitive numeric type
        from which the input type is derived. Note that the fact that
        the type should be the least is <phrase diff="chg" at="E014">not</phrase> expressed by the
        inference rule notation used here. Parameters of type
        <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> are always promoted to <code>xs:double</code>.
        <phrase diff="del" at="E014">
        Instead of writing a separate judgment for each function, we
        write one rule for the functions whose name is either
        (<code>FN-URI</code>,<quote><code>abs</code></quote>), (<code>FN-URI</code>,<quote><code>ceiling</code></quote>), (<code>FN-URI</code>,<quote><code>floor</code></quote>),
        (<code>FN-URI</code>,<quote><code>round</code></quote>), or (<code>FN-URI</code>,<quote><code>round-half-to-even</code></quote>) functions.</phrase></p><infergr><infer><prejudge><multiclause><clause><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_isin" class="judgment"><term>in</term></a> { <code>xs:integer</code>,
                  <code>xs:decimal</code>, <code>xs:float</code>, <code>xs:double</code> } </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a> ?</expression></clause></multiclause><multiclause><clause><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> = <a href="#jd_convert_untypedAtomic" class="judgment"><term>convert_untypedAtomic</term></a>(<a href="#doc-fs-Type"><emph>Type</emph></a>,  <code>xs:double</code>)</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><expression><a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> <a href="#jd_isin" class="judgment"><term>in</term></a> { <phrase diff="add" at="E014">(<code>FN-URI</code>,<quote><code>abs</code></quote>), </phrase> (<code>FN-URI</code>,<quote><code>ceiling</code></quote>), (<code>FN-URI</code>,<quote><code>floor</code></quote>),
        (<code>FN-URI</code>,<quote><code>round</code></quote>), (<code>FN-URI</code>,<quote><code>round-half-to-even</code></quote>) } </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                  <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> (<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)
 		</expression></clause></postjudge></infer></infergr></smtype><smnotation diff="add" at="E033"><p id="jd_has_base_atomic_type">
        The auxiliary judgment <a href="#jd_has_base_atomic_type" class="judgment"><term>has base atomic type</term></a>
        is used in the next subsection
        and also in <specref ref="sec_fn_aggregates"/>.
        </p><display>
   	  <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>1</subscript> <a href="#jd_has_base_atomic_type" class="judgment"><term>has base atomic type</term></a> <a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>2</subscript></expression></clause>
   	</display><p>
        To a first approximation, this judgment holds when
        <a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>1</subscript> is (or is derived from) primitive atomic type <a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>2</subscript>.
        However,
        for the purpose of typing the functions that use this judgment,
        there are three non-primitive atomic types
        that are treated similarly to primitive types:
        <code>xs:integer</code>
        (derived from <code>xs:decimal</code>),
        and
        <a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a> and <a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      
        (derived from <code>xs:duration</code>).
        </p><p>
        If <a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>1</subscript> is (or is a subtype of) any primitive atomic type
        other than <code>xs:decimal</code> or <code>xs:duration</code>,
        then that type is its base atomic type.
        </p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>2</subscript></expression></clause></multiclause><multiclause><clause><expression><a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>2</subscript> is a primitive atomic type</expression></clause></multiclause><multiclause><clause><expression><a href="#jd_not" class="judgment"><term>not</term></a>(<a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>2</subscript> <a href="#jd_isin" class="judgment"><term>in</term></a> { <code>xs:decimal</code>, <code>xs:duration</code> })</expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>1</subscript> <a href="#jd_has_base_atomic_type" class="judgment"><term>has base atomic type</term></a> <a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>2</subscript></expression></clause></multiclause></postjudge></infer></infergr><p>
        Similarly for <code>xs:integer</code>, <a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a>, and <a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      .
        </p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>2</subscript></expression></clause></multiclause><multiclause><clause><expression>
                    <a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>2</subscript> <a href="#jd_isin" class="judgment"><term>in</term></a>
                    { <code>xs:integer</code>, <a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a>, <a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>       }
                  </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>1</subscript> <a href="#jd_has_base_atomic_type" class="judgment"><term>has base atomic type</term></a> <a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>2</subscript></expression></clause></multiclause></postjudge></infer></infergr><p>
        For <code>xs:decimal</code>, we exclude <code>xs:integer</code> and its subtypes:
        </p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <code>xs:decimal</code></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_not" class="judgment"><term>not</term></a>( <a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <code>xs:integer</code> )</expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>1</subscript> <a href="#jd_has_base_atomic_type" class="judgment"><term>has base atomic type</term></a> <code>xs:decimal</code></expression></clause></multiclause></postjudge></infer></infergr><p>
        And finally, for <code>xs:duration</code>,
        we exclude <a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a> and <a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      ,
        and their subtypes.
        </p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <code>xs:duration</code></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_not" class="judgment"><term>not</term></a>( <a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a> )</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_not" class="judgment"><term>not</term></a>( <a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>       )</expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>1</subscript> <a href="#jd_has_base_atomic_type" class="judgment"><term>has base atomic type</term></a> <code>xs:duration</code></expression></clause></multiclause></postjudge></infer></infergr></smnotation><smtype diff="add" at="E033"><p>
        Note that, in the declarations for the built-in functions
        <code>fn:abs</code>,
        <code>fn:ceiling</code>,
        <code>fn:floor</code>,
        <code>fn:round</code>, and
        <code>fn:round-half-to-even</code>,
        the (first) parameter is declared with type "<code>numeric?</code>".
        Thus, for a call to one of these functions,
        the normalization rules of <specref ref="id-function-calls"/>
        will have wrapped the argument in calls to
        <code>fn:data</code>() and <a href="#sec_convert_simple_operand"><emph>fs:</emph><code>convert-simple-operand</code></a>()
        (with a 'prototypical value' of type <code>xs:double</code>).
        Thus, static analysis of the call is guaranteed that
        the argument type is a subtype of <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>*,
        with no occurrences of <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>.
        </p><p>
        In the static typing rule for these functions,
        we check that the argument type is numeric,
        extract its prime type
        (which must be a choice of atomic types),
        find the base atomic type for each,
        and then form the choice of those results.
        </p><infergr><infer><prejudge><multiclause><clause><expression>
                    <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> <a href="#jd_isin" class="judgment"><term>in</term></a> {
                      (<code>FN-URI</code>,<quote><code>abs</code></quote>),
                      (<code>FN-URI</code>,<quote><code>ceiling</code></quote>),
                      (<code>FN-URI</code>,<quote><code>floor</code></quote>),
                      (<code>FN-URI</code>,<quote><code>round</code></quote>),
                      (<code>FN-URI</code>,<quote><code>round-half-to-even</code></quote>)
                    }
                  </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <emph>fs:</emph><code>numeric</code> ?</expression></clause></multiclause><multiclause><clause><expression><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) = <a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>1</subscript> | ... | <a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>n</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>1</subscript> <a href="#jd_has_base_atomic_type" class="judgment"><term>has base atomic type</term></a> <a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>1</subscript>'</expression></clause></multiclause><multiclause><clause><expression>...</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>n</subscript> <a href="#jd_has_base_atomic_type" class="judgment"><term>has base atomic type</term></a> <a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>n</subscript>'</expression></clause></multiclause><multiclause><clause><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript> = <a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>1</subscript>' | ... | <a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>n</subscript>'</expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript> · <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)</expression></clause></multiclause></postjudge></infer></infergr><p>
        The <code>fn:round-half-to-even</code> function also has a two-parameter version.
        Its static type-checking can be reduced to that of the one-parameter
        version.
        </p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <code>xs:integer</code></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript></expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>(<code>FN-URI</code>,<quote><code>round-half-to-even</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript></expression></clause></multiclause></postjudge></infer></infergr></smtype></div3><div3 id="sec_fn_boolean"><head><phrase>The <code>fn:boolean</code><phrase diff="add" at="E027"> and <code>fn:not</code></phrase> functions</phrase></head><smtype><p>The <code>fn:boolean</code> function as described in the
        <bibref ref="xpath-functions-30"/> document takes an empty sequence, a sequence
        <phrase diff="chg" at="E026">whose first item is a node</phrase>,
        or a singleton value of type <code>xs:boolean</code>,
        <code>xs:string</code>,<phrase diff="add" at="E026"> <code>xs:anyURI</code>,</phrase> <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> or some numeric type.  All
        other values are illegal.
        <phrase diff="add" at="E026">
        The static typing of <code>fn:boolean</code> reflects these restrictions,
        but further constrains "a sequence whose first item is a node"
        to "a sequence of nodes".
        </phrase>
        </p><p diff="add" at="E027">
        The <code>fn:not</code> function has an implicit call to <code>fn:boolean</code>,
        and raises type errors for the same cases,
        so its static typing is the same as <code>fn:boolean</code>.
        </p><infergr><infer><prejudge><multiclause diff="add" at="E027"><clause><expression>
                    <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> <a href="#jd_isin" class="judgment"><term>in</term></a> { (<code>FN-URI</code>,<quote><code>boolean</code></quote>), (<code>FN-URI</code>,<quote><code>not</code></quote>) }
                  </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> (empty |
                <phrase diff="chg" at="E026"><map>node()+</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a></phrase>
                | <code>xs:boolean</code> | <code>xs:string</code> |
                <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> | <emph>fs:</emph><code>numeric</code> | <code>xs:anyURI</code>)</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><phrase diff="chg" at="E027"><a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></phrase>(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:boolean</code></expression></clause></postjudge></infer></infergr></smtype></div3><div3 id="sec_fn_doc_collection"><head><phrase>The <code>fn:collection</code> and <code>fn:doc</code> functions</phrase></head><smintro><p>The static typing rules for <code>fn:collection</code> and <code>fn:doc</code>
        depend on the syntactic form of their input expression. As a
        result, the corresponding static typing rules must be written
        directly over the input expression, unlike the other functions
        in this section.</p></smintro><smtype><p>The <code>fn:collection</code> function as described in the
        <bibref ref="xpath-functions-30"/> document, takes a string-valued expression,
        which denotes a URI, and returns a value.</p><p>If the <code>fn:collection</code> function has no parameter, the
        result type is given by the implementation for the default
        sequence if it exists.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>QName</emph>
                  <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> (<code>FN-URI</code>,<quote><code>collection</code></quote>)</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>Implementation-defined default sequence
                has type <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><emph>QName</emph>() <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause></postjudge></infer></infergr><p>If the argument to <code>fn:collection</code> is a <emph>URILiteral</emph>
        expression which is defined in <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_collection_type_env" class="env">collectionType</a>, then
        the result type is the type corresponding to the
        <emph>URILiteral</emph> in <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_collection_type_env" class="env">collectionType</a>. </p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>QName</emph>
                  <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> (<code>FN-URI</code>,<quote><code>collection</code></quote>)</expression></clause></multiclause><multiclause><clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_collection_type_env" class="env">collectionType</a>(<emph>URILiteral</emph>) = <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><emph>QName</emph>(<emph>URILiteral</emph>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause></postjudge></infer></infergr><p>Otherwise, if the argument is a URI literal but is not
        defined in <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_collection_type_env" class="env">collectionType</a>, or if it is not a URI
        literal, then we don't know anything about the URI and the
        static type is a collection of nodes.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>QName</emph>
                  <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> (<code>FN-URI</code>,<quote><code>collection</code></quote>)</expression></clause></multiclause><multiclause><clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_collection_type_env" class="env">collectionType</a>(<emph>URILiteral</emph>) undefined</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><emph>QName</emph>(<emph>URILiteral</emph>) <a href="#jd_has_type" class="judgment"><term>:</term></a>
                (element<phrase diff="add" at="E023"> *</phrase> | attribute<phrase diff="add" at="E023"> *</phrase> | processing-instruction<phrase diff="add" at="E022"> *</phrase> | text |
                comment | document ) *</expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>QName</emph>
                  <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> (<code>FN-URI</code>,<quote><code>collection</code></quote>)</expression></clause></multiclause><multiclause><clause><expression><emph>Expr</emph> is not a <emph>URILiteral</emph></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><emph>QName</emph>(<emph>Expr</emph>) <a href="#jd_has_type" class="judgment"><term>:</term></a> (element<phrase diff="add" at="E023"> *</phrase> | attribute<phrase diff="add" at="E023"> *</phrase> | processing-instruction<phrase diff="add" at="E022"> *</phrase> | text |
                comment | document ) *</expression></clause></postjudge></infer></infergr><p>The <code>fn:doc</code> function has similar static typing rules, but,
        in addition, the static type must be a document node.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>QName</emph>
                  <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> (<code>FN-URI</code>,<quote><code>doc</code></quote>)</expression></clause></multiclause><multiclause><clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_doc_type_env" class="env">docType</a>(<emph>URILiteral</emph>) = <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> document </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><emph>QName</emph>(<emph>URILiteral</emph>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause></postjudge></infer></infergr><p>Otherwise, if the argument is a URI literal not defined in
        the domain of <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_doc_type_env" class="env">docType</a> or if it is not a URI literal,
        then we don't know anything about the URI, and the static type
        is document.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>QName</emph>
                  <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> (<code>FN-URI</code>,<quote><code>doc</code></quote>)</expression></clause></multiclause><multiclause><clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_doc_type_env" class="env">docType</a>(<emph>URILiteral</emph>) undefined</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><emph>QName</emph>(<emph>URILiteral</emph>) <a href="#jd_has_type" class="judgment"><term>:</term></a> document?</expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>QName</emph>
                  <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> (<code>FN-URI</code>,<quote><code>doc</code></quote>)</expression></clause></multiclause><multiclause><clause><expression><emph>Expr</emph> is not a <emph>URILiteral</emph></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><emph>QName</emph>(<emph>Expr</emph>) <a href="#jd_has_type" class="judgment"><term>:</term></a> document?</expression></clause></postjudge></infer></infergr></smtype></div3><div3 id="sec_fn_data"><head>The <code>fn:data</code> function</head><smintro><p>The <code>fn:data</code> function converts a sequence of items to a
        sequence of atomic values.</p></smintro><smnotation><p id="jd_data">Inferring the type for the <code>fn:data</code> function
        is done by applying the <a href="#jd_data" class="judgment"><term>data on</term></a> auxiliary judgment, using
        the same approach as for the XPath steps.</p><display>
   	  <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_data" class="judgment"><term>data on</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression></clause>
   	</display></smnotation><smtype><p>The general rule for <code>fn:data</code> is to apply the filter
        <a href="#jd_data" class="judgment"><term>data on</term></a> to the prime type of its argument type, then
        apply the quantifier to the result:</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                    <a href="#jd_data" class="judgment"><term>data on</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
                  </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                  (<code>FN-URI</code>,<quote><code>data</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_has_type" class="judgment"><term>:</term></a>
                  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)
 		</expression></clause></postjudge></infer></infergr><p>When applied to none, <a href="#jd_data" class="judgment"><term>data on</term></a> yields none.</p><infergr><infer><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                  <a href="#jd_data" class="judgment"><term>data on</term></a> <code>none</code> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>none</code>
 		</expression></clause></postjudge></infer></infergr><p>When applied to empty, <a href="#jd_data" class="judgment"><term>data on</term></a> yields empty.</p><infergr><infer><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                  <a href="#jd_data" class="judgment"><term>data on</term></a> <code>empty</code> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>empty</code>
 		</expression></clause></postjudge></infer></infergr><p>When applied to the union of two types, <a href="#jd_data" class="judgment"><term>data on</term></a> is
        applied to each of the two types. The resulting type is
        computed using <a href="#jd_prime" class="judgment">prime</a> and <a href="#jd_quantifier" class="judgment">quantifier</a>, which are
        defined in <specref ref="sec_factor"/>.  This rule is
        necessary because <a href="#jd_data" class="judgment"><term>data on</term></a> may return a sequence of atomic
        types.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_data" class="judgment"><term>data on</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>'</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_data" class="judgment"><term>data on</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>'</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                  <a href="#jd_data" class="judgment"><term>data on</term></a> (<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>|<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a>
                  <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>'|<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>')
                  <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>'|<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>')
 		</expression></clause></postjudge></infer></infergr><p>When applied to an atomic type, <a href="#jd_data" class="judgment"><term>data on</term></a> simply
        returns the atomic type:</p><infergr><infer><prejudge><multiclause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                  <a href="#jd_data" class="judgment"><term>data on</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
 		</expression></clause></postjudge></infer></infergr><p>When applied to comment or processing instruction node types, <a href="#jd_data" class="judgment"><term>data on</term></a> returns
        <code>xs:string</code></p><infergr><infer><prejudge><multiclause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
                    <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> comment | processing-instruction<phrase diff="add" at="E022"> *</phrase>
                  </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                  <a href="#jd_data" class="judgment"><term>data on</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:string</code>
 		</expression></clause></postjudge></infer></infergr><p>When applied to text or document node types, <a href="#jd_data" class="judgment"><term>data on</term></a>
        returns <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a></p><infergr><infer><prejudge><multiclause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
                    <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> text | document
                  </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                  <a href="#jd_data" class="judgment"><term>data on</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>
 		</expression></clause></postjudge></infer></infergr><p>When applied to element node types with <xtermref spec="XQ" ref="dt-type-annotation"/> <a href="#dt-xs_untyped"><code>xs:untyped</code></a>, the <a href="#jd_data" class="judgment"><term>data on</term></a> filter
        returns <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>.</p><!--
      	<infergr>
 	  <infer>
 	    <prejudge>
              <multiclause>
  	        <clause><environment>&xq_stat_env;</environment>
                  <expression>
                    &gr_AttributeType; &jd_static_lookup; of type &xs_untypedAtomic;
                  </expression>
 	        </clause>
              </multiclause>
 	    </prejudge>
 	    <postjudge>
 	      <clause><environment>&xq_stat_env;</environment>
 		<expression>
                  &jd_data; &gr_AttributeType; &jd_has_type; &xs_untypedAtomic;
 		</expression>
 	      </clause>
 	    </postjudge>
 	  </infer>
      	</infergr>
--><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                    <a href="#doc-fs-ElementType"><emph>ElementType</emph></a> <a href="#jd_static_lookup" class="judgment"><term>type lookup</term></a> of type <a href="#dt-xs_untyped"><code>xs:untyped</code></a>
                  </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                  <a href="#jd_data" class="judgment"><term>data on</term></a> <a href="#doc-fs-ElementType"><emph>ElementType</emph></a> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>
 		</expression></clause></postjudge></infer></infergr><p>When applied to an attribute node type, the <a href="#jd_data" class="judgment"><term>data on</term></a> filter returns the
        attribute's simple type.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                    <a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a> <a href="#jd_static_lookup" class="judgment"><term>type lookup</term></a> of type <a href="#doc-fs-TypeName"><emph>TypeName</emph></a>
                  </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                    of type <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> <a href="#jd_expands_to" class="judgment"><term>expands to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
                  </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                  <a href="#jd_data" class="judgment"><term>data on</term></a> <a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
 		</expression></clause></postjudge></infer></infergr><p>When applied to an element type whose <xtermref spec="XQ" ref="dt-type-annotation"/> denotes a simple type or a complex
        type of simple content, <a href="#jd_data" class="judgment"><term>data on</term></a> returns the element's simple
        type.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                    <a href="#doc-fs-ElementType"><emph>ElementType</emph></a> <a href="#jd_static_lookup" class="judgment"><term>type lookup</term></a> <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a>
                  </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                     <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a> <a href="#jd_expands_to" class="judgment"><term>expands to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
                  </expression></clause></multiclause><multiclause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
                     <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> (attribute<phrase diff="add" at="E023">*</phrase>*, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)
                  </expression></clause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
                     <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>*
                  </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                  <a href="#jd_data" class="judgment"><term>data on</term></a> <a href="#doc-fs-ElementType"><emph>ElementType</emph></a> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
 		</expression></clause></postjudge></infer></infergr><p>When applied to an element type whose <xtermref spec="XQ" ref="dt-type-annotation"/> denotes a complex type of mixed
        content, the <a href="#jd_data" class="judgment"><term>data on</term></a> filter returns <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                    <a href="#doc-fs-ElementType"><emph>ElementType</emph></a> <a href="#jd_static_lookup" class="judgment"><term>type lookup</term></a> of type <a href="#doc-fs-TypeName"><emph>TypeName</emph></a>
                  </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           </expression></clause><clause><expression>
                    <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>) =
                    define type <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> <a href="#doc-fs-Derivation"><emph>Derivation</emph></a> mixed { <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> }
                  </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                  <a href="#jd_data" class="judgment"><term>data on</term></a> <a href="#doc-fs-ElementType"><emph>ElementType</emph></a> <a href="#jd_has_type" class="judgment"><term>:</term></a> xs:untypedAtomic
 		</expression></clause></postjudge></infer></infergr><p>The <a href="#jd_data" class="judgment"><term>data on</term></a> filter is not defined on any element type
        whose <xtermref spec="XQ" ref="dt-type-annotation"/> denotes a
        complex type of complex content and therefore applying
        <a href="#jd_data" class="judgment"><term>data on</term></a> to such a node raises a static error.</p></smtype><smexample><p>Consider the following variable and its corresponding
        static type.</p><eg xml:space="preserve">
    $x : (element price { attribute currency { xs:string }, xs:decimal }
         | element price_code { xs:integer })
</eg><p>Applying the <code>fn:data</code> function on that variable results in
        the following type.</p><eg xml:space="preserve">
    fn:data($x) : (xs:decimal | xs:integer)
</eg><p>Because the input type is a choice, applying the
        <a href="#jd_data" class="judgment"><term>data on</term></a> filter results in a choice of simple types for the
        output of the <code>fn:data</code> function.</p></smexample></div3><div3 id="sec_fn_distinct_node_vals"><head><phrase>The <code>fn:distinct-values</code> function</phrase></head><smtype><p>The <code>fn:distinct-values</code> function expects a sequence of atomic
        values as input and returns a sequence of prime types, which
        are defined in <specref ref="sec_factor"/>.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>*</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>(<code>FN-URI</code>,<quote><code>distinct-values</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)</expression></clause></postjudge></infer></infergr></smtype></div3><div3 id="sec_fn_unordered"><head><phrase>The <code>fn:unordered</code> function</phrase></head><smtype><p>The static semantics for <code>fn:unordered</code> is computed using
        <a href="#jd_prime" class="judgment">prime</a> and <a href="#jd_quantifier" class="judgment">quantifier</a>, which are defined in <specref ref="sec_factor"/>. The type of the argument is determined,
        and then <a href="#jd_prime" class="judgment">prime</a>(.) and <a href="#jd_quantifier" class="judgment">quantifier</a>(.)  are applied to
        that type.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>(<code>FN-URI</code>,<quote><code>unordered</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)
			 <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) <a href="#jd_quantifier" class="judgment">·</a>
			 <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)</expression></clause></postjudge></infer></infergr></smtype></div3><div3 id="sec_fnerror"><head><phrase>The <code>fn:error</code> function</phrase></head><smtype><p>The fn:error function always has the <code>none</code> type.</p><infergr><infer><prejudge/><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>(<code>FN-URI</code>,<quote><code>error</code></quote>)() <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>none</code></expression></clause></multiclause></postjudge></infer></infergr><infergr><infer><prejudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <code>xs:QName</code></expression></clause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>(<code>FN-URI</code>,<quote><code>error</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>none</code></expression></clause></multiclause></postjudge></infer></infergr><infergr><infer><prejudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <code>xs:QName</code>?</expression></clause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <code>xs:string</code></expression></clause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>(<code>FN-URI</code>,<quote><code>error</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>none</code></expression></clause></multiclause></postjudge></infer></infergr><infergr><infer><prejudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <code>xs:QName</code>?</expression></clause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <code>xs:string</code></expression></clause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>(<code>FN-URI</code>,<quote><code>error</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>none</code></expression></clause></multiclause></postjudge></infer></infergr></smtype></div3><div3 id="sec_fn_aggregates"><head><phrase>The <code>fn:min</code>, <code>fn:max</code>, <code>fn:avg</code>, and <code>fn:sum</code>
      functions</phrase></head><smintro><p>The semantics of aggregate functions convert any item of
       type <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> in the input sequence to <code>xs:double</code>,
       then attempt to promote all values in the input sequence to
       values that are comparable.  The static typing rules reflect
       the dynamic evaluation rules.</p><p>The <code>fn:sum</code> function has two forms.  The first form takes
      two arguments: The first argument is the input sequence and the
      second argument is the value that should be returned if the
      input sequence is empty. In case there is no second argument,
      the value returned for an empty sequence is the <code>xs:integer</code>
      value 0. The following static typing rule applies in the case
      there is no second argument.</p></smintro><smtype><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                  (<code>FN-URI</code>,<quote><code>sum</code></quote>)(
                  <phrase diff="del" at="E033"><emph>Expr</emph>,0</phrase>
                  <phrase diff="add" at="E033"><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <code>xs:integer</code></phrase>
                  ) <a href="#jd_has_type" class="judgment"><term>:</term></a>
                  <phrase diff="del" at="E033"><a href="#doc-fs-Type"><emph>Type</emph></a></phrase>
                  <phrase diff="add" at="E033"><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></phrase>
                </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                  (<code>FN-URI</code>,<quote><code>sum</code></quote>)(
                  <phrase diff="del" at="E033"><emph>Expr</emph></phrase>
                  <phrase diff="add" at="E033"><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></phrase>
                  ) <a href="#jd_has_type" class="judgment"><term>:</term></a>
                  <phrase diff="del" at="E033"><a href="#doc-fs-Type"><emph>Type</emph></a></phrase>
                  <phrase diff="add" at="E033"><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></phrase>
                </expression></clause></postjudge></infer></infergr></smtype><smnotation><p id="jd_convert_untypedAtomic">The type function
       <a href="#jd_convert_untypedAtomic" class="judgment"><term>convert_untypedAtomic</term></a> takes a prime type and converts all
       occurrences of the type <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> to a target type.
       It is defined recursively as follows.</p><table summary="" role="figure"><col align="left" span="1"/><col align="left" span="1"/><col align="center" span="1"/><col align="left" span="1"/><col align="left" span="1"/><tbody><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"><a href="#jd_convert_untypedAtomic" class="judgment"><term>convert_untypedAtomic</term></a>(<a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>, <a href="#doc-fs-Type"><emph>Type</emph></a>)</td><td rowspan="1" colspan="1">  =  </td><td rowspan="1" colspan="1"><a href="#doc-fs-Type"><emph>Type</emph></a></td></tr><tr><td rowspan="1" colspan="1">if not(<a href="#doc-fs-FormalItemType"><emph>FormalItemType</emph></a> = <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>)</td><td rowspan="1" colspan="1"><a href="#jd_convert_untypedAtomic" class="judgment"><term>convert_untypedAtomic</term></a>(<a href="#doc-fs-FormalItemType"><emph>FormalItemType</emph></a>, <a href="#doc-fs-Type"><emph>Type</emph></a>)</td><td rowspan="1" colspan="1">  =  </td><td rowspan="1" colspan="1"><a href="#doc-fs-FormalItemType"><emph>FormalItemType</emph></a></td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"><a href="#jd_convert_untypedAtomic" class="judgment"><term>convert_untypedAtomic</term></a>(<code>empty</code>, <a href="#doc-fs-Type"><emph>Type</emph></a>)</td><td rowspan="1" colspan="1">  =  </td><td rowspan="1" colspan="1"><code>empty</code></td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"><a href="#jd_convert_untypedAtomic" class="judgment"><term>convert_untypedAtomic</term></a>(<code>none</code>, <a href="#doc-fs-Type"><emph>Type</emph></a>)</td><td rowspan="1" colspan="1">  =  </td><td rowspan="1" colspan="1"><code>none</code></td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"><a href="#jd_convert_untypedAtomic" class="judgment"><term>convert_untypedAtomic</term></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> | <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a>)</td><td rowspan="1" colspan="1">  =  </td><td rowspan="1" colspan="1"><a href="#jd_convert_untypedAtomic" class="judgment"><term>convert_untypedAtomic</term></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a>) | <a href="#jd_convert_untypedAtomic" class="judgment"><term>convert_untypedAtomic</term></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a>)</td></tr></tbody></table></smnotation><smnotation><p id="jd_agg_quantifier">The function <a href="#jd_agg_quantifier" class="judgment"><term>aggregate_quantifier</term></a>
       converts the input type quantifier zero-or-more or zero-or-one
       to the result type quantifier zero-or-one, and converts the
       input type quantifier one or one-or-more, to the result type
       quantifier one.</p><table summary="" role="figure"><col align="left" span="1"/><col align="center" span="1"/><col align="left" span="1"/><tbody><tr><td rowspan="1" colspan="1"><a href="#jd_agg_quantifier" class="judgment"><term>aggregate_quantifier</term></a>(<code>?</code>)</td><td rowspan="1" colspan="1">  =  </td><td rowspan="1" colspan="1"><code>?</code></td></tr><tr><td rowspan="1" colspan="1"><a href="#jd_agg_quantifier" class="judgment"><term>aggregate_quantifier</term></a>(<code>*</code>)</td><td rowspan="1" colspan="1">  =  </td><td rowspan="1" colspan="1"><code>?</code></td></tr><tr><td rowspan="1" colspan="1"><a href="#jd_agg_quantifier" class="judgment"><term>aggregate_quantifier</term></a>(<code>1</code>)</td><td rowspan="1" colspan="1">  =  </td><td rowspan="1" colspan="1"><code>1</code></td></tr><tr><td rowspan="1" colspan="1"><a href="#jd_agg_quantifier" class="judgment"><term>aggregate_quantifier</term></a>(<code>+</code>)</td><td rowspan="1" colspan="1">  =  </td><td rowspan="1" colspan="1"><code>1</code></td></tr></tbody></table></smnotation><smtype diff="del" at="E033"><p>Now we can define the static typing rules for the aggregate
       functions.  First, the input type is converted to a prime type.
       Second, the type function <a href="#jd_convert_untypedAtomic" class="judgment"><term>convert_untypedAtomic</term></a> is applied
       to the prime type, yielding a new prime type, in which
       occurrences of <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> are converted to
       <code>xs:double</code>.  Third, the judgment <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> is
       applied to the new prime type and target type. The result type
       is combined with the aggregate quantifier of the input
       type.</p><p>For a given aggregate function, instead of writing a
       separate judgment for each target type, we write one rule using
       a target type <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>.</p><p>For <code>fn:min</code> and <code>fn:max</code>, the target type <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> is
       either <code>xs:string</code>, <code>xs:integer</code>, <code>xs:decimal</code>, <code>xs:float</code>,
       <code>xs:double</code>, <code>xs:date</code>, <code>xs:time</code>, <code>xs:dateTime</code>,
       <a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a>, or <a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      .</p><infergr><infer><prejudge><multiclause><clause><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> = <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)</expression></clause></multiclause><multiclause><clause><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> =
           <a href="#jd_convert_untypedAtomic" class="judgment"><term>convert_untypedAtomic</term></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <code>xs:double</code>)</expression></clause></multiclause><multiclause><clause><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> = empty</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
              (<code>FN-URI</code>,<quote><code>min</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_has_type" class="judgment"><term>:</term></a> empty
      	     </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> = <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)</expression></clause></multiclause><multiclause><clause><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> =
           <a href="#jd_convert_untypedAtomic" class="judgment"><term>convert_untypedAtomic</term></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <code>xs:double</code>)</expression></clause></multiclause><multiclause><clause><expression><a href="#doc-fs-FormalItemType"><emph>FormalItemType</emph></a><subscript>1</subscript>, ...,<a href="#doc-fs-FormalItemType"><emph>FormalItemType</emph></a><subscript>n</subscript> = <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-FormalItemType"><emph>FormalItemType</emph></a><subscript>1</subscript> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript></expression></clause></multiclause><multiclause><clause><expression>...</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-FormalItemType"><emph>FormalItemType</emph></a><subscript>n</subscript> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript></expression></clause></multiclause><multiclause><clause><expression>
          <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>
          <a href="#jd_isin" class="judgment"><term>in</term></a>
          { <code>xs:string</code>, <code>xs:integer</code>, <code>xs:decimal</code>, <code>xs:float</code>,
       <code>xs:double</code>, <code>xs:date</code>, <code>xs:time</code>, <code>xs:dateTime</code>,
       <a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a>, <a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>       }
         </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
              (<code>FN-URI</code>,<quote><code>min</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_agg_quantifier" class="judgment"><term>aggregate_quantifier</term></a>(<a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>))
      	     </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> = <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)</expression></clause></multiclause><multiclause><clause><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> =
           <a href="#jd_convert_untypedAtomic" class="judgment"><term>convert_untypedAtomic</term></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <code>xs:double</code>)</expression></clause></multiclause><multiclause><clause><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> = empty</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
              (<code>FN-URI</code>,<quote><code>max</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_has_type" class="judgment"><term>:</term></a> empty
      	     </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> = <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)</expression></clause></multiclause><multiclause><clause><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> =
           <a href="#jd_convert_untypedAtomic" class="judgment"><term>convert_untypedAtomic</term></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <code>xs:double</code>)</expression></clause></multiclause><multiclause><clause><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> = <a href="#doc-fs-FormalItemType"><emph>FormalItemType</emph></a><subscript>1</subscript>, ...,<a href="#doc-fs-FormalItemType"><emph>FormalItemType</emph></a><subscript>n</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-FormalItemType"><emph>FormalItemType</emph></a><subscript>1</subscript> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript></expression></clause></multiclause><multiclause><clause><expression>...</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-FormalItemType"><emph>FormalItemType</emph></a><subscript>n</subscript> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript></expression></clause></multiclause><multiclause><clause><expression>
          <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>
          <a href="#jd_isin" class="judgment"><term>in</term></a>
          { <code>xs:string</code>, <code>xs:integer</code>, <code>xs:decimal</code>, <code>xs:float</code>,
       <code>xs:double</code>, <code>xs:date</code>, <code>xs:time</code>, <code>xs:dateTime</code>,
       <a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a>, <a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>       }
         </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
              (<code>FN-URI</code>,<quote><code>max</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_agg_quantifier" class="judgment"><term>aggregate_quantifier</term></a>(<a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>))
      	     </expression></clause></postjudge></infer></infergr><p>For <code>fn:avg</code>, the target type <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> is either
      <code>xs:decimal</code>, <code>xs:float</code>, <code>xs:double</code>, <a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a>,
      or <a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      .</p><infergr><infer><prejudge><multiclause><clause><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> = <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)</expression></clause></multiclause><multiclause><clause><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> =
           <a href="#jd_convert_untypedAtomic" class="judgment"><term>convert_untypedAtomic</term></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <code>xs:double</code>)</expression></clause></multiclause><multiclause><clause><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> = empty</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
              (<code>FN-URI</code>,<quote><code>avg</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_has_type" class="judgment"><term>:</term></a> empty
      	     </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> = <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)</expression></clause></multiclause><multiclause><clause><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> =
           <a href="#jd_convert_untypedAtomic" class="judgment"><term>convert_untypedAtomic</term></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <code>xs:double</code>)</expression></clause></multiclause><multiclause><clause><expression><a href="#doc-fs-FormalItemType"><emph>FormalItemType</emph></a><subscript>1</subscript>, ...,<a href="#doc-fs-FormalItemType"><emph>FormalItemType</emph></a><subscript>n</subscript> = <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-FormalItemType"><emph>FormalItemType</emph></a><subscript>1</subscript> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript></expression></clause></multiclause><multiclause><clause><expression>...</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-FormalItemType"><emph>FormalItemType</emph></a><subscript>n</subscript> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript></expression></clause></multiclause><multiclause><clause><expression>
          <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>
          <a href="#jd_isin" class="judgment"><term>in</term></a>
          { <code>xs:decimal</code>, <code>xs:float</code>, <code>xs:double</code>, <a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a>,
      <a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>       }
         </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
              (<code>FN-URI</code>,<quote><code>avg</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_agg_quantifier" class="judgment"><term>aggregate_quantifier</term></a>(<a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>))
      	     </expression></clause></postjudge></infer></infergr><p>For <code>fn:sum</code>, the target type <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> is either
      <code>xs:integer</code>, <code>xs:decimal</code>, <code>xs:float</code>, <code>xs:double</code>,
      <a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a>, or <a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      . The second
      argument in <code>fn:sum</code> is the value that should be returned if the
      input sequence is empty. The result type is the union of the
      target type and the type of the second argument. Note that the
      rule checks that the type for the zero value is consistent with
      the type of the input sequence.</p><infergr><infer><prejudge><multiclause><clause><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> = <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)</expression></clause></multiclause><multiclause><clause><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> =
           <a href="#jd_convert_untypedAtomic" class="judgment"><term>convert_untypedAtomic</term></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <code>xs:double</code>)</expression></clause></multiclause><multiclause><clause><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> = empty</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
              (<code>FN-URI</code>,<quote><code>sum</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:integer</code>
      	     </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a> ?</expression></clause></multiclause><multiclause><clause><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript> = <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)</expression></clause></multiclause><multiclause><clause><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>4</subscript> =
           <a href="#jd_convert_untypedAtomic" class="judgment"><term>convert_untypedAtomic</term></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript>, <code>xs:double</code>)</expression></clause></multiclause><multiclause><clause><expression><a href="#doc-fs-FormalItemType"><emph>FormalItemType</emph></a><subscript>1</subscript>, ...,<a href="#doc-fs-FormalItemType"><emph>FormalItemType</emph></a><subscript>n</subscript> = <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>4</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-FormalItemType"><emph>FormalItemType</emph></a><subscript>1</subscript> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript></expression></clause></multiclause><multiclause><clause><expression>...</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-FormalItemType"><emph>FormalItemType</emph></a><subscript>n</subscript> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript></expression></clause></multiclause><multiclause><clause><expression>
          <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>
          <a href="#jd_isin" class="judgment"><term>in</term></a>
          { <code>xs:integer</code>, <code>xs:decimal</code>, <code>xs:float</code>, <code>xs:double</code>, <a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a> }
         </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
              (<code>FN-URI</code>,<quote><code>sum</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>
              <a href="#jd_quantifier" class="judgment">·</a>
              <a href="#jd_agg_quantifier" class="judgment"><term>aggregate_quantifier</term></a>(<a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>))
      	     </expression></clause></postjudge></infer></infergr></smtype><smtype diff="add" at="E033"><p>
        Now we can define the static typing rules for the aggregate functions.
        Note that the normalization rules of <specref ref="id-function-calls"/>
        will have wrapped each argument
        in calls to <code>fn:data</code>() and <a href="#sec_convert_simple_operand"><emph>fs:</emph><code>convert-simple-operand</code></a>()
        (with a 'prototypical value' of type <code>xs:double</code>).
        Thus, static analysis of the call to an aggregate function
        is guaranteed that any argument type is a subtype of <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>*,
        with no occurrences of <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>.
        </p><p>
        First, we can quickly deal with <code>fn:avg</code>.
        For the purposes of static type analysis,
            <code>fn:avg($arg)</code>
        is equivalent to
            <code>fs:div( fn:sum($arg,()), fn:count($arg) )</code>
        Thus, we have the rule:
        </p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>(<code>FN-URI</code>,<quote><code>sum</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, empty) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>(<code>FS-URI</code>,<quote><code>div</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>, <code>xs:integer</code>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript></expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>(<code>FN-URI</code>,<quote><code>avg</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript></expression></clause></multiclause></postjudge></infer></infergr><p>
        For the remaining aggregate functions
        (<code>fn:min</code>, <code>fn:max</code>, and <code>fn:sum</code>),
        the general approach is as follows.
        First, we check that the input type(s) are acceptable for the function.
        Then we construct the (first) argument's prime type,
        a union of AtomicTypeNames.
        For each of the latter,
        we find the 'base atomic type'.
        The union of these base atomic types
        is the basis for the result type,
        which may finally be adjusted
        for cardinality (<code>fn:min</code> and <code>fn:max</code>)
        or for the effect of the second argument (<code>fn:sum</code>).
        In addition, we provide a rule for the special case
        when the (first) argument has type 'empty'.
        </p><p>
        For <code>fn:min</code> and <code>fn:max</code>,
        the permitted input types
        are all those for which ge(T,T) and le(T,T) are defined.
        An empty input sequence yields an empty result.
        </p><infergr><infer><prejudge><multiclause><clause><expression><a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> <a href="#jd_isin" class="judgment"><term>in</term></a> { (<code>FN-URI</code>,<quote><code>min</code></quote>), (<code>FN-URI</code>,<quote><code>max</code></quote>) }</expression></clause></multiclause><multiclause><clause><expression><a href="#doc-fs-Type"><emph>Type</emph></a> = empty</expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_has_type" class="judgment"><term>:</term></a> empty</expression></clause></multiclause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><expression><a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> <a href="#jd_isin" class="judgment"><term>in</term></a> { (<code>FN-URI</code>,<quote><code>min</code></quote>), (<code>FN-URI</code>,<quote><code>max</code></quote>) }</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript>*</expression></clause></multiclause><multiclause><clause><expression>
                    <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript> <a href="#jd_isin" class="judgment"><term>in</term></a> {
                      <emph>fs:</emph><code>numeric</code>,
                      <code>xs:anyURI</code>|<code>xs:string</code>,
                      <a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a>, <a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      ,
                      <code>xs:date</code>, <code>xs:time</code>, <code>xs:dateTime</code>, <code>xs:boolean</code>
                    }
                  </expression></clause></multiclause><multiclause><clause><expression><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) = <a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>1</subscript> | ... | <a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>n</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>1</subscript> <a href="#jd_has_base_atomic_type" class="judgment"><term>has base atomic type</term></a> <a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>1</subscript>'</expression></clause></multiclause><multiclause><clause><expression>...</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>n</subscript> <a href="#jd_has_base_atomic_type" class="judgment"><term>has base atomic type</term></a> <a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>n</subscript>'</expression></clause></multiclause><multiclause><clause><expression><a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>1</subscript>' | ...  | <a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>n</subscript>' = <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>4</subscript></expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                    <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)
                    <a href="#jd_has_type" class="judgment"><term>:</term></a>
                    <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>4</subscript> · <a href="#jd_agg_quantifier" class="judgment"><term>aggregate_quantifier</term></a>(<a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>))
                  </expression></clause></multiclause></postjudge></infer></infergr><p>
        For <code>fn:sum</code>,
        the permitted input types for the first argument
        are all those for which plus(T,T) is defined.
        If you pass an empty sequence as the first argument,
        the function returns the value of the second argument.
        </p><infergr><infer><prejudge><multiclause><clause><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> = empty</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>?</expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>(<code>FN-URI</code>,<quote><code>sum</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression></clause></multiclause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript>*</expression></clause></multiclause><multiclause><clause><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript> <a href="#jd_isin" class="judgment"><term>in</term></a> {<emph>fs:</emph><code>numeric</code>, <a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a>, <a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      }</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>?</expression></clause></multiclause><multiclause><clause><expression><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) = <a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>1</subscript> | ... | <a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>n</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>1</subscript> <a href="#jd_has_base_atomic_type" class="judgment"><term>has base atomic type</term></a> <a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>1</subscript>'</expression></clause></multiclause><multiclause><clause><expression>...</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>n</subscript> <a href="#jd_has_base_atomic_type" class="judgment"><term>has base atomic type</term></a> <a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>n</subscript>'</expression></clause></multiclause><multiclause><clause><expression><a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>1</subscript>' | ...  | <a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>n</subscript>' = <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>4</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_sacfsw" class="judgment"><term>second argument contribution for sum with</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_sacfsw" class="judgment"><term>and</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_sacfsw" class="judgment"><term>is</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>'</expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>(<code>FN-URI</code>,<quote><code>sum</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>4</subscript> | <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>'</expression></clause></multiclause></postjudge></infer></infergr><p id="jd_sacfsw">
        The second argument's contribution (if any) to the above result type
        is determined as follows.  If the first argument could be the empty
        sequence, we add the type of the second argument to the result type.
        Otherwise, the type of the second argument is ignored.
        </p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>empty <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_sacfsw" class="judgment"><term>second argument contribution for sum with</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_sacfsw" class="judgment"><term>and</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_sacfsw" class="judgment"><term>is</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression></clause></multiclause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_not" class="judgment"><term>not</term></a> (empty <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)</expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_sacfsw" class="judgment"><term>second argument contribution for sum with</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_sacfsw" class="judgment"><term>and</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_sacfsw" class="judgment"><term>is</term></a> none</expression></clause></multiclause></postjudge></infer></infergr></smtype></div3><div3 id="sec_fn_remove"><head><phrase>The <code>fn:remove</code> function</phrase></head><smtype><p>The static type for the <code>fn:remove</code> function is computed
        using <a href="#jd_prime" class="judgment">prime</a> and <a href="#jd_quantifier" class="judgment">quantifier</a>, which are defined in
        <specref ref="sec_factor"/>. Since one item may be removed
        from the sequence, the resulting type is made optional.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <code>xs:integer</code></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                  (<code>FN-URI</code>,<quote><code>remove</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a>
                  <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_quantifier" class="judgment">·</a>
                  <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_quantifier" class="judgment">·</a> ?
 		</expression></clause></postjudge></infer></infergr></smtype></div3><div3 id="sec_fn_reverse"><head><phrase>The <code>fn:reverse</code> function</phrase></head><smtype><p>The static type for the <code>fn:reverse</code> function is computed
        using <a href="#jd_prime" class="judgment">prime</a> and <a href="#jd_quantifier" class="judgment">quantifier</a>, which are defined in
        <specref ref="sec_factor"/>.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                  (<code>FN-URI</code>,<quote><code>reverse</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)
 		</expression></clause></postjudge></infer></infergr></smtype></div3><div3 id="sec_fn_subsequence"><head><phrase>The <code>fn:subsequence</code> function</phrase></head><smintro diff="del" at="E024"><p>The <code>fn:subsequence</code> function has special static typing
        rules when its second argument is the numeric literal value 1
        or the built-in variable <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>last</code></a>.  These rules provide
        better typing for path expressions such as <emph>Expr</emph>[1] and
        <emph>Expr</emph>[<code>fn:last</code>()].</p><p>The static typing rules for <code>fn:subsequence</code> depends on the
        syntactic form of their input expression. As a result, the
        corresponding static typing rules must be written directly
        over the input expression, unlike the other functions in this
        section.</p></smintro><smtype><p diff="del" at="E024">If the type of the input expression has exactly one or
        one-or-more items, then the type inferred for <code>fn:subsequence</code>
        is the prime type of the input type.</p><infergr diff="del" at="E024"><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>QName</emph>
                   <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> (<code>FN-URI</code>,<quote><code>subsequence</code></quote>)</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a>
 		<a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause><clause><expression><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_isin" class="judgment"><term>in</term></a>
                { <code>1</code>, <code>+</code> }</expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><emph>QName</emph>(<emph>Expr</emph>,
			 1, 1) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)</expression></clause></multiclause></postjudge></infer></infergr><p diff="del" at="E024">If the type of the input expression has zero or more items,
        <code>fn:subsequence</code> is applied on a numeric literal,
        <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>position</code></a>, or <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>last</code></a>, then the static type is
        zero-or-one of the prime type of the input type. Those static
        typing rules are intended to support more precise typing for
        the cases where <code>fn:subsequence</code> is the result of normalizing
        an XPath predicate of the form <emph>Expr</emph>[<emph>NumericLiteral</emph>]
        of <emph>Expr</emph>[last()], see <specref ref="id-axis-steps"/>.</p><infergr diff="del" at="E024"><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>QName</emph>
                   <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> (<code>FN-URI</code>,<quote><code>subsequence</code></quote>)</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a>
 		<a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause><clause><expression><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_isin" class="judgment"><term>in</term></a>
                { <code>*</code>, <code>+</code> }</expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><emph>QName</emph>(<emph>Expr</emph>,
			 <emph>NumericLiteral</emph>, 1) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) <code>?</code></expression></clause></multiclause></postjudge></infer></infergr><p diff="del" at="E024">The same rule applies when the last item in the input
        sequence is selected.</p><infergr diff="del" at="E024"><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>QName</emph>
                   <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> (<code>FN-URI</code>,<quote><code>subsequence</code></quote>)</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a>
 		<a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause><clause><expression><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_isin" class="judgment"><term>in</term></a>
                { <code>*</code>, <code>+</code> }</expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><emph>QName</emph>(<emph>Expr</emph>,
			 <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>last</code></a>, 1) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) <code>?</code></expression></clause></multiclause></postjudge></infer></infergr><p diff="del" at="E024">The same rule applies when an item is selected based on its
        position in the input sequence.</p><infergr diff="del" at="E024"><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>QName</emph>
                   <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> (<code>FN-URI</code>,<quote><code>subsequence</code></quote>)</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a>
 		<a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause><clause><expression><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_isin" class="judgment"><term>in</term></a>
                { <code>*</code>, <code>+</code> }</expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><emph>QName</emph>(<emph>Expr</emph>,
			 <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>position</code></a>, 1) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) <code>?</code></expression></clause></multiclause></postjudge></infer></infergr><p diff="del" at="E024">The last rule applies to all other applications of the
        <code>fn:subsequence</code> function. </p><infergr diff="del" at="E024"><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>QName</emph>
                   <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> (<code>FN-URI</code>,<quote><code>subsequence</code></quote>)</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:double</code></expression></clause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:double</code></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                  <emph>QName</emph>(<emph>Expr</emph>, <emph>Expr</emph><subscript>1</subscript>, <emph>Expr</emph><subscript>2</subscript>)
                  <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)
                  <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_quantifier" class="judgment">·</a> ?
 		</expression></clause></postjudge></infer></infergr><p diff="add" at="E024">
        The static type of a call to <code>fn:subsequence</code>
        is computed using <a href="#jd_prime" class="judgment">prime</a>() and <a href="#jd_quantifier" class="judgment">quantifier</a>(),
        which are defined in <specref ref="sec_factor"/>.
        </p><infergr diff="add" at="E024"><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <emph>fs:</emph><code>numeric</code></expression></clause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <emph>fs:</emph><code>numeric</code></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                  (<code>FN-URI</code>,<quote><code>subsequence</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript>)
                  <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)
                  <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) <a href="#jd_quantifier" class="judgment">·</a> ?
                </expression></clause></postjudge></infer></infergr></smtype></div3><div3 id="sec_op_union_intersect_except"><head><phrase>The <code>op:union</code>, <code>op:intersect</code>, and
      <code>op:except</code> operators</phrase></head><smtype><p>The static semantics for <code>op:union</code> is computed using
        <a href="#jd_prime" class="judgment">prime</a> and <a href="#jd_quantifier" class="judgment">quantifier</a>, which are defined in <specref ref="sec_factor"/>.  The type of each argument is determined,
        and then <a href="#jd_prime" class="judgment">prime</a>(.) and <a href="#jd_quantifier" class="judgment">quantifier</a>(.)  are applied to
        the sequence type (<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>).</p><infergr><infer><prejudge/><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>(<code>OP-URI</code>,<quote><code>union</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)
			 <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> , <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)
			 <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> , <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)</expression></clause></multiclause></postjudge></infer></infergr><p>The static semantics of <code>op:intersect</code> is analogous to that
        for <code>op:union</code>. Because an intersection may be empty, the
        result type is optional.</p><infergr><infer><prejudge/><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>(<code>OP-URI</code>,<quote><code>intersect</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,
		        <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>) <a href="#jd_quantifier" class="judgment">·</a>
		        <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>) <a href="#jd_quantifier" class="judgment">·</a> ?</expression></clause></multiclause></postjudge></infer></infergr><p>The static semantics of <code>op:except</code> follows.  The type of
        the second argument is ignored as it does not contribute to
        the result type.  As with <code>op:intersect</code>, the result of
        <code>op:except</code> may be the empty sequence.</p><infergr><infer><prejudge/><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>(<code>OP-URI</code>,<quote><code>except</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)
			 <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) <a href="#jd_quantifier" class="judgment">·</a>
			 <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) <a href="#jd_quantifier" class="judgment">·</a>
			 ?</expression></clause></multiclause></postjudge></infer></infergr></smtype></div3><div3 id="sec_fn_insert_before"><head><phrase>The <code>fn:insert-before</code> function</phrase></head><smtype><p>The static type for the <code>fn:insert-before</code> function is
        computed using <a href="#jd_prime" class="judgment">prime</a> and <a href="#jd_quantifier" class="judgment">quantifier</a>, which are
        defined in <specref ref="sec_factor"/>.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <code>xs:integer</code></expression></clause></multiclause><multiclause><clause><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>4</subscript> = (<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript>)</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                  (<code>FN-URI</code>,<quote><code>insert-before</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>4</subscript>) <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>4</subscript>)
 		</expression></clause></postjudge></infer></infergr></smtype></div3><div3 id="sec_fn_cardinality_funcs"><head><phrase>The <code>fn:zero-or-one</code>, <code>fn:one-or-more</code>, and
      <code>fn:exactly-one</code> functions</phrase></head><p>The functions <code>fn:zero-or-one</code>, <code>fn:one-or-more</code>, and
      <code>fn:exactly-one</code> check that the cardinality of a sequence is in
      the expected range.  They are useful to override the static type
      inferred for a given query.</p><p>For example, in the following query, the user may know that
      all ISBN numbers are unique and therefore that the function
      always returns at most one book element. However, the static
      typing feature cannot infer a precise enough type and will raise
      a type error during static type analysis.</p><eg xml:space="preserve">
  declare function book_with_isbn($isbn as xs:string) as schema-element(book)? {
    //book[@isbn=$isbn]
  }
</eg><p>In that query, the <code>fn:zero-or-one</code> function can be used to
      tell the type system that the cardinality is known to be zero or
      one.</p><eg xml:space="preserve">
  declare function book_with_isbn($isbn as xs:string) as schema-element(book)? {
    fn:zero-or-one(//book[@isbn=$isbn])
  }
</eg><smtype><p>The static typing rules for those functions always infer a
        type with the cardinality indicated by that function.</p><infergr><infer><prejudge/><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>(<code>FN-URI</code>,<quote><code>zero-or-one</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a>)
			 <a href="#jd_has_type" class="judgment"><term>:</term></a>
			 <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)?</expression></clause></multiclause></postjudge></infer></infergr><infergr><infer><prejudge/><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>(<code>FN-URI</code>,<quote><code>one-or-more</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a>)
			 <a href="#jd_has_type" class="judgment"><term>:</term></a>
			 <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)+</expression></clause></multiclause></postjudge></infer></infergr><infergr><infer><prejudge/><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>(<code>FN-URI</code>,<quote><code>exactly-one</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a>)
			 <a href="#jd_has_type" class="judgment"><term>:</term></a>
			 <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)</expression></clause></multiclause></postjudge></infer></infergr></smtype></div3></div2></div1><!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-indent-step:2
indent-tabs-mode:nil
sgml-parent-document:("XPathXQuerySemantics.xml" "body" "div1")
End:
--><!-- *************************** Auxiliary judgments **************** --><div1 id="sec_auxiliary_judgments"><head>Auxiliary Judgments</head><p>This section defines auxiliary judgments used in defining the
  formal semantics.  Many auxiliary judgments are used in both static
  typing and dynamic evaluation rules.  Those auxiliary judgments that
  are used in only the static or dynamic semantics are labeled as
  such.</p><div2 id="sec_accessing_types"><head>Judgments for accessing types</head><smintro><p>This section defines several auxiliary judgments to access
      components of the [XPath/XQuery] type system. The first two
      judgments (<a href="#jd_derives_from" class="judgment"><term>derives from</term></a> and <a href="#jd_substitutes_for" class="judgment"><term>substitutes for</term></a>) are used
      to access the type and element name hierarchies in an XML
      Schema. The other judgments (<a href="#jd_lookup" class="judgment"><term>name lookup</term></a>, <a href="#jd_static_lookup" class="judgment"><term>type lookup</term></a>,
      <a href="#jd_extended_by" class="judgment"><term>extended by</term></a>, <a href="#jd_adjusts_to" class="judgment"><term>adjusts to</term></a> and <a href="#jd_expands_to" class="judgment"><term>expands to</term></a>) are used
      to lookup the meaning of element or attribute types from the
      schema. These judgments are used in many expressions, notably in
      the specification of type matching (See <specref ref="sec_type_matching"/>), validation (See <specref ref="sec_validate"/>), and the static semantics of step
      expressions (See <specref ref="sec_auxiliary_xpath"/>).</p></smintro><div3 id="jd_aux_derives_from"><head>Derives from</head><smnotation><p id="jd_derives_from">The judgment</p><display>
          <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>1</subscript> <a href="#jd_derives_from" class="judgment"><term>derives from</term></a> <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>2</subscript></expression></clause>
        </display><p>holds when <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>1</subscript> derives from <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>2</subscript>.
        This judgment formalizes the definition of the
        <code>derives-from</code> function in <xspecref spec="XQ" ref="id-sequencetype-matching"/>. </p></smnotation><smexample><p>For example, assuming the extended XML Schema given in
        section <specref ref="sec_types_example"/>, then the following
        judgments hold.</p><eg xml:space="preserve">
  USAddress            derives from  xs:anyType
  NYCAddress           derives from  USAddress
  NYCAddress           derives from  xs:anyType
  xsd:positiveInteger  derives from  xsd:integer
  xsd:integer          derives from  xs:anySimpleType
  fs:anon3             derives from  xsd:positiveInteger
  fs:anon3             derives from  xsd:integer
  fs:anon3             derives from  xs:anySimpleType
  fs:anon3             derives from  xs:anyType
</eg></smexample><smnote><p>Derivation is a partial order. It is reflexive and
        transitive by the definition below.</p></smnote><smrules><p>This judgment is specified by the following rules.</p><!--    
        <p>Some rules have hypotheses that simply list a type,
        element, or attribute declaration.</p>
--><p>Every type name derives from itself.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-TypeName"><emph>TypeName</emph></a> <a href="#jd_derives_from" class="judgment"><term>derives from</term></a> <a href="#doc-fs-TypeName"><emph>TypeName</emph></a></expression></clause></postjudge></infer></infergr><p>Every type name derives from the type it is declared to
      derive from by extension or restriction.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           </expression></clause></multiclause><multiclause><clause><expression>
             <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>) = define type <a href="#doc-fs-TypeName"><emph>TypeName</emph></a>
             extends <a href="#doc-fs-TypeName"><emph>BaseTypeName</emph></a> <a href="#doc-fs-OptMixed"><emph>OptMixed</emph></a> { <a href="#doc-fs-Type"><emph>Type</emph></a> }
           </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-TypeName"><emph>TypeName</emph></a> <a href="#jd_derives_from" class="judgment"><term>derives from</term></a> <a href="#doc-fs-TypeName"><emph>BaseTypeName</emph></a></expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           </expression></clause></multiclause><multiclause><clause><expression>
             <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>) = define type <a href="#doc-fs-TypeName"><emph>TypeName</emph></a>
             restricts <a href="#doc-fs-TypeName"><emph>BaseTypeName</emph></a> <a href="#doc-fs-OptMixed"><emph>OptMixed</emph></a> { <a href="#doc-fs-Type"><emph>Type</emph></a> }
           </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-TypeName"><emph>TypeName</emph></a> <a href="#jd_derives_from" class="judgment"><term>derives from</term></a> <a href="#doc-fs-TypeName"><emph>BaseTypeName</emph></a></expression></clause></postjudge></infer></infergr><p>The above rules all require that the type names be defined in
      the static context, but [XPath/XQuery] permits references to
      "unknown" type names, i.e., type names that are not defined in
      the static context.  An unknown type name might be encountered,
      if a module in which the given type name occurs does not import
      the schema in which the given type name is defined. In this
      case, an implementation is allowed (but is not required) to
      provide an implementation-dependent mechanism for determining
      whether the unknown type name is the same as or derived by
      restriction from the expected type name.  The following rule
      formalizes this implementation dependent mechanism.</p><infergr><infer><prejudge><multiclause><clause><expression>
             "The implementation is able to determine that
<a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>1</subscript> is derived by
restriction from <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>2</subscript>."
           </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>1</subscript> <a href="#jd_derives_from" class="judgment"><term>derives from</term></a> <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>2</subscript></expression></clause></postjudge></infer></infergr><p>The derivation relation is transitive.</p><infergr><infer><prejudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>1</subscript> <a href="#jd_derives_from" class="judgment"><term>derives from</term></a> <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>2</subscript></expression></clause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>2</subscript> <a href="#jd_derives_from" class="judgment"><term>derives from</term></a> <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>3</subscript></expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>1</subscript> <a href="#jd_derives_from" class="judgment"><term>derives from</term></a> <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>3</subscript></expression></clause></postjudge></infer></infergr></smrules></div3><div3 id="sec_substitutes"><head>Substitutes for</head><p>The substitutes judgment is used to know whether an element
      name is in the substitution group of another element name.</p><smnotation><p id="jd_substitutes_for">The judgment</p><display>
          <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>1</subscript> <a href="#jd_substitutes_for" class="judgment"><term>substitutes for</term></a>
          <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>2</subscript></expression></clause>
        </display><p>holds when <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>1</subscript> substitutes for
        <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>2</subscript>.</p></smnotation><smexample><p>For example, assuming the extended XML Schema given in
        section <specref ref="sec_types_example"/>, then the following
        judgments hold.</p><eg xml:space="preserve">
  usaddress  substitutes for  address
  nyaddress  substitutes for  usaddress
  nyaddress  substitutes for  address
</eg></smexample><smnote><p>Substitution is a partial order.  It is reflexive and
        transitive by the definition below.  It is asymmetric because
        no cycles are allowed in substitution groups.</p></smnote><smrules><p>The substitutes judgment for element names is specified by
        the following rules.</p><p>Every element name substitutes for itself.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#jd_substitutes_for" class="judgment"><term>substitutes for</term></a> <a href="#doc-fs-ElementName"><emph>ElementName</emph></a></expression></clause></postjudge></infer></infergr><p>Every element name substitutes for the element it is
        declared to substitute for.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           </expression></clause></multiclause><multiclause><clause><expression>
               <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_elem_decl" class="env">elemDecl</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>) =
                 define element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a>
                   substitutes for <a href="#doc-fs-ElementName"><emph>BaseElementName</emph></a> <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a> <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a>
             </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#jd_substitutes_for" class="judgment"><term>substitutes for</term></a> <a href="#doc-fs-ElementName"><emph>BaseElementName</emph></a></expression></clause></postjudge></infer></infergr><p>Substitution is transitive.</p><infergr><infer><prejudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>1</subscript> <a href="#jd_substitutes_for" class="judgment"><term>substitutes for</term></a> <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>2</subscript></expression></clause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>1</subscript> <a href="#jd_substitutes_for" class="judgment"><term>substitutes for</term></a> <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>3</subscript></expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>1</subscript> <a href="#jd_substitutes_for" class="judgment"><term>substitutes for</term></a> <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>3</subscript></expression></clause></postjudge></infer></infergr></smrules></div3><div3 id="sec_element_lookup"><head>Element and attribute name lookup (Dynamic)</head><p>The <a href="#jd_lookup" class="judgment"><term>name lookup</term></a> judgment is used in the definition of the
      <a href="#jd_matches" class="judgment"><term>matches</term></a> judgment, which takes a value and a type and
      determines whether the value matches, or is an instance of, the
      given type.  Both <a href="#jd_lookup" class="judgment"><term>name lookup</term></a> and <a href="#jd_matches" class="judgment"><term>matches</term></a> are used in the
      dynamic semantics. </p><p>The <a href="#jd_lookup" class="judgment"><term>name lookup</term></a> judgment takes an element(attribute) name
      (derived from a node value) and an element(attribute) type and
      if the element(attribute) name matches the corresponding name in
      the element(attribute) type, the judgment yields the type's
      corresponding type reference and for elements, its nillable
      property.</p><smnotation><p id="jd_lookup">The judgment</p><display>
          <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#jd_lookup" class="judgment"><term>name lookup</term></a> <a href="#doc-fs-ElementType"><emph>ElementType</emph></a>
          <a href="#jd_lookup" class="judgment"><term>yields</term></a> <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a>
          <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression></clause>
        </display><p>holds when the given element name matches the given element
        type and requires that the element be nillable as indicated
        and have the given type reference.</p></smnotation><smexample><p>For example, assuming the extended XML Schema given in
        section <specref ref="sec_types_example"/>, then the following
        judgments hold.</p><eg xml:space="preserve">
  comment    name lookup element comment                          yields of type xsd:string
  size       name lookup element size nillable of type xs:integer yields nillable of type xsd:string
  apt        name lookup element apt                              yields of type fs:anon3
  nycaddress name lookup element address                          yields of type NYCAddress
</eg><p>Note that when the element name is in a substitution group,
        the name lookup returns the type name corresponding to the
        original element name (here the type <code>NYCAddress</code>
        for the element <code>nycaddress</code>, instead of
        <code>Address</code> for the element
        <code>address</code>).</p></smexample><smrules><p>This judgment is specified by the following rules.</p><p>If the element type is a reference to a global element,
        then name lookup yields the type reference in the element
        declaration for the given element name.  The given element
        name must be in the substitution group of the global
        element.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>1</subscript> <a href="#jd_substitutes_for" class="judgment"><term>substitutes for</term></a> <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>2</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>1</subscript> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript>
           </expression></clause></multiclause><multiclause><clause><expression>
                <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_elem_decl" class="env">elemDecl</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript>) =
                  define element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>1</subscript>
                    <a href="#doc-fs-OptSubstitution"><emph>OptSubstitution</emph></a> <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a> <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a>
              </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>1</subscript> <a href="#jd_lookup" class="judgment"><term>name lookup</term></a> element
             <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>2</subscript> <a href="#jd_lookup" class="judgment"><term>yields</term></a> <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a>
             <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression></clause></postjudge></infer></infergr><p>If the given element name matches the element name in the
        element type, and the element type contains a type reference,
        then name lookup yields that type reference.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#jd_lookup" class="judgment"><term>name lookup</term></a> element
             <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a> <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a>
             <a href="#jd_lookup" class="judgment"><term>yields</term></a> <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a>
             <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression></clause></postjudge></infer></infergr><p>If the element type has no element name but contains a type
        reference, then name lookup yields the type reference.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#jd_lookup" class="judgment"><term>name lookup</term></a> element<phrase diff="add" at="E023"> *</phrase>
             <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a> <a href="#jd_lookup" class="judgment"><term>yields</term></a>
             <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression></clause></postjudge></infer></infergr><p>If the element type has no element name and no type
        reference, then name lookup yields <code>xs:anyType</code>.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#jd_lookup" class="judgment"><term>name lookup</term></a> element<phrase diff="add" at="E023"> *</phrase>
             <a href="#jd_lookup" class="judgment"><term>yields</term></a> of type <code>xs:anyType</code></expression></clause></postjudge></infer></infergr></smrules><smnotation><p id="jd_attribute_lookup">The judgment</p><display>
          <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a> <a href="#jd_attribute_lookup" class="judgment"><term>name lookup</term></a>
          <a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a> <a href="#jd_attribute_lookup" class="judgment"><term>yields</term></a>
          <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression></clause>
        </display><p>holds when matching an attribute with the given attribute
        name against the given attribute type matches the type
        reference.</p></smnotation><smexample><p>For example, assuming the extended XML Schema given in
        section <specref ref="sec_types_example"/>, then the following
        judgments hold.</p><eg xml:space="preserve">
  orderDate  name lookup  attribute orderDate of type xsd:date  yields  of type xsd:date?
  orderDate  name lookup  attribute of type xsd:date            yields  of type xsd:date?
</eg></smexample><smrules><p>This judgment is specified by the following rules.</p><p>If the attribute type is a reference to a global attribute,
        then name lookup yields the type reference in the attribute
        declaration for the given attribute name.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a> <a href="#jd_attr_qname_expands_to" class="judgment"><term>of attr expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression></clause></multiclause><multiclause><clause><expression>
                <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_attr_decl" class="env">attrDecl</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>) =
                  define attribute <a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a>
                    <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a>
              </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a> <a href="#jd_attribute_lookup" class="judgment"><term>name lookup</term></a>
             attribute <a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a> <a href="#jd_attribute_lookup" class="judgment"><term>yields</term></a>
             <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression></clause></postjudge></infer></infergr><p>If the given attribute name matches the attribute name in
        the attribute type, and the attribute type contains a type
        reference, then name lookup yields that type reference.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a> <a href="#jd_attribute_lookup" class="judgment"><term>name lookup</term></a>
             attribute <a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a> <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a>
             <a href="#jd_attribute_lookup" class="judgment"><term>yields</term></a>
             <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression></clause></postjudge></infer></infergr><p>If the attribute type has no attribute name but contains a
        type reference, then name lookup yields the type
        reference.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a> <a href="#jd_attribute_lookup" class="judgment"><term>name lookup</term></a>
             attribute<phrase diff="add" at="E023"> *</phrase> <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a> <a href="#jd_attribute_lookup" class="judgment"><term>yields</term></a>
             <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression></clause></postjudge></infer></infergr><p>If the attribute type has no attribute name and no type
        reference, then name lookup yields <code>xs:anySimpleType</code>.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a> <a href="#jd_attribute_lookup" class="judgment"><term>name lookup</term></a>
             attribute<phrase diff="add" at="E023"> *</phrase> <a href="#jd_attribute_lookup" class="judgment"><term>yields</term></a> of type
             <code>xs:anySimpleType</code></expression></clause></postjudge></infer></infergr></smrules></div3><div3 id="jd_aux_static_lookup"><head>Element and attribute type lookup (Static)</head><p>The type lookup judgments are used to obtain the
      appropriate type reference for an attribute or element.</p><smnotation><p id="jd_static_lookup">The judgment</p><display>
          <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-ElementType"><emph>ElementType</emph></a> <a href="#jd_static_lookup" class="judgment"><term>type lookup</term></a> <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a>
          <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression></clause>
        </display><p>holds when the element type is optionally nillable and has
        the given type reference.</p></smnotation><smrules><p>The element type lookup judgments are specified by the
        following rules.</p><p>A reference to a global element yields the type reference
        in the global element declaration with the given element
        name.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           </expression></clause></multiclause><multiclause><clause><expression>
                <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_elem_decl" class="env">elemDecl</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>) = define element
                  <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#doc-fs-OptSubstitution"><emph>OptSubstitution</emph></a> <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a>
                  <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a>
              </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#jd_static_lookup" class="judgment"><term>type lookup</term></a>
             <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a> <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression></clause></postjudge></infer></infergr><p>In the case of a local element type, type lookup yields the
        corresponding type reference.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a>
             <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a> <a href="#jd_static_lookup" class="judgment"><term>type lookup</term></a> <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a>
             <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression></clause></postjudge></infer></infergr><p>If the element type has no element name but contains a type
        reference, then type lookup yields that type reference.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>element<phrase diff="add" at="E023"> *</phrase> <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a> <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a>
             <a href="#jd_static_lookup" class="judgment"><term>type lookup</term></a> <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression></clause></postjudge></infer></infergr><p>If the element type has no element name and no type
        reference, then lookup yields <code>xs:anyType</code>.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>element<phrase diff="add" at="E023"> *</phrase> <a href="#jd_static_lookup" class="judgment"><term>type lookup</term></a> of type
             <code>xs:anyType</code></expression></clause></postjudge></infer></infergr></smrules><smnotation><p id="jd_attribute_static_lookup">The judgment</p><display>
          <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a> <a href="#jd_attribute_static_lookup" class="judgment"><term>type lookup</term></a>
          <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression></clause>
        </display><p>holds when the attribute type has the  given type reference.</p></smnotation><smrules><p>This judgment is specified by the following rules.</p><p>A reference to a global attribute yields the type reference in
        the global attribute declaration with the given attribute name.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a> <a href="#jd_attr_qname_expands_to" class="judgment"><term>of attr expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression></clause></multiclause><multiclause><clause><expression>
                <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_attr_decl" class="env">attrDecl</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>) =
                  define attribute <a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a>
                    <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a>
              </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>attribute <a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a> 
             <a href="#jd_attribute_static_lookup" class="judgment"><term>type lookup</term></a>
             <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression></clause></postjudge></infer></infergr><p>If the attribute name is not defined, i.e., it is not declared
       in the in-scope schema definitions, then the attribute's
       default type is <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a> <a href="#jd_attr_qname_expands_to" class="judgment"><term>of attr expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression></clause></multiclause><multiclause><clause><expression>
                <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_attr_decl" class="env">attrDecl</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>) undefined
              </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>attribute <a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a>
             <a href="#jd_attribute_static_lookup" class="judgment"><term>type lookup</term></a>
             of type <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a></expression></clause></postjudge></infer></infergr><p>In the case of a local attribute type, type lookup yields
        the corresponding type reference.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>attribute <a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a>
             <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a> <a href="#jd_attribute_static_lookup" class="judgment"><term>type lookup</term></a>
             <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression></clause></postjudge></infer></infergr><p>If the attribute type has no attribute name but contains a
        type reference, then type lookup yields the type
        reference.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>attribute<phrase diff="add" at="E023"> *</phrase> <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a> 
             <a href="#jd_attribute_static_lookup" class="judgment"><term>type lookup</term></a>
             <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression></clause></postjudge></infer></infergr><p>If the attribute type has no attribute name and no type
        reference, then type lookup yields <code>xs:anySimpleType</code>.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>attribute<phrase diff="add" at="E023"> *</phrase> <a href="#jd_attribute_static_lookup" class="judgment"><term>type lookup</term></a> of
             type <code>xs:anySimpleType</code></expression></clause></postjudge></infer></infergr></smrules></div3><div3 id="sec_extension"><head>Extension</head><smnotation><p id="jd_extended_by">The judgment</p><display>
          <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_extended_by" class="judgment"><term>extended by</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_extended_by" class="judgment"><term>is</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause>
        </display><p>holds when the result of extending <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> by <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
        is <a href="#doc-fs-Type"><emph>Type</emph></a>.  This judgment is used in the definition of type
        expansion <specref ref="sec_type_expansion"/>, which expands a
        type to include the union of all types derived from the given
        type, </p></smnotation><smrules><p>This judgment is specified by the following rules.</p><infergr><infer><prejudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> = <a href="#doc-fs-AttributeModel"><emph>AttributeModel</emph></a><subscript>1</subscript> , <a href="#doc-fs-ElementModel"><emph>ElementModel</emph></a><subscript>1</subscript></expression></clause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> = <a href="#doc-fs-AttributeModel"><emph>AttributeModel</emph></a><subscript>2</subscript> , <a href="#doc-fs-ElementModel"><emph>ElementModel</emph></a><subscript>2</subscript></expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_extended_by" class="judgment"><term>extended by</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_extended_by" class="judgment"><term>is</term></a>
                 (<a href="#doc-fs-AttributeModel"><emph>AttributeModel</emph></a><subscript>1</subscript> &amp; <a href="#doc-fs-AttributeModel"><emph>AttributeModel</emph></a><subscript>2</subscript>) , <a href="#doc-fs-ElementModel"><emph>ElementModel</emph></a><subscript>1</subscript> , <a href="#doc-fs-ElementModel"><emph>ElementModel</emph></a><subscript>2</subscript></expression></clause></postjudge></infer></infergr></smrules></div3><div3 id="sec_mixed"><head>Mixed content</head><smnotation><p id="jd_mixes_to">The judgment</p><display>
          <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_mixes_to" class="judgment"><term>mixes to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression></clause>
        </display><p>holds when the result of creating a mixed content from
        <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> is <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>.</p></smnotation><smrules><p>This judgment is specified by the following rule, which
        interleaves the element content with a sequence of text nodes
        and adds a union of <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a> values.  The
        <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a> sequence is required because it is
        possible to derive an element containing only atomic values
        from an element that is mixed.</p><infergr><infer><prejudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a> = <a href="#doc-fs-AttributeModel"><emph>AttributeModel</emph></a> , <a href="#doc-fs-ElementModel"><emph>ElementModel</emph></a></expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_mixes_to" class="judgment"><term>mixes to</term></a> <a href="#doc-fs-AttributeModel"><emph>AttributeModel</emph></a> , (
             <a href="#doc-fs-ElementModel"><emph>ElementModel</emph></a> &amp; text* | <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a> *)</expression></clause></postjudge></infer></infergr></smrules></div3><div3 id="sec_adjustment"><head>Type adjustment</head><p>In the [XPath/XQuery] type system, a complex-type declaration
      does not include the implicit attributes and nodes that may be
      included in the type.  Type adjustment takes a complex type and
      adjusts it to include implicit attributes and nodes.  In
      particular, type adjustment:

      <ulist><item><p>adds the four (optional) built-in attributes xsi:type,
        xsi:nil, xsi:schemaLocation, or
        xsi:noNamespaceSchemaLocation,</p></item><item><p>interleaves the type with a sequence of comments and
        processing-instructions, and </p></item><item><p>if the
        complex type is mixed, interleaves the type with a sequence of
        text nodes and <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>.</p></item></ulist>
      </p><smnotation><p id="jd_adjusts_to">The judgment</p><display>
          <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-OptMixed"><emph>OptMixed</emph></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_adjusts_to" class="judgment"><term>adjusts to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression></clause>
        </display><p>holds when the second type is the same as the first after
        the first has been adjusted as described above.  </p></smnotation><smrules><p>This judgment is specified by the following rules.</p><p>If the type is flagged as mixed, then mix the type and
        extend it by the built-in attributes.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_mixes_to" class="judgment"><term>mixes to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_extended_by" class="judgment"><term>extended by</term></a> <a href="#sec_built_in_attributes"><code>BuiltInAttributes</code></a> <a href="#jd_extended_by" class="judgment"><term>is</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>4</subscript> = <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript> &amp;
              <code>processing-instruction<phrase diff="add" at="E022">*</phrase>*</code> &amp;
              <code>comment*</code></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>mixed <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_adjusts_to" class="judgment"><term>adjusts to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>4</subscript></expression></clause></postjudge></infer></infergr><p>Otherwise, just extend the type by the built-in
        attributes.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_extended_by" class="judgment"><term>extended by</term></a> <a href="#sec_built_in_attributes"><code>BuiltInAttributes</code></a> <a href="#jd_extended_by" class="judgment"><term>is</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript> = <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> &amp;
              <code>processing-instruction<phrase diff="add" at="E022">*</phrase>*</code> &amp;
              <code>comment*</code></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_adjusts_to" class="judgment"><term>adjusts to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript></expression></clause></postjudge></infer></infergr></smrules></div3><div3 id="sec_built_in_attributes"><head>Builtin attributes</head><p>Schema defines four built-in attributes that can appear on
      any element in the document without being explicitly declared in
      the schema. Those four attributes need to be added inside
      content models when doing matching. The four built-in attributes
      of Schema are declared as follows.</p><eg xml:space="preserve">
  define attribute xsi:type of type xs:QName<phrase diff="add" at="E042">;</phrase>
  define attribute xsi:nil of type xs:boolean<phrase diff="add" at="E042">;</phrase>
  define attribute xsi:schemaLocation of type fs:anon<phrase diff="add" at="E042">;</phrase>
  define type fs:anon1 { xs:anyURI* }<phrase diff="add" at="E042">;</phrase>
  define attribute xsi:noNamespaceSchemaLocation of type xs:anyURI<phrase diff="add" at="E042">;</phrase>
</eg><p>For convenience, a type that is an all group of the four
       built-in XML Schema attributes is defined.</p><eg xml:space="preserve">
  BuiltInAttributes =
      attribute xsi:type ?
    &amp; attribute xsi:nil ?
    &amp; attribute xsi:schemaLocation ?
    &amp; attribute xsi:noNamespaceSchemaLocation ?
</eg></div3><div3 id="sec_type_expansion"><head>Type expansion</head><p>The <a href="#jd_expands_to" class="judgment"><term>expands to</term></a> judgment is one of the most important
      static judgments.  It is used in the static semantics of the
      child axis <specref ref="sec_static_axis_judge"/>, which is used
      in the definition of many other rules that extract element types
      from an arbitrary content type.</p><p>The judgment takes a type name and computes the union of all
      types derived from the given type.  If the type is nillable, it
      also makes sure the content model allows the empty sequence.  If
      the type is mixed, it also adjusts the type to include the mixed
      content model.  The judgment depends on the
      <a href="#jd_union_interpretation" class="judgment"><term>extended with union interpretation of</term></a> judgment to recursively compute all
      derived types.</p><smnotation><p id="jd_expands_to">The judgment</p><display>
          <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a> <a href="#jd_expands_to" class="judgment"><term>expands to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause>
        </display><p>holds when expanding the type specifier results in the
        given type.</p></smnotation><smrules><p>This judgment is specified by the following rules.</p><p>If the type is nillable, then it expands into an optional
        type.</p><infergr><infer><prejudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a> <a href="#jd_expands_to" class="judgment"><term>expands to</term></a>
             <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>nillable <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a> <a href="#jd_expands_to" class="judgment"><term>expands to</term></a>
             <a href="#doc-fs-Type"><emph>Type</emph></a>?</expression></clause></postjudge></infer></infergr><p>The type definition for the type reference is contained in
        its expansion.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           </expression></clause></multiclause><multiclause><clause><expression>
               <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>) = define type
               <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> extends <a href="#doc-fs-TypeName"><emph>BaseTypeName</emph></a> <a href="#doc-fs-OptMixed"><emph>OptMixed</emph></a> {
               <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> }
             </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
            <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_union_interpretation" class="judgment"><term>is</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_union_interpretation" class="judgment"><term>extended with union interpretation of</term></a> <a href="#doc-fs-TypeName"><emph>TypeName</emph></a>
             </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-OptMixed"><emph>OptMixed</emph></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_adjusts_to" class="judgment"><term>adjusts to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>of type <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> <a href="#jd_expands_to" class="judgment"><term>expands to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript></expression></clause></postjudge></infer></infergr><p>In case the type is <a href="#dt-xs_untyped"><code>xs:untyped</code></a>, the type does not need to
        be adjusted as is required for other XML Schema types. See the
        corresponding definition in <specref ref="id-predefined-types"/>.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                <a href="#dt-xs_untyped"><code>xs:untyped</code></a> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
              </expression></clause></multiclause><multiclause><clause><expression>
               <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>) = define type
               <a href="#dt-xs_untyped"><code>xs:untyped</code></a> extends <code>xs:anyType</code> {
               <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> }
             </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>of type <a href="#dt-xs_untyped"><code>xs:untyped</code></a> <a href="#jd_expands_to" class="judgment"><term>expands to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression></clause></postjudge></infer></infergr></smrules></div3><div3 id="sec_union_interpretation"><head>Union interpretation of derived types</head><smnotation><p id="jd_union_interpretation">The judgment</p><display>
          <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_union_interpretation" class="judgment"><term>is</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
          <a href="#jd_union_interpretation" class="judgment"><term>extended with union interpretation of</term></a> 
          <a href="#doc-fs-TypeName"><emph>TypeName</emph></a></expression></clause>
        </display><p>holds when the type <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> is the expansion of the type
        name <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> with definition <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> to include all
        types derived by extension and restriction from the given type
        name.  This rule is recursive, because each type name itself
        may have other type names that are derived from it.  The
        recursive rules traverse the entire derivation tree,
        identifying every type name derived from the original type
        name.</p></smnotation><smrules><p>This judgment is specified by the following rules.</p><infergr><infer><prejudge><multiclause><clause><expression>
            <emph>No type derives from <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>0</subscript></emph>
            </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> <a href="#jd_union_interpretation" class="judgment"><term>is</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>
          <a href="#jd_union_interpretation" class="judgment"><term>extended with union interpretation of</term></a> 
          <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>0</subscript></expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><!-- First, the type names immediately derived by restriction --><multiclause><clause><expression>
               <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>R,1</subscript>) = define type
               <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>R,1</subscript> restricts <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>0</subscript> <a href="#doc-fs-OptMixed"><emph>OptMixed</emph></a><subscript>R,1</subscript> {
               <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>R,1</subscript> }
</expression></clause></multiclause><multiclause><clause><expression>· · ·
</expression></clause></multiclause><multiclause><clause><expression>
               <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>R,n</subscript>) = define type
               <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>R,n</subscript> restricts <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>0</subscript> <a href="#doc-fs-OptMixed"><emph>OptMixed</emph></a><subscript>R,n</subscript> {
               <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>R,n</subscript> }
</expression></clause></multiclause><!-- Second, the union interpretation of all the type names immediately derived by restriction --><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>R,1</subscript>' <a href="#jd_union_interpretation" class="judgment"><term>is</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>R,1</subscript> <a href="#jd_union_interpretation" class="judgment"><term>extended with union interpretation of</term></a> <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>R,1</subscript> 
</expression></clause></multiclause><multiclause><clause><expression>· · ·
</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>R,n</subscript>' <a href="#jd_union_interpretation" class="judgment"><term>is</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>R,n</subscript> <a href="#jd_union_interpretation" class="judgment"><term>extended with union interpretation of</term></a> <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>R,n</subscript> 
</expression></clause></multiclause><!-- Third, all type names immediately derived by extension --><multiclause><clause><expression>
               <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>E,1</subscript>) = define type
               <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>E,1</subscript> extends <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>0</subscript> <a href="#doc-fs-OptMixed"><emph>OptMixed</emph></a><subscript>E,1</subscript> {
               <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>E,1</subscript> }
</expression></clause></multiclause><multiclause><clause><expression>· · ·
</expression></clause></multiclause><multiclause><clause><expression>
               <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>E,m</subscript>) = define type
               <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>E,m</subscript> extends <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>0</subscript> <a href="#doc-fs-OptMixed"><emph>OptMixed</emph></a><subscript>E,m</subscript> {
               <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>E,m</subscript> }
</expression></clause></multiclause><!-- Fourth, the union interpretation of all the type names immediately derived by extension --><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>E,1</subscript>' <a href="#jd_union_interpretation" class="judgment"><term>is</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>E,1</subscript> <a href="#jd_union_interpretation" class="judgment"><term>extended with union interpretation of</term></a> <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>E,1</subscript> 
</expression></clause></multiclause><multiclause><clause><expression>· · ·
</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>E,m</subscript>' <a href="#jd_union_interpretation" class="judgment"><term>is</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>E,m</subscript> <a href="#jd_union_interpretation" class="judgment"><term>extended with union interpretation of</term></a> <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>E,m</subscript> 
</expression></clause></multiclause><!-- Finally, the entire type --><multiclause><clause><expression>
<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> = <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>R,1</subscript>' | · · · | <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>R,n</subscript>'
| <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> | (<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>E,1</subscript>' ) | · · · | (<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>E,m</subscript>')
</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_union_interpretation" class="judgment"><term>is</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>
          <a href="#jd_union_interpretation" class="judgment"><term>extended with union interpretation of</term></a> 
          <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>0</subscript></expression></clause></postjudge></infer></infergr><smexamples><p>Note that this expansion does not enforce the <term>unique
  particule attribution</term> property specified by XML Schema in
  the resulting content models. Implementations may want to implement
  an equivalent alternative expansion that enforces that property.
  For example, expanding type <code>T1</code> below yields the
  following type that is not one-deterministic:</p><eg xml:space="preserve">
define type T1 { element a }
define type T2 extends T1 { element b }

(element a | element a, element b) is (element a) extended with union interpretation of T1
</eg><p>An implementation might want to infer the equivalent content model
that verifies the <term>unique particule attribution</term> property of
XML Schema:</p><eg xml:space="preserve">
(element a, (() | element b)) is (element a) extended with union interpretation of T1
</eg></smexamples></smrules></div3></div2><div2 id="sec_auxiliary_xpath"><head>Judgments for step expressions and filtering</head><smintro><p>Step expressions are one of the elementary operations in
      [XPath/XQuery]. Steps select nodes reachable from the root of an XML tree.
      Defining the semantics of step expressions requires a
      detailed analysis of all the possible cases of axis and node
      tests.</p><p>This section introduces auxiliary judgments used to define
      the semantics of step expressions.  The <a href="#jd_principal" class="judgment"><term>has principal</term></a> judgment
      (<specref ref="sec_jd_principal"/>) captures the notion of
      <emph>principal node kind</emph> in XPath.  The Axis judgments
      (<specref ref="sec_axis_judge"/>) define the static and dynamic
      semantics of all axes, and the Node Test judgments (<specref ref="sec_test_judge"/>) define the static and dynamic semantics
      of all node tests.  The <a href="#jd_filter" class="judgment"><term>filter</term></a> judgment accesses the value
      of an attribute and is used in the definition of validation
      (<specref ref="sec_validation_judgments"/>).</p></smintro><div3 id="sec_jd_principal"><head>Principal Node Kind</head><smnotation><p>The following auxiliary grammar production describes
        principal node kinds (See <bibref ref="xpath-30"/>).</p><scrap headstyle="show"><head>PrincipalNodeKind</head><prodrecap ref="PrincipalNodeKind" id="PrincipalNodeKind" orig="formal"/></scrap></smnotation><smnotation><p id="jd_principal">The judgment</p><display>
        <clause><expression><emph>Axis</emph> <a href="#jd_principal" class="judgment"><term>has principal</term></a>
         <emph>PrincipalNodeKind</emph></expression></clause>
       </display><p>holds when <emph>PrincipalNodeKind</emph> is the principal node
        kind for <emph>Axis</emph>.</p></smnotation><smexample><p>For example, the following judgments hold.</p><eg xml:space="preserve">
  child::       principal  element
  descendant::  principal  element
  preceding::   principal  element
  attribute::   principal  attribute
  namespace::   principal  namespace
</eg></smexample><smrules><p>This judgment is specified by the following rules.</p><p>The principal node type for the attribute axis is
        attribute.</p><infergr><infer><postjudge><clause><expression><code>attribute::</code> <a href="#jd_principal" class="judgment"><term>has principal</term></a> attribute</expression></clause></postjudge></infer></infergr><p>The principal node type for the namespace axis is
        namespace.</p><infergr><infer><postjudge><clause><expression><code>namespace::</code> <a href="#jd_principal" class="judgment"><term>has principal</term></a> namespace</expression></clause></postjudge></infer></infergr><p>The principal node type for all other axis is element.</p><infergr><infer><prejudge><clause><expression><emph>Axis</emph> != <code>attribute::</code></expression></clause><clause><expression><emph>Axis</emph> != <code>namespace::</code></expression></clause></prejudge><postjudge><clause><expression><emph>Axis</emph> <a href="#jd_principal" class="judgment"><term>has principal</term></a> element</expression></clause></postjudge></infer></infergr></smrules></div3><div3 id="sec_axis_judge"><head>Auxiliary judgments for axes</head><div4 id="sec_static_axis_judge"><head>Static semantics of axes</head><smnotation><p id="jd_axis_type">The following judgment</p><display>
           <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
             <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
            </expression></clause>
          </display><p>holds when applying the axis <emph>Axis</emph> on type <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
          yields the type <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>.</p><p id="jd_has_element_content">The following two judgments are used
          in the definition of <a href="#jd_axis_type" class="judgment"><term>axis</term></a>.  The judgment</p><display>
           <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_has_element_content" class="judgment"><term>has node content</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> 
            </expression></clause>
          </display><p>only applies to a type that is a valid element content
          type and holds when <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> has the content type
          <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>.  The judgment separates the attribute types from
          the other node or atomic-valued types of the element content type
          and yields the non-attribute types.</p><p id="jd_has_attribute_content">The judgment</p><display>
           <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_has_attribute_content" class="judgment"><term>has attribute content</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> 
            </expression></clause>
          </display><p>only applies to a type that is a valid element content
          type and holds when <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> has attribute types
          <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>.  The judgment yields the attribute types of
          the element content type.</p></smnotation><smexample><p>For example, the following judgments hold.</p><eg xml:space="preserve">
  axis child::      of  element of type xs:string   :  text
  axis child::      of  element items of type Items :  element item of type fs:anon1*

  axis child::      of  element purchaseOrder       : 
    element shipTo of type USAddress,
    element billTo of type USAddress,
    element ipo:comment?,
    element items of type Items

  axis attribute::  of  element of type xs:string   :  empty

    attribute partNum of type SKU,
    element item of type fs:anon1*
  has-node-content
    element item of type fs:anon1*

    attribute partNum of type SKU,
    element item of type fs:anon1*
  has-attribute-content
    attribute partNum of type SKU

    (attribute partNum of type SKU,
     element item of type fs:anon1*) |
    (attribute orderDate of type xs:date?,
     element shipTo of type USAddress,
     element billTo of type USAddress,
     element comment?,
     element items of type Items)
  has-node-content
    (element item of type fs:anon1*) |
    (element shipTo of type USAddress,
     element billTo of type USAddress,
     element comment?,
     element items of type Items)

    (attribute partNum of type SKU,
     element item of type fs:anon1*) |
    (attribute orderDate of type xs:date?,
     element shipTo of type USAddress,
     element billTo of type USAddress,
     element comment?,
     element items of type Items)
  has-attribute-content
    (attribute partNum of type SKU) |
    (attribute orderDate of type xs:date?)
</eg></smexample><div5 id="sec_inference_axis"><head>Inference rules for all axes</head><smrules><p>The following rules compute the type of the axis
          expression when applied to each item type in the content
          model.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
              <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
              <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
              <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <emph>OccurrenceIndicator</emph>
              <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <emph>OccurrenceIndicator</emph>
             </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
              <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
              <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
              <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
              <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>4</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
              <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>&amp;<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
              <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript>&amp;<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>4</subscript>
             </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
              <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
              <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
              <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
              <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>4</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
              <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
              <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript>,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>4</subscript>
             </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
              <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
              <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
              <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
              <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>4</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
              <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>|<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
              <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript>|<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>4</subscript>
             </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><clause><expression>  </expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
              <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis_type" class="judgment"><term>of</term></a> none <a href="#jd_axis_type" class="judgment"><term>:</term></a> none
             </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><clause><expression>  </expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
              <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis_type" class="judgment"><term>of</term></a> <code>empty</code> <a href="#jd_axis_type" class="judgment"><term>:</term></a> <code>empty</code>
             </expression></clause></postjudge></infer></infergr><p>The rules in the following subsections specify how to
         compute the type of each axis applied to an item type.</p></smrules></div5><div5 id="sec_inference_self"><head>Inference rules for the <code>self</code> axis</head><smrules><p>Applying the self axis to a node type results in the same
         node type.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
	           <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>self::</code> <a href="#jd_axis_type" class="judgment"><term>of</term></a>
	           <a href="#doc-fs-NodeType"><emph>NodeType</emph></a> <a href="#jd_axis_type" class="judgment"><term>:</term></a>
	           <a href="#doc-fs-NodeType"><emph>NodeType</emph></a>
	         </expression></clause></postjudge></infer></infergr></smrules></div5><div5 id="sec_inference_child"><head>Inference rules for the <code>child</code> axis</head><smrules><p>In the case of an element type, the static type of the
         child axis is obtained by type lookup and expansion of the
         resulting type.  Note that the <a href="#jd_expands_to" class="judgment"><term>expands to</term></a> judgment
         yields the type that corresponds to a given type name.
         Because the meaning of a type name includes the definitions
         of <emph>all</emph> type names derived by extension and
         restriction from the given type name, <a href="#jd_expands_to" class="judgment"><term>expands to</term></a> yields
         the <emph>union</emph> of all the type definitions of all
         type names derived from the input type name.  Each type in
         the union contains the complete definition of the type name,
         i.e., it includes built-in attributes and, if necessary,
         processing-instruction, comment, and text types.</p><p>After type expansion, the judgment
         <a href="#jd_has_element_content" class="judgment"><term>has node content</term></a> is applied to each type in the
         union.  The resulting type is the union of all non-attribute
         types in the expanded type.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-ElementType"><emph>ElementType</emph></a>
                <a href="#jd_static_lookup" class="judgment"><term>type lookup</term></a> <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a>
                <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                  <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a> <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a>
                  <a href="#jd_expands_to" class="judgment"><term>expands to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> | · ·
                  · | <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript> 
                </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_has_element_content" class="judgment"><term>has node content</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>' 
                </expression></clause></multiclause><multiclause><clause><expression>
· · · 
                </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript> <a href="#jd_has_element_content" class="judgment"><term>has node content</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>' 
                </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
	               <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>child::</code>
	               <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-ElementType"><emph>ElementType</emph></a>
	               <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>' | ... | <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>'
	         </expression></clause></postjudge></infer></infergr><p>If the type is a sequence of attributes, then the content
         type is <code>empty</code>.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> attribute<phrase diff="add" at="E023">*</phrase>*</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
	               <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_has_element_content" class="judgment"><term>has node content</term></a> <code>empty</code>
	         </expression></clause></postjudge></infer></infergr><p>If the type is attributes followed by a simple type, the
         content type is zero-or-one text nodes.  The resulting type
         is optional since an expression returning the empty sequence
         results in no text node being constructed.</p><infergr><infer><prejudge><multiclause><clause><expression><a href="#doc-fs-Type"><emph>Type</emph></a> = <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
                attribute<phrase diff="add" at="E023">*</phrase>*
                </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
                <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>*
                </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                   <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_has_element_content" class="judgment"><term>has node content</term></a> text? 
	         </expression></clause></postjudge></infer></infergr><p>In the case of an element type with complex content type,
         the content type is simply the non-attribute part of the
         complex content type.</p><infergr><infer><prejudge><multiclause><clause><expression><a href="#doc-fs-Type"><emph>Type</emph></a> = <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
                attribute<phrase diff="add" at="E023">*</phrase>*
                </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-ElementModel"><emph>ElementModel</emph></a>*</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
	               <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_has_element_content" class="judgment"><term>has node content</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> 
	         </expression></clause></postjudge></infer></infergr><p>In the case of an attribute type, the static type of the
         child axis is empty.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
	               <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>child::</code> <a href="#jd_axis_type" class="judgment"><term>of</term></a>
	               <a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a> <a href="#jd_axis_type" class="judgment"><term>:</term></a> <code>empty</code>
	         </expression></clause></postjudge></infer></infergr><p>In the case of a text node type, the static type of the child
         axis is empty.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
	               <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>child::</code> <a href="#jd_axis_type" class="judgment"><term>of</term></a> text
	               <a href="#jd_axis_type" class="judgment"><term>:</term></a> <code>empty</code>
	         </expression></clause></postjudge></infer></infergr><p>In the case of a comment node type, the static type of the child
         axis is empty.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
	               <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>child::</code>
	               <a href="#jd_axis_type" class="judgment"><term>of</term></a> comment
	               <a href="#jd_axis_type" class="judgment"><term>:</term></a> <code>empty</code>
	         </expression></clause></postjudge></infer></infergr><p>In the case of a processing-instruction node type, the
         static type of the child axis is empty.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
	               <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>child::</code>
	               <a href="#jd_axis_type" class="judgment"><term>of</term></a> processing-instruction<phrase diff="add" at="E022">*</phrase>
	               <a href="#jd_axis_type" class="judgment"><term>:</term></a> <code>empty</code>
	         </expression></clause></postjudge></infer></infergr><p>In case of a document node type, the static type of the
         child axis is the type of the document node content,
         interleaved with a sequence of comments and
         processing-instructions.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
	               <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>child::</code>
	               <a href="#jd_axis_type" class="judgment"><term>of</term></a> document { <a href="#doc-fs-Type"><emph>Type</emph></a> }
	               <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a> &amp;
	               processing-instruction<phrase diff="add" at="E022">*</phrase>* &amp; comment*
	         </expression></clause></postjudge></infer></infergr></smrules></div5><div5 id="sec_inference_attribute"><head>Inference rules for the <code>attribute</code> axis</head><smrules><p>The static type for the attribute axis is computed in a
         similar way as the static type for the child axis.  As above,
         the <a href="#jd_expands_to" class="judgment"><term>expands to</term></a> judgment may yield a union type.  After
         type expansion, the judgment <a href="#jd_has_attribute_content" class="judgment"><term>has attribute content</term></a> is
         applied to each type in the union.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-ElementType"><emph>ElementType</emph></a> 
                <a href="#jd_static_lookup" class="judgment"><term>type lookup</term></a> <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a>
                <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                  <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a> <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a>
                  <a href="#jd_expands_to" class="judgment"><term>expands to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> | · ·
                  · | <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript> 
                </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_has_attribute_content" class="judgment"><term>has attribute content</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>'
                </expression></clause></multiclause><multiclause><clause><expression>
· · · 
                </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript> <a href="#jd_has_attribute_content" class="judgment"><term>has attribute content</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>'
                </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
	               <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>attribute::</code>
	               <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-ElementType"><emph>ElementType</emph></a>
	               <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>' | ... | <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>'
	         </expression></clause></postjudge></infer></infergr><p>When applied to an element type,
         <a href="#jd_has_attribute_content" class="judgment"><term>has attribute content</term></a> yields the type of the element's
         content that are attributes.</p><infergr><infer><prejudge><multiclause><clause><expression>
                  <a href="#doc-fs-Type"><emph>Type</emph></a> = (<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)
                </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
                attribute<phrase diff="add" at="E023">*</phrase>*
                </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-ElementModel"><emph>ElementModel</emph></a>* | <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>*</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
	               <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_has_attribute_content" class="judgment"><term>has attribute content</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
	         </expression></clause></postjudge></infer></infergr><p>In case of an attribute type, the static type of the
         attribute axis is empty.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
	               <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>attribute::</code> <a href="#jd_axis_type" class="judgment"><term>of</term></a>
	               <a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a> <a href="#jd_axis_type" class="judgment"><term>:</term></a> <code>empty</code>
	         </expression></clause></postjudge></infer></infergr><p>In case of a text node type, the static type of the
         attribute axis is empty.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
	               <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>attribute::</code>
	               <a href="#jd_axis_type" class="judgment"><term>of</term></a> text <a href="#jd_axis_type" class="judgment"><term>:</term></a> <code>empty</code>
	         </expression></clause></postjudge></infer></infergr><p>In case of a comment node type, the static type of the
         attribute axis is empty.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
	               <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>attribute::</code>
	               <a href="#jd_axis_type" class="judgment"><term>of</term></a> comment <a href="#jd_axis_type" class="judgment"><term>:</term></a>
	               <code>empty</code>
	         </expression></clause></postjudge></infer></infergr><p>In case of a processing-instruction node type, the static type of the
         attribute axis is empty.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
	               <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>attribute::</code>
	               <a href="#jd_axis_type" class="judgment"><term>of</term></a> processing-instruction<phrase diff="add" at="E022"> *</phrase>
	               <a href="#jd_axis_type" class="judgment"><term>:</term></a> <code>empty</code>
	         </expression></clause></postjudge></infer></infergr><p>In case of a document node type, the static type of the
         attribute axis is the empty.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
	               <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>attribute::</code>
	               <a href="#jd_axis_type" class="judgment"><term>of</term></a> document { <a href="#doc-fs-Type"><emph>Type</emph></a> }
	               <a href="#jd_axis_type" class="judgment"><term>:</term></a> <code>empty</code>
	         </expression></clause></postjudge></infer></infergr></smrules></div5><div5 id="sec_inference_parent"><head>Inference rules for the <code>parent</code> axis</head><smrules><p>The type for the parent of an element type, a text node
         type, a PI node type, or a comment node type is either an
         element, a document, or empty.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
	               <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>parent::</code>
	               <a href="#jd_axis_type" class="judgment"><term>of</term></a> element<phrase diff="add" at="E023"> *</phrase> <a href="#jd_axis_type" class="judgment"><term>:</term></a>
	               (element<phrase diff="add" at="E023"> *</phrase> | document)?
	         </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
	               <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>parent::</code>
	               <a href="#jd_axis_type" class="judgment"><term>of</term></a> text <a href="#jd_axis_type" class="judgment"><term>:</term></a>
	               (element<phrase diff="add" at="E023"> *</phrase> | document)?
	         </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
	               <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>parent::</code>
	               <a href="#jd_axis_type" class="judgment"><term>of</term></a> processing-instruction<phrase diff="add" at="E022"> *</phrase>
	               <a href="#jd_axis_type" class="judgment"><term>:</term></a> (element<phrase diff="add" at="E023"> *</phrase> | document)?
	         </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
	               <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>parent::</code>
	               <a href="#jd_axis_type" class="judgment"><term>of</term></a> comment <a href="#jd_axis_type" class="judgment"><term>:</term></a>
	               (element<phrase diff="add" at="E023"> *</phrase> | document)?
	         </expression></clause></postjudge></infer></infergr><p>The type for the parent of an attribute node is an
         element or empty.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
	               <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>parent::</code>
	               <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a>
	               <a href="#jd_axis_type" class="judgment"><term>:</term></a> element<phrase diff="add" at="E023"> *</phrase>?
	         </expression></clause></postjudge></infer></infergr><p>The type for the parent of a document node type is always
         empty.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
	               <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>parent::</code>
	               <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-DocumentType"><emph>DocumentType</emph></a>
	               <a href="#jd_axis_type" class="judgment"><term>:</term></a> <code>empty</code>
	         </expression></clause></postjudge></infer></infergr></smrules></div5><div5 id="sec_inference_namespace"><head>Inference rules for the <code>namespace</code> axis</head><smrules><p>The type for the namespace axis is always empty.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
	               <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>namespace::</code>
	               <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeType"><emph>NodeType</emph></a>
	               <a href="#jd_axis_type" class="judgment"><term>:</term></a> <code>empty</code>
	         </expression></clause></postjudge></infer></infergr></smrules></div5><div5 id="sec_inference_descendant"><head>Inference rules for the <code>descendant</code> axis</head><smrules><p>The types for the descendant axis is obtained as the
         closure of the type of the child axis. This is expressed by
         the following inference rule.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                   <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>child::</code>
                   <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
                   <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                   <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>child::</code>
                   <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)
                   <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> </expression></clause></multiclause><multiclause><clause><expression>...</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                   <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>child::</code>
                   <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>)
                   <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n+1</subscript> </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                     <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n+1</subscript>) <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) | ... | <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>) </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                   <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>descendant::</code>
                   <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
                   <a href="#jd_axis_type" class="judgment"><term>:</term></a>
                   (<a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) | ... |
                   <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>))*
	         </expression></clause></postjudge></infer></infergr><smnote><p>Note that the last premise in the above rule 
           terminates the recursion. The rule computes the n-th
           type <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript> such that applying the child axis one more
           time does not add any new item type to the union. This
           condition is guaranteed to hold at some point, because the
           number of item types is bounded by all of the item types
           defined in the in-scope schema definitions.</p></smnote></smrules></div5><div5 id="sec_inference_descendant_of_self"><head>Inference rules for the <code>descendant-or-self</code> axis</head><smrules><p>The type for the descendant-or-self axis is the union of
         the type for the self axis and for the descendant axis.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                   <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>descendant::</code>
                   <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
                   <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                   <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>descendant-or-self::</code>
                   <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
                   <a href="#jd_axis_type" class="judgment"><term>:</term></a> (<a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) | <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>))*
	         </expression></clause></postjudge></infer></infergr></smrules></div5><div5 id="sec_inference_ancestor"><head>Inference rules for the <code>ancestor</code> axis</head><smrules><p>The type for the ancestor axis is computed similarly as
         for the descendant axis.</p><infergr><infer><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
	               <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>ancestor::</code> <a href="#jd_axis_type" class="judgment"><term>of</term></a>
	               <a href="#doc-fs-NodeType"><emph>NodeType</emph></a> <a href="#jd_axis_type" class="judgment"><term>:</term></a>
	               (element<phrase diff="add" at="E023"> *</phrase> | document)*
	         </expression></clause></postjudge></infer></infergr><p>Note that this rule will always result in the type
         <code>(element<phrase diff="add" at="E023"> *</phrase> | document)*</code> type, but this formulation
         is preferred for consistency, and in case the static typing
         for the parent axis gets improved in a future version.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                   <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>parent::</code>
                   <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
                   <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                   <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>parent::</code>
                   <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)
                   <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> </expression></clause></multiclause><multiclause><clause><expression>...</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                   <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>parent::</code>
                   <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>)
                   <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n+1</subscript> </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                     <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n+1</subscript>) <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) | ... | <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>) </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                   <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>ancestor::</code>
                   <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
                   <a href="#jd_axis_type" class="judgment"><term>:</term></a>
                   (<a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) | ... |
                   <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>))*
	         </expression></clause></postjudge></infer></infergr></smrules></div5><div5 id="sec_inference_ancestor_of_self"><head>Inference rules for the <code>ancestor-or-self</code> axis</head><smrules><p>The type for the ancestor-or-self axis is the union of the
         type for the self axis and for the ancestor axis.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                   <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>ancestor::</code>
                   <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
                   <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                   <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>ancestor-or-self::</code>
                   <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
                   <a href="#jd_axis_type" class="judgment"><term>:</term></a> (<a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) | <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>))*
	         </expression></clause></postjudge></infer></infergr></smrules></div5></div4><div4 id="sec_dyn_axes"><head>Dynamic semantics of axes</head><smnotation><p id="jd_axis">The following judgment</p><display>
           <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
             <a href="#jd_axis" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis" class="judgment"><term>of</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_axis" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>
            </expression></clause>
          </display><p>holds when applying the axis <emph>Axis</emph> on <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>
          yields <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>:</p></smnotation><smexample><p>For example, the following judgments hold.</p><eg xml:space="preserve">
  axis child::      of    element sizes { text { "1 2 3" } }  =&gt;  text { "1 2 3" }

  axis attribute::  of
     element weight of type xs:integer {
       attribute xsi:type of type xs:QName {
         "xs:integer" of type xs:QName
       },
       42 of type xs:integer
     }
  =&gt; attribute xsi:type of type xs:QName {
       "xs:integer" of type xs:QName
     }

  
</eg></smexample><smrules><p>This judgment is specified by the following rules.</p><p>The first set of rules are used to process the axis
          judgment on each individual item in the input sequence.</p><infergr><infer><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
               <a href="#jd_axis" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis" class="judgment"><term>of</term></a> () <a href="#jd_axis" class="judgment"><term>=&gt;</term></a> ()
              </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
                <a href="#jd_axis" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis" class="judgment"><term>of</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>
                <a href="#jd_axis" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>3</subscript>
               </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
                <a href="#jd_axis" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis" class="judgment"><term>of</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>
                <a href="#jd_axis" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>4</subscript>
               </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
               <a href="#jd_axis" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis" class="judgment"><term>of</term></a>
               <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>
               <a href="#jd_axis" class="judgment"><term>=&gt;</term></a>
               <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>3</subscript>,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>4</subscript>
              </expression></clause></postjudge></infer></infergr><p>The following rules specifies how the value filter
          judgment is applied on each Axis.</p><p>The self axis just returns the context node.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
                    <a href="#jd_axis" class="judgment"><term>axis</term></a> <code>self::</code> <a href="#jd_axis" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a>
                    <a href="#jd_axis" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a>
                  </expression></clause></postjudge></infer></infergr><p>The child, parent, attribute and namespace axis are
          specified as follows.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
               <a href="#jd_axis" class="judgment"><term>axis</term></a> <code> child::</code> <a href="#jd_axis" class="judgment"><term>of</term></a> element
               <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> { <a href="#doc-fs-AttributeValue"><emph>AttributeValue</emph></a>,<a href="#doc-fs-ElementValue"><emph>ElementValue</emph></a> } <a href="#jd_axis" class="judgment"><term>=&gt;</term></a>
               <a href="#doc-fs-ElementValue"><emph>ElementValue</emph></a>
              </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
               <a href="#jd_axis" class="judgment"><term>axis</term></a> <code>attribute::</code> <a href="#jd_axis" class="judgment"><term>of</term></a>
               element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> {
               <a href="#doc-fs-AttributeValue"><emph>AttributeValue</emph></a>,<a href="#doc-fs-ElementValue"><emph>ElementValue</emph></a> }
               <a href="#jd_axis" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-AttributeValue"><emph>AttributeValue</emph></a>
              </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
               <a href="#jd_axis" class="judgment"><term>axis</term></a> <code>parent::</code> <a href="#jd_axis" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a>
               <a href="#jd_axis" class="judgment"><term>=&gt;</term></a> <emph>dm:</emph>parent(<a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a>)
              </expression></clause></postjudge></infer></infergr><p>The descendant, descendant-or-self, ancestor, and
          ancestor-or-self axis are implemented through recursive
          application of the children and parent filters.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
               <a href="#jd_axis" class="judgment"><term>axis</term></a> <code>child::</code> <a href="#jd_axis" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a>
               <a href="#jd_axis" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>
               </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><a href="#jd_axis" class="judgment"><term>axis</term></a> <code>descendant::</code> <a href="#jd_axis" class="judgment"><term>of</term></a>
               <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_axis" class="judgment"><term>=&gt;</term></a>
               <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
               <a href="#jd_axis" class="judgment"><term>axis</term></a> <code>descendant::</code> <a href="#jd_axis" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a>
               <a href="#jd_axis" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>, <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>
              </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
               <a href="#jd_axis" class="judgment"><term>axis</term></a> <code>self::</code> <a href="#jd_axis" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a>
               <a href="#jd_axis" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>
               </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
               <a href="#jd_axis" class="judgment"><term>axis</term></a> <code>descendant::</code> <a href="#jd_axis" class="judgment"><term>of</term></a>
               <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_axis" class="judgment"><term>=&gt;</term></a>
               <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
               <a href="#jd_axis" class="judgment"><term>axis</term></a> <code>descendant-or-self::</code> <a href="#jd_axis" class="judgment"><term>of</term></a>
               <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> <a href="#jd_axis" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>,
               <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>
              </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
               <a href="#jd_axis" class="judgment"><term>axis</term></a> <code>parent::</code> <a href="#jd_axis" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a>
               <a href="#jd_axis" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>
               </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
               <a href="#jd_axis" class="judgment"><term>axis</term></a> <code>ancestor::</code> <a href="#jd_axis" class="judgment"><term>of</term></a>
               <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_axis" class="judgment"><term>=&gt;</term></a>
               <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
               <a href="#jd_axis" class="judgment"><term>axis</term></a> <code>ancestor::</code> <a href="#jd_axis" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a>
               <a href="#jd_axis" class="judgment"><term>=&gt;</term></a>
               <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>, <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>
              </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
               <a href="#jd_axis" class="judgment"><term>axis</term></a> <code>self::</code> <a href="#jd_axis" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a>
               <a href="#jd_axis" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>
               </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><a href="#jd_axis" class="judgment"><term>axis</term></a> <code> ancestor::</code> <a href="#jd_axis" class="judgment"><term>of</term></a>
               <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_axis" class="judgment"><term>=&gt;</term></a>
               <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
               <a href="#jd_axis" class="judgment"><term>axis</term></a> <code>ancestor-or-self::</code> <a href="#jd_axis" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a>
               <a href="#jd_axis" class="judgment"><term>=&gt;</term></a>
               <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>, <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>
              </expression></clause></postjudge></infer></infergr><!--

MFF: sibling and preceding and following axes are normalized away.


          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment> <expression>
               &fn_root;(&gr_NodeValue;) &jd_yields; &gr_NodeValue1;
               </expression>
              </clause>
              <clause><environment>&xq_dyn_env;</environment> <expression>
               &fn_nodeequal;(&gr_NodeValue;, &gr_NodeValue1;) &jd_yields; false
               </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment>
               <expression>&jd_axis; <code> descendant-or-self::</code> &jd_axis_of;
               &gr_NodeValue1; &jd_axis_arrow;
               &gr_Value1; </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment>
               <expression>&gr_Value1; &jd_node_before; &gr_NodeValue;
               &jd_yields; &gr_Value2; </expression>
              </clause>
             </multiclause>

            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_axis; <code>preceding::</code> &jd_axis_of; &gr_NodeValue;
               &jd_axis_arrow; &gr_Value2;
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment> <expression>
               &fn_root;(&gr_NodeValue;) &jd_yields; &gr_NodeValue1;
               </expression>
              </clause>
              <clause><environment>&xq_dyn_env;</environment> <expression>
               &fn_nodeequal;(&gr_NodeValue;, &gr_NodeValue1;) &jd_yields; false
               </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment>
               <expression>&jd_axis; <code> descendant-or-self::</code> &jd_axis_of;
               &gr_NodeValue1; &jd_axis_arrow;
               &gr_Value1; </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment>
               <expression>&gr_Value1; &jd_node_after; &gr_NodeValue;
               &jd_yields; &gr_Value2; </expression>
              </clause>
             </multiclause>

            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_axis; <code>following::</code> &jd_axis_of; &gr_NodeValue;
               &jd_axis_arrow; &gr_Value2;
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment> <expression>
               &fn_root;(&gr_NodeValue;) &jd_yields; &gr_NodeValue1;
               </expression>
              </clause>
              <clause><environment>&xq_dyn_env;</environment> <expression>
               &fn_nodeequal;(&gr_NodeValue;, &gr_NodeValue1;) &jd_yields; true
               </expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_axis; (<code>following::</code> or
               <code>preceding::</code>) &jd_axis_of; &gr_NodeValue;
               &jd_axis_arrow; ()
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment> <expression>
               &jd_axis; <code>parent::</code> &jd_axis_of; &gr_NodeValue;
               &jd_axis_arrow; &gr_NodeValue1;
               </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment>
               <expression>&jd_axis; <code> child::</code> &jd_axis_of;
               &gr_NodeValue1; &jd_axis_arrow;
               &gr_Value1; </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment>
               <expression>&gr_Value1; &jd_node_before; &gr_NodeValue;
               &jd_yields; &gr_Value2; </expression>
              </clause>
             </multiclause>

            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_axis; <code>preceding-sibling::</code> &jd_axis_of; &gr_NodeValue;
               &jd_axis_arrow; &gr_Value2;
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment> <expression>
               &jd_axis; <code>parent::</code> &jd_axis_of; &gr_NodeValue;
               &jd_axis_arrow; &gr_NodeValue1;
               </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment>
               <expression>&jd_axis; <code> child::</code> &jd_axis_of;
               &gr_NodeValue1; &jd_axis_arrow;
               &gr_Value1; </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment>
               <expression>&gr_Value1; &jd_node_after; &gr_NodeValue;
               &jd_yields; &gr_Value2; </expression>
              </clause>
             </multiclause>

            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_axis; <code>following-sibling::</code> &jd_axis_of; &gr_NodeValue;
               &jd_axis_arrow; &gr_Value2;
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment> <expression>
               &jd_axis; <code>parent::</code> &jd_axis_of; &gr_NodeValue;
               &jd_axis_arrow; ()
               </expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_axis; (<code>following-sibling::</code>
               or <code>preceding-sibling::</code>) &jd_axis_of; &gr_NodeValue;
               &jd_axis_arrow; ()
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
--><p>In all the other cases, the axis application results in
          an empty sequence, and the following judgment holds.</p><display diff="del" at="E034">
           <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
             <a href="#jd_axis" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a>
             <a href="#jd_axis" class="judgment"><term>=&gt;</term></a> ()
            </expression></clause>
          </display><infergr diff="add" at="E034"><infer><prejudge><clause><expression><emph>Otherwise</emph></expression></clause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
                    <a href="#jd_axis" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a>
                    <a href="#jd_axis" class="judgment"><term>=&gt;</term></a> ()
                  </expression></clause></postjudge></infer></infergr></smrules></div4></div3><div3 id="sec_test_judge"><head>Auxiliary judgments for node tests</head><p>A node test may be a name test or a kind test.  In the static
      and dynamic semantics, we begin with name tests, followed by
      kind tests. </p><div4 id="sec_sem_node_tests"><head>Static semantics of node tests</head><smnotation><p id="jd_test_type">The following judgment</p><display>
           <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test_type" class="judgment"><term>with</term></a>
             <emph>PrincipalNodeKind</emph> <a href="#jd_test_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
             <a href="#jd_test_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
            </expression></clause>
          </display><p>holds when applying the node test <emph>NodeTest</emph> on the
          type <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> in the context of the given principal node
          kind, yields the type <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>.</p></smnotation><smexample><p>For example, assuming the extended XML Schema given in
          section <specref ref="sec_types_example"/>, then the
          following judgments hold.</p><eg xml:space="preserve">
  test shipTo with element of
    element shipTo of type USAddress,
    element billTo of type USAddress,
    element ipo:comment?,
    element items of type Items
  : element shipTo of type USAddress
</eg></smexample><smrules><p>This judgment is specified by the following rules.</p><p>The first set of rules is similar to that for axes, and
          are used to process the content each individual item type in
          the input content model.</p><infergr><infer><prejudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
              <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test_type" class="judgment"><term>with</term></a>
              <emph>PrincipalNodeKind</emph> <a href="#jd_test_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
              <a href="#jd_test_type" class="judgment"><term>:</term></a>  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
             </expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
              <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test_type" class="judgment"><term>with</term></a>
              <emph>PrincipalNodeKind</emph> <a href="#jd_test_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <emph>OccurrenceIndicator</emph>
              <a href="#jd_test_type" class="judgment"><term>:</term></a>  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <emph>OccurrenceIndicator</emph>
             </expression></clause></postjudge></infer></infergr><!-- T1 & T2 --><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
              <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test_type" class="judgment"><term>with</term></a>
              <emph>PrincipalNodeKind</emph> <a href="#jd_test_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
              <a href="#jd_test_type" class="judgment"><term>:</term></a>  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript>
             </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
              <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test_type" class="judgment"><term>with</term></a>
              <emph>PrincipalNodeKind</emph> <a href="#jd_test_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
              <a href="#jd_test_type" class="judgment"><term>:</term></a>  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>4</subscript>
             </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
              <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test_type" class="judgment"><term>with</term></a>
              <emph>PrincipalNodeKind</emph> <a href="#jd_test_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
              &amp; <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
              <a href="#jd_test_type" class="judgment"><term>:</term></a>  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript> &amp; <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>4</subscript> 
             </expression></clause></postjudge></infer></infergr><!-- T1 , T2 --><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
              <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test_type" class="judgment"><term>with</term></a>
              <emph>PrincipalNodeKind</emph> <a href="#jd_test_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
              <a href="#jd_test_type" class="judgment"><term>:</term></a>  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript>
             </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
              <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test_type" class="judgment"><term>with</term></a>
              <emph>PrincipalNodeKind</emph> <a href="#jd_test_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
              <a href="#jd_test_type" class="judgment"><term>:</term></a>  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>4</subscript>
             </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
              <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test_type" class="judgment"><term>with</term></a>
              <emph>PrincipalNodeKind</emph> <a href="#jd_test_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> , <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
              <a href="#jd_test_type" class="judgment"><term>:</term></a>  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript> , <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>4</subscript> 
             </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
              <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test_type" class="judgment"><term>with</term></a>
              <emph>PrincipalNodeKind</emph> <a href="#jd_test_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
              <a href="#jd_test_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript>
             </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
              <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test_type" class="judgment"><term>with</term></a>
              <emph>PrincipalNodeKind</emph> <a href="#jd_test_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
              <a href="#jd_test_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>4</subscript>
              </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
              <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test_type" class="judgment"><term>with</term></a>
              <emph>PrincipalNodeKind</emph> <a href="#jd_test_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>|<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
              <a href="#jd_test_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript>|<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>4</subscript>
             </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><clause><expression>  </expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
              <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test_type" class="judgment"><term>with</term></a>
              <emph>PrincipalNodeKind</emph> <a href="#jd_test_type" class="judgment"><term>of</term></a> none
              <a href="#jd_test_type" class="judgment"><term>:</term></a> none
             </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><clause><expression>  </expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
              <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test_type" class="judgment"><term>with</term></a>
              <emph>PrincipalNodeKind</emph> <a href="#jd_test_type" class="judgment"><term>of</term></a> empty
              <a href="#jd_test_type" class="judgment"><term>:</term></a> empty
             </expression></clause></postjudge></infer></infergr></smrules><p>The following rules specify how the test judgment apply to
      node tests in the context of a principal node kind.  We start
      with name tests followed by kind tests.</p><div5 id="sec_sem_name_tests"><head>Name Tests</head><p>Name tests on elements and attributes always compute the most
      specific type possible. For example, if <code>$v</code> is bound
      to an element with a computed name, the type of <code>$v</code>
      is <code>element</code>. The static type computed for the
      expression <code>$v/self::foo</code> is <code>element foo of
      type xs:anyType</code>, which makes use of <code>foo</code> in
      the name test to compute a more specific type.  Also note that
      each case of name matching restricts the principal node kind
      appropriately.</p><!-- Name tests of the form QName --><!-- rule #1 in REC --><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <emph>QName</emph><subscript>1</subscript> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <emph>QName</emph><subscript>2</subscript> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>QName</emph><subscript>2</subscript>
             <a href="#jd_test_type" class="judgment"><term>with</term></a> element <a href="#jd_test_type" class="judgment"><term>of</term></a> element
             <emph>QName</emph><subscript>1</subscript> <a href="#doc-fs-OptTypeSpecifier"><emph>OptTypeSpecifier</emph></a> <a href="#jd_test_type" class="judgment"><term>:</term></a>
             element <emph>QName</emph><subscript>1</subscript> <a href="#doc-fs-OptTypeSpecifier"><emph>OptTypeSpecifier</emph></a> </expression></clause></postjudge></infer></infergr><infergr diff="add" at="E018:13"><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                    <emph>QName</emph><subscript>1</subscript> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript>
                  </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                    <emph>QName</emph><subscript>2</subscript> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>2</subscript>
                  </expression></clause></multiclause><multiclause><clause><expression>
                    <a href="#jd_not" class="judgment"><term>not</term></a>( <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript> = <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>2</subscript> )
                  </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                    <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>QName</emph><subscript>2</subscript>
                    <a href="#jd_test_type" class="judgment"><term>with</term></a> element
                    <a href="#jd_test_type" class="judgment"><term>of</term></a> element <emph>QName</emph><subscript>1</subscript> <a href="#doc-fs-OptTypeSpecifier"><emph>OptTypeSpecifier</emph></a><subscript>1</subscript>
                    <a href="#jd_test_type" class="judgment"><term>:</term></a> empty
                  </expression></clause></multiclause></postjudge></infer></infergr><!-- rule #2 in REC --><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>QName</emph><subscript>2</subscript> <a href="#jd_test_type" class="judgment"><term>with</term></a>
             element <a href="#jd_test_type" class="judgment"><term>of</term></a> element
             <code>*</code> <a href="#doc-fs-OptTypeSpecifier"><emph>OptTypeSpecifier</emph></a>
             <a href="#jd_test_type" class="judgment"><term>:</term></a> element <emph>QName</emph><subscript>2</subscript>
             <a href="#doc-fs-OptTypeSpecifier"><emph>OptTypeSpecifier</emph></a>
             <phrase diff="add" at="E018:2">?</phrase>
            </expression></clause></postjudge></infer></infergr><!-- rule #3 in REC --><infergr diff="del" at="E018:27"><infer><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>QName</emph><subscript>2</subscript> <a href="#jd_test_type" class="judgment"><term>with</term></a> element
             <a href="#jd_test_type" class="judgment"><term>of</term></a> element <a href="#doc-fs-OptTypeSpecifier"><emph>OptTypeSpecifier</emph></a> <a href="#jd_test_type" class="judgment"><term>:</term></a>
             element <emph>QName</emph><subscript>2</subscript> <a href="#doc-fs-OptTypeSpecifier"><emph>OptTypeSpecifier</emph></a>
            </expression></clause></postjudge></infer></infergr><!-- Name tests of the form *:LocalPart --><!-- rule #4 in REC --><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <emph>QName</emph><subscript>1</subscript> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript>
           </expression></clause></multiclause><multiclause diff="del" at="E018:9"><clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a>(<emph>Prefix</emph><subscript>1</subscript>) = (<a href="#xq_ns_env"><emph>NamespaceKind</emph></a>,<emph>AnyURI</emph>)</expression></clause></multiclause><multiclause diff="del" at="E018:9"><clause><expression><code>fn:namespace-uri-from-QName</code>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript>) = <emph>AnyURI</emph></expression></clause></multiclause><multiclause><clause><expression><emph>LocalPart</emph><subscript>2</subscript> = <code>fn:local-name-from-QName</code>( <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript> )</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <a href="#jd_test_type" class="judgment"><term>test</term></a> <code>*:</code><emph>LocalPart</emph><subscript>2</subscript>
             <a href="#jd_test_type" class="judgment"><term>with</term></a> element
             <a href="#jd_test_type" class="judgment"><term>of</term></a> element
             <emph>QName</emph><subscript>1</subscript> <a href="#doc-fs-OptTypeSpecifier"><emph>OptTypeSpecifier</emph></a>
             <a href="#jd_test_type" class="judgment"><term>:</term></a> element
             <emph>QName</emph><subscript>1</subscript> <a href="#doc-fs-OptTypeSpecifier"><emph>OptTypeSpecifier</emph></a>
            </expression></clause></postjudge></infer></infergr><infergr diff="add" at="E018:14"><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                    <emph>QName</emph><subscript>1</subscript> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript>
                  </expression></clause></multiclause><multiclause><clause><expression>
                    <code>fn:local-name-from-QName</code>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript>) = <emph>LocalPart</emph><subscript>1</subscript>
                  </expression></clause></multiclause><multiclause><clause><expression>
                    <a href="#jd_not" class="judgment"><term>not</term></a>( <emph>LocalPart</emph><subscript>1</subscript> = <emph>LocalPart</emph><subscript>2</subscript> )
                  </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                    <a href="#jd_test_type" class="judgment"><term>test</term></a> *:<emph>LocalPart</emph><subscript>2</subscript>
                    <a href="#jd_test_type" class="judgment"><term>with</term></a> element
                    <a href="#jd_test_type" class="judgment"><term>of</term></a> element <emph>QName</emph><subscript>1</subscript> <a href="#doc-fs-OptTypeSpecifier"><emph>OptTypeSpecifier</emph></a><subscript>1</subscript>
                    <a href="#jd_test_type" class="judgment"><term>:</term></a> empty
                  </expression></clause></multiclause></postjudge></infer></infergr><!-- rule #5 in REC --><infergr><infer><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <a href="#jd_test_type" class="judgment"><term>test</term></a> <code>*:</code><emph>LocalPart</emph><subscript>2</subscript>
             <a href="#jd_test_type" class="judgment"><term>with</term></a> element
             <a href="#jd_test_type" class="judgment"><term>of</term></a> element * <a href="#doc-fs-OptTypeSpecifier"><emph>OptTypeSpecifier</emph></a>
             <a href="#jd_test_type" class="judgment"><term>:</term></a> element
             <phrase diff="chg" at="E018:3">*</phrase>
             <a href="#doc-fs-OptTypeSpecifier"><emph>OptTypeSpecifier</emph></a>
             <phrase diff="add" at="E018:3">?</phrase>
            </expression></clause></postjudge></infer><!-- Name tests of the form Prefix:* --><!-- rule #6 in REC --><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <emph>QName</emph><subscript>1</subscript> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript>
           </expression></clause></multiclause><multiclause><clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a>(<phrase diff="chg" at="E018:10"><emph>Prefix</emph><subscript>2</subscript></phrase>) = (<a href="#xq_ns_env"><emph>NamespaceKind</emph></a>,<emph>AnyURI</emph>)</expression></clause></multiclause><multiclause><clause><expression><code>fn:namespace-uri-from-QName</code>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript>) = <emph>AnyURI</emph></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>Prefix</emph><subscript>2</subscript>:*
             <a href="#jd_test_type" class="judgment"><term>with</term></a> element
             <a href="#jd_test_type" class="judgment"><term>of</term></a> element
             <emph>QName</emph><subscript>1</subscript> <a href="#doc-fs-OptTypeSpecifier"><emph>OptTypeSpecifier</emph></a>
             <a href="#jd_test_type" class="judgment"><term>:</term></a> element
             <emph>QName</emph><subscript>1</subscript> <a href="#doc-fs-OptTypeSpecifier"><emph>OptTypeSpecifier</emph></a>
            </expression></clause></postjudge></infer></infergr><infergr diff="add" at="E018:15"><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                    <emph>QName</emph><subscript>1</subscript> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript>
                  </expression></clause></multiclause><multiclause><clause><expression>
                    <code>fn:namespace-uri-from-QName</code>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript>) = <emph>AnyURI</emph><subscript>1</subscript>
                  </expression></clause></multiclause><multiclause><clause><expression>
                    <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a>(<emph>Prefix</emph><subscript>2</subscript>) = (<a href="#xq_ns_env"><emph>NamespaceKind</emph></a>,<emph>AnyURI</emph><subscript>2</subscript>)
                  </expression></clause></multiclause><multiclause><clause><expression>
                    <a href="#jd_not" class="judgment"><term>not</term></a>( <emph>AnyURI</emph><subscript>1</subscript> = <emph>AnyURI</emph><subscript>2</subscript> )
                  </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                    <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>Prefix</emph><subscript>2</subscript>:*
                    <a href="#jd_test_type" class="judgment"><term>with</term></a> element
                    <a href="#jd_test_type" class="judgment"><term>of</term></a> element <emph>QName</emph><subscript>1</subscript> <a href="#doc-fs-OptTypeSpecifier"><emph>OptTypeSpecifier</emph></a><subscript>1</subscript>
                    <a href="#jd_test_type" class="judgment"><term>:</term></a> empty 
                  </expression></clause></multiclause></postjudge></infer></infergr><!-- rule #7 in REC --><infergr><infer><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>Prefix</emph><subscript>2</subscript><code>:*</code>
             <a href="#jd_test_type" class="judgment"><term>with</term></a> element
             <a href="#jd_test_type" class="judgment"><term>of</term></a> element * <a href="#doc-fs-OptTypeSpecifier"><emph>OptTypeSpecifier</emph></a> <a href="#jd_test_type" class="judgment"><term>:</term></a>
             element
             <phrase diff="chg" at="E018:4">*</phrase>
             <a href="#doc-fs-OptTypeSpecifier"><emph>OptTypeSpecifier</emph></a>
             <phrase diff="add" at="E018:4">?</phrase>
            </expression></clause></postjudge></infer></infergr><!-- Name tests of the form * --><!-- rule #8 in REC --><infergr><infer><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <a href="#jd_test_type" class="judgment"><term>test</term></a> <code>*</code>
             <a href="#jd_test_type" class="judgment"><term>with</term></a> element
             <a href="#jd_test_type" class="judgment"><term>of</term></a>
             <phrase diff="chg" at="E018:21"><a href="#doc-fs-ElementType"><emph>ElementType</emph></a></phrase> <a href="#jd_test_type" class="judgment"><term>:</term></a>
             <phrase diff="chg" at="E018:21"><a href="#doc-fs-ElementType"><emph>ElementType</emph></a></phrase>
            </expression></clause></postjudge></infer></infergr><!-- Name tests in general --><infergr diff="add" at="E018:24"><infer><prejudge><clause><expression>
                  <a href="#jd_not" class="judgment"><term>not</term></a>( <a href="#doc-fs-Type"><emph>Type</emph></a> is an element type )
                </expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                  <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>NameTest</emph>
                  <a href="#jd_test_type" class="judgment"><term>with</term></a> element
                  <a href="#jd_test_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
                  <a href="#jd_test_type" class="judgment"><term>:</term></a> empty
                </expression></clause></postjudge></infer></infergr><p>Similar static typing rules apply to the attribute name
     tests:</p><!-- Name tests of the form QName --><!-- rule #9 in REC --><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <emph>QName</emph><subscript>1</subscript> <a href="#jd_attr_qname_expands_to" class="judgment"><term>of attr expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <emph>QName</emph><subscript>2</subscript> <a href="#jd_attr_qname_expands_to" class="judgment"><term>of attr expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
          <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>QName</emph><subscript>2</subscript>
          <a href="#jd_test_type" class="judgment"><term>with</term></a> attribute
          <a href="#jd_test_type" class="judgment"><term>of</term></a> attribute
          <emph>QName</emph><subscript>1</subscript> <a href="#doc-fs-OptTypeReference"><emph>OptTypeReference</emph></a>
          <a href="#jd_test_type" class="judgment"><term>:</term></a> attribute
          <emph>QName</emph><subscript>1</subscript> <a href="#doc-fs-OptTypeReference"><emph>OptTypeReference</emph></a>
         </expression></clause></postjudge></infer></infergr><infergr diff="add" at="E018:16"><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                    <emph>QName</emph><subscript>1</subscript> <a href="#jd_attr_qname_expands_to" class="judgment"><term>of attr expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript>
                  </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                    <emph>QName</emph><subscript>2</subscript> <a href="#jd_attr_qname_expands_to" class="judgment"><term>of attr expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>2</subscript>
                  </expression></clause></multiclause><multiclause><clause><expression>
                    <a href="#jd_not" class="judgment"><term>not</term></a>( <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript> = <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>2</subscript> )
                  </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                    <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>QName</emph><subscript>2</subscript>
                    <a href="#jd_test_type" class="judgment"><term>with</term></a> attribute
                    <a href="#jd_test_type" class="judgment"><term>of</term></a> attribute <emph>QName</emph><subscript>1</subscript> <a href="#doc-fs-OptTypeReference"><emph>OptTypeReference</emph></a>
                    <a href="#jd_test_type" class="judgment"><term>:</term></a> empty
                  </expression></clause></multiclause></postjudge></infer></infergr><!-- rule #10 in REC --><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
          <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>QName</emph><subscript>2</subscript>
          <a href="#jd_test_type" class="judgment"><term>with</term></a> attribute
          <a href="#jd_test_type" class="judgment"><term>of</term></a> attribute
          <code>*</code> <a href="#doc-fs-OptTypeReference"><emph>OptTypeReference</emph></a>
          <a href="#jd_test_type" class="judgment"><term>:</term></a> attribute
          <emph>QName</emph><subscript>2</subscript> <a href="#doc-fs-OptTypeReference"><emph>OptTypeReference</emph></a>
          <phrase diff="add" at="E018:5">?</phrase>
         </expression></clause></postjudge></infer></infergr><!-- rule #11 in REC --><infergr diff="del" at="E018:28"><infer><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
          <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>QName</emph><subscript>2</subscript>
          <a href="#jd_test_type" class="judgment"><term>with</term></a> attribute
          <a href="#jd_test_type" class="judgment"><term>of</term></a> attribute <a href="#doc-fs-OptTypeReference"><emph>OptTypeReference</emph></a>
          <a href="#jd_test_type" class="judgment"><term>:</term></a> attribute
          <emph>QName</emph><subscript>2</subscript> <a href="#doc-fs-OptTypeReference"><emph>OptTypeReference</emph></a>
         </expression></clause></postjudge></infer></infergr><!-- Name tests of the form *:LocalPart --><!-- rule #12 in REC --><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <emph>QName</emph><subscript>1</subscript> <a href="#jd_attr_qname_expands_to" class="judgment"><term>of attr expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript>
           </expression></clause></multiclause><multiclause><clause><expression><code>fn:local-name-from-QName</code>( <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript> ) = <emph>LocalPart</emph><subscript>2</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
          <a href="#jd_test_type" class="judgment"><term>test</term></a> <code>*:</code><emph>LocalPart</emph><subscript>2</subscript>
          <a href="#jd_test_type" class="judgment"><term>with</term></a> attribute
          <a href="#jd_test_type" class="judgment"><term>of</term></a> attribute
          <emph>QName</emph><subscript>1</subscript> <a href="#doc-fs-OptTypeReference"><emph>OptTypeReference</emph></a>
          <a href="#jd_test_type" class="judgment"><term>:</term></a> attribute
          <emph>QName</emph><subscript>1</subscript> <a href="#doc-fs-OptTypeReference"><emph>OptTypeReference</emph></a>
         </expression></clause></postjudge></infer></infergr><infergr diff="add" at="E018:17"><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                    <emph>QName</emph><subscript>1</subscript> <a href="#jd_attr_qname_expands_to" class="judgment"><term>of attr expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript>
                  </expression></clause></multiclause><multiclause><clause><expression>
                    <code>fn:local-name-from-QName</code>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript>) = <emph>LocalPart</emph><subscript>1</subscript>
                  </expression></clause></multiclause><multiclause><clause><expression>
                    <a href="#jd_not" class="judgment"><term>not</term></a>( <emph>LocalPart</emph><subscript>1</subscript> = <emph>LocalPart</emph><subscript>2</subscript> )
                  </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                    <a href="#jd_test_type" class="judgment"><term>test</term></a> *:<emph>LocalPart</emph><subscript>2</subscript>
                    <a href="#jd_test_type" class="judgment"><term>with</term></a> attribute
                    <a href="#jd_test_type" class="judgment"><term>of</term></a> attribute <emph>QName</emph><subscript>1</subscript> <a href="#doc-fs-OptTypeReference"><emph>OptTypeReference</emph></a>
                    <a href="#jd_test_type" class="judgment"><term>:</term></a> empty
                  </expression></clause></multiclause></postjudge></infer></infergr><!-- rule #13 in REC --><infergr><infer><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
          <a href="#jd_test_type" class="judgment"><term>test</term></a> <code>*:</code><emph>LocalPart</emph><subscript>2</subscript>
          <a href="#jd_test_type" class="judgment"><term>with</term></a> attribute
          <a href="#jd_test_type" class="judgment"><term>of</term></a> attribute * <a href="#doc-fs-OptTypeReference"><emph>OptTypeReference</emph></a>
          <a href="#jd_test_type" class="judgment"><term>:</term></a> attribute
          <phrase diff="chg" at="E018:6">*</phrase>
          <a href="#doc-fs-OptTypeReference"><emph>OptTypeReference</emph></a>
          <phrase diff="add" at="E018:6">?</phrase>
         </expression></clause></postjudge></infer></infergr><!-- Name tests of the form Prefix:* --><!-- rule #14 in REC --><infergr><infer><prejudge><multiclause><clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a>(<emph>Prefix</emph><subscript>2</subscript>) = (<a href="#xq_ns_env"><emph>NamespaceKind</emph></a>,<emph>AnyURI</emph>)</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <emph>QName</emph><subscript>1</subscript> <phrase diff="chg" at="E018:11"><a href="#jd_attr_qname_expands_to" class="judgment"><term>of attr expands to</term></a></phrase> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript>
           </expression></clause></multiclause><multiclause><clause><expression><code>fn:namespace-uri-from-QName</code>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript>) = <emph>AnyURI</emph></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
          <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>Prefix</emph><subscript>2</subscript><code>:*</code>
          <a href="#jd_test_type" class="judgment"><term>with</term></a> attribute
          <a href="#jd_test_type" class="judgment"><term>of</term></a> attribute
          <emph>QName</emph><subscript>1</subscript> <a href="#doc-fs-OptTypeReference"><emph>OptTypeReference</emph></a>
          <a href="#jd_test_type" class="judgment"><term>:</term></a> attribute
          <emph>QName</emph><subscript>1</subscript> <a href="#doc-fs-OptTypeReference"><emph>OptTypeReference</emph></a>
         </expression></clause></postjudge></infer></infergr><infergr diff="add" at="E018:18"><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                    <emph>QName</emph><subscript>1</subscript> <a href="#jd_attr_qname_expands_to" class="judgment"><term>of attr expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript>
                  </expression></clause></multiclause><multiclause><clause><expression>
                    <code>fn:namespace-uri-from-QName</code>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript>) = <emph>AnyURI</emph><subscript>1</subscript>
                  </expression></clause></multiclause><multiclause><clause><expression>
                    <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a>(<emph>Prefix</emph><subscript>2</subscript>) = (<a href="#xq_ns_env"><emph>NamespaceKind</emph></a>,<emph>AnyURI</emph><subscript>2</subscript>)
                  </expression></clause></multiclause><multiclause><clause><expression>
                    <a href="#jd_not" class="judgment"><term>not</term></a>( <emph>AnyURI</emph><subscript>1</subscript> = <emph>AnyURI</emph><subscript>2</subscript> )
                  </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                    <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>Prefix</emph><subscript>2</subscript>:*
                    <a href="#jd_test_type" class="judgment"><term>with</term></a> attribute
                    <a href="#jd_test_type" class="judgment"><term>of</term></a> attribute <emph>QName</emph><subscript>1</subscript> <a href="#doc-fs-OptTypeReference"><emph>OptTypeReference</emph></a>
                    <a href="#jd_test_type" class="judgment"><term>:</term></a> empty 
                  </expression></clause></multiclause></postjudge></infer></infergr><!-- rule #15 in REC --><infergr><infer><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
          <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>Prefix</emph><subscript>2</subscript><code>:*</code>
          <a href="#jd_test_type" class="judgment"><term>with</term></a> attribute
          <a href="#jd_test_type" class="judgment"><term>of</term></a> attribute * <a href="#doc-fs-OptTypeReference"><emph>OptTypeReference</emph></a>
          <a href="#jd_test_type" class="judgment"><term>:</term></a> attribute
          <phrase diff="chg" at="E018:7">*</phrase>
          <a href="#doc-fs-OptTypeReference"><emph>OptTypeReference</emph></a>
          <phrase diff="add" at="E018:7">?</phrase>
         </expression></clause></postjudge></infer></infergr><!-- Name tests of the form * --><!-- rule #16 in REC --><infergr><infer><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
          <a href="#jd_test_type" class="judgment"><term>test</term></a> <code>*</code> <a href="#jd_test_type" class="judgment"><term>with</term></a> attribute
          <a href="#jd_test_type" class="judgment"><term>of</term></a> <phrase diff="chg" at="E018:22"><a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a></phrase>
          <a href="#jd_test_type" class="judgment"><term>:</term></a> <phrase diff="chg" at="E018:22"><a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a></phrase>
         </expression></clause></postjudge></infer></infergr><!-- Name tests in general --><infergr diff="add" at="E018:25"><infer><prejudge><clause><expression>
                  <a href="#jd_not" class="judgment"><term>not</term></a>( <a href="#doc-fs-Type"><emph>Type</emph></a> is an attribute type )
                </expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                  <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>NameTest</emph>
                  <a href="#jd_test_type" class="judgment"><term>with</term></a> attribute
                  <a href="#jd_test_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
                  <a href="#jd_test_type" class="judgment"><term>:</term></a> empty
                </expression></clause></postjudge></infer></infergr><!-- rule #17 in REC --><p diff="del" at="E018:19">Lastly, if none of the above rules holds, then the type
          of the input expression is empty.</p><infergr diff="del" at="E018:19"><infer><prejudge><multiclause><clause><expression><a href="#doc-xquery-ElementNameOrWildcard"><emph>ElementNameOrWildcard</emph></a><subscript>1</subscript> = <emph>NameTest</emph></expression></clause></multiclause><multiclause><clause><expression><a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>1</subscript> = of type <code>xs:anyType</code></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_not" class="judgment"><term>not</term></a>(element <a href="#doc-xquery-ElementNameOrWildcard"><emph>ElementNameOrWildcard</emph></a><subscript>1</subscript>
               <a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> element <a href="#doc-xquery-ElementNameOrWildcard"><emph>ElementNameOrWildcard</emph></a><subscript>2</subscript> <a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>2</subscript>)
               </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_not" class="judgment"><term>not</term></a>(element <a href="#doc-xquery-ElementNameOrWildcard"><emph>ElementNameOrWildcard</emph></a><subscript>2</subscript>
               <a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> element <a href="#doc-xquery-ElementNameOrWildcard"><emph>ElementNameOrWildcard</emph></a><subscript>1</subscript> <a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>1</subscript>)
               </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>1</subscript> <a href="#jd_expands_to" class="judgment"><term>expands to</term></a>
              <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>2</subscript> <a href="#jd_expands_to" class="judgment"><term>expands to</term></a>
              <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_not" class="judgment"><term>not</term></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
               <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)
               </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_not" class="judgment"><term>not</term></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
               <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)
               </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
               <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>NameTest</emph>
               <a href="#jd_test_type" class="judgment"><term>with</term></a> element
               <a href="#jd_test_type" class="judgment"><term>of</term></a> element <a href="#doc-xquery-ElementNameOrWildcard"><emph>ElementNameOrWildcard</emph></a><subscript>2</subscript> <a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>2</subscript>
               <a href="#jd_test_type" class="judgment"><term>:</term></a> empty
              </expression></clause></postjudge></infer></infergr></div5><div5 id="sec_sem_kind_tests"><head>Kind Tests</head><p>All the rules for typing the document, element, and attribute
    kind tests are similar.  First, the document, element, or
    attribute test is normalized to the equivalent document, element,
    or attribute type by applying the <map/><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
    normalization rule to the kind test.</p><p>After normalization of the kind test as an XQuery type, that
    type is compared to the expression's inferred type. If the latter
    is a subtype of the former other, then the kind test yields the
    smaller type.</p><p><b><emph>Document kind test</emph></b></p><smrules><p>If the type of the expression is a subtype of the document
      kind test, then we are guaranteed that during evaluation, the
      expression's value will always match the document kind test, and
      therefore the type of the entire expression is the type of the
      input expression.</p><infergr><infer><prejudge><multiclause><clause><expression><map><emph>DocumentTest</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
            = <a href="#doc-fs-DocumentType"><emph>DocumentType</emph></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-DocumentType"><emph>DocumentType</emph></a></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
           <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>DocumentTest</emph>
           <a href="#jd_test_type" class="judgment"><term>with</term></a> element
           <a href="#jd_test_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> 
           <a href="#jd_test_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> 
          </expression></clause></postjudge></infer></infergr><p>Conversely, if the type of the document kind test is a
      subtype of the expression, then during evaluation, the
      expression's value may or may not match the document kind test,
      and therefore the type of the entire expression is zero-or-one
      of the type of the document kind test. </p><infergr><infer><prejudge><multiclause><clause><expression><map><emph>DocumentTest</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
            = <a href="#doc-fs-DocumentType"><emph>DocumentType</emph></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-DocumentType"><emph>DocumentType</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
           <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>DocumentTest</emph>
           <a href="#jd_test_type" class="judgment"><term>with</term></a> element
           <a href="#jd_test_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> 
           <a href="#jd_test_type" class="judgment"><term>:</term></a> <a href="#doc-fs-DocumentType"><emph>DocumentType</emph></a>?
          </expression></clause></postjudge></infer></infergr><p>If the types of the expression and document kind test are
      unrelated, then we apply the kind test rule recursively on the
      element types, which may yield a non-empty type.</p><infergr><infer><prejudge><multiclause><clause><expression><map>document-node (<emph>ElementTest</emph>)</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                = <a href="#doc-fs-DocumentType"><emph>DocumentType</emph></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_not" class="judgment"><term>not</term></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
               <a href="#doc-fs-DocumentType"><emph>DocumentType</emph></a>)</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_not" class="judgment"><term>not</term></a>(<a href="#doc-fs-DocumentType"><emph>DocumentType</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
               <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>ElementTest</emph>
               <a href="#jd_test_type" class="judgment"><term>with</term></a> element
               <a href="#jd_test" class="judgment"><term>of</term></a>  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> 
               <a href="#jd_test_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
               </expression></clause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                <a href="#jd_not" class="judgment"><term>not</term></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <code>empty</code>)
               </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
               <a href="#jd_test_type" class="judgment"><term>test</term></a> document-node (<emph>ElementTest</emph>)
               <a href="#jd_test_type" class="judgment"><term>with</term></a> element
               <a href="#jd_test" class="judgment"><term>of</term></a> document { <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> }
               <a href="#jd_test_type" class="judgment"><term>:</term></a> document { <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> }
              </expression></clause></postjudge></infer></infergr><p>If there is no non-empty type, then the kind test yields
          the empty type.</p><infergr><infer><prejudge><multiclause><clause><expression><map>document-node (<emph>ElementTest</emph>)</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                = <a href="#doc-fs-DocumentType"><emph>DocumentType</emph></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_not" class="judgment"><term>not</term></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
               <a href="#doc-fs-DocumentType"><emph>DocumentType</emph></a>)</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_not" class="judgment"><term>not</term></a>(<a href="#doc-fs-DocumentType"><emph>DocumentType</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
               <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>ElementTest</emph>
               <a href="#jd_test_type" class="judgment"><term>with</term></a> element
               <a href="#jd_test" class="judgment"><term>of</term></a>  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> 
               <a href="#jd_test_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
               </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <code>empty</code></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
               <a href="#jd_test_type" class="judgment"><term>test</term></a> document-node (<emph>ElementTest</emph>)
               <a href="#jd_test_type" class="judgment"><term>with</term></a> element
               <a href="#jd_test" class="judgment"><term>of</term></a> document { <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> }
               <a href="#jd_test_type" class="judgment"><term>:</term></a> empty
              </expression></clause></postjudge></infer></infergr></smrules><p><b><emph>Element kind test</emph></b></p><smrules><p>The rules for the element kind test are similar to those for
     the document kind test.</p><p>If the type of the expression is a
     subtype of the element kind test, then we are guaranteed that
     during evaluation, the expression's element value will always
     match the element kind test, and therefore the type of the entire
     expression is the type of the input expression.</p><infergr><infer><prejudge><multiclause><clause><expression><map><emph>ElementTest</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                = <a href="#doc-fs-ElementType"><emph>ElementType</emph></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-ElementType"><emph>ElementType</emph></a></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
               <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>ElementTest</emph>
               <a href="#jd_test_type" class="judgment"><term>with</term></a> element
               <a href="#jd_test_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> 
               <a href="#jd_test_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> 
              </expression></clause></postjudge></infer></infergr><p>Conversely, if the type of the element kind test is a
          subtype of the expression, then during evaluation, the
          expression's element value may or may not match the element
          kind test, and therefore the type of the entire expression
          is zero-or-one of the type of the element kind test. </p><infergr><infer><prejudge><multiclause><clause><expression><map><emph>ElementTest</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                = <a href="#doc-fs-ElementType"><emph>ElementType</emph></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-ElementType"><emph>ElementType</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
               <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>ElementTest</emph>
               <a href="#jd_test_type" class="judgment"><term>with</term></a> element
               <a href="#jd_test_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> 
               <a href="#jd_test_type" class="judgment"><term>:</term></a> <a href="#doc-fs-ElementType"><emph>ElementType</emph></a>?
              </expression></clause></postjudge></infer></infergr><p>If the types of the expression and element kind test are
          unrelated (i.e., neither type is a subtype of the other),
          then we must compare the structure of the type of the
          element test with the type of the element expression, as an
          element type or test may contain wildcards.</p><p>In the first case, the element kind test contains an
          element name and a type name and the input expression's type
          contains only a type name.  If the input expression's
          content type is a subtype of the element kind test's content
          type, then the type of the entire expression is zero-or-one
          of an element with the given name and the input expression's
          content type.</p><infergr><infer><prejudge><multiclause><clause><expression><map><emph>ElementTest</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                = element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>1</subscript> <a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>1</subscript></expression></clause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>1</subscript> <a href="#jd_expands_to" class="judgment"><term>expands to</term></a>
              <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>2</subscript> <a href="#jd_expands_to" class="judgment"><term>expands to</term></a>
              <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
               <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>ElementTest</emph>
               <a href="#jd_test_type" class="judgment"><term>with</term></a> element
               <a href="#jd_test_type" class="judgment"><term>of</term></a> element<phrase diff="add" at="E023"> *</phrase> <a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>2</subscript>
               <a href="#jd_test_type" class="judgment"><term>:</term></a> element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>1</subscript>
               <a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>2</subscript>? 
              </expression></clause></postjudge></infer></infergr><p>In the second case, the structure of the input types is
          reversed: The input expression's type contains an element
          name and a type name and the element kind test's type
          contains only a type name.  If the element kind test's
          content type is a subtype of the input expression's content
          type, then the type of the entire expression is zero-or-one
          of an element with the given name and the element kind
          test's content type.</p><infergr><infer><prejudge><multiclause><clause><expression><map><emph>ElementTest</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                = element<phrase diff="add" at="E023"> *</phrase> <a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>1</subscript></expression></clause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>1</subscript> <a href="#jd_expands_to" class="judgment"><term>expands to</term></a>
              <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>2</subscript> <a href="#jd_expands_to" class="judgment"><term>expands to</term></a>
              <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
               <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>ElementTest</emph>
               <a href="#jd_test_type" class="judgment"><term>with</term></a> element
               <a href="#jd_test_type" class="judgment"><term>of</term></a> element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>2</subscript> <a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>2</subscript>
               <a href="#jd_test_type" class="judgment"><term>:</term></a> element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>2</subscript>
               <a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>1</subscript>? 
              </expression></clause></postjudge></infer></infergr><p>Lastly, if none of the above rules holds, then the type
          of the input expression is empty.</p><infergr><infer><prejudge><multiclause><clause><expression><map><emph>ElementTest</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                = element <a href="#doc-xquery-ElementNameOrWildcard"><emph>ElementNameOrWildcard</emph></a><subscript>1</subscript> <a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_not" class="judgment"><term>not</term></a>(element <a href="#doc-xquery-ElementNameOrWildcard"><emph>ElementNameOrWildcard</emph></a><subscript>1</subscript>
               <a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> element <a href="#doc-xquery-ElementNameOrWildcard"><emph>ElementNameOrWildcard</emph></a><subscript>2</subscript> <a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>2</subscript>)
</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_not" class="judgment"><term>not</term></a>(element <a href="#doc-xquery-ElementNameOrWildcard"><emph>ElementNameOrWildcard</emph></a><subscript>2</subscript>
               <a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> element <a href="#doc-xquery-ElementNameOrWildcard"><emph>ElementNameOrWildcard</emph></a><subscript>1</subscript> <a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>1</subscript>)
</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>1</subscript> <a href="#jd_expands_to" class="judgment"><term>expands to</term></a>
              <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>2</subscript> <a href="#jd_expands_to" class="judgment"><term>expands to</term></a>
              <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_not" class="judgment"><term>not</term></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
               <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)
</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_not" class="judgment"><term>not</term></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
               <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)
</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
               <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>ElementTest</emph>
               <a href="#jd_test_type" class="judgment"><term>with</term></a> element
               <a href="#jd_test_type" class="judgment"><term>of</term></a> element <a href="#doc-xquery-ElementNameOrWildcard"><emph>ElementNameOrWildcard</emph></a><subscript>2</subscript> <a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>2</subscript>
               <a href="#jd_test_type" class="judgment"><term>:</term></a> empty
              </expression></clause></postjudge></infer></infergr></smrules><p><b><emph>Attribute kind test</emph></b></p><smrules><p>The rules for the attribute kind test are isomorphic to those
     for element kind test.</p><p>If the type of the expression is a
     subtype of the attribute kind test, then we are guaranteed that
     during evaluation, the expression's attribute value will always
     match the attribute kind test, and therefore the type of the
     entire expression is the type of the input expression.</p><infergr><infer><prejudge><multiclause><clause><expression><map><emph>AttributeTest</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                = <a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
               <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>AttributeTest</emph>
               <a href="#jd_test_type" class="judgment"><term>with</term></a> attribute
               <a href="#jd_test_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> 
               <a href="#jd_test_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> 
              </expression></clause></postjudge></infer></infergr><p>Conversely, if the type of the attribute kind test is a
          subtype of the expression, then during evaluation, the
          expression's attribute value may or may not match the
          attribute kind test, and therefore the type of the entire
          expression is zero-or-one of the type of the attribute kind
          test. </p><infergr><infer><prejudge><multiclause><clause><expression><map><emph>AttributeTest</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                = <a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
               <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>AttributeTest</emph>
               <a href="#jd_test_type" class="judgment"><term>with</term></a> attribute
               <a href="#jd_test_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> 
               <a href="#jd_test_type" class="judgment"><term>:</term></a> <a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a>?
              </expression></clause></postjudge></infer></infergr><p>If the types of the expression and attribute kind test
          are unrelated (i.e., neither type is a subtype of the
          other), then we must compare the structure of the type of
          the attribute test with the type of the attribute
          expression, as an attribute type or test may contain
          wildcards.</p><p>In the first case, the attribute kind test contains an
          attribute name and a type name and the input expression's
          type contains only a type name.  If the input expression's
          content type is a subtype of the attribute kind test's
          content type, then the type of the entire expression is
          zero-or-one of an attribute with the given name and the
          input expression's content type.</p><infergr><infer><prejudge><multiclause><clause><expression><map><emph>AttributeTest</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                = attribute <a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a><subscript>1</subscript> <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a><subscript>1</subscript></expression></clause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a><subscript>1</subscript> <a href="#jd_expands_to" class="judgment"><term>expands to</term></a>
              <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a><subscript>2</subscript> <a href="#jd_expands_to" class="judgment"><term>expands to</term></a>
              <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
               <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>AttributeTest</emph>
               <a href="#jd_test_type" class="judgment"><term>with</term></a> attribute
               <a href="#jd_test_type" class="judgment"><term>of</term></a> attribute<phrase diff="add" at="E023"> *</phrase> <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a><subscript>2</subscript>
               <a href="#jd_test_type" class="judgment"><term>:</term></a> attribute <a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a><subscript>1</subscript>
               <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a><subscript>2</subscript>? 
              </expression></clause></postjudge></infer></infergr><p>In the second case, the structure of the input types is
          reversed: The input expression's type contains an attribute
          name and a type name and the attribute kind test's type
          contains only a type name.  If the attribute kind test's
          content type is a subtype of the input expression's content
          type, then the type of the entire expression is zero-or-one
          of an attribute with the given name and the attribute kind
          test's content type.</p><infergr><infer><prejudge><multiclause><clause><expression><map><emph>AttributeTest</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                = attribute<phrase diff="add" at="E023"> *</phrase> <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a><subscript>1</subscript></expression></clause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a><subscript>1</subscript> <a href="#jd_expands_to" class="judgment"><term>expands to</term></a>
              <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a><subscript>2</subscript> <a href="#jd_expands_to" class="judgment"><term>expands to</term></a>
              <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
               <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>AttributeTest</emph>
               <a href="#jd_test_type" class="judgment"><term>with</term></a> attribute
               <a href="#jd_test_type" class="judgment"><term>of</term></a> attribute <a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a><subscript>2</subscript> <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a><subscript>2</subscript>
               <a href="#jd_test_type" class="judgment"><term>:</term></a> attribute <a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a><subscript>2</subscript>
               <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a><subscript>1</subscript>? 
              </expression></clause></postjudge></infer></infergr><p>Lastly, if none of the above rules holds, then the type
          of the input expression is empty.</p><infergr><infer><prejudge><multiclause><clause><expression><map><emph>AttributeTest</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                = attribute <a href="#doc-fs-AttributeNameOrWildcard"><emph>AttributeName</emph></a><subscript>1</subscript> <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_not" class="judgment"><term>not</term></a>(attribute <a href="#doc-fs-AttributeNameOrWildcard"><emph>AttributeName</emph></a><subscript>1</subscript>
               <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> attribute <a href="#doc-fs-AttributeNameOrWildcard"><emph>AttributeName</emph></a><subscript>2</subscript> <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a><subscript>2</subscript>)
               </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_not" class="judgment"><term>not</term></a>(attribute <a href="#doc-fs-AttributeNameOrWildcard"><emph>AttributeName</emph></a><subscript>2</subscript>
               <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> attribute <a href="#doc-fs-AttributeNameOrWildcard"><emph>AttributeName</emph></a><subscript>1</subscript> <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a><subscript>1</subscript>)
               </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a><subscript>1</subscript> <a href="#jd_expands_to" class="judgment"><term>expands to</term></a>
              <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a><subscript>2</subscript> <a href="#jd_expands_to" class="judgment"><term>expands to</term></a>
              <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_not" class="judgment"><term>not</term></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
               <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)
               </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_not" class="judgment"><term>not</term></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
               <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)
               </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
               <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>AttributeTest</emph>
               <a href="#jd_test_type" class="judgment"><term>with</term></a> attribute
               <a href="#jd_test_type" class="judgment"><term>of</term></a> attribute <a href="#doc-fs-AttributeNameOrWildcard"><emph>AttributeName</emph></a><subscript>2</subscript> <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a><subscript>2</subscript>
               <a href="#jd_test_type" class="judgment"><term>:</term></a> empty
              </expression></clause></postjudge></infer></infergr></smrules><p><b><emph>Processing instruction, comment, and text kind
     tests</emph></b></p><smrules><infergr diff="chg" at="E022"><infer><prejudge><clause><expression><map><emph>PITest</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a> = processing-instruction *</expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
          <a href="#jd_test_type" class="judgment"><term>test</term></a> 
          <emph>PITest</emph>
          <a href="#jd_test_type" class="judgment"><term>with</term></a> <emph>PrincipalNodeKind</emph>
          <a href="#jd_test_type" class="judgment"><term>of</term></a> <a href="#doc-fs-ProcessingInstructionType"><emph>ProcessingInstructionType</emph></a>
          <a href="#jd_test_type" class="judgment"><term>:</term></a> <a href="#doc-fs-ProcessingInstructionType"><emph>ProcessingInstructionType</emph></a>
         </expression></clause></postjudge></infer></infergr><p>A processing-instruction node test with a string
     literal or NCName matches a processing instruction whose target
     has the given name.  <phrase diff="del" at="E022">Since target matching cannot be checked
     statically, the static type of the node test is zero-or-one
     processing instruction.</phrase></p><infergr diff="chg" at="E022"><infer><prejudge><clause><expression><map><emph>PITest</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a> = processing-instruction <emph>NCName</emph></expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
          <a href="#jd_test_type" class="judgment"><term>test</term></a>
          <emph>PITest</emph>
          <a href="#jd_test_type" class="judgment"><term>with</term></a> <emph>PrincipalNodeKind</emph>
          <a href="#jd_test_type" class="judgment"><term>of</term></a> processing-instruction <emph>NCName</emph>
          <a href="#jd_test_type" class="judgment"><term>:</term></a> processing-instruction <emph>NCName</emph>
         </expression></clause></postjudge></infer></infergr><infergr diff="chg" at="E022"><infer><prejudge><clause><expression><map><emph>PITest</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a> = processing-instruction <emph>NCName</emph></expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
          <a href="#jd_test_type" class="judgment"><term>test</term></a>
          <emph>PITest</emph>
          <a href="#jd_test_type" class="judgment"><term>with</term></a> <emph>PrincipalNodeKind</emph>
          <a href="#jd_test_type" class="judgment"><term>of</term></a> processing-instruction *
          <a href="#jd_test_type" class="judgment"><term>:</term></a> processing-instruction <emph>NCName</emph> ?
         </expression></clause></postjudge></infer></infergr><infergr><infer><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
          <a href="#jd_test_type" class="judgment"><term>test</term></a> <code>comment()</code>
          <a href="#jd_test_type" class="judgment"><term>with</term></a> <emph>PrincipalNodeKind</emph>
          <a href="#jd_test_type" class="judgment"><term>of</term></a> comment <a href="#jd_test_type" class="judgment"><term>:</term></a>
          comment
         </expression></clause></postjudge></infer></infergr><infergr><infer><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
          <a href="#jd_test_type" class="judgment"><term>test</term></a> <code>text()</code>
          <a href="#jd_test_type" class="judgment"><term>with</term></a> <emph>PrincipalNodeKind</emph>
          <a href="#jd_test_type" class="judgment"><term>of</term></a> text <a href="#jd_test_type" class="judgment"><term>:</term></a> text
         </expression></clause></postjudge></infer></infergr><infergr><infer><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
          <a href="#jd_test_type" class="judgment"><term>test</term></a> <code>node()</code>
          <a href="#jd_test_type" class="judgment"><term>with</term></a> <emph>PrincipalNodeKind</emph>
          <a href="#jd_test_type" class="judgment"><term>of</term></a>
          <a href="#doc-fs-NodeType"><emph>NodeType</emph></a> <a href="#jd_test_type" class="judgment"><term>:</term></a> <a href="#doc-fs-NodeType"><emph>NodeType</emph></a>
         </expression></clause></postjudge></infer></infergr><p>If none of the above rules applies then the node test
          returns the empty sequence, and the following dynamic rule
          is applied:</p><infergr><infer><prejudge><multiclause><clause><expression><emph>Otherwise</emph></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
       <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>NodeTest</emph>
       <a href="#jd_test_type" class="judgment"><term>with</term></a> <emph>PrincipalNodeKind</emph>
       <a href="#jd_test_type" class="judgment"><term>of</term></a>
       <a href="#doc-fs-NodeType"><emph>NodeType</emph></a> <a href="#jd_test_type" class="judgment"><term>:</term></a> <code>empty</code>
              </expression></clause></postjudge></infer></infergr></smrules></div5></div4><div4 id="sec_dyn_node_tests"><head>Dynamic semantics of node tests</head><smnotation><p id="jd_test">The following judgment</p><display>
         <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
           <a href="#jd_test" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test" class="judgment"><term>with</term></a>
           <emph>PrincipalNodeKind</emph> <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_test" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>
          </expression></clause>
        </display><p>holds when applying the node test <emph>NodeTest</emph> on
        <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> in the context of the <emph>PrincipalNodeKind</emph>
        yields <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>:</p></smnotation><smexample><p>For example, the following judgments hold.</p><eg xml:space="preserve">
  test node()  with element  of    text { "1 2 3" }  =&gt; text { "1 2 3" }
  test size    with element  of    text { "1 2 3" }  =&gt; ()

  test foo:*   with element  of
     (element foo:a of type xs:int { 1 },
      element foo:a of type xs:int { 2 },
      element bar:b of type xs:int { 3 },
      element bar:c of type xs:int { 4 },
      element foo:d of type xs:int { 5 })
  =&gt; (element foo:a of type xs:int { 1 },
      element foo:a of type xs:int { 2 },
      (),
      (),
      element foo:d of type xs:int { 5 })
</eg></smexample><smnote><p>The last example illustrates how a test judgment operates
        on a sequence of nodes, applying the test on each node in the
        sequence individually, while preserving the structure of the
        sequence.</p></smnote><smrules><p>This judgment is specified by the following rules.</p><p>The first set of rules are similar to those for axes, and
        are used to process the test judgment on each individual item
        in the input sequence.</p><infergr><infer><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
               <a href="#jd_test" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test" class="judgment"><term>with</term></a>
             <emph>PrincipalNodeKind</emph> <a href="#jd_test" class="judgment"><term>of</term></a> () <a href="#jd_test" class="judgment"><term>=&gt;</term></a> ()
              </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
                <a href="#jd_test" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test" class="judgment"><term>with</term></a>
             <emph>PrincipalNodeKind</emph> <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_test" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>3</subscript>
               </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
                <a href="#jd_test" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test" class="judgment"><term>with</term></a>
             <emph>PrincipalNodeKind</emph> <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> <a href="#jd_test" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>4</subscript>
               </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
             <a href="#jd_test" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test" class="judgment"><term>with</term></a> <emph>PrincipalNodeKind</emph>
             <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> <a href="#jd_test" class="judgment"><term>=&gt;</term></a>
             <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>3</subscript>,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>4</subscript>
              </expression></clause></postjudge></infer></infergr></smrules><div5 id="sec_dyn_sem_name_tests"><head>Name Tests</head><p>The following rules specify how the value filter judgment
        is applied on a name test in the context of a principal node
        kind.</p><smrules><infergr><infer><prejudge><multiclause><clause><expression><emph>dm:</emph><code>node-kind</code>( <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> ) = <emph>PrincipalNodeKind</emph></expression></clause></multiclause><multiclause><clause><expression><code>fn:node-name</code>( <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> ) = <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression></clause></multiclause><multiclause><clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a>(<emph>Prefix</emph>) = (<a href="#xq_ns_env"><emph>NamespaceKind</emph></a>,<emph>AnyURI</emph>)</expression></clause></multiclause><multiclause><clause><expression><code>fn:namespace-uri-from-QName</code>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>) = <emph>AnyURI</emph></expression></clause></multiclause><multiclause><clause><expression><code>fn:local-name-from-QName</code>( <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> ) = <emph>LocalPart</emph>
               </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
               <a href="#jd_test" class="judgment"><term>test</term></a> <emph>Prefix</emph>:<emph>LocalPart</emph>
               <a href="#jd_test" class="judgment"><term>with</term></a> <emph>PrincipalNodeKind</emph>
               <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> <a href="#jd_test" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a>
              </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><expression><emph>dm:</emph><code>node-kind</code>( <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> ) = <emph>PrincipalNodeKind</emph></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
               <a href="#jd_test" class="judgment"><term>test</term></a> <code>*</code>
               <a href="#jd_test" class="judgment"><term>with</term></a> <emph>PrincipalNodeKind</emph>
               <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a>
               <a href="#jd_test" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a>
              </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><expression><emph>dm:</emph><code>node-kind</code>( <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> ) = <emph>PrincipalNodeKind</emph></expression></clause></multiclause><multiclause><clause><expression><code>fn:node-name</code> ( <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> ) = <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression></clause></multiclause><multiclause><clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a>(<emph>Prefix</emph>) = (<a href="#xq_ns_env"><emph>NamespaceKind</emph></a>,<emph>AnyURI</emph>)</expression></clause></multiclause><multiclause><clause><expression><code>fn:namespace-uri-from-QName</code>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>) = <emph>AnyURI</emph></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
               <a href="#jd_test" class="judgment"><term>test</term></a> <emph>Prefix</emph><code>:*</code>
               <a href="#jd_test" class="judgment"><term>with</term></a> <emph>PrincipalNodeKind</emph>
               <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> <a href="#jd_test" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a>
              </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><expression><emph>dm:</emph><code>node-kind</code>( <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> ) = <emph>PrincipalNodeKind</emph></expression></clause></multiclause><multiclause><clause><expression><code>fn:node-name</code> ( <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> ) = <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression></clause></multiclause><multiclause><clause><expression><code>fn:local-name-from-QName</code> ( <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> ) = <emph>LocalPart</emph></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
               <a href="#jd_test" class="judgment"><term>test</term></a> <code>*:</code><emph>LocalPart</emph>
               <a href="#jd_test" class="judgment"><term>with</term></a> <emph>PrincipalNodeKind</emph>
               <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> <a href="#jd_test" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a>
              </expression></clause></postjudge></infer></infergr></smrules></div5><div5 id="sec_dyn_kind_tests"><head>Kind Tests</head><p>All the rules for evaluating the document, element, and
        attribute kind tests are similar.  First, the document,
        element, or attribute test is normalized to the equivalent
        document, element, or attribute type by applying the
        <map/><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a> normalization rule.  As
        explained in <specref ref="id-sequencetype"/>, SequenceTypes
        are normalized to XQuery types whenever a dynamic evaluation
        or static typing rule requires the corresponding type. The
        reason for this deviation from the processing model is that
        the result of SequenceType normalization is not part of the
        [XPath/XQuery] core syntax.</p><p>After normalization of the SequenceType to an XQuery type,
        the document, element, or attribute value is simply matched
        against the XQuery type.  If the value matches the type, then
        the judgment yields the value, otherwise the judgment yields
        the empty sequence.</p><p><b><emph>Document kind test</emph></b></p><smrules><infergr><infer><prejudge><multiclause><clause><expression><map><emph>DocumentTest</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                = <a href="#doc-fs-DocumentType"><emph>DocumentType</emph></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-DocumentValue"><emph>DocumentValue</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-DocumentType"><emph>DocumentType</emph></a></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
               <a href="#jd_test" class="judgment"><term>test</term></a> <emph>DocumentTest</emph>
               <a href="#jd_test" class="judgment"><term>with</term></a> element
               <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-DocumentValue"><emph>DocumentValue</emph></a> <a href="#jd_test" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-DocumentValue"><emph>DocumentValue</emph></a>
              </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><expression><map><emph>DocumentTest</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                = <a href="#doc-fs-DocumentType"><emph>DocumentType</emph></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_not" class="judgment"><term>not</term></a>(<a href="#doc-fs-DocumentValue"><emph>DocumentValue</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-DocumentType"><emph>DocumentType</emph></a>)</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
               <a href="#jd_test" class="judgment"><term>test</term></a> <emph>DocumentTest</emph>
               <a href="#jd_test" class="judgment"><term>with</term></a> element
               <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-DocumentValue"><emph>DocumentValue</emph></a> <a href="#jd_test" class="judgment"><term>=&gt;</term></a> ()
              </expression></clause></postjudge></infer></infergr></smrules><p><b><emph>Element kind test</emph></b></p><smrules><infergr><infer><prejudge><multiclause><clause><expression><map><emph>ElementTest</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                = <a href="#doc-fs-ElementType"><emph>ElementType</emph></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-ElementValue"><emph>ElementValue</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-ElementType"><emph>ElementType</emph></a></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
               <a href="#jd_test" class="judgment"><term>test</term></a> <emph>ElementTest</emph>
               <a href="#jd_test" class="judgment"><term>with</term></a> element
               <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-ElementValue"><emph>ElementValue</emph></a> <a href="#jd_test" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-ElementValue"><emph>ElementValue</emph></a>
              </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><expression><map><emph>ElementTest</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                = <a href="#doc-fs-ElementType"><emph>ElementType</emph></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_not" class="judgment"><term>not</term></a>(<a href="#doc-fs-ElementValue"><emph>ElementValue</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-ElementType"><emph>ElementType</emph></a>)</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
               <a href="#jd_test" class="judgment"><term>test</term></a> <emph>ElementTest</emph>
               <a href="#jd_test" class="judgment"><term>with</term></a> element
               <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-ElementValue"><emph>ElementValue</emph></a> <a href="#jd_test" class="judgment"><term>=&gt;</term></a> ()
              </expression></clause></postjudge></infer></infergr></smrules><p><b><emph>Attribute kind test</emph></b></p><smrules><infergr><infer><prejudge><multiclause><clause><expression><map><emph>AttributeTest</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                = <a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-AttributeValue"><emph>AttributeValue</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
               <a href="#jd_test" class="judgment"><term>test</term></a> <emph>AttributeTest</emph>
               <a href="#jd_test" class="judgment"><term>with</term></a> attribute
               <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-AttributeValue"><emph>AttributeValue</emph></a> <a href="#jd_test" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-AttributeValue"><emph>AttributeValue</emph></a>
              </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><expression><map><emph>AttributeTest</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                = <a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_not" class="judgment"><term>not</term></a>(<a href="#doc-fs-AttributeValue"><emph>AttributeValue</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a>)</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
               <a href="#jd_test" class="judgment"><term>test</term></a> <emph>AttributeTest</emph>
               <a href="#jd_test" class="judgment"><term>with</term></a> attribute
               <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-AttributeValue"><emph>AttributeValue</emph></a> <a href="#jd_test" class="judgment"><term>=&gt;</term></a> ()
              </expression></clause></postjudge></infer></infergr></smrules><p><b><emph>Processing instruction, comment, and text kind
        tests</emph></b></p><smrules><infergr><infer><prejudge><multiclause><clause><expression><emph>dm:</emph><code>node-kind</code> ( <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> ) = "processing-instruction"</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
               <a href="#jd_test" class="judgment"><term>test</term></a> <code>processing-instruction()</code>
               <a href="#jd_test" class="judgment"><term>with</term></a> <emph>PrincipalNodeKind</emph>
               <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> <a href="#jd_test" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a>
              </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><expression><emph>dm:</emph><code>node-kind</code> ( <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> ) = "processing-instruction"</expression></clause></multiclause><multiclause><clause><expression><code>fn:node-name</code> ( <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> ) = <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>StringLiteral</emph> <a href="#jd_has_atomic_value" class="judgment"><term>has atomic value</term></a> <emph>String</emph>
 	       </expression></clause></multiclause><multiclause><clause><expression><code>fn:local-name-from-QName</code> ( <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> ) = <emph>String</emph></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
               <a href="#jd_test" class="judgment"><term>test</term></a> <code>processing-instruction(</code> <emph>StringLiteral</emph> <code>)</code>
               <a href="#jd_test" class="judgment"><term>with</term></a> <emph>PrincipalNodeKind</emph>
               <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> <a href="#jd_test" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a>
              </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><expression><a href="#jd_not" class="judgment"><term>not</term></a>(<emph>dm:</emph><code>node-kind</code> ( <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> ) = "processing-instruction")</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
               <a href="#jd_test" class="judgment"><term>test</term></a> <code>processing-instruction()</code>
               <a href="#jd_test" class="judgment"><term>with</term></a> <emph>PrincipalNodeKind</emph>
               <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> <a href="#jd_test" class="judgment"><term>=&gt;</term></a> ()
              </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><expression><emph>dm:</emph><code>node-kind</code> ( <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> ) = "comment"</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
               <a href="#jd_test" class="judgment"><term>test</term></a> <code>comment()</code>
               <a href="#jd_test" class="judgment"><term>with</term></a> <emph>PrincipalNodeKind</emph>
               <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> <a href="#jd_test" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a>
              </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><expression><a href="#jd_not" class="judgment"><term>not</term></a>(<emph>dm:</emph><code>node-kind</code> ( <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> ) = "comment")</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
               <a href="#jd_test" class="judgment"><term>test</term></a> <code>comment()</code>
               <a href="#jd_test" class="judgment"><term>with</term></a> <emph>PrincipalNodeKind</emph>
               <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> <a href="#jd_test" class="judgment"><term>=&gt;</term></a> ()
              </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><expression><emph>dm:</emph><code>node-kind</code> ( <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> ) = "text"</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
               <a href="#jd_test" class="judgment"><term>test</term></a> <code>text()</code>
               <a href="#jd_test" class="judgment"><term>with</term></a> <emph>PrincipalNodeKind</emph>
               <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> <a href="#jd_test" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a>
              </expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><expression><a href="#jd_not" class="judgment"><term>not</term></a>(<emph>dm:</emph><code>node-kind</code> ( <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> ) = "text")</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
               <a href="#jd_test" class="judgment"><term>test</term></a> <code>text()</code>
               <a href="#jd_test" class="judgment"><term>with</term></a> <emph>PrincipalNodeKind</emph>
               <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> <a href="#jd_test" class="judgment"><term>=&gt;</term></a> ()
              </expression></clause></postjudge></infer></infergr><p>The <code>node()</code> node test is true for all
          nodes. Therefore, the following rule does not have any
          precondition (remember that an empty upper part in the rule
          indicates that the rule is always true).</p><infergr><infer><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
               <a href="#jd_test" class="judgment"><term>test</term></a> <code>node()</code>
               <a href="#jd_test" class="judgment"><term>with</term></a> <emph>PrincipalNodeKind</emph>
               <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> <a href="#jd_test" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a>
              </expression></clause></postjudge></infer></infergr><p>If none of the above rules applies then the node test
          returns the empty sequence, and the following dynamic rule
          is applied:</p><infergr><infer><prejudge><multiclause><clause><expression><emph>Otherwise</emph></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression>
               <a href="#jd_test" class="judgment"><term>test</term></a> <emph>NodeTest</emph>
                 <a href="#jd_test" class="judgment"><term>with</term></a> <emph>PrincipalNodeKind</emph>
               <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> <a href="#jd_test" class="judgment"><term>=&gt;</term></a> ()
              </expression></clause></postjudge></infer></infergr></smrules></div5></div4></div3></div2><div2 id="sec_type_matching"><head>Judgments for type matching</head><smintro><p>XQuery supports type declarations on variable bindings, and
      several operations on types (<code>typeswitch</code>,
      <code>instance of</code>, etc). This section describes judgments
      used for the specification of the semantics of those
      operations.</p><ulist><item><p>The <quote>match</quote> judgment specifies formally type
          matching. It takes as input a value and a type and either
          succeeds or fails. It is used in matching parameters against
          function signatures, type declarations, and matching values
          against cases in <quote>typeswitch</quote>. An informal
          description of type matching is given in <xspecref spec="XQ" ref="id-sequencetype-matching"/>.</p></item><item><p>The <quote>subtyping</quote> judgment takes two types and
          succeeds if all values matching the first type also match
          the second. It is used to define the static semantics of
          operations using type matching.</p></item></ulist></smintro><div3 id="sec_matches"><head>Matches</head><smnotation><p id="jd_matches">The judgment</p><display>
          <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause>
        </display><p>holds when the given value matches the given type.</p></smnotation><smexample><p>For example, assuming the extended XML Schema given in
        section <specref ref="sec_types_example"/>, then the following
        judgments hold.</p><eg xml:space="preserve">
  element comment of type xsd:string { "This is not important" }
    matches
  element comment of type xsd:string

  (element apt of type fs:anon3 { 2510 },
   element apt of type fs:anon3 { 2511 })
    matches
  element apt+

  ()
    matches
  element usaddress?

  element usaddress of type USAddress {
    element name of type xsd:string { "The Archive" },
    element street of type xsd:string { "Christopher Street" },
    element city of type xsd:string { "New York" },
    element state of type xsd:string { "NY" },
    element zip of type xsd:decimal { 10210 }
  }
    matches
  element usaddress?
</eg></smexample><smrules><p>We start by giving the inference rules for matching an
        item value with an item type.</p><p>An atomic value matches an atomic type if its <xtermref spec="XQ" ref="dt-type-annotation"/> derives from the atomic
        type.  The value itself is ignored -- this is checked as part
        of validation.</p><infergr><infer><prejudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>1</subscript> <a href="#jd_derives_from" class="judgment"><term>derives from</term></a>
              <a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>2</subscript></expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-AtomicValueContent"><emph>AtomicValueContent</emph></a> of type <a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>1</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>2</subscript></expression></clause></postjudge></infer></infergr><p>A text node matches text.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>text { <emph>String</emph> } <a href="#jd_matches" class="judgment"><term>matches</term></a> text</expression></clause></postjudge></infer></infergr><p>A comment node matches comment.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>comment { <emph>String</emph> } <a href="#jd_matches" class="judgment"><term>matches</term></a> comment</expression></clause></postjudge></infer></infergr><p>A processing-instruction node matches <phrase diff="chg" at="E022">the general processing-instruction type,
        and also the particular processing-instruction type that shares its PITarget.</phrase></p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>processing-instruction <emph>NCName</emph> { <emph>String</emph> } <a href="#jd_matches" class="judgment"><term>matches</term></a> processing-instruction<phrase diff="add" at="E022"> *</phrase></expression></clause></postjudge></infer></infergr><infergr diff="add" at="E022"><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>processing-instruction <emph>NCName</emph> { <emph>String</emph> } <a href="#jd_matches" class="judgment"><term>matches</term></a> processing-instruction <emph>NCName</emph></expression></clause></postjudge></infer></infergr><p>A document node matches a document type if the node's
        content matches the document type's corresponding content
        type.</p><infergr><infer><prejudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression> <a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
             </expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>document { <a href="#doc-fs-Value"><emph>Value</emph></a> } <a href="#jd_matches" class="judgment"><term>matches</term></a> document { <a href="#doc-fs-Type"><emph>Type</emph></a> }</expression></clause></postjudge></infer></infergr><p>The rules for matching an element value with an element
        type are more complicated.  When an element value is not
        nilled, the element matches an element type if the element
        name and the element type resolve to some type name, and the
        element value's <xtermref spec="XQ" ref="dt-type-annotation"/>
        is derived from the resolved type name.  Note that there is no
        need to check structural constraints on the value since those
        have been checked during XML Schema validation and the value
        is assumed to be consistent with its <xtermref spec="XQ" ref="dt-type-annotation"/>.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#jd_lookup" class="judgment"><term>name lookup</term></a>
              <a href="#doc-fs-ElementType"><emph>ElementType</emph></a> <a href="#jd_lookup" class="judgment"><term>yields</term></a> <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a> of
              type <a href="#doc-fs-TypeName"><emph>BaseTypeName</emph></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-TypeName"><emph>TypeName</emph></a> <a href="#jd_derives_from" class="judgment"><term>derives from</term></a>
              <a href="#doc-fs-TypeName"><emph>BaseTypeName</emph></a></expression></clause></multiclause><multiclause><clause><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_filter" class="judgment"><term>filter</term></a> @xsi:nil
              <a href="#jd_filter" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a></expression></clause></multiclause><multiclause><clause><expression><a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a> <a href="#jd_isin" class="judgment"><term>in</term></a> { (), false }</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> of type
             <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> { <a href="#doc-fs-Value"><emph>Value</emph></a> } <a href="#jd_matches" class="judgment"><term>matches</term></a>
             <a href="#doc-fs-ElementType"><emph>ElementType</emph></a></expression></clause></postjudge></infer></infergr><smnote><p>Type matching uses the name lookup judgment defined in
          <specref ref="sec_element_lookup"/>.</p></smnote><p>In the case the element has been nilled, that is there
        exists and xsi:nil attribute set to true in the element value,
        the following rule checks that the type is nillable. </p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#jd_lookup" class="judgment"><term>name lookup</term></a>
              <a href="#doc-fs-ElementType"><emph>ElementType</emph></a> <a href="#jd_lookup" class="judgment"><term>yields</term></a> nillable of type
              <a href="#doc-fs-TypeName"><emph>BaseTypeName</emph></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-TypeName"><emph>TypeName</emph></a> <a href="#jd_derives_from" class="judgment"><term>derives from</term></a>
              <a href="#doc-fs-TypeName"><emph>BaseTypeName</emph></a></expression></clause></multiclause><multiclause><clause><expression><a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_filter" class="judgment"><term>filter</term></a> @xsi:nil
              <a href="#jd_filter" class="judgment"><term>=&gt;</term></a> true</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> of type
             <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> { <a href="#doc-fs-Value"><emph>Value</emph></a> } <a href="#jd_matches" class="judgment"><term>matches</term></a>
             <a href="#doc-fs-ElementType"><emph>ElementType</emph></a></expression></clause></postjudge></infer></infergr><p>The rule for attributes is similar, but does not require
        the check for the xsi:nil attribute.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a> <a href="#jd_attribute_lookup" class="judgment"><term>name lookup</term></a>
              <a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a> <a href="#jd_attribute_lookup" class="judgment"><term>yields</term></a> of type
              <a href="#doc-fs-TypeName"><emph>BaseTypeName</emph></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-TypeName"><emph>TypeName</emph></a> <a href="#jd_derives_from" class="judgment"><term>derives from</term></a>
              <a href="#doc-fs-TypeName"><emph>BaseTypeName</emph></a></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>attribute <a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a> of type
             <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> { <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a> } <a href="#jd_matches" class="judgment"><term>matches</term></a>
             <a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a></expression></clause></postjudge></infer></infergr><p>A type can also be a sequence of items, in that case the
        matching rules also need to check whether the constraints
        described by the type as a regular expression hold. This is
        specified by the following rules.</p><p>The empty sequence matches the empty sequence type.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>() <a href="#jd_matches" class="judgment"><term>matches</term></a> <code>empty</code></expression></clause></postjudge></infer></infergr><p>If two values match two types, then their sequence matches
        the corresponding sequence type.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression></clause></postjudge></infer></infergr><p>If a value matches a type, then it also matches a choice
        type where that type is one of the choices.</p><infergr><infer><prejudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>|<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>|<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression></clause></postjudge></infer></infergr><p>If two values match two types, then their interleaving
        matches the corresponding all group.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a>
              <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a>
              <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_interleave" class="judgment"><term>interleave</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>
              <a href="#jd_interleave" class="judgment"><term>yields</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> &amp;
             <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression></clause></postjudge></infer></infergr><p>An optional type matches a value of that type or the empty
        sequence.</p><infergr><infer><prejudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a>
              (<a href="#doc-fs-Type"><emph>Type</emph></a> | empty)</expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>?</expression></clause></postjudge></infer></infergr><p>The following rules are used to match a value against a
        sequence of zero (or one) or more types.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>() <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>*</expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>*</expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>, <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>*</expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>*</expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>, <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>+</expression></clause></postjudge></infer></infergr></smrules><smnote><p>The above definition of type matching, although complete
        and precise, does not give a simple means to
        <emph>compute</emph> type matching. Notably, some of the above
        rules can be non-deterministic (e.g., the rule for matching of
        choice or repetition).</p><p>The structural component of the [XPath/XQuery] type system can
        be modeled by regular expressions. Regular expressions can be
        implemented by means of finite state automata. Computing type
        matching then is equivalent to check if a given sequence of
        items is <emph>recognized</emph> by its corresponding finite
        state automata. Finite state automata and their relationships
        to regular expressions have been extensively studied and
        documented in computer-science literature. The interested reader can
        consult the relevant literature, for instance <bibref ref="Languages"/>, or <bibref ref="TATA"/>.</p></smnote></div3><div3 id="sec_subtyping"><head>Subtyping (&lt;:)</head><smintro><p>This section defines the semantics of subtyping in
        [XPath/XQuery]. Subtyping is used during static type analysis, in
        typeswitch, treat and assert expressions, and to check the
        correctness of function applications.</p><p>Note that intuitive relationships between types. For
        instance, that (<a href="#doc-fs-Type"><emph>Type</emph></a>,()) is equivalent to <a href="#doc-fs-Type"><emph>Type</emph></a> can
        be deduced using the subtyping judgment (and algorithm)
        described here.</p></smintro><smnotation><p id="jd_subtype_of">The judgment</p><display>
          <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression></clause>
        </display><p>holds if the first type is a subtype of the second.</p></smnotation><smrules><p>This judgment is true if and only if, for every value
        <a href="#doc-fs-Value"><emph>Value</emph></a>, if <a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> holds, then
        <a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> also holds.</p></smrules><smnote><p>It is easy to see that the subtype relation <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
        is a partial order, i.e. it is <term>reflexive</term>:</p><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
            <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
          </expression></clause><p>and it is <term>transitive</term>: if,</p><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
            <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
          </expression></clause><p>and,</p><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
            <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript>
          </expression></clause><p>then,</p><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
            <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript>
          </expression></clause><p>Finally, two types are equal if each is a subtype of the
        other, that is: </p><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
            <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
          </expression></clause><p>and,</p><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
            <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
          </expression></clause><p>then,</p><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
            <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> = <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
          </expression></clause></smnote><smnote><p>The above definition, although complete and precise, does
        not give a simple means to <emph>compute</emph>
        subtyping. Notably the definition above refers to values,
        which are not available at static type checking time.</p><p>The structural component of the [XPath/XQuery] type system can
        be modeled by regular expressions. Regular expressions can be
        implemented by means of finite state automata. Computing
        subtyping between two types can then be done by computing if
        <emph>inclusion</emph> holds between their corresponding
        finite state automata.</p><p>Finite state automata and how to compute operations on
        those automata, such as inclusion, emptiness or intersection,
        have been extensively studied and documented in the
        literature. The interested reader can consult the relevant
        literature on tree grammars, for instance <bibref ref="Languages"/>, or <bibref ref="TATA"/>.</p></smnote></div3></div2><div2 id="sec_factor"><head>Judgments for FLWOR and other expressions on sequences</head><smintro><p>Some [XPath/XQuery] operations work on sequences of items. For
      instance, [For/FLWOR] expressions iterate over a sequence of
      items and the <code>fn:unordered</code> function can return all items in a
      sequence in any order, etc.</p><p>Static typing for those operations needs to infer a type
      acceptable for <emph>all</emph> the items in the sequence. This
      sometimes requires approximating the type known for each item
      individually.</p></smintro><smexample><p>Assume the variable <code>$shipTo</code> is bound to the
      shipTo element</p><eg xml:space="preserve">
    &lt;shipTo country="US"&gt;
        &lt;name&gt;Alice Smith&lt;/name&gt;
        &lt;street&gt;123 Maple Street&lt;/street&gt;
        &lt;city&gt;Mill Valley&lt;/city&gt;
        &lt;state&gt;CA&lt;/state&gt;
        &lt;zip&gt;90952&lt;/zip&gt;
    &lt;/shipTo&gt;
</eg><p>and has type</p><eg xml:space="preserve">
   element shipTo of type USAddress
</eg><p>The following query orders all children of the shipTo element
      by alphabetical order of their content.</p><eg xml:space="preserve">
   for $x in $shipTo/*
   order by $x/text()
   return $x
</eg><p>resulting in the sequence</p><eg xml:space="preserve">
    (&lt;street&gt;123 Maple Street&lt;/street&gt;,
     &lt;zip&gt;90952&lt;/zip&gt;,
     &lt;name&gt;Alice Smith&lt;/name&gt;,
     &lt;state&gt;CA&lt;/state&gt;,
     &lt;city&gt;Mill Valley&lt;/city&gt;)
</eg><p>This operation iterates over the elements in the input
      sequence returned by the expression <code>$shipTo/*</code>,
      whose type is the content of a type USAddress.</p><eg xml:space="preserve">
    (element name of type xsd:string,
     element street of type xsd:string,
     element city of type xsd:string,
     element state of type xsd:string,
     element zip of type xsd:decimal)
</eg><p>During static typing, one must give a type to the variable
      <code>$x</code> which corresponds to the type of each element in
      the sequence. Since each item is of a different type, one must
      find an item type which is valid for all cases in the
      sequence. This can be done by using a choice for the variable
      <code>$x</code>, as follows</p><eg xml:space="preserve">
    (element name of type xsd:string |
     element street of type xsd:string |
     element city of type xsd:string |
     element state of type xsd:string |
     element zip of type xsd:decimal)
</eg><p>This type indicates that the type of the variable can be of
      any of the item types in the input sequence.</p><p>The static inference also needs to approximate the number of
      occurrences of items in the sequence. In this example, there is
      at least one item and more than one, so the closest occurrence
      indicator is <code>+</code> for one or more items.</p><p>The static inference for this example finally results in the
      following type.</p><eg xml:space="preserve">
    (element name of type xsd:string |
     element street of type xsd:string |
     element city of type xsd:string |
     element state of type xsd:string |
     element zip of type xsd:decimal)+
</eg><p><termdef term="prime type" id="term-prime-type">A <term><phrase diff="chg" at="E015">prime
      type</phrase></term> is a choice of item types<phrase diff="chg" at="E015">.</phrase></termdef> This section
      defines two functions on types that compute the prime type of an
      arbitrary type, and approximate the occurrence of items in an
      arbitrary type.  These type functions are used in the static
      semantics of many expressions, including <quote>for</quote>,
      <quote>some</quote>, and <quote>every</quote> expressions, and
      many functions, including <quote>fn:unordered</quote> and
      <phrase diff="del" at="E053"><quote>fn:distinct</quote></phrase>
      <phrase diff="add" at="E053"><quote>fn:distinct-values</quote></phrase>.</p></smexample><smnotation><p>A choice of item types is called a <emph>prime type</emph>,
      as described by the following grammar production.</p><scrap headstyle="show"><head>Prime Types</head><prodrecap ref="PrimeType" id="PrimeType" orig="formal"/></scrap></smnotation><smnotation><p id="jd_prime">The type function <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)
      extracts all item types from the type <a href="#doc-fs-Type"><emph>Type</emph></a>, and combines
      them into a choice.</p><p id="jd_quantifier">The function <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)
      approximates the possible number of items in <a href="#doc-fs-Type"><emph>Type</emph></a> with the
      occurrence indicators supported by the [XPath/XQuery] type system
      (<code>?, +, *</code>).</p><p>For interim results, the auxiliary occurrence
      indicator <code>1</code> denotes  exactly one occurrence.</p></smnotation><smrules><p>The <a href="#jd_prime" class="judgment">prime</a> function is defined by induction as
      follows.</p><table summary="" role="figure"><col align="left" span="1"/><col align="center" span="1"/><col align="left" span="1"/><tbody><tr><td rowspan="1" colspan="1"><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-FormalItemType"><emph>FormalItemType</emph></a>)</td><td rowspan="1" colspan="1">  =  </td><td rowspan="1" colspan="1"><a href="#doc-fs-FormalItemType"><emph>FormalItemType</emph></a></td></tr><tr><td rowspan="1" colspan="1"><a href="#jd_prime" class="judgment">prime</a>(<code>empty</code>)</td><td rowspan="1" colspan="1">  =  </td><td rowspan="1" colspan="1"><code>none</code></td></tr><tr><td rowspan="1" colspan="1"><a href="#jd_prime" class="judgment">prime</a>(<code>none</code>)</td><td rowspan="1" colspan="1">  =  </td><td rowspan="1" colspan="1"><code>none</code></td></tr><tr><td rowspan="1" colspan="1"><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> , <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)</td><td rowspan="1" colspan="1">  =  </td><td rowspan="1" colspan="1"><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) | <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)</td></tr><tr><td rowspan="1" colspan="1"><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> &amp; <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)</td><td rowspan="1" colspan="1">  =  </td><td rowspan="1" colspan="1"><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) | <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)</td></tr><tr><td rowspan="1" colspan="1"><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> | <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)</td><td rowspan="1" colspan="1">  =  </td><td rowspan="1" colspan="1"><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) | <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)</td></tr><tr><td rowspan="1" colspan="1"><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>?)</td><td rowspan="1" colspan="1">  =  </td><td rowspan="1" colspan="1"><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)</td></tr><tr><td rowspan="1" colspan="1"><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>*)</td><td rowspan="1" colspan="1">  =  </td><td rowspan="1" colspan="1"><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)</td></tr><tr><td rowspan="1" colspan="1"><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>+)</td><td rowspan="1" colspan="1">  =  </td><td rowspan="1" colspan="1"><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)</td></tr></tbody></table></smrules><smrules><p>The <a href="#jd_quantifier" class="judgment">quantifier</a> function is defined by induction as
      follows.</p><table summary="" role="figure"><col align="left" span="1"/><col align="center" span="1"/><col align="left" span="1"/><tbody><tr><td rowspan="1" colspan="1"><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-FormalItemType"><emph>FormalItemType</emph></a>)</td><td rowspan="1" colspan="1">  =  </td><td rowspan="1" colspan="1">1</td></tr><tr><td rowspan="1" colspan="1"><a href="#jd_quantifier" class="judgment">quantifier</a>(<code>empty</code>)</td><td rowspan="1" colspan="1">  =  </td><td rowspan="1" colspan="1">?</td></tr><tr><td rowspan="1" colspan="1"><a href="#jd_quantifier" class="judgment">quantifier</a>(<code>none</code>)</td><td rowspan="1" colspan="1">  =  </td><td rowspan="1" colspan="1">1</td></tr><tr><td rowspan="1" colspan="1"><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> , <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)</td><td rowspan="1" colspan="1">  =  </td><td rowspan="1" colspan="1"><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) , <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)</td></tr><tr><td rowspan="1" colspan="1"><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> &amp; <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)</td><td rowspan="1" colspan="1">  =  </td><td rowspan="1" colspan="1"><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) , <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)</td></tr><tr><td rowspan="1" colspan="1"><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> | <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)</td><td rowspan="1" colspan="1">  =  </td><td rowspan="1" colspan="1"><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) | <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)</td></tr><tr><td rowspan="1" colspan="1"><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>?)</td><td rowspan="1" colspan="1">  =  </td><td rowspan="1" colspan="1"><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_quantifier" class="judgment">·</a> ?</td></tr><tr><td rowspan="1" colspan="1"><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>*)</td><td rowspan="1" colspan="1">  =  </td><td rowspan="1" colspan="1"><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_quantifier" class="judgment">·</a> *</td></tr><tr><td rowspan="1" colspan="1"><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>+)</td><td rowspan="1" colspan="1">  =  </td><td rowspan="1" colspan="1"><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_quantifier" class="judgment">·</a> +</td></tr></tbody></table><p>This definition uses the sum (<emph>OccurrenceIndicator</emph><subscript>1</subscript> ,
      <emph>OccurrenceIndicator</emph><subscript>2</subscript>), the choice (<emph>OccurrenceIndicator</emph><subscript>1</subscript> |
      <emph>OccurrenceIndicator</emph><subscript>2</subscript>), and the product (<emph>OccurrenceIndicator</emph><subscript>1</subscript> <a href="#jd_quantifier" class="judgment">·</a>
      <emph>OccurrenceIndicator</emph><subscript>2</subscript>) of two occurrence indicators <emph>OccurrenceIndicator</emph><subscript>1</subscript>,
      <emph>OccurrenceIndicator</emph><subscript>2</subscript>, which are defined by the following tables.</p><table summary="" role="figure"><tbody><tr><td rowspan="1" colspan="1">
        <table summary="" border="1"><tbody><!--        <tr><td>&sp1;,&sp1;</td><td>&sp1;0&sp1;</td><td>&sp1;1&sp1;</td><td>&sp1;?&sp1;</td><td>&sp1;+&sp1;</td><td>&sp1;*&sp1;</td></tr> --><tr><td rowspan="1" colspan="1"> , </td><td rowspan="1" colspan="1"> 1 </td><td rowspan="1" colspan="1"> ? </td><td rowspan="1" colspan="1"> + </td><td rowspan="1" colspan="1"> * </td></tr><!--        <tr><td>&sp1;0&sp1;</td><td>&sp1;0&sp1;</td><td>&sp1;1&sp1;</td><td>&sp1;?&sp1;</td><td>&sp1;+&sp1;</td><td>&sp1;*&sp1;</td></tr>--><tr><td rowspan="1" colspan="1"> 1 </td><td rowspan="1" colspan="1"> + </td><td rowspan="1" colspan="1"> + </td><td rowspan="1" colspan="1"> + </td><td rowspan="1" colspan="1"> + </td></tr><tr><td rowspan="1" colspan="1"> ? </td><td rowspan="1" colspan="1"> + </td><td rowspan="1" colspan="1"> * </td><td rowspan="1" colspan="1"> + </td><td rowspan="1" colspan="1"> * </td></tr><tr><td rowspan="1" colspan="1"> + </td><td rowspan="1" colspan="1"> + </td><td rowspan="1" colspan="1"> + </td><td rowspan="1" colspan="1"> + </td><td rowspan="1" colspan="1"> + </td></tr><tr><td rowspan="1" colspan="1"> * </td><td rowspan="1" colspan="1"> + </td><td rowspan="1" colspan="1"> * </td><td rowspan="1" colspan="1"> + </td><td rowspan="1" colspan="1"> * </td></tr></tbody></table>
        </td><td rowspan="1" colspan="1">    </td><td rowspan="1" colspan="1">
        <table summary="" border="1"><tbody><!--        <tr><td>&sp1;|&sp1;</td><td>&sp1;0&sp1;</td><td>&sp1;1&sp1;</td><td>&sp1;?&sp1;</td><td>&sp1;+&sp1;</td><td>&sp1;*&sp1;</td></tr>--><tr><td rowspan="1" colspan="1"> | </td><td rowspan="1" colspan="1"> 1 </td><td rowspan="1" colspan="1"> ? </td><td rowspan="1" colspan="1"> + </td><td rowspan="1" colspan="1"> * </td></tr><!--        <tr><td>&sp1;0&sp1;</td><td>&sp1;0&sp1;</td><td>&sp1;?&sp1;</td><td>&sp1;?&sp1;</td><td>&sp1;*&sp1;</td><td>&sp1;*&sp1;</td></tr>--><tr><td rowspan="1" colspan="1"> 1 </td><td rowspan="1" colspan="1"> 1 </td><td rowspan="1" colspan="1"> ? </td><td rowspan="1" colspan="1"> + </td><td rowspan="1" colspan="1"> * </td></tr><tr><td rowspan="1" colspan="1"> ? </td><td rowspan="1" colspan="1"> ? </td><td rowspan="1" colspan="1"> ? </td><td rowspan="1" colspan="1"> * </td><td rowspan="1" colspan="1"> * </td></tr><tr><td rowspan="1" colspan="1"> + </td><td rowspan="1" colspan="1"> + </td><td rowspan="1" colspan="1"> * </td><td rowspan="1" colspan="1"> + </td><td rowspan="1" colspan="1"> * </td></tr><tr><td rowspan="1" colspan="1"> * </td><td rowspan="1" colspan="1"> * </td><td rowspan="1" colspan="1"> * </td><td rowspan="1" colspan="1"> * </td><td rowspan="1" colspan="1"> * </td></tr></tbody></table>
        </td><td rowspan="1" colspan="1">    </td><td rowspan="1" colspan="1">
        <table summary="" border="1"><tbody><!--        <tr><td>&sp1;&middot;&sp1;</td><td>&sp1;0&sp1;</td><td>&sp1;1&sp1;</td><td>&sp1;?&sp1;</td><td>&sp1;+&sp1;</td><td>&sp1;*&sp1;</td></tr> --><tr><td rowspan="1" colspan="1"> · </td><td rowspan="1" colspan="1"> 1 </td><td rowspan="1" colspan="1"> ? </td><td rowspan="1" colspan="1"> + </td><td rowspan="1" colspan="1"> * </td></tr><!--        <tr><td>&sp1;0&sp1;</td><td>&sp1;0&sp1;</td><td>&sp1;0&sp1;</td><td>&sp1;0&sp1;</td><td>&sp1;0&sp1;</td><td>&sp1;0&sp1;</td></tr> --><tr><td rowspan="1" colspan="1"> 1 </td><td rowspan="1" colspan="1"> 1 </td><td rowspan="1" colspan="1"> ? </td><td rowspan="1" colspan="1"> + </td><td rowspan="1" colspan="1"> * </td></tr><tr><td rowspan="1" colspan="1"> ? </td><td rowspan="1" colspan="1"> ? </td><td rowspan="1" colspan="1"> ? </td><td rowspan="1" colspan="1"> * </td><td rowspan="1" colspan="1"> * </td></tr><tr><td rowspan="1" colspan="1"> + </td><td rowspan="1" colspan="1"> + </td><td rowspan="1" colspan="1"> * </td><td rowspan="1" colspan="1"> + </td><td rowspan="1" colspan="1"> * </td></tr><tr><td rowspan="1" colspan="1"> * </td><td rowspan="1" colspan="1"> * </td><td rowspan="1" colspan="1"> * </td><td rowspan="1" colspan="1"> * </td><td rowspan="1" colspan="1"> * </td></tr></tbody></table>
        </td></tr></tbody></table></smrules><smexamples><p>For example, here are the result of applying <a href="#jd_prime" class="judgment">prime</a> and
      <a href="#jd_quantifier" class="judgment">quantifier</a> on a few simple types.</p><eg xml:space="preserve">
  prime(element a+)                         = element a
  prime(element a | empty)                  = element a
  prime(element a?,element b?)              = element a | element b
  prime(element a | element b+, element c*) = element a | element b | element c

  quantifier(element a+)                         = +
  quantifier(element a | empty)                  = ?
  quantifier(element a?,element b?)              = *
  quantifier(element a | element b+, element d*) = +
</eg><p>Note that the last occurrence indicator should be '+', since
      the regular expression is such that there must be at least one
      element in the sequence (this element being an 'a' element or a
      'b' element).</p></smexamples><smnote><p>Note that <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) ·
      <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) is always a super type of the
      original type <a href="#doc-fs-Type"><emph>Type</emph></a> I.e.,
      <phrase diff="del" at="E054">
      <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) · <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
      </phrase>
      <phrase diff="add" at="E054">
      <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) · <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)
      </phrase>
      always
      holds. Therefore, it is appropriate to used it as an
      approximation for the type of an expression. This property is
      required for the soundness of the static type analysis.</p></smnote><smrules><p>Finally, a type <a href="#doc-fs-Type"><emph>Type</emph></a> and an occurrence indicator can be
      combined back together to yield a new type with the ·
      operation, as follows.</p><table summary="" role="figure"><col align="left" span="1"/><col align="center" span="1"/><col align="left" span="1"/><tbody><tr><td rowspan="1" colspan="1"><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_quantifier" class="judgment">·</a> 1</td><td rowspan="1" colspan="1">  =  </td><td rowspan="1" colspan="1"><a href="#doc-fs-Type"><emph>Type</emph></a></td></tr><tr><td rowspan="1" colspan="1"><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_quantifier" class="judgment">·</a> ?</td><td rowspan="1" colspan="1">  =  </td><td rowspan="1" colspan="1"><a href="#doc-fs-Type"><emph>Type</emph></a>?</td></tr><tr><td rowspan="1" colspan="1"><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_quantifier" class="judgment">·</a> +</td><td rowspan="1" colspan="1">  =  </td><td rowspan="1" colspan="1"><a href="#doc-fs-Type"><emph>Type</emph></a>+</td></tr><tr><td rowspan="1" colspan="1"><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_quantifier" class="judgment">·</a> *</td><td rowspan="1" colspan="1">  =  </td><td rowspan="1" colspan="1"><a href="#doc-fs-Type"><emph>Type</emph></a>*</td></tr></tbody></table></smrules></div2><div2 id="sec_promotion_judgments"><head>Judgments for function calls</head><smintro><p>Function calls can perform type promotion between atomic
      types. This section introduces judgments which describe type
      promotion for the purpose of the dynamic and static semantics.
      These promotion rules include promoting <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> to any
      other type.</p></smintro><div3 id="sec_promotion"><head>Type promotion</head><smnotation><p id="jd_can_be_promoted_to">The judgment</p><display>
          <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression></clause>
      </display><p>holds if type <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> can be promoted to type
      <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>.</p></smnotation><smexample><p>For example, the following judgments hold:</p><eg xml:space="preserve">
  xs:integer  can be promoted to  xs:integer
  xs:decimal  can be promoted to  xs:float
  xs:integer  can be promoted to  xs:float
  xs:float    can be promoted to  xs:double
</eg></smexample><smrules><p>This judgment is specified by the following rules.</p><p><code>xs:decimal</code> can be promoted to <code>xs:float</code>:</p><infergr><infer><prejudge/><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <code>xs:decimal</code> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <code>xs:float</code>
           </expression></clause></multiclause></postjudge></infer></infergr><p><code>xs:float</code> can be promoted to <code>xs:double</code>:</p><infergr><infer><prejudge/><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <code>xs:float</code> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <code>xs:double</code>
           </expression></clause></multiclause></postjudge></infer></infergr><p diff="add" at="E010"><code>xs:anyURI</code> can be promoted to <code>xs:string</code>:</p><infergr diff="add" at="E010"><infer><prejudge/><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <code>xs:anyURI</code> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <code>xs:string</code>
           </expression></clause></multiclause></postjudge></infer></infergr><p><a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> can be promoted to any atomic type:</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>
           </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
           </expression></clause></multiclause></postjudge></infer></infergr><p>A type can be promoted to itself or to any type of which it
      is a subtype:</p><infergr><infer><prejudge/><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
           </expression></clause></multiclause></postjudge></infer></infergr><infergr><infer><prejudge><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
             <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
           </expression></clause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
           </expression></clause></multiclause></postjudge></infer></infergr><p>Type promotion is transitive:</p><infergr><infer><prejudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
           </expression></clause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript>
           </expression></clause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript>
           </expression></clause></multiclause></postjudge></infer></infergr><p>Finally, type promotion distributes over occurrence and union
      constructors.</p><infergr><infer><prejudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)
              </expression></clause><clause><expression>
                <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) &lt;= <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)
              </expression></clause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
                </expression></clause></multiclause></postjudge></infer><infer><prejudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
              </expression></clause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
              </expression></clause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
                  (<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> | <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>) <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
                </expression></clause></multiclause></postjudge></infer></infergr></smrules><p>where the <quote>&lt;=</quote> operator for occurrence
      indicators denotes set inclusion of the subsets of the allowed
      occurrences.</p><smnotation><p id="jd_promotes_to">The judgment</p><display>
          <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_promotes_to" class="judgment"><term>against</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
        <a href="#jd_promotes_to" class="judgment"><term>promotes to</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression></clause>
      </display><p>holds if value <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> can be promoted to the value
      <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> against the type <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>.</p></smnotation><smexample><p>For example, the following judgments hold</p><eg xml:space="preserve">
  1     of type xs:integer  against  xs:integer  promotes to  1     of type xs:integer
  1     of type xs:integer  against  xs:decimal  promotes to  1     of type xs:integer
  1     of type xs:integer  against  xs:float    promotes to  1.0e0 of type xs:float
  1.0e0 of type xs:float    against  xs:double   promotes to  1.0e0 of type xs:double
</eg><p>Note that type promotion changes the value, and only occurs
       if the input value does not match the target type.</p></smexample><smrules><p>This judgment is specified by the following rules.</p><p>If the value matches the target type, then it is promoted to
      itself</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
            <a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_promotes_to" class="judgment"><term>against</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_promotes_to" class="judgment"><term>promotes to</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
           </expression></clause></multiclause></postjudge></infer></infergr><p>If the value does not match the target type, but is an atomic
      value and it matches a type which can be promoted to the target
      type, then the value is cast to the target type.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a><subscript>1</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript>
           </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>2</subscript>
           </expression></clause></multiclause><multiclause><clause><expression>
             <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript> != <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>2</subscript>
           </expression></clause></multiclause><multiclause><clause><expression><a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a><subscript>1</subscript> <a href="#jd_cast_value_to" class="judgment"><term>cast value to type</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>2</subscript>
           <a href="#jd_cast_value_to" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a><subscript>2</subscript></expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a><subscript>1</subscript> <a href="#jd_promotes_to" class="judgment"><term>against</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>2</subscript> <a href="#jd_promotes_to" class="judgment"><term>promotes to</term></a> <a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a><subscript>2</subscript>
           </expression></clause></multiclause></postjudge></infer></infergr></smrules></div3></div2><div2 id="sec_validation_mode"><head>Judgments for validation modes and contexts</head><div3 id="jd_aux_context_is"><head>Elements in validation mode</head><smnotation><p>A validation mode may occur explicitly in a validate
      expression <specref ref="sec_validate_expr"/>. The following
      <a href="#jd_in_validation_context" class="judgment"><term>with mode</term></a> judgment resolves an element name within a given
      validation mode to the type that the element name denotes. The
      judgment is used in the semantics of the validate expression and
      in sequence type.</p><p id="jd_in_validation_context">The judgment</p><display>
          <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-xquery-ElementNameOrWildcard"><emph>ElementNameOrWildcard</emph></a> <a href="#jd_in_validation_context" class="judgment"><term>with mode</term></a> <emph>ValidationMode</emph> <a href="#jd_in_validation_context" class="judgment"><term>resolves to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause>
        </display><p>holds when the possibly optional element name resolves to
        the given type in the given validation mode.</p></smnotation><smrules><p>We start with the rules for the global validation
      context.</p><p>If no element name is present, the global validation context
      resolves to the union of all element types that are globally
      declared.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>1</subscript> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript>
           </expression></clause></multiclause><multiclause><clause><expression>...</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>n</subscript> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>n</subscript>
           </expression></clause></multiclause><multiclause><clause><expression>
<a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_elem_decl" class="env">elemDecl</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript>) = define element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>1</subscript> <a href="#doc-fs-OptSubstitution"><emph>OptSubstitution</emph></a><subscript>1</subscript> <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a><subscript>1</subscript> <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a><subscript>1</subscript> </expression></clause></multiclause><multiclause><clause><expression>...</expression></clause></multiclause><multiclause><clause><expression>
<a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_elem_decl" class="env">elemDecl</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>n</subscript>) = define element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>n</subscript> <a href="#doc-fs-OptSubstitution"><emph>OptSubstitution</emph></a><subscript>n</subscript> <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a><subscript>n</subscript> <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a><subscript>n</subscript> </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><phrase diff="add" at="E023">* </phrase><a href="#jd_in_validation_context" class="judgment"><term>with mode</term></a> <emph>ValidationMode</emph>
          <a href="#jd_in_validation_context" class="judgment"><term>resolves to</term></a> (element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>1</subscript> | ... |
          element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>n</subscript>)</expression></clause></postjudge></infer></infergr><p>If the element name is globally declared in the schema, it
      resolves to the element type of the corresponding global element
      declaration, independently of the validation mode.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           </expression></clause></multiclause><multiclause><clause><expression>
<a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_elem_decl" class="env">elemDecl</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>) = define element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#doc-fs-OptSubstitution"><emph>OptSubstitution</emph></a> <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a> <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#jd_in_validation_context" class="judgment"><term>with mode</term></a>
          <emph>ValidationMode</emph> <a href="#jd_in_validation_context" class="judgment"><term>resolves to</term></a> element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a></expression></clause></postjudge></infer></infergr><p>If an element name is not globally defined and the validation
      mode is lax, then the element name resolves to the element type
      with the given element name with any content type.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           </expression></clause></multiclause><multiclause><clause><expression>
<a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_elem_decl" class="env">elemDecl</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>) undefined </expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#jd_in_validation_context" class="judgment"><term>with mode</term></a> lax
          <a href="#jd_in_validation_context" class="judgment"><term>resolves to</term></a> element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> of type <code>xs:anyType</code></expression></clause></postjudge></infer></infergr></smrules></div3></div2></div1><!--  Keep this comment at the end of the file
Local variables:
mode: xml
sgml-indent-step:2
indent-tabs-mode:nil
sgml-parent-document:("XPathXQuerySemantics.xml" "body" "div1")
End:
--></body><back><!-- *************************** Core Grammar         **************** --><div1 id="sec_core"><head>Normalized core and formal grammars</head><p>This section contains the set of productions for the of
  [XPath/XQuery] grammar after it has been normalized, sometimes referred
  to as the <quote>core</quote> grammar, and for the formal grammar
  productions.</p><div2 id="sec_core_grammar"><head>Core BNF</head><p>The following grammar uses the same Basic EBNF notation as
     <bibref ref="REC-xml"/>, except that grammar symbols always have
     initial capital letters. The EBNF contains the lexemes embedded
     in the productions.</p><scrap headstyle="show"><head id="DefinedLexemes">Named Terminals</head><prodrecap role="DefinedLexemes" ref="DefinedLexemes" at="../build/core-grammar.xml"/></scrap><scrap id="BNF-Grammar" role="non-terminal-structure-expand" headstyle="show"><head id="BNF-Grammar-prods">Non-Terminals</head><prodrecap role="BNF-Grammar-prods" ref="BNF-Grammar-prods" at="../build/core-grammar.xml"/></scrap><scrap headstyle="show"><head/><prodrecap id="LocalTerminalSymbols" ref="LocalTerminalSymbols" at="../build/core-grammar.xml"/></scrap></div2><div2 id="sec_formal_grammar"><head>Formal BNF</head><p>The following grammar uses the same Basic EBNF notation as
     <bibref ref="REC-xml"/>, except that grammar symbols always have
     initial capital letters. The EBNF contains the lexemes embedded
     in the productions.</p><scrap headstyle="show"><head id="Formal-DefinedLexemes">Named Terminals</head><prodrecap role="DefinedLexemes" ref="DefinedLexemes" at="../src/formal-grammar.xml"/></scrap><scrap id="Formal-BNF-Grammar" role="non-terminal-structure-expand" headstyle="show"><head id="Formal-BNF-Grammar-prods">Non-Terminals</head><prodrecap role="BNF-Grammar-prods" ref="BNF-Grammar-prods" at="../src/formal-grammar.xml"/></scrap></div2></div1><div1 id="sec_indexes"><head>Index of judgments</head><p>Here is the list of the judgments defined in this
  specification.</p><p>Main judgments:</p><ulist><item><p>
    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>Expr</emph> <a href="#jd_has_type_extension" class="judgment"><term>:</term><subscript>ext</subscript></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a>; <a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a></expression></clause>
</p></item></ulist><p>Auxiliary judgments:</p><ulist><item><p>
    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>(<emph>AnyURI</emph> | #MAIN) <a href="#jd_module_statEnv" class="judgment"><term>=&gt;</term><subscript>module_statEnv</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a></expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>(<emph>AnyURI</emph> | #MAIN) <a href="#jd_module_dynEnv" class="judgment"><term>=&gt;</term><subscript>module_dynEnv</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a></expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></environment><expression><emph>PrologDeclList</emph> <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a>
        <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript> <a href="#jd_yields_context" class="judgment"><term>with</term></a> <emph>PrologDeclList</emph><subscript>1</subscript></expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript></environment><expression><emph>PrologDeclList</emph> <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a>
        <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>2</subscript></expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></environment><expression><emph>Definitions</emph> <a href="#jd_yields_type_context" class="judgment"><term>=&gt;</term><subscript>type</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript> ; <emph>AnyURI</emph></environment><expression>
        <phrase diff="chg" at="E006">
        (<emph>FunctionKey</emph><subscript>1</subscript>,<emph>FunctionSig</emph><subscript>1</subscript>) ...
        (<emph>FunctionKey</emph><subscript>n</subscript>,<emph>FunctionSig</emph><subscript>n</subscript>)
        </phrase>
        <a href="#jd_import_functions" class="judgment"><term>=&gt;</term><subscript>import_functions</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>2</subscript></expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript> ; <emph>AnyURI</emph></environment><expression>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>), ···,
      (<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>n</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>) <a href="#jd_import_variables" class="judgment"><term>=&gt;</term><subscript>import_variables</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>2</subscript></expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-OptMixed"><emph>OptMixed</emph></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_adjusts_to" class="judgment"><term>adjusts to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_promotes_to" class="judgment"><term>against</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
        <a href="#jd_promotes_to" class="judgment"><term>promotes to</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_against" class="judgment"><term>against</term></a> <emph>FormalCaseClauses</emph> <a href="#jd_against" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a> ( <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> )
          <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_axis_type" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
             <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><a href="#jd_axis" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis" class="judgment"><term>of</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_axis" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_type_case" class="judgment"><term>case</term></a> <emph>FormalCaseClause</emph> <a href="#jd_type_case" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause>
</p></item><item diff="add" at="E032"><p>
    <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_can_be_cast_to" class="judgment"><term>can be cast to</term></a> <emph>SingleType</emph></expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression></clause>
</p></item><item><p>
    <clause><expression><a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a><subscript>1</subscript> <a href="#jd_cast_value_to" class="judgment"><term>cast value to type</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a>
            <a href="#jd_cast_value_to" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a><subscript>2</subscript></expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_data" class="judgment"><term>data on</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression></clause>
</p></item><item diff="add" at="E008"><p>
    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> <a href="#jd_denotes_a_constructor_function" class="judgment"><term>denotes a constructor function</term></a></expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_erases_to" class="judgment"><term>erases to</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a> <a href="#jd_expands_to" class="judgment"><term>expands to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_extended_by" class="judgment"><term>extended by</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_extended_by" class="judgment"><term>is</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause>
</p></item><item><p>
    <clause><expression><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript>
          <a href="#jd_extended_with_dynamic_environment" class="judgment"><term>extended with dynamic environment</term></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>2</subscript>
          <a href="#jd_extended_with_dynamic_environment" class="judgment"><term>yields</term></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>3</subscript>
          <a href="#jd_extended_with_dynamic_environment" class="judgment"><term>for uri</term></a> <emph>AnyURI</emph></expression></clause>
</p></item><item><p>
    <clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript>
        <a href="#jd_extended_with_static_environment" class="judgment"><term>extended with static environment</term></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript>
        <a href="#jd_extended_with_static_environment" class="judgment"><term>yields</term></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>3</subscript>
        <a href="#jd_extended_with_static_environment" class="judgment"><term>for uri</term></a> <emph>AnyURI</emph></expression></clause>
</p></item><item><p>
    <clause><expression><a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_filter" class="judgment"><term>filter</term></a> @<emph>QName</emph> <a href="#jd_filter" class="judgment"><term>=&gt;</term></a> <a href="#jd_filter" class="judgment"><term>absent</term></a></expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_function_declaration" class="judgment"><term>function declaration</term></a> <emph>FunctionDecl</emph>
               <a href="#jd_function_declaration" class="judgment"><term>with signature</term></a> <emph>FunctionSig</emph> <a href="#jd_function_declaration" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>r</subscript>
               </expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><a href="#jd_function_with_types" class="judgment"><term>function</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           <a href="#jd_function_with_types" class="judgment"><term>with types</term></a> (<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,...,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>)
           <a href="#jd_function_with_types" class="judgment"><term>on values</term></a>
           (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>,...,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript>)
           <a href="#jd_function_with_types" class="judgment"><term>yields</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a></expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>LiteralExpr</emph> <a href="#jd_has_atomic_value" class="judgment"><term>has atomic value</term></a> <a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a></expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_has_attribute_content" class="judgment"><term>has attribute content</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression></clause>
</p></item><item diff="add" at="E033"><p>
    <clause><expression><a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>1</subscript> <a href="#jd_has_base_atomic_type" class="judgment"><term>has base atomic type</term></a> <a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>2</subscript></expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_has_element_content" class="judgment"><term>has node content</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression></clause>
</p></item><item><p>
    <clause><expression><emph>Axis</emph> <a href="#jd_principal" class="judgment"><term>has principal</term></a>
         <emph>PrincipalNodeKind</emph></expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_interleave" class="judgment"><term>interleave</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>
          <a href="#jd_interleave" class="judgment"><term>yields</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>3</subscript></expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_union_interpretation" class="judgment"><term>is</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
          <a href="#jd_union_interpretation" class="judgment"><term>extended with union interpretation of</term></a> 
          <a href="#doc-fs-TypeName"><emph>TypeName</emph></a></expression></clause>
</p></item><item><p>
    <clause><expression><emph>AnyURI</emph> <a href="#jd_is_target_namespace_of_modules" class="judgment"><term>is target namespace of modules</term></a>
      <emph>Module</emph><subscript>1</subscript> ... <emph>Module</emph><subscript>n</subscript></expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_mixes_to" class="judgment"><term>mixes to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#jd_lookup" class="judgment"><term>name lookup</term></a> <a href="#doc-fs-ElementType"><emph>ElementType</emph></a>
          <a href="#jd_lookup" class="judgment"><term>yields</term></a> <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a>
          <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a> <a href="#jd_attribute_lookup" class="judgment"><term>name lookup</term></a>
          <a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a> <a href="#jd_attribute_lookup" class="judgment"><term>yields</term></a>
          <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_nil_annotate_as" class="judgment"><term>nil-annotate as</term></a> <a href="#doc-fs-Nillable"><emph>Nillable</emph></a>? <a href="#doc-fs-Type"><emph>Type</emph></a> (
          <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> ) <a href="#jd_nil_annotate_as" class="judgment"><term>=&gt;</term></a>
          <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>QName</emph> <a href="#jd_attr_qname_expands_to" class="judgment"><term>of attr expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>QName</emph> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>QName</emph> <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>QName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a> <emph>Variable</emph></expression></clause>
</p></item><item><p>
    <clause><expression><a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> <a href="#jd_operator_type_for" class="judgment"><term>operator type for</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript> <a href="#jd_operator_type_for" class="judgment"><term>and</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>2</subscript> <a href="#jd_operator_type_for" class="judgment"><term>is</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>3</subscript></expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a>
          <a href="#jd_resolves_to" class="judgment"><term>resolves to</term></a> <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> { <a href="#doc-fs-Type"><emph>Type</emph></a> }</expression></clause>
</p></item><item diff="add" at="E033"><p>
    <clause><expression>
        <a href="#jd_sacfsw" class="judgment"><term>second argument contribution for sum with</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_sacfsw" class="judgment"><term>and</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_sacfsw" class="judgment"><term>is</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript>
      </expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_cast_as" class="judgment"><term>simply annotate as</term></a> <emph>SimpleType</emph> ( <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a>
            ) <a href="#jd_cast_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript></expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a> <a href="#jd_simply_erases_to" class="judgment"><term>simply erases to</term></a>
          <emph>String</emph></expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>1</subscript> <a href="#jd_substitutes_for" class="judgment"><term>substitutes for</term></a> <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>2</subscript></expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a> <a href="#jd_attribute_static_lookup" class="judgment"><term>type lookup</term></a>
          <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-ElementType"><emph>ElementType</emph></a> <a href="#jd_static_lookup" class="judgment"><term>type lookup</term></a> <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a>
          <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test_type" class="judgment"><term>with</term></a>
             <emph>PrincipalNodeKind</emph> <a href="#jd_test_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
             <a href="#jd_test_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><a href="#jd_test" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test" class="judgment"><term>with</term></a>
           <emph>PrincipalNodeKind</emph> <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_test" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression></clause>
</p></item><item><p>
    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-xquery-ElementNameOrWildcard"><emph>ElementNameOrWildcard</emph></a> <a href="#jd_in_validation_context" class="judgment"><term>with mode</term></a> <emph>ValidationMode</emph> <a href="#jd_in_validation_context" class="judgment"><term>resolves to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause>
</p></item><item diff="add" at="E029"><p>
    <clause><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript> <a href="#jd_with_text_nodes_processed_is" class="judgment"><term>with text nodes processed is</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript></expression></clause>
</p></item></ulist></div1><div1 id="sec_functions_and_operators"><head>Functions and Operators</head><div2 id="sec_used_functions"><head>Functions and Operators used in the Formal Semantics</head><p>Here is the list of functions from the <bibref ref="xpath-functions-30"/> document
    that are used in the [XPath/XQuery] Formal Semantics:</p><ulist><item><p id="func-add-dayTimeDurations"><xspecref spec="FO" ref="func-add-dayTimeDurations"/></p></item><item><p id="func-add-dayTimeDuration-to-dateTime"><xspecref spec="FO" ref="func-add-dayTimeDuration-to-dateTime"/></p></item><item><p id="func-add-dayTimeDuration-to-date"><xspecref spec="FO" ref="func-add-dayTimeDuration-to-date"/></p></item><item><p id="func-add-dayTimeDuration-to-time"><xspecref spec="FO" ref="func-add-dayTimeDuration-to-time"/></p></item><item><p id="func-add-yearMonthDurations"><xspecref spec="FO" ref="func-add-yearMonthDurations"/></p></item><item><p id="func-add-yearMonthDuration-to-dateTime"><xspecref spec="FO" ref="func-add-yearMonthDuration-to-dateTime"/></p></item><item><p id="func-add-yearMonthDuration-to-date"><xspecref spec="FO" ref="func-add-yearMonthDuration-to-date"/></p></item><item><p id="func-boolean-equal"><xspecref spec="FO" ref="func-boolean-equal"/></p></item><item><p id="func-boolean-greater-than"><xspecref spec="FO" ref="func-boolean-greater-than"/></p></item><item><p id="func-boolean-less-than"><xspecref spec="FO" ref="func-boolean-less-than"/></p></item><item><p id="func-boolean"><xspecref spec="FO" ref="func-boolean"/></p></item><item><p id="func-compare"><xspecref spec="FO" ref="func-compare"/></p></item><item><p id="func-concatenate"><xspecref spec="FO" ref="func-concatenate"/></p></item><item><p id="func-count"><xspecref spec="FO" ref="func-count"/></p></item><item><p id="func-dateTime-equal"><xspecref spec="FO" ref="func-dateTime-equal"/></p></item><item><p id="func-dateTime-greater-than"><xspecref spec="FO" ref="func-dateTime-greater-than"/></p></item><item><p id="func-dateTime-less-than"><xspecref spec="FO" ref="func-dateTime-less-than"/></p></item><item><p id="func-dayTimeDuration-greater-than"><xspecref spec="FO" ref="func-dayTimeDuration-greater-than"/></p></item><item><p id="func-dayTimeDuration-less-than"><xspecref spec="FO" ref="func-dayTimeDuration-less-than"/></p></item><item><p id="func-divide-dayTimeDuration"><xspecref spec="FO" ref="func-divide-dayTimeDuration"/></p></item><item><p id="func-divide-yearMonthDuration"><xspecref spec="FO" ref="func-divide-yearMonthDuration"/></p></item><item><p id="func-data"><xspecref spec="FO" ref="func-data"/></p></item><item><p id="func-empty"><xspecref spec="FO" ref="func-empty"/></p></item><item><p id="func-error"><xspecref spec="FO" ref="func-error"/></p></item><item><p id="func-except"><xspecref spec="FO" ref="func-except"/></p></item><item><p id="func-false"><xspecref spec="FO" ref="func-false"/></p></item><item><p id="func-intersect"><xspecref spec="FO" ref="func-intersect"/></p></item><item><p id="func-is-same-node"><xspecref spec="FO" ref="func-is-same-node"/></p></item><item><p id="func-last"><xspecref spec="FO" ref="func-last"/></p></item><item><p id="func-multiply-dayTimeDuration"><xspecref spec="FO" ref="func-multiply-dayTimeDuration"/></p></item><item><p id="func-multiply-yearMonthDuration"><xspecref spec="FO" ref="func-multiply-yearMonthDuration"/></p></item><item><p id="func-node-after"><xspecref spec="FO" ref="func-node-after"/></p></item><item><p id="func-node-before"><xspecref spec="FO" ref="func-node-before"/></p></item><item><p id="func-NOTATION-equal"><xspecref spec="FO" ref="func-NOTATION-equal"/></p></item><item><p id="func-not"><xspecref spec="FO" ref="func-not"/></p></item><item><p id="func-numeric-add"><xspecref spec="FO" ref="func-numeric-add"/></p></item><item><p id="func-numeric-divide"><xspecref spec="FO" ref="func-numeric-divide"/></p></item><item><p id="func-numeric-equal"><xspecref spec="FO" ref="func-numeric-equal"/></p></item><item><p id="func-numeric-greater-than"><xspecref spec="FO" ref="func-numeric-greater-than"/></p></item><item><p id="func-numeric-less-than"><xspecref spec="FO" ref="func-numeric-less-than"/></p></item><item><p id="func-numeric-mod"><xspecref spec="FO" ref="func-numeric-mod"/></p></item><item><p id="func-numeric-multiply"><xspecref spec="FO" ref="func-numeric-multiply"/></p></item><item><p id="func-numeric-subtract"><xspecref spec="FO" ref="func-numeric-subtract"/></p></item><item><p id="func-numeric-unary-minus"><xspecref spec="FO" ref="func-numeric-unary-minus"/></p></item><item><p id="func-numeric-unary-plus"><xspecref spec="FO" ref="func-numeric-unary-plus"/></p></item><item><p id="func-position"><xspecref spec="FO" ref="func-position"/></p></item><item><p id="func-QName-equal"><xspecref spec="FO" ref="func-QName-equal"/></p></item><item><p id="func-root"><xspecref spec="FO" ref="func-root"/></p></item><item><p id="func-round"><xspecref spec="FO" ref="func-round"/></p></item><item diff="add" at="E031"><p id="func-string-join"><xspecref spec="FO" ref="func-string-join"/></p></item><item diff="del" at="E024"><p id="func-subsequence"><xspecref spec="FO" ref="func-subsequence"/></p></item><item><p id="func-subtract-dayTimeDuration-from-dateTime"><xspecref spec="FO" ref="func-subtract-dayTimeDuration-from-dateTime"/></p></item><item><p id="func-subtract-dayTimeDuration-from-date"><xspecref spec="FO" ref="func-subtract-dayTimeDuration-from-date"/></p></item><item><p id="func-subtract-dayTimeDuration-from-time"><xspecref spec="FO" ref="func-subtract-dayTimeDuration-from-time"/></p></item><item><p id="func-subtract-dayTimeDurations"><xspecref spec="FO" ref="func-subtract-dayTimeDurations"/></p></item><item><p id="func-subtract-yearMonthDuration-from-dateTime"><xspecref spec="FO" ref="func-subtract-yearMonthDuration-from-dateTime"/></p></item><item><p id="func-subtract-yearMonthDuration-from-date"><xspecref spec="FO" ref="func-subtract-yearMonthDuration-from-date"/></p></item><item><p id="func-subtract-yearMonthDurations"><xspecref spec="FO" ref="func-subtract-yearMonthDurations"/></p></item><item><p id="func-to"><xspecref spec="FO" ref="func-to"/></p></item><item><p id="func-true"><xspecref spec="FO" ref="func-true"/></p></item><item><p id="func-union"><xspecref spec="FO" ref="func-union"/></p></item><item><p id="func-yearMonthDuration-greater-than"><xspecref spec="FO" ref="func-yearMonthDuration-greater-than"/></p></item><item><p id="func-yearMonthDuration-less-than"><xspecref spec="FO" ref="func-yearMonthDuration-less-than"/></p></item></ulist></div2><div2 id="sec_operators"><head>Mapping of Overloaded Internal Functions</head><p>This section gives the semantics specific to overloaded
    internal functions (with prefix <emph>fs:</emph>) that are used to
    define overloaded XQuery operators (with prefix <emph>op:</emph>),
    such as comparison expressions or arithmetic expressions. Static
    typing for those functions are defined over unions of (possibly
    optional) atomic types. The semantics is obtained in three
    steps. First, a rule is applied to deal with the union of those
    (possibly optional) atomic types. A second set of rules treat the
    cases where one of the operands of those functions is the empty
    type (resp. empty sequence) or optional. Finally, a final rule
    deals with type promotion and access to an operators mapping table
    which maps the overloaded internal functions to the appropriate
    operator functions defined in <bibref ref="xpath-functions-30"/> and give the
    corresponding type.</p><smnotation><p>The following auxiliary grammar production describe optional
      atomic types.</p><scrap headstyle="show"><head>OptAtomicType</head><prodrecap ref="OptAtomicType" id="OptAtomicType" orig="formal"/></scrap></smnotation><smtype><p>The following static typing rules apply generically to all
      the <emph>fs:</emph> special functions. They do not apply to any
      other function calls, which are treated in <specref ref="id-function-calls"/>.</p><p>First, if the static type of one or several of the
      expressions passed as argument is a union of atomic types, the
      function call is type checked once separately for each atomic
      type in that union. The static type of the entire function call
      expression is then the union of the types computed in each
      case.</p><infergr><infer><prejudge><multiclause><clause><expression>
                  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> = (<a href="#doc-fs-OptAtomicType"><emph>OptAtomicType</emph></a><subscript>1</subscript><subscript>,1</subscript>|...|<a href="#doc-fs-OptAtomicType"><emph>OptAtomicType</emph></a><subscript>m</subscript><subscript>,1</subscript>)
                </expression></clause></multiclause><multiclause><clause><expression>
                  ...
                </expression></clause></multiclause><multiclause><clause><expression>
                  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript> = (<a href="#doc-fs-OptAtomicType"><emph>OptAtomicType</emph></a><subscript>1</subscript><subscript>,n</subscript>|...|<a href="#doc-fs-OptAtomicType"><emph>OptAtomicType</emph></a><subscript>m</subscript><subscript>,n</subscript>)
                </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
                  <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-fs-OptAtomicType"><emph>OptAtomicType</emph></a><subscript>1</subscript><subscript>,1</subscript>,..., <a href="#doc-fs-OptAtomicType"><emph>OptAtomicType</emph></a><subscript>1</subscript><subscript>,n</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-OptAtomicType"><emph>OptAtomicType</emph></a><subscript>1</subscript>'
                </expression></clause></multiclause><multiclause><clause><expression>...</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
                  <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-fs-OptAtomicType"><emph>OptAtomicType</emph></a><subscript>m</subscript><subscript>,1</subscript>,..., <a href="#doc-fs-OptAtomicType"><emph>OptAtomicType</emph></a><subscript>m</subscript><subscript>,n</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-OptAtomicType"><emph>OptAtomicType</emph></a><subscript>r</subscript>'
                </expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
                  <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, ..., <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>)
                  <a href="#jd_has_type" class="judgment"><term>:</term></a>
                  (<a href="#doc-fs-OptAtomicType"><emph>OptAtomicType</emph></a><subscript>1</subscript>'|...|<a href="#doc-fs-OptAtomicType"><emph>OptAtomicType</emph></a><subscript>r</subscript>')
                </expression></clause></multiclause></postjudge></infer></infergr><smnote><p>Note that this approach can be used since the type declared
        for a function parameter is never itself be a union.</p></smnote><p>The following rules deal with optional arguments. In the case
      of binary operators, if either one of the types of the operands
      is empty, the resulting type is empty.</p><infergr><infer><prejudge><multiclause><clause><expression>
		  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> = empty
		</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
		  <emph><a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></emph>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> empty
		</expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><expression>
		  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> = empty
		</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
		  <emph><a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></emph>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> empty
		</expression></clause></postjudge></infer></infergr><p>If either one of the types of the operands is optional, the
        type obtained by propagating the optional occurrence
        indicator.</p><infergr><infer><prejudge><multiclause><clause><expression>
		  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> = <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript>
		</expression></clause></multiclause><multiclause><clause><expression>
		  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> = <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>2</subscript>?
		</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
          <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript>,<a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>2</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>3</subscript>
		</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
		  <emph><a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></emph>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>3</subscript>?
		</expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><expression>
		  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> = <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript>?
		</expression></clause></multiclause><multiclause><clause><expression>
		  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> = <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>2</subscript>
		</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
          <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript>,<a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>2</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>3</subscript>
		</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
		  <emph><a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></emph>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>3</subscript>?
		</expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><expression>
		  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> = <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript>?
		</expression></clause></multiclause><multiclause><clause><expression>
		  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> = <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>2</subscript>?
		</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
          <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript>,<a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>2</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>3</subscript>
		</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
		  <emph><a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></emph>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>3</subscript>?
		</expression></clause></postjudge></infer></infergr><p>In the case of unary operators, if the type of the operand is
      empty, the resulting type is empty.</p><infergr><infer><prejudge><multiclause><clause><expression>
		  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> = empty
		</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
		  <emph><a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></emph>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> empty
		</expression></clause></postjudge></infer></infergr><p>Finally, the resulting type is obtained by performing type
      promotion and accessing the operators mapping table (using the
      <a href="#jd_operator_type_for" class="judgment"><term>operator type for</term></a> judgment defined below).</p><infergr><infer><prejudge><multiclause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript>'</expression></clause></multiclause><multiclause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>2</subscript> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>2</subscript>'</expression></clause></multiclause><multiclause><clause><expression>
		  <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> <a href="#jd_operator_type_for" class="judgment"><term>operator type for</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript> <a href="#jd_operator_type_for" class="judgment"><term>and</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>2</subscript> <a href="#jd_operator_type_for" class="judgment"><term>is</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>3</subscript>
		</expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
                  <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript>,<a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>2</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>3</subscript>
                </expression></clause></multiclause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression><a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript>'</expression></clause></multiclause><multiclause><clause><expression>
		  <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> <a href="#jd_operator_type_for" class="judgment"><term>operator type for</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript> <a href="#jd_operator_type_for" class="judgment"><term>is</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>3</subscript>
		</expression></clause></multiclause></prejudge><postjudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment><expression>
                  <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>3</subscript>
                </expression></clause></multiclause></postjudge></infer></infergr><!--
            Type1 is not a union of atomic types
            Type2 is not a union of atomic types
            statEnv |- Type1 can be promoted to Type1'
            statEnv |- Type2 can be promoted to Type2'
            operator type for Type1' and Type2' is Type3'

            statEnv |- expanded-QName(Type1, Type2) : Type3'

            [expanded-Qname is that of a unary pseudo-function]
            Type1 is not a union of atomic types
            statEnv |- Type1 can be promoted to Type1'
            operator type for Type1' is Type3'

            statEnv |- expanded-QName(Type1) : Type3'
--></smtype><smeval><p>Each <code>fs:</code> overloaded operator maps to the
      corresponding equivalent overloaded <code>op:</code> operator,
      as defined in <bibref ref="xpath-functions-30"/>, and deals with the case where one
      of the operands is the empty sequence.</p><p>The dynamic semantics of the <code>fs:</code> operator is
      similar to using the following user-defined function.</p><table summary=""><tbody><tr><td rowspan="1" colspan="1"><code>declare function</code> <emph>fs:opname</emph><code>($x1 as
            xs:anyAtomicType?, $x2 as xs:anyAtomicType?) as
            xs:anyAtomicType? {</code></td></tr><tr><td rowspan="1" colspan="1">  <code>if (fn:empty($x1) or fn:empty($x2)) then () else</code>
            <map><emph>fs:opname($x1,$x2)</emph></map><a href="#jd_map_overloaded_op" class="judgment"><subscript>OverloadedOp</subscript></a></td></tr><tr><td rowspan="1" colspan="1"><code>};</code></td></tr></tbody></table><p>Where
      <map><emph>fs:opname()</emph></map><a href="#jd_map_overloaded_op" class="judgment"><subscript>OverloadedOp</subscript></a> maps
      to the corresponding op: operator in <bibref ref="xpath-functions-30"/>, as defined
      in the table below.</p></smeval><smnotation><p>The operators mapping table is given below. The table is used
      to define the following auxiliary mapping rules and
      judgments.</p><p id="jd_map_overloaded_op">The mapping rule for binary and
      unary operators</p><display>
        <clause><!-- E056 start --><expression><map><emph>fs:opname1</emph>(<emph>Expr</emph><subscript>1</subscript>,<emph>Expr</emph><subscript>2</subscript>)</map><a href="#jd_map_overloaded_op" class="judgment"><subscript>OverloadedOp</subscript></a>
        == <emph>op:opname2</emph>(<emph>Expr</emph><subscript>1</subscript>,<emph>Expr</emph><subscript>2</subscript>)</expression><!-- E056 end --></clause>
      </display><p>and</p><display>
        <clause><!-- E056 start --><expression><map><emph>fs:opname1</emph>(<emph>Expr</emph><subscript>1</subscript>)</map><a href="#jd_map_overloaded_op" class="judgment"><subscript>OverloadedOp</subscript></a>
        == <emph>op:opname2</emph>(<emph>Expr</emph><subscript>1</subscript>)</expression><!-- E056 end --></clause>
      </display><p>where the operator depends on the type of each value returned
      by <emph>Expr</emph><subscript>1</subscript> and <emph>Expr</emph><subscript>2</subscript>.</p><p id="jd_operator_type_for">The judgments for binary and unary
      operators</p><display>
        <clause><expression>
	  <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> <a href="#jd_operator_type_for" class="judgment"><term>operator type for</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript> <a href="#jd_operator_type_for" class="judgment"><term>and</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>2</subscript> <a href="#jd_operator_type_for" class="judgment"><term>is</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>3</subscript>
	 </expression></clause>
      </display><p>and</p><display>
        <clause><expression>
	  <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> <a href="#jd_operator_type_for" class="judgment"><term>operator type for</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript> <a href="#jd_operator_type_for" class="judgment"><term>is</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>3</subscript>
	 </expression></clause>
      </display><p>hold when the operator table indicates that the operator
      <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> has the output type <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>3</subscript> for the input
      types <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript> and <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>2</subscript>.</p></smnotation><p>Note that in the following table, all numeric functions are
    applied to operands with the same type.  Values are promoted to
    compatible types using the function call semantics given in
    <specref ref="id-function-calls"/>.</p><p><term>Gregorian</term> refers to the types <code>xs:gYearMonth</code>,
    <code>xs:gYear</code>, <code>xs:gMonthDay</code>, <code>xs:gDay</code>, and <code>xs:gMonth</code>.  For
    binary operators that accept two Gregorian-type operands, both
    operands must have the same type (for example, if one operand is
    of type <code>xs:gDay</code>, the other operand must be of type
    <code>xs:gDay</code>.)</p><table summary="" border="1"><caption>Binary Operators</caption><tbody><tr><th rowspan="1" colspan="1"><small>Internal Function</small></th><th rowspan="1" colspan="1"><small><a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript></small></th><th rowspan="1" colspan="1"><small><a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>2</subscript></small></th><th rowspan="1" colspan="1"><small>Denotes</small></th><th rowspan="1" colspan="1"><small><a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>3</subscript></small></th></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>plus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-add(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>plus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-add(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>plus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-add(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>plus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-add(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>plus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small>op:add-yearMonthDuration-to-date(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>plus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td><td rowspan="1" colspan="1"><small>op:add-yearMonthDuration-to-date(B, A)</small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>plus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small>op:add-dayTimeDuration-to-date(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>plus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td><td rowspan="1" colspan="1"><small>op:add-dayTimeDuration-to-date(B, A)</small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>plus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:time</code></small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small>op:add-dayTimeDuration-to-time(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:time</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>plus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small><code>xs:time</code></small></td><td rowspan="1" colspan="1"><small>op:add-dayTimeDuration-to-time(B, A)</small></td><td rowspan="1" colspan="1"><small><code>xs:time</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>plus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small>op:add-yearMonthDuration-to-dateTime(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>plus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td><td rowspan="1" colspan="1"><small>op:add-yearMonthDuration-to-dateTime(B, A)</small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>plus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small>op:add-dayTimeDuration-to-dateTime(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>plus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td><td rowspan="1" colspan="1"><small>op:add-dayTimeDuration-to-dateTime(B, A)</small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>plus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small>op:add-yearMonthDurations(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>plus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small>op:add-dayTimeDurations(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>minus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-subtract(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>minus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-subtract(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>minus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-subtract(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>minus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-subtract(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>minus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td><td rowspan="1" colspan="1"><small><phrase diff="del" at="E053">fn</phrase><phrase diff="add" at="E053">op</phrase>:subtract-dates(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>minus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small>op:subtract-yearMonthDuration-from-date(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>minus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small>op:subtract-dayTimeDuration-from-date(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>minus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:time</code></small></td><td rowspan="1" colspan="1"><small><code>xs:time</code></small></td><td rowspan="1" colspan="1"><small><phrase diff="del" at="E053">fn</phrase><phrase diff="add" at="E053">op</phrase>:subtract-times(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>minus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:time</code></small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small>op:subtract-dayTimeDuration-from-time(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:time</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>minus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td><td rowspan="1" colspan="1"><small><phrase diff="del" at="E053">fn</phrase><phrase diff="add" at="E053">op</phrase>:subtract-dateTimes(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>minus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small>op:subtract-yearMonthDuration-from-dateTime(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>minus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small>op:subtract-dayTimeDuration-from-dateTime(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>minus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small>op:subtract-yearMonthDurations(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>minus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small>op:subtract-dayTimeDurations(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>times</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-multiply(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>times</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-multiply(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>times</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-multiply(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>times</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-multiply(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>times</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small>op:multiply-yearMonthDuration(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>times</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small>op:multiply-yearMonthDuration(B, A)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>times</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small>op:multiply-dayTimeDuration(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>times</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small>op:multiply-dayTimeDuration(B, A)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>idiv</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1" diff="chg" at="E016"><small>op:numeric-integer-divide(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td></tr><tr diff="add" at="E016"><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>idiv</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-integer-divide(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td></tr><tr diff="add" at="E016"><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>idiv</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-integer-divide(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td></tr><tr diff="add" at="E016"><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>idiv</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-integer-divide(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>div</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-divide(A, B)</small></td><td rowspan="1" colspan="1" diff="chg" at="E025"><small><code>xs:decimal</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>div</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-divide(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>div</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-divide(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>div</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-divide(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>div</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small>op:divide-yearMonthDuration(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>div</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small>op:divide-dayTimeDuration(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>div</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small>op:divide-yearMonthDuration-by-yearMonthDuration(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>div</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small>op:divide-dayTimeDuration-by-dayTimeDuration(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>mod</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-mod(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>mod</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-mod(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>mod</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-mod(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>mod</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-mod(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>eq</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-equal(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>eq</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-equal(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>eq</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-equal(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>eq</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-equal(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>eq</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td><td rowspan="1" colspan="1"><small>op:boolean-equal(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>eq</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:string</code></small></td><td rowspan="1" colspan="1"><small><code>xs:string</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-equal(fn:compare(A, B), 0)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>eq</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td><td rowspan="1" colspan="1"><small>op:date-equal(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>eq</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:time</code></small></td><td rowspan="1" colspan="1"><small><code>xs:time</code></small></td><td rowspan="1" colspan="1"><small>op:time-equal(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>eq</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td><td rowspan="1" colspan="1"><small>op:dateTime-equal(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>eq</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:duration</code></small></td><td rowspan="1" colspan="1"><small><code>xs:duration</code></small></td><td rowspan="1" colspan="1"><small>op:duration-equal(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>eq</code>(A, B)</small></td><td rowspan="1" colspan="1"><small>Gregorian</small></td><td rowspan="1" colspan="1"><small>Gregorian</small></td><td rowspan="1" colspan="1"><small>op:gYear-equal(A, B) etc.</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>eq</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:hexBinary</code></small></td><td rowspan="1" colspan="1"><small><code>xs:hexBinary</code></small></td><td rowspan="1" colspan="1"><small><phrase diff="del" at="E053">op:hex-binary-equal</phrase><phrase diff="add" at="E053">op:hexBinary-equal</phrase>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>eq</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:base64Binary</code></small></td><td rowspan="1" colspan="1"><small><code>xs:base64Binary</code></small></td><td rowspan="1" colspan="1"><small><phrase diff="del" at="E053">op:base64-binary-equal</phrase><phrase diff="add" at="E053">op:base64Binary-equal</phrase>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>eq</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:anyURI</code></small></td><td rowspan="1" colspan="1"><small><code>xs:anyURI</code></small></td><td rowspan="1" colspan="1"><small><phrase diff="chg" at="E010">op:numeric-equal(fn:compare(A, B), 0)</phrase></small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>eq</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:QName</code></small></td><td rowspan="1" colspan="1"><small><code>xs:QName</code></small></td><td rowspan="1" colspan="1"><small>op:QName-equal(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>eq</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:NOTATION</code></small></td><td rowspan="1" colspan="1"><small><code>xs:NOTATION</code></small></td><td rowspan="1" colspan="1"><small>op:NOTATION-equal(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ne</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small><code>fn:not</code>(op:numeric-equal(A, B))</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ne</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small><code>fn:not</code>(op:numeric-equal(A, B))</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ne</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small><code>fn:not</code>(op:numeric-equal(A, B))</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ne</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small><code>fn:not</code>(op:numeric-equal(A, B))</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ne</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td><td rowspan="1" colspan="1"><small><code>fn:not</code>(op:boolean-equal(A, B))</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ne</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:string</code></small></td><td rowspan="1" colspan="1"><small><code>xs:string</code></small></td><td rowspan="1" colspan="1"><small><code>fn:not</code>(op:numeric-equal(fn:compare(A, B), 0))</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ne</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td><td rowspan="1" colspan="1"><small><code>fn:not</code>(op:date-equal(A, B))</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ne</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:time</code></small></td><td rowspan="1" colspan="1"><small><code>xs:time</code></small></td><td rowspan="1" colspan="1"><small><code>fn:not</code>(op:time-equal(A, B))</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ne</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td><td rowspan="1" colspan="1"><small><code>fn:not</code>(op:dateTime-equal(A, B))</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ne</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:duration</code></small></td><td rowspan="1" colspan="1"><small><code>xs:duration</code></small></td><td rowspan="1" colspan="1"><small><code>fn:not</code>(op:duration-equal(A, B))</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ne</code>(A, B)</small></td><td rowspan="1" colspan="1"><small>Gregorian</small></td><td rowspan="1" colspan="1"><small>Gregorian</small></td><td rowspan="1" colspan="1"><small><code>fn:not</code>(op:gYear-equal(A, B)) etc.</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ne</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:hexBinary</code></small></td><td rowspan="1" colspan="1"><small><code>xs:hexBinary</code></small></td><td rowspan="1" colspan="1"><small><code>fn:not</code>(<phrase diff="del" at="E053">op:hex-binary-equal</phrase><phrase diff="add" at="E053">op:hexBinary-equal</phrase>(A, B))</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ne</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:base64Binary</code></small></td><td rowspan="1" colspan="1"><small><code>xs:base64Binary</code></small></td><td rowspan="1" colspan="1"><small><code>fn:not</code>(<phrase diff="del" at="E053">op:base64-binary-equal</phrase><phrase diff="add" at="E053">op:base64Binary-equal</phrase>(A, B))</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ne</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:anyURI</code></small></td><td rowspan="1" colspan="1"><small><code>xs:anyURI</code></small></td><td rowspan="1" colspan="1"><small><code>fn:not</code>(<phrase diff="chg" at="E010">op:numeric-equal(fn:compare(A, B), 0)</phrase>)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ne</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:QName</code></small></td><td rowspan="1" colspan="1"><small><code>xs:QName</code></small></td><td rowspan="1" colspan="1"><small><code>fn:not</code>(op:QName-equal(A, B))</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ne</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:NOTATION</code></small></td><td rowspan="1" colspan="1"><small><code>xs:NOTATION</code></small></td><td rowspan="1" colspan="1"><small><code>fn:not</code>(op:NOTATION-equal(A, B))</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>gt</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-greater-than(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>gt</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-greater-than(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>gt</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-greater-than(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>gt</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-greater-than(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>gt</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td><td rowspan="1" colspan="1"><small>op:boolean-greater-than(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>gt</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:string</code></small></td><td rowspan="1" colspan="1"><small><code>xs:string</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-greater-than(<code>fn:compare</code>(A, B), 0)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>gt</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td><td rowspan="1" colspan="1"><small>op:date-greater-than(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>gt</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:time</code></small></td><td rowspan="1" colspan="1"><small><code>xs:time</code></small></td><td rowspan="1" colspan="1"><small>op:time-greater-than(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>gt</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td><td rowspan="1" colspan="1"><small>op:dateTime-greater-than(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>gt</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small>op:yearMonthDuration-greater-than(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>gt</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small>op:dayTimeDuration-greater-than(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>lt</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-less-than(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>lt</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-less-than(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>lt</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-less-than(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>lt</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-less-than(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>lt</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td><td rowspan="1" colspan="1"><small>op:boolean-less-than(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>lt</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:string</code></small></td><td rowspan="1" colspan="1"><small><code>xs:string</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-less-than(<code>fn:compare</code>(A, B), 0)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>lt</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td><td rowspan="1" colspan="1"><small>op:date-less-than(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>lt</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:time</code></small></td><td rowspan="1" colspan="1"><small><code>xs:time</code></small></td><td rowspan="1" colspan="1"><small>op:time-less-than(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>lt</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td><td rowspan="1" colspan="1"><small>op:dateTime-less-than(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>lt</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small>op:yearMonthDuration-less-than(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>lt</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small>op:dayTimeDuration-less-than(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ge</code>(A,
    B)</small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-greater-than(A, B) or op:numeric-equal(A,B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ge</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-greater-than(A, B) or op:numeric-equal(A,B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ge</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-greater-than(A, B) or op:numeric-equal(A,B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ge</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-greater-than(A, B) or op:numeric-equal(A,B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ge</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-greater-than(A, B) or op:numeric-equal(A,B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ge</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:string</code></small></td><td rowspan="1" colspan="1"><small><code>xs:string</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-greater-than(<code>fn:compare</code>(A, B), -1)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ge</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td><td rowspan="1" colspan="1"><small>op:date-less-than(B, A)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ge</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:time</code></small></td><td rowspan="1" colspan="1"><small><code>xs:time</code></small></td><td rowspan="1" colspan="1"><small>op:time-less-than(B, A)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ge</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td><td rowspan="1" colspan="1"><small>op:dateTime-less-than(B, A)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ge</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small>op:yearMonthDuration-less-than(B, A)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ge</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small>op:dayTimeDuration-less-than(B, A)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>le</code>(A,
    B)</small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-less-than(A, B) or op:numeric-equal(A,B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>le</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-less-than(A, B) or op:numeric-equal(A,B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>le</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-less-than(A, B) or op:numeric-equal(A,B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>le</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-less-than(A, B) or op:numeric-equal(A,B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>le</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-less-than(A, B) or op:numeric-equal(A,B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>le</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:string</code></small></td><td rowspan="1" colspan="1"><small><code>xs:string</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-less-than(<code>fn:compare</code>(A, B), 1)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>le</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td><td rowspan="1" colspan="1"><small>op:date-greater-than(B, A)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>le</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:time</code></small></td><td rowspan="1" colspan="1"><small><code>xs:time</code></small></td><td rowspan="1" colspan="1"><small>op:time-greater-than(B, A)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>le</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td><td rowspan="1" colspan="1"><small>op:dateTime-greater-than(B, A)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>le</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small>op:yearMonthDuration-greater-than(B, A)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>le</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small>op:dayTimeDuration-greater-than(B, A)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>is-same-node</code>(A, B)</small></td><td rowspan="1" colspan="1"><small>node()</small></td><td rowspan="1" colspan="1"><small>node()</small></td><td rowspan="1" colspan="1"><small><code>op:is-same-node</code></small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>node-before</code>(A, B)</small></td><td rowspan="1" colspan="1"><small>node()</small></td><td rowspan="1" colspan="1"><small>node()</small></td><td rowspan="1" colspan="1"><small><code>op:node-before</code></small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>node-after</code>(A,
    B)</small></td><td rowspan="1" colspan="1"><small>node()</small></td><td rowspan="1" colspan="1"><small>node()</small></td><td rowspan="1" colspan="1"><small><code>op:node-after</code></small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td></tr></tbody></table><table border="1" summary="Unary operators"><caption>Unary Operators</caption><tbody><tr><th rowspan="1" colspan="1"><small>Internal Function</small></th><th rowspan="1" colspan="1"><small><a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript></small></th><th rowspan="1" colspan="1"><small>Denotes</small></th><th rowspan="1" colspan="1"><small><a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>3</subscript></small></th></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>unary-plus</code>(A)</small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-unary-plus(A)</small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>unary-plus</code>(A)</small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-unary-plus(A)</small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>unary-plus</code>(A)</small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-unary-plus(A)</small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>unary-plus</code>(A)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-unary-plus(A)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>unary-minus</code>(A)</small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-unary-minus(A)</small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>unary-minus</code>(A)</small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-unary-minus(A)</small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>unary-minus</code>(A)</small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-unary-minus(A)</small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td></tr><tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>unary-minus</code>(A)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-unary-minus(A)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td></tr></tbody></table></div2></div1><div1 id="sec_importing_schema"><head>Importing Schemas</head><p>This section describes how XML Schema declarations, as specified
  by XML Schema are imported into the [XPath/XQuery] type system.</p><div2 id="sec_import_intro"><head>Introduction</head><p>During schema import processing, the [XPath/XQuery] environment
    imports XML Schema declarations and loads them as declarations in
    the [XPath/XQuery] type system. The semantics of that loading process
    is defined by normalization rules that map XML Schema descriptions
    into the [XPath/XQuery] type system.</p><div3 id="sec_import_features"><head>Features</head><p>Here is summarized the XML Schema features which are covered
      by the formal semantics, and handled by the import mapping
      described in this section. For each feature, the following
      indications are used.</p><ulist><item><p><term>Handled</term> indicates features that are relevant for
          [XPath/XQuery], are modeled in the [XPath/XQuery] type system,
          and are supported by the mapping.</p></item><item><p><term>Not in v1.0</term> indicates features that  are relevant to
          [XPath/XQuery], but are not yet modeled in the [XPath/XQuery]
          type system or are not handled by the mapping in XQuery
          V1.0. In case the [XPath/XQuery]
          type system provides appropriate support for those features,
          but the mapping is incomplete, the additional annotation
          <term>mapping only</term> is used.</p></item><item><p><term>Not handled</term> indicates features that are relevant
          for [XPath/XQuery], but are not modeled in the [XPath/XQuery]
          type system, and are not handled by the mapping. Such
          features are typically only related to validation, for which
          the formal semantics defines a partial model.</p></item><item><p><term>Ignored</term> Indicates features that are not relevant
          for [XPath/XQuery], are not modeled in the [XPath/XQuery] type
          system, and are not relevant for the mapping. Such features
          might have to do with documentation of the schema, or might
          affect which Schemas are legal, but do not affect which
          documents match which Schemas.</p></item></ulist><p>Here is the exhaustive list of XML Schema features and their
      status in this document.</p><table summary="" role="figure"><col align="left" span="1"/><col align="center" span="1"/><col align="left" span="1"/><tbody><tr><td rowspan="1" colspan="1"><term>Feature:</term></td><td rowspan="1" colspan="1"><term>Supported</term></td></tr><tr><td rowspan="1" colspan="1">Primitive Simple types</td><td rowspan="1" colspan="1">Handled</td></tr><tr><td rowspan="1" colspan="1">Simple type derivation by restriction</td><td rowspan="1" colspan="1">Handled</td></tr><tr><td rowspan="1" colspan="1">Derivation by list and union</td><td rowspan="1" colspan="1">Handled</td></tr><tr><td rowspan="1" colspan="1">Facets on simple types</td><td rowspan="1" colspan="1">Not handled</td></tr><tr><td rowspan="1" colspan="1">ID and IDREF constraints</td><td rowspan="1" colspan="1">Ignored</td></tr><tr><td rowspan="1" colspan="1">Attribute Declarations</td><td rowspan="1" colspan="1"/></tr><tr><td rowspan="1" colspan="1">    default,fixed,use</td><td rowspan="1" colspan="1">Not in v1.0</td></tr><tr><td rowspan="1" colspan="1">Element Declarations</td><td rowspan="1" colspan="1"/></tr><tr><td rowspan="1" colspan="1">    default, fixed (value constraint)</td><td rowspan="1" colspan="1">Not in v1.0</td></tr><tr><td rowspan="1" colspan="1">    nillable</td><td rowspan="1" colspan="1">Handled</td></tr><tr><td rowspan="1" colspan="1">    substitution group affiliation</td><td rowspan="1" colspan="1">Handled</td></tr><tr><td rowspan="1" colspan="1">    substitution group exclusions</td><td rowspan="1" colspan="1">Ignored</td></tr><tr><td rowspan="1" colspan="1">    disallowed substitutions</td><td rowspan="1" colspan="1">Ignored</td></tr><tr><td rowspan="1" colspan="1">    abstract</td><td rowspan="1" colspan="1">Not in v1.0</td></tr><tr><td rowspan="1" colspan="1">Complex Type Definitions</td><td rowspan="1" colspan="1"/></tr><tr><td rowspan="1" colspan="1">    derivation by restriction</td><td rowspan="1" colspan="1">Handled</td></tr><tr><td rowspan="1" colspan="1">    derivation by extension</td><td rowspan="1" colspan="1">Handled</td></tr><tr><td rowspan="1" colspan="1">    final</td><td rowspan="1" colspan="1">Ignored</td></tr><tr><td rowspan="1" colspan="1">    abstract</td><td rowspan="1" colspan="1">Not in v1.0</td></tr><tr><td rowspan="1" colspan="1">AttributeUses</td><td rowspan="1" colspan="1"/></tr><tr><td rowspan="1" colspan="1">    required</td><td rowspan="1" colspan="1">Not in v1.0, mapping only</td></tr><tr><td rowspan="1" colspan="1">    default, fixed (value constraint)</td><td rowspan="1" colspan="1">Not in v1.0</td></tr><tr><td rowspan="1" colspan="1">Attribute Group Definitions</td><td rowspan="1" colspan="1">Not in v1.0, mapping only</td></tr><tr><td rowspan="1" colspan="1">Model Group Definitions</td><td rowspan="1" colspan="1">Not in v1.0, mapping only</td></tr><tr><td rowspan="1" colspan="1">Model Groups</td><td rowspan="1" colspan="1">Handled</td></tr><tr><td rowspan="1" colspan="1">Particles</td><td rowspan="1" colspan="1">Handled</td></tr><tr><td rowspan="1" colspan="1">Wildcards</td><td rowspan="1" colspan="1"/></tr><tr><td rowspan="1" colspan="1">    process contents strict, skip, lax</td><td rowspan="1" colspan="1">Ignored</td></tr><tr><td rowspan="1" colspan="1">    namespace wild cards.</td><td rowspan="1" colspan="1">Ignored</td></tr><tr><td rowspan="1" colspan="1">Identity-constraint Definitions</td><td rowspan="1" colspan="1">Ignored</td></tr><tr><td rowspan="1" colspan="1">Notation Declarations</td><td rowspan="1" colspan="1">Ignored</td></tr><tr><td rowspan="1" colspan="1">Annotations</td><td rowspan="1" colspan="1">Ignored</td></tr></tbody></table><p>Note that the schema import feature specified here assumes
        it is given a legal schema as input. As a result, it is not
        necessary to check for 'block' or 'abstract' attributes.</p></div3><div3 id="sec_import_organization"><head>Organization</head><p>The presentation of the schema mapping is done according to
      the following organization.</p><smschema><p>First each schema component is summarized using the same
    	notation used in the XML Representation Summary sections in
    	XML Schema. For instance, here is the XML Representation
    	Summary for complex types.</p><schemaRepresentationEg><schemaRepresentation><name>complexType</name><schemaAttribute role="ignored">
    	       abstract = boolean : false
    	    </schemaAttribute><schemaAttribute role="ignored">
    	       block = (#all | List of (extension | restriction))
    	    </schemaAttribute><schemaAttribute role="ignored">
    	       final = (#all | List of (extension | restriction))
    	    </schemaAttribute><schemaAttribute role="ignored">
    	       id = ID
    	    </schemaAttribute><schemaAttribute>
    	       mixed = boolean : false
    	    </schemaAttribute><schemaAttribute>
    	       name = NCName
    	    </schemaAttribute><schemaAttribute role="ignored">
    	       {any schemaAttributes with non-schema namespace ...}
    	    </schemaAttribute><content>
    	      Content: (annotation?, (simpleContent | complexContent |
    	      ((group | all | choice | sequence)?, ((schemaAttribute |
    	      schemaAttributeGroup)*, anySchemaAttribute?))))
    	    </content></schemaRepresentation></schemaRepresentationEg><p>Attributes indicated as <term>[ ignored ]</term> are not mapped
    	into the [XPath/XQuery] type system.</p><p>Attributes indicated as <term>[ not handled ]</term> are not
    	currently handled by the mapping.</p><p>Note that in order to simplify the mapping, it is assumed
    	that the default values for all attributes in the XML
    	Representation of Schema are filled in. For instance in the
    	above complex type, if the <code>mixed</code> attribute is not
    	present, it will be treated as being present and having the
    	value <code>"false"</code>.</p></smschema><smschemanorm><p>XML Schema import is specified by means of mapping
    	rules. All mapping rules have the structure below.</p><mapping><xquery><expression>
    	      <map><emph>SchemaComponent</emph></map><subscript>Subscript</subscript>
    	    </expression></xquery><core><expression>
    	      <emph>TypeComponent</emph>
    	    </expression></core></mapping><p>The <emph>SchemaComponent</emph> above the horizontal rule
    	denotes an XML Schema component before translation and the
    	<emph>TypeComponent</emph> beneath the horizontal rule denotes
    	an equivalent type component in the [XPath/XQuery] type system.</p></smschemanorm><smnotation><p>Whenever necessary for the mapping rules, specific grammar
    	productions which describe fragments of XML Schema may be
    	introduced. For instance, here are grammar productions used to
    	describes fragments of the XML Representation Summary for the
    	complexType Element Information Item.</p><scrap headstyle="show"><head>Complex type content</head><prodrecap ref="ComplexTypeContent" id="test-ComplexTypeContent" orig="formal" test="Example"/><prodrecap ref="AttributeContent" id="test-AttributeContent" orig="formal" test="Example"/><prodrecap ref="ChildrenContent" id="test-ChildrenContent" orig="formal" test="Example"/></scrap><p>As in the rest of this document, some mapping rules may use
    	fragments of the XML Representation corresponding to the
    	syntactic categories defined by those grammar productions. For
    	instance, the following complex type fragment uses the
    	syntactic categories: <a href="#doc-fs-TypeName"><emph>TypeName</emph></a>, <emph>ComplexTypeContent</emph>,
    	and <emph>AttributeContent</emph>, <emph>ChildrenContent</emph>, and
    	<emph>MixedAttribute</emph>.</p><schemaRepresentation><name>complexType</name><schemaAttribute>
    	     name = <a href="#doc-fs-TypeName"><emph>TypeName</emph></a>
    	  </schemaAttribute><schemaAttribute>
    	     <emph>MixedAttribute</emph>
    	  </schemaAttribute><content><emph>ChildrenContent</emph> <emph>AttributeContent</emph></content></schemaRepresentation></smnotation></div3><div3 id="sec_import_mapping"><head>Main mapping rules</head><smnotation><p id="jd_map_schema">The normalization rule</p><display>
  	  <mapping><xquery><expression>
  	         <map><emph>Schema</emph></map><a href="#jd_map_schema" class="judgment"><subscript>Schema</subscript></a>
              </expression></xquery><core><expression>
  	        <emph>Definitions</emph>
              </expression></core></mapping>
        </display><p>maps a complete schema into a set of <emph>Definitions</emph> in
        the [XPath/XQuery] type system.</p><p id="jd_map_definition">The normalization rule</p><display>
  	  <mapping><xquery><expression>
  	         <map><emph>SchemaComponent</emph></map><a href="#jd_map_definition" class="judgment"><subscript>definition(<emph>target</emph><emph>NCName</emph>)</subscript></a>
              </expression></xquery><core><expression>
  	        <a href="#sec_top_level_definitions"><emph>Definition</emph></a>
              </expression></core></mapping>
  	</display><p>maps a top level schema component into a <a href="#sec_top_level_definitions"><emph>Definition</emph></a> in
        the [XPath/XQuery] type system, given the target namespace
        <emph>target</emph><emph>AnyURI</emph>.</p><p id="jd_map_content">The normalization rule</p><display>
  	  <mapping><xquery><expression>
  	         <map><emph>SchemaComponent</emph></map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
              </expression></xquery><core><expression>
  	        <emph>TypeComponent</emph>
              </expression></core></mapping>
  	</display><p>maps a schema component not directly under the schema
        element, into a <emph>TypeComponent</emph> in the [XPath/XQuery]
        type system, given the target namespace <emph>target</emph><emph>AnyURI</emph>.</p></smnotation></div3><div3 id="sec_use"><head>Special attributes</head><p>The XML Schema attributes: use, default, fixed, minOccurs,
      maxOccurs, mixed, nillable, and substitutionGroup, require
      specific mapping rules.</p><div4 id="sec_import_attributes"><head>use, default, and fixed</head><p>The <quote>use</quote>, <quote>default</quote>, and
        <quote>fixed</quote> attributes are used to describe the
        occurrence and default behavior of a given attribute.</p><smnotation><p>The following auxiliary grammar productions are used to
  	  describe the <quote>use</quote>, <quote>default</quote>, and
  	  <quote>fixed</quote> attributes.</p><scrap headstyle="show"><head>Use, default, and fixed attributes</head><prodrecap ref="UseAttribute" id="UseAttribute" orig="formal"/><prodrecap ref="DefaultAttribute" id="DefaultAttribute" orig="formal"/><prodrecap ref="FixedAttribute" id="FixedAttribute" orig="formal"/></scrap><p id="jd_map_use">The normalization rule</p><display>
  	    <mapping><xquery><expression>
  		  <map><emph>UseAttribute</emph> <emph>DefaultAttribute</emph>? <emph>FixedAttribute</emph>? </map><a href="#jd_map_use" class="judgment"><subscript>use</subscript></a>
  		</expression></xquery><core><expression>
  		  <emph>OccurrenceIndicator</emph>
  		</expression></core></mapping>
  	  </display><p>maps a combination of a use attribute <emph>UseAttribute</emph>,
  	  along with an optional default or fixed attribute in Schema
  	  into the occurrence indicator <emph>OccurrenceIndicator</emph> in the
  	  [XPath/XQuery] type system.</p></smnotation><smschemanorm><p>Use attributes are mapped to the type system in the
  	  following way. In case there is a default or fixed
  	  attribute, the attribute is always present in the PSVI and
  	  the use attribute is ignored.</p><mapping><xquery><expression><emph>UseAttribute</emph> <emph>DefaultAttribute</emph><a href="#jd_map_use" class="judgment"><subscript>use</subscript></a></expression></xquery><core><expression>1</expression></core></mapping><mapping><xquery><expression><emph>UseAttribute</emph> <emph>FixedAttribute</emph><a href="#jd_map_use" class="judgment"><subscript>use</subscript></a></expression></xquery><core><expression>1</expression></core></mapping><mapping><xquery><expression>use = <quote>optional</quote><a href="#jd_map_use" class="judgment"><subscript>use</subscript></a></expression></xquery><core><expression>?</expression></core></mapping><mapping><xquery><expression>use = <quote>required</quote><a href="#jd_map_use" class="judgment"><subscript>use</subscript></a></expression></xquery><core><expression>1</expression></core></mapping><ednote><edtext>Issue: how derivation of attribute declaration and
  	    the <quote>prohibited</quote> use attributes are mapped in
  	    the [XPath/XQuery] type system is still an open
  	    issue.</edtext></ednote></smschemanorm></div4><div4 id="prod-formal-OccursAttributes"><head>minOccurs, maxOccurs, minLength, maxLength, and length</head><smnotation><p>The following auxiliary grammar productions are used to
  	  describe occurrence attributes and the length facets.</p><scrap headstyle="show"><head>Occurrence attributes</head><prodrecap ref="OccursAttributes" id="OccursAttributes" orig="formal"/><prodrecap ref="maxOccurs" id="maxOccurs" orig="formal"/><prodrecap ref="minOccurs" id="minOccurs" orig="formal"/><prodrecap ref="maxLength" id="maxLength" orig="formal"/><prodrecap ref="minLength" id="minLength" orig="formal"/><prodrecap ref="length" id="length" orig="formal"/></scrap><p id="jd_map_occurs">The normalization rule</p><display>
  	    <mapping><xquery><expression>
  		  <map><a href="#prod-formal-OccursAttributes"><emph>OccursAttributes</emph></a></map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a>
  		</expression></xquery><core><expression>
  		  <emph>OccurrenceIndicator</emph>
  		</expression></core></mapping>
  	  </display><p>maps the occurrence attributes and facets <a href="#prod-formal-OccursAttributes"><emph>OccursAttributes</emph></a> in
  	  Schema into the occurrence indicator <emph>OccurrenceIndicator</emph> in the
  	  [XPath/XQuery] type system.</p></smnotation><smschemanorm><p>Occurrence attributes are mapped to the type system in
  	  the following way.</p><mapping><xquery><expression><map>minOccurs="0" maxOccurs="1"</map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a></expression></xquery><core><expression>?</expression></core></mapping><mapping><xquery><expression><map>minOccurs="1" maxOccurs="1"</map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a></expression></xquery><core><expression/></core></mapping><mapping><xquery><expression><map>minOccurs="0" maxOccurs="n"</map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a></expression></xquery><core><expression>*</expression></core></mapping><mapping><xquery><expression><map>minOccurs="1" maxOccurs="n"</map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a></expression></xquery><core><expression>+</expression></core></mapping><p>where <expression>n &gt; 1</expression>.</p><mapping><xquery><expression><map>minOccurs="n" maxOccurs="m"</map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a></expression></xquery><core><expression>+</expression></core></mapping><p>where <expression>m &gt;= n &gt; 1</expression></p><mapping><xquery><expression><map>minLength="0" maxLength="1"</map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a></expression></xquery><core><expression>?</expression></core></mapping><mapping><xquery><expression><map>minLength="1" maxLength="1"</map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a></expression></xquery><core><expression/></core></mapping><mapping><xquery><expression><map>minLength="0" maxLength="n"</map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a></expression></xquery><core><expression>*</expression></core></mapping><mapping><xquery><expression><map>minLength="1" maxLength="n"</map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a></expression></xquery><core><expression>+</expression></core></mapping><p>where <expression>n &gt; 1</expression>.</p><mapping><xquery><expression><map>minLength="n" maxLength="m"</map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a></expression></xquery><core><expression>+</expression></core></mapping><p>where <expression>m &gt;= n &gt; 1</expression></p><mapping><xquery><expression><map>length="1"</map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a></expression></xquery><core><expression/></core></mapping><mapping><xquery><expression><map>length="n"</map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a></expression></xquery><core><expression>+</expression></core></mapping><p>where <expression>n &gt; 1</expression></p></smschemanorm></div4><div4 id="sec_import_mixed"><head>mixed</head><smnotation><p>The following auxiliary grammar productions are used to
  	  describe the <quote>mixed</quote> attribute.</p><scrap headstyle="show"><head>Mixed attribute</head><prodrecap ref="MixedAttribute" id="MixedAttribute" orig="formal"/></scrap><p id="jd_map_mixed">The normalization rule</p><display>
  	    <mapping><xquery><expression>
  		  <map><emph>MixedAttribute</emph></map><a href="#jd_map_mixed" class="judgment"><subscript>mixed</subscript></a>
  		</expression></xquery><core><expression>
  		  <a href="#doc-fs-Mixed"><emph>Mixed</emph></a>
  		</expression></core></mapping>
  	  </display><p>maps the mixed attribute <emph>MixedAttribute</emph> in Schema into
  	  a <a href="#doc-fs-Mixed"><emph>Mixed</emph></a> notation in the [XPath/XQuery] type system.</p></smnotation><smschemanorm><p>If the mixed attribute is true it is mapped to a mixed
  	  notation in the [XPath/XQuery] type system.</p><mapping><xquery><expression>
  		<map>
  		  mixed = <quote>true</quote>
  	      </map><a href="#jd_map_mixed" class="judgment"><subscript>mixed</subscript></a>
  	    </expression></xquery><core><expression>mixed</expression></core></mapping><p>If the mixed attribute is false it is mapped to empty in
  	  the [XPath/XQuery] type system.</p><mapping><xquery><expression>
  		<map>
  		  mixed = <quote>false</quote>
  		</map><a href="#jd_map_mixed" class="judgment"><subscript>mixed</subscript></a>
  	    </expression></xquery><core><expression/></core></mapping></smschemanorm></div4><div4 id="sec_import_nillable"><head>nillable</head><smnotation><p>The following auxiliary grammar productions are used to
  	  describe the <quote>nillable</quote> attribute.</p><scrap headstyle="show"><head>Nillable attribute</head><prodrecap ref="NillableAttribute" id="NillableAttribute" orig="formal"/></scrap><p id="jd_map_nillable">The normalization rule</p><display>
  	    <mapping><xquery><expression>
  		  <map><emph>NillableAttribute</emph></map><a href="#jd_map_nillable" class="judgment"><subscript>nillable</subscript></a>
  		</expression></xquery><core><expression>
  		  <a href="#doc-fs-Nillable"><emph>Nillable</emph></a>
  		</expression></core></mapping>
  	  </display><p>maps the nillable attribute <emph>NillableAttribute</emph> in
  	  Schema into a <a href="#doc-fs-Nillable"><emph>Nillable</emph></a> notation in the [XPath/XQuery] type
  	  system.</p></smnotation><smschemanorm><p>If the nillable attribute is true it is mapped to a
  	  nillable notation in the [XPath/XQuery] type system.</p><mapping><xquery><expression>
  		<map>
  		  nillable = <quote>true</quote>
  	      </map><a href="#jd_map_nillable" class="judgment"><subscript>nillable</subscript></a>
  	    </expression></xquery><core><expression>nillable</expression></core></mapping><p>If the nillable attribute is false it is mapped to empty
  	  in the [XPath/XQuery] type system.</p><mapping><xquery><expression>
  		<map>
  		  nillable = <quote>false</quote>
  		</map><a href="#jd_map_nillable" class="judgment"><subscript>nillable</subscript></a>
  	    </expression></xquery><core><expression/></core></mapping></smschemanorm></div4><div4 id="sec_import_substitution"><head>substitutionGroup</head><smnotation><p>The substitution group declaration indicates the element
  	  that a given element can be substituted for. The following
  	  auxiliary grammar productions are used to describe the
  	  <quote>substitutionGroup</quote> attribute.</p><scrap headstyle="show"><head>substitutionGroup attribute</head><prodrecap ref="substitutionGroupAttribute" id="substitutionGroupAttribute" orig="formal"/></scrap><p id="jd_map_substitution">The normalization rule</p><display>
  	    <mapping><xquery><expression>
  		  <map><emph>substitutionGroupAttribute</emph></map><a href="#jd_map_substitution" class="judgment"><subscript>substitution</subscript></a>
  		</expression></xquery><core><expression>
  		  <emph>Substitution</emph>
  		</expression></core></mapping>
  	  </display><p>maps the substitutionGroup attribute
  	  <emph>substitutionGroupAttribute</emph> in Schema into a
  	  <emph>Substitution</emph> notation in the [XPath/XQuery] type
  	  system.</p></smnotation><smschemanorm><p>If the substitutionGroup attribute is present, it is
  	  mapped to a substitutionGroup notation in the [XPath/XQuery]
  	  type system.</p><mapping><xquery><expression>
  		<map>
  		  substitutionGroup = <emph>QName</emph>
  	      </map><a href="#jd_map_substitution" class="judgment"><subscript>substitution</subscript></a>
  	    </expression></xquery><core><expression>substitutes for <emph>QName</emph></expression></core></mapping><p>Otherwise, it is mapped to empty.</p></smschemanorm></div4></div3><div3 id="sec_import_anonymous"><head>Anonymous type names</head><smnotation><p>As explained in <specref ref="sec_types"/>, the [XPath/XQuery]
        type uses system-generated type names for anonymous types. For
        the purpose of this document those type names are generated at
        XML Schema import time.</p></smnotation></div3></div2><div2 id="sec_schema_as_a_whole"><head>Schemas as a whole</head><div3 id="sec_import_whole"><head>Schema</head><smschema><p>A schema is represented in XML by the following
        structure.</p><schemaRepresentationEg><schemaRepresentation><name>schema</name><schemaAttribute role="nothandled">
             attributeFormDefault = (qualified | unqualified) : unqualified
          </schemaAttribute><schemaAttribute role="ignored">
             blockDefault = (#all | List of (extension | restriction | substitution))  : ' '
          </schemaAttribute><schemaAttribute role="nothandled">
             elementFormDefault = (qualified | unqualified) : unqualified
          </schemaAttribute><schemaAttribute role="ignored">
             finalDefault = (#all | List of (extension | restriction)) :  ' '
          </schemaAttribute><schemaAttribute role="ignored">
             id = ID
          </schemaAttribute><schemaAttribute>
             targetNamespace = anyURI
          </schemaAttribute><schemaAttribute role="ignored">
             version = token
          </schemaAttribute><schemaAttribute role="ignored">
             xml:lang = language
          </schemaAttribute><schemaAttribute role="ignored">
             {any attributes with non-schema namespace ...}
          </schemaAttribute><content>
            Content: ((include | import | redefine | annotation)*,
            (((simpleType | complexType | group | attributeGroup) |
            element | attribute | notation), annotation*)*)
          </content></schemaRepresentation></schemaRepresentationEg></smschema><smnotation><p>The following auxiliary grammar productions are used.</p><scrap headstyle="show"><head>XML Schema Pragma and Content</head><prodrecap ref="SPragma" id="SPragma" orig="formal"/><prodrecap ref="Content" id="Content" orig="formal"/></scrap><p id="jd_map_pragma">The auxiliary normalization rule</p><display>
          <mapping><xquery><expression>
                <map><emph>Pragma</emph></map><a href="#jd_map_pragma" class="judgment"><subscript>pragma(<emph>target</emph><emph>AnyURI</emph>)</subscript></a>
              </expression></xquery><core><expression>
                <emph>Definitions</emph>
              </expression></core></mapping>
        </display><p>maps the a schema pragma into a set of definitions in the
        [XPath/XQuery] type system.</p></smnotation><smschemanorm><p>Schemas are imported by the <quote>schema</quote>
        declaration in the preamble of a query. To import a schema,
        the document referred to by the given URI is opened and the
        schema declarations contained in the document are translated
        into the corresponding in-line type definitions.  The
        mechanism for finding a schema document, possibly using the
        optional schema location hint, is not specified formally. </p><mapping><xquery><expression>
              <map>schema <emph>StringLiteral</emph> (at <emph>StringLiteral</emph>)?</map><a href="#jd_map_schema" class="judgment"><subscript>Schema</subscript></a>
            </expression></xquery><core><expression>
              <map>open-schema-document(<emph>StringLiteral</emph> (at <emph>StringLiteral</emph>)?)</map><a href="#jd_map_schema" class="judgment"><subscript>Schema</subscript></a>
            </expression></core></mapping><mapping><xquery><expression>
             <map>
                 <schemaRepresentation><name>schema</name><schemaAttribute>
                      targetNamespace = <emph>target</emph><emph>AnyURI</emph>
                   </schemaAttribute><content>
                     <emph>Pragma</emph> <emph>Content</emph>
                   </content></schemaRepresentation>
             </map><a href="#jd_map_schema" class="judgment"><subscript>Schema</subscript></a>
           </expression></xquery><core><expression>
                <map><emph>Pragma</emph></map><a href="#jd_map_pragma" class="judgment"><subscript>pragma(<emph>target</emph><emph>AnyURI</emph>)</subscript></a>
                <map><emph>Content</emph></map><a href="#jd_map_definition" class="judgment"><subscript>definition(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            </expression></core></mapping></smschemanorm></div3><div3 id="sec_import_include"><head>Include</head><smschema><p>A schema include is represented in XML by the following
          structure.</p><schemaRepresentationEg><schemaRepresentation><name>include</name><schemaAttribute role="ignored">
                 id = ID
              </schemaAttribute><schemaAttribute>
                 schemaLocation = anyURI
              </schemaAttribute><schemaAttribute role="ignored">
                 {any attributes with non-schema namespace ...}
              </schemaAttribute><content>
                Content: (annotation?)
              </content></schemaRepresentation></schemaRepresentationEg></smschema><smschemanorm><p>A schema include is not specified here, and is assumed
          to be handled by the XML Schema processor.</p></smschemanorm></div3><div3 id="sec_import_redefine"><head>Redefine</head><smschema><p>A schema redefinition is represented in XML by the
          following structure.</p><schemaRepresentationEg><schemaRepresentation><name>redefine</name><schemaAttribute role="ignored">
                 id = ID
              </schemaAttribute><schemaAttribute>
                 schemaLocation = anyURI
              </schemaAttribute><schemaAttribute role="ignored">
                 {any attributes with non-schema namespace ...}
              </schemaAttribute><content>
                Content: (annotation | (simpleType | complexType | group | attributeGroup))*
              </content></schemaRepresentation></schemaRepresentationEg></smschema><smschemanorm><p>A schema redefine is not specified here, and is assumed
          to be handled by the XML Schema processor.</p></smschemanorm></div3><div3 id="sec_import_import"><head>Import</head><smschema><p>A schema import is represented in XML by the following
          structure.</p><schemaRepresentationEg><schemaRepresentation><name>import</name><schemaAttribute role="ignored">
                 id = ID
              </schemaAttribute><schemaAttribute>
                 namespace = anyURI
              </schemaAttribute><schemaAttribute>
                 schemaLocation = anyURI
              </schemaAttribute><schemaAttribute role="ignored">
                 {any attributes with non-schema namespace ...}
              </schemaAttribute><content>
                Content: (annotation?)
              </content></schemaRepresentation></schemaRepresentationEg></smschema><smschemanorm><p>A schema import is not specified here, and is assumed to
          be handled by the XML Schema processor.</p></smschemanorm></div3></div2><div2 id="sec_import_attribute_decl"><head>Attribute Declarations</head><smschema><p>The following structure describes attribute declarations in
      XML Schema.</p><schemaRepresentationEg><schemaRepresentation><name>attribute</name><schemaAttribute role="nothandled">
    	       default = string
    	    </schemaAttribute><schemaAttribute role="nothandled">
    	       fixed = string
    	    </schemaAttribute><schemaAttribute role="nothandled">
    	       form = (qualified | unqualified)
    	    </schemaAttribute><schemaAttribute role="ignored">
    	       id = ID
    	    </schemaAttribute><schemaAttribute>
    	       name = NCName
    	    </schemaAttribute><schemaAttribute>
    	       ref = QName
    	    </schemaAttribute><schemaAttribute>
    	       type = QName
    	    </schemaAttribute><schemaAttribute>
    	       use = (optional | prohibited | required) : optional
    	    </schemaAttribute><schemaAttribute role="ignored">
    	       {any attributes with non-schema namespace ...}
    	    </schemaAttribute><content>
    	      Content: (annotation?, (simpleType?))
    	    </content></schemaRepresentation></schemaRepresentationEg></smschema><div3 id="sec_import_global_attributes"><head>Global attributes declarations</head><p>Schema import distinguishes between global attribute
      declarations and local attribute declarations.</p><smschemanorm><p>Global attribute declarations are mapped like local
        attribute declarations, but are prefixed by a
        <quote>define</quote> keyword in the [XPath/XQuery] type
        system.</p><mapping><xquery><expression><map><emph>AttributeDecl</emph></map><a href="#jd_map_definition" class="judgment"><subscript>definition(<emph>target</emph><emph>NCName</emph>)</subscript></a></expression></xquery><core><expression>define <map><emph>AttributeDecl</emph></map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a></expression></core></mapping></smschemanorm></div3><div3 id="sec_import_local_attributes"><head>Local attribute declarations</head><smschemanorm><p>Local attributes whose type is given by a reference to a
        global type name are mapped in the type system as
        follows.</p><mapping><xquery><expression>
              <map>
    	  	  <schemaRepresentationNoContent><name>attribute</name><schemaAttribute>
    	  	       name = <emph>NCName</emph>
    	  	    </schemaAttribute><schemaAttribute>
    	  	       type = <emph>QName</emph>
    	  	    </schemaAttribute><schemaAttribute>
    	  	       <emph>UseAttribute</emph>
    	  	    </schemaAttribute></schemaRepresentationNoContent>
              </map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            </expression></xquery><core><expression>( attribute <emph>target</emph><emph>NCName</emph>:<emph>NCName</emph> {
            of type <emph>QName</emph> }
            )<map><emph>UseAttribute</emph></map><a href="#jd_map_use" class="judgment"><subscript>use</subscript></a></expression></core></mapping><p>References to a global attribute are mapped in the type
        system as follows.</p><mapping><xquery><expression>
              <map>
    	  	  <schemaRepresentationNoContent><name>attribute</name><schemaAttribute>
    	  	       ref = <emph>QName</emph>
    	  	    </schemaAttribute><schemaAttribute>
    	  	       <emph>UseAttribute</emph>
    	  	    </schemaAttribute></schemaRepresentationNoContent>
              </map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            </expression></xquery><core><expression>( attribute <emph>QName</emph>
            )<map><emph>UseAttribute</emph></map><a href="#jd_map_use" class="judgment"><subscript>use</subscript></a></expression></core></mapping><p>A local attribute with a local content is mapped to the
        [XPath/XQuery] type system as follows. Let <emph>fs:</emph>anon<subscript>k</subscript> be a newly
        generated anonymous name.</p><mapping><xquery><expression>
              <map>
    	  	  <schemaRepresentation><name>attribute</name><schemaAttribute>
    	  	       name = <emph>NCName</emph>
    	  	    </schemaAttribute><schemaAttribute>
    	  	       <emph>UseAttribute</emph>
    	  	    </schemaAttribute><content>
    	    	      <emph>simpleType</emph>
    	    	    </content></schemaRepresentation>
              </map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            </expression></xquery><core><expression>
            <table summary=""><tbody><tr><td rowspan="1" colspan="1"><expression>( attribute <emph>target</emph><emph>NCName</emph>:<emph>NCName</emph> of
            type <emph>fs:</emph>anon<subscript>k</subscript>
            )<map><emph>UseAttribute</emph></map><a href="#jd_map_use" class="judgment"><subscript>use</subscript></a></expression></td></tr><tr><td rowspan="1" colspan="1">  with</td></tr><tr><td rowspan="1" colspan="1"><expression>define type <emph>fs:</emph>anon<subscript>k</subscript> of type
            xs:anySimpleType {
            <map><emph>simpleType</emph></map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a> }</expression></td></tr></tbody></table>
            </expression></core></mapping></smschemanorm></div3></div2><div2 id="sec_import_element"><head>Element Declarations</head><smschema><p>The following structure describes attribute declarations in
      XML Schema.</p><schemaRepresentationEg><schemaRepresentation><name>element</name><schemaAttribute role="ignored">
            abstract = boolean : false
          </schemaAttribute><schemaAttribute role="ignored">
    	    block = (#all | List of (extension | restriction))
    	  </schemaAttribute><schemaAttribute role="nothandled">
            default = string
          </schemaAttribute><schemaAttribute role="ignored">
    	    final = (#all | List of (extension | restriction))
    	  </schemaAttribute><schemaAttribute role="nothandled">
            fixed = string
          </schemaAttribute><schemaAttribute role="nothandled">
            form = (qualified | unqualified)
          </schemaAttribute><schemaAttribute role="ignored">
            id = ID
          </schemaAttribute><schemaAttribute>
    	    maxOccurs = (nonNegativeInteger | unbounded)  : 1
    	  </schemaAttribute><schemaAttribute>
    	    minOccurs = nonNegativeInteger : 1
    	  </schemaAttribute><schemaAttribute>
            name = NCName
          </schemaAttribute><schemaAttribute>
            nillable = boolean : false
          </schemaAttribute><schemaAttribute>
            ref = QName
          </schemaAttribute><schemaAttribute>
            substitutionGroup = QName
          </schemaAttribute><schemaAttribute>
             type = QName
          </schemaAttribute><schemaAttribute role="ignored">
             {any attributes with non-schema namespace ...}
          </schemaAttribute><content>
            Content: (annotation?, ((simpleType | complexType)?, (unique | key | keyref)*))
          </content></schemaRepresentation></schemaRepresentationEg></smschema><div3 id="sec_import_global_element"><head>Global element declarations</head><p>Schema import distinguishes between global element
      declarations and local element declarations.</p><smschemanorm><p>Global element declarations are mapped like local element
        declarations, but are prefixed by a <quote>define</quote>
        keyword in the [XPath/XQuery] type system.</p><mapping><xquery><expression>
              <map>
        	<schemaRepresentationNoContent><name>element</name><schemaAttribute>
        	    name = <emph>NCName</emph>
        	  </schemaAttribute><schemaAttribute>
        	    <emph>NillableAttribute</emph>
        	  </schemaAttribute><schemaAttribute>
        	    <emph>substitutionGroupAttribute</emph>
        	  </schemaAttribute><schemaAttribute>
        	    type = <emph>QName</emph>
        	  </schemaAttribute></schemaRepresentationNoContent>
              </map><a href="#jd_map_definition" class="judgment"><subscript>definition(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            </expression></xquery><core><expression>define element <emph>target</emph><emph>NCName</emph>:<emph>NCName</emph>
            <map><emph>substitutionGroupAttribute</emph></map><a href="#jd_map_substitution" class="judgment"><subscript>substitution</subscript></a>
            <map><emph>NillableAttribute</emph></map><a href="#jd_map_nillable" class="judgment"><subscript>nillable</subscript></a> of type
            <emph>QName</emph></expression></core></mapping><mapping><xquery><expression>
              <map>
        	<schemaRepresentation><name>element</name><schemaAttribute>
        	    name = <emph>NCName</emph>
        	  </schemaAttribute><schemaAttribute>
        	    <emph>NillableAttribute</emph>
        	  </schemaAttribute><schemaAttribute>
        	    <emph>substitutionGroupAttribute</emph>
        	  </schemaAttribute><content>
        	    <a href="#doc-fs-ElementModel"><emph>ElementModel</emph></a>
        	  </content></schemaRepresentation>
              </map><a href="#jd_map_definition" class="judgment"><subscript>definition(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            </expression></xquery><core><expression>define element <emph>target</emph><emph>NCName</emph>:<emph>NCName</emph>
            <map><emph>substitutionGroupAttribute</emph></map><a href="#jd_map_substitution" class="judgment"><subscript>substitution</subscript></a>
            <map><emph>NillableAttribute</emph></map><a href="#jd_map_nillable" class="judgment"><subscript>nillable</subscript></a>
            <map><a href="#doc-fs-ElementModel"><emph>ElementModel</emph></a></map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a></expression></core></mapping></smschemanorm></div3><div3 id="sec_import_local_element"><head>Local element declarations</head><smschemanorm><p>Local element declarations, but mapped into corresponding
        notations in the [XPath/XQuery] type system. Note that
        substitution group cannot be declared on local elements.</p><mapping><xquery><expression>
              <map>
        	<schemaRepresentationNoContent><name>element</name><schemaAttribute>
          	    <a href="#prod-formal-OccursAttributes"><emph>OccursAttributes</emph></a>
    	    	  </schemaAttribute><schemaAttribute>
        	    name = <emph>NCName</emph>
        	  </schemaAttribute><schemaAttribute>
        	    <emph>NillableAttribute</emph>
        	  </schemaAttribute><schemaAttribute>
        	    type = <emph>QName</emph>
        	  </schemaAttribute></schemaRepresentationNoContent>
              </map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            </expression></xquery><core><expression>( element <emph>target</emph><emph>NCName</emph>:<emph>NCName</emph>
            <map><emph>NillableAttribute</emph></map><a href="#jd_map_nillable" class="judgment"><subscript>nillable</subscript></a> of type
            <emph>QName</emph> )
            <map><a href="#prod-formal-OccursAttributes"><emph>OccursAttributes</emph></a></map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a></expression></core></mapping><mapping><xquery><expression>
              <map>
        	<schemaRepresentationNoContent><name>element</name><schemaAttribute>
          	    <a href="#prod-formal-OccursAttributes"><emph>OccursAttributes</emph></a>
    	    	  </schemaAttribute><schemaAttribute>
        	    ref = <emph>QName</emph>
        	  </schemaAttribute></schemaRepresentationNoContent>
              </map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            </expression></xquery><core><expression>( element <emph>QName</emph> )
            <map><a href="#prod-formal-OccursAttributes"><emph>OccursAttributes</emph></a></map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a></expression></core></mapping><p>Let <emph>fs:</emph>anon<subscript>k</subscript> be a newly generated anonymous name.</p><mapping><xquery><expression>
              <map>
        	<schemaRepresentation><name>element</name><schemaAttribute>
          	    <a href="#prod-formal-OccursAttributes"><emph>OccursAttributes</emph></a>
    	    	  </schemaAttribute><schemaAttribute>
        	    name = <emph>NCName</emph>
        	  </schemaAttribute><schemaAttribute>
        	    <emph>NillableAttribute</emph>
        	  </schemaAttribute><content>
        	    <a href="#doc-fs-ElementModel"><emph>ElementModel</emph></a>
        	  </content></schemaRepresentation>
              </map><a href="#jd_map_definition" class="judgment"><subscript>definition(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            </expression></xquery><core><expression>
            <table summary=""><tbody><tr><td rowspan="1" colspan="1"><expression>( element
            <emph>target</emph><emph>NCName</emph>:<emph>NCName</emph>
            <map><emph>NillableAttribute</emph></map><a href="#jd_map_nillable" class="judgment"><subscript>nillable</subscript></a> of type
            <emph>fs:</emph>anon<subscript>k</subscript> )
            <map><a href="#prod-formal-OccursAttributes"><emph>OccursAttributes</emph></a></map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a></expression></td></tr><tr><td rowspan="1" colspan="1">  with</td></tr><tr><td rowspan="1" colspan="1"><expression>define type <emph>fs:</emph>anon<subscript>k</subscript>
            <map><a href="#doc-fs-ElementModel"><emph>ElementModel</emph></a></map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            }</expression></td></tr></tbody></table>
            </expression></core></mapping></smschemanorm></div3></div2><div2 id="sec_complex_type"><head>Complex Type Definitions</head><smschema><p>A complex type definition is represented in XML by the
      following structure.</p><schemaRepresentationEg><schemaRepresentation><name>complexType</name><schemaAttribute role="ignored">
    	       abstract = boolean : false
    	    </schemaAttribute><schemaAttribute role="ignored">
    	       block = (#all | List of (extension | restriction))
    	    </schemaAttribute><schemaAttribute role="ignored">
    	       final = (#all | List of (extension | restriction))
    	    </schemaAttribute><schemaAttribute role="ignored">
    	       id = ID
    	    </schemaAttribute><schemaAttribute>
    	       mixed = boolean : false
    	    </schemaAttribute><schemaAttribute>
    	       name = NCName
    	    </schemaAttribute><schemaAttribute role="ignored">
    	       {any attributes with non-schema namespace ...}
    	    </schemaAttribute><content>
    	      Content: (annotation?, (simpleContent | complexContent |
    	      ((group | all | choice | sequence)?, ((attribute |
    	      attributeGroup)*, anyAttribute?))))
    	    </content></schemaRepresentation></schemaRepresentationEg></smschema><smnotation><p>The following auxiliary grammar productions are used to
      describe the content of a complex type definition.</p><scrap headstyle="show"><head>Complex type content</head><prodrecap ref="ComplexTypeContent" id="ComplexTypeContent" orig="formal"/><prodrecap ref="AttributeContent" id="AttributeContent" orig="formal"/><prodrecap ref="ChildrenContent" id="ChildrenContent" orig="formal"/></scrap></smnotation><div3 id="sec_import_global_complex_type"><head>Global complex type</head><p>Schema import distinguishes between global complex types
      (which are mapped to sort declarations) and local complex types
      (which are mapped to type definitions).</p><smschemanorm><p>In the case of global complex types, the mapping rule which
        applies is denoted by <map/><a href="#jd_map_definition" class="judgment"><subscript>definition(<emph>target</emph><emph>NCName</emph>)</subscript></a>.</p><mapping><xquery><expression>
              <map>
    	  	  <schemaRepresentation><name>complexType</name><schemaAttribute>
    	  	       <emph>MixedAttribute</emph>
    	  	    </schemaAttribute><schemaAttribute>
    	  	       name = <emph>NCName</emph>
    	  	    </schemaAttribute><content>
    	  	       <emph>ComplexTypeContent</emph>
    	  	    </content></schemaRepresentation>
            </map><a href="#jd_map_definition" class="judgment"><subscript>definition(<emph>target</emph><emph>NCName</emph>)</subscript></a>
          </expression></xquery><core><expression>define type <emph>target</emph><emph>NCName</emph>:<emph>NCName</emph>
            <map><emph>MixedAttribute</emph>
            <emph>ComplexTypeContent</emph></map><a href="#jd_map_mixed_content" class="judgment"><subscript>mixed_content(<emph>target</emph><emph>NCName</emph>)</subscript></a></expression></core></mapping><p>Note that the <code>mixed</code> is passed along in the
        normalization rules, in order to map it later on to the
        appropriate indication in the [XPath/XQuery] type system.</p></smschemanorm></div3><div3 id="sec_import_local_complex_type"><head>Local complex type</head><smschemanorm><p>In the case of a local complex types, there must not be a
        name attribute and the mapping rule which applies is denoted
        by <map/><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>.</p><mapping><xquery><expression>
              <map>
    	  	  <schemaRepresentation><name>complexType</name><schemaAttribute>
    	  	       <emph>MixedAttribute</emph>
    	  	    </schemaAttribute><content>
    	  	       <emph>ComplexTypeContent</emph>
    	  	    </content></schemaRepresentation>
            </map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
          </expression></xquery><core><expression><map><emph>MixedAttribute</emph>
            <emph>ComplexTypeContent</emph></map><a href="#jd_map_mixed_content" class="judgment"><subscript>mixed_content(<emph>target</emph><emph>NCName</emph>)</subscript></a></expression></core></mapping><p>Note that the <code>mixed</code> is passed along in the
        normalization rules, in order to map it later on to the
        appropriate indication in the [XPath/XQuery] type system.</p></smschemanorm></div3><div3 id="sec_import_ct_simple"><head>Complex type with simple content</head><smschema><p>A complex type can be of simple content. A simple content
    	  is represented in XML by the following structure.</p><schemaRepresentationEg><schemaRepresentation><name>simpleContent</name><schemaAttribute role="ignored">
    		 id = ID
    	      </schemaAttribute><schemaAttribute role="ignored">
    		 {any attributes with non-schema namespace ...}
    	      </schemaAttribute><content>
    		Content: (annotation?, (restriction | extension))
    	      </content></schemaRepresentation></schemaRepresentationEg><p>Derivation by restriction inside a simple content is
        represented in XML by the following structure.</p><schemaRepresentationEg><schemaRepresentation><name>restriction</name><schemaAttribute>
    		 base = QName
    	      </schemaAttribute><schemaAttribute role="ignored">
    		 id = ID
    	      </schemaAttribute><schemaAttribute role="ignored">
    		 {any attributes with non-schema namespace ...}
    	      </schemaAttribute><content>
    		Content: (annotation?, (simpleType?, (minExclusive |
    		minInclusive | maxExclusive | maxInclusive |
    		totalDigits | fractionDigits | length | minLength |
    		maxLength | enumeration | whiteSpace | pattern)*)?,
    		((attribute | attributeGroup)*, anyAttribute?))
    	      </content></schemaRepresentation></schemaRepresentationEg><p>Derivation by extension inside a simple content is
        represented in XML by the following structure.</p><schemaRepresentationEg><schemaRepresentation><name>extension</name><schemaAttribute>
    		 <term>base</term> = QName
    	      </schemaAttribute><schemaAttribute role="ignored">
    		 id = ID
    	      </schemaAttribute><schemaAttribute role="ignored">
    		 {any attributes with non-schema namespace ...}
    	      </schemaAttribute><content>
              Content: (annotation?, ((attribute | attributeGroup)*,
              anyAttribute?))
    	      </content></schemaRepresentation></schemaRepresentationEg></smschema><smnotation><p id="jd_map_mixed_content">The normalization rule</p><display>
          <mapping><xquery><expression>
                <map><emph>MixedAttribute</emph> <emph>ComplexTypeContent</emph></map><a href="#jd_map_mixed_content" class="judgment"><subscript>mixed_content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
              </expression></xquery><core><expression>
                <a href="#doc-fs-TypeDerivation"><emph>TypeDerivation</emph></a>
              </expression></core></mapping>
        </display><p>maps a pair of mixed attribute and complex type content to
        a type derivation.</p></smnotation><smschemanorm><p>A complex types with simple content must not have a
        <code>mixed</code> attribute set to <quote>true</quote>.</p><p>If the simple content is derived by restriction, it is
        mapped into a simple type restriction in the [XPath/XQuery] type
        system. Only the name of the base atomic type and attributes
        are mapped, while the actual simple type restriction is
        ignored. (Remember that facets are not captured in the
        [XPath/XQuery] type system.)</p><mapping><xquery><expression>
              <map>
                <table summary=""><tbody><tr><td rowspan="1" colspan="1">mixed = <quote>false</quote></td><td rowspan="1" colspan="1">
   	  	  <schemaRepresentationNoAttribute><name>simpleContent</name><content>
    	    	      <schemaRepresentation><name>restriction</name><schemaAttribute>
    	 		   base = <emph>QName</emph>
    	    		</schemaAttribute><content>
    	 		  <emph>simpleContentRestriction</emph> <emph>AttributeContent</emph>
    	    		</content></schemaRepresentation>
    	  	    </content></schemaRepresentationNoAttribute>
               </td></tr></tbody></table>
            </map><a href="#jd_map_mixed_content" class="judgment"><subscript>mixed_content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
          </expression></xquery><core><expression>restricts <emph>QName</emph> {
            <map><emph>AttributeContent</emph></map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            <emph>QName</emph> }</expression></core></mapping><p>If the simple type is derived by extension, it is mapped
        into an extended type specifier into the [XPath/XQuery] type
        system.</p><mapping><xquery><expression>
              <map>
                <table summary=""><tbody><tr><td rowspan="1" colspan="1">mixed = <quote>false</quote></td><td rowspan="1" colspan="1">
   	  	  <schemaRepresentationNoAttribute><name>simpleContent</name><content>
    	    	      <schemaRepresentation><name>extension</name><schemaAttribute>
    	 		   base = <emph>QName</emph>
    	    		</schemaAttribute><content>
    	 		  <emph>AttributeContent</emph>
    	    		</content></schemaRepresentation>
    	  	    </content></schemaRepresentationNoAttribute>
               </td></tr></tbody></table>
            </map><a href="#jd_map_mixed_content" class="judgment"><subscript>mixed_content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
          </expression></xquery><core><expression>extends <emph>QName</emph> {
            <map><emph>AttributeContent</emph></map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            }</expression></core></mapping></smschemanorm></div3><div3 id="sec_import_ct_complex"><head>Complex type with complex content</head><smschema><p>A complex type can be of complex content. A complex
    	  content is represented in XML by the following
    	  structure.</p><schemaRepresentationEg><schemaRepresentation><name>complexContent</name><schemaAttribute role="ignored">
    		 id = ID
    	      </schemaAttribute><schemaAttribute>
        	 mixed = boolean : false
            </schemaAttribute><schemaAttribute role="ignored">
    		 {any attributes with non-schema namespace ...}
    	      </schemaAttribute><content>
               Content: (annotation?, (restriction | extension))
    	      </content></schemaRepresentation></schemaRepresentationEg><p>Derivation by restriction inside a complex content is
        represented in XML by the following structure.</p><schemaRepresentationEg><schemaRepresentation><name>restriction</name><schemaAttribute>
    		 base = QName
    	      </schemaAttribute><schemaAttribute role="ignored">
    		 id = ID
    	      </schemaAttribute><schemaAttribute role="ignored">
    		 {any attributes with non-schema namespace ...}
    	      </schemaAttribute><content>
               Content: (annotation?, (group | all | choice |
               sequence)?, ((attribute | attributeGroup)*,
               anyAttribute?))
            </content></schemaRepresentation></schemaRepresentationEg><p>Derivation by extension inside a complex content is
        represented in XML by the following structure.</p><schemaRepresentationEg><schemaRepresentation><name>extension</name><schemaAttribute>
               <term>base</term> = QName
            </schemaAttribute><schemaAttribute role="ignored">
               id = ID
            </schemaAttribute><schemaAttribute role="ignored">
               {any attributes with non-schema namespace ...}
            </schemaAttribute><content>
            Content: (annotation?, ((group | all | choice |
            sequence)?, ((attribute | attributeGroup)*,
            anyAttribute?)))
            </content></schemaRepresentation></schemaRepresentationEg></smschema><smschemanorm><p>If the complex content is derived by restriction, it is
        mapped into a type restriction in the [XPath/XQuery] type
        system, and the </p><mapping><xquery><expression>
              <map>
                <table summary=""><tbody><tr><td rowspan="1" colspan="1"><emph>MixedAttribute</emph></td><td rowspan="1" colspan="1">
   	  	  <schemaRepresentationNoAttribute><name>complexContent</name><content>
    	    	      <schemaRepresentation><name>restriction</name><schemaAttribute>
    	 		   base = <emph>QName</emph>
    	    		</schemaAttribute><content>
    	 		  <emph>annotation</emph>? <emph>ChildrenContent</emph> <emph>AttributeContent</emph>
    	    		</content></schemaRepresentation>
    	  	    </content></schemaRepresentationNoAttribute>
               </td></tr></tbody></table>
            </map><a href="#jd_map_mixed_content" class="judgment"><subscript>mixed_content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
          </expression></xquery><core><expression>restricts <emph>QName</emph>
            <map><emph>MixedAttribute</emph></map><a href="#jd_map_mixed" class="judgment"><subscript>mixed</subscript></a> {
            <map><emph>AttributeContent</emph></map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            <map><emph>ChildrenContent</emph></map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            }</expression></core></mapping><p>If the complex content is derived by extension, it is
        mapped into an extended type specifier into the [XPath/XQuery]
        type system.</p><mapping><xquery><expression>
              <map>
                <table summary=""><tbody><tr><td rowspan="1" colspan="1"><emph>MixedAttribute</emph></td><td rowspan="1" colspan="1">
   	  	  <schemaRepresentationNoAttribute><name>complexContent</name><content>
    	    	      <schemaRepresentation><name>extension</name><schemaAttribute>
    	 		   base = <emph>QName</emph>
    	    		</schemaAttribute><content>
    	 		  <emph>annotation</emph>? <emph>ChildrenContent</emph> <emph>AttributeContent</emph>
    	    		</content></schemaRepresentation>
    	  	    </content></schemaRepresentationNoAttribute>
               </td></tr></tbody></table>
            </map><a href="#jd_map_mixed_content" class="judgment"><subscript>mixed_content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
          </expression></xquery><core><expression>extends <emph>QName</emph>
            <map><emph>MixedAttribute</emph></map><a href="#jd_map_mixed" class="judgment"><subscript>mixed</subscript></a> {
            <map><emph>AttributeContent</emph></map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            <map><emph>ChildrenContent</emph></map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            }</expression></core></mapping></smschemanorm></div3></div2><div2 id="sec_attribute_use"><head>Attribute Uses</head><p>Mapping for attribute uses is given in <specref ref="sec_use"/>.</p></div2><div2 id="sec_attribute_group"><head>Attribute Group Definitions</head><div3 id="sec_attribute_group_def"><head>Attribute group definitions</head><smschema><p>Model group definitions are represented in XML by the
    	  following structure.</p><schemaRepresentationEg><schemaRepresentation><name>attributeGroup</name><schemaAttribute role="ignored">
    		 id = ID
    	      </schemaAttribute><schemaAttribute>
    		   name = NCame
    	      </schemaAttribute><schemaAttribute>
    		   ref = QName
    	      </schemaAttribute><schemaAttribute role="ignored">
    		 {any attributes with non-schema namespace ...}
    	      </schemaAttribute><content>
    		Content: (annotation?, ((attribute | attributeGroup)*,
    		anyAttribute?))
    	      </content></schemaRepresentation></schemaRepresentationEg></smschema><smschemanorm><p>Attribute group definitions are not currently handled by
    	  the mapping. See Issue 501 (FS-Issue-0158).</p></smschemanorm></div3><div3 id="sec_import_attribute_group_ref"><head>Attribute group reference</head><smschemanorm><p>Attribute group references are not currently handled by
    	  the mapping. See Issue 501 (FS-Issue-0158).</p></smschemanorm></div3></div2><div2 id="sec_import_model"><head>Model Group Definitions</head><smschema><p>Model group definitions are represented in XML by the
      following structure.</p><schemaRepresentationEg><schemaRepresentation><name>group</name><schemaAttribute>
    		 <term>name</term> = NCame
    	    </schemaAttribute><content>
            Content: (annotation?, (all | choice | sequence))
    	    </content></schemaRepresentation></schemaRepresentationEg></smschema><smschemanorm><p>Model group definitions are not currently handled by the
      mapping. See Issue 501 (FS-Issue-0158).</p></smschemanorm></div2><div2 id="sec_import_model_groups"><head>Model Groups</head><p>Model groups are either <quote>all</quote>,
    <quote>sequence</quote> or <quote>choice</quote>. One can also
    refer to a model group definition.</p><div3 id="sec_import_all_groups"><head>All groups</head><smschema><p>All groups are represented in XML by the following
    	  structure.</p><schemaRepresentationEg><schemaRepresentation><name>all</name><schemaAttribute role="ignored">
    		 id = ID
    	      </schemaAttribute><schemaAttribute>
    		 maxOccurs = 1 : 1
    	      </schemaAttribute><schemaAttribute>
    		 minOccurs = (0 | 1) : 1
    	      </schemaAttribute><schemaAttribute role="ignored">
    		 {any attributes with non-schema namespace ...}
    	      </schemaAttribute><content>
    		Content: (annotation?, element*)
    	      </content></schemaRepresentation></schemaRepresentationEg></smschema><smschemanorm><p>All groups are mapped into the <quote>&amp;</quote>
         operation in the [XPath/XQuery] type system.</p><mapping><xquery><expression>
              <map>
    	    	  <schemaRepresentation><name>all</name><schemaAttribute>
          	      <a href="#prod-formal-OccursAttributes"><emph>OccursAttributes</emph></a>
    	    	    </schemaAttribute><content>
    	 	      <emph>Element</emph><subscript>1</subscript> ... <emph>Element</emph><subscript>n</subscript>
    	    	    </content></schemaRepresentation>
             </map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            </expression></xquery><core><expression>(<map><emph>Element</emph><subscript>1</subscript></map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            &amp; ... &amp;
            <map><emph>Element</emph><subscript>n</subscript></map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>)
            <map><a href="#prod-formal-OccursAttributes"><emph>OccursAttributes</emph></a></map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a></expression></core></mapping></smschemanorm></div3><div3 id="sec_import_choice_groups"><head>Choice groups</head><smschema><p>Choice groups are represented in XML by the following
    	  structure.</p><schemaRepresentationEg><schemaRepresentation><name>choice</name><schemaAttribute role="ignored">
    		 id = ID
    	      </schemaAttribute><schemaAttribute>
    		 maxOccurs = (nonNegativeInteger | unbounded)  : 1
    	      </schemaAttribute><schemaAttribute>
    		 minOccurs = nonNegativeInteger : 1
    	      </schemaAttribute><schemaAttribute role="ignored">
    		 {any attributes with non-schema namespace ...}
    	      </schemaAttribute><content>
    		Content: (annotation?, (element | group | choice |
    		sequence | any)*)
    	      </content></schemaRepresentation></schemaRepresentationEg></smschema><smnotation><p>The following auxiliary grammar productions are used to
        describe group components.</p><scrap headstyle="show"><head>Group Component </head><prodrecap ref="GroupComponent" id="GroupComponent" orig="formal"/></scrap></smnotation><smschemanorm><p>Choice groups are mapped into the <quote>|</quote>
        operation in the [XPath/XQuery] type system.</p><mapping><xquery><expression>
              <map>
    	    	  <schemaRepresentation><name>choice</name><schemaAttribute>
          	      <a href="#prod-formal-OccursAttributes"><emph>OccursAttributes</emph></a>
    	    	    </schemaAttribute><content>
    	 	      <emph>GroupComponent</emph><subscript>1</subscript> ... <emph>GroupComponent</emph><subscript>n</subscript>
    	    	    </content></schemaRepresentation>
             </map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            </expression></xquery><core><expression>(<map><emph>GroupComponent</emph><subscript>1</subscript></map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            | ... |
            <map><emph>GroupComponent</emph><subscript>n</subscript></map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>)
            <map><a href="#prod-formal-OccursAttributes"><emph>OccursAttributes</emph></a></map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a></expression></core></mapping></smschemanorm></div3><div3 id="sec_import_sequence_groups"><head>Sequence groups</head><smschema><p>Sequence groups are represented in XML by the following
    	  structure.</p><schemaRepresentationEg><schemaRepresentation><name>sequence</name><schemaAttribute role="ignored">
    		 id = ID
    	      </schemaAttribute><schemaAttribute>
    		 maxOccurs = (nonNegativeInteger | unbounded)  : 1
    	      </schemaAttribute><schemaAttribute>
    		 minOccurs = nonNegativeInteger : 1
    	      </schemaAttribute><schemaAttribute role="ignored">
    		 {any attributes with non-schema namespace ...}
    	      </schemaAttribute><content>
    		Content: (annotation?, (element | group | choice |
    		sequence | any)*)
    	      </content></schemaRepresentation></schemaRepresentationEg></smschema><smschemanorm><p>Sequence groups are mapped into the <quote>,</quote>
        operation in the [XPath/XQuery] type system.</p><mapping><xquery><expression>
              <map>
    	    	  <schemaRepresentation><name>sequence</name><schemaAttribute>
          	      <a href="#prod-formal-OccursAttributes"><emph>OccursAttributes</emph></a>
    	    	    </schemaAttribute><content>
    	 	      <emph>GroupComponent</emph><subscript>1</subscript> ... <emph>GroupComponent</emph><subscript>n</subscript>
    	    	    </content></schemaRepresentation>
             </map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            </expression></xquery><core><expression>(<map><emph>GroupComponent</emph><subscript>1</subscript></map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            , ... ,
            <map><emph>GroupComponent</emph><subscript>n</subscript></map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>)
            <map><a href="#prod-formal-OccursAttributes"><emph>OccursAttributes</emph></a></map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a></expression></core></mapping></smschemanorm></div3></div2><div2 id="sec_import_particles"><head>Particles</head><p>Particles contribute to the definition of content models.</p><p>A particle can be either an element reference, a group
    reference or a wildcard.</p><div3 id="sec_import_element_ref"><head>Element reference</head><smschema><p>Element reference particles are represented in XML by the
    	  following structure.</p><schemaRepresentationEg><schemaRepresentationNoContent><name>element</name><schemaAttribute>
    		 ref = QName
    	      </schemaAttribute><schemaAttribute>
    		   maxOccurs = (nonNegativeInteger | unbounded)  : 1
    	      </schemaAttribute><schemaAttribute>
    		   minOccurs = nonNegativeInteger : 1
    	      </schemaAttribute><schemaAttribute role="ignored">
    		 {any attributes with non-schema namespace ...}
    	      </schemaAttribute></schemaRepresentationNoContent></schemaRepresentationEg></smschema><smschemanorm><p>Element references are mapped into element references in
        the [XPath/XQuery] type system.</p><mapping><xquery><expression>
      	<map>
    	      	  <schemaRepresentationNoContent><name>element</name><schemaAttribute>
    	  	       ref = <emph>QName</emph>
    	     	    </schemaAttribute><schemaAttribute>
    	  	       <a href="#prod-formal-OccursAttributes"><emph>OccursAttributes</emph></a>
    	     	    </schemaAttribute></schemaRepresentationNoContent>
              </map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            </expression></xquery><core><expression>element <emph>QName</emph>
            <map><a href="#prod-formal-OccursAttributes"><emph>OccursAttributes</emph></a></map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a></expression></core></mapping></smschemanorm></div3><div3 id="sec_group_ref"><head>Group reference</head><smschema><p>Group reference particles are represented in XML by the
    	  following structure.</p><schemaRepresentationEg><schemaRepresentationNoContent><name>group</name><schemaAttribute>
    		 ref = QName
    	      </schemaAttribute><schemaAttribute>
    		   maxOccurs = (nonNegativeInteger | unbounded)  : 1
    	      </schemaAttribute><schemaAttribute>
    		   minOccurs = nonNegativeInteger : 1
    	      </schemaAttribute><schemaAttribute role="ignored">
    		 {any attributes with non-schema namespace ...}
    	      </schemaAttribute></schemaRepresentationNoContent></schemaRepresentationEg></smschema><smschemanorm><p>Model group references are not currently handled by the
        mapping.</p></smschemanorm></div3></div2><div2 id="sec_import_wildcards"><head>Wildcards</head><div3 id="sec_import_attribute_wildcards"><head>Attribute wildcards</head><smschema><p>Attribute wildcards are represented in XML by the
    	  following structure.</p><schemaRepresentationEg><schemaRepresentation><name>anyAttribute</name><schemaAttribute role="ignored">
        	 id = ID
            </schemaAttribute><schemaAttribute role="nothandled">
    		 namespace = ((##any | ##other) | List of (anyURI | (##targetNamespace | ##local)) )  : ##any
    	      </schemaAttribute><schemaAttribute>
    		 processContents = (lax | skip | strict) : strict
    	      </schemaAttribute><schemaAttribute role="ignored">
    		 {any attributes with non-schema namespace ...}
    	      </schemaAttribute><content>
               Content: (annotation?)
            </content></schemaRepresentation></schemaRepresentationEg></smschema><smschemanorm><p>An attribute wildcard with a <quote>skip</quote> process
        content is mapped as an attribute wildcard in the [XPath/XQuery]
        type system.</p><mapping><xquery><expression>
        	<map>
    		  <schemaRepresentation><name>anyAttribute</name><schemaAttribute>
    		       processContents = <quote>skip</quote>
    		    </schemaAttribute><content>
      	       <emph>annotation</emph>?
      	    </content></schemaRepresentation>
      	 </map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            </expression></xquery><core><expression>(attribute (*, <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>))*</expression></core></mapping><mapping><xquery><expression>
        	<map>
    		  <schemaRepresentation><name>anyAttribute</name><schemaAttribute>
    		       processContents = <quote>lax</quote>
    		    </schemaAttribute><content>
      	       <emph>annotation</emph>?
      	    </content></schemaRepresentation>
      	 </map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            </expression></xquery><core><expression>attribute *</expression></core></mapping><mapping><xquery><expression>
        	<map>
    		  <schemaRepresentation><name>anyAttribute</name><schemaAttribute>
    		       processContents = <quote>strict</quote>
    		    </schemaAttribute><content>
      	       <emph>annotation</emph>?
      	    </content></schemaRepresentation>
      	 </map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            </expression></xquery><core><expression>attribute *</expression></core></mapping><!--
  	<ednote>
  	  <edtext>Attribute wildcards with a
          <quote>strict</quote> process content
          are not handled by the mapping. </edtext>
  	</ednote>
--><ednote><edtext>Namespace wildcards are not
  	  handled by the mapping.</edtext></ednote></smschemanorm></div3><div3 id="sec_import_element_wildcards"><head>Element wildcards</head><smschema><p>Element wildcards are represented in XML by the following
    	  structure.</p><schemaRepresentationEg><schemaRepresentation><name>any</name><schemaAttribute role="ignored">
        	 id = ID
            </schemaAttribute><schemaAttribute>
    		 maxOccurs = (nonNegativeInteger | unbounded)  : 1
    	      </schemaAttribute><schemaAttribute>
    		 minOccurs = nonNegativeInteger : 1
    	      </schemaAttribute><schemaAttribute role="nothandled">
    		 namespace = ((##any | ##other) | List of (anyURI | (##targetNamespace | ##local)) )  : ##any
    	      </schemaAttribute><schemaAttribute>
    		 processContents = (lax | skip | strict) : strict
    	      </schemaAttribute><schemaAttribute role="ignored">
    		 {any attributes with non-schema namespace ...}
    	      </schemaAttribute><content>
               Content: (annotation?)
            </content></schemaRepresentation></schemaRepresentationEg></smschema><smschemanorm><p>An element wildcard with a <quote>skip</quote> process
        content is mapped as an element wildcard in the [XPath/XQuery]
        type system.</p><mapping><xquery><expression>
      	<map>
    		  <schemaRepresentation><name>any</name><schemaAttribute>
    		       <a href="#prod-formal-OccursAttributes"><emph>OccursAttributes</emph></a>
    		    </schemaAttribute><schemaAttribute>
    		       processContents = <quote>skip</quote>
    		    </schemaAttribute><content>
      	       <emph>annotation</emph>?
      	    </content></schemaRepresentation>
      	 </map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            </expression></xquery><core><expression>( element (*, <a href="#dt-xs_untyped"><code>xs:untyped</code></a>)
            )<map><a href="#prod-formal-OccursAttributes"><emph>OccursAttributes</emph></a></map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a></expression></core></mapping><mapping><xquery><expression>
      	<map>
    		  <schemaRepresentation><name>any</name><schemaAttribute>
    		       <a href="#prod-formal-OccursAttributes"><emph>OccursAttributes</emph></a>
    		    </schemaAttribute><schemaAttribute>
    		       processContents = <quote>lax</quote>
    		    </schemaAttribute><content>
      	       <emph>annotation</emph>?
      	    </content></schemaRepresentation>
      	 </map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            </expression></xquery><core><expression>( element (*, <code>xs:anyType</code>)
            )<map><a href="#prod-formal-OccursAttributes"><emph>OccursAttributes</emph></a></map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a></expression></core></mapping><ednote><edtext>Element wildcards with a
          <quote>lax</quote> or <quote>strict</quote> process content
          are not handled by the mapping. </edtext></ednote><ednote><edtext>Namespace wildcards are not
  	  handled by the mapping.</edtext></ednote></smschemanorm></div3></div2><div2 id="sec_import_identity"><head>Identity-constraint Definitions</head><p>All identity-constraints definitions are ignored when mapping
    into the [XPath/XQuery] type system.</p></div2><div2 id="sec_import_notation"><head>Notation Declarations</head><p>All notation declarations are ignored when mapping into the
    [XPath/XQuery] type system.</p></div2><div2 id="sec_import_annotation"><head>Annotation</head><p>All annotation are ignored when mapping into the [XPath/XQuery]
    type system.</p></div2><div2 id="sec_import_simple_type"><head>Simple Type Definitions</head><smschema><p>A simple type is represented in XML by the following
      structure.</p><schemaRepresentationEg><schemaRepresentation><name>simpleType</name><schemaAttribute role="ignored">
             final = (#all | (list | union | restriction))
          </schemaAttribute><schemaAttribute role="ignored">
             id = ID
          </schemaAttribute><schemaAttribute>
             name = NCName
          </schemaAttribute><schemaAttribute role="ignored">
             {any attributes with non-schema namespace ...}
          </schemaAttribute><content>
            name = NCName
          </content></schemaRepresentation></schemaRepresentationEg><p>Derivation by restriction inside a simple type is represented
      in XML by the following structure.</p><schemaRepresentationEg><schemaRepresentation><name>restriction</name><schemaAttribute>
             base = QName
          </schemaAttribute><schemaAttribute role="ignored">
             id = ID
          </schemaAttribute><schemaAttribute role="ignored">
             {any attributes with non-schema namespace ...}
          </schemaAttribute><content>
            Content: (annotation?, (simpleType?, (minExclusive |
            minInclusive | maxExclusive | maxInclusive |
            totalDigits | fractionDigits | length | minLength |
            maxLength | enumeration | whiteSpace | pattern)*)?)
          </content></schemaRepresentation></schemaRepresentationEg><p>Derivation by list inside a simple type is represented in XML
      by the following structure.</p><schemaRepresentationEg><schemaRepresentation><name>list</name><schemaAttribute role="ignored">
             id = ID
          </schemaAttribute><schemaAttribute>
             itemType = QName
          </schemaAttribute><schemaAttribute role="ignored">
             {any attributes with non-schema namespace ...}
          </schemaAttribute><content>
             Content: (annotation?, (simpleType?))
          </content></schemaRepresentation></schemaRepresentationEg><p>Derivation by union inside a simple type is represented in
      XML by the following structure.</p><schemaRepresentationEg><schemaRepresentation><name>union</name><schemaAttribute role="ignored">
             id = ID
          </schemaAttribute><schemaAttribute>
             memberTypes = List of QName
          </schemaAttribute><schemaAttribute role="ignored">
             {any attributes with non-schema namespace ...}
          </schemaAttribute><content>
             Content: (annotation?, (simpleType*))
          </content></schemaRepresentation></schemaRepresentationEg></smschema><div3 id="sec_import_global_simple_type"><head>Global simple type definition</head><p>Schema import distinguishes between global simple types
      (which are mapped to sort declarations) and local simple types
      (which are mapped to type definitions).</p><smschemanorm><p>In the case of global simple types, the mapping rule which
        applies is denoted by <map/><a href="#jd_map_definition" class="judgment"><subscript>definition(<emph>target</emph><emph>NCName</emph>)</subscript></a>.</p><mapping><xquery><expression>
      	      <map>
      		<schemaRepresentation><name>simpleType</name><schemaAttribute>
      		     name = <emph>NCName</emph>
      		  </schemaAttribute><content>
      		     <emph>SimpleTypeContent</emph>
      		  </content></schemaRepresentation>
      	    </map><a href="#jd_map_definition" class="judgment"><subscript>definition(<emph>target</emph><emph>NCName</emph>)</subscript></a>
      	  </expression></xquery><core><expression>define type <emph>target</emph><emph>NCName</emph>:<emph>NCName</emph>
      	    <map><emph>SimpleTypeContent</emph></map><a href="#jd_map_simple_content" class="judgment"><subscript>simple_content(<emph>target</emph><emph>NCName</emph>)</subscript></a></expression></core></mapping></smschemanorm></div3><div3 id="sec_import_local_simple_type"><head>Local simple type definition</head><smschemanorm><p>In the case of global simple types, the mapping rule which
        applies is denoted by <map/><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>.</p><mapping><xquery><expression>
      	      <map>
      		<schemaRepresentationNoAttribute><name>simpleType</name><content>
      		     <emph>SimpleTypeContent</emph>
      		  </content></schemaRepresentationNoAttribute>
      	    </map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
      	  </expression></xquery><core><expression><map><emph>SimpleTypeContent</emph></map><a href="#jd_map_simple_content" class="judgment"><subscript>simple_content(<emph>target</emph><emph>NCName</emph>)</subscript></a></expression></core></mapping></smschemanorm></div3><div3 id="sec_import_simple_type_content"><head>Simple type content</head><smnotation><p id="jd_map_simple_content">The normalization rule
        <map/><a href="#jd_map_simple_content" class="judgment"><subscript>simple_content(<emph>target</emph><emph>NCName</emph>)</subscript></a> maps a simple type content
        to a type specifier and an optional occurrence indicator.</p></smnotation><smschemanorm><p>If the simple type is derived by restriction, it is mapped
        into a simple type restriction in the [XPath/XQuery] type
        system.   The name of the base atomic type and attributes
        are mapped.  Only the minLength, maxLength, and length facets in the simple type
        restriction are handled.  All other properties of the simple-type restriction are ignored.</p><mapping><xquery><expression>
      	      <map>
      		<schemaRepresentation><name>restriction</name><schemaAttribute>
      		     base = <emph>QName</emph>
      		  </schemaAttribute><content>
      		     <emph>simpleContentRestriction</emph>
      		  </content></schemaRepresentation>
      	    </map><a href="#jd_map_simple_content" class="judgment"><subscript>simple_content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
      	  </expression></xquery><core><expression>restricts <emph>QName</emph> { <emph>QName</emph> } <map><emph>simpleContentRestriction</emph></map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a></expression></core></mapping><p>If the simple type is derived by list, and its content type
        does not constrain the length of the list, 
        it is mapped into a zero-or-more repetition type into the [XPath/XQuery] type system.</p><mapping><xquery><expression>
      	      <map>
                <schemaRepresentationNoAttribute><name>list</name><content>
                    <emph>SimpleType</emph>
                  </content></schemaRepresentationNoAttribute>
      	      </map><a href="#jd_map_simple_content" class="judgment"><subscript>simple_content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
              <a href="#doc-fs-Type"><emph>Type</emph></a> = <map><emph>SimpleType</emph></map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
      	    </expression></xquery><core><expression>{ <a href="#doc-fs-Type"><emph>Type</emph></a> * }</expression></core></mapping><p>If the simple type is derived by list, and its content type
        does constrain the length of the list, then it is mapped into
        a zero-or-more repetition type into the [XPath/XQuery] type
        system.</p><mapping><xquery><expression>
      	      <map>
                <schemaRepresentationNoAttribute><name>list</name><content>
                    <emph>SimpleType</emph>
                  </content></schemaRepresentationNoAttribute>
      	      </map><a href="#jd_map_simple_content" class="judgment"><subscript>simple_content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
              <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_quantifier" class="judgment">·</a> <emph>OccurrenceIndicator</emph> = <map><emph>SimpleType</emph></map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
      	    </expression></xquery><core><expression>{ <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_quantifier" class="judgment">·</a> <emph>OccurrenceIndicator</emph> }</expression></core></mapping><mapping><xquery><expression>
      	      <map>
                <schemaRepresentationNoContent><name>list</name><schemaAttribute>
                     itemType = <emph>QName</emph>
                  </schemaAttribute></schemaRepresentationNoContent>
      	      </map><a href="#jd_map_simple_content" class="judgment"><subscript>simple_content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
      	    </expression></xquery><core><expression>{ <emph>QName</emph>* }</expression></core></mapping><p>If the simple type is derived by union, it is mapped into a
        union type into the [XPath/XQuery] type system.</p><mapping><xquery><expression>
      	      <map>
                <schemaRepresentationNoAttribute><name>union</name><content>
                    <emph>SimpleType</emph><subscript>1</subscript> ... <emph>SimpleType</emph><subscript>n</subscript>
                  </content></schemaRepresentationNoAttribute>
      	      </map><a href="#jd_map_simple_content" class="judgment"><subscript>simple_content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
      	    </expression></xquery><core><expression>{ (<map><emph>SimpleType</emph></map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            | ... | <map><emph>SimpleType</emph><subscript>n</subscript></map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>) }</expression></core></mapping><mapping><xquery><expression>
      	      <map>
                <schemaRepresentationNoContent><name>union</name><schemaAttribute>
                     memberTypes = <emph>QName</emph><subscript>1</subscript> ... <emph>QName</emph><subscript>n</subscript>
                  </schemaAttribute></schemaRepresentationNoContent>
      	      </map><a href="#jd_map_simple_content" class="judgment"><subscript>simple_content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
      	    </expression></xquery><core><expression>{ <emph>QName</emph><subscript>1</subscript> | ... | <emph>QName</emph><subscript>n</subscript> }</expression></core></mapping></smschemanorm></div3></div2></div1><!-- *************************** References           **************** --><div1 id="appendix_references"><head>References</head><div2 id="id-normative-references"><head>Normative References</head><blist><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="REC-xml" key="XML" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><!-- not referenced so far?
<bibl id="XMLNAMES" key="XML Names">World Wide Web
Consortium. <emph>Namespaces in XML.</emph> W3C Recommendation. See
<loc
href="http://www.w3.org/TR/REC-xml-names/">http://www.w3.org/TR/REC-xml-names/</loc></bibl>
--><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XMLNAMES11" key="XML Names 1.1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web
Consortium. <emph>Namespaces in XML 1.1.</emph> W3C
Recommendation. See <loc href="http://www.w3.org/TR/xml-names11/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xml-names11/</loc></bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xmlschema-1" key="Schema Part 1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xmlschema-2" key="Schema Part 2" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xpath-datamodel-30" key="Data Model" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xslt-xquery-serialization-30" key="Data Model Serialization 3.0" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xquery-30" key="XQuery 3.0: An XML Query Language" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xpath-30" key="XML Path Language (XPath) 3.0" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xpath-functions-30" key="Functions and Operators 3.0" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/></blist></div2><div2 id="id-non-normative-references"><head>Non-normative References</head><blist><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xmlschema-0" key="XML Schema Part 0" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xquery-30-requirements" key="XQuery 3.0 Requirements" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xpath-30-requirements" key="XPath 3.0 Requirements" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/></blist></div2><div2 id="id-background-references"><head>Background References</head><blist><!--
     <bibl key="BFS00" id="BFS00">
       P. Buneman, M. Fernandez, D. Suciu.  UnQL: A query language and
       algebra for semistructured data based on structural recursion.
       <emph>VLDB Journal</emph>, April, 2000, Vol 9, Number 1.
     </bibl>
     <bibl key="BKD90" id="BKD90">     
       Francois Bancilhon, Paris Kanellakis, Claude Delobel.
       <emph>Building an Object-Oriented Database System</emph>.
       Morgan Kaufmann, 1990.
     </bibl>
     <bibl key="BNTW95" id="BNTW95">   
       Peter Buneman, Shamim Naqvi, Val Tannen, Limsoon Wong.
       Principles of programming with complex object and collection
       types.  <emph>Theoretical Computer Science</emph> 149(1):3&mdash;48,
       1995.
     </bibl>
     <bibl key="Quilt" id="Quilt">
       Don Chamberlin, Jonathan Robie, and Daniela Florescu.  Quilt: An
       XML Query Language for Heterogeneous Data Sources.
       <emph>International Workshop on the Web and Databases
       (WebDB'2000)</emph>, Dallas, Texas, May 2000.
     </bibl>
--><!--
     <bibl key="CM93" id="CM93">        
       S. Cluet and G. Moerkotte. Nested queries in object bases.
       <emph>Workshop on Database Programming Languages</emph>, pages
       226-242, New York, August 1993.
     </bibl>
     <bibl key="YAT99" id="YAT99">
       S.&nbsp;Cluet, and J.&nbsp;Sim&eacute;on.  YATL: A Functional
       and Declarative Language for XML.  See <loc
       href="http://db.bell-labs.com/user/simeon/icfp.ps">http://db.bell-labs.com/user/simeon/icfp.ps</loc>
     </bibl>
     <bibl key="Col90" id="Col90">      
       L. S. Colby.  A recursive algebra for nested relations.
       <emph>Information Systems</emph> 15(5):567-582, 1990.
     </bibl>
     <bibl key="XMLQL99" id="XMLQL99">
       A.&nbsp;Deutsch, M.&nbsp;Fernandez, D.&nbsp;Florescu,
       A.&nbsp;Levy, and D.&nbsp;Suciu.  <emph>A query language for
       XML.</emph> In <emph>International World Wide Web
       Conference</emph>, 1999.
     </bibl>
     <bibl key="Graefe93" id="Graefe93">
       Goetz Graefe, <emph>Query Evaluation Techniques for Large
       Databases</emph>. In <emph>ACM Computing Surveys</emph>,
       25(2):73-170, 1993.
     </bibl>
     <bibl key="LW97" id="LW97">        
       Leonid Libkin and Limsoon Wong.  Query languages for bags and
       aggregate functions.  <emph>Journal of Computer and Systems
       Sciences</emph>, 55(2):241-272, October 1997.
     </bibl>
     <bibl key="HP2000" id="HP2000">    
       Haruio Hosoya, Benjamin Pierce, XDuce : A Typed XML Processing
       Language (Preliminary Report) <emph>WebDB Workshop</emph> 2000.
     </bibl>
     <bibl key="LMW96" id="LMW96">      
       Leonid Libkin, Rona Machlin, and Limsoon Wong.  A query language
       for multi-dimensional arrays: Design, implementation, and
       optimization techniques.  <emph>SIGMOD</emph> 1996.
     </bibl>
     <bibl key="Milner" id="Milner">
       R. Milner, M. Tofte, R. Harper, D. MacQueen <emph>The Definition
       of Standard ML (Revise)</emph>.  MIT Press, 1997.
     </bibl>
     <bibl key="Mitchell" id="Mitchell">
       John C. Mitchell <emph>Foundations for Programming
       Languages</emph>.  MIT Press, 1998.
     </bibl>
     <bibl key="Mog89" id="Mog89">  
       E. Moggi, Computational lambda-calculus and monads.  In
       <emph>Symposium on Logic in Computer Science</emph> Asilomar,
       California, IEEE, June 1989.
     </bibl>
     <bibl key="Mog91" id="Mog91">
       E. Moggi, Notions of computation and monads.  <emph>Information
       and Computation</emph>, 93(1), 1991.
     </bibl>
     <bibl key="SQL" id="SQL">
       International Organization for Standardization (ISO).
       <emph>Information Technology-Database Language
       SQL</emph>. Standard No. ISO/IEC 9075:1999.  (Available from
       American National Standards Institute, New York, NY 10036,
       (212) 642-4900.)
     </bibl>
     <bibl key="ODMG" id="ODMG">
       Rick Cattell et al. <emph>The Object Database Standard:
       ODMG-93, Release 1.2</emph>. Morgan Kaufmann Publishers, San
       Francisco, 1996.
     </bibl>
     <bibl key="XQL99" id="XQL99">
       J.&nbsp;Robie, editor.  XQL '99 Proposal, 1999.  See <loc
       href="http://www.ibiblio.org/xql/xql-proposal.html">http://www.ibiblio.org/xql/xql-proposal.html</loc>.
     </bibl>
--><bibl xmlns:xlink="http://www.w3.org/1999/xlink" key="Languages" id="Languages" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
       Handbook of Formal Languages. G. Rozenberg and A. Salomaa,
       editors. <emph>Springer-Verlag</emph>. 1997.
     </bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" key="TATA" id="TATA" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
       Tree Automata Techniques and Applications. H. Comon and
       M. Dauchet and R. Gilleron and F. Jacquemard and D. Lugiez and
       S. Tison and M. Tommasi. See <loc href="http://www.grappa.univ-lille3.fr/tata/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.grappa.univ-lille3.fr/tata/</loc>. 1997.
     </bibl><!--
     <bibl key="Wad93" id="Wad93">     
       P. Wadler, Monads for functional programming.  In M. Broy,
       editor, <emph>Program Design Calculi</emph>, NATO ASI Series,
       Springer Verlag, 1993.  Also in J. Jeuring and E. Meijer,
       editors, <emph>Advanced Functional Programming</emph>, LNCS 925,
       Springer Verlag, 1995.
     </bibl>

     <bibl key="Wad95" id="Wad95">
       P. Wadler, How to declare an imperative.  <emph>ACM Computing
       Surveys</emph>, 29(3):240-263, September 1997.
     </bibl>

     <bibl key="Won00" id="Won00">
       Limsoon Wong.  An introduction to the Kleisli query system and a
       commentary on the influence of functional programming on its
       implementation.  <emph>Journal of Functional Programming</emph>,
       to appear.
     </bibl>
--></blist></div2></div1><inform-div1 id="sec_validation_judgments"><head>Auxiliary Judgments for Validation</head><div2 id="sec_validate"><head>Judgments for the validate expression</head><p>XQuery supports XML Schema validation using the validate
    expression. This section gives a non-normative formal semantics of XML Schema
    validation, solely for the purpose of specifying its usage in XQuery.</p><p>Specifying XML Schema validation requires a fairly large number
    of auxiliary judgments. There are two main judgments used to
    describe the semantics of validation.</p><ulist><item><p>The <quote>erase</quote> judgment takes a value and removes
        all type information from it. This operation is necessary
        since, in XQuery, validation can occur both on well-formed or
        already validated documents.</p></item><item><p>The <quote>annotate</quote> operation takes an untyped
        value and a type and either fails or succeeds by returning a
        new -validated- value.</p></item></ulist><p>Before defining these two judgments, we first introduce the
    auxiliary judgments used to describe specific parts of XML
    Schema's semantics.</p><div3 id="sec_type_resolution"><head>Type resolution</head><smnotation><p id="jd_resolves_to">The judgments</p><display>
          <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a>
          <a href="#jd_resolves_to" class="judgment"><term>resolves to</term></a> <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> { <a href="#doc-fs-Type"><emph>Type</emph></a> }</expression></clause>
        </display><p>and</p><display>
          <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-TypeDerivation"><emph>TypeDerivation</emph></a>
          <a href="#jd_resolves_to" class="judgment"><term>resolves to</term></a> <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> { <a href="#doc-fs-Type"><emph>Type</emph></a> }</expression></clause>
        </display><p>hold when a type reference (resp. a type derivation)
        resolves to the given type name and type content.</p></smnotation><smrules><p>Those judgments are specified by the following rules.</p><p>If the type is omitted, it is resolved as the empty
	sequence type.</p><infergr><infer><prejudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
               <phrase diff="del" at="E036"><a href="#doc-fs-Derivation"><emph>Derivation</emph></a>?</phrase>
               <phrase diff="add" at="E036"><a href="#doc-fs-OptDerivation"><emph>OptDerivation</emph></a></phrase>
               <a href="#doc-fs-OptMixed"><emph>OptMixed</emph></a> { empty } <a href="#jd_resolves_to" class="judgment"><term>resolves to</term></a> <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> { <a href="#doc-fs-Type"><emph>Type</emph></a> }
             </expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
               <phrase diff="del" at="E036"><a href="#doc-fs-Derivation"><emph>Derivation</emph></a>?</phrase>
               <phrase diff="add" at="E036"><a href="#doc-fs-OptDerivation"><emph>OptDerivation</emph></a></phrase>
               <a href="#doc-fs-OptMixed"><emph>OptMixed</emph></a> { } <a href="#jd_resolves_to" class="judgment"><term>resolves to</term></a> <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> { <a href="#doc-fs-Type"><emph>Type</emph></a> }
             </expression></clause></postjudge></infer></infergr><p>In case of a type reference, then the type name is the name
        of that type, and the type is taken by resolving the type
        declaration of the global type.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           </expression></clause></multiclause><multiclause><clause><expression>
                <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>) = define type
                <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> <a href="#doc-fs-TypeDerivation"><emph>TypeDerivation</emph></a>
              </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-TypeDerivation"><emph>TypeDerivation</emph></a> <a href="#jd_resolves_to" class="judgment"><term>resolves to</term></a>
              <a href="#doc-fs-TypeName"><emph>BaseTypeName</emph></a> { <a href="#doc-fs-Type"><emph>Type</emph></a> }</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>of type <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> <a href="#jd_resolves_to" class="judgment"><term>resolves to</term></a> <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> { <a href="#doc-fs-Type"><emph>Type</emph></a> }</expression></clause></postjudge></infer></infergr><p>In the above inference rule, note that <a href="#doc-fs-TypeName"><emph>BaseTypeName</emph></a> is
        the base type of the type referred to. So this is indeed the
        original type name, <a href="#doc-fs-TypeName"><emph>TypeName</emph></a>, which must be returned, and
        eventually used to annotated the corresponding element or
        attribute. However, the type needs to be obtained through a
        second application of the <a href="#jd_resolves_to" class="judgment"><term>resolves to</term></a> judgment.</p><p>If the type derivation is a restriction, then the type name
        is the name of the base type, and the type is taken from the
        type derivation.</p><infergr><infer><prejudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-OptMixed"><emph>OptMixed</emph></a> <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_adjusts_to" class="judgment"><term>adjusts to</term></a> <emph>Adjusted</emph><a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>restricts <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> <a href="#doc-fs-OptMixed"><emph>OptMixed</emph></a> {
             <a href="#doc-fs-Type"><emph>Type</emph></a> } <a href="#jd_resolves_to" class="judgment"><term>resolves to</term></a> <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> {
             <emph>Adjusted</emph><a href="#doc-fs-Type"><emph>Type</emph></a> }</expression></clause></postjudge></infer></infergr><p>If the type derivation is an extension, then the type name
        is the name of the base type, and the type is the base type
        extended by the type in the type derivation.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
             <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           </expression></clause></multiclause><multiclause><clause><expression>
                <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>) = define type
                <a href="#doc-fs-TypeName"><emph>TypeName</emph></a>
                <phrase diff="del" at="E036"><a href="#doc-fs-Derivation"><emph>Derivation</emph></a>?</phrase>
                <phrase diff="add" at="E036"><a href="#doc-fs-OptDerivation"><emph>OptDerivation</emph></a></phrase>
                <a href="#doc-fs-OptMixed"><emph>BaseOptMixed</emph></a> {
                <emph>Base</emph><a href="#doc-fs-Type"><emph>Type</emph></a>? }
              </expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>Base</emph><a href="#doc-fs-Type"><emph>Type</emph></a>? <a href="#jd_extended_by" class="judgment"><term>extended by</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
              <a href="#jd_extended_by" class="judgment"><term>is</term></a> <emph>Extended</emph><a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-OptMixed"><emph>OptMixed</emph></a> <emph>Extended</emph><a href="#doc-fs-Type"><emph>Type</emph></a>
              <a href="#jd_adjusts_to" class="judgment"><term>adjusts to</term></a> <emph>Adjusted</emph><a href="#doc-fs-Type"><emph>Type</emph></a></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>extends <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> <a href="#doc-fs-OptMixed"><emph>OptMixed</emph></a> { <a href="#doc-fs-Type"><emph>Type</emph></a>
             } <a href="#jd_resolves_to" class="judgment"><term>resolves to</term></a> <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> { <emph>Adjusted</emph><a href="#doc-fs-Type"><emph>Type</emph></a> }</expression></clause></postjudge></infer></infergr></smrules></div3><div3 id="sec_interleaving"><head>Interleaving</head><smnotation><p id="jd_interleave">The judgment</p><display>
          <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_interleave" class="judgment"><term>interleave</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>
          <a href="#jd_interleave" class="judgment"><term>yields</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>3</subscript></expression></clause>
        </display><p>holds if some interleaving of <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> and <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>
        yields <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>3</subscript>.  Interleaving is non-deterministic; it is
        used for processing all groups.</p></smnotation><smrules><p>This judgment is specified by the following rules.</p><p>Interleaving two empty sequences yields the empty
        sequence.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>() <a href="#jd_interleave" class="judgment"><term>interleave</term></a> () <a href="#jd_interleave" class="judgment"><term>yields</term></a>
             ()</expression></clause></postjudge></infer></infergr><p>Otherwise, pick an item from the head of one of the
        sequences, and recursively interleave the remainder.</p><infergr><infer><prejudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_interleave" class="judgment"><term>interleave</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>
             <a href="#jd_interleave" class="judgment"><term>yields</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>3</subscript></expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Item"><emph>Item</emph></a>,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_interleave" class="judgment"><term>interleave</term></a>
             <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> <a href="#jd_interleave" class="judgment"><term>yields</term></a>
             <a href="#doc-fs-Item"><emph>Item</emph></a>,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>3</subscript></expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_interleave" class="judgment"><term>interleave</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>
             <a href="#jd_interleave" class="judgment"><term>yields</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>3</subscript></expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_interleave" class="judgment"><term>interleave</term></a>
             <a href="#doc-fs-Item"><emph>Item</emph></a>,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> <a href="#jd_interleave" class="judgment"><term>yields</term></a>
             <a href="#doc-fs-Item"><emph>Item</emph></a>,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>3</subscript></expression></clause></postjudge></infer></infergr></smrules></div3><div3 id="sec_jd_filter"><head>Attribute filtering</head><smintro><p>Finally, we introduce an auxiliary judgment which extracts
        the value of a given attribute if it exists. This judgment is
        not used in the semantics of step expressions, but in <specref ref="sec_type_matching"/>, and is based on the other filter
        judgments.</p></smintro><smnotation><p id="jd_filter">The judgment</p><display>
          <clause><expression><a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_filter" class="judgment"><term>filter</term></a> @<emph>QName</emph> <a href="#jd_filter" class="judgment"><term>=&gt;</term></a> <a href="#jd_filter" class="judgment"><term>absent</term></a></expression></clause>
        </display><p>holds if there are no occurrences of the attribute
        <emph>QName</emph> in <a href="#doc-fs-Value"><emph>Value</emph></a>. The judgment</p><display>
          <clause><expression><a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_filter" class="judgment"><term>filter</term></a> @<emph>QName</emph> <a href="#jd_filter" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a></expression></clause>
        </display><p>holds if there is one occurrence of the attribute
        <emph>QName</emph> in <a href="#doc-fs-Value"><emph>Value</emph></a>, and the value of that attribute is
        <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a>.</p></smnotation><smrules><p>The <a href="#jd_filter" class="judgment"><term>filter</term></a> judgments are defined as follows.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><a href="#jd_axis" class="judgment"><term>axis</term></a> attribute:: <a href="#jd_axis" class="judgment"><term>of</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>
              <a href="#jd_axis" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><a href="#jd_test" class="judgment"><term>test</term></a> <emph>QName</emph> <a href="#jd_test" class="judgment"><term>with</term></a> attribute
              <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> <a href="#jd_test" class="judgment"><term>=&gt;</term></a>
              ()</expression></clause></multiclause></prejudge><postjudge><clause><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_filter" class="judgment"><term>filter</term></a> @<emph>QName</emph>
              <a href="#jd_filter" class="judgment"><term>=&gt;</term></a> <a href="#jd_filter" class="judgment"><term>absent</term></a></expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><a href="#jd_axis" class="judgment"><term>axis</term></a> attribute:: <a href="#jd_axis" class="judgment"><term>of</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> 
              <a href="#jd_axis" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><a href="#jd_test" class="judgment"><term>test</term></a> <emph>QName</emph> <a href="#jd_test" class="judgment"><term>with</term></a> attribute
              <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> <a href="#jd_test" class="judgment"><term>=&gt;</term></a>
              <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>3</subscript></expression></clause></multiclause><multiclause><clause><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>3</subscript> = attribute <emph>QName</emph> {
              <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a> }</expression></clause></multiclause></prejudge><postjudge><clause><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_filter" class="judgment"><term>filter</term></a> @<emph>QName</emph>
              <a href="#jd_filter" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a></expression></clause></postjudge></infer></infergr></smrules></div3><div3 id="sec_erasure"><head>Erasure</head><div4 id="sec_simply_erases"><head>Simply erases</head><smnotation><p id="jd_simply_erases_to">To define erasure, an auxiliary
        judgment is needed.  The judgment</p><display>
          <clause><expression><a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a> <a href="#jd_simply_erases_to" class="judgment"><term>simply erases to</term></a>
          <emph>String</emph></expression></clause>
        </display><p>holds when <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a> erases to the string
        <emph>String</emph>.</p></smnotation><smrules><p>This judgment is specified by the following rules.</p><p>The empty sequence erases to the empty string.</p><infergr><infer><prejudge/><postjudge><clause><expression>() <a href="#jd_simply_erases_to" class="judgment"><term>simply erases to</term></a> ""</expression></clause></postjudge></infer></infergr><p>The concatenation of two non-empty sequences of values
        erases to the concatenation of their erasures with a
        separating space.</p><infergr><infer><prejudge><multiclause><clause><expression><a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>1</subscript> <a href="#jd_simply_erases_to" class="judgment"><term>simply erases to</term></a>
              <emph>String</emph><subscript>1</subscript></expression></clause></multiclause><multiclause><clause><expression><a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>1</subscript> != ()</expression></clause></multiclause><multiclause><clause><expression><a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript> <a href="#jd_simply_erases_to" class="judgment"><term>simply erases to</term></a>
              <emph>String</emph><subscript>2</subscript></expression></clause></multiclause><multiclause><clause><expression><a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript> != ()</expression></clause></multiclause></prejudge><postjudge><clause><expression><a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>1</subscript>,<a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript>
             <a href="#jd_simply_erases_to" class="judgment"><term>simply erases to</term></a> <code>fn:concat</code>(<emph>String</emph><subscript>1</subscript>,"
             ",<emph>String</emph><subscript>2</subscript>)</expression></clause></postjudge></infer></infergr><p>An atomic value erases to its string representation as an
        instance of <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>.</p><infergr><infer><prejudge/><postjudge><clause><expression><a href="#doc-fs-AtomicValueContent"><emph>AtomicValueContent</emph></a> of type <a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a>
             <a href="#jd_simply_erases_to" class="judgment"><term>simply erases to</term></a>
             <emph>dm:</emph><code>string-value</code>(<a href="#doc-fs-AtomicValueContent"><emph>AtomicValueContent</emph></a>)</expression></clause></postjudge></infer></infergr></smrules></div4><div4 id="sec_erases"><head>Erases</head><smnotation><p id="jd_erases_to">The <a href="#jd_erases_to" class="judgment"><term>erases to</term></a> judgment is used in
        the definition of the dynamic semantics of validation.  The
        normative dynamic semantics of validation is specified in
        <xspecref spec="XQ" ref="id-validate"/>.

        The effect of the validate expression is equivalent to:
        <ulist><item><p>serialization of the data model, as described in
          <bibref ref="xslt-xquery-serialization-30"/>, followed by </p></item><item><p>validation of the serialized value into a
          Post-Schema Validated Infoset, as described in
          <bibref ref="xmlschema-1"/>, followed by</p></item><item><p>construction of a new data model value, as
          described in <bibref ref="xpath-datamodel-30"/>.</p></item></ulist>

        Erasure is the formal equivalent of serialization followed by
        construction of a new data model value in which all element
        nodes are labeled with <a href="#dt-xs_untyped"><code>xs:untyped</code></a> and all attribute nodes
        with <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>.</p><p>The judgment</p><display>
          <clause><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_erases_to" class="judgment"><term>erases to</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression></clause>
        </display><p>holds when the erasure of <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> is <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>.</p></smnotation><smrules><p>This judgment is specified by the following rules.</p><p>The empty sequence erases to itself.</p><infergr><infer><prejudge/><postjudge><clause><expression>() <a href="#jd_erases_to" class="judgment"><term>erases to</term></a> ()</expression></clause></postjudge></infer></infergr><p>The erasure of the concatenation of two values is the
        concatenation of their erasure, so long as neither of the two
        original values is simple.</p><infergr><infer><prejudge><multiclause><clause><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_erases_to" class="judgment"><term>erases to</term></a>
              <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>'</expression></clause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> not a simple value</expression></clause></multiclause><multiclause><clause><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> <a href="#jd_erases_to" class="judgment"><term>erases to</term></a>
              <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>'</expression></clause><clause><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> not a simple value</expression></clause></multiclause></prejudge><postjudge><clause><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> <a href="#jd_erases_to" class="judgment"><term>erases to</term></a>
             <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>',<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>'</expression></clause></postjudge></infer></infergr><p>The erasure of an element is an element that has the same
        name and the type <a href="#dt-xs_untyped"><code>xs:untyped</code></a> and the erasure of the original
        content.</p><infergr><infer><prejudge><multiclause><clause><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_erases_to" class="judgment"><term>erases to</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression></clause></multiclause></prejudge><postjudge><clause><expression>element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> of type
             <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> { <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> } <a href="#jd_erases_to" class="judgment"><term>erases to</term></a> element
             <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> of type <a href="#dt-xs_untyped"><code>xs:untyped</code></a> { <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>
             }</expression></clause></postjudge></infer></infergr><p>The erasure of an attribute is an attribute that has the
        same name and the type <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> and the simple erasure
        of the original content labeled with <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>.</p><infergr><infer><prejudge><multiclause><clause><expression><a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a> <a href="#jd_simply_erases_to" class="judgment"><term>simply erases to</term></a>
              <emph>String</emph></expression></clause></multiclause></prejudge><postjudge><clause><expression>attribute <a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a> of type
             <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> { <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a> } <a href="#jd_erases_to" class="judgment"><term>erases to</term></a> attribute
             <a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a> of type <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> { <emph>String</emph>
             of type <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> }</expression></clause></postjudge></infer></infergr><p>The erasure of a document is a document with the erasure of
        the original content.</p><infergr><infer><prejudge><multiclause><clause><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_erases_to" class="judgment"><term>erases to</term></a>
              <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression></clause></multiclause></prejudge><postjudge><clause><expression>document { <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> } <a href="#jd_erases_to" class="judgment"><term>erases to</term></a>
             document { <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> }</expression></clause></postjudge></infer></infergr><p>The erasure of a text or comment or processing-instruction node is itself.</p><infergr><infer><prejudge/><postjudge><clause><expression>text
             { <emph>String</emph> } <a href="#jd_erases_to" class="judgment"><term>erases to</term></a> text { <emph>String</emph>
             }</expression></clause></postjudge></infer></infergr><infergr><infer><prejudge/><postjudge><clause><expression>comment
             { <emph>String</emph> } <a href="#jd_erases_to" class="judgment"><term>erases to</term></a> comment { <emph>String</emph>
             }</expression></clause></postjudge></infer></infergr><infergr><infer><prejudge/><postjudge><clause><expression>processing-instruction <emph>NCName</emph>
             { <emph>String</emph> } <a href="#jd_erases_to" class="judgment"><term>erases to</term></a> processing-instruction <emph>NCName</emph> { <emph>String</emph>
             }</expression></clause></postjudge></infer></infergr><p>The erasure of a simple value is the corresponding text
        node.</p><infergr><infer><prejudge><multiclause><clause><expression><a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a> <a href="#jd_simply_erases_to" class="judgment"><term>simply erases to</term></a>
              <emph>String</emph></expression></clause></multiclause></prejudge><postjudge><clause><expression><a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a> <a href="#jd_erases_to" class="judgment"><term>erases to</term></a> text {
             <emph>String</emph> }</expression></clause></postjudge></infer></infergr></smrules></div4></div3><div3 id="sec_jd_annotate"><head>Annotate</head><p>The <a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> judgment is used in the definition of the dynamic
semantics of validation. 
The normative dynamic semantics of validation is specified in 
<xspecref spec="XQ" ref="id-validate"/>.
The effect of the validate expression is equivalent to:
<ulist><item><p>serialization of the data model, as described in
<bibref ref="xslt-xquery-serialization-30"/>, followed by</p></item><item><p>parsing of the serialized value into the Infoset</p></item><item><p>validation of the Infoset into a Post-Schema
Validated Infoset, as described in <bibref ref="xmlschema-1"/>, followed by</p></item><item><p>construction of a new data model value, as described in
<bibref ref="xpath-datamodel-30"/>.</p></item></ulist>
Annotation is the formal equivalent of schema validation of an Infoset
value into the PSVI followed by construction of a new data model
value.   Because the Formal Semantics is defined on data model values,
not the Infoset, annotation is applied to data model values in which
all element nodes are labeled with <a href="#dt-xs_untyped"><code>xs:untyped</code></a> and all attribute
nodes with <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> -- that is, the result of erasure. 
</p><div4 id="sec_simply_annotate"><head>Simply annotate</head><smnotation><p id="jd_cast_as">The judgment</p><display>
          <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_cast_as" class="judgment"><term>simply annotate as</term></a> <emph>SimpleType</emph> ( <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a>
            ) <a href="#jd_cast_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript></expression></clause>
          </display><p>holds if the result of casting the <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>1</subscript> to
          <emph>SimpleType</emph> is <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript>.</p></smnotation><smrules><p>This judgment is specified by the following rules.</p><p>Simply annotating a simple value to a union type yields the
          result of simply annotating the simple value to either the
          first or second type in the union. Note that simply annotating
          to the second type is attempted only if simply annotating to
          the first type <emph>fails</emph>.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_cast_as" class="judgment"><term>simply annotate as</term></a> <emph>SimpleType</emph><subscript>1</subscript>
                (<a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>1</subscript>) <a href="#jd_cast_as" class="judgment"><term>=&gt;</term></a>
                <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_cast_as" class="judgment"><term>simply annotate as</term></a>
               <emph>SimpleType</emph><subscript>1</subscript>|<emph>SimpleType</emph><subscript>2</subscript> (<a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>1</subscript>)
               <a href="#jd_cast_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript></expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_not" class="judgment"><term>not</term></a>(<a href="#jd_cast_as" class="judgment"><term>simply annotate as</term></a> <emph>SimpleType</emph><subscript>1</subscript>
                (<a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>1</subscript>) <a href="#jd_cast_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript>)</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_cast_as" class="judgment"><term>simply annotate as</term></a> <emph>SimpleType</emph><subscript>2</subscript>
                (<a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>1</subscript>) <a href="#jd_cast_as" class="judgment"><term>=&gt;</term></a>
                <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_cast_as" class="judgment"><term>simply annotate as</term></a>
               <emph>SimpleType</emph><subscript>1</subscript>|<emph>SimpleType</emph><subscript>2</subscript> (<a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>1</subscript>)
               <a href="#jd_cast_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript></expression></clause></postjudge></infer></infergr><p>The simple annotation rules for ?, +, * are similar.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_cast_as" class="judgment"><term>simply annotate as</term></a> <emph>SimpleType</emph>? ( () )
               <a href="#jd_cast_as" class="judgment"><term>=&gt;</term></a> ()</expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_cast_as" class="judgment"><term>simply annotate as</term></a> <emph>SimpleType</emph>
                (<a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>1</subscript>) <a href="#jd_cast_as" class="judgment"><term>=&gt;</term></a>
                <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_cast_as" class="judgment"><term>simply annotate as</term></a> <emph>SimpleType</emph>?
               (<a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>1</subscript>) <a href="#jd_cast_as" class="judgment"><term>=&gt;</term></a>
               <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript></expression></clause></postjudge></infer></infergr><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_cast_as" class="judgment"><term>simply annotate as</term></a> <emph>SimpleType</emph>* ( () )
               <a href="#jd_cast_as" class="judgment"><term>=&gt;</term></a> ()</expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_cast_as" class="judgment"><term>simply annotate as</term></a> <emph>SimpleType</emph>
                (<a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>1</subscript>) <a href="#jd_cast_as" class="judgment"><term>=&gt;</term></a>
                <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>1</subscript>'</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_cast_as" class="judgment"><term>simply annotate as</term></a> <emph>SimpleType</emph>*
                (<a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript>) <a href="#jd_cast_as" class="judgment"><term>=&gt;</term></a>
                <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript>'</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_cast_as" class="judgment"><term>simply annotate as</term></a> <emph>SimpleType</emph>*
               (<a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>1</subscript>,<a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript>) <a href="#jd_cast_as" class="judgment"><term>=&gt;</term></a>
               <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>1</subscript>',<a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript>'</expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_cast_as" class="judgment"><term>simply annotate as</term></a> <emph>SimpleType</emph>
                (<a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>1</subscript>) <a href="#jd_cast_as" class="judgment"><term>=&gt;</term></a>
                <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>1</subscript>'</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_cast_as" class="judgment"><term>simply annotate as</term></a> <emph>SimpleType</emph>*
                (<a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript>) <a href="#jd_cast_as" class="judgment"><term>=&gt;</term></a>
                <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript>'</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_cast_as" class="judgment"><term>simply annotate as</term></a> <emph>SimpleType</emph>+
               (<a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>1</subscript>,<a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript>) <a href="#jd_cast_as" class="judgment"><term>=&gt;</term></a>
               <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>1</subscript>',<a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript>'</expression></clause></postjudge></infer></infergr><p>Simply annotating an atomic value to <code>xs:string</code> yields its
          string representation.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_cast_as" class="judgment"><term>simply annotate as</term></a> <code>xs:string</code> (<a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a>)
               <a href="#jd_cast_as" class="judgment"><term>=&gt;</term></a>
               <emph>dm:</emph>string-value(<a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a>)</expression></clause></postjudge></infer></infergr><p>Simply annotating an atomic value to <code>xs:decimal</code> yields
          the decimal that results from parsing its string
          representation.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_cast_as" class="judgment"><term>simply annotate as</term></a> <code>xs:decimal</code> (<a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a>)
               <a href="#jd_cast_as" class="judgment"><term>=&gt;</term></a>
               <code>xs:decimal</code>(<emph>dm:</emph><code>string-value</code>(<a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a>))</expression></clause></postjudge></infer></infergr><p>Similar rules are assumed for the rest of the 19 XML Schema
          primitive types.</p></smrules></div4><div4 id="sec_nil_annotate"><head>Nil-annotate</head><smnotation><p id="jd_nil_annotate_as">The judgment</p><display>
          <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_nil_annotate_as" class="judgment"><term>nil-annotate as</term></a> <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a> <a href="#doc-fs-Type"><emph>Type</emph></a> (
          <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> ) <a href="#jd_nil_annotate_as" class="judgment"><term>=&gt;</term></a>
          <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression></clause>
        </display><p>holds if it is possible to annotate value <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> as if
        it had the nillable type <a href="#doc-fs-Type"><emph>Type</emph></a> and <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> is the
        corresponding annotated value.</p></smnotation><smrules><p>This judgment is specified by the following rules.</p><p>If the type is not nillable, then the xsi:nil attribute
        must not appear in the value, and it must be possible to
        annotate value <a href="#doc-fs-Value"><emph>Value</emph></a> as if it had the type <a href="#doc-fs-Type"><emph>Type</emph></a>.</p><infergr><infer><prejudge><multiclause><clause><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_filter" class="judgment"><term>filter</term></a> @xsi:nil
              <a href="#jd_filter" class="judgment"><term>=&gt;</term></a> <a href="#jd_filter" class="judgment"><term>absent</term></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a> ( <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> )
              <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_nil_annotate_as" class="judgment"><term>nil-annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a> ( <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> )
             <a href="#jd_nil_annotate_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression></clause></postjudge></infer></infergr><p>If the type is nillable, and the xsi:nil attribute does not
        appear or is false, then it must be possible to annotate value
        <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> as if it had the type <a href="#doc-fs-Type"><emph>Type</emph></a>.</p><infergr><infer><prejudge><multiclause><clause><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_filter" class="judgment"><term>filter</term></a> @xsi:nil
              <a href="#jd_filter" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a></expression></clause></multiclause><multiclause><clause><expression><a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a> <a href="#jd_isin" class="judgment"><term>in</term></a> { (), false }</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a> ( <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> )
              <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_nil_annotate_as" class="judgment"><term>nil-annotate as</term></a> nillable <a href="#doc-fs-Type"><emph>Type</emph></a> (
             <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> ) <a href="#jd_nil_annotate_as" class="judgment"><term>=&gt;</term></a>
             <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression></clause></postjudge></infer></infergr><p>If the type is nillable, and the xsi:nil attribute is true,
        then it must be possible to annotate value <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> as if
        it had a type where the attributes in the type are kept and
        the element content of the type is ignored.</p><infergr><infer><prejudge><multiclause><clause><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_filter" class="judgment"><term>filter</term></a> @xsi:nil
              <a href="#jd_filter" class="judgment"><term>=&gt;</term></a> true</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-AttributeModel"><emph>AttributeModel</emph></a> (
              <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> ) <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a>
              <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_nil_annotate_as" class="judgment"><term>nil-annotate as</term></a> nillable
             (<a href="#doc-fs-AttributeModel"><emph>AttributeModel</emph></a>, <a href="#doc-fs-ElementModel"><emph>ElementModel</emph></a>) ( <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> )
             <a href="#jd_nil_annotate_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression></clause></postjudge></infer></infergr></smrules></div4><div4 id="sec_annotate"><head>Annotate</head><p id="jd_annotate_as">
The <a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> judgment is used in the definition of the dynamic
semantics of validation. 
The normative dynamic semantics of validation is specified in 
<xspecref spec="XQ" ref="id-validate"/>.
The effect of the validate expression is equivalent to:
<ulist><item><p>serialization of the data model, as described in
<bibref ref="xslt-xquery-serialization-30"/>, followed by</p></item><item><p>parsing of the serialized value into the Infoset</p></item><item><p>validation of the Infoset into a Post-Schema
Validated Infoset, as described in <bibref ref="xmlschema-1"/>, followed by</p></item><item><p>construction of a new data model value, as described in
<bibref ref="xpath-datamodel-30"/>.</p></item></ulist>
Erasure is the formal equivalent of serialization followed by
construction of a new data model value in which all element nodes are labeled with <a href="#dt-xs_untyped"><code>xs:untyped</code></a> and all attribute nodes with <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>.
</p><smnotation><p>The judgment</p><display>
          <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a> ( <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> )
          <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression></clause>
        </display><p>holds if it is possible to annotate value <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> as if
        it had type <a href="#doc-fs-Type"><emph>Type</emph></a> and <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> is the corresponding
        annotated value.</p></smnotation><smnote><p>Assume an XML Infoset instance X1 is validated against an
        XML Schema S, yielding PSVI instance X2. Then if X1
        corresponds to <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> and S corresponds to <a href="#doc-fs-Type"><emph>Type</emph></a> and
        X2 corresponds to <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>, the following should hold:
        <a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a> ( <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> )
        <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>.</p></smnote><smrules><p>This judgment is specified by the following rules.</p><p>Annotating the empty sequence as the empty type yields the
        empty sequence.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> empty (())
             <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> ()</expression></clause></postjudge></infer></infergr><p>Annotating a concatenation of values as a concatenation of
        types yields the concatenation of the annotated values.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>)
              <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>'</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>)
              <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>'</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
             (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>) <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a>
             <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>',<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>'</expression></clause></postjudge></infer></infergr><p>Annotating a value as a choice type yields the result of
        annotating the value as either the first or second type in the
        choice.</p><infergr><infer><prejudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>)
              <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>|<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
             (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>) <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a>
             <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>)
              <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>|<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
             (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>) <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a>
             <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression></clause></postjudge></infer></infergr><p>Annotating a value as an all group uses interleaving to
        decompose the original value and recompose the annotated
        value.</p><ednote><edtext>Jerome and Phil: Note that this may reorder the
          original sequence.  Perhaps we should disallow such
          reordering. Specifying that formally is not as easy as we
          would like.</edtext></ednote><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> ( <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> )
              <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>'</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> ( <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> )
              <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>'</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_interleave" class="judgment"><term>interleave</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>
              <a href="#jd_interleave" class="judgment"><term>yields</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>' <a href="#jd_interleave" class="judgment"><term>interleave</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>'
              <a href="#jd_interleave" class="judgment"><term>yields</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>'</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> &amp; <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
             ( <a href="#doc-fs-Value"><emph>Value</emph></a> ) <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a>
             <a href="#doc-fs-Value"><emph>Value</emph></a>'</expression></clause></postjudge></infer></infergr><p>The annotation rules for ?, +, * are similar.</p><infergr><infer><prejudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> (<a href="#doc-fs-Type"><emph>Type</emph></a> |
              empty)(<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>) <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a>
              <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>? (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>)
             <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a> (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>)
              <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>'</expression></clause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>* (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>)
              <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>'</expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>+
             (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>) <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a>
             (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>',<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>')</expression></clause></postjudge></infer></infergr><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>* ( () )
             <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> ()</expression></clause></postjudge></infer></infergr><infergr><infer><prejudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a> (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>)
              <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>'</expression></clause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>* (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>)
              <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>'</expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>*
             (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>) <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a>
             (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>',<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>')</expression></clause></postjudge></infer></infergr><p>To annotate an element with no xsi:type attribute, first
        look up the element type, next resolve the resulting type
        reference, then annotate the value against the resolved type,
        and finally return a new element with the name of the original
        element, the resolved type name, and the annotated value.</p><infergr><infer><prejudge><multiclause><clause><expression><a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_filter" class="judgment"><term>filter</term></a> @xsi:type
              <a href="#jd_filter" class="judgment"><term>=&gt;</term></a> ()</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#jd_lookup" class="judgment"><term>name lookup</term></a>
              <a href="#doc-fs-ElementType"><emph>ElementType</emph></a> <a href="#jd_lookup" class="judgment"><term>yields</term></a> <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a>
              <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a> <a href="#jd_resolves_to" class="judgment"><term>resolves to</term></a>
              <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> { <a href="#doc-fs-Type"><emph>Type</emph></a> }</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_nil_annotate_as" class="judgment"><term>nil-annotate as</term></a>
              <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a> <a href="#doc-fs-Type"><emph>Type</emph></a> (<a href="#doc-fs-Value"><emph>Value</emph></a>) <a href="#jd_nil_annotate_as" class="judgment"><term>=&gt;</term></a>
              <a href="#doc-fs-Value"><emph>Value</emph></a>'</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-ElementType"><emph>ElementType</emph></a> ( element
             <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> of type <code>xs:anyType</code> { <a href="#doc-fs-Value"><emph>Value</emph></a> } )
             <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> of type
             <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> { <a href="#doc-fs-Value"><emph>Value</emph></a>' }</expression></clause></postjudge></infer></infergr><p>To annotate an element with an xsi:type attribute, define a
        type reference corresponding to the xsi:type.  Look up the
        element type, yielding a type reference, and check that the
        xsi:type reference derives from this type reference.  Resolve
        the xsi:type reference, then annotate the value against the
        resolved type, and finally return a new element with the name
        of the original element, the resolved type name, and the
        annotated value.</p><infergr><infer><prejudge><multiclause><clause><expression><a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_filter" class="judgment"><term>filter</term></a> @xsi:type
              <a href="#jd_filter" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-TypeName"><emph>TypeName</emph></a></expression></clause></multiclause><multiclause><clause><expression><emph>Xsi</emph><a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a> = of type
              <a href="#doc-fs-TypeName"><emph>TypeName</emph></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#jd_lookup" class="judgment"><term>name lookup</term></a>
              <a href="#doc-fs-ElementType"><emph>ElementType</emph></a> <a href="#jd_lookup" class="judgment"><term>yields</term></a> <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a>
              of type <a href="#doc-fs-TypeName"><emph>BaseTypeName</emph></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-TypeName"><emph>TypeName</emph></a>
              <a href="#jd_derives_from" class="judgment"><term>derives from</term></a>
              <a href="#doc-fs-TypeName"><emph>BaseTypeName</emph></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><emph>Xsi</emph><a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a> <a href="#jd_resolves_to" class="judgment"><term>resolves to</term></a>
              <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> { <a href="#doc-fs-Type"><emph>Type</emph></a> }</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_nil_annotate_as" class="judgment"><term>nil-annotate as</term></a>
              <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a> <a href="#doc-fs-Type"><emph>Type</emph></a> (<a href="#doc-fs-Value"><emph>Value</emph></a>) <a href="#jd_nil_annotate_as" class="judgment"><term>=&gt;</term></a>
              <a href="#doc-fs-Value"><emph>Value</emph></a>'</expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-ElementType"><emph>ElementType</emph></a> ( element
             <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> of type <code>xs:anyType</code> { <a href="#doc-fs-Value"><emph>Value</emph></a> } )
             <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> of type
             <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> { <a href="#doc-fs-Value"><emph>Value</emph></a>' }</expression></clause></postjudge></infer></infergr><!--
        <ednote>
          <edtext>Issue: the treatment of xsi:type in the
          &xq_xquerydoc; document and in the formal semantics document
          still differ. See Issue 485 (FS-Issue-0142).</edtext>
        </ednote>
--><p>The rule for attributes is similar to the first rule for
        elements.</p><infergr><infer><prejudge><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a> <a href="#jd_attribute_lookup" class="judgment"><term>name lookup</term></a>
              <a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a> <a href="#jd_attribute_lookup" class="judgment"><term>yields</term></a>
              <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a> <a href="#jd_resolves_to" class="judgment"><term>resolves to</term></a>
              <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> { <a href="#doc-fs-Type"><emph>Type</emph></a> }</expression></clause></multiclause><multiclause><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_nil_annotate_as" class="judgment"><term>nil-annotate as</term></a>
              <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a> <a href="#doc-fs-Type"><emph>Type</emph></a> (<a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>1</subscript>) <a href="#jd_nil_annotate_as" class="judgment"><term>=&gt;</term></a>
              <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript></expression></clause></multiclause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a> (
             attribute <a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a> of type <code>xs:anySimpleType</code> {
             <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>1</subscript> } ) <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> attribute
             <a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a> of type <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> { <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript>
             }</expression></clause></postjudge></infer></infergr><p>Annotating a document node yields a document with the
        annotation of its contents.</p><infergr><infer><prejudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a> (<a href="#doc-fs-Value"><emph>Value</emph></a>)
              <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>'</expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> document { <a href="#doc-fs-Type"><emph>Type</emph></a> } (
             document { <a href="#doc-fs-Value"><emph>Value</emph></a> } ) <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> document
             { <a href="#doc-fs-Value"><emph>Value</emph></a>' }</expression></clause></postjudge></infer></infergr><p>Annotating a text node as text yields itself.</p><infergr><infer><prejudge/><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> text (text { <emph>String</emph> })
             <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> text { <emph>String</emph> }</expression></clause></postjudge></infer></infergr><p>Annotating a text nodes as a simple type is identical to
        casting.</p><infergr><infer><prejudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_cast_as" class="judgment"><term>simply annotate as</term></a> <emph>SimpleType</emph> ( <emph>String</emph> ) <a href="#jd_cast_as" class="judgment"><term>=&gt;</term></a>
              <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a>'</expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <emph>SimpleType</emph> ( text {
             <emph>String</emph> } ) <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a>
             <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a>'</expression></clause></postjudge></infer></infergr><p>Annotating a simple value as a simple type is identical to
        casting.</p><infergr><infer><prejudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_cast_as" class="judgment"><term>simply annotate as</term></a> <emph>SimpleType</emph> (
              <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a> ) <a href="#jd_cast_as" class="judgment"><term>=&gt;</term></a>
              <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a>'</expression></clause></prejudge><postjudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <emph>SimpleType</emph> (
             <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a> ) <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a>
             <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a>'</expression></clause></postjudge></infer></infergr></smrules></div4></div3></div2></inform-div1><inform-div1 id="id-fs-revisions-log"><head>Revision Log</head><!--*

  <p>This log records the changes that have been made to this document
  since the Working Draft of September 3 June 2005 Last Call Working Draft.</p>

  <div2 id="sec_changes_09152005">
    <head>15 September 2005</head>

    <olist>
      <item><p>Completely removed the formal specification of error
      propagation, and which kind of dynamic errors are
      raised.</p></item>
      <item><p>Fixed static typing rules for fn:subsequence</p></item>
      <item><p>Numerous fixes to static typing rules for function
      calls, including overloaded functions in Appendix B.2.</p></item>
      <item><p>Fixed bugs in auxiliary functions dealing with type
      promotion and atomization in the semantics of function
      calls.</p></item>
      <item><p>Fixed handling of namespace "unbinding" under the
      namespaces rules for XML 1.1.</p></item>
      <item><p>Fixed dynamic evaluation rules for literals.</p></item>
      <item><p>Fixed static typing rules for document constructors.</p></item>
      <item><p>Fixed a bug in the rule implementing the 'union
      interpretation' for derivation by extension.</p></item>
      <item><p>Fixed bugs in the rules for module import, now dealing
      with multiple modules with the same namespace properly.</p></item>
      <item><p>Fixed terminology for some aspects of the type system,
      and added clarification pointers in a number of
      places.</p></item>
      <item><p>Fixed numerous bugs and typos, as a result of
      processing last call comments.</p></item>
      <item><p>A few minor fixes to the core grammar (e.g.,
      Constructor production was missing).</p></item>
    </olist>
  </div2>

  <div2 id="sec_changes_11032005">
    <head>03 November 2005 (CR Draft)</head>

    <olist>
      <item><p>Numerous improvements and clarifications in the
      preliminary section which introduces the formal semantics
      notations.</p></item>
      <item><p>Complete refactoring of the formal semantics of
      function calls.</p></item>
      <item><p>Always provide the normalization rule even for the
      trivial cases.</p></item>
      <item><p>Default values in formal notations are only used in
      examples, not in inference rules anymore.</p></item>
      <item><p>Removed the use of the confusing notation
      <emph>NonTerminal</emph>?  in inference rules.</p></item>
      <item><p>Fixes to the formal semantics of
      constructors.</p></item>
      <item><p>Fixes to the semantics of global variables and function
      declarations.</p></item>
      <item><p>Fixed numerous bugs and typos, as a result of
      processing last call comments.</p></item>
      <item><p>Grammar productions now have a marker indicating when
      they correspond to the XQuery or the XPath grammar.</p></item>
    </olist>
  </div2>

  <div2 id="sec_changes_06092006">
    <head>09 June 2006</head>

    <olist>
      <item><p>Replaced the xdt: namespace with the xs: namespace
      throughout the specification.</p></item>
      <item><p>Fixed a bug with precedence in the normalization of
      path expressions.</p></item>
      <item><p>Fixed a bug in the normalization of
      fs:eq().</p></item>
      <item><p>Added some clarifications in the section on Notations,
      notably for judgments using ellipses, and the definition of
      formal atomic values.</p></item>
      <item><p>Removed unused productions from the XQuery Core
      (Module, MainModule, LibraryModule, Prolog, Setter, Import,
      VersionDecl).</p></item>
      <item><p>Fixed inappropriate use of QNames in inference rules
      where an expanded-QName is expected (notably when handling
      variables and function signatures in the static
      context).</p></item>
      <item><p>Simplified the normalization of FLWOR expressions.</p></item>
      <item><p>An index of the judgments used in this specification
      has been added in <specref ref="sec_indexes"/>.</p></item>
      <item><p>Fixed numerous bugs and typos, as a result of
      processing the remaining last call comments.</p></item>
    </olist>
  </div2>

  <div2 id="sec_changes_21112006">
    <head>21 November 2006</head>

    <olist>
      <item><p>Fixed module import processing to break issues with
      circularity. This change closes Bugzilla entry 1705.</p></item>
      <item><p>Simplfied and aligned the type promotion rules with the
      XQuery 1.0 specification. This change closes Bugzilla entries
      2671 and 3664.</p></item>
      <item><p>Fixed confusing precedence in the normalization rules
      for StepExpr. This change closes Bugzilla entry 2720.</p></item>
      <item><p>Fixed inconsistencies in the operator's mapping
      table. This change closes Bugzilla entries 3652 and
      3670.</p></item>
      <item><p>Added missing handling of &xs_anyURI; type in static
      typing rules for &fn_boolean;. This change closes Bugzilla entry
      3667.</p></item>
      <item><p>Added missing handling of + occurrence indicator in
      static typing rules for &fn_subsequence;. This change closes
      Bugzilla entry 3676.</p></item>
      <item><p>Simplified static typing rules for constructors,
      providing a more uniform treatment. This change closes Bugzilla
      entry 3758.</p></item>
      <item><p>Removed duplicate call to &fs_item_seq_to_node_seq; in
      the semantics of constructors. This change closes Bugzilla entry
      3760.</p></item>
      <item><p>Loosened static typing of constructors to not raise
      errors when constructing attributes in enclosed
      expressions. This change closes Bugzilla entry 3771.</p></item>
      <item><p>Fixed bug in static typing of function declarations,
      not dealing with type promotion rules and atomization for the
      return type. This change closes Bugzilla entry 3841.</p></item>
      <item><p>Fixed numerous editorial problems throughout the
      document.</p></item>
    </olist>
  </div2>
*--><p>This appendix lists the changes that have been made to this specification
         since the publication of the Proposed Recommendation Draft on 21 November 2006. </p><!--*
  <div2 id="sec_changes_23012007">
    <head>23 January 2007</head>
*--><olist><item><p>Fixed a number of typos and editorial issues throughout the
      document.</p></item></olist><!--*   </div2> *--></inform-div1></back></spec><!--
Local Variables:
indent-tabs-mode:nil
End:
-->

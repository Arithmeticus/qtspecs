<!-- *************************** &language; Semantics            **************** -->

<div1 id="id-basics">
  <head>Basics</head>

  <p>The organization of this section parallels the organization of
  <xspecref spec="XQ" ref="id-basics"/>.</p>

  <div2 id="sec_context">
    <head>Expression Context</head>

    <smintro>
      <p>The expression context for a given expression consists of all
      the information that can affect the result of the
      expression. This information is organized into the <emph>static
      context</emph> and the <emph>dynamic context</emph>.  This
      section specifies the environments that represent the context
      information used by &language; expressions.</p>
    </smintro>

    <div3 id="static_context">
      <head>Static Context</head>

      <smnotation>
        <p>We introduce the following auxiliary grammar production to
        describe function signatures.</p>

      <scrap diff='chg' at='E009'>
        <head/>
        <prodrecap id="FunctionSig" ref="FunctionSig" orig="formal"/>
        <prodrecap id="TypeList"    ref="TypeList"    orig="formal"/>
      </scrap>

        <p diff='add' at='E006'>
          In the static (and dynamic) context,
          each function is uniquely identified by
          its expanded QName and its arity (number of parameters).
          We introduce the auxilliary symbol &gr_FunctionKey; to
          encapsulate this combination.
        </p>

        <scrap diff='add' at='E006'>
          <head/>
          <prodrecap id="FunctionKey" ref="FunctionKey" orig="formal"/>
        </scrap>

        <p diff='add' at='E006'>(<emph>Arity</emph> is understood to be a non-negative integer.)</p>
      </smnotation>

      <p id="xq_stat_env">&xq_stat_env; denotes the environment
      available during static analysis.  Static analysis may extend
      parts of the static environment. The static environment is also
      available during dynamic evaluation.</p>

      <p>If analysis of an expression relies on some component of the
      static context that has not been assigned a value, a static
      error is raised.</p>

      <p id="xq_stat_env_def">The following environment components are
      part of the static environment:</p>
  
      <table summary="" role="figure" cellpadding="5">
      <col width="10%"/><!-- empty column forces left indentation -->
      <col width="15%"/>
      <col width="65%" align="justify"/>
      <col width="10%"/><!-- empty column forces right indentation -->
      <tbody>
      <tr><td/>
          <td id="xq_xpath_compat_flag" valign="top">&xq_xpath_compat_flag;</td>
          <td>
             <table summary="">
             <tbody>
               <tr><td>The &xq_xpath_compat_flag; environment
               component designates the <term>XPath 1.0 compatibility
               flag</term> in the &language; static context. It
               specifies whether the semantic rules for backward
               compatibility with XPath 1.0 are in effect. This
               document defines the formal semantics for XPath 2.0
               only when the XPath 1.0 backward compatibility rules
               are not in effect.</td></tr>
             </tbody>
             </table>
          </td>
          <td/>
      </tr>
      <tr><td/>
          <td id="xq_ns_env" valign="top">&xq_ns_env;</td>
          <td>
            <table summary="" id="term_active">
              <tbody>
                <tr><td>The &xq_ns_env; environment component
                designates the <term>statically known
                namespaces</term> in the &language; static
                context.</td></tr>

                <tr><td>The &xq_ns_env; environment component maps a
                namespace prefix (&gr_NCName;) onto a <term>namespace
                kind</term> and a namespace URI (&gr_URI;), the null
                namespace (#NULL-NAMESPACE), or (#UNDECLARED). The
                namespace kind is either <term>passive</term> or
                <term>active</term>.  The namespace kind determines
                whether a namespace node is created for an element
                during element construction. The (#UNDECLARED) value
                may be used to indicate that the prefix has been
                undeclared, and may occur only if the implementation
                supports <bibref ref="XMLNAMES11"/>.</td></tr>
              </tbody>
            </table>
          </td>
          <td/>
      </tr>
      <tr><td/>
          <td id="xq_default_elem_ns_env" valign="top">&xq_default_elem_ns_env;</td>
          <td>
            <table summary="">
              <tbody>
                <tr><td>The &xq_default_elem_ns_env; environment
                component designates the <term>default element/type
                namespace</term> in the &language; static
                context.</td></tr>

                <tr><td>The &xq_default_elem_ns_env; environment
                component contains a namespace URI (a &gr_URI;) or the
                null namespace (#NULL-NAMESPACE) and is used for any
                unprefixed QName appearing in a position where an
                element or type name is expected.</td></tr>
  
              </tbody>
            </table>
          </td>
          <td/>
      </tr>

      <tr><td/>
          <td id="xq_default_fn_ns_env" valign="top">&xq_default_fn_ns_env;</td>
          <td>
            <table summary="">
              <tbody>
                <tr><td>The &xq_default_fn_ns_env; environment
                component designates the <term>default function
                namespace</term> in the &language; static
                context.</td></tr>

                <tr><td>The &xq_default_fn_ns_env; environment
                component contains a namespace URI (a &gr_URI;) or the
                null namespace (#NULL-NAMESPACE) and is used for any
                unprefixed QName appearing as the function name in a
                function call.</td></tr>
              </tbody>
            </table>
          </td>
          <td/>
      </tr>
      <tr><td/>
          <td id="xq_type_defn" valign="top">&xq_type_defn;</td>
          <td>
            <table summary="">
              <tbody>
                <tr><td>The &xq_type_defn; environment component
                designates the <term>in-scope schema types</term> in
                the &language; static context.</td></tr>

                <tr><td>The &xq_type_defn; environment component maps
                expanded type names (expanded &gr_TypeName;s) onto
                their type definition (&gr_Definition;).  A type name
                may be globally declared or anonymous.</td></tr>
             </tbody>
           </table>
          </td>
          <td/>
      </tr>
      <tr><td/>
          <td id="xq_elem_decl" valign="top">&xq_elem_decl;</td>
          <td>
            <table summary="">
              <tbody>
                <tr><td>The &xq_elem_decl; environment component
                designates the <term>in-scope element
                declarations</term> in the &language; static
                context.</td></tr>

                <tr><td>The &xq_elem_decl; environment component maps
                expanded element names (expanded &gr_ElementName;s)
                onto their declaration (&gr_Definition;).</td></tr>
              </tbody>
            </table>
          </td>
          <td/>
      </tr>
      <tr><td/>
          <td id="xq_attr_decl" valign="top">&xq_attr_decl;</td>
          <td>
            <table summary="">
              <tbody>
                <tr><td>The &xq_attr_decl; environment component
                designates the <term>in-scope attribute
                declarations</term> in the &language; static
                context.</td></tr>

                <tr><td>The &xq_attr_decl; environment component maps
                expanded attribute names (expanded
                &gr_AttributeName;s) onto their declaration
                (&gr_Definition;).</td></tr>
  
              </tbody>
            </table>
          </td>
          <td/>
      </tr>
      <tr><td/>
          <td id="xq_type_env" valign="top">&xq_type_env;</td>
          <td>
            <table summary="">
              <tbody>
                <tr><td>The &xq_type_env; environment component
                designates the <term>in-scope variables</term> in
                the &language; static context.</td></tr>

                <tr><td>The &xq_type_env; environment component maps
                expanded variable names (expanded &gr_VarName;) to
                their static type (&gr_Type;).</td></tr>

                <tr><td>The <term>context item static type</term> in
                the &language; static context is represented by the
                binding of the variable &fs_dot; to its corresponding
                type in &xq_type_env;.</td></tr>
              </tbody>
            </table>
          </td>
          <td/>
      </tr>

      <tr><td/>
          <td id="xq_functy_env" valign="top">&xq_functy_env;</td>
          <td>
            <table summary="">
              <tbody>

                <tr><td>The &xq_functy_env; environment component
                designates the <term>function signatures</term> in the
                &language; static context.</td></tr>

                <tr><td>The &xq_functy_env; environment component
                stores the static type signatures of
                functions. Because &language; allows multiple
                functions with the same name differing in the number
                of parameters, this environment component maps
                <phrase diff='chg' at='E006'>a &gr_FunctionKey; (an expanded &gr_QName; and arity)</phrase>
                to a function
                signature &gr_FunctionSig;.</td></tr>
              </tbody>
            </table>
          </td>
          <td/>
      </tr>

      <tr><td/>
          <td id="xq_collations_env" valign="top">&xq_collations_env;</td>
          <td>
            <table summary="">
              <tbody>
                <tr><td>The &xq_collations_env; environment component
                designates the <term>statically known
                collations</term> in the &language; static
                context.</td></tr> <tr><td>The &xq_collations_env;
                environment component maps a unique namespace URI (a
                &gr_URI;) to a pair of functions: the first function
                takes a set of strings and returns a sequence
                containing those strings in sorted order; and the
                second function takes two strings, returns true if
                they are considered equal, and false if not.</td></tr>
              </tbody>
            </table>
          </td>
          <td/>
      </tr>

      <tr><td/>
         <td id="xq_default_collation_env" valign="top">&xq_default_collation_env;</td>
          <td>
            <table summary="">
              <tbody>
                <tr><td>The &xq_default_collation_env; environment
                component designates the <term>default
                collation</term> in the &language; static
                context.</td></tr>

                <tr><td>The &xq_default_collation_env; environment
                component is a pair of functions as described in
                &xq_collations_env; above.</td></tr>
              </tbody>
            </table>
          </td>
          <td/>
      </tr>

      <tr><td/>
          <td id="xq_construction_mode_env" valign="top">&xq_construction_mode_env;</td>
          <td>
            <table summary="">
              <tbody>
                <tr><td>The &xq_construction_mode_env; environment
                component designates the <term>construction
                mode</term> in the &language; static
                context.</td></tr>

                <tr><td>The &xq_construction_mode_env; environment
                component is one of <term>preserve</term> or
                <term>strip</term>.  </td></tr>
  
              </tbody>
            </table>
          </td>
          <td/>
      </tr>

      <tr><td/>
          <td id="xq_ordering_mode_env" valign="top">&xq_ordering_mode_env;</td>
          <td>
            <table summary="">
              <tbody>
                <tr><td>The &xq_ordering_mode_env; environment
                component designates the <term>ordering mode</term> in
                the &language; static context.</td></tr>

                <tr><td>The &xq_ordering_mode_env; environment
                component is one of <term>ordered</term> or
                <term>unordered</term>.</td></tr>
  
              </tbody>
            </table>
          </td>
          <td/>
      </tr>

      <tr><td/>
          <td id="xq_default_empty_order" valign="top">&xq_default_empty_order;</td>
          <td>
            <table summary="">
              <tbody>
                <tr><td>The &xq_default_empty_order; environment
                component designates the <term>default order for empty
                sequences</term> in the &language; static
                context.</td></tr>

                <tr><td> The &xq_default_empty_order; environment
                component controls whether an empty sequence is
                interpreted as the greatest value or as the least
                value during processing of an <code>order by</code>
                clause in a FLWOR expression. Its value may be
                <code>greatest</code> or <code>least</code>.</td></tr>
              </tbody>
            </table>
          </td>
          <td/>
      </tr>

      <tr><td/>
          <td id="xq_boundary_space" valign="top">&xq_boundary_space;</td>
          <td>
            <table summary="">
              <tbody>
                <tr><td>The &xq_boundary_space; environment component
                designates the <term>boundary-space policy</term>
                in the &language; static context.</td></tr>

                <tr><td>The &xq_boundary_space; environment component
                controls the processing of boundary whitespace by
                element constructors. Its value may be
                <code>preserve</code> or <code>strip</code>.</td></tr>
            </tbody>
            </table>
          </td>
          <td/>
      </tr>

      <tr><td/>
          <td id="xq_copy_namespaces_mode" valign="top">&xq_copy_namespaces_mode;</td>
          <td>
            <table summary="">
              <tbody>
                <tr><td>The &xq_copy_namespaces_mode; environment
                component designates the <term>copy-namespaces
                mode</term> in the &language; static
                context.</td></tr>

                <tr><td>The &xq_copy_namespaces_mode; environment
                component controls the namespace bindings that are
                assigned when an existing element node is copied by an
                element constructor. Its value consists of two parts:
                <code>preserve</code> or <code>no-preserve</code>, and
                <code>inherit</code> or
                <code>no-inherit</code>.</td></tr>
            </tbody>
            </table>
          </td>
          <td/>
      </tr>

      <tr><td/>
          <td id="xq_base_uri_env" valign="top">&xq_base_uri_env;</td>
          <td>
            <table summary="">
              <tbody>
                <tr><td>The &xq_base_uri_env; environment component
                designates the <term>base URI</term> in the &language;
                static context.</td></tr>

                <tr><td>The &xq_base_uri_env; environment component
                contains a unique namespace URI (a
                &gr_URI;).</td></tr>
              </tbody>
            </table>
          </td>
          <td/>
      </tr>
      <tr><td/>
          <td id="xq_doc_type_env" valign="top">&xq_doc_type_env;</td>
          <td>
            <table summary="">
              <tbody>
                <tr><td>The &xq_doc_type_env; environment component
                designates the <term>statically known documents</term>
                in the &language; static context.  It contains the
                static type for the input documents, and is used to
                provide the static type to the &fn_doc;
                function.</td></tr>

                <tr><td>The &xq_doc_type_env; environment component
                contains bindings from input URIs (a &gr_URI;) to
                types (a &gr_Type;).</td></tr>
  
              </tbody>
            </table>
          </td>
          <td/>
      </tr>
      <tr><td/>
          <td id="xq_collection_type_env" valign="top">&xq_collection_type_env;</td>
          <td>
            <table summary="">
              <tbody>
                <tr><td>The &xq_collection_type_env; environment
                component designates the <term>statically known
                collections</term> in the &language; static context.
                It contains the static type for the input collections,
                and is used to provide the static type to the
                &fn_collection; function.</td></tr>

                <tr><td>The &xq_collection_type_env; environment
                component contains bindings from input URIs (a
                &gr_URI;) to types (a &gr_Type;).</td></tr>
  
              </tbody>
            </table>
          </td>
          <td/>
      </tr>
      <tr><td/>
          <td id="xq_default_collection_type_env" valign="top">&xq_default_collection_type_env;</td>
          <td>
            <table summary="">
              <tbody>
                <tr><td>The &xq_default_collection_type_env;
                environment component designates the <term>statically
                known default collection type</term> in the &language;
                static context. It contains the static type for the
                default collection, and is used to provide the static
                type to the &fn_collection; function when called with
                no arguments.</td></tr>

                <tr><td>The &xq_default_collection_type_env;
                environment component contains type (a
                &gr_Type;).</td></tr>
  
              </tbody>
            </table>
          </td>
          <td/>
      </tr>
      </tbody>
      </table>

      <p>Note that the boundary-space behavior is not formally
      specified in this document.</p>

      <p id="xq_default_stat_env">An initial environment is set up
      when &query-expr; processing begins, containing, for example,
      the function signatures of all built-in functions.  The initial
      values for the static context are defined in <xspecref spec="XQ"
      ref="id-xq-context-components"/> and <xspecref spec="XP"
      ref="id-xp-context-components"/> and is denoted by
      &xq_default_stat_env; in the Formal Semantics.</p>

      <p>Here is an example that shows how the static environment is
      modified in response to a namespace definition.</p>

      <infergr>
        <infer>
         <prejudge>
 	  <multiclause>
 	    <clause>
            <environment>&xq_dyn_env;</environment>
 	    <expression>&gr_URILiteral; &jd_has_atomic_value; &gr_URI;
 	    </expression>
 	    </clause>
 	  </multiclause>
          <multiclause>
          <clause>
            <environment>
              <update>
                <environment>&xq_ns_env;</environment>
                <expression>&gr_NCName; &xt_bind; (passive, &gr_URI;)</expression>
              </update>
            </environment>
            <expression>&gr_Expr; &jd_has_type; &gr_Type;</expression>
          </clause>
          </multiclause>
         </prejudge>
         <postjudge>
          <clause>
           <environment>&xq_stat_env;</environment>
           <expression><code>declare namespace</code> &gr_NCName; = &gr_URILiteral;; &gr_Expr; &jd_has_type; &gr_Type;</expression>
          </clause>
         </postjudge>
        </infer>
      </infergr>
  
      <p>This rule reads as follows: <quote>the phrase on the bottom
      (a namespace declaration in the query prolog followed by an
      expression) is well-typed (accepted by the static typing rules)
      within an environment &xq_stat_env; <emph>if</emph> the
      expression above the line is well-typed in the environment
      obtained from &xq_stat_env; by adding the namespace
      declaration</quote>.</p>

      <p id="fs_activeNS">The helper function
      &fs_activeNS;(&xq_stat_env;) returns all the active in-scope
      namespaces in the given static environment.</p>

      <p id="fs_ns_from_items">For each attribute and element node in
      &gr_Value;, such that the node has name &xd_qname; in the
      namespace &gr_URI;, the helper function
      &fs_ns_from_items;(&xq_stat_env;, &gr_Value;) returns the
      in-scope namespace that corresponds to &gr_URI;.  This is a
      reverse-lookup on &xq_ns_env; by &gr_URI;.</p>

    <div4  id="id-expanded-qnames">
      <head>Resolving QNames to Expanded QNames</head>

      <p>A common use of the static environment is to expand a
      &gr_QName; by looking up the URI that corresponds to the QName's
      namespace prefix in the &xq_ns_env; environment component and by
      constructing an <xtermref spec="DM" ref="dt-expanded-qname"/>,
      which contains the URI and the QName's local part. Element and
      type names may be in the null namespace, that is, there is no
      URI associated with their namespace prefix.  The null namespace
      is denoted by the special value
      <code>#NULL-NAMESPACE</code>.</p>

      <p>The auxiliary judgments below expand an element, type,
      attribute, variable, or function &gr_QName; by looking up the
      namespace prefix in &xq_ns_env; or, if the QName is unqualified,
      by using the appropriate default namespace. </p>
  
      <smnotation>
        <p id="jd_elem_qname_expands_to">The judgment</p>
        <display>
          <clause>
          <environment>&xq_stat_env;</environment>
          <expression>&gr_QName; &jd_elem_qname_expands_to; &xd_qname;</expression>
          </clause>
        </display>
        <p>holds when the element or type QName expands to the 
        given expanded QName.</p>
        <p id="jd_attr_qname_expands_to">The judgment</p>
        <display>
          <clause>
          <environment>&xq_stat_env;</environment>
          <expression>&gr_QName; &jd_attr_qname_expands_to; &xd_qname;</expression>
          </clause>
        </display>
        <p>holds when the attribute QName expands to the 
        given expanded QName.</p>

        <p>We use &gr_Variable; to denote the expanded QNames of
        variables.</p>

        <p id="jd_var_qname_expands_to">The judgment</p>
        <display>
          <clause>
          <environment>&xq_stat_env;</environment>
          <expression>&gr_QName; &jd_var_qname_expands_to; &gr_Variable;</expression>
          </clause>
        </display>
        <p>holds when the variable QName expands to the 
        given expanded QName.</p>

        <p id="jd_func_qname_expands_to">The judgment</p>
        <display>
          <clause>
          <environment>&xq_stat_env;</environment>
          <expression>&gr_QName; &jd_func_qname_expands_to; &xd_qname;</expression>
          </clause>
        </display>
        <p>holds when the function QName expands to the 
        given expanded QName.</p>
    </smnotation>

    <smrules>
      <p>Note that none of the inference rules can infer a resolved
      name in the case a given namespace prefix is bound to the
      (#UNDECLARED) value. As a result, namespace resolution will fail
      if the implementation supports <bibref ref="XMLNAMES11"/> and a
      given namespace prefix has been undeclared.</p>

      <p>An element or type QName consisting of a prefix NCName and a
      local part NCName expands to the URI (or the null namespace)
      corresponding to that prefix and the local part.</p>

      <infergr>
        <infer>
         <prejudge>
         <clause>
         <expression>&xq_ns_env;(&gr_NCName1;) = (&gr_NamespaceKind;,&gr_URIorNullNS;)</expression>
         </clause>
         </prejudge>
         <postjudge>
          <clause>
           <environment>&xq_stat_env;</environment>
           <expression>&gr_NCName1;:&gr_NCName2; &jd_elem_qname_expands_to;
           (&gr_URIorNullNS;, &gr_NCName2;)</expression>
          </clause>
         </postjudge>
        </infer>
      </infergr>

      <p>An element or type QName consisting only of a local part
      NCName expands to the default element/type namespace and the
      local part.</p>

      <infergr>
        <infer>
         <prejudge>
         <clause>
         <expression>&xq_default_elem_ns_env; = &gr_URIorNullNS;</expression>
         </clause>
         </prejudge>
         <postjudge>
          <clause>
           <environment>&xq_stat_env;</environment>
           <expression>&gr_NCName; &jd_elem_qname_expands_to;
           (&gr_URIorNullNS;, &gr_NCName;)</expression>
          </clause>
         </postjudge>
        </infer>
      </infergr>

      <p>An attribute QName consisting of a prefix NCName and a local
      part NCName expands to the URI (or the null namespace)
      corresponding to the prefix and the local part.</p>

      <infergr>
        <infer>
         <prejudge>
         <clause>
         <expression>&xq_ns_env;(&gr_NCName1;) = (&gr_NamespaceKind;,&gr_URIorNullNS;)</expression>
         </clause>
         </prejudge>
         <postjudge>
          <clause>
           <environment>&xq_stat_env;</environment>
           <expression>&gr_NCName1;:&gr_NCName2;
           &jd_attr_qname_expands_to; (&gr_URIorNullNS;, &gr_NCName2;)</expression>
          </clause>
         </postjudge>
        </infer>
      </infergr>

      <p>An attribute QName consisting only of a local part NCName
      expands to the null namespace and the local part.</p>

      <infergr>
        <infer>
         <postjudge>
          <clause>
           <environment>&xq_stat_env;</environment>
           <expression>&gr_NCName; &jd_attr_qname_expands_to;
           (#NULL-NAMESPACE, &gr_NCName;)</expression>
          </clause>
         </postjudge>
        </infer>
      </infergr>

      <p>A variable QName consisting of a prefix NCName and a local
      part NCName expands to the URI that corresponds to the prefix
      and the local part.</p>

      <infergr>
        <infer>
         <prejudge>
         <clause>
         <expression>&xq_ns_env;(&gr_NCName1;) = (&gr_NamespaceKind;,&gr_URI;)</expression>
         </clause>
         </prejudge>
         <postjudge>
          <clause>
           <environment>&xq_stat_env;</environment>
           <expression>&gr_NCName1;:&gr_NCName2;
           &jd_var_qname_expands_to; (&gr_URI;, &gr_NCName2;)</expression>
          </clause>
         </postjudge>
        </infer>
      </infergr>

      <p>A variable QName consisting only of a local part NCName
      expands to the null namespace and the local part.</p>

      <infergr>
        <infer>
         <postjudge>
          <clause>
           <environment>&xq_stat_env;</environment>
           <expression>&gr_NCName; &jd_var_qname_expands_to;
           (#NULL-NAMESPACE, &gr_NCName;)</expression>
          </clause>
         </postjudge>
        </infer>
      </infergr>

      <p>A function QName consisting of a prefix NCName and a local
      part NCName expands to the URI that corresponds to the prefix
      and the local part.</p>

      <infergr>
        <infer>
         <prejudge>
         <clause>
         <expression>&xq_ns_env;(&gr_NCName1;) = (&gr_NamespaceKind;,&gr_URI;)</expression>
         </clause>
         </prejudge>
         <postjudge>
          <clause>
           <environment>&xq_stat_env;</environment>
           <expression>&gr_NCName1;:&gr_NCName2;
           &jd_func_qname_expands_to; (&gr_URI;, &gr_NCName2;)</expression>
          </clause>
         </postjudge>
        </infer>
      </infergr>

      <p>A function QName consisting only of a local part NCName
      expands to the default function namespace URI and the local
      part.</p>

      <infergr>
        <infer>
         <prejudge>
         <clause>
         <expression>&xq_default_fn_ns_env; = &gr_URI;</expression>
         </clause>
         </prejudge>
         <postjudge>
          <clause>
           <environment>&xq_stat_env;</environment>
           <expression>&gr_NCName; &jd_func_qname_expands_to;
           (&gr_URI;, &gr_NCName;)</expression>
          </clause>
         </postjudge>
        </infer>
      </infergr>
    </smrules>
    </div4>  

    </div3>
   
    <div3 id="eval_context">
      <head>Dynamic Context</head>

      <p id="xq_dyn_env_def">&xq_dyn_env; denotes the environment
      available during dynamic evaluation. Dynamic evaluation may
      extend parts of the dynamic environment.</p>

      <p>If evaluation of an expression relies on some component of
      the dynamic context that has not been assigned a value, a
      dynamic error is raised.</p>

      <p>The following environment components are part of the dynamic
      environment:</p>
  
      <table summary="" role="figure" cellpadding="5">
      <col width="10%"/><!-- empty column forces left indentation -->
      <col width="15%"/>
      <col width="65%" align="justify"/>
      <col width="10%"/><!-- empty column forces right indentation -->
      <tbody>

      <tr><td/>
          <td id="xq_val_env" valign="top">&xq_val_env;</td>
          <td>
           <table summary=""><tbody>
            <tr><td>The &xq_val_env; environment component corresponds to the
            <term>variable values</term>, the <term>context
            item</term>, the <term>context position</term> and the
            <term>context size</term> in the &language; evaluation
            context.</td></tr>

            <tr><td>The dynamic value environment component maps an
            expanded variable name (expanded &gr_VarName;) to the
            variable's value (&gr_Value;) or to the value
            <code>#IMPORTED</code>(&gr_URI;), if the variable is
            defined in the imported module with namespace
            &gr_URI;.</td></tr> </tbody></table>
          </td>
          <td/>
      </tr>

      <tr><td/>
          <td id="xq_func_env" valign="top">&xq_func_env;</td>
          <td>
            <table summary="">
              <tbody>
               <tr><td>The &xq_func_env; environment component corresponds to
               the <term>function implementations</term> (or
               definition) part of the &language; dynamic
               context.</td></tr>

               <tr><td>The &xq_func_env; environment component maps
               <phrase diff='chg' at='E006'>
               a &gr_FunctionKey; (expanded function name and arity)
               </phrase>
               to the remainder of the
               corresponding function definition. If the function is
               defined in &xq_functions;, the function definition is
               the value <code>#BUILT-IN</code>. If the function is
               externally defined, the function definition is the
               value <code>#EXTERNAL</code>. If the function is
               defined in the imported module with namespace &gr_URI;,
               the function definition is the value
               <code>#IMPORTED</code>(&gr_URI;). If the function is
               locally declared, the function definition is of the
               form <quote>(&gr_Expr;, &gr_Variable1;,...,
               &gr_Variablen;)</quote>, where &gr_Expr; is the
               function body and &gr_Variable1;, ..., &gr_Variablen;
               are the function parameters.</td></tr>

               <tr><td> The initial function environment component
               (&xq_default_dyn_env;.funcDefn) maps the signatures of
               the internal functions defined in <specref
               ref="sec_operators"/> and the signatures of the
               functions defined in &xq_functions; to
               <code>#BUILT-IN</code>.</td></tr>
              </tbody>
            </table>
          </td>
          <td/>
      </tr>

      <tr><td/>
          <td id="xq_date_time_env" valign="top">&xq_date_time_env;</td>
          <td>
           <table summary=""><tbody>
            <tr><td>The &xq_date_time_env; environment component corresponds to
            the <term>current dateTime</term> in the &language;
            dynamic context.</td></tr> </tbody></table>
          </td>
          <td/>
      </tr>

      <tr><td/>
          <td id="xq_timezone_env" valign="top">&xq_timezone_env;</td>
          <td>
           <table summary=""><tbody>

            <tr><td>The &xq_timezone_env; environment component corresponds to
            the <term>implicit timezone</term> in the &language;
            dynamic context and is used by the timezone related
            functions in &xq_functions;.</td></tr> </tbody></table>
          </td>
          <td/>
      </tr>

      <tr><td/>
          <td id="xq_doc_value_env" valign="top">&xq_doc_value_env;</td>
          <td>
            <table summary="">
              <tbody>
                <tr><td>The &xq_doc_value_env; environment component corresponds
                to the <term>available documents</term> in the
                &language; dynamic context.  It contains the document
                nodes corresponding to input documents, and is used to
                provide the dynamic value of the &fn_doc;
                function.</td></tr>

                <tr><td>The &xq_doc_value_env; environment component contains
                bindings from input URIs (a &gr_URI;) to documents (a
                &gr_DocumentValue;).</td></tr>
              </tbody>
            </table>
          </td>
          <td/>
      </tr>
      <tr><td/>
          <td id="xq_collection_value_env" valign="top">&xq_collection_value_env;</td>
          <td>
            <table summary="">
              <tbody>
                <tr><td>The &xq_collection_value_env; environment component
                corresponds to the <term>available collections</term>
                in the &language; dynamic context.  It contains the
                root nodes corresponding to the input collections, and
                is used to provide the dynamic value of the
                &fn_collection; function.</td></tr>

                <tr><td>The &xq_collection_value_env; environment component
                contains bindings from input URIs (a &gr_URI;) to
                a sequence of nodes.</td></tr>
                </tbody>
            </table>
          </td>
          <td/>
      </tr>
      <tr><td/>
          <td id="xq_default_collection_value_env" valign="top">&xq_default_collection_value_env;</td>
          <td>
            <table summary="">
              <tbody>
                <tr><td>The &xq_default_collection_value_env;
                environment component corresponds to the <term>default
                collection</term> in the &language; dynamic context.
                It contains the sequence of nodes corresponding to the
                default collection, and is used to provide the dynamic
                value of the &fn_collection; function when called with
                no arguments.</td></tr>

                <tr><td>The &xq_default_collection_value_env;
                environment component contains a sequence of nodes.</td></tr>
  
              </tbody>
            </table>
          </td>
          <td/>
      </tr>
      </tbody>
      </table>

      <p id="xq_default_dyn_env">The initial values for the dynamic
      context are defined in <xspecref spec="XQ"
      ref="id-xq-context-components"/> and <xspecref spec="XP"
      ref="id-xp-context-components"/>. The corresponding initial
      dynamic environment is denoted by &xq_default_dyn_env; in the
      Formal Semantics.</p>

      <p id="fs_builtin_vars">The following Formal Semantics variables
      represent the <term>context item</term>, <term>context
      position</term>, and <term>context size</term> properties of the
      dynamic context:</p>
  
      <table summary="" border="1">
       <tbody>
        <tr><td>Built-in Variable&sp2;</td><td>Represents:</td></tr>
        <tr><td>&fs_dot;</td><td>context item</td></tr>
        <tr><td>&fs_position;</td><td>context position </td></tr>
        <tr><td>&fs_last;</td><td>context size</td></tr>
       </tbody>
      </table>
  
      <p>Within this document, variables with the "fs" prefix are
      reserved for use in the formal specification. Values of
      &fs_position; and &fs_last; can be obtained by invoking the
      &fn_position; and &fn_last; functions, respectively. Note that
      the type for those variables is obtained as for any other
      variables. As expected the type of &fs_position; and &fs_last;
      is always &xs_integer; while the type of &fs_dot; depends on the
      context in which it is being used.</p>
    </div3>
  </div2>

  <div2 id="id-processing-model">
    <head>Processing Model</head>

    <p>This section reviews the processing model for &language;. The
    &language; processing model is defined normatively in <xspecref
    spec="XQ" ref="id-processing-model"/>.  This section also explains
    how the main notations (normalization rules, static typing rules,
    and dynamic evaluation rules) relate to the phases in that
    processing model.</p>

    <div3 id="id-fs-processing-model">
      <head>Processing model</head>

      <p>The following figure depicts the &language; processing
      model</p>

<graphic source="ProcMod-XQuery.gif" alt="Processing Model Overview" role="xquery"/>

      <p>Figure 1: Processing Model Overview</p>

      <p>This processing model is not intended to describe an actual
      implementation, although a naive implementation might be based
      upon it. It does not prescribe an implementation technique, but
      any implementation should produce the same results as obtained
      by following this processing model and applying the rest of the
      Formal Semantics specification.</p>

      <p>Query processing consists of two phases: a static analysis
      phase and a dynamic evaluation phase.  Static analysis is further
      divided into four sub-phases.   Typically, each phase consumes the result of
      the previous phase and generates output for the next phase. When
      processing query prologs, these phases may be mutually dependent
      (See <specref ref="id-query-prolog"/>).
      For       each processing phase, we point to the relevant notations
      introduced later in the document.</p>

      <p><termdef id="dt-static-analysis" term="static analysis
      phase">The <term>static analysis phase</term> depends on the
      expression itself and on the static context. The <term>static
      analysis phase</term> does not depend on input data (other than
      schemas).</termdef></p>

      <p>The purpose of the static analysis phase is to detect errors,
      e.g., syntax errors or type errors, at compile time rather than
      at run-time. If no error occurs, the result of static analysis
      could be some compiled form of &query-expr;, suitable for
      execution by a compiled-&query-expr; processor. Static analysis
      consists of the following sub-phases:</p>

      <olist>
        <item>
          <p id="processing_parsing"><term>Parsing.</term> (Step SQ1
          in Figure 1). The grammar for the &language; syntax is
          defined in &xq_xquerydoc;.  Parsing may generate syntax
          errors.  If no error occurs, an internal operation tree of
          the parsed query is created.</p>
        </item>

        <item>
          <p id="processing_context"><term>Static Context
          Processing.</term> (Steps SQ2, SQ3, and SQ4 in Figure
          1). The static semantics of &query-expr; depends on the
          input static context. The input static context needs to be
          generated before the &query-expr; can be analysed. In
          XQuery, the input static context may be defined by the
          processing environment and by declarations in the Query
          Prolog (See <specref ref="id-query-prolog"/>). In XPath, the
          input static context is defined by the processing
          environment. The static context is denoted by
          &xq_stat_env;. </p>
        </item>

        <item>
          <p id="processing_normalization"><term>Normalization.</term>
          (Step SQ5 in Figure 1). To simplify the semantics
          specification, some normalization is performed on the
          &query-expr;. The &language; language provides many powerful
          features that make &query-expr;s simpler to write and use,
          but are also redundant. For instance, a complex
          <code>for</code> expression might be rewritten as a
          composition of several simple <code>for</code>
          expressions. The language composed of these simpler
          &query-expr; is called the &language; <emph>Core
          language</emph> and is described by a grammar which is a
          subset of the XQuery grammar. The grammar of the &language;
          Core language is given in <specref ref="sec_core"/>.</p>

          <p>During the normalization phase, each &language;
          &query-expr; is mapped into its equivalent &query-expr; in
          the Core. (Note that this has nothing to do with Unicode
          Normalization, which works on character strings.)
          Normalization works by recursive application of the
          normalization rules over a given expression.</p>

          <p>Specifically the normalization phase is defined in terms
          of the static part of the context (&xq_stat_env;) and a
          &query-expr; (&gr_Expr;) abstract syntax tree. Formal
          notations for the normalization phase are introduced in
          <specref ref="sec_normalization"/>.</p>

          <p>After normalization, the full semantics is obtained by
          giving a semantics to the normalized Core &query-expr;. This
          is done during the last two phases.</p>
        </item>
        <item>
          <p id="processing_static"><term>Static type analysis.</term>
          (Step SQ6 in Figure 1).  Static type analysis is optional.
          If this phase is not supported, then normalization is
          followed directly by dynamic evaluation.  </p> <p>Static
          type analysis checks whether each &query-expr; is
          well-typed, and if so, determines its static type. Static
          type analysis is defined only for Core &query-expr;. Static
          type analysis works by recursive application of the static
          typing rules over a given expression.</p>

          <p>If the &query-expr; is not well-typed, static type
          analysis yields a <emph>type error</emph>. For instance, a
          comparison between an integer value and a string value might
          be detected as an type error during the static type
          analysis. If static type analysis succeeds, it yields an
          abstract syntax tree where each sub-expression is associated
          with its static type.</p>

          <p>More precisely, the static analysis phase is defined in
          terms of the static context (&xq_stat_env;) and a Core
          &query-expr; (<emph>CoreExpr</emph>).  Formal notations for
          the static analysis phase are introduced in <specref
          ref="sec_static"/>.</p>

          <p>Static typing does not imply that the content of XML
          documents must be rigidly fixed or even known in advance.
          The &language; type system accommodates
          <quote>flexible</quote> types, such as elements that can
          contain any content.  Schema-less documents are handled in
          &language; by associating a standard type with the document,
          such that it may include any legal XML content.</p>
        </item>
      </olist>

      <p>If the static analysis phase succeeds, the dynamic evaluation
      phase (sometimes also called <quote>execution</quote>) evaluates
      a query on input document(s).</p>

      <olist>
        <item>
          <p id="dyn_processing_context"><term>Dynamic Context
          Processing.</term> (Steps DQ2 and DQ3 in Figure 1).The
          dynamic semantics of &query-expr; depends on the dynamic
          input context. The dynamic input context needs to be
          generated before the &query-expr; can be evaluated. The
          dynamic input context may be defined by the processing
          environment and by statements in the Query Prolog (See
          <specref ref="id-query-prolog"/>). In XPath, the dynamic
          input context is defined by the processing environment. The
          static input context is denoted by &xq_dyn_env;.</p>
        </item>
        <item>

          <p id="processing_dynamic"><term>Dynamic Evaluation.</term>
          (Steps DQ4 and DQ5 in Figure 1). This phase computes the
          value of an &query-expr;.  The semantics of evaluation is
          defined only for Core &query-expr; terms. The formal
          description of evaluation works by recursive application of
          the dynamic evaluation rules over a given
          expression. Evaluation may result in a value OR a dynamic
          error, which may be a non-type error or a type error.  If
          static typing of an expression does not raise a type error,
          then dynamic evaluation of the same expression will not
          raise a type error (and thus dynamic type checking can be
          avoided when static typing is enabled). Dynamic evaluation
          may still raise a non-type error.</p>

          <p>The dynamic evaluation phase is defined in terms of the
          static context (&xq_stat_env;) and evaluation context
          (&xq_dyn_env;), and a Core &query-expr;
          (<emph>CoreExpr</emph>). Formal notations for the dynamic
          evaluation phase are introduced in <specref
          ref="sec_evaluation"/>.</p>
        </item>
      </olist>

      <p>Static type analysis catches only certain classes of
      errors. For instance, it can detect a comparison operation
      applied between incompatible types (e.g., <code>xs:int</code>
      and <code>xs:date</code>). Some other classes of errors cannot
      be detected by the static analysis and are only detected at
      evaluation time. For instance, whether an arithmetic expression
      on 32 bit integers (<code>xs:int</code>) yields an out-of-bound
      value can only be detected at run-time by looking at the
      data.</p>

      <p>While implementations are free to implement different
      processing models, the &language; static semantics relies on the
      existence of a static type analysis phase that precedes any
      access to the input data.</p>

      <p>The above processing phases are all internal to the
      &language; processor. They do not deal with how the &language;
      processor interacts with the outside world, notably how it
      accesses actual documents and types. A typical &query-expr;
      engine would support at least three other important processing
      phases:</p>

      <olist>
        <item>
          <p><term>Schema Import Processing.</term> The &language;
          type system is based on XML Schema. In order to perform
          dynamic or static typing, the &language; processor needs to
          build type descriptions that correspond to the schema(s) of
          the input documents. This phase is achieved by mapping all
          schemas required by the &query-expr; into the &language;
          type system. The XML Schema import phase is described in
          <specref ref="sec_importing_schema"/>.</p>
        </item>
        <item>
          <p><term>Data Model Generation.</term> Expressions are
          evaluated on values in the &xq_datamodel;. XML documents
          must be loaded into the &xq_datamodel; before the evaluation
          phase. This is described in the &xq_datamodel; and is not
          discussed further here.</p>
        </item>
        <item>
          <p><term>Serialization.</term> Once the &query-expr; is
          evaluated, processors might want to serialize the result of
          the &query-expr; as actual XML documents. Serialization of
          data model instances is described in
          &xq_datamodel_serialization; and is not discussed further
          here.</p>
        </item>
      </olist>

      <p>The parsing phase is not specified formally; the formal
      semantics does not define a formal model for the syntax trees,
      but uses the &language; concrete syntax directly.  More details
      about parsing for XQuery 1.0 can be found in the &xq_xquerydoc;
      document and more details about parsing for XPath 2.0 can be
      found in the &xq_xpath; document. No further discussion of
      parsing is included here.</p>

    </div3>

    <div3 id="sec_normalization">
      <head>Normalization mapping rules</head>

      <p>Normalization is specified using <emph>mapping</emph> rules,
      which describe how a &language; expression is rewritten into an
      expression in the &language; Core. Mapping rules are also used
      in <specref ref="sec_importing_schema"/> to specify how XML
      Schemas are imported into the &language; type system.</p>

      <smnotation>
        <p>Mapping rules are written using a square bracket notation,
          as follows:</p>

        <mapping>
          <xquery>
            <expression> 
              <map><expression>Object</expression></map><subscript>Subscript</subscript>,
              <emph>premises</emph>
            </expression>
          </xquery>
          <core>
            <expression>
              <emph>Mapped Object</emph>
            </expression>
          </core>
        </mapping>
        
        <p>The original <quote>object</quote>, and an optional list of
        premises, is written above the <term>=</term> sign. The
        rewritten <quote>object</quote> is written beneath the
        <term>=</term> sign. The subscript is used to indicate what
        kind of <quote>object</quote> is mapped, and sometimes to pass
        some information between mapping rules. For instance, the
        mapping rule <map>&gr_Expr;</map>&jd_map_function_argument; is
        used in the normalization of <specref
        ref="id-function-calls"/> and passes a sequence type as a
        parameter during normalization.</p>

        <p>Since normalization is always applied in the presence of a 
        static context, the above rule is a shorthand for:</p>

        <display>
         <infergr>
          <infer><prejudge><clause><environment>&xq_stat_env;</environment><expression>premises</expression></clause></prejudge>
          <postjudge>
           <clause>
            <environment>&xq_stat_env;</environment>
            <expression>
              <map><expression>Object</expression></map>
              <subscript>Subscript</subscript>
              =
              Mapped Object
            </expression>
          </clause>
          </postjudge>
         </infer>
         </infergr>
        </display>

        <p>Most normalization rules have no premises, so they are
        omitted.  The static environment is used in certain
        normalization rules (e.g. for normalization of function
        calls).  To keep the notation simpler, the static environment
        is not written in the normalization rules, but it is assumed
        to be available.</p>

        <p id="jd_map_expr">The normalization rule that is used to map
        <quote>top-level</quote> expressions in the &language; syntax
        into expressions in the &language; Core is:</p>

      	<mapping>
      	  <xquery>
      	    <expression>
      	      <map>&gr_Expr;</map>&jd_map_expr;
      	    </expression>
      	  </xquery>
      	  <core>
      	    <expression>
      	      <emph>CoreExpr</emph>
      	    </expression>
      	  </core>
      	</mapping>

        <p>which indicates that the expression &gr_Expr; is normalized
        to the expression <emph>CoreExpr</emph> in the &language; Core
        (with the implied &xq_stat_env;). Note that &gr_Expr; within
        the square brackets are the expression being normalized, while
        the &gr_Expr; in the subscript indicate that this is the main
        normalization rule that applies to expressions. For instance,
        here is the normalization rule applied to the literal integer
        <code>1</code>.</p>

      	<mapping>
      	  <xquery>
      	    <expression>
      	      <map>1</map>&jd_map_expr;
      	    </expression>
      	  </xquery>
      	  <core>
      	    <expression>1</expression>
      	  </core>
      	</mapping>

        <p>To simplify the specification in some cases, some further
        normalization may be used on the right-hand side of a
        normalization rule. For instance, the following normalization
        rules for the <code>/</code> operator applies normalization to
        the expanded expression on the right-hand side.</p>

      <mapping>
       <xquery>
         <expression><map>/</map>&jd_map_expr;</expression>
       </xquery>
       <core>
         <expression><map>(&fn_root;(self::node()) treat as document-node())</map>&jd_map_expr;</expression>
       </core>
      </mapping>
      </smnotation>

      <smexample>
        <p>For instance, the following &query-expr;</p>

<eg><![CDATA[
    for $i in (1, 2),
        $j in (3, 4)
    return
      element pair { ($i,$j) }
]]></eg>

        <p>is normalized to the Core expression</p>

<eg><![CDATA[
    for $i in (1, 2) return
      for $j in (3, 4) return
          element pair { ($i,$j) }]]><phrase diff='add' at='E045'> {}</phrase><![CDATA[
]]></eg>

        <p>in which the <quote>FWLR</quote> expression is
        mapped into a composition of two simpler "for" expressions.</p>
      </smexample>

    </div3>

    <div3 id="sec_static">
      <head>Static typing judgment</head>

      <p>The static semantics is specified using <term>static typing
      rules</term>, which relate &language; expressions to types and
      specify under what conditions an expression is well typed.</p>

      <smnotation>
        <p id="jd_has_type">The judgment</p>

        <display>
        <clause>
          <environment>&xq_stat_env;</environment>
          <expression>&gr_Expr; &jd_has_type; &gr_Type;</expression>
        </clause>
        </display>

        <p>holds when, in the static environment &xq_stat_env;, the
        expression &gr_Expr; has type &gr_Type;.</p>
      </smnotation>

      <smexample>
        <p>The result of static type inference is to associate a
        static type with every &query-expr;, such that any evaluation
        of that &query-expr; is guaranteed to yield a value that
        belongs to that type.</p>

        <p>For instance, the following expression.</p>

<eg><![CDATA[
   let $v := 3 return $v+5
]]></eg>

        <p>has type &xs_integer;. This can be inferred as follows: the
        literal '3' has type integer, so the variable
        $v also has type integer. Since the sum of two integers is an
        integer, the complete expression has type integer.</p>
      </smexample>

      <smnote>
        <p>The type of an expression is computed by inference. Static
        typing rules define for each kind of expression how to compute
        the type of the expression given the types of its
        sub-expressions.  Here is a simple example:</p>

      	<infergr>
      	  <infer>
      	   <prejudge>
      	    <clause>
      	     <environment>&xq_stat_env;</environment>
      	     <expression> &gr_Expr1; &jd_has_type; &xs_boolean; </expression>
      	    </clause>
      	    <clause>
      	     <environment>&xq_stat_env;</environment>
      	     <expression> &gr_Expr2; &jd_has_type; &gr_Type2;   </expression>
      	    </clause>
      	    <clause>
      	     <environment>&xq_stat_env;</environment>
      	     <expression> &gr_Expr3; &jd_has_type; &gr_Type3;    </expression>
      	    </clause>
      	   </prejudge>
      	   <postjudge>
      	    <clause>
      	     <environment>&xq_stat_env;</environment>
      	     <expression>
      	  <code>if</code> (&gr_Expr1;)
      	  <code>then</code> &gr_Expr2;
      	  <code>else</code> &gr_Expr3; &jd_has_type; ( &gr_Type2; | &gr_Type3; )
      	    </expression>
      	    </clause>
      	   </postjudge>
      	  </infer>
      	</infergr>
  
      	<p>This rule states that if the conditional expression of an
      	<quote>if</quote> expression has type boolean, then the type
      	of the entire expression is one of the two types of its
      	<quote>then</quote> and <quote>else</quote> clauses.  Note
      	that the resulting type is represented as a union:
      	'(&gr_Type2;|&gr_Type3;)'.</p>

        <p>The part after the <term>&xt_turn;</term> and before
        <term>:</term> in the judgment <emph>below</emph> the line
        corresponds to some &query-expr;, for which a type is
        computed. If the &query-expr; has been parsed into an internal
        abstract syntax tree, this usually corresponds to some node in
        that tree. The judgment usually has patterns in it (here
        &gr_Expr1;, &gr_Expr2;, and &gr_Expr3;) that need to be
        matched against the children of the node in the abstract
        syntax tree. The judgments <emph>above</emph> the line
        indicate things that need to be computed to use this rule; in
        this case, the types of the condition expression and the two
        branches of the if-then-else expression.  Once those types are
        computed (by further applying static typing rules recursively
        to those sub-expressions), then the type of the expression
        below the line can be computed.  This example illustrates a
        general feature of the &language; type system: the type of an
        expression depends only on the type of its sub-expressions.
        Static type inference is recursive, following the abstract
        syntax of the &query-expr;.  At each point in the recursion,
        an inference rule whose conclusion has a structure that
        matches that of the premise in question is sought.  If all the
        premises of a rule cannot be satisfied, then the static type
        inference has failed for the given expression, and the
        &query-expr; is not well-typed.</p>

     </smnote>

    </div3>

    <!-- ***************** Evaluation **************** -->

    <div3 id="sec_evaluation">
      <head>Dynamic evaluation judgment</head>

      <p>The dynamic, or operational, semantics is specified using
      <term>dynamic evaluation rules</term>, which relate &language;
      expressions to values, and in some cases specify the order in
      which an &language; expression is evaluated.</p>

      <smnotation>
        <p id="jd_yields">The judgment</p>

        <display>
        <clause>
          <environment>&xq_stat_env;; &xq_dyn_env;</environment>
          <expression>&gr_Expr; &jd_yields; &gr_Value;</expression>
        </clause>
        </display>

        <p>holds when, in the static environment &xq_stat_env; and
        dynamic environment &xq_dyn_env;, the expression &gr_Expr;
        yields the value &gr_Value;.</p>

      </smnotation>

      <p>The static environment is used in certain cases (e.g. for
      type matching) during evaluation. To keep the notation simpler,
      the static environment is not written in the dynamic evaluation
      rules, but it is assumed to be available.</p>

      <p>The inference rules used for dynamic evaluation, like those
      for static typing, follow a recursive structure, computing the
      value of expressions from the values of their
      sub-expressions.</p>

    </div3>

  </div2>

  <div2 id="sec_errors">
    <head>Error Handling</head>

    <p>Expressions can raise errors during static analysis or dynamic
    evaluation.  The &xq_functions; &xq_xquerydoc;, and &xq_xpath;
    specify the conditions under which an expression or operator
    raises an error.  The user may raise an error explicitly by
    calling the &fn_error; function, which takes an optional item as
    an argument.</p>

    <p>This document does not describe formally the conditions under
    which dynamic errors are raised. Notably, it does not specify the
    error codes or the rules about errors and optimization, as
    described in <bibref ref="xquery-30"/>. Instead, this document
    describe the rules necessary to statically detect the subset of
    the &language; dynamic errors known as <xtermref spec="XQ"
    ref="dt-type-error"/>.</p>

  </div2>

  <div2 id="id-important-concepts">
    <head>Concepts</head>

    <p>&language; is most generally used to process
    <term>documents</term>. The representation of a document is
    normatively defined in &xq_datamodel;. The functions used to
    access documents and collections are normatively defined in
    &xq_functions;. </p>

    <div3 id="id-doc-order">
      <head>Document Order</head>

      <p>Document order is defined in &xq_datamodel;.</p>
    </div3>


      <div3 id="id-atomization">
        <head>Atomization</head>

        <p>Atomization converts an item sequence into a sequence of
        atomic values and is implemented by the &fn_data; function.
        Atomization is applied to a value when the value is used in a
        context in which a sequence of atomic values is required.</p>
      </div3>
  
    <div3 id="id-ebv">
      <head>Effective Boolean Value</head>

      <p>If a sequence of items is encountered where a boolean value
      is expected, the item sequence's effective boolean value is
      used. The &fn_boolean; function returns the effective boolean
      value of an item sequence.</p>
    </div3>
  
    <div3 id="id-input-sources"><head>Input Sources</head>
      <p>&language; has several functions that provide access to input
      data, described in <xspecref spec="XQ"
      ref="id-input-sources"/>. These functions are of particular
      importance because they provide a way in which an expression can
      reference a document or a collection of documents. The dynamic
      semantics of these input functions are described in more detail
      in &xq_functions;.</p>
    </div3>

    <div3 id="id-uri-literals" role="xquery">
      <head>URI Literals</head>

      <p>In certain places in the XQuery grammar, a statically known
      valid absolute URI is required. These places are denoted by the
      grammatical symbol &gr_URILiteral;, and are treated as described
      in <bibref ref="xquery-30"/>.</p>

    </div3>
  </div2>

  <div2 id="id-type-conversion">
    <head>Types</head>

    <div3  id="id-predefined-types">
      <head>Predefined Schema Types</head>

      <p>All the built-in types of XML Schema are recognized by
      &language;. In addition, &language; recognizes the predefined
      types &xs_anyAtomicType;, &xs_untypedAtomic; and &xs_untyped;
      and the duration subtypes &xs_yearMonthDuration; and
      &xs_dayTimeDuration;. The definition of those types in the
      &language; type system is given below.</p>

      <p><termdef id="dt-xs_anyType" term="xs:anyType"> The following
      type definition of <term><phrase>&xs_anyType;</phrase></term>
      reflects the semantics of the Ur type from Schema in the
      &language; type system.</termdef></p>

<eg diff='chg' at='E022'><![CDATA[
  define type xs:anyType restricts xs:anyType {
    ( attribute * of type xs:anySimpleType )*,
    ( xs:anyAtomicType* | ( element * of type xs:anyType | text | comment | processing-instruction * )* )
  }
]]></eg>

      <p><termdef id="dt-xs_anySimpleType" term="xs:anySimpleType">
      The following type definition of
      <term><phrase>&xs_anySimpleType;</phrase></term> reflects the
      semantics of the Ur simple type from Schema in the &language;
      type system.</termdef></p>

<eg><![CDATA[
  define type xs:anySimpleType restricts xs:anyType {
    xs:anyAtomicType*
  }
]]></eg>

      <p>The name of the Ur simple type is &xs_anySimpleType;. It is
      derived by restriction from &xs_anyType;, its content is a
      sequence any atomic types.</p>

      <p><termdef id="dt-xs_anyAtomicType"
      term="xs:anyAtomicType"><phrase>The following type definition
      of <term><phrase>&xs_anyAtomicType;</phrase></term> reflects
      the semantics of &xs_anyAtomicType; in the &language; type
      system.</phrase></termdef></p>

<eg><![CDATA[
  define type xs:anyAtomicType restricts xs:anySimpleType {
    ( xs:string
    | xs:boolean
    | xs:decimal
    | xs:float
    | xs:double
    | xs:duration
    | xs:dateTime
    | xs:time
    | xs:date
    | xs:gYearMonth
    | xs:gYear
    | xs:gMonthDay
    | xs:gDay
    | xs:gMonth
    | xs:hexBinary
    | xs:base64Binary
    | xs:anyURI
    | xs:QName
    | xs:NOTATION
    | xs:untypedAtomic )
  }
]]></eg>

      <p><termdef id="dt-primitive-types" term="primitive types"> The
      following type definitions of <term> the XML Schema primitive
      types</term> reflect the semantics of the primitive types from
      Schema in the &language; type system.</termdef></p>

<eg><![CDATA[
  define type xs:string       restricts xs:anyAtomicType]]>&E042_semi;<![CDATA[
  define type xs:boolean      restricts xs:anyAtomicType]]>&E042_semi;<![CDATA[
  define type xs:decimal      restricts xs:anyAtomicType]]>&E042_semi;<![CDATA[
  define type xs:float        restricts xs:anyAtomicType]]>&E042_semi;<![CDATA[
  define type xs:double       restricts xs:anyAtomicType]]>&E042_semi;<![CDATA[
  define type xs:duration     restricts xs:anyAtomicType]]>&E042_semi;<![CDATA[
  define type xs:dateTime     restricts xs:anyAtomicType]]>&E042_semi;<![CDATA[
  define type xs:time         restricts xs:anyAtomicType]]>&E042_semi;<![CDATA[
  define type xs:date         restricts xs:anyAtomicType]]>&E042_semi;<![CDATA[
  define type xs:gYearMonth   restricts xs:anyAtomicType]]>&E042_semi;<![CDATA[
  define type xs:gYear        restricts xs:anyAtomicType]]>&E042_semi;<![CDATA[
  define type xs:gMonthDay    restricts xs:anyAtomicType]]>&E042_semi;<![CDATA[
  define type xs:gDay         restricts xs:anyAtomicType]]>&E042_semi;<![CDATA[
  define type xs:gMonth       restricts xs:anyAtomicType]]>&E042_semi;<![CDATA[
  define type xs:hexBinary    restricts xs:anyAtomicType]]>&E042_semi;<![CDATA[
  define type xs:base64Binary restricts xs:anyAtomicType]]>&E042_semi;<![CDATA[
  define type xs:anyURI       restricts xs:anyAtomicType]]>&E042_semi;<![CDATA[
  define type xs:QName        restricts xs:anyAtomicType]]>&E042_semi;<![CDATA[
  define type xs:NOTATION     restricts xs:anyAtomicType]]>&E042_semi;<![CDATA[
]]></eg>

      <p>All of those primitive types derive from
      &xs_anyAtomicType;. Note that the value space of each atomic
      type (such as &xs_string;) does not appear. The value space for
      each type is built-in and is as defined in &xq_xmlschema2;.</p>

      <p><termdef id="dt-xs_untypedAtomic"
      term="xs:untypedAtomic">The type
      <term><phrase>&xs_untypedAtomic;</phrase></term> is defined as
      follows.</termdef></p>

<eg><![CDATA[
  define type xs:untypedAtomic restricts xs:anyAtomicType
]]></eg>

      <p>Note that this rule does not indicate the value space of
      &xs_untypedAtomic;. By definition, &xs_untypedAtomic; has the
      same value space as &xs_string;.</p>

      <p>The following example shows two atomic values. The first one
      is a value of type string containing "Database". The second one
      is an untyped atomic value containing "Database".</p>

<eg><![CDATA[
  "Databases" of type xs:string
  "Databases" of type xs:untypedAtomic
]]></eg>

      <p><termdef id="dt-xs_untyped" term="xs:untyped">The type
      <term><phrase>&xs_untyped;</phrase></term> is defined as
      follows.</termdef></p>

<eg diff='chg' at='E022'><![CDATA[
  define type xs:untyped restricts xs:anyType {
    attribute * of type xs:untypedAtomic*,
    ( element * of type xs:untyped | text | comment | processing-instruction * )*
  }
]]></eg>

      <p><termdef id="dt-derived-types" term="derived types">The
      following type definitions of the <term>XML Schema derived
      types</term> reflect the semantics of the XML Schema types
      derived by restriction from another atomic type.</termdef></p>

<eg><![CDATA[
  define type xs:normalizedString   restricts xs:string]]>&E042_semi;<![CDATA[
  define type xs:token              restricts xs:normalizedString]]>&E042_semi;<![CDATA[
  define type xs:language           restricts xs:token]]>&E042_semi;<![CDATA[
  define type xs:NMTOKEN            restricts xs:token]]>&E042_semi;<![CDATA[
  define type xs:Name               restricts xs:token]]>&E042_semi;<![CDATA[
  define type xs:NCName             restricts xs:Name]]>&E042_semi;<![CDATA[
  define type xs:ID                 restricts xs:NCName]]>&E042_semi;<![CDATA[
  define type xs:IDREF              restricts xs:NCName]]>&E042_semi;<![CDATA[
  define type xs:ENTITY             restricts xs:NCName]]>&E042_semi;<![CDATA[
  define type xs:integer            restricts xs:decimal]]>&E042_semi;<![CDATA[
  define type xs:nonPositiveInteger restricts xs:integer]]>&E042_semi;<![CDATA[
  define type xs:negativeInteger    restricts xs:nonPositiveInteger]]>&E042_semi;<![CDATA[
  define type xs:long               restricts xs:integer]]>&E042_semi;<![CDATA[
  define type xs:int                restricts xs:long]]>&E042_semi;<![CDATA[
  define type xs:short              restricts xs:int]]>&E042_semi;<![CDATA[
  define type xs:byte               restricts xs:short]]>&E042_semi;<![CDATA[
  define type xs:nonNegativeInteger restricts xs:integer]]>&E042_semi;<![CDATA[
  define type xs:unsignedLong       restricts xs:nonNegativeInteger]]>&E042_semi;<![CDATA[
  define type xs:unsignedInt        restricts xs:unsignedLong]]>&E042_semi;<![CDATA[
  define type xs:unsignedShort      restricts xs:unsignedInt]]>&E042_semi;<![CDATA[
  define type xs:unsignedByte       restricts xs:unsignedShort]]>&E042_semi;<![CDATA[
  define type xs:positiveInteger    restricts xs:nonNegativeInteger]]>&E042_semi;<![CDATA[
]]></eg>

      <p>Three XML Schema built-in derived types are derived by list,
      as follows. Note that those derive directly from
      &xs_anySimpleType;, since they are derived by list, and that
      their value space is defined using a <quote>one or more</quote>
      occurrence indicator.</p>

<eg><![CDATA[
  define type xs:NMTOKENS restricts xs:anySimpleType { xs:NMTOKEN+ }]]>&E042_semi;<![CDATA[
  define type xs:IDREFS   restricts xs:anySimpleType { xs:IDREF+ }]]>&E042_semi;<![CDATA[
  define type xs:ENTITIES restricts xs:anySimpleType { xs:ENTITY+ }]]>&E042_semi;<![CDATA[
]]></eg>

     <p>For example, here is an element whose content is of type
     &xs_IDREFS;.</p>

<eg><![CDATA[
  element a of type xs:IDREFS {
    "id1" of type xs:IDREF,
    "id2" of type xs:IDREF,
    "id3" of type xs:IDREF
  }
]]></eg>

      <p>Note that the type name &xs_IDREFS; derives from
      &xs_anySimpleType;, but not from &xs_IDREF;. As a consequence,
      calling the following three XQuery functions with the element
      <code>a</code> as a parameter succeeds for <code>f1</code> and
      <code>f2</code>, but raises a type error for
      <code>f3</code>.</p>

<eg><![CDATA[
  declare function f1($x as element(*,xs:anySimpleType)) { $x }
  declare function f2($x as element(*,xs:IDREFS)) { $x }
  declare function f3($x as element(*,xs:IDREF)) { $x }
]]></eg>

      <p><termdef id="dt-xs_durations" term="Totally ordered duration
      types"><phrase>The <term>totally ordered duration types</term>,
      &xs_yearMonthDuration; and &xs_dayTimeDuration;, are derived
      by restriction from &xs_duration;.</phrase></termdef></p>

<eg><![CDATA[
  define type xs:yearMonthDuration restricts xs:duration]]>&E042_semi;<![CDATA[
  define type xs:dayTimeDuration   restricts xs:duration]]>&E042_semi;<![CDATA[
]]></eg>

      <p><termdef id="dt-fs_numeric" term="fs:numeric">In addition,
      the Formal Semantics uses the additional type &fs_numeric;. This
      type is necessary for the specification of some of XPath type
      conversion rules.  It is defined as follows.</termdef></p>

<eg><![CDATA[
  define type fs:numeric restricts xs:anyAtomicType { xs:decimal | xs:float | xs:double }
]]></eg>

    </div3>

    <div3 id="id-typed-value">
      <head>Typed Value and String Value</head>
      <p>The typed value of a node is computed by the &fn_data;
      function, and the string value of a node is computed by the
      &fn_string; function, defined in &xq_functions;.
The normative definitions of typed value and string value are defined in &xq_datamodel;.
</p>
    </div3>

    <div3 id="id-sequencetype"> 
      <head>SequenceType Syntax</head> 

      <smintro>
        <p>Sequence types can be used in &language; to refer to an XML
        Schema type. Sequence types are used to declare the types of
        function parameters and in several &language; expressions.</p>
  
        <p>The syntax of sequence types is described by the following
        grammar productions.</p>

    <scrap> 
      <head>SequenceType</head> 
      <prodrecap id="SequenceType"          ref="SequenceType" orig="xquery"/>
      <prodrecap id="ItemType"              ref="ItemType" orig="xquery"/>
      <prodrecap id="OccurrenceIndicator"   ref="OccurrenceIndicator" orig="xquery"/>
      <prodrecap id="AtomicType"            ref="AtomicType" orig="xquery"/>
      <prodrecap id="KindTest"              ref="KindTest" orig="xquery"/>
      <prodrecap id="DocumentTest"          ref="DocumentTest" orig="xquery"/>
      <prodrecap id="ElementTest"           ref="ElementTest" orig="xquery"/>
      <prodrecap id="SchemaElementTest"     ref="SchemaElementTest" orig="xquery"/>
      <prodrecap id="ElementDeclaration"    ref="ElementDeclaration" orig="xquery"/>
      <prodrecap id="AttributeTest"         ref="AttributeTest" orig="xquery"/>
      <prodrecap id="SchemaAttributeTest"   ref="SchemaAttributeTest" orig="xquery"/>
      <prodrecap id="AttributeDeclaration"  ref="AttributeDeclaration" orig="xquery"/>
      <prodrecap id="ElementNameOrWildcard" ref="ElementNameOrWildcard" orig="xquery"/>
      <prodrecap id="ElementName"           ref="ElementName" orig="xquery"/>
      <prodrecap id="AttribNameOrWildcard"  ref="AttribNameOrWildcard" orig="xquery"/>
      <prodrecap id="AttributeName"         ref="AttributeName" orig="xquery"/>
      <prodrecap id="TypeName"              ref="TypeName" orig="xquery"/>
      <prodrecap id="PITest"                ref="PITest" orig="xquery"/>
      <prodrecap id="CommentTest"           ref="CommentTest" orig="xquery"/>
      <prodrecap id="TextTest"              ref="TextTest" orig="xquery"/>
      <prodrecap id="AnyKindTest"           ref="AnyKindTest" orig="xquery"/>
    </scrap> 

        <smcore>
          <p>The Core grammar productions for sequence types are:</p>
      
  <scrap>
   <head></head>
   <prodrecap id="core-SequenceType"          ref="SequenceType" orig="core"/>
   <prodrecap id="core-ItemType"              ref="ItemType" orig="core"/>
   <prodrecap id="core-OccurrenceIndicator"   ref="OccurrenceIndicator" orig="core"/>
   <prodrecap id="core-AtomicType"            ref="AtomicType" orig="core"/>
   <prodrecap id="core-KindTest"              ref="KindTest" orig="core"/>
   <prodrecap id="core-DocumentTest"          ref="DocumentTest" orig="core"/>
   <prodrecap id="core-ElementTest"           ref="ElementTest" orig="core"/>
   <prodrecap id="core-SchemaElementTest"     ref="SchemaElementTest" orig="core"/>
   <prodrecap id="core-ElementDeclaration"    ref="ElementDeclaration" orig="core"/>
   <prodrecap id="core-AttributeTest"         ref="AttributeTest" orig="core"/>
   <prodrecap id="core-SchemaAttributeTest"   ref="SchemaAttributeTest" orig="core"/>
   <prodrecap id="core-AttributeDeclaration"  ref="AttributeDeclaration" orig="core"/>
   <prodrecap id="core-ElementNameOrWildcard" ref="ElementNameOrWildcard" orig="core"/>
   <prodrecap id="core-ElementName"           ref="ElementName" orig="core"/>
   <prodrecap id="core-AttribNameOrWildcard"  ref="AttribNameOrWildcard" orig="core"/>
   <prodrecap id="core-AttributeName"         ref="AttributeName" orig="core"/>
   <prodrecap id="core-TypeName"              ref="TypeName" orig="core"/>
   <prodrecap id="core-PITest"                ref="PITest" orig="core"/>
   <prodrecap id="core-CommentTest"           ref="CommentTest" orig="core"/>
   <prodrecap id="core-TextTest"              ref="TextTest" orig="core"/>
   <prodrecap id="core-AnyKindTest"           ref="AnyKindTest" orig="core"/>
  </scrap>
        </smcore>

        <p>The semantics of SequenceTypes is defined by means of
        normalization rules from SequenceTypes into types in the
        &language; type system (See <specref ref="sec_types"/>).</p>

        <p>However, the &language; type system not being part of the
        &language; syntax, the SequenceType syntax is still part of
        the &language; Core. Normalization from SequenceTypes to types
        is not applied during the normalization phase but whenever a
        dynamic evaluation or static typing rule requires it.</p>

      </smintro>
  
    </div3>
      <div3 id="id-sequencetype-matching">
        <head>SequenceType Matching</head>
    
        <smintro>
          <p>During processing of a query, it is sometimes necessary
          to determine whether a given value matches a type that was
          declared using the SequenceType syntax. This process is
          known as SequenceType matching, and is formally specified in
          <specref ref="sec_type_matching"/>.</p>
        </smintro>

        <smnotation>
          <p id="jd_map_sequencetype">To define normalization of
          SequenceTypes to the &language; type system, the following
          auxiliary mapping rule is used.</p>
        
            <mapping>
             <xquery>
              <expression>
               <map>&gr_SequenceType;</map>&jd_map_sequencetype;
              </expression>
             </xquery>
             <core>
              <expression>
               &gr_Type;
              </expression>
             </core>
            </mapping>
        
          <p>specifies that &gr_SequenceType; is mapped to a &gr_Type;,
          in the &language; type system.</p>
        </smnotation>
        
        <smnorm>
          <p>OccurenceIndicators are left unchanged when normalizing
          SequenceTypes into &language; types. Each kind of
          SequenceType component is normalized separately into the
          &language; type system.</p>

            <mapping>
             <xquery>
              <expression>
               <map>&gr_ItemType; &gr_OccurrenceIndicator;</map>&jd_map_sequencetype;
              </expression>
             </xquery>
             <core>
              <expression>
               <map>&gr_ItemType;</map>&jd_map_sequencetype; &gr_OccurrenceIndicator;
              </expression>
             </core>
            </mapping>
        
            <p>The <quote>empty-sequence()</quote> sequence type is
            mapped to the empty type.</p>
        
            <mapping>
             <xquery>
              <expression>
               <map>empty-sequence()</map>&jd_map_sequencetype;
              </expression>
             </xquery>
             <core>
              <expression>
               empty
              </expression>
             </core>
            </mapping>

            <p>An atomic type is normalized to itself in the
            &language; type system.</p>

            <mapping>
             <xquery>
              <expression>
               <map>&gr_AtomicType;</map>&jd_map_sequencetype;
              </expression>
             </xquery>
             <core>
              <expression>
               &gr_AtomicType;
              </expression>
             </core>
            </mapping>

            <p>An <quote>element</quote> SequenceType without content
            or with a wildcard and no type name is normalized into a
            wildcard element type.</p>

            <mapping>
             <xquery>
              <expression>
               <map>element()</map>&jd_map_sequencetype;
              </expression>
             </xquery>
             <core>
              <expression>
                element * of type &xs_anyType;
              </expression>
             </core>
            </mapping>
        
            <mapping>
             <xquery>
              <expression>
               <map>element(*)</map>&jd_map_sequencetype;
              </expression>
             </xquery>
             <core>
              <expression>
                element * of type &xs_anyType;
              </expression>
             </core>
            </mapping>

            <p>An <quote>element</quote> SequenceType with a wildcard
            and a type name is normalized into a wildcard element type
            with a corresponding type name. The presence of a
            <quote>?</quote> after the type name indicates a nillable
            element.</p>

            <mapping>
             <xquery>
              <expression>
               <map>element(*,&gr_TypeName;)</map>&jd_map_sequencetype;
              </expression>
             </xquery>
             <core>
              <expression>
                element * of type &gr_TypeName;
              </expression>
             </core>
            </mapping>

            <mapping>
             <xquery>
              <expression>
               <map>element(*,&gr_TypeName;?)</map>&jd_map_sequencetype;
              </expression>
             </xquery>
             <core>
              <expression>
                element * nillable of type &gr_TypeName;
              </expression>
             </core>
            </mapping>

            <p>An <quote>element</quote> SequenceType with a name and
            a type name is normalized into an element type with a
            corresponding type name. The presence of a
            <quote>?</quote> after the type name indicates a nillable
            element.</p>

            <mapping>
             <xquery>
              <expression>
               <map>element(&gr_ElementName;,&gr_TypeName;)</map>&jd_map_sequencetype;
              </expression>
             </xquery>
             <core>
              <expression>
                element &gr_ElementName; of type &gr_TypeName;
              </expression>
             </core>
            </mapping>

            <mapping>
             <xquery>
              <expression>
               <map>element(&gr_ElementName;,&gr_TypeName;?)</map>&jd_map_sequencetype;
              </expression>
             </xquery>
             <core>
              <expression>
                element &gr_ElementName; nillable of type &gr_TypeName;
              </expression>
             </core>
            </mapping>

            <p>An <quote>element</quote> SequenceType with only a name
            is normalized into a <emph>nillable</emph> element type
            with a corresponding name. The reason for the
            normalization to allow nillable elements is because the
            semantics of SequenceTypes in that case allows it to match
            every possible element with that names, regardless of its
            type or nilled property.</p>

            <mapping>
             <xquery>
              <expression>
               <map>element(&gr_ElementName;)</map>&jd_map_sequencetype;
              </expression>
             </xquery>
             <core>
              <expression>
                element &gr_ElementName; nillable of type &xs_anyType;
              </expression>
             </core>
            </mapping>
       
            <p>A <quote>schema-element</quote> SequenceType with an
            element declaration is normalized into a reference to the
            corresponding global element declaration.</p>

            <mapping>
             <xquery>
              <expression>
               <map>schema-element(&gr_ElementName;)</map>&jd_map_sequencetype;
              </expression>
             </xquery>
             <core>
              <expression>
                element &gr_ElementName;
              </expression>
             </core>
            </mapping>
        
            <p>An <quote>attribute</quote> SequenceType without
            content or with a wildcard and no type name is normalized
            into a wildcard attribute type.</p>

            <mapping>
             <xquery>
              <expression>
               <map>attribute()</map>&jd_map_sequencetype;
              </expression>
             </xquery>
             <core>
              <expression>
                attribute * of type &xs_anySimpleType; 
              </expression>
             </core>
            </mapping>
        
            <mapping>
             <xquery>
              <expression>
               <map>attribute(*)</map>&jd_map_sequencetype;
              </expression>
             </xquery>
             <core>
              <expression>
                attribute * of type &xs_anySimpleType; 
              </expression>
             </core>
            </mapping>

            <p>An <quote>attribute</quote> SequenceType with a
            wildcard and a type name is normalized into a wildcard
            attribute type with a corresponding type name.</p>

            <mapping>
             <xquery>
              <expression>
               <map>attribute(*,&gr_TypeName;)</map>&jd_map_sequencetype;
              </expression>
             </xquery>
             <core>
              <expression>
                attribute * of type &gr_TypeName;
              </expression>
             </core>
            </mapping>

            <p>An <quote>attribute</quote> SequenceType with a name
            and a type name is normalized into an attribute type with
            a corresponding type name.</p>

            <mapping>
             <xquery>
              <expression>
               <map>attribute(&gr_AttributeName;,&gr_TypeName;)</map>&jd_map_sequencetype;
              </expression>
             </xquery>
             <core>
              <expression>
                attribute &gr_AttributeName; of type &gr_TypeName;
              </expression>
             </core>
            </mapping>

            <p>A <quote>schema-attribute</quote> SequenceType with an
            attribute declaration is normalized into a reference to
            the corresponding global attribute declaration.</p>

            <mapping>
             <xquery>
              <expression>
               <map>schema-attribute(&gr_AttributeName;)</map>&jd_map_sequencetype;
              </expression>
             </xquery>
             <core>
              <expression>
                attribute &gr_AttributeName;
              </expression>
             </core>
            </mapping>

            <p>A <quote>document-node()</quote> sequence types is
            normalized into the corresponding document type.</p>

            <mapping>
             <xquery>
              <expression>
               <map>document-node()</map>&jd_map_sequencetype;
              </expression>
             </xquery>
             <core>
              <expression>
                document { (element * of type &xs_anyType; | text | comment | processing-instruction<phrase diff='add' at='E022'> *</phrase> )* }
              </expression>
             </core>
            </mapping>

            <p>A <quote>document-node</quote> sequence type with an
            element test (resp. a schema element test) is normalized
            into the corresponding document type, whose content is the
            normalization of the element test (resp. schema element
            test), interleaved with an arbitrary sequence of
            processing instruction, comment, and text nodes.</p>

            <mapping>
             <xquery>
              <expression>
               <map>document-node(&gr_ElementTest;)</map>&jd_map_sequencetype;
              </expression>
             </xquery>
             <core>
              <expression>
                document {
                <map>&gr_ElementTest;</map>&jd_map_sequencetype; &amp;
                ( processing-instruction<phrase diff='add' at='E022'> *</phrase> | comment ) *}
              </expression>
             </core>
            </mapping>

            <mapping>
             <xquery>
              <expression>
               <map>document-node(&gr_SchemaElementTest;)</map>&jd_map_sequencetype;
              </expression>
             </xquery>
             <core>
              <expression>
                document {
                <map>&gr_SchemaElementTest;</map>&jd_map_sequencetype; &amp;
                ( processing-instruction<phrase diff='add' at='E022'> *</phrase> | comment ) *}
              </expression>
             </core>
            </mapping>

            <p>A <quote>processing-instruction()</quote> SequenceType
            is normalized into the corresponding
            processing-instruction type.</p>

            <mapping>
             <xquery>
              <expression>
               <map>processing-instruction()</map>&jd_map_sequencetype;
              </expression>
             </xquery>
             <core>
              <expression>processing-instruction<phrase diff='add' at='E022'> *</phrase></expression>
             </core>
            </mapping>

            <p diff='del' at='E022'>The &language; type system does not model the target of
            a processing-instruction, which is treated as a dynamic
            property. Therefore a
            <quote>processing-instruction</quote> SequenceType with a
            string or NCName parameter is normalized into an optional
            processing-instruction type.</p>

            <mapping diff='del' at='E022'>
             <xquery>
              <expression>
               <map>processing-instruction(&gr_StringLiteral;)</map>&jd_map_sequencetype;
              </expression>
             </xquery>
             <core>
              <expression>processing-instruction?</expression>
             </core>
            </mapping>

            <mapping>
             <xquery>
              <expression>
               <map>processing-instruction(&gr_NCName;)</map>&jd_map_sequencetype;
              </expression>
             </xquery>
             <core>
              <expression diff='chg' at='E022'>processing-instruction &gr_NCName;</expression>
             </core>
            </mapping>

            <!--
                <mapping> is transformed to a div with whitespace only at the top;
                <infergr> is transformed to a div with whitespace only at the bottom.
                Thus a <mapping> followed by an <infergr> transforms to two divs
                with no space in between.
                So add a para to separate them.
            -->
            <p diff='add' at='E022'>
            For backward compatibility with XPath 1.0,
            the PITarget of a PITest
            may also be expressed as a string literal.
            The following rule handles that case.
            </p>

            <infergr diff='add' at='E022'>
              <infer>
                <prejudge>
                  <multiclause>
                    <clause>
                      <expression>&gr_StringLiteral; &jd_has_atomic_value; &gr_String;</expression>
                    </clause>
                  </multiclause>
                  <multiclause>
                    <clause>
                      <expression>&xs_NCName;(&gr_String;) = &gr_NCName; </expression>
                    </clause>
                  </multiclause>
                </prejudge>
                <postjudge>
                  <clause>
                    <expression>
                      <map>processing-instruction(&gr_StringLiteral;)</map>&jd_map_sequencetype;
                      =
                      processing-instruction &gr_NCName;
                    </expression>
                  </clause>
                </postjudge>
              </infer>
            </infergr>

            <p>A <quote>comment()</quote> SequenceType is normalized
            into the corresponding comment type.</p>
        
            <mapping>
             <xquery>
              <expression>
               <map>comment()</map>&jd_map_sequencetype;
              </expression>
             </xquery>
             <core>
              <expression>comment</expression>
             </core>
            </mapping>

            <p>A <quote>text()</quote> SequenceType is normalized into
            the corresponding text type.</p>
        
            <mapping>
             <xquery>
              <expression>
               <map>text()</map>&jd_map_sequencetype;
              </expression>
             </xquery>
             <core>
              <expression>
                text
              </expression>
             </core>
            </mapping>

            <p>The <quote>node()</quote> SequenceType denotes any
            node. It is normalized into a choice between the
            corresponding wildcard types for each kind of node.</p>

            <mapping>
             <xquery>
              <expression>
               <map>node()</map>&jd_map_sequencetype;
              </expression>
             </xquery>
             <core>
              <expression>
                (element * of type &xs_anyType; | attribute * of type
                &xs_anySimpleType; | text | document { (element * of
                type &xs_anyType; | text | comment |
                processing-instruction<phrase diff='add' at='E022'> *</phrase>)* } | comment | processing-instruction<phrase diff='add' at='E022'> *</phrase>)
              </expression>
             </core>
            </mapping>

            <p>The <quote>item()</quote> SequenceType denotes any node
            or atomic value. It is normalized into a choice between
            the corresponding wildcard types for each kind of nodes or
            atomic values.</p>

            <mapping>
             <xquery>
              <expression>
               <map>item()</map>&jd_map_sequencetype;
              </expression>
             </xquery>
             <core>
              <expression>
                (element * of type &xs_anyType; | attribute * of type &xs_anySimpleType; | text | document { (element * of
                type &xs_anyType; | text | comment |
                processing-instruction<phrase diff='add' at='E022'> *</phrase>)* } | comment |
                processing-instruction<phrase diff='add' at='E022'> *</phrase> | &xs_anyAtomicType; )
              </expression>
             </core>
            </mapping>

        </smnorm>
      </div3>
  
  
  </div2>

  <div2 id="comments">
    <head>Comments</head>
  
    <scrap>
      <head></head>
      <prodrecap id="Comment"         ref="Comment"         orig="xquery"/>
      <prodrecap id="CommentContents" ref="CommentContents" orig="xquery"/>
    </scrap>

    <p>Comments are lexical constructs only, and have no effect on the
    meaning of the query, and therefore do not have any formal
    semantics.</p>
  
  </div2>

  <div2 id="xml-terminals">
    <head>XML-defined Terminals</head>

    <p>The following terminals are defined by XML.</p>
	
	<scrap headstyle="show">  
		<head></head>
		<prodrecap id="XQueryDefinedLexemesForXML" ref="XQueryDefinedLexemesForXML" 
			role="XQueryDefinedLexemesForXML" 
			at="../xquery-semantics/temp-shared/xquery-grammar.xml" orig="xquery"/> 	   
	</scrap>

  </div2>

</div1>

<div1 id="id-expressions">
  <head>Expressions</head>

  <p>This section gives the semantics of all the &language;
  expressions. The organization of this section parallels the
  organization of <xspecref spec="XQ" ref="id-expressions"/>.</p>

  <scrap><head></head>
    <prodrecap id="Expr"        ref="Expr"        orig="xquery"/>
    <prodrecap id="ExprSingle"  ref="ExprSingle"  orig="xquery"/>
    <prodrecap id="XPath"       ref="XPath"       orig="xpath" test="XPath"/>
  </scrap>

  <p>For each expression, a short description and the relevant grammar
  productions are given. The semantics of an expression includes the
  normalization, static analysis, and dynamic evaluation
  phases. Recall that normalization rules translate &language; syntax
  into Core syntax. In the sections that contain normalization rules,
  the Core grammar productions into which the expression is normalized
  are also provided. After normalization, sections on static type
  inference and dynamic evaluation define the static type and dynamic
  value for the Core expression.</p>

  <smcore>
    <p>The Core grammar productions for expressions are:</p>

    <scrap><head></head>
      <prodrecap id="core-Expr" ref="Expr" orig="core"/>
      <prodrecap id="core-ExprSingle" ref="ExprSingle" orig="core"/>
    </scrap>
  </smcore>

  <smtype>
    <p>During static analysis, it is a type error for an expression to have the empty
    type, except for the following expressions and function calls:

    <ulist>
      <item><p>Empty parentheses <code>()</code>, which denote the
      empty sequence.</p></item>
      <item><p>The &fn_data; function and all functions in the
      <emph>fs</emph> namespace applied to empty
      parentheses <code>()</code>.</p></item>
      <item><p>Any function which returns the empty type.</p></item>
    </ulist>

    The reason for these exceptions is that they are typically part of
    the result of normalizing a larger user-level expression and are
    used to capture the semantics of the user-level expression when
    applied to the empty sequence.</p>

    <p>The rule below enforces the above constraints. It is a static
    type error, if the following conditions hold for a given
    expression &gr_Expr;.</p>

      <infergr>
    	<infer>
          <prejudge>
 	    <multiclause>
 	      <clause><environment>&xq_stat_env;</environment>
 		      <expression>&gr_Expr; &jd_has_type; &gr_Type;</expression>
 	      </clause>
 	    </multiclause>
 	    <multiclause>
              <clause><environment>&xq_stat_env;</environment>
 		      <expression>&gr_Type; &jd_subtype_of; &xt_empty;</expression></clause>
 	    </multiclause>
 	    <multiclause>
              <clause><expression>&jd_not;(&gr_Expr; is the empty
              parentheses () or &fn_data; or any <emph>fs</emph>
              function applied to empty parentheses ())</expression></clause>
 	    </multiclause>
          </prejudge>
 	  <postjudge>
 	    <multiclause>
              <clause>
               <expression>A static type error is raised for expression &gr_Expr;</expression>
              </clause>
 	    </multiclause>
 	  </postjudge>
    	</infer>
      </infergr>

      <p>In general, static type errors are raised whenever there
      <phrase diff='del' at='E046'>is</phrase>
      <phrase diff='add' at='E046'>are</phrase>
      no static typing rules which can compute the type of a given
      expression. This is the reason for the absence of a formal
      <phrase diff='del' at='E046'>post-condition</phrase>
      <phrase diff='add' at='E046'>conclusion</phrase>
      in this
      <phrase diff='del' at='E046'>rules</phrase>
      <phrase diff='add' at='E046'>rule</phrase>.
      There is indeed a rule that infers
      the type for expression &gr_Expr;, however the inferred type is
      empty and still a static type error must be raised.</p>

      <smexample>
        <p>The above rule is useful in catching common mistakes, such
        as the misspelling of an element or attribute name or
        referencing of an element or attribute that does not
        exist. For instance, the following path expression</p>
<eg><![CDATA[  $x/title
]]></eg>
    <p>raises a static type error if the type of variable
    <code>$x</code> does not include any
    <code>title</code> children elements.</p>
  </smexample>
  </smtype>

  <!-- ***************** Primary expressions              ****** -->

  <div2  id="id-primary-expressions">
    <head>Primary Expressions</head>
  
    <p><term>Primary expressions</term> are the basic primitives of
    the language. They include literals, variables, function calls,
    and the parenthesized expressions.</p>

    <scrap>
      <head>Primary Expressions</head>
      <prodrecap id="PrimaryExpr" ref="PrimaryExpr" orig="xquery"/>
    </scrap>

    <smcore>
      <p>The Core grammar production for primary expressions is:</p>
  
      <scrap>
        <head>Primary Expressions</head>
        <prodrecap id="core-PrimaryExpr" ref="PrimaryExpr" orig="core"/>
      </scrap>
    </smcore>

    <div3 id="id-literals">
      <head>Literals</head>

      <smintro>
        <p>A <term>literal</term> is a direct syntactic representation
        of an atomic value.  &language; supports two kinds of literals:
        string literals and numeric literals.</p>
      </smintro>

<scrap>
  <head>Literals</head>
  <prodrecap id="Literal"             ref="Literal"             orig="xquery"/>
  <prodrecap id="NumericLiteral"      ref="NumericLiteral"      orig="xquery"/>
  <prodrecap id="IntegerLiteral"      ref="IntegerLiteral"      orig="xquery"/>
  <prodrecap id="DecimalLiteral"      ref="DecimalLiteral"      orig="xquery"/>
  <prodrecap id="DoubleLiteral"       ref="DoubleLiteral"       orig="xquery"/>
  <prodrecap id="StringLiteral"       ref="StringLiteral"       orig="xquery"/>
  <prodrecap id="URILiteral"          ref="URILiteral"          orig="xquery"/>
  <prodrecap id="PredefinedEntityRef" ref="PredefinedEntityRef" orig="xquery"/>
  <prodrecap id="Digits"              ref="Digits"              orig="xquery"/>
</scrap>

      <smcore>
        <p>The Core grammar productions for literals are:</p>

<scrap>
  <head>Literals</head>

  <prodrecap id="core-Literal"             ref="Literal"             orig="core"/>
  <prodrecap id="core-NumericLiteral"      ref="NumericLiteral"      orig="core"/>
  <prodrecap id="core-IntegerLiteral"      ref="IntegerLiteral"      orig="core"/>
  <prodrecap id="core-DecimalLiteral"      ref="DecimalLiteral"      orig="core"/>
  <prodrecap id="core-DoubleLiteral"       ref="DoubleLiteral"       orig="core"/>
  <prodrecap id="core-StringLiteral"       ref="StringLiteral"       orig="core"/>
  <prodrecap id="core-URILiteral"          ref="URILiteral"          orig="core"/>
  <prodrecap id="core-Digits"              ref="Digits"              orig="core"/>
</scrap>
      </smcore>

      <smnotation>
         <p>To define the dynamic semantics of literals, we introduce
         the following auxiliary judgments.</p>

        <p id="jd_has_atomic_value">The judgment</p>
        <display>
          <clause>
          <environment>&xq_dyn_env;</environment>
          <expression>&gr_Literal; &jd_has_atomic_value; &gr_AtomicValue;</expression>
          </clause>
        </display>

          <p>holds if the literal expression &gr_Literal; corresponds
          to the value &gr_AtomicValue;. This judgment yields an
          atomic value, according to the rules described in <bibref
          ref="xquery-30"/>. Notably, this judgment deals with handling
          of literal overflows for numeric literals, and handling of
          character references, and predefined entity references for
          string literals.</p> </smnotation>

      <smnorm>
        <p>Literals are left unchanged through normalization.</p>

        <mapping>
         <xquery>
          <expression>
           <map>&gr_IntegerLiteral;</map>&jd_map_expr;
          </expression>
         </xquery>
         <core>
          <expression>
            &gr_IntegerLiteral;
          </expression>
         </core>
        </mapping>

        <mapping>
         <xquery>
          <expression>
           <map>&gr_DecimalLiteral;</map>&jd_map_expr;
          </expression>
         </xquery>
         <core>
          <expression>
            &gr_DecimalLiteral;
          </expression>
         </core>
        </mapping>

        <mapping>
         <xquery>
          <expression>
           <map>&gr_DoubleLiteral;</map>&jd_map_expr;
          </expression>
         </xquery>
         <core>
          <expression>
            &gr_DoubleLiteral;
          </expression>
         </core>
        </mapping>

        <mapping>
         <xquery>
          <expression>
           <map>&gr_StringLiteral;</map>&jd_map_expr;
          </expression>
         </xquery>
         <core>
          <expression>
            &gr_StringLiteral;
          </expression>
         </core>
        </mapping>
      </smnorm>

      <smtype>
        <p>The static type of a literal expression is its
        corresponding atomic type.</p>

	<infergr>
	  <infer>
	    <postjudge>
	      <multiclause>
		<clause><environment> &xq_stat_env;</environment>
			<expression>&gr_IntegerLiteral; &jd_has_type; xs:integer</expression>
		</clause>
	      </multiclause>
	    </postjudge>
	  </infer>
	</infergr>

	<infergr>
	  <infer>
	    <postjudge>
	      <multiclause>
		<clause><environment>&xq_stat_env;</environment>
		<expression>&gr_DecimalLiteral; &jd_has_type; xs:decimal</expression>
		</clause>
	      </multiclause>
	    </postjudge>
	  </infer>
	</infergr>

        <infergr>
          <infer>
            <postjudge>
              <multiclause>
                <clause><environment>&xq_stat_env;</environment>
                <expression>&gr_DoubleLiteral; &jd_has_type; xs:double</expression>
                </clause>
              </multiclause>
            </postjudge>
          </infer>
        </infergr>

        <infergr>
          <infer>
            <postjudge>
              <multiclause>
                <clause><environment>&xq_stat_env;</environment>
                <expression>&gr_StringLiteral; &jd_has_type; xs:string</expression>
                </clause>
              </multiclause>
            </postjudge>
          </infer>
        </infergr>
      </smtype>

      <smeval>
        <p>In the dynamic semantics, a literal is evaluated by
        constructing an atomic value in the data model, using the
        &jd_has_atomic_value; judgment defined above.</p>

	<infergr>
	  <infer>
 	    <prejudge>
 	      <multiclause>
 	        <clause>
                <environment>&xq_dyn_env;</environment>
 	        <expression>&gr_Literal; &jd_has_atomic_value; &gr_AtomicValue;
 	        </expression>
 	        </clause>
 	      </multiclause>
 	    </prejudge>
	    <postjudge>
	      <multiclause>
		<clause><environment> &xq_dyn_env;</environment>
			<expression>&gr_Literal; &jd_yields; &gr_AtomicValue;</expression>
		</clause>
	      </multiclause>
	    </postjudge>
	  </infer>
	</infergr>
      </smeval>

  </div3>

  <div3 id="id-variables">
    <head>Variable References</head>

    <smintro>
      <p>A <term>variable</term> evaluates to the value to which the
      variable's QName is bound in the <term>dynamic
      context</term>.</p>
    </smintro>

    <scrap>
      <head>Variable References</head>
      <prodrecap id="VarRef"     ref="VarRef"     orig="xquery"/>
      <prodrecap id="VarName"    ref="VarName"     orig="xquery"/>
    </scrap>

    <smcore>
      <p>The Core grammar productions for variable references are:</p>
  
      <scrap>
        <head>Primary Expressions</head>
        <prodrecap id="core-VarRef"  ref="VarRef"  orig="core"/>
        <prodrecap id="core-VarName" ref="VarName" orig="core"/>
      </scrap>
    </smcore>

    <smnorm>
      <p>Variable references are left unchanged through
      normalization.</p>

      <mapping>
       <xquery>
        <expression>
         <map>&gr_VarRef;</map>&jd_map_expr;
        </expression>
       </xquery>
       <core>
        <expression>
          &gr_VarRef;
        </expression>
       </core>
      </mapping>
    </smnorm>

    <smtype>
      <p>In the static semantics, the type of a variable is simply its
      type in the static environment &xq_type_env;:</p>

      <infergr>
    	<infer>
 	  <prejudge>
 	    <multiclause>
 	      <clause>
              <environment>&xq_stat_env;</environment>
 	      <expression>&gr_VarName; &jd_var_qname_expands_to; &gr_Variable;
 	      </expression>
 	      </clause>
 	    </multiclause>
 	    <multiclause>
 	      <clause>
 	      <expression>&xq_type_env;(&gr_Variable;) = &gr_Type;</expression>
 	      </clause>
 	    </multiclause>
 	  </prejudge>
 	  <postjudge>
 	    <multiclause>
 	      <clause><environment>&xq_stat_env;</environment>
 		      <expression>&gr_DVarName; &jd_has_type; &gr_Type;</expression>
 	      </clause>
 	    </multiclause>
 	  </postjudge>
    	</infer>
      </infergr>

      <p>If the variable is not bound in the static environment, a
      static type error is raised.</p>
    </smtype>

    <smeval>
      <p>In the dynamic semantics, a locally declared variable is
      evaluated by "looking up" its value in &xq_val_env;:</p>
    
      <infergr>
    	<infer>
 	  <prejudge>
 	    <multiclause>
 	      <clause>
              <environment>&xq_stat_env;</environment>
 	      <expression>&gr_VarName; &jd_var_qname_expands_to; &gr_Variable;
 	      </expression>
 	      </clause>
 	    </multiclause>
 	    <multiclause>
 	      <clause>
 		<expression>&xq_val_env;(&gr_Variable;) = &gr_Value;</expression>
 	      </clause>
 	    </multiclause>
 	  </prejudge>
 	  <postjudge>
 	    <multiclause>
 	      <clause><environment>&xq_dyn_env;</environment>
 		      <expression>&gr_DVarName; &jd_yields; &gr_Value;</expression>
 	      </clause>
 	    </multiclause>
 	  </postjudge>
    	</infer>
      </infergr>

      <p>In the dynamic semantics, a reference to a variable imported
      from a module is evaluated by accessing the dynamic context of
      the module in which the variable is declared.</p>

      <p>The notation &gr_URI; &jd_module_dynEnv; &xq_dyn_env1; is
      used to access a module context and is defined in <specref
      ref="id-module-declaration"/>.</p>

      <infergr>
    	<infer>
 	  <prejudge>
 	    <multiclause>
 	      <clause>
              <environment>&xq_stat_env;</environment>
 	      <expression>&gr_VarName; &jd_var_qname_expands_to; &gr_Variable;</expression>
 	      </clause>
 	    </multiclause>
 	    <multiclause>
 	      <clause>
 		<expression>&xq_val_env;(&gr_Variable;) = <code>#IMPORTED</code>(&gr_URI;)</expression>
 	      </clause>
 	    </multiclause>
 	    <multiclause>
 	      <clause>
 	      <expression>&gr_URI; &jd_module_dynEnv; &xq_dyn_env1;</expression>
 	      </clause>
 	    </multiclause>
 	    <multiclause>
 	      <clause>
 		<expression>&xq_val_env1;(&gr_Variable;) = &gr_Value;</expression>
 	      </clause>
 	    </multiclause>
 	  </prejudge>
 	  <postjudge>
 	    <multiclause>
 	      <clause><environment>&xq_dyn_env;</environment>
 		      <expression>&gr_DVarName; &jd_yields; &gr_Value;</expression>
 	      </clause>
 	    </multiclause>
 	  </postjudge>
    	</infer>
      </infergr>
    </smeval>

  </div3>

  <div3 id="id-paren-expressions">
    <head>Parenthesized Expressions</head>

    <scrap> 
      <head/>
      <prodrecap id="ParenthesizedExpr" ref="ParenthesizedExpr" orig="xquery"/> 
    </scrap>

    <smcore>
      <p>The Core grammar production for parenthesized expressions is:</p>

      <scrap>
        <head/>
        <prodrecap id="core-ParenthesizedExpr" ref="ParenthesizedExpr" orig="core"/> 
      </scrap>
    </smcore>

    <p>Empty parentheses <code>()</code> always have the empty
    type. Remember that it is a static type error for most expressions
    other than <code>()</code> to have the empty type (see <specref
    ref="id-expressions"/> for the complete rule.)</p>

    <smtype>
      <infergr>
    	<infer>
 	  <postjudge>
 	    <multiclause>
 	      <clause><environment>&xq_stat_env;</environment>
 		      <expression>() &jd_has_type; &xt_empty;</expression>
 	      </clause>
 	    </multiclause>
 	  </postjudge>
    	</infer>
      </infergr>

      <infergr>
    	<infer>
 	  <prejudge>
 	    <multiclause>
 	      <clause><environment>&xq_stat_env;</environment>
 	      <expression>&gr_Expr; &jd_has_type; &gr_Type;</expression>
 	      </clause>
 	    </multiclause>
 	  </prejudge>
 	  <postjudge>
 	    <multiclause>
 	      <clause><environment>&xq_stat_env;</environment>
 		      <expression>( &gr_Expr; ) &jd_has_type; &gr_Type;</expression>
 	      </clause>
 	    </multiclause>
 	  </postjudge>
    	</infer>
      </infergr>
    </smtype>

    <smeval>
      <p>Empty parentheses <code>()</code> evaluate to the empty
      sequence.</p>

      <infergr>
    	<infer>
 	  <postjudge>
 	    <multiclause>
 	      <clause><environment>&xq_dyn_env;</environment>
 		      <expression>() &jd_yields; ()</expression>
 	      </clause>
 	    </multiclause>
 	  </postjudge>
    	</infer>
      </infergr>

      <infergr>
    	<infer>
 	  <prejudge>
 	    <multiclause>
 	      <clause><environment>&xq_dyn_env;</environment>
 	      <expression>&gr_Expr; &jd_yields; &gr_Value;</expression>
 	      </clause>
 	    </multiclause>
 	  </prejudge>
 	  <postjudge>
 	    <multiclause>
 	      <clause><environment>&xq_dyn_env;</environment>
 		      <expression>( &gr_Expr; ) &jd_yields; &gr_Value;</expression>
 	      </clause>
 	    </multiclause>
 	  </postjudge>
    	</infer>
      </infergr>
    </smeval>

  </div3>

         <div3 id="id-context-item-expression">
           <head>Context Item Expression</head>

           <scrap> <head/><prodrecap id="ContextItemExpr"
           ref="ContextItemExpr" orig="xquery"/> </scrap>

           <smintro>
             <p>A <term>context item expression</term> evaluates to
             the context item, which may be either a node or an atomic
             value.</p>
           </smintro>

         <smnorm>
           <p>A context item expression is normalized to the built-in
           variable &fs_dot;. Because it can only be bound through the
           external context or a path expression, there is no need for
           a specific static typing rule to enforce that its value is
           a singleton item.</p>

           <mapping>
            <xquery>
              <expression><map>.</map>&jd_map_expr;</expression>
            </xquery>
            <core>
              <expression>&fs_dot;</expression>
            </core>
           </mapping>
         </smnorm>

         </div3>

  <div3 id="id-function-calls">
    <head>Function Calls</head>

    <smintro>
      <p>A function call consists of a QName followed by a
      parenthesized list of zero or more expressions.  In &language;,
      the actual argument to a function is called an
      <term>argument</term> and the formal argument of a function is
      called a <term>parameter</term>.  We use the same terminology
      here. </p>
      
      <scrap>
        <head>Function Calls</head>
        <prodrecap id="FunctionCall" ref="FunctionCall" orig="xquery"/>
      </scrap>

      <p>Because &language; implicitly converts the values of function
      arguments, a normalization step is required.</p>
    </smintro>

    <smcore>
      <p>The Core grammar production for function calls is:</p>

      <scrap>
        <head>Function Calls</head>
        <prodrecap id="core-FunctionCall" ref="FunctionCall" orig="core"/>
      </scrap>
    </smcore>
 
    <smnotation>
      <p id="jd_map_function_argument">Normalization of function calls
      uses an auxiliary mapping <map></map>&jd_map_function_argument;
      used to insert conversions of function arguments that depend
      only on the expected &gr_Type; of the corresponding
      parameters. It is defined as follows:</p>

      <mapping>
       <xquery>
         <expression><map>&gr_Expr;</map>&jd_map_function_argument;</expression>
       </xquery>
       <core>
         <expression><map><map><map>&gr_Expr;</map>&jd_map_expr;</map>&jd_map_atomize_atomic;</map>&jd_map_convert;</expression>
       </core>
      </mapping>

      <p>where</p>

        <ulist>

          <item>
            <p><map>&gr_Expr;</map>&jd_map_atomize_atomic; denotes</p>
            <table summary="">
              <tbody>
                <tr>
                  <td>If
                  </td>

                  <td>&gr_Type; &jd_subtype_of; &xs_anyAtomicType;*</td>
                </tr>
                <tr>
                  <td>Then</td>
                  <td>&fn_data;(&gr_Expr;)</td><td>&nbsp;&nbsp;</td>
                </tr>
                <tr>
                  <td>Else</td>
                  <td>&gr_Expr;</td><td>&nbsp;&nbsp;</td>
                </tr>
              </tbody>
            </table>

            <p>which specifies that if the function expects atomic
            parameters, then &fn_data; is called to obtain them.</p>
          </item>

          <item>
            <p><map>&gr_Expr;</map>&jd_map_convert; denotes</p>
            <table summary="">
              <tbody>
                <tr>
                  <td>If</td>
                  <td>&gr_Type; &jd_subtype_of; &xs_anyAtomicType;*</td>
                </tr>
                <tr>
                  <td>Then</td>
                  <td>&fs_convert_simple_argument;(&gr_Expr;,<emph>PrototypicalValue</emph>)</td>
                </tr>
                <tr>
                  <td>Else</td>
                  <td>&gr_Expr;</td>
                </tr>
              </tbody>
            </table>

          <p>where <emph>PrototypicalValue</emph> is a built-in atomic
          value used to encode the expected atomic type (for instance
          the value <code>1.0</code> if the expected type is
          &xs_decimal;). A value is used here since &language;
          expressions cannot operate directly on types. Which value is
          chosen does not have any impact on the actual semantics,
          only its actual atomic type matters.</p>
        </item>
      </ulist>

    </smnotation>

      <smnote>
        <p>The &fs_convert_simple_argument; function takes a
        <emph>PrototypicalValue</emph>, which is a value of the target
        type, to ensure that conversion to base types is possible even
        though types are not first class objects in &language;. Also,
        note that in the case of built-in functions where the expected
        type is specified as numeric, the prototypical value is a
        value of type &xs_double;.</p>
      </smnote>

      <smnorm>
        <p>Each argument expression in a function call is normalized
        to its corresponding Core expression by applying
        <map></map>&jd_map_function_argument;
        <phrase diff='del' at='E047'>for each argument</phrase>
        <phrase diff='del' at='E047'>
        with
        the expected &gr_SequenceType; for the argument inserted.
        </phrase>
        <phrase diff='add' at='E047'>
        where &gr_Type; is the corresponding parameter type.
        </phrase>
        </p>

         <infergr>
          <infer>
           <prejudge>
            <multiclause>
              <clause><environment>&xq_stat_env;</environment>
                <expression>&gr_QName; &jd_func_qname_expands_to; &xd_qname;</expression>
              </clause>
            </multiclause>
            <multiclause>
             <clause diff='chg' at='E008'>
              <environment>&xq_stat_env;</environment>
              <expression>
                &jd_not;(&xd_qname; &jd_denotes_a_constructor_function;)
              </expression>
             </clause>
            </multiclause>
            <multiclause>
              <clause>
                <expression>&xq_functy_env;(&xd_qname;,n) =
                  declare function &xd_qname;(&gr_Type1;, ..., &gr_Typen;) as &gr_Type;
                </expression>
              </clause>
            </multiclause>
           </prejudge>
          <postjudge>
           <clause>
            <environment>&xq_stat_env;</environment>
            <expression>
              <map>&gr_QName; (&gr_Expr1;, ..., &gr_Exprn;)</map>&jd_map_expr;
              =
              &gr_QName;
              ( <map>&gr_Expr1;</map>&jd_map_function_argument1;, ...,
                <map>&gr_Exprn;</map>&jd_map_function_argumentn; )
            </expression>
           </clause>
          </postjudge>
         </infer>
         </infergr>

        <mapping diff='del' at='E047'>
          <xquery>
            <expression>
              
            </expression>
          </xquery>
          <core>
            <expression>
              &gr_QName;
              ( <map>&gr_Expr1;</map>&jd_map_function_argument1;, ...,
                <map>&gr_Exprn;</map>&jd_map_function_argumentn; )
            </expression>
          </core>
        </mapping>

        <p>Note that this normalization rule depends on the function
        <phrase diff='del' at='E047'>signatures,</phrase>
        <phrase diff='add' at='E047'>signature (found in &xq_functy_env;),</phrase>
        which is used to get the types of the function
        parameters
        <phrase diff='del' at='E047'>(&gr_SequenceType1;,...,&gr_SequenceTypen;)</phrase>
        <phrase diff='add' at='E047'>(&gr_Type1;, ..., &gr_Typen;)</phrase>.
        <phrase diff='del' at='E047'>
        For
        user-defined functions, the function signature can be obtained
        from the XQuery prolog where the function is declared.  For
        built-in functions, the signature is given in the
        &xq_functions; document. For overloaded built-in functions,
        several signatures may exists, however, because they all
        correspond to sequences of atomic values, they all result in
        the same normalization.</phrase></p>
      </smnorm>

      <smtype>
        <p>Different sets of static typing rules are used to type
        check function calls depending on which of the following
        categories
        <phrase diff='del' at='E048'>the</phrase>
        <phrase diff='add' at='E048'>they</phrase>
        belong to: overloaded internal functions,
        built-in functions with a specific static typing rule, and
        other built-in and user-defined functions.</p>

        <p>The following two rules
        <phrase diff='del' at='E048'>
        are common to all those categories,
        and are used to bootstrap type inference, by first looking-up
        the expanded QName for the function, then applying the
        appropriate set of static typing rules depending on the
        category in which the function is.
        </phrase>
        <phrase diff='add' at='E048'>
        factor out the step
        (common to all those categories)
        of translating
        a type-inference judgment
        on syntactic objects (&gr_QName; and &gr_Expri;)
        into a type-inference judgment
        on semantic objects (&xd_qname; and &gr_Typei;).
        </phrase>
        </p>

        <infergr>
          <infer>
            <prejudge>
              <multiclause>
                <clause><environment>&xq_stat_env;</environment>
                  <expression>&gr_QName;
                  &jd_func_qname_expands_to; &xd_qname;</expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause><environment>&xq_stat_env; </environment>
                  <expression>
                    &xd_qname;() &jd_has_type; &gr_Type;
                  </expression>
                </clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <multiclause>
                <clause><environment>&xq_stat_env; </environment>
                  <expression>
                    &gr_QName;() &jd_has_type; &gr_Type;
                  </expression>
                </clause>
              </multiclause>
            </postjudge>
          </infer>
        </infergr>

        <infergr>
          <infer>
            <prejudge>
              <multiclause>
                <clause><environment>&xq_stat_env;</environment>
                  <expression>&gr_QName;
                  &jd_func_qname_expands_to; &xd_qname;</expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause><environment>&xq_stat_env;</environment> 
                  <expression>
                    &gr_Expr1; &jd_has_type; &gr_Type1;
                  </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <expression>
                    ...
                  </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause><environment>&xq_stat_env;</environment> 
                  <expression>
                    &gr_Exprn; &jd_has_type; &gr_Typen;
                  </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause><environment>&xq_stat_env; </environment>
                  <expression>
                    &xd_qname;(&gr_Type1;,...,&gr_Typen;) &jd_has_type; &gr_Type;
                  </expression>
                </clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <multiclause>
                <clause><environment>&xq_stat_env; </environment>
                  <expression>
                    &gr_QName; (&gr_Expr1;,...,&gr_Exprn;) &jd_has_type; &gr_Type;
                  </expression>
                </clause>
              </multiclause>
            </postjudge>
          </infer>
        </infergr>

        <p>The following depends on the kind of function call.</p>

        <olist>
          <item>
            <p>If the expanded QName for the function corresponds to
            one of the overloaded internal <emph>fs:</emph> functions
            listed in <specref ref="sec_operators"/>, the static
            typing rules in <specref ref="sec_operators"/> are
            applied.</p>
          </item>
          <item>
            <p>If the expanded QName for the function corresponds to
            one of the built-in functions with a specialized static
            typing rule, listed in <specref
            ref="sec_special_functions"/>, the static typing rules in
            <specref ref="sec_special_functions"/> are applied.</p>
          </item>
          <item><p>Otherwise, the following general static typing
            rules are applied.</p></item>
        </olist>

        <p>
        <phrase diff='add' at='E048'>
        Recall that &xq_functy_env; contains
        at most one function signature
        for any given (function name, arity) pair.
        </phrase>
        The two following rules look up the function in the static
        environment and check that
        <phrase diff='del' at='E048'>
        some signature for the function
        satisfies the following constraint: the type of each actual
        argument is a subtype of some type that
        </phrase>
        <phrase diff='add' at='E048'>
        the type of each actual argument
        </phrase>
        can be promoted to the
        type of the corresponding function parameter.  In this case,
        the function call is well typed and the result type is the
        return type specified in the function's signature. </p>

        <infergr>
          <infer>
            <prejudge>
              <multiclause>
                <clause>
                  <expression>&xq_functy_env;(&xd_qname;,0) =
                    declare function &xd_qname;() as &gr_Type;'
                  </expression>
                </clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <multiclause>
                <clause><environment>&xq_stat_env; </environment>
                  <expression>
                    &xd_qname;() &jd_has_type; &gr_Type;'
                  </expression>
                </clause>
              </multiclause>
            </postjudge>
          </infer>
        </infergr>

        <infergr>
          <infer>
            <prejudge>
              <multiclause>
                <clause>
                  <expression>&xq_functy_env;(&xd_qname;,n) =
                    declare function &xd_qname;(&gr_Type1;', ..., &gr_Typen;') as &gr_Type;'
                  </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause><environment> &xq_stat_env; </environment>
                        <expression>&gr_Type1; &jd_can_be_promoted_to; &gr_Type1;'</expression></clause>
              </multiclause>
              <multiclause>
                <clause><expression>...</expression></clause>
              </multiclause>
              <multiclause>
                <clause><environment> &xq_stat_env; </environment>
                        <expression>&gr_Typen; &jd_can_be_promoted_to; &gr_Typen;'</expression></clause>
              </multiclause>

            </prejudge>
            <postjudge>
              <multiclause>
                <clause><environment>&xq_stat_env; </environment>
                  <expression>
                    &xd_qname;(&gr_Type1;, ..., &gr_Typen;) &jd_has_type; &gr_Type;'
                  </expression>
                </clause>
              </multiclause>
            </postjudge>
          </infer>
        </infergr>

        <p>The function body itself is not analyzed for each
        invocation: static typing of the function definition itself
        guarantees that the function body always returns a value of
        the declared return type.</p>

        <p diff='del' at='E048'>Notice that the static context contains at most one
        function declaration for each function. This is possible since
        the treatment of overloaded operators is done through a set of
        specific static typing rules which do not require access to
        the environment. See <specref ref="sec_operators"/>.</p>
      </smtype>

      <smnotation>
        <p id="jd_function_with_types">The following auxiliary
        judgment</p>

        <display>
         <clause>
          <environment>&xq_dyn_env;</environment>
          <expression>
           &jd_function_with_types; &xd_qname;
           &jd_function_with_types_with;
           &jd_function_with_types_on_values;
           &jd_function_with_types_yields; &gr_Value;
          </expression>
         </clause>
        </display>

        <p>holds when applying the function with expanded QName
        &xd_qname; and no parameter yields the value &gr_Value;.</p>

        <display>
         <clause>
          <environment>&xq_dyn_env;</environment>
          <expression>
           &jd_function_with_types; &xd_qname;
           &jd_function_with_types_with; (&gr_Type1;,...,&gr_Typen;)
           &jd_function_with_types_on_values;
           (&gr_Value1;,...,&gr_Valuen;)
           &jd_function_with_types_yields; &gr_Value;
          </expression>
         </clause>
        </display>

        <p>holds when applying the function with expanded QName
        &xd_qname;, and parameters of type (&gr_Type1;,...,&gr_Typen;)
        on the values (&gr_Value1;,...,&gr_Valuen;) yields the value
        &gr_Value;.</p>

        <p>That judgment is defined below for each kind of function
        (user-defined, built-in, external, and imported
        functions).</p>
      </smnotation>

      <smeval>
        <p>The following rules apply to all the different kinds of
        functions using the previously defined judgment.</p>

    <infergr>
     <infer>
      <prejudge>
       <multiclause>
        <clause><environment>&xq_stat_env;</environment>
         <expression>&gr_QName; &jd_func_qname_expands_to; &xd_qname;</expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause>
         <expression>&xq_functy_env;(&xd_qname;<phrase diff='chg' at='E006'>,0</phrase>) = &gr_FunctionSig;
         </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause>
         <expression>
          &gr_FunctionSig;
          =
          declare function &xd_qname;() as &gr_Type;
         </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause><environment>&xq_dyn_env;</environment>
         <expression>
           &jd_function_with_types; &xd_qname;
           &jd_function_with_types_with;
           &jd_function_with_types_on_values;
           &jd_function_with_types_yields; &gr_Value;
         </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause><environment>&xq_stat_env;</environment>
         <expression>&gr_Value; &jd_promotes_against; &gr_Type; &jd_promotes_to; &gr_Value;'</expression>
        </clause>
       </multiclause>
      </prejudge>
      <postjudge>
       <multiclause>
        <clause><environment>&xq_dyn_env; </environment>
         <expression>
          &gr_QName;() &jd_yields; &gr_Value;'
         </expression>
        </clause>
       </multiclause>
      </postjudge>
     </infer>
    </infergr>

    <infergr>
     <infer>
      <prejudge>
       <multiclause>
        <clause><environment>&xq_dyn_env;</environment>
         <expression>
          &gr_Expr1; &jd_yields; &gr_Value1;
         </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause><expression>...</expression></clause>
       </multiclause>
       <multiclause>
        <clause><environment>&xq_dyn_env;</environment>
         <expression>
          &gr_Exprn; &jd_yields; &gr_Valuen;
         </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause><environment>&xq_stat_env;</environment>
         <expression>&gr_QName; &jd_func_qname_expands_to; &xd_qname;</expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause>
         <expression>&xq_functy_env;(&xd_qname;<phrase diff='chg' at='E006'>,n</phrase>) = &gr_FunctionSig;
         </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause>
         <expression>
          &gr_FunctionSig;
          =
          declare function &xd_qname;(&gr_Type1;, ..., &gr_Typen;) as &gr_Type;
         </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause><environment>&xq_stat_env;</environment>
         <expression>
          &gr_Value1; &jd_promotes_against; &gr_Type1; &jd_promotes_to; &gr_Value1;'
         </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause><expression>...</expression></clause>
       </multiclause>
       <multiclause>
        <clause><environment>&xq_stat_env;</environment>
         <expression>
          &gr_Valuen; &jd_promotes_against; &gr_Typen; &jd_promotes_to; &gr_Valuen;'
         </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause><environment>&xq_dyn_env;</environment>
         <expression>
           &jd_function_with_types; &xd_qname;
           &jd_function_with_types_with; (&gr_Type1;,...,&gr_Typen;)
           &jd_function_with_types_on_values;
           (&gr_Value1;',...,&gr_Valuen;')
           &jd_function_with_types_yields; &gr_Value;
         </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause><environment>&xq_stat_env;</environment>
         <expression>&gr_Value; &jd_promotes_against; &gr_Type; &jd_promotes_to; &gr_Value;'</expression>
        </clause>
       </multiclause>
      </prejudge>
      <postjudge>
       <multiclause>
        <clause><environment>&xq_dyn_env; </environment>
         <expression>
          &gr_QName; ( &gr_Expr1;, ...,  &gr_Exprn; ) &jd_yields; &gr_Value;'
         </expression>
        </clause>
       </multiclause>
      </postjudge>
     </infer>
    </infergr>

    <p>First the function name is expanded, and the expanded name is
    used to retrieve the function signature from the static
    environment. Then, the rule evaluates each function argument
    expression, and the resulting values are promoted according to the
    expected type for the function. The result of evaluating the
    function is obtained through the auxiliary judgment previously
    defined, and the resulting value is promoted according to the
    expected return type.</p>

    <p>In case the function is a user defined function in a main
    module, the expression body is retrieved from the dynamic
    environment and used to compute the value of the function. The
    rule extends &xq_val_env; by binding each formal variable to its
    corresponding value, and evaluates the body of the function in the
    new environment. The resulting value is the value of the function
    call.</p>

    <p>The notation &gr_URI; &jd_module_dynEnv; &xq_dyn_env1; is used
    to access a module context and is defined in <specref
    ref="id-module-declaration"/>.</p>

    <infergr>
     <infer>
      <prejudge>
       <multiclause>
        <clause>
         <expression>
          &xq_func_env;(&xd_qname;<phrase diff='chg' at='E006'>,0</phrase>)
          =
          (&gr_Expr;)
         </expression>
        </clause>
       </multiclause>
       <multiclause>
 	<clause>
 	 <expression>#MAIN &jd_module_dynEnv; &xq_dyn_env1;</expression>
 	</clause>
       </multiclause>
       <multiclause>
        <clause>
         <environment>
           <phrase diff='del' at='E049'>&xq_val_env1;</phrase>
           <phrase diff='add' at='E049'>&xq_dyn_env1;</phrase>
         </environment>
         <expression>&gr_Expr; &jd_yields; &gr_Value; </expression>
        </clause>
       </multiclause>
      </prejudge>
      <postjudge>
       <multiclause>
        <clause><environment>&xq_dyn_env;</environment>
         <expression>
           &jd_function_with_types; &xd_qname;
           &jd_function_with_types_with;
           &jd_function_with_types_on_values;
           &jd_function_with_types_yields; &gr_Value;
         </expression>
        </clause>
       </multiclause>
      </postjudge>
     </infer>
    </infergr>

    <infergr>
     <infer>
      <prejudge>
       <multiclause>
        <clause>
         <expression>
          &xq_func_env;(&xd_qname;<phrase diff='chg' at='E006'>,n</phrase>)
          =
          (&gr_Expr;, &gr_Variable1;, ... , &gr_Variablen;)
         </expression>
        </clause>
       </multiclause>
       <multiclause>
 	<clause>
 	 <expression>#MAIN &jd_module_dynEnv; &xq_dyn_env1;</expression>
 	</clause>
       </multiclause>
       <multiclause>
        <clause>
         <environment>
          <update>
           <environment>&xq_val_env1;</environment>
           <expression>
            &gr_Variable1; &xt_bind; &gr_Value1;;
            ...;
            &gr_Variablen; &xt_bind; &gr_Valuen;</expression>
          </update>
         </environment>
         <expression>&gr_Expr; &jd_yields; &gr_Value; </expression>
        </clause>
       </multiclause>
      </prejudge>
      <postjudge>
       <multiclause>
        <clause><environment>&xq_dyn_env;</environment>
         <expression>
           &jd_function_with_types; &xd_qname;
           &jd_function_with_types_with; (&gr_Type1;,...,&gr_Typen;)
           &jd_function_with_types_on_values;
           (&gr_Value1;,...,&gr_Valuen;)
           &jd_function_with_types_yields; &gr_Value;
         </expression>
        </clause>
       </multiclause>
      </postjudge>
     </infer>
    </infergr>

    <p>Note that the function body is evaluated in the dynamic
    environment containing the main module declarations.</p>

    <p>The rule for evaluating
    <phrase diff='del' at='E049'>an</phrase>
    <phrase diff='add' at='E049'>a</phrase>
    function imported from a module is
    similar to that for evaluating a user-defined function in a main
    module, except that the function call is evaluated in the dynamic
    context of the module in which it is declared, and that the
    appropriate additional type matching must be performed.</p>

    <infergr>
     <infer>
      <prejudge>
       <multiclause>
        <clause>
         <expression>
          &xq_func_env;(&xd_qname;<phrase diff='chg' at='E006'>,0</phrase>)
          = <code>#IMPORTED</code>(&gr_URI;)
         </expression>
        </clause>
       </multiclause>
       <multiclause>
 	<clause>
 	 <expression>&gr_URI; &jd_module_statEnv; &xq_stat_env1;</expression>
 	</clause>
       </multiclause>
       <multiclause>
 	<clause>
 	 <expression>&gr_URI; &jd_module_dynEnv; &xq_dyn_env1;</expression>
 	</clause>
       </multiclause>
       <multiclause>
        <clause>
         <expression>&xq_functy_env1;(&xd_qname;<phrase diff='chg' at='E006'>,0</phrase>) = &gr_FunctionSig;'
         </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause>
         <expression>
          &gr_FunctionSig;'
          =
          declare function &xd_qname;() as &gr_Type;'
         </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause>
         <expression>
          &xq_func_env1;(&xd_qname;<phrase diff='chg' at='E006'>,0</phrase>)
          =
          (&gr_Expr;)
         </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause>
         <environment>
           <phrase diff='del' at='E049'>&xq_val_env1;</phrase>
           <phrase diff='add' at='E049'>&xq_dyn_env1;</phrase>
         </environment>
         <expression>&gr_Expr; &jd_yields; &gr_Value; </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause><environment>&xq_stat_env;</environment>
         <expression>
          &gr_Value; &jd_matches; &gr_Type;'
         </expression>
        </clause>
       </multiclause>
      </prejudge>
      <postjudge>
       <multiclause>
        <clause><environment>&xq_dyn_env;</environment>
         <expression>
           &jd_function_with_types; &xd_qname;
           &jd_function_with_types_with;
           &jd_function_with_types_on_values;
           &jd_function_with_types_yields; &gr_Value;
         </expression>
        </clause>
       </multiclause>
      </postjudge>
     </infer>
    </infergr>

    <infergr>
     <infer>
      <prejudge>
       <multiclause>
        <clause>
         <expression>
          &xq_func_env;(&xd_qname;<phrase diff='chg' at='E006'>,n</phrase>)
          = <code>#IMPORTED</code>(&gr_URI;)
         </expression>
        </clause>
       </multiclause>
       <multiclause>
 	<clause>
 	 <expression>&gr_URI; &jd_module_statEnv; &xq_stat_env1;</expression>
 	</clause>
       </multiclause>
       <multiclause>
 	<clause>
 	 <expression>&gr_URI; &jd_module_dynEnv; &xq_dyn_env1;</expression>
 	</clause>
       </multiclause>
       <multiclause>
        <clause>
         <expression>&xq_functy_env1;(&xd_qname;<phrase diff='chg' at='E006'>,n</phrase>) = &gr_FunctionSig;'
         </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause>
         <expression>
          &gr_FunctionSig;'
          =
          declare function &xd_qname;(&gr_Type1;', ..., &gr_Typen;') as &gr_Type;'
         </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause><environment>&xq_stat_env;</environment>
         <expression>
          &gr_Value1; &jd_matches; &gr_Type1;'
         </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause><expression>...</expression></clause>
       </multiclause>
       <multiclause>
        <clause><environment>&xq_stat_env;</environment>
         <expression>
          &gr_Valuen; &jd_matches; &gr_Typen;'
         </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause>
         <expression>
          &xq_func_env1;(&xd_qname;<phrase diff='chg' at='E006'>,n</phrase>)
          =
          (&gr_Expr;, &gr_Variable1;, ... , &gr_Variablen;)
         </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause>
         <environment>
          <update>
           <environment>&xq_val_env1;</environment>
           <expression>
            &gr_Variable1; &xt_bind; &gr_Value1;;
            ...;
            &gr_Variablen; &xt_bind; &gr_Valuen;</expression>
          </update>
         </environment>
         <expression>&gr_Expr; &jd_yields; &gr_Value; </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause><environment>&xq_stat_env;</environment>
         <expression>
          &gr_Value; &jd_matches; &gr_Type;'
         </expression>
        </clause>
       </multiclause>
      </prejudge>
      <postjudge>
       <multiclause>
        <clause><environment>&xq_dyn_env;</environment>
         <expression>
           &jd_function_with_types; &xd_qname;
           &jd_function_with_types_with; (&gr_Type1;,...,&gr_Typen;)
           &jd_function_with_types_on_values;
           (&gr_Value1;,...,&gr_Valuen;)
           &jd_function_with_types_yields; &gr_Value;
         </expression>
        </clause>
       </multiclause>
      </postjudge>
     </infer>
    </infergr>

    <p>If the function is a built-in function (resp. special formal
    semantics function), the value returned by the function is the one
    specified in &xq_functions; (resp.
    <phrase diff='del' at='E049'><specref ref="sec_special_functions"/></phrase>
    <phrase diff='add' at='E049'><specref ref="sec_special_fs_functions"/></phrase>
    <phrase diff='add' at='E049'>or <specref ref="sec_operators"/></phrase>).</p>

    <infergr>
     <infer>
      <prejudge>
       <multiclause>
        <clause>
         <expression>
          &xq_func_env;(&xd_qname;<phrase diff='chg' at='E006'>,0</phrase>)
          = <code>#BUILT-IN</code>
         </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause>
         <expression>
           The built-in function &xd_qname; (See &xq_functions; or
           <phrase diff='del' at='E049'><specref ref="sec_special_functions"/></phrase>
           <phrase diff='add' at='E049'><specref ref="sec_special_fs_functions"/></phrase>
           <phrase diff='add' at='E049'>or <specref ref="sec_operators"/></phrase>)
           yields the value
           &gr_Value;
          </expression>
        </clause>
       </multiclause>
      </prejudge>
      <postjudge>
       <multiclause>
        <clause><environment>&xq_dyn_env;</environment>
         <expression>
           &jd_function_with_types; &xd_qname;
           &jd_function_with_types_with;
           &jd_function_with_types_on_values;
           &jd_function_with_types_yields; &gr_Value;
         </expression>
        </clause>
       </multiclause>
      </postjudge>
     </infer>
    </infergr>

    <infergr>
     <infer>
      <prejudge>
       <multiclause>
        <clause>
         <expression>
          &xq_func_env;(&xd_qname;<phrase diff='chg' at='E006'>,n</phrase>)
          = <code>#BUILT-IN</code>
         </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause>
         <expression>
           The built-in function &xd_qname; (See &xq_functions; or
           <phrase diff='del' at='E049'><specref ref="sec_special_functions"/></phrase>
           <phrase diff='add' at='E049'><specref ref="sec_special_fs_functions"/></phrase>
           <phrase diff='add' at='E049'>or <specref ref="sec_operators"/></phrase>)
           applied to values
           (&gr_Value1;,...,&gr_Valuen;) yields the value &gr_Value;
          </expression>
        </clause>
       </multiclause>
      </prejudge>
      <postjudge>
       <multiclause>
        <clause><environment>&xq_dyn_env;</environment>
         <expression>
           &jd_function_with_types; &xd_qname;
           &jd_function_with_types_with; (&gr_Type1;,...,&gr_Typen;)
           &jd_function_with_types_on_values;
           (&gr_Value1;,...,&gr_Valuen;)
           &jd_function_with_types_yields; &gr_Value;
         </expression>
        </clause>
       </multiclause>
      </postjudge>
     </infer>
    </infergr>

    <p>If the function is an external function, the value returned by
    the function is implementation-defined.</p>

    <infergr>
     <infer>
      <prejudge>
       <multiclause>
        <clause>
         <expression>
          &xq_func_env;(&xd_qname;<phrase diff='chg' at='E006'>,0</phrase>) = <code>#EXTERNAL</code>
         </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause>
         <expression>
           The external function &xd_qname; yields the value
           &gr_Value;
          </expression>
        </clause>
       </multiclause>
      </prejudge>
      <postjudge>
       <multiclause>
        <clause><environment>&xq_dyn_env;</environment>
         <expression>
           &jd_function_with_types; &xd_qname;
           &jd_function_with_types_with;
           &jd_function_with_types_on_values;
           &jd_function_with_types_yields; &gr_Value;
         </expression>
        </clause>
       </multiclause>
      </postjudge>
     </infer>
    </infergr>

    <infergr>
     <infer>
      <prejudge>
       <multiclause>
        <clause>
         <expression>
          &xq_func_env;(&xd_qname;<phrase diff='chg' at='E006'>,n</phrase>)
          = <code>#EXTERNAL</code>
         </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause>
         <expression>
           The external function &xd_qname; applied to values
           (&gr_Value1;,...,&gr_Valuen;) yields the value &gr_Value;
          </expression>
        </clause>
       </multiclause>
      </prejudge>
      <postjudge>
       <multiclause>
        <clause><environment>&xq_dyn_env;</environment>
         <expression>
           &jd_function_with_types; &xd_qname;
           &jd_function_with_types_with; (&gr_Type1;,...,&gr_Typen;)
           &jd_function_with_types_on_values;
           (&gr_Value1;,...,&gr_Valuen;)
           &jd_function_with_types_yields; &gr_Value;
         </expression>
        </clause>
       </multiclause>
      </postjudge>
     </infer>
    </infergr>
   </smeval>

  </div3>

  </div2>

  <div2 id="id-path-expressions">
    <head>Path Expressions</head>

    <smintro>
      <p>Path expressions are used to locate nodes within a
      tree. There are two kinds of path expressions, absolute path
      expressions and relative path expressions. An absolute path
      expression is a rooted relative path expression. A relative path
      expression is composed of a sequence of steps.</p>
  
      <scrap>
        <head>Path Expressions</head>
        <prodrecap id="PathExpr"         ref="PathExpr"         orig="xquery"/>
        <prodrecap id="RelativePathExpr" ref="RelativePathExpr" orig="xquery"/>
      </scrap>

    </smintro>

    <smcore>
      <p>PathExpr and RelativePathExpr are fully normalized, therefore
      they have no corresponding productions in the Core. The grammar
      for path expressions in the Core starts with the StepExpr
      production.</p>
    </smcore>

    <smnorm>
      <p>Absolute path expressions are path expressions starting with
      the <code>/</code> or <code>//</code> symbols, indicating that
      the expression must be applied on the root node in the current
      context.  The root node in the current context is the greatest
      ancestor of the context node. The following two rules normalize
      absolute path expressions to relative ones. They use the
      &fn_root; function, which returns the greatest ancestor of its
      argument node. The treat expressions guarantee that the value
      bound to the context variable &fs_dot; is a document node.</p>

      <mapping>
       <xquery>
         <expression><map>/</map>&jd_map_expr;</expression>
       </xquery>
       <core>
         <expression><map>(&fn_root;(self::node()) treat as document-node())</map>&jd_map_expr;</expression>
       </core>
      </mapping>

      <mapping>
       <xquery>
         <expression><map>/ &gr_RelativePathExpr;</map>&jd_map_expr;</expression>
       </xquery>
       <core>
         <expression><map>((&fn_root;(self::node())) treat as document-node()) /
         &gr_RelativePathExpr;</map>&jd_map_expr;</expression>
       </core>
      </mapping>

      <mapping>
       <xquery>
         <expression><map>// &gr_RelativePathExpr;</map>&jd_map_expr;</expression>
       </xquery>
       <core>
         <expression><map>((&fn_root;(self::node())) treat as document-node()) /
         <code>descendant-or-self::node()</code> /
         &gr_RelativePathExpr;</map>&jd_map_expr;</expression>
       </core>
      </mapping>

      <mapping>
        <xquery>
          <expression><map>&gr_RelativePathExpr; // &gr_StepExpr; </map>&jd_map_expr;</expression>
        </xquery>
        <core>
          <expression><map>&gr_RelativePathExpr; / descendant-or-self::node() / &gr_StepExpr;</map>&jd_map_expr;
          </expression>
        </core>
      </mapping>

      <p>A composite relative path expression (using <code>/</code>)
      is normalized into a <code>for</code> expression by
      concatenating the sequences obtained by mapping each node of the
      left-hand side in document order to the sequence it generates on
      the right-hand side.  The call to the &fs_distinctdocorder;
      function ensures that the result is in document order without
      duplicates.  The dynamic context is defined by binding the
      <code>$</code><emph>fs:</emph><code>dot</code>,
      <code>$</code><emph>fs:</emph><code>sequence</code>,
      <code>$</code><emph>fs:</emph><code>position</code> and
      <code>$</code><emph>fs:</emph><code>last</code> variables.</p>

      <p>Note that sorting by document order enforces the restriction
      that input and output sequences contains only nodes, and that
      the last step in a path expression may actually return atomic
      values.</p>

      <mapping>
       <xquery>
        <expression><map>&gr_RelativePathExpr; / &gr_StepExpr;</map>&jd_map_expr;</expression>
       </xquery>
       <core>
        <expression>
         <table summary=""><tbody>
           <tr><td>&fs_apply_ordering_mode; (</td></tr>
           <tr><td>&fs_distinctdocorderoratomicsequence; (</td></tr>
           <tr><td diff='chg' at='E021'>&sp2;let &fs_sequence_var; := &fs_node_sequence;( <map>&gr_RelativePathExpr;</map>&jd_map_expr; ) return</td></tr>  
           <tr><td>&sp2;let &fs_last; := fn:count(&fs_sequence_var;)   return</td></tr>  
           <tr><td>&sp2;for &fs_dot; at &fs_position; in &fs_sequence_var; return</td></tr>  
           <tr><td>&sp2;&sp2;<map>&gr_StepExpr;</map>&jd_map_expr;</td></tr>
           <tr><td>))</td></tr>
         </tbody></table>
        </expression>
       </core>
      </mapping>

    </smnorm>

    <div3 id="id-axis-steps">
      <head>Steps</head>

      <p>Note that this section uses some auxiliary judgments which
      are defined in <specref ref="sec_auxiliary_xpath"/>.</p>

      <smintro>
        <scrap>
          <head>Steps</head>
          <prodrecap id="StepExpr"      ref="StepExpr"      orig="xquery"/>
          <prodrecap id="AxisStep"      ref="AxisStep"      orig="xquery"/>
          <prodrecap id="ForwardStep"   ref="ForwardStep"   orig="xquery"/>
          <prodrecap id="ReverseStep"   ref="ReverseStep"   orig="xquery"/>
          <prodrecap id="PredicateList" ref="PredicateList" orig="xquery"/>
        </scrap>
      </smintro>

      <smcore>
        <p>The Core grammar productions for XPath steps are:</p>
    
        <scrap>
          <head>Steps</head>
          <prodrecap id="core-StepExpr"    ref="StepExpr"    orig="core"/>
          <prodrecap id="core-AxisStep"    ref="AxisStep"    orig="core"/>
          <prodrecap id="core-ForwardStep" ref="ForwardStep" orig="core"/>
          <prodrecap id="core-ReverseStep" ref="ReverseStep" orig="core"/>
        </scrap>
      </smcore>

      <smnote>
        <p>Step expressions can be followed by
        predicates. Normalization of predicates uses the following
        auxiliary mapping rule: <map></map>&jd_map_predicates;, which
        is specified in <specref ref="id-predicates"/>. Normalization
        for step expressions also uses the following auxiliary mapping
        rule: <map></map>&jd_map_axis;, which is specified in <specref
        ref="sec_axes"/>.</p>
      </smnote>

      <smnorm>
        <p>Normalization of predicates need to distinguish between
        forward steps, reverse steps, and primary expressions.</p>
  
        <p>As explained in the &language; document, applying a step in
        XPath changes the focus (or context). The change of focus is
        made explicit by the normalization rule below, which binds the
        variable &fs_dot; to the node currently being processed, and
        the variable &fs_position; to the position (i.e., the position
        within the input sequence) of that node.</p>

        <p>There are two sets of normalization rules for Predicates.
        The first set of rules apply when the predicate is a numeric
        literal or the expression <code>last()</code>.  The second set
        of rules apply to all predicate expressions other than numeric
        literals and the expression <code>last()</code>.  In the first
        case, the normalization rules provides a more precise static
        type than if the general rules were applied.</p>

        <p>When the predicate expression is a numeric literal or the
        &fn_last; function, the following normalization rules
        apply.</p>
  
        <mapping>
          <xquery>
            <expression><map>&gr_ForwardStep; &gr_PredicateList; [
            &gr_NumericLiteral; ]</map>&jd_map_expr;</expression>
          </xquery>
          <core>
            <expression>
              <table summary=""><tbody>
                <tr><td>let &fs_sequence_var; :=
                &fs_apply_ordering_mode;(&fs_distinctdocorder;( <map>&gr_ForwardStep;
                &gr_PredicateList;</map>&jd_map_expr; )) return</td></tr>
<tr><td><phrase diff='chg' at='E024'>&fs_item_at;</phrase>(&fs_sequence_var;,&gr_NumericLiteral;<phrase diff='del' at='E024'>,1</phrase>)</td></tr>
              </tbody></table>
            </expression>
          </core>
        </mapping>
  
        <mapping>
          <xquery>
            <expression><map>&gr_ForwardStep; &gr_PredicateList; [
            &fn_last;() ]</map>&jd_map_expr;</expression>
          </xquery>
          <core>
            <expression>
              <table summary=""><tbody>
                <tr><td>let &fs_sequence_var; :=
                &fs_apply_ordering_mode;(&fs_distinctdocorder;( <map>&gr_ForwardStep;
                &gr_PredicateList;</map>&jd_map_expr; )) return</td></tr>
                <tr><td>let &fs_last; := &fn_count;(&fs_sequence_var;) return</td></tr>
<tr><td><phrase diff='chg' at='E024'>&fs_item_at;</phrase>(&fs_sequence_var;,&fs_last;<phrase diff='del' at='E024'>,1</phrase>)</td></tr>
              </tbody></table>
            </expression>
          </core>
        </mapping>
  
        <p>When predicates are applied on a reverse step, the position
        variable is bound in reverse document order. </p>
  
        <mapping>
          <xquery>
            <expression><map>&gr_ReverseStep; &gr_PredicateList; [
            &gr_NumericLiteral; ]</map>&jd_map_expr;</expression>
          </xquery>
          <core>
          <expression>
             <table summary=""><tbody>
                <tr><td>let &fs_sequence_var; :=
                &fs_apply_ordering_mode;(&fs_distinctdocorder;( <map>&gr_ReverseStep; &gr_PredicateList;</map>&jd_map_expr; )) return</td></tr>
                <tr><td>let &fs_last; := fn:count(&fs_sequence_var;) return</td></tr>
                <tr><td>let &fs_position; := &fs_plus;(1, &fs_minus;(&fs_last;,&gr_NumericLiteral;)) return</td></tr>
                <tr><td>&sp2;<phrase diff='chg' at='E024'>&fs_item_at;</phrase>(&fs_sequence_var;,&fs_position;<phrase diff='del' at='E024'>,1</phrase>)</td></tr>
             </tbody></table>
           </expression>
          </core>
        </mapping>

        <p>When the step is a reverse axis, then the last item in the
        context sequence is the first in document order.</p>

        <mapping>
          <xquery>
            <expression><map>&gr_ReverseStep; &gr_PredicateList; [
            &fn_last;() ]</map>&jd_map_expr;</expression>
          </xquery>
          <core>
          <expression>
             <table summary=""><tbody>
                <tr><td>let &fs_sequence_var; :=
                &fs_apply_ordering_mode;(&fs_distinctdocorder;( <map>&gr_ReverseStep; &gr_PredicateList;</map>&jd_map_expr; )) return</td></tr>
                <tr><td>&sp2;<phrase diff='chg' at='E024'>&fs_item_at;</phrase>(&fs_sequence_var;,1<phrase diff='del' at='E024'>,1</phrase>)</td></tr>
             </tbody></table>
           </expression>
          </core>
        </mapping>
  
        <p>The normalization rules above all use the function
        <phrase diff='chg' at='E024'>&fs_item_at;</phrase> to select a particular item.  The static
        typing rules for this function are defined in <phrase diff='chg' at='E024'><specref
        ref="sec_item_at"/></phrase>.</p>
  
        <p>When predicates are applied on a forward step, the input
        sequence is first sorted in document order and duplicates are
        removed. The context is changed by binding the &fs_dot;
        variable to each node in document order.</p>
  
        <mapping>
          <xquery>
            <expression><map>&gr_ForwardStep; &gr_PredicateList; [
            &gr_Expr; ]</map>&jd_map_expr;</expression>
          </xquery>
          <core>
            <expression>
              <table summary=""><tbody>
                <tr><td>let &fs_sequence_var; :=
                &fs_apply_ordering_mode;(&fs_distinctdocorder;( <map>&gr_ForwardStep;
                &gr_PredicateList;</map>&jd_map_expr; )) return</td></tr>
                <tr><td>let &fs_last; := fn:count(&fs_sequence_var;) return</td></tr>
                <tr><td>for &fs_dot; at &fs_position; in &fs_sequence_var; return</td></tr>
                <tr><td>&sp2; if (<map>&gr_Expr;</map>&jd_map_predicates;) then &fs_dot; else ()</td></tr>
              </tbody></table>
            </expression>
          </core>
        </mapping>
  
        <p>When predicates are applied on a reverse step, the input
        sequence is first sorted in document order and duplicates are
        removed. The context is changed by binding the &fs_dot;
        variable to each node in document order. </p>

        <mapping>
          <xquery>
            <expression><map>&gr_ReverseStep; &gr_PredicateList; [
            &gr_Expr; ]</map>&jd_map_expr;</expression>
          </xquery>
          <core>
          <expression>
             <table summary=""><tbody>
               <tr><td>let &fs_sequence_var; := &fs_apply_ordering_mode;(&fs_distinctdocorder;(
               <map>&gr_ReverseStep; &gr_PredicateList;</map>&jd_map_expr; )) return</td></tr>
               <tr><td>let &fs_last; := fn:count(&fs_sequence_var;) return</td></tr>
               <tr><td>for &fs_dot; at &xq_newvar; in &fs_sequence_var; return</td></tr>
               <tr><td>let &fs_position; := &fs_plus;(1,&fs_minus;(&fs_last;,&xq_newvar;)) return </td></tr>
               <tr><td>&sp2;if (<map>&gr_Expr;</map>&jd_map_predicates;)
                            then &fs_dot; else ()</td></tr>
             </tbody></table>
           </expression>
          </core>
        </mapping>
  

        <p>Finally, a stand-alone forward or reverse step is
        normalized by the auxiliary normalization rule for
        &gr_Axis;.</p>
  
        <mapping>
          <xquery>
            <expression><map>&gr_ForwardStep;</map>&jd_map_expr;</expression>
          </xquery>
          <core>
            <expression>&fs_apply_ordering_mode;(<map>&gr_ForwardStep;</map>&jd_map_axis;)</expression>
          </core>
        </mapping>

        <mapping>
          <xquery>
            <expression><map>&gr_ReverseStep;</map>&jd_map_expr;</expression>
          </xquery>
          <core>
            <expression>&fs_apply_ordering_mode;(<map>&gr_ReverseStep;</map>&jd_map_axis;)</expression>
          </core>
        </mapping>
      </smnorm>

      <smtype>
        <p>The static semantics of an &gr_Axis; &gr_NodeTest; pair is
        obtained by retrieving the type of the context node, and
        applying the two filters (the &gr_Axis;, and then the
        &gr_NodeTest; with a &gr_PrincipalNodeKind;) on the
        result.</p>

        <infergr>
         <infer>
          <prejudge>
           <multiclause>
            <clause>
             <expression>&xq_type_env;(&fs_uri_dot;) = &gr_Type1;</expression>
            </clause>
           </multiclause>
           <multiclause>
            <clause>
             <environment> &xq_stat_env; </environment>
             <expression>&gr_Type1; &jd_subtype_of; <map>node()</map>&jd_map_sequencetype;</expression>
            </clause>
           </multiclause>
           <multiclause>
            <clause><environment>&xq_stat_env;</environment>
             <expression>
              &jd_axis_type; &gr_Axis; &jd_axis_of; &gr_Type1; &jd_axis_type_is;
              &gr_Type2;
             </expression>
            </clause>
           </multiclause>
           <multiclause>
            <clause>
             <expression>&gr_Axis; &jd_principal; &gr_PrincipalNodeKind;</expression>
            </clause>
           </multiclause>
           <multiclause>
            <clause><environment>&xq_stat_env;</environment>
             <expression>
              &jd_test_type; &gr_NodeTest; &jd_test_type_with;
              &gr_PrincipalNodeKind; &jd_test_type_of; &gr_Type2;
              &jd_test_type_is; &gr_Type3;
             </expression>
            </clause>
           </multiclause>
          </prejudge>
          <postjudge>
           <clause><environment>&xq_stat_env;</environment>
            <expression>
             &gr_Axis; &gr_NodeTest; &jd_has_type; &gr_Type3;
            </expression>
           </clause>
          </postjudge>
         </infer>
        </infergr>

        <smnote>
          <p>Note that the second judgment in the rule requires that
          the context item be a node, guaranteeing that a type error
          is raised when the context item is an atomic value.</p>
        </smnote>
      
      </smtype>
      
      <smeval>
        <p>The dynamic semantics of an &gr_Axis; &gr_NodeTest; pair is
        obtained by retrieving the context node, and applying the two
        filters (&gr_Axis;, then &gr_NodeTest;) on the result. The
        application of each filter is expressed through several
        auxiliary judgments (&jd_axis_of;, &jd_principal;, and
        &jd_test;), as follows.</p>
      
        <infergr>
         <infer>
          <prejudge>
           <multiclause>
            <clause>
             <expression>&xq_val_env;(
             <phrase diff='del' at='E050'>&fs_dot;</phrase>
             <phrase diff='add' at='E050'>&fs_uri_dot;</phrase>
             ) = &gr_Value1;</expression>
            </clause>
           </multiclause>
           <multiclause>
            <clause>
             <environment> &xq_stat_env; </environment>
             <expression>&gr_Value1; &jd_matches; <map>node()</map>&jd_map_sequencetype;</expression>
            </clause>
           </multiclause>
           <multiclause>
            <clause><environment>&xq_dyn_env;</environment>
             <expression>
              &jd_axis; &gr_Axis; &jd_axis_of; &gr_Value1;
              &jd_axis_arrow; &gr_Value2;
             </expression>
            </clause>
           </multiclause>
           <multiclause>
            <clause>
             <expression>&gr_Axis; &jd_principal; &gr_PrincipalNodeKind;</expression>
            </clause>
           </multiclause>
           <multiclause>
            <clause><environment>&xq_dyn_env;</environment>
             <expression>
              &jd_test; &gr_NodeTest; &jd_test_with; &gr_PrincipalNodeKind;
              &jd_test_of; &gr_Value2; &jd_test_arrow;
              &gr_Value3;</expression>
            </clause>
           </multiclause>
          </prejudge>
          <postjudge>
           <clause><environment>&xq_dyn_env;</environment>
            <expression>
             &gr_Axis; &gr_NodeTest; &jd_yields; &fs_distinctdocorder;(&gr_Value3;)
            </expression>
           </clause>
          </postjudge>
         </infer>
        </infergr>
      
        <smnote>
          <p>Note that the second judgment in the rule guarantees that
          the context item is bound to a node.</p>
        </smnote>
      
      </smeval>
      
      <div4 id="sec_axes">
        <head>Axes</head>

        <smintro>
          <p>The XQuery grammar for forward and reverse axis is as
          follows.</p>

          <scrap>
            <head>Axes</head>
            <prodrecap id="ForwardAxis" ref="ForwardAxis" orig="xquery"/>
            <prodrecap id="ReverseAxis" ref="ReverseAxis" orig="xquery"/>
          </scrap>

          <p>In the case of XPath, forward axis also contain the
          <code>namespace::</code> axis.</p>

          <scrap>
            <head>Axes</head>
            <prodrecap ref="ForwardAxis" orig="xpath" test="XPath"/>
          </scrap>

        </smintro>

        <smcore>
          <p>The Core grammar productions for XPath axis are:</p>
      
            <scrap>
            <head>Axes</head>
              <prodrecap id="core-ForwardAxis" ref="ForwardAxis" orig="core"/>
              <prodrecap id="core-ReverseAxis" ref="ReverseAxis" orig="core"/>
            </scrap>
        </smcore>

        <smnotation>
        <p>We introduce the following auxiliary grammar production to
        describe all axis.</p>

      <scrap>
        <head/>
        <prodrecap id="Axis" ref="Axis" orig="formal"/>
      </scrap>
        </smnotation>

        <smnotation>
          <p id="jd_map_axis">The normalization of axes uses the
          following auxiliary mapping rule:
          <map></map>&jd_map_axis;.</p>
        </smnotation>

        <smnorm>
          <p>The normalization for all axes is specified as
          follows.</p>

          <p>The semantics of the following(-sibling) and
          preceding(-sibling) axes are expressed by mapping them to
          Core expressions. All other axes are part of the Core and
          therefore are left unchanged through normalization.</p>
           
          <mapping>
            <xquery>
              <expression><map><code>following-sibling::</code>
              &gr_NodeTest;</map>&jd_map_axis;</expression>
            </xquery>
            <core>
              <expression><map>let $e := . return $e/parent::node()/child:: &gr_NodeTest; [.&gt;&gt;$e]</map>&jd_map_expr;</expression>
            </core>
          </mapping>
    
          <mapping>
          <xquery>
            <expression><map><code>following::</code>
            &gr_NodeTest;</map>&jd_map_axis;</expression>
          </xquery>
          <core>
            <expression><map><code>ancestor-or-self::node()/following-sibling::node()/descendant-or-self::</code>&gr_NodeTest;</map>&jd_map_expr;</expression>
          </core>
          </mapping>
    
          <p>All other forward axes are part of the Core &language;
          and handled by the normalization rules below:</p>
    
          <mapping>
          <xquery>
            <expression><map><code>child::</code> &gr_NodeTest;</map>&jd_map_axis;</expression>
          </xquery>
          <core>
            <expression><code>child::</code> &gr_NodeTest;</expression>
          </core>
          </mapping>
          
          <mapping>
          <xquery>
            <expression><map><code>attribute::</code> &gr_NodeTest;</map>&jd_map_axis;</expression>
          </xquery>
          <core>
            <expression><code>attribute::</code> &gr_NodeTest;</expression>
          </core>
          </mapping>
          
          <mapping>
          <xquery>
            <expression><map><code>self::</code> &gr_NodeTest;</map>&jd_map_axis;</expression>
          </xquery>
          <core>
            <expression><code>self::</code> &gr_NodeTest;</expression>
          </core>
          </mapping>
          
          <mapping>
          <xquery>
            <expression><map><code>descendant::</code> &gr_NodeTest;</map>&jd_map_axis;</expression>
          </xquery>
          <core>
            <expression><code>descendant::</code> &gr_NodeTest;</expression>
          </core>
          </mapping>
          
          <mapping>
          <xquery>
            <expression><map><code>descendant-or-self::</code> &gr_NodeTest;</map>&jd_map_axis;</expression>
          </xquery>
          <core>
            <expression><code>descendant-or-self::</code> &gr_NodeTest;</expression>
          </core>
          </mapping>
          
          <mapping>
          <xquery>
            <expression><map><code>namespace::</code> &gr_NodeTest;</map>&jd_map_axis;</expression>
          </xquery>
          <core>
            <expression><code>namespace::</code> &gr_NodeTest;</expression>
          </core>
          </mapping>
    
          <p>Reverse axes:</p>
          
          <mapping>
          <xquery>
            <expression><map><code>preceding-sibling::</code> &gr_NodeTest;</map>&jd_map_axis;</expression>
          </xquery>
          <core>
            <expression><map>let $e := . return $e/parent::node()/child:: &gr_NodeTest; [.&lt;&lt;$e]</map>&jd_map_expr;</expression>
          </core>
          </mapping>
          
          <mapping>
          <xquery>
          <expression><map><code>preceding::</code> &gr_NodeTest;</map>&jd_map_axis;</expression>
          </xquery>
          <core>
          <expression><map><code>ancestor-or-self::node()/preceding-sibling::node()/descendant-or-self::</code>&gr_NodeTest;</map>&jd_map_expr;</expression>
          </core>
          </mapping>
           
          <p>All other reverse axes are part of the Core &language;
          and handled by the normalization rules below:</p>
           
          <mapping>
          <xquery>
          <expression><map><code>parent::</code> &gr_NodeTest;</map>&jd_map_axis;</expression>
          </xquery>
          <core>
          <expression><code>parent::</code> &gr_NodeTest;</expression>
          </core>
          </mapping>
          
          <mapping>
          <xquery>
          <expression><map><code>ancestor::</code> &gr_NodeTest;</map>&jd_map_axis;</expression>
          </xquery>
          <core>
          <expression><code>ancestor::</code> &gr_NodeTest;</expression>
          </core>
          </mapping>
          
          <mapping>
          <xquery>
          <expression><map><code>ancestor-or-self::</code> &gr_NodeTest;</map>&jd_map_axis;</expression>
          </xquery>
          <core>
          <expression><code>ancestor-or-self::</code> &gr_NodeTest;</expression>
          </core>
          </mapping>
    
        </smnorm>

      </div4>

      <div4 id="node-tests">
        <head>Node Tests</head>
  
        <smintro>
          <p>A node test is a condition applied on the nodes selected
          by an axis step. Node tests are described by the following
          grammar productions.</p>
    
          <scrap>
            <head>Node Tests</head>
            <prodrecap id="NodeTest"  ref="NodeTest"   orig="xquery"/>
            <prodrecap id="NameTest"  ref="NameTest"   orig="xquery"/>
            <prodrecap id="Wildcard"  ref="Wildcard"   orig="xquery"/>
          </scrap>
        </smintro>
  
        <smcore>
          <p>The Core grammar productions for node tests are:</p>

          <scrap>
            <head>Node Tests</head>
            <prodrecap id="core-NodeTest" ref="NodeTest" orig="core"/>
            <prodrecap id="core-NameTest" ref="NameTest" orig="core"/>
            <prodrecap id="core-Wildcard" ref="Wildcard" orig="core"/>
          </scrap>
        </smcore>

        <smnotation>
          <p>For convenience, we will use the grammar non-terminals
          &gr_Prefix;, and &gr_LocalPart;, both of which are
          &gr_NCName;s, in some of the inference rules. They are
          defined by the following grammar productions.</p>

          <scrap>
            <head>Prefix and LocalPart</head>
            <prodrecap id="Prefix" ref="Prefix" orig="formal"/>
            <prodrecap id="LocalPart" ref="LocalPart" orig="formal"/>
          </scrap>

        </smnotation>

      </div4>

    </div3>

    <div3 id="id-predicates">
      <head>Predicates</head>
  
      <smintro>
        <p>A predicate consists of an expression, called a <term>predicate
        expression</term>, enclosed in square brackets.</p>
  
        <scrap>
          <head/>
          <prodrecap id="Predicate" ref="Predicate" orig="xquery"/>
        </scrap>
  
      </smintro>
  
      <smnotation>
        <p id="jd_map_predicates">Normalization of predicates uses the
        following auxiliary mapping rule:
        <map></map>&jd_map_predicates;.</p>
      </smnotation>

      <smnorm>
        <p>Predicates in path expressions are normalized with a
        special mapping rule:</p>
  
        <mapping>
          <xquery>
            <expression><map>&gr_Expr;</map>&jd_map_predicates;</expression>
          </xquery>
          <core>
            <expression>
              <table summary=""><tbody>
              <tr><td>typeswitch (<map>&gr_Expr;</map>&jd_map_expr;)</td></tr>
              <tr><td>&sp2;case $v as &fs_numeric; return <emph>op:</emph>numeric-equal($v, &fs_position;)</td></tr>
              <tr><td>&sp2;default $v return &fn_boolean;($v)</td></tr> 
              </tbody>
              </table>
            </expression>
          </core>
        </mapping>
  
        <p>Note that the semantics of predicates whose input
        expression returns a numeric value also work if that value is
        not an integer. In those cases the
        <code>op:numeric-equal</code> returns false when compared to a
        position. For example, the expression <code>//a[3.4]</code>
        always returns the empty sequence.</p>
      </smnorm>
  
    </div3>

    <div3 id="unabbrev">
      <head>Unabbreviated Syntax</head>
  
      <p>The corresponding Section in the &language; document just
      contains examples.</p>
  
    </div3>

    <div3 id="abbrev">
      <head>Abbreviated Syntax</head>
  
      <scrap>
        <head>Abbreviated Syntax</head>
        <prodrecap id="AbbrevForwardStep" ref="AbbrevForwardStep" orig="xquery"/> 
        <prodrecap id="AbbrevReverseStep" ref="AbbrevReverseStep" orig="xquery"/>
      </scrap>
  
      <smnorm>
        <p>Here are normalization rules for the abbreviated
        syntax.</p>

        <mapping>
        <xquery>
          <expression><map>..</map>&jd_map_axis;</expression>
        </xquery>
        <core>
          <expression>parent::node()</expression>
        </core>
        </mapping>
        
        <mapping>
        <xquery>
          <expression><map>@&gr_NodeTest;</map>&jd_map_axis;</expression>
        </xquery>
        <core>
          <expression>attribute::&gr_NodeTest;</expression>
        </core>
        </mapping>
        <mapping>
        <xquery>
          <expression><map>&gr_NodeTest;</map>&jd_map_axis;</expression>
        </xquery>
        <core>
          <expression>child::&gr_NodeTest;</expression>
        </core>
        </mapping>
      </smnorm>
    </div3>
  </div2>

  <div2  id="id-sequence-expressions">
    <head>Sequence Expressions</head>

    <smintro>
      <p>&language; supports operators to construct and combine
      sequences.  A <term>sequence</term> is an ordered collection of
      zero or more items. An <term>item</term> is either an atomic
      value or a node.</p>
    </smintro>

    <div3 id="sec_constructing_sequences">
      <head>Constructing Sequences</head>

      <scrap>
        <head>Constructing Sequences</head>
        <prodrecap                   ref="Expr"      orig="xquery"/>
        <prodrecap id="RangeExpr"    ref="RangeExpr" orig="xquery"/>
      </scrap>

      <smcore>
        <p>The Core grammar production for sequence expressions is:</p>

        <scrap>
          <head>Core Sequence Expressions</head>
          <prodrecap ref="Expr" orig="core"/>
        </scrap>
      </smcore>

      <smnorm>
        <p>A sequence expression is normalized into a sequence of
        normalized single expressions:</p>

        <mapping>
          <xquery>
            <expression>
              <map>&gr_Expr1; , &gr_Expr2;</map>&jd_map_expr;
            </expression>
          </xquery>
          <core>
            <expression>
              <map>&gr_Expr1;</map>&jd_map_expr;, <map>&gr_Expr2;</map>&jd_map_expr;
            </expression>
          </core>
        </mapping>
      </smnorm>

      <smtype>
        <p><!--The static semantics of the sequence expression follows.-->
        The type of the sequence expression is the sequence over the
        types of the individual expressions.</p>

        <infergr>
          <infer>
            <prejudge>
              <multiclause>
                <clause><environment>&xq_stat_env; </environment>
                  <expression>&gr_Expr1; &jd_has_type; &gr_Type1;</expression>
                </clause>
                <clause><environment>&xq_stat_env; </environment>
                  <expression>&gr_Expr2; &jd_has_type; &gr_Type2;</expression>
                </clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <multiclause>
                <clause><environment>&xq_stat_env; </environment>
                        <expression>&gr_Expr1; , &gr_Expr2; &jd_has_type; &gr_Type1;, &gr_Type2;</expression>
                </clause>
              </multiclause>
            </postjudge>
          </infer>
        </infergr>
      </smtype>

      <smeval>  
        <p><!-- The dynamic semantics of the sequence expression follows.-->
        Each expression in the sequence is evaluated and the resulting
        values are concatenated into one sequence.</p>

        <infergr>
          <infer>
            <prejudge>
              <multiclause>
                <clause><environment>&xq_dyn_env;</environment>
                <expression>&gr_Expr1; &jd_yields; &gr_Value1;</expression></clause>
                <clause><environment>&xq_dyn_env;</environment>
                <expression>&gr_Expr2; &jd_yields; &gr_Value2;</expression></clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <multiclause>
                <clause><environment>&xq_dyn_env;</environment>
                <expression>&gr_Expr1;, &gr_Expr2; &jd_yields;
                &gr_Value1;, &gr_Value2;</expression></clause>
              </multiclause>
            </postjudge>
          </infer>
        </infergr>

      </smeval>

      <smnorm>
        <p>The range operator is normalized to the &fs_to;
        function.</p>

        <mapping>
          <xquery>
            <expression>
             <map>&gr_Expr1; <code>to</code> &gr_Expr2;</map>&jd_map_expr;
            </expression>
          </xquery>
          <core>
            <expression>
              &fs_to;((<map>&gr_Expr1;</map>&jd_map_expr;),(<map>&gr_Expr2;</map>&jd_map_expr;))
            </expression>
          </core>
        </mapping>
      </smnorm>

      <smtype>
        <p>The static semantics of the &fs_to; function is defined in
        <specref ref="sec_fs_to"/>.</p>
      </smtype>

      <smeval>
        <p>The dynamic semantics of the &fs_to; function is defined in
        <specref ref="sec_fs_to"/>.</p>
      </smeval>

    </div3>

    <div3 id="sec_filter_exprs">
      <head>Filter Expressions</head>
      <smintro>
        <scrap>
          <head>Filter Expression</head>
          <prodrecap id="FilterExpr"  ref="FilterExpr"  orig="xquery"/>
        </scrap>
      </smintro>

      <smcore>
        <p>There are no Core grammar productions for filter
        expressions as they are normalized to other Core
        expressions. </p>
      </smcore>

      <smnorm>
        <p>When a predicate with a numeric literal or the
        <code>last()</code> expression is applied on a primary
        expression, it is normalized using the <phrase diff='chg' at='E024'>&fs_item_at;</phrase>
        function. This results in a more precise static type for those
        cases.</p>
  
        <mapping>
          <xquery>
            <expression><map>&gr_PrimaryExpr; &gr_PredicateList; [ &gr_NumericLiteral; ]</map>&jd_map_expr;</expression>
          </xquery>
          <core>
            <expression>
              <table summary=""><tbody>
                <tr><td>let &fs_sequence_var; := <map>&gr_PrimaryExpr; &gr_PredicateList;</map>&jd_map_expr; return</td></tr>
                <tr><td><phrase diff='chg' at='E024'>&fs_item_at;</phrase>(&fs_sequence_var;,&gr_NumericLiteral;<phrase diff='del' at='E024'>,1</phrase>)</td></tr>
              </tbody></table>
            </expression>
          </core>
        </mapping>
        
        <mapping>
          <xquery>
            <expression><map>&gr_PrimaryExpr; &gr_PredicateList; [ fn:last() ]</map>&jd_map_expr;</expression>
          </xquery>
          <core>
            <expression>
              <table summary=""><tbody>
                <tr><td>let &fs_sequence_var; := <map>&gr_PrimaryExpr; &gr_PredicateList;</map>&jd_map_expr; return</td></tr>
                <tr><td diff='add' at='E019'>let &fs_last; := fn:count(&fs_sequence_var;) return</td></tr>
                <tr><td><phrase diff='chg' at='E024'>&fs_item_at;</phrase>(&fs_sequence_var;,&fs_last;<phrase diff='del' at='E024'>,1</phrase>)</td></tr>
              </tbody></table>
            </expression>
          </core>
        </mapping>
        
        <p>In the general case, when a predicate is applied on a
        primary expression, it is normalized to a FLWOR expression as
        follows. The input sequence is processed in sequence order and
        the context item is bound to each item in the input
        sequence.</p>

        <mapping>
          <xquery>
            <expression><map>&gr_PrimaryExpr; &gr_PredicateList; [ &gr_Expr; ]</map>&jd_map_expr;</expression>
          </xquery>
          <core>
            <expression>
              <table summary=""><tbody>
                <tr><td>let &fs_sequence_var; := <map>&gr_PrimaryExpr; &gr_PredicateList;</map>&jd_map_expr; return</td></tr>
                <tr><td>let &fs_last; := fn:count(&fs_sequence_var;) return</td></tr>
                <tr><td>for &fs_dot; at &fs_position; in &fs_sequence_var; return</td></tr>
                <tr><td>&sp2; if (<map>&gr_Expr;</map>&jd_map_predicates;) then &fs_dot; else ()</td></tr>
              </tbody></table>
            </expression>
          </core>
        </mapping>
    </smnorm>

    <smtype>
      <p>There are no additional static typing rules for filter
      expressions.</p>
    </smtype>

    <smeval>
      <p>There are no additional dynamic evaluation rules for filter
      expressions.</p>
    </smeval>
    </div3>

    <div3 id="sec_combining_sequences">
      <head>Combining Node Sequences</head>

      <p>&language; provides several operators for combining
      sequences of nodes.</p>

      <scrap>
        <head>Combining Sequences</head>
        <prodrecap id="UnionExpr"           ref="UnionExpr"           orig="xquery"/>
        <prodrecap id="IntersectExceptExpr" ref="IntersectExceptExpr" orig="xquery"/>
      </scrap>

    <smnotation>
      <p id="jd_map_sequenceop">The union, intersect, and except
      expressions are normalized into function calls to the
      appropriate functions. The mapping function
      <map></map>&jd_map_sequenceop; is defined by the following
      table:</p>

      <table summary="" border="1"><tbody>
      <tr><td>SequenceOp</td><td><map><emph>SequenceOp</emph></map>&jd_map_sequenceop;</td></tr>
      <tr><td>"union"</td><td><emph>op:</emph>union</td></tr>
      <tr><td>"|"</td><td><emph>op:</emph>union</td></tr>
      <tr><td>"intersect"</td><td><emph>op:</emph>intersect</td></tr>
      <tr><td>"except"</td><td><emph>op:</emph>except</td></tr> </tbody></table>
    </smnotation>

    <smnorm>
      <p>Operators for combining node sequences are normalized as
      follows.</p>

      <mapping>
       <xquery>
        <expression>
        <map>&gr_Expr1; <emph>SequenceOp</emph> &gr_Expr2;</map>&jd_map_expr;
        </expression>
       </xquery>
       <core>
        <expression>
        &fs_apply_ordering_mode; (<map><emph>SequenceOp</emph></map>&jd_map_sequenceop; (
        <map>&gr_Expr1;</map>&jd_map_expr;, <map>&gr_Expr2;</map>&jd_map_expr; ))
        </expression>
       </core>
      </mapping>

    </smnorm>

    <smtype>
      <p>The static semantics of the operators that combine sequences
      are defined in <specref
      ref="sec_op_union_intersect_except"/>.</p>
    </smtype>

    <smeval>
      <p>The dynamic semantics for function calls is given in <specref
      ref="id-function-calls"/>.</p>
    </smeval>

  </div3>

  </div2>

  <div2 id="sec_arithmetic">
    <head>Arithmetic Expressions</head>

    <p>&language; provides arithmetic operators for addition,
    subtraction, multiplication, division, and modulus, in their usual
    binary and unary forms.</p>

    <scrap>
     <head>Arithmetic Expressions</head>
     <prodrecap id="AdditiveExpr"       ref="AdditiveExpr"       orig="xquery"/>
     <prodrecap id="MultiplicativeExpr" ref="MultiplicativeExpr" orig="xquery"/>
     <prodrecap id="UnaryExpr"          ref="UnaryExpr"          orig="xquery"/>
     <prodrecap id="ValueExpr"          ref="ValueExpr"          orig="xquery"/>
    </scrap>

    <smcore>
      <p>The Core grammar production for arithmetic expressions
      is:</p>

      <scrap>
        <head></head>
        <prodrecap id="core-ValueExpr" ref="ValueExpr" orig="core"/>
      </scrap>
    </smcore>

    <smnotation>
      <p id="jd_map_arithop">The mapping function
      <map></map>&jd_map_arithop; is defined by the following
      table:</p>

      <table summary="" border="1">
        <tbody>
          <tr><td>&gr_ArithOp;</td><td><map>&gr_ArithOp;</map>&jd_map_arithop;</td></tr>
          <tr><td>"+"</td><td>&fs_plus;</td></tr>
          <tr><td>"-"</td><td>&fs_minus;</td></tr>
          <tr><td>"*"</td><td>&fs_times;</td></tr>
          <tr><td>"div"</td><td>&fs_div;</td></tr>
          <tr><td>"mod"</td><td>&fs_mod;</td></tr>
        </tbody>
      </table>

   </smnotation>

  <smcore>
    <p>There are no Core grammar productions for arithmetic
    expressions as they are normalized to other Core expressions. </p>
    </smcore>

  <smnorm>
     <p>The normalization rules for all the arithmetic operators
     except &xo_idiv; first atomize each argument by applying
     &fn_data; and then apply the internal function
     &fs_convert_operand; to each argument.  If the first argument to
     this function has type &xs_untypedAtomic;, then the first
     argument is cast to a double, otherwise it is returned unchanged.
     The overloaded internal function corresponding to the arithmetic
     operator is then applied to the two converted arguments.  The
     table above maps the operators to the corresponding internal
     function.  The mapping from the overloaded internal functions to
     the corresponding non-overloaded function is given in <specref
     ref="sec_operators"/>.</p>

   <mapping>
    <xquery>
     <expression>
      <map>&gr_Expr1; &gr_ArithOp;  &gr_Expr2;</map>&jd_map_expr;
     </expression>
    </xquery>
    <core>
     <expression>
      <table summary=""><tbody>
        <tr><td><map>&gr_ArithOp;</map>&jd_map_arithop;
          (</td><td>&fs_convert_operand;(&fn_data;((<map>&gr_Expr1;</map>&jd_map_expr;)), 1.0E0),
         </td></tr>
        <tr><td></td><td>&fs_convert_operand;(&fn_data;((<map>&gr_Expr2;</map>&jd_map_expr;)), 1.0E0))
         </td></tr>
       </tbody></table>
     </expression>
    </core>
   </mapping>

   <p>The normalization rules for the &xo_idiv; operator are similar,
   but instead of casting arguments with type &xs_untypedAtomic; to
   &xs_double;, they are cast to &xs_integer;.</p>

   <mapping>
    <xquery>
     <expression>
      <map>&gr_Expr1; &xo_idiv;  &gr_Expr2;</map>&jd_map_expr;
     </expression>
    </xquery>
    <core>
     <expression>
      <table summary=""><tbody>
        <tr valign="baseline"><td>&fs_idiv;
          (</td><td>&fs_convert_operand;(&fn_data;((<map>&gr_Expr1;</map>&jd_map_expr;)), 1),
         </td></tr>
        <tr><td></td><td>&fs_convert_operand;(&fn_data;((<map>&gr_Expr2;</map>&jd_map_expr;)), 1))
         </td></tr>
       </tbody></table>
     </expression>
    </core>
   </mapping>
  

   <p>The unary operators are mapped similarly.</p>

   <mapping>
    <xquery>
     <expression>
      <map>&xo_uplus; &gr_Expr;</map>&jd_map_expr;
     </expression>
    </xquery>
    <core>
     <expression>
            &fs_unary_plus;(&fs_convert_operand;(&fn_data;((<map>&gr_Expr;</map>&jd_map_expr;)), 1.0E0))
     </expression>
    </core>
   </mapping>

   <mapping>
    <xquery>
     <expression>
      <map>&xo_uminus; &gr_Expr;</map>&jd_map_expr;
     </expression>
    </xquery>
    <core>
     <expression>
        &fs_unary_minus;(&fs_convert_operand;(&fn_data;((<map>&gr_Expr;</map>&jd_map_expr;)), 1.0E0))
     </expression>
    </core>
   </mapping>

</smnorm>

<smtype>
  <p>The static semantics for function calls is given in <specref
  ref="id-function-calls"/>. The mapping from the overloaded internal
  functions to the corresponding non-overloaded function is given in
  <specref ref="sec_operators"/>.</p>
</smtype>

<smeval>
  <p>The dynamic semantics for function calls is given in <specref
  ref="id-function-calls"/>. The mapping from the overloaded internal
  functions to the corresponding non-overloaded function is given in
  <specref ref="sec_operators"/>.</p>
</smeval>

  </div2>

  <div2 id="sec_comparisons">
    <head>Comparison Expressions</head>

    <smintro>

      <p>Comparison expressions allow two values to be
      compared. &language; provides three kinds of comparison
      expressions, called value comparisons, general comparisons, and
      node comparisons.</p>

      <scrap>
        <head>Comparison Expressions</head>
        <prodrecap id="ComparisonExpr" ref="ComparisonExpr" orig="xquery"/>
        <prodrecap id="ValueComp"      ref="ValueComp"      orig="xquery"/>
        <prodrecap id="GeneralComp"    ref="GeneralComp"    orig="xquery"/>
        <prodrecap id="NodeComp"       ref="NodeComp"       orig="xquery"/>
      </scrap>
    </smintro>

  <div3 id="sec_value_comparisons">
    <head>Value Comparisons</head>

    <smnotation>
      <p id="jd_map_valuecomp">The mapping function
      <map></map>&jd_map_valuecomp; is defined by the following
      table:</p>

      <table summary="" border="1"><tbody>
      <tr><td>ValueComp</td><td><map>ValueComp</map>&jd_map_valuecomp;</td></tr>
      <tr><td>"&xo_fortraneq;"</td><td><emph>fs:</emph>eq</td></tr>
      <tr><td>"&xo_fortranne;"</td><td><emph>fs:</emph>ne</td></tr>
      <tr><td>"&xo_fortranlt;"</td><td><emph>fs:</emph>lt</td></tr>
      <tr><td>"&xo_fortranle;"</td><td><emph>fs:</emph>le</td></tr>
      <tr><td>"&xo_fortrangt;"</td><td><emph>fs:</emph>gt</td></tr> 
      <tr><td>"&xo_fortrange;"</td><td><emph>fs:</emph>ge</td></tr></tbody></table>
    </smnotation>

    <smcore>
      <p>There are no Core grammar productions for value comparisons
      as they are normalized to other Core expressions. </p>
    </smcore>

    <smnorm>
      <p>The normalization rules for the value comparison operators
      first atomize each argument by applying &fn_data; and then apply
      the internal function &fs_convert_operand; defined in <specref
      ref="sec_convert_operand"/>.  If the first argument to this
      function has type &xs_untypedAtomic;, then the first argument is
      cast to a string, otherwise it is returned unchanged.  The
      overloaded internal function corresponding to the value
      comparison operator is then applied to the two converted
      arguments.  The table above maps the value operators to the
      corresponding internal function.  The mapping from the
      overloaded internal functions to the corresponding
      non-overloaded function is given in <specref
      ref="sec_operators"/>.</p>

      <mapping>
       <xquery>
        <expression>
         <map>&gr_Expr1; &gr_ValueComp;  &gr_Expr2;</map>&jd_map_expr;
        </expression>
       </xquery>
       <core>
        <expression>
         <table summary=""><tbody>
           <tr><td><map>&gr_ValueComp;</map>&jd_map_valuecomp;
             (</td><td>&fs_convert_operand;(&fn_data;((<map>&gr_Expr1;</map>&jd_map_expr;)), "string"),
            </td></tr>
           <tr><td></td><td>&fs_convert_operand;(&fn_data;((<map>&gr_Expr2;</map>&jd_map_expr;)), "string") )
            </td></tr>
          </tbody></table>
        </expression>
       </core>
      </mapping>
    </smnorm>

    <smtype>
      <p>The static semantics for function calls is given in <specref
      ref="id-function-calls"/>.  The comparison functions all have
      return type &xs_boolean;, as specified in &xq_functions;. </p>
    </smtype>

    <smeval>
      <p>The dynamic semantics for function calls is given in <specref
      ref="id-function-calls"/>.</p>
    </smeval>

  </div3>

  <div3 id="sec_general_comparisons">
    <head>General Comparisons</head>

    <smintro>
      <p>General comparisons are defined by adding existential
      semantics to value comparisons. The operands of a general
      comparison may be sequences of any length. The result of a
      general comparison is always <code>true</code> or
      <code>false</code>.</p>
    </smintro>

    <smnotation>
      <p id="jd_map_generalcomp">The function
      <map></map>&jd_map_generalcomp; is defined by the following
      table:</p>

      <table summary="" border="1"><tbody>
      <tr><td>&gr_GeneralComp;</td><td><map>&gr_GeneralComp;</map>&jd_map_generalcomp;</td></tr>
      <tr><td>"&xo_eq;"</td><td><emph>fs:</emph>eq</td></tr>
      <tr><td>"&xo_neq;"</td><td><emph>fs:</emph>ne</td></tr>
      <tr><td>"&xo_lt;"</td><td><emph>fs:</emph>lt</td></tr>
      <tr><td>"&xo_le;"</td><td><emph>fs:</emph>le</td></tr>
      <tr><td>"&xo_gt;"</td><td><emph>fs:</emph>gt</td></tr> 
      <tr><td>"&xo_ge;"</td><td><emph>fs:</emph>ge</td></tr></tbody></table>

    </smnotation>

    <smcore>
      <p>There are no Core grammar productions for general comparisons
      as they are normalized to existentially quantified Core
      expressions.</p>
    </smcore>

    <smnorm>
      <p>The normalization rule for a general comparison expression
      first atomizes each argument by applying &fn_data;,
      <phrase diff='del' at='E055'>
      and then
      applies the existentially quantified &gr_SomeExpr; expression to
      each sequence.  The internal function &fs_convert_operand; is
      applied to each pair of atomic values.
      If the first argument to
      this function has type &xs_untypedAtomic;, then the first
      argument is cast to type of the second argument.  If the second
      argument has type &xs_untypedAtomic;, the first argument is cast
      to a string.
      </phrase>
      <phrase diff='add' at='E055'>
      resulting in two sequences of atomic values.
      Two nested <code>some</code> expressions then examine
      (potentially) every pair of values
      (one value from each sequence).
      For each pair, the internal function &fs_convert_operand; is called twice;
      if either of the two values is of type &xs_untypedAtomic;,
      one of the calls will cast it to a type determined by the other value.
      </phrase>
      The overloaded internal function corresponding to
      the general comparison operator is then applied to the two
      converted values.</p>

          <mapping>
            <xquery>
              <expression>
                <map>&gr_Expr1; &gr_GeneralComp; &gr_Expr2;</map>&jd_map_expr;
              </expression>
            </xquery>
            <core>
              <expression>
                <table summary="">
                  <tbody>
                    <tr><td>some $v1 in &fn_data;((<map>&gr_Expr1;</map>&jd_map_expr;)) satisfies</td></tr>
                    <tr><td>some $v2 in &fn_data;((<map>&gr_Expr2;</map>&jd_map_expr;)) satisfies</td></tr>
                    <tr><td>let $u1 := &fs_convert_operand;($v1, $v2) return </td></tr>
                    <tr><td>let $u2 := &fs_convert_operand;($v2, $v1) return </td></tr>
                    <tr><td><map>&gr_GeneralComp;</map>&jd_map_generalcomp; ($u1, $u2)</td></tr>
                  </tbody>
                </table>
              </expression>
            </core>
          </mapping>
      </smnorm>

  </div3>

  <div3 id="sec_node-comparisons">
    <head>Node Comparisons</head>

<smcore>
  <p>There are no Core grammar productions for node comparisons as
  they are normalized to other Core expressions.</p>
</smcore>

<smnorm>
  <p>The normalization rules for node comparisons map each argument
  expression and then apply the internal function corresponding to the
  node comparison operator. The internal function are defined in
  <specref ref="sec_operators"/>.</p>

<mapping>
<xquery>
<expression>
<map>&gr_Expr1; &xo_nodeequal; &gr_Expr2;</map>&jd_map_expr;
</expression>
</xquery>
<core>
     <expression>
       <table summary=""><tbody>
       <tr><td>&sp2; &fs_nodeequal;((<map>&gr_Expr1;</map>&jd_map_expr;), (<map>&gr_Expr2;</map>&jd_map_expr;))</td></tr>
       </tbody></table>
     </expression>
</core>
</mapping>

<mapping>
<xquery>
<expression>
<map>&gr_Expr1; &xo_ltlt; &gr_Expr2;</map>&jd_map_expr;
</expression>
</xquery>
<core>
<expression>
       <table summary=""><tbody>
       <tr><td>&fs_nodebefore;((<map>&gr_Expr1;</map>&jd_map_expr;), (<map>&gr_Expr2;</map>&jd_map_expr;))</td></tr>
       </tbody></table>
</expression>
</core>
</mapping>

<mapping>
<xquery>
<expression>
<map>&gr_Expr1; &xo_gtgt; &gr_Expr2;</map>&jd_map_expr;
</expression>
</xquery>
<core>
<expression>
       <table summary=""><tbody>
       <tr><td>&fs_nodeafter;((<map>&gr_Expr1;</map>&jd_map_expr;), (<map>&gr_Expr2;</map>&jd_map_expr;))</td></tr>
       </tbody></table>
</expression>
</core>
</mapping>

</smnorm>

<smtype>
  <p>The static semantics for the internal functions are defined in
  <specref ref="sec_operators"/>. </p>
</smtype>

<smeval>
  <p>The dynamic semantics for internal function is defined in
  <specref ref="sec_operators"/>.</p>
</smeval>

  </div3>

  </div2>

  <div2 id="id-logical-expressions"> 
    <head>Logical Expressions</head>

    <smintro>
      <p>A <term>logical expression</term> is either an
      <term>and-expression</term> or an
      <term>or-expression</term>. The value of a logical expression is
      always one of the boolean values: <code>true</code> or
      <code>false</code>.</p>
    </smintro>

    <scrap>
      <head>Logical Expressions</head>
      <prodrecap ref="OrExpr"  id="OrExpr"  orig="xquery"/>
      <prodrecap ref="AndExpr" id="AndExpr" orig="xquery"/>
    </scrap>

    <smcore>
      <p>The Core grammar productions for logical expressions are:</p>

      <scrap>
        <head>Core Logical Expressions</head>
        <prodrecap ref="OrExpr"  id="core-OrExpr"  orig="core"/>
        <prodrecap ref="AndExpr" id="core-AndExpr" orig="core"/>
      </scrap>
    </smcore>

    <smnorm>
      <p>The normalization rules for "&xo_and;" and "&xo_or;" first
      get the effective boolean value of each argument, then apply the
      appropriate Core operator.</p>

   <mapping>
    <xquery>
     <expression>
      <map>&gr_Expr1; &xo_and; &gr_Expr2;</map>&jd_map_expr;
     </expression>
    </xquery>
    <core>
     <expression>
      &fn_boolean;((<map>&gr_Expr1;</map>&jd_map_expr;)) &xo_and; &fn_boolean;((<map>&gr_Expr2;</map>&jd_map_expr;))
     </expression>
    </core>
   </mapping>

   <mapping>
    <xquery>
     <expression>
      <map>&gr_Expr1; &xo_or; &gr_Expr2;</map>&jd_map_expr;
     </expression>
    </xquery>
    <core>
     <expression>
      &fn_boolean;((<map>&gr_Expr1;</map>&jd_map_expr;)) &xo_or; &fn_boolean;((<map>&gr_Expr2;</map>&jd_map_expr;))
     </expression>
    </core>
   </mapping>
    </smnorm>

    <smtype>
      <p>The logical expressions require that each subexpression have
type &xs_boolean;.  The result type is also &xs_boolean;.</p>

<infergr>
  <infer>
    <prejudge>
      <multiclause>
        <clause><environment>&xq_stat_env; </environment>
          <expression>&gr_Expr1; &jd_has_type; &xs_boolean;</expression>
        </clause>
        <clause><environment>&xq_stat_env; </environment>
          <expression>&gr_Exprn; &jd_has_type; &xs_boolean;</expression>
        </clause>
      </multiclause>
    </prejudge>
    <postjudge>
      <multiclause>
        <clause><environment>&xq_stat_env; </environment>
                <expression>&gr_Expr1; &xo_and; &gr_Expr2; &jd_has_type; &xs_boolean;</expression>
        </clause>
      </multiclause>
    </postjudge>
  </infer>
</infergr>

<infergr>
  <infer>
    <prejudge>
      <multiclause>
        <clause><environment>&xq_stat_env; </environment>
          <expression>&gr_Expr1; &jd_has_type; &xs_boolean;</expression>
        </clause>
        <clause><environment>&xq_stat_env; </environment>
          <expression>&gr_Exprn; &jd_has_type; &xs_boolean;</expression>
        </clause>
      </multiclause>
    </prejudge>
    <postjudge>
      <multiclause>
        <clause><environment>&xq_stat_env; </environment>
                <expression>&gr_Expr1; &xo_or; &gr_Expr2; &jd_has_type; &xs_boolean;</expression>
        </clause>
      </multiclause>
    </postjudge>
  </infer>
</infergr>

    </smtype>
    
    <smeval>
      <p>The dynamic semantics of logical expressions is
non-deterministic.   This non-determinism permits implementations to use
short-circuit evaluation strategies when evaluating logical expressions. In the expression, &gr_Expr1; &xo_and; &gr_Expr2;,
if either expression raises an error or evaluates to false, the entire
expression may raise an error or evaluate to false. 
In the expression, &gr_Expr1; &xo_or; &gr_Expr2;,
if either expression raises an error or evaluates to true, the entire
expression may raise an error or evaluate to true. </p>

<infergr>
  <infer>
    <prejudge>
      <multiclause>
        <clause><environment>&xq_dyn_env; </environment>
          <expression>&gr_Expri; &jd_yields; false</expression>
        </clause>
      </multiclause>
      <multiclause>
        <clause><expression>i &jd_isin; { 1,2 }</expression></clause>
      </multiclause>
    </prejudge>
    <postjudge>
      <multiclause>
        <clause><environment>&xq_dyn_env; </environment>
                <expression>&gr_Expr1; &xo_and; &gr_Expr2; &jd_yields;
                false</expression>
        </clause>
      </multiclause>
    </postjudge>
  </infer>
</infergr>

<infergr>
  <infer>
    <prejudge>
      <multiclause>
        <clause><environment>&xq_dyn_env; </environment>
          <expression>&gr_Expr1; &jd_yields; true</expression>
        </clause>
        <clause><environment>&xq_dyn_env; </environment>
          <expression>&gr_Expr2; &jd_yields; true</expression>
        </clause>

      </multiclause>
    </prejudge>
    <postjudge>
      <multiclause>
        <clause><environment>&xq_dyn_env; </environment>
                <expression>&gr_Expr1; &xo_and; &gr_Expr2; &jd_yields;
                true</expression>
        </clause>
      </multiclause>
    </postjudge>
  </infer>
</infergr>

<infergr>
  <infer>
    <prejudge>
      <multiclause>
        <clause><environment>&xq_dyn_env; </environment>
          <expression>&gr_Expri; &jd_yields; true</expression>
        </clause>
      </multiclause>
      <multiclause>
        <clause><expression>i &jd_isin; { 1,2 }</expression></clause>
      </multiclause>
    </prejudge>
    <postjudge>
      <multiclause>
        <clause><environment>&xq_dyn_env; </environment>
                <expression>&gr_Expr1; &xo_or; &gr_Expr2; &jd_yields;
                true</expression>
        </clause>
      </multiclause>
    </postjudge>
  </infer>
</infergr>

<infergr>
  <infer>
    <prejudge>
      <multiclause>
        <clause><environment>&xq_dyn_env; </environment>
          <expression>&gr_Expr1; &jd_yields; false</expression>
        </clause>
        <clause><environment>&xq_dyn_env; </environment>
          <expression>&gr_Expr2; &jd_yields; false</expression>
        </clause>

      </multiclause>
    </prejudge>
    <postjudge>
      <multiclause>
        <clause><environment>&xq_dyn_env; </environment>
                <expression>&gr_Expr1; &xo_or; &gr_Expr2; &jd_yields;
                false</expression>
        </clause>
      </multiclause>
    </postjudge>
  </infer>
</infergr>

    </smeval>

  </div2>

  <div2 id="sec_constructors">
    <head>Constructors</head>

    <p>&language; supports two forms of constructors. <term>Direct
    constructors</term> support literal XML syntax for elements,
    attributes, text nodes, processing-instructions and
    comments. <term>Computed constructors</term> can be used to
    construct elements, attributes, text nodes,
    processing-instructions, comments, and document nodes.  All direct
    constructors are normalized into computed constructors, i.e.,
    there are no direct-constructor expressions in the Core.</p>

    <scrap>
      <head>Constructors</head>
      <prodrecap id="Constructor"           ref="Constructor"           orig="xquery"/>
      <prodrecap id="DirectConstructor"     ref="DirectConstructor"     orig="xquery"/>
      <prodrecap id="DirElemConstructor"    ref="DirElemConstructor"    orig="xquery"/>
      <prodrecap id="DirElemContent"        ref="DirElemContent"        orig="xquery"/>
      <prodrecap id="ElementContentChar"    ref="ElementContentChar"    orig="xquery"/>
      <prodrecap id="CommonContent"         ref="CommonContent"         orig="xquery"/>
      <prodrecap id="CDataSection"          ref="CDataSection"          orig="xquery"/>
      <prodrecap id="CDataSectionContents"  ref="CDataSectionContents"  orig="xquery"/>
      <prodrecap id="DirAttributeList"      ref="DirAttributeList"      orig="xquery"/>
      <prodrecap id="DirAttributeValue"     ref="DirAttributeValue"     orig="xquery"/>
      <prodrecap id="QuotAttrValueContent"  ref="QuotAttrValueContent"  orig="xquery"/>
      <prodrecap id="AposAttrValueContent"  ref="AposAttrValueContent"  orig="xquery"/>
      <prodrecap id="QuotAttrContentChar"   ref="QuotAttrContentChar"   orig="xquery"/>
      <prodrecap id="AposAttrContentChar"   ref="AposAttrContentChar"   orig="xquery"/>
      <prodrecap id="EscapeQuot"            ref="EscapeQuot"            orig="xquery"/>
      <prodrecap id="EscapeApos"            ref="EscapeApos"            orig="xquery"/>
      <prodrecap id="EnclosedExpr"          ref="EnclosedExpr"          orig="xquery"/>
    </scrap>

    <smcore>
      <p>The Core grammar productions for constructors are:</p>

<scrap>
  <head>Constructors</head>
  <prodrecap id="core-Constructor"         ref="Constructor"         orig="core"/>
  <prodrecap id="core-ComputedConstructor" ref="ComputedConstructor" orig="core"/>
  <prodrecap id="core-EnclosedExpr"        ref="EnclosedExpr"        orig="core"/>
</scrap>

      <p>There are no Core grammar productions for direct XML element
      or attribute constructors as they are normalized to computed
      constructors.</p>
    </smcore>

  <div3 id="id_element_constructor">
    <head>Direct Element Constructors</head>

    <smintro>
      <p>The static and dynamic semantics of the direct forms of
      element and attribute constructors are specified
      <phrase diff='del' at='E052'>on</phrase>
      <phrase diff='add' at='E052'>in terms of</phrase>
      the
      equivalent computed element and attribute constructors.</p>
    </smintro>

    <smnotation>
      <p id="jd_map_element_content">The auxiliary mapping rules
      <map></map>&jd_map_element_content;,
      <map></map>&jd_map_element_content_unit;,
      <map></map>&jd_partition_into_units;, and
      <map></map>&jd_dir_chars_units; are defined in this section and
      are used for the normalization of the content of direct element
      constructors.</p>
    </smnotation>

    <smnotation>
      <p>An element-content unit is either
      <phrase diff='add' at='E052'>a &gr_DirCharsUnit; (</phrase>
      a maximal contiguous
      sequence of literal characters
      <phrase diff='del' at='E052'>(including</phrase>
      <phrase diff='add' at='E052'>, CDataSections,</phrase>
      character references,
      escaped braces, and predefined entity references), an enclosed
      expression, a direct element constructor, an XML comment, or an
      XML processing instruction. We use the following auxiliary
      grammar productions to describe element-content units.</p>

      <scrap>
        <head/>
        <prodrecap id="ElementContentUnit" ref="ElementContentUnit" orig="formal"/>
        <prodrecap id="DirCharsUnit" ref="DirCharsUnit" orig="formal"/>
      </scrap>

      <p>We use the auxiliary normalization rule <map>
      &gr_DirElemContent;* </map>&jd_partition_into_units; to
      restructure the original element content, &gr_DirElemContent;*,
      into the appropriate sequence of element-content units. This
      normalization rule is not specified formally.</p>

      <p>Here are three direct element constructors, each of which
      contains one element-content unit:</p>

<eg><![CDATA[
<date>{ xs:date("2003-03-18") }</date>

<name>Dizzy Gillespie</name>

<comment><!-- Just a comment --></comment>
]]></eg>

     <p>The first contains one enclosed expression, the second
     contains one contiguous sequence of characters, and the third
     contains one XML comment.</p>

     <p>After boundary whitespace is stripped, the next example
     contains six element-content units: </p>

<eg><![CDATA[
<address>
  <!-- Dizzy's address -->
  { 123 }-0A <street>Roosevelt Ave.</street> Flushing, NY { 11368 }
</address>
]]></eg>

     <p>It contains an XML comment, followed by an enclosed expression
     that contains the integer 123, a contiguous sequence of
     characters ("-0A "), a direct XML element constructor, a
     contiguous sequence of characters (" Flushing, NY "), and an
     enclosed expression that contains the integer 11368. Evaluation
     of that constructor will result in the following element.</p>

<eg><![CDATA[
<address><!-- Dizzy's address -->123-0A <street>Roosevelt Ave.</street> Flushing, NY 11368</address>
]]></eg>

    </smnotation>

    <smnorm>
      <p>We start by giving the rules for the two forms of direct XML
      element constructors.  Note that the direct attribute
      constructors are normalized twice: the
      <map></map>&jd_map_namespace_attrs; normalizes the
      namespace-declaration attributes and
      <map></map>&jd_map_attribute; normalizes all other attributes
      that are not namespace-declaration attributes. </p>

      <mapping>
      <xquery>
        <expression><map> &lt; &gr_QName; &gr_DirAttributeList; >
          &gr_DirElemContent;* &lt;/ &gr_QName; S? >
          </map>&jd_map_expr;</expression>
      </xquery>
      <core>
        <expression>element &gr_QName; { <map>
          &gr_DirAttributeList; </map>&jd_map_attribute; , <map>
          <map> &gr_DirElemContent;* </map>&jd_partition_into_units;
          </map>&jd_map_element_content; } { <map>
          &gr_DirAttributeList; </map>&jd_map_namespace_attrs; }
        </expression>
      </core>
      </mapping>

      <mapping>
      <xquery>
        <expression><map> &lt; &gr_QName; &gr_DirAttributeList; />
          </map>&jd_map_expr;</expression>
      </xquery>
      <core>
        <expression>element &gr_QName; { <map>
        &gr_DirAttributeList; </map>&jd_map_attribute; } { <map>
          &gr_DirAttributeList; </map>&jd_map_namespace_attrs; }
        </expression>
      </core>
      </mapping>

      <p>We can now give the rules for normalizing a direct element
      constructor's content.
      <phrase diff='del' at='E011'>
      We distinguish between direct element
      constructors that contain only one element-content unit and
      those that contain more than one element-content unit.
      </phrase></p>

      <p>Adjacent element-content units
      <phrase diff='del' at='E052'>are convenient because they</phrase>
      permit arbitrary interleaving of text and atomic data.  During
      evaluation, atomic values are converted to text nodes containing
      the string representations of the atomic values, and then
      adjacent text nodes are concatenated together.  In the example
      at the beginning of this section, the integer 123 is converted
      to a string and concatenated with "-0A" and the result is a
      single text node containing "123-0A".</p>

      <p>Below are two examples of normalization for element
      constructors.</p>

<eg><![CDATA[
<date>{ xs:date("2003-03-18") }</date>
 =
element date { 
  fs:item-sequence-to-node-sequence(
    xs:date("2003-03-18")
  )
}]]><phrase diff='add' at='E052'> {}</phrase><![CDATA[

<address>
  <!-- Dizzy's address -->
  { 123 }-0A <street>Roosevelt Ave.</street> Flushing, NY { 11368 }
</address>
 =
element address {
  fs:item-sequence-to-node-sequence(
    comment { " Dizzy's address "},
    123, 
    text { "-0A "}, 
    element street {"Roosevelt Ave."}]]><phrase diff='add' at='E052'> {}</phrase><![CDATA[,
    text { " Flushing, NY "  },
    11368
  )
}]]><phrase diff='add' at='E052'> {}</phrase><![CDATA[
]]></eg>

    <p>We normalize each unit individually and construct a sequence of
    the normalized results<phrase diff='del' at='E029'> interleaved with empty text nodes.  The
    empty text nodes guarantee that the results of evaluating
    consecutive element-content units can be distinguished.  Then we
    apply the function &fs_item_seq_to_node_seq;.  <xspecref spec="XQ"
    ref="id-element-constructor"/> specifies the rules for converting
    a sequence of atomic values and nodes into a sequence of nodes
    before element construction.  The Formal Semantics function
    &fs_item_seq_to_node_seq; implements these conversion rules</phrase>.</p>

      <mapping diff='del' at='E011'>
        <xquery>
          <expression><map>&gr_ElementContentUnit1;</map>&jd_map_element_content;</expression>
        </xquery>
        <core>
          <expression>&fs_item_seq_to_node_seq;((<map> &gr_ElementContentUnit1;</map>&jd_map_element_content_unit;))
          </expression>
        </core>
      </mapping>

      <mapping>
        <xquery>
          <expression><map>&gr_ElementContentUnit1;, ...,  &gr_ElementContentUnitn;</map>&jd_map_element_content;</expression>
        </xquery>
        <core>
          <expression>
            <phrase diff='del' at='E029'>&fs_item_seq_to_node_seq;((</phrase>
            <map> &gr_ElementContentUnit1; </map>&jd_map_element_content_unit; ,
            <phrase diff='del' at='E029'>text { "" },</phrase>
            ...,
            <phrase diff='del' at='E029'>text { "" },</phrase>
            <map> &gr_ElementContentUnitn;</map>&jd_map_element_content_unit;
            <phrase diff='del' at='E029'>))</phrase>
          </expression>
        </core>
      </mapping>

    <p diff='add' at='E011'>
      (Note that this rule should be understood to cover
      the degenerate cases of n=0 and n=1,
      where the element constructor's content
      consists of zero or one element-content units.)
    </p>

    <p diff='del' at='E029'>We must distinguish between the results of consecutive
    element-content units, because the rule for converting sequences
    of atomic values into strings applies to sequences within distinct
    enclosed expressions.  The empty text nodes are eliminated during
    evaluation of &fs_item_seq_to_node_seq; when consecutive text
    nodes are coalesced into a single text node.  The text node
    guarantees that a whitespace character will not be inserted
    between atomic values computed by distinct enclosed expressions.
    For example, here is an expression, its normalization, and the
    resulting XML value:</p>

<eg diff='del' at='E029'><![CDATA[
<example>{ 1 }{ 2 }</example>
 =
element example { fs:item-sequence-to-node-sequence ((1, text {""}, 2)) }
 ==>
<example>12</example>
]]></eg>

      <p diff='del' at='E029'>In the absence of the empty text node, the expression would
      evaluate to the following incorrect value:</p>

<eg diff='del' at='E029'><![CDATA[
<example>{ 1 }{ 2 }</example>
 (incorrect normalization) =
element example { fs:item-sequence-to-node-sequence ((1, 2)) }
 (incorrect value) ==>
<example>1 2</example>
]]></eg>

      <p>Next, we give the normalization rules for each
      element-content unit. The normalization rule for a contiguous
      sequence of characters assumes that the significant whitespace
      characters in element constructors have been preserved, as
      described in <specref ref="sec_whitespace"/>.</p>

      <p>The following normalization rule takes
      <phrase diff='del' at='E052'>the longest consecutive sequence</phrase>
      <phrase diff='add' at='E052'>a maximal contiguous sequence</phrase>
      of individual characters that include
      literal characters,
      <phrase diff='add' at='E052'>CDataSections,</phrase>
      escaped curly braces, character references,
      and predefined entity references and normalizes the character
      sequence as a text node containing the string of characters.</p>

      <mapping>
        <xquery>
       <expression><map>&gr_DirCharsUnit;</map>&jd_map_element_content_unit;</expression>
        </xquery>
        <core>
       <expression>text { <map> &gr_DirCharsUnit;
       </map>&jd_dir_chars_units; }</expression>
        </core>
      </mapping>

    <p>The application of <map></map>&jd_dir_chars_units; to
    &gr_DirCharsUnit; is defined informally. It produces a string
    literal corresponding to the content of the &gr_DirCharsUnit;, in
    <phrase diff='add' at='E052'>which</phrase>
    boundary whitespace is processed
    <phrase diff='add' at='E052'>as specified in <xspecref spec="XQ" ref="id-whitespace"/>,</phrase>
    and non-literal characters
    (CharRefs, PredefinedEntityRefs, CDataSections, and
    escaped-braces) are resolved according to the rules in <xspecref
    spec="XQ" ref="id-content"/>.</p>

    <p>XML processing instructions and comments in element content are
    normalized by applying the standard normalization rules for
    expressions, which appear in <specref
    ref="sec_other_constructors"/>.</p>

      <mapping>
      <xquery>
        <expression><map>&gr_DirPIConstructor;</map>&jd_map_element_content_unit;</expression>
      </xquery>
      <core>
        <expression><map>&gr_DirPIConstructor;</map>&jd_map_expr;</expression>
      </core>
      </mapping>

      <mapping>
      <xquery>
        <expression><map>&gr_DirCommentConstructor;</map>&jd_map_element_content_unit;</expression>
      </xquery>
      <core>
        <expression><map>&gr_DirCommentConstructor;</map>&jd_map_expr;</expression>
      </core>
      </mapping>

    <p>A direct element constructor is normalized using the
    normalization rule for expressions.</p>

      <mapping>
      <xquery>
        <expression><map>&gr_DirElemConstructor;</map>&jd_map_element_content_unit;</expression>
      </xquery>
      <core>
        <expression><map>&gr_DirElemConstructor;</map>&jd_map_expr;</expression>
      </core>
      </mapping>

    <p>An enclosed expression in element content is normalized
    <phrase diff='del' at='E029'>by
    normalizing each individual expression in its expression sequence
    and then constructing a sequence of the normalized values:
    </phrase>
    <phrase diff='add' at='E029'>
    into a call to the function &fs_item_seq_to_node_seq;,
    which implements various rules for converting
    a sequence of atomic values and nodes
    into a sequence of nodes before element construction.
    </phrase></p>

      <mapping>
        <xquery>
          <expression><map>
            {
            <phrase diff='del' at='E029'>&gr_Expr1;, ..., &gr_Exprn;</phrase>
            <phrase diff='add' at='E029'>&gr_Expr;</phrase>
            }
          </map>&jd_map_element_content_unit;</expression>
        </xquery>
        <core>
          <expression>
            <phrase diff='del' at='E029'>
            <map> &gr_Expr1; </map>&jd_map_expr; , ..., <map> &gr_Exprn;</map>&jd_map_expr;
            </phrase>
            <phrase diff='add' at='E029'>
            &fs_item_seq_to_node_seq;(( <map>&gr_Expr;</map>&jd_map_expr; ))
            </phrase>
          </expression>
        </core>
      </mapping>
      </smnorm>

      <smtype>
        <p>There are no additional static typing rules for direct XML
        element or attribute constructors.</p>
      </smtype>

      <smeval>
        <p>There are no additional dynamic evaluation rules for direct
        XML element or attribute constructors.</p>
      </smeval>

      <div4 id="sec_direct_attributes">
        <head>Attributes</head>

        <p>Like direct element constructors, direct attribute
        constructors are normalized to computed attribute
        constructors.</p>

      <smnotation>
        <p id="jd_map_attr_content">The auxiliary mapping rules
        <map></map>&jd_map_attribute;,
        <phrase diff='add' at='E001'>
        <map></map>&jd_map_dir_attribute_value;,
        </phrase>
        <map></map>&jd_map_attribute_content;,
        <map></map>&jd_map_attribute_content_unit;,
        and
        <phrase diff='add' at='E001'>
        <map></map>&jd_map_attribute_chars_unit;,
        </phrase>
        are defined in
        this section and are used for the normalization of direct
        attribute constructors.</p>

        <p>We use the following grammar productions to represent
        &gr_AttributeContentUnit;s, i.e., the expressions used to
        compute the content of an attribute.</p>

      <scrap diff='chg' at='E001'>
      <head/>
      <prodrecap id="AttributeContentUnits" ref="AttributeContentUnits" orig="formal"/>
      <prodrecap id="AttributeContentUnit"  ref="AttributeContentUnit"  orig="formal"/>
      <prodrecap id="AttributeCharsUnit"    ref="AttributeCharsUnit"    orig="formal"/>
      </scrap>

      <p diff='add' at='E001'>
      An &gr_AttributeCharsUnit; is required to be maximal,
      i.e., it must extend as far as possible in both directions.
      In other words, an &gr_AttributeContentUnits;
      must not contain two adjacent &gr_AttributeCharsUnit;s.
      </p>

      </smnotation>

      <smnorm>
        <p id="sec_attribute_normalization">Direct attributes may
        contain namespace-declaration attributes.  The normalization
        rules in this section ignore namespace-declaration attributes
        -- they are handled by the normalization rules in <specref
        ref="sec_namespace_attrs"/>.</p>

        <p>A &gr_DirAttributeList; is normalized by the following
        rule, which maps each of the individual attribute-value
        expressions in the attribute list and constructs a sequence of
        the normalized values.</p>

      <mapping>
      <xquery>
        <expression>
      <map><table summary=""><tbody>
      <tr><td>
          &gr_QName1; S? = S? &gr_DirAttributeValue1;
      </td></tr>
      <tr><td>
          ...
      </td></tr>
      <tr><td>
          &gr_QNamen; S? = S? &gr_DirAttributeValuen;
      </td></tr>
      </tbody></table></map>&jd_map_attribute;
        </expression>
        </xquery>
      <core>
      <expression>
      <table summary=""><tbody>
      <tr><td>
        (<map>&gr_QName1; S? = S? &gr_DirAttributeValue1; </map>&jd_map_attribute;
      </td></tr>
      <tr><td>
         ..., 
      </td></tr>
      <tr><td>
        <map>&gr_QNamen; S? = S? &gr_DirAttributeValuen;</map>&jd_map_attribute;)
      </td></tr>
      </tbody></table>
      </expression>
      </core>
      </mapping>

      <p id="jd_map_attribute">Namespace-declaration attributes, i.e.,
      those attributes whose prefix is <code>xmlns</code> are ignored
      by mapping them to the empty sequence.</p>

      <mapping>
      <xquery>
        <expression>
<table summary=""><tbody><tr><td>
      <map>&gr_Prefix;:&gr_LocalPart; S? = S?
      &gr_DirAttributeValue;</map>&jd_map_attribute;
</td></tr>
<tr><td>
      (&gr_Prefix; = <code>xmlns</code>)
</td></tr>
</tbody></table>
        </expression>
        </xquery>
      <core>
      <expression>
        ()
      </expression>
      </core>
      </mapping>

      <p>All attributes that are not namespace-declaration attributes
      are mapped to computed attribute constructors.</p>

      <mapping>
      <xquery>
        <expression>
<table summary=""><tbody><tr><td>
      <map>&gr_Prefix;:&gr_LocalPart; S? = S?
      <phrase diff='chg' at='E001'>&gr_DirAttributeValue;</phrase></map>&jd_map_attribute;
</td></tr>
<tr><td>
      &jd_not;(&gr_Prefix; = <code>xmlns</code>)
</td></tr>
</tbody></table>
        </expression>
        </xquery>
      <core>
      <expression>
        attribute &gr_Prefix;:&gr_LocalPart;
        {
          <map>
            <phrase diff='chg' at='E001'><map>&gr_DirAttributeValue;</map>&jd_map_dir_attribute_value;</phrase>
          </map>&jd_map_attribute_content;
        }
      </expression>
      </core>
      </mapping>

      <p id="jd_map_dir_attribute_value" diff='add' at='E001'>
        The effect of
        <map>&gr_DirAttributeValue;</map>&jd_map_dir_attribute_value;
        is not specified formally;
        informally, it partitions the content of &gr_DirAttributeValue;
        into a sequence of &gr_AttributeContentUnit;s,
        each of which is either
        an enclosed expression (&gr_EnclosedExpr;)
        or
        a maximal run of character content (&gr_AttributeCharsUnit;).
        These content units are then normalized via <map></map>&jd_map_attribute_content;,
        which is defined below.
      </p>

      <p diff='del' at='E011'>As with literal XML elements, we need to distinguish between
      direct attribute constructors that contain one attribute-content
      unit and those that contain multiple attribute-content units,
      because the rule for converting sequences of atomic values into
      strings is applied to sequences within distinct enclosed
      expressions.  If the direct attribute constructor contains
      exactly one attribute-content unit, we simply normalize that
      unit by applying the normalization rule for attribute content
      units:</p>

      <mapping diff='del' at='E011'>
      <xquery>
        <expression><map> &gr_AttributeContentUnit1;
          </map>&jd_map_attribute_content;</expression>
      </xquery>
      <core>
        <expression>
          <map>&gr_AttributeContentUnit1;</map>&jd_map_attribute_content_unit;
        </expression>
      </core>
      </mapping>

      <p>
      <phrase diff='chg' at='E011'>
      To apply <map></map>&jd_map_attribute_content; to zero or more attribute-content units,
      </phrase>
      we normalize each unit individually and
      construct a sequence of the normalized results<phrase diff='del' at='E031'> interleaved with
      empty text nodes.  The empty text nodes guarantee that the
      results of evaluating consecutive attribute-content units can be
      distinguished</phrase>.  Then we apply the function
      <phrase diff='del' at='E031'>
      &fs_item_seq_to_untypedAtomic;, which applies the appropriate
      conversion rules to the normalized attribute content:
      </phrase>
      <phrase diff='add' at='E031'>
      <code>fn:string-join</code>, which will concatenate the values of the normalized units.
      </phrase>
      </p>

      <mapping>
      <xquery>
        <expression><map> &gr_AttributeContentUnit1; ...
          &gr_AttributeContentUnitn;
          </map>&jd_map_attribute_content;</expression>
      </xquery>
      <core>
        <expression>
          <phrase diff='del' at='E031'>&fs_item_seq_to_untypedAtomic;</phrase>
          <phrase diff='add' at='E031'>fn:string-join</phrase>
          ((<map> &gr_AttributeContentUnit1;
          </map>&jd_map_attribute_content_unit; ,
          <phrase diff='del' at='E031'>text { "" },</phrase>
          ...,
          <phrase diff='del' at='E031'>text {""},</phrase>
          <map>
          &gr_AttributeContentUnitn;</map>&jd_map_attribute_content_unit;)
          <phrase diff='add' at='E031'>, ''</phrase>
          )
        </expression>
      </core>
      </mapping>

      <p diff='add' at='E011'>
        (Note that this rule should be understood to cover
        the degenerate cases of n=0 and n=1,
        where the attribute constructor's content
        consists of zero or one attribute-content units.)
      </p>

      <p diff='del' at='E001'>Literal characters, escaped curly braces, character
      references, and predefined entity references in attribute
      content are treated as in element content.  In addition, the
      normalization rule for characters in attributes assumes:</p>

      <olist diff='del' at='E001'>
        <item><p>that an escaped single or double quote is converted
        to an individual single or double quote.</p></item>
      </olist>

      <p diff='del' at='E001'>The following normalization rules take the longest
      consecutive sequence of individual characters that include
      literal characters, escaped curly braces, escaped quotes,
      character references, predefined entity references, and escaped
      single and double quotes and normalizes the character sequence
      as a string. </p>

      <mapping diff='del' at='E001'>
        <xquery>
          <expression><map>( &gr_Char; | &gr_CharRef; |
          &gr_EscapeQuot; | &gr_EscapeApos; | &gr_PredefinedEntityRef;
          ) +</map>&jd_map_attribute_content_unit;</expression>
        </xquery>
        <core>
          <expression>&fs_characters_to_string;(( &gr_Char; | &gr_CharRef; |
          &gr_EscapeQuot; | &gr_EscapeApos; | &gr_PredefinedEntityRef;
          )+)</expression>
        </core>
      </mapping>

      <p diff='add' at='E001'>
      The next two rules specify the normalization of each attribute-content unit
      via <map></map>&jd_map_attribute_content_unit;.
      </p>

      <p diff='add' at='E001'>
      We normalize an &gr_AttributeCharsUnit;
        (i.e., a maximal run of attribute-content characters, including
        literal characters,
        character references,
        predefined entity references,
        escaped curly braces,
        and escaped single and double quotes)
      by converting it into a string literal.
      </p>

      <mapping diff='add' at='E001'>
        <xquery>
          <expression>
            <map>
              <phrase diff='chg' at='E001'>&gr_AttributeCharsUnit;</phrase>
            </map>&jd_map_attribute_content_unit;
          </expression>
        </xquery>
        <core>
          <expression diff='chg' at='E001'>
            <map>
              &gr_AttributeCharsUnit;
            </map>&jd_map_attribute_chars_unit;
          </expression>
        </core>
      </mapping>

      <p id="jd_map_attribute_chars_unit" diff='add' at='E001'>
        The effect of <map>&gr_AttributeCharsUnit;</map>&jd_map_attribute_chars_unit;
        is not specified formally;
        informally, it
        unescapes any escaped braces or quotes,
        performs attribute value normalization
        as specified in <xspecref spec="XQ" ref="id-attributes"/>,
        and then represents the resulting string value
        as a string literal.
      </p>

      <p>We normalize an enclosed expression
      <phrase diff='del' at='E031'>
      by normalizing each
      individual expression in its expression sequence and then
      constructing a sequence of the normalized values:
      </phrase>
      <phrase diff='add' at='E031'>
      into a call to the function &fs_item_seq_to_string;,
      which implements various rules
      for converting a sequence of atomic values and nodes
      into a string.
      </phrase>
      </p>


      <mapping>
      <xquery>
        <expression><map> {
          <phrase diff='del' at='E031'>&gr_Expr1;, ..., &gr_Exprn;</phrase>
          <phrase diff='add' at='E031'>&gr_Expr;</phrase>
          }
          </map>&jd_map_attribute_content_unit;</expression>
      </xquery>
      <core>
        <expression>
          <phrase diff='del' at='E031'>(<map> &gr_Expr1; </map>&jd_map_expr; , ..., <map> &gr_Exprn;</map>&jd_map_expr;)</phrase>
          <phrase diff='add' at='E031'>&fs_item_seq_to_string;(( <map> &gr_Expr; </map>&jd_map_expr; ))</phrase>
        </expression>
      </core>
      </mapping>
    </smnorm>
    </div4>

    <div4 id="sec_namespace_attrs">
      <head>Namespace Declaration Attributes</head>

      <smnotation>
        <p id="jd_map_namespace_attr">The auxiliary mapping rules
        <map></map>&jd_map_namespace_attr;, and
        <map></map>&jd_map_namespace_attrs; are defined in this
        section and are used for the normalization of namespace
        declaration attributes.</p>
      </smnotation>

      <smnorm>
        <p>Some direct attributes may be namespace-declaration
        attributes.  The normalization rules for namespace-declaration
        attributes ignore all non-namespace attributes -- they are
        handled by the normalization rules in <specref
        ref="sec_direct_attributes"/>.</p>

        <p>A &gr_DirAttributeList; containing namespace-declaration
        attributes is normalized by the following rule, which maps
        each of the individual namespace-declaration attributes in the
        attribute list and constructs a sequence of the normalized
        namespace attribute values.</p>

      <mapping>
      <xquery>
        <expression>
      <map><table summary=""><tbody>
      <tr><td>
          &gr_QName1; S? = S? &gr_DirAttributeValue1;
      </td></tr>
      <tr><td>
          ...
      </td></tr>
      <tr><td>
          &gr_QNamen; S? = S? &gr_DirAttributeValuen;
      </td></tr>
      </tbody></table></map>&jd_map_namespace_attrs;
        </expression>
        </xquery>
      <core>
      <expression>
      <table summary=""><tbody>
      <tr><td>
        (<map>&gr_QName1; S? = S? &gr_DirAttributeValue1;</map>&jd_map_namespace_attr;
      </td></tr>
      <tr><td>
         ..., 
      </td></tr>
      <tr><td>
        <map>&gr_QNamen; S? = S? &gr_DirAttributeValuen;</map>&jd_map_namespace_attr;)
      </td></tr>
      </tbody></table>
      </expression>
      </core>
      </mapping>

      <p>Attributes whose prefix is not <code>xmlns</code> are ignored
      by mapping them to the empty sequence.</p>

      <mapping>
      <xquery>
        <expression>
<table summary=""><tbody><tr><td>
      <map>&gr_Prefix;:&gr_LocalPart; S? = S? &gr_DirAttributeValue;</map>&jd_map_namespace_attr;
</td></tr>
<tr><td>
      &jd_not;(&gr_Prefix; = <code>xmlns</code>)
</td></tr>
</tbody></table>
</expression>
        </xquery>
      <core>
      <expression>
        ()
      </expression>
      </core>
      </mapping>

      <p>Namespace-declaration attributes are normalized to local
      namespace declarations (<phrase diff='chg' at='E002'>&gr_LocalNamespaceDecl;</phrase>). The content of
      such attributes must be defined with a URI literal.</p>

      <mapping>
      <xquery>
        <expression>
<table summary=""><tbody><tr><td>
      <map>&gr_Prefix;:&gr_LocalPart; S? = S? &quot; &gr_URILiteral; &quot;</map>&jd_map_namespace_attr;
</td></tr>
<tr><td>
      (&gr_Prefix; = <code>xmlns</code>)
</td></tr>
</tbody></table>
        </expression>
        </xquery>
      <core>
      <expression>
        namespace &gr_LocalPart; { &gr_URILiteral; }
      </expression>
      </core>
      </mapping>

    </smnorm>
    </div4>

    <div4 id="sec_content">
      <head>Content</head>
<p>The rules for normalizing element content are given above in
<specref ref="id_element_constructor"/>.</p>
    </div4>

    <div4 id="sec_whitespace">
      <head>Boundary Whitespace</head>

      <p><xspecref spec="XQ" ref="id-whitespace"/> describes how
      whitespace is processed in element constructors depending on the
      value of the <code>boundary-space</code> declaration in the
      query prolog. The Formal Semantics assumes that the rules for
      handling whitespace are applied by the (informally defined)
      auxiliary rule <map></map>&jd_dir_chars_units;.</p> </div4>

  </div3>
  <!-- ***************** PI and Comments       ****** -->
  <div3 id="sec_other_constructors">
    <head>Other Direct Constructors</head>

    <scrap>
      <head>Other Constructors</head>
      <prodrecap id="DirPIConstructor"      ref="DirPIConstructor"      orig="xquery"/>
      <prodrecap id="DirPIContents"         ref="DirPIContents"         orig="xquery"/>
      <prodrecap id="DirCommentConstructor" ref="DirCommentConstructor" orig="xquery"/>
      <prodrecap id="DirCommentContents"    ref="DirCommentContents"    orig="xquery"/>
    </scrap>

    <smnotation>
      <p id="jd_map_characters">The auxiliary mapping rule
      <map></map>&jd_map_characters; is defined in this section and
      used for the normalization of direct PI and comment
      constructors.</p>

      <p><map>&gr_Char;*</map>&jd_map_characters; takes the character
      content of a PI or comment constructor and yields a
      corresponding &gr_StringLiteral;.</p>
    </smnotation>

    <smnorm>
      <p>A literal XML processing instruction is normalized into a
      computed processing-instruction constructor; its character
      content is converted to a string using the auxiliary mapping
      rule <map></map>&jd_map_characters;.</p>

   <mapping>
    <xquery>
     <expression>
      <map>&lt;? &gr_NCName; &gr_DirPIContents; ?&gt;</map>&jd_map_expr;
     </expression>
    </xquery>
    <core>
     <expression>
      <map>processing-instruction &gr_NCName; { <map>&gr_DirPIContents;</map>&jd_map_characters; }</map>&jd_map_expr;
     </expression>
    </core>
   </mapping>

    <p>A literal XML comment is normalized into a computed comment
    constructor; its character content is converted to a string using
    the auxiliary mapping rule <map></map>&jd_map_characters;.</p>

    <mapping>
    <xquery>
    <expression>
     <map>&lt;!-- &gr_DirCommentContents; --&gt;</map>&jd_map_expr;
    </expression>
    </xquery>
    <core>
    <expression>
     <map>comment { <map>&gr_DirCommentContents;</map>&jd_map_characters; }</map>&jd_map_expr;
    </expression>
    </core>
    </mapping>

    </smnorm>

    <smtype>
      <p>There are no additional static typing rules for direct
      processing-instruction or comment constructors.</p>
    </smtype>

    <smeval>
      <p>There are no additional dynamic evaluation rules for direct
      processing-instruction or comment constructors.</p>
    </smeval>

  </div3>
   
  <div3 id="sec_computedConstructors">
    <head>Computed Constructors</head>

    <scrap>
      <head>Computed Constructors</head>
      <prodrecap id="ComputedConstructor" ref="ComputedConstructor" orig="xquery"/>
    </scrap>

  <div4 id="sec_comp_elem_constructor">
    <head>Computed Element Constructors</head>

    <smintro><p>This section describes the semantics of computed
    element constructors. Remember that direct element constructors
    are normalized into computed element constructors. This document
    does not formally specify how namespaces are copied. The semantics
    of namespaces copying in element constructors can be found in
    &xq_xquerydoc;.</p></smintro>

    <scrap>
      <head></head>
      <prodrecap id="CompElemConstructor" ref="CompElemConstructor" orig="xquery"/>
      <prodrecap id="ContentExpr"         ref="ContentExpr"         orig="xquery"/>
    </scrap>

<!--
    <smnotation>
      <p id="jd_split_namespaces">Local namespace declarations may
      occur explicitly in a computed element constructor or may be the
      result of normalizing namespace-declaration attributes contained
      in direct element constructors.  For local element declarations
      that occur explicitly in a query, the immediately enclosing
      expression of the local namespace declaration
      (<phrase diff='chg' at='E002'>&gr_LocalNamespaceDecl;</phrase>) must be a computed element constructor;
      otherwise, as specified in &language;, a static error is
      raised.</p>
    </smnotation>
-->

    <smcore>
      <p>The Core grammar productions for computed element
      constructors are:</p>

      <scrap diff='chg' at='E002'><head>Computed Element Constructors</head>
      <prodrecap id="core-CompElemConstructor" ref="CompElemConstructor" orig="core"/>
      <prodrecap id="core-ContentExpr"         ref="ContentExpr"         orig="core"/>
      <prodrecap id="LocalNamespaceDecls"      ref="LocalNamespaceDecls"   orig="core"/>
      <prodrecap id="LocalNamespaceDecl"       ref="LocalNamespaceDecl"    orig="core"/>
      </scrap>
    </smcore>

    <smnorm>
      <p>If the content expression is missing, the computed element
      constructor is normalized as if its content expression was the
      empty sequence.</p>

      <mapping>
       <xquery>
 	<expression>
         <map>element &gr_QName; { }</map>&jd_map_expr;
        </expression>
       </xquery>
       <core>
        <expression>
         <map>element &gr_QName; { () }</map>&jd_map_expr;
        </expression>
       </core>
      </mapping>

      <p>Computed element constructors are normalized using the
      &fs_item_seq_to_node_seq; function over their content
      expression.</p>

      <mapping>
       <xquery>
 	<expression>
         <map>element &gr_QName; { &gr_Expr; }</map>&jd_map_expr;
        </expression>
       </xquery>
       <core>
        <expression>
         element &gr_QName; { &fs_item_seq_to_node_seq;((<map>&gr_Expr;</map>&jd_map_expr;)) }<phrase diff='add' at='E003'> {}</phrase>
        </expression>
       </core>
      </mapping>

      <p>When the name of the element is also computed, the
      normalization rule applies atomization to the name
      expression.</p>

      <mapping>
       <xquery>
 	<expression>
         <map>element { &gr_Expr1; } { &gr_Expr2; }</map>&jd_map_expr;
        </expression>
       </xquery>
       <core>
        <expression>
          element { &fn_data;((<map>&gr_Expr1;</map>&jd_map_expr;)) }{ &fs_item_seq_to_node_seq;((<map>&gr_Expr2;</map>&jd_map_expr;)) }<phrase diff='add' at='E003'> {}</phrase>
        </expression>
       </core>
      </mapping>
    </smnorm>

    <smnotation>
      <p id="jd_add_namespace_bindings">The following auxiliary
      judgment adds a sequence of namespace bindings to the static
      context.</p>

        <display>
          <clause>
          <expression>&jd_add_namespace_bindings;
          <phrase diff='chg' at='E002'>&gr_LocalNamespaceDecls;</phrase> &jd_add_namespace_bindings_to;
          &xq_stat_env1; &jd_add_namespace_bindings_yields;
          &xq_stat_env2;</expression>
          </clause>
        </display>

      <p>This judgment is defined as follows.</p>

        <infergr>
          <infer>
            <prejudge>
            </prejudge>
            <postjudge>
              <multiclause>
                <clause><environment>&xq_stat_env; </environment>
                  <expression>
                    &jd_add_namespace_bindings; &jd_add_namespace_bindings_to;
          &xq_stat_env0; &jd_add_namespace_bindings_yields;
          &xq_stat_env0;
                  </expression>
                </clause>
              </multiclause>
            </postjudge>
          </infer>
        </infergr>

        <infergr>
          <infer>
            <prejudge>
              <multiclause>
                <clause>
                  <expression><phrase diff='chg' at='E002'>&gr_LocalNamespaceDecl1;</phrase> = namespace &gr_LocalPart1; { &gr_URILiteral1; }</expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <expression>
                    ...
                  </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <expression><phrase diff='chg' at='E002'>&gr_LocalNamespaceDecln;</phrase> = namespace &gr_LocalPartn; { &gr_URILiteraln; }</expression>
                </clause>
              </multiclause>
 	  <multiclause>
 	    <clause>
            <environment>&xq_default_dyn_env;</environment>
 	    <expression>&gr_URILiteral1; &jd_has_atomic_value; &gr_URI;
 	    </expression>
 	    </clause>
 	  </multiclause>
          <multiclause>
            <clause>
              <expression>
                ...
              </expression>
            </clause>
          </multiclause>
 	  <multiclause>
 	    <clause>
            <environment>&xq_default_dyn_env;</environment>
 	    <expression>&gr_URILiteral1; &jd_has_atomic_value; &gr_URI;
 	    </expression>
 	    </clause>
 	  </multiclause>
          <multiclause>
          <clause>
            <expression>&xq_ns_env1; =
              <update>
                <environment>&xq_ns_env0;</environment>
                <expression>&gr_LocalPart1; &xt_bind; (passive, &gr_URI1;)</expression>
              </update></expression>
          </clause>
          </multiclause>
              <multiclause>
                <clause>
                  <expression>
                    ...
                  </expression>
                </clause>
              </multiclause>
          <multiclause>
          <clause>
            <expression>&xq_ns_envn; =
              <update>
                <environment>&xq_ns_envnm1;</environment>
                <expression>&gr_LocalPartn; &xt_bind; (passive, &gr_URIn;)</expression>
              </update></expression>
          </clause>
          </multiclause>
            </prejudge>
            <postjudge>
              <multiclause>
                <clause><environment>&xq_stat_env; </environment>
                  <expression>
                    &jd_add_namespace_bindings;
          <phrase diff='chg' at='E002'>&gr_LocalNamespaceDecl1; ... &gr_LocalNamespaceDecln;</phrase> &jd_add_namespace_bindings_to;
          &xq_stat_env0; &jd_add_namespace_bindings_yields;
          &xq_stat_envn;
                  </expression>
                </clause>
              </multiclause>
            </postjudge>
          </infer>
        </infergr>
    </smnotation>

    <smtype>
      <p>The normalization rules of direct element and attribute
      constructors leave us with only the computed forms of
      constructors. The static semantics for constructors is defined
      on all the computed forms. The computed element constructor
      itself has two forms: one in which the element name is a literal
      &gr_QName;, and the other in which the element name is a
      computed expression.</p>

      <p>A computed element constructor creates a new element with
      either the <xtermref spec="XQ" ref="dt-type-annotation"/>
      &xs_untyped; (in strip construction mode), or with the <xtermref
      spec="XQ" ref="dt-type-annotation"/> &xs_anyType; (in preserve
      construction mode). The content expression must return a
      <phrase diff='chg' at='E012'>
      sequence of nodes with attribute nodes at the beginning.
      </phrase>
      </p>

      <infergr>
	<infer>
	  <prejudge>
 	    <multiclause>
 	      <clause>
 	      <expression>&xq_construction_mode_env; = preserve</expression>
 	      </clause>
 	    </multiclause>
 	    <multiclause>
               <clause>
               <expression>&jd_add_namespace_bindings;
               <phrase diff='chg' at='E002'>&gr_LocalNamespaceDecls;</phrase> &jd_add_namespace_bindings_to;
               &xq_stat_env1; &jd_add_namespace_bindings_yields;
               &xq_stat_env2;</expression>
               </clause>
 	    </multiclause>
	    <multiclause>
	      <clause><environment>&xq_stat_env2;</environment>
                      <expression>&gr_Expr; &jd_has_type; &gr_Type;</expression>
	      </clause>
	    </multiclause>
	    <multiclause>
	      <clause diff='chg' at='E012'><environment>&xq_stat_env2;</environment>
              <expression>&gr_Type; &jd_subtype_of;
              attribute<phrase diff='add' at='E023'> *</phrase>*, (element<phrase diff='add' at='E023'> *</phrase> | text | comment | processing-instruction<phrase diff='add' at='E022'> *</phrase>) * </expression>
	      </clause>
	    </multiclause>
	  </prejudge>
	  <postjudge>
	    <clause><environment>&xq_stat_env1;</environment>
	            <expression> element &gr_QName; {
	            &gr_Expr; } { <phrase diff='chg' at='E002'>&gr_LocalNamespaceDecls;</phrase> }
	            &jd_has_type; element &gr_QName; of type &xs_anyType;
	      </expression>
	    </clause>
	  </postjudge>
	</infer>
      </infergr>

      <infergr>
	<infer>
	  <prejudge>
 	    <multiclause>
 	      <clause>
 	      <expression>&xq_construction_mode_env; = strip</expression>
 	      </clause>
 	    </multiclause>
 	    <multiclause>
               <clause>
               <expression>&jd_add_namespace_bindings;
               <phrase diff='chg' at='E002'>&gr_LocalNamespaceDecls;</phrase> &jd_add_namespace_bindings_to;
               &xq_stat_env1; &jd_add_namespace_bindings_yields;
               &xq_stat_env2;</expression>
               </clause>
 	    </multiclause>
	    <multiclause>
	      <clause><environment>&xq_stat_env2;</environment>
                      <expression>&gr_Expr; &jd_has_type; &gr_Type;</expression>
	      </clause>
	    </multiclause>
	    <multiclause>
	      <clause diff='chg' at='E012'><environment>&xq_stat_env2;</environment>
                      <expression>&gr_Type; &jd_subtype_of;
                      attribute<phrase diff='add' at='E023'> *</phrase>*, (element<phrase diff='add' at='E023'> *</phrase> | text | comment | processing-instruction<phrase diff='add' at='E022'> *</phrase>) * </expression>
	      </clause>
	    </multiclause>
	  </prejudge>
	  <postjudge>
	    <clause><environment>&xq_stat_env1;</environment>
	            <expression> element &gr_QName; {
	            &gr_Expr; } { <phrase diff='chg' at='E002'>&gr_LocalNamespaceDecls;</phrase> }
	            &jd_has_type; element &gr_QName; of type &xs_untyped;
	      </expression>
	    </clause>
	  </postjudge>
	</infer>
      </infergr>

      <p>In case the element name is computed as well, the name
      expression must be of type &xs_QName;, &xs_string;, or
      &xs_untypedAtomic;.</p>

      <infergr>
	<infer>
	  <prejudge>
 	    <multiclause>
 	      <clause>
 	      <expression>&xq_construction_mode_env; = preserve</expression>
 	      </clause>
 	    </multiclause>
 	    <multiclause>
               <clause>
               <expression>&jd_add_namespace_bindings;
               <phrase diff='chg' at='E002'>&gr_LocalNamespaceDecls;</phrase> &jd_add_namespace_bindings_to;
               &xq_stat_env1; &jd_add_namespace_bindings_yields;
               &xq_stat_env2;</expression>
               </clause>
 	    </multiclause>
	    <multiclause>
	      <clause><environment>&xq_stat_env2;</environment>
                      <expression>&gr_Expr1; &jd_has_type; &gr_Type1;</expression>
	      </clause>
	    </multiclause>
	    <multiclause>
	      <clause><environment>&xq_stat_env2;</environment>
                      <expression>&gr_Type1; &jd_subtype_of;
                      (&xs_QName; | &xs_string; | &xs_untypedAtomic;) </expression>
	      </clause>
	    </multiclause>
	    <multiclause>
	      <clause><environment>&xq_stat_env2;</environment>
                      <expression>&gr_Expr2; &jd_has_type; &gr_Type2;</expression>
	      </clause>
	    </multiclause>
	    <multiclause>
	      <clause diff='chg' at='E012'><environment>&xq_stat_env2;</environment>
                      <expression>&gr_Type2; &jd_subtype_of;
                      attribute<phrase diff='add' at='E023'> *</phrase>*, (element<phrase diff='add' at='E023'> *</phrase> | text | comment | processing-instruction<phrase diff='add' at='E022'> *</phrase>) * </expression>
	      </clause>
	    </multiclause>
	  </prejudge>
	  <postjudge>
	    <clause><environment>&xq_stat_env1;</environment>
	            <expression> element { &gr_Expr1; } { &gr_Expr2; }
	            { <phrase diff='chg' at='E002'>&gr_LocalNamespaceDecls;</phrase> }
	            &jd_has_type; element<phrase diff='add' at='E023'> *</phrase> of type &xs_anyType;
	      </expression>
	    </clause>
	  </postjudge>
	</infer>
      </infergr>

      <infergr>
	<infer>
	  <prejudge>
 	    <multiclause>
 	      <clause>
 	      <expression>&xq_construction_mode_env; = strip</expression>
 	      </clause>
 	    </multiclause>
 	    <multiclause>
               <clause>
               <expression>&jd_add_namespace_bindings;
               <phrase diff='chg' at='E002'>&gr_LocalNamespaceDecls;</phrase> &jd_add_namespace_bindings_to;
               &xq_stat_env1; &jd_add_namespace_bindings_yields;
               &xq_stat_env2;</expression>
               </clause>
 	    </multiclause>
	    <multiclause>
	      <clause><environment>&xq_stat_env2;</environment>
                      <expression>&gr_Expr1; &jd_has_type; &gr_Type1;</expression>
	      </clause>
	    </multiclause>
	    <multiclause>
	      <clause><environment>&xq_stat_env2;</environment>
                      <expression>&gr_Type1; &jd_subtype_of;
                      (&xs_QName; | &xs_string; | &xs_untypedAtomic;) </expression>
	      </clause>
	    </multiclause>
	    <multiclause>
              <clause>
	      <environment>&xq_stat_env2;</environment>
	      <expression> &gr_Expr2; &jd_has_type; &gr_Type2;</expression>
	      </clause>
	    </multiclause>
	    <multiclause>
	      <clause diff='chg' at='E012'><environment>&xq_stat_env2;</environment>
                      <expression>&gr_Type2; &jd_subtype_of;
                      attribute<phrase diff='add' at='E023'> *</phrase>*, (element<phrase diff='add' at='E023'> *</phrase> | text | comment | processing-instruction<phrase diff='add' at='E022'> *</phrase>) * </expression>
	      </clause>
	    </multiclause>
	  </prejudge>
	  <postjudge>
	    <clause><environment>&xq_stat_env1;</environment>
	            <expression> element { &gr_Expr1; } { &gr_Expr2; }
	            { <phrase diff='chg' at='E002'>&gr_LocalNamespaceDecls;</phrase> }
	            &jd_has_type; element<phrase diff='add' at='E023'> *</phrase> of type &xs_untyped;
	      </expression>
	    </clause>
	  </postjudge>
	</infer>
      </infergr>

     </smtype>

     <smnotation diff='add' at='E029'>
       <p id="jd_with_text_nodes_processed_is">
       The following auxiliary judgment
       is used in the dynamic semantics of node constructors.
       </p>

       <display>
         <clause>
           <expression>
             &gr_Value0; &jd_with_text_nodes_processed_is; &gr_Value1;
           </expression>
         </clause>
       </display>

       <p>
       This judgment is informally defined to hold when
       &gr_Value1; is obtained by applying the following modifications to &gr_Value0;:
       </p>
       <ulist>
         <item>
         <p>
         Adjacent text nodes in &gr_Value0; are merged into a single text node
         by concatenating their contents, with no intervening blanks.
         </p>
         </item>
         <item>
         <p>
         After concatenation, any text node whose content is a zero-length string
         is deleted from the sequence.
         </p>
         </item>
       </ulist>
     </smnotation>

     <smeval>
       <p>The following rules take a computed element constructor
       expression and construct an element node.  The dynamic
       semantics for computed element constructors is the most complex
       of all expressions in XQuery.  Here is how to read the rule
       below.</p>

       <p>
       <phrase diff='chg' at='E003'> First, the constructor's</phrase>
       local namespace declarations are evaluated, yielding a
       sequence of namespace bindings.  The static environment is
       extended to include the new namespace bindings, which are all
       <a href="#term_active">active</a>.  In <xspecref spec="XQ"
       ref="id-namespaces"/>, it is implementation-defined whether
       undeclaration of namespace prefixes (by setting the namespace
       prefix to the zero-length string) in an element constructor is
       supported.  In the dynamic semantics below, we assume all local
       namespace declarations declare a binding of a prefix to a
       URI.</p>

       <p>Second, the expression is evaluated,
       <phrase diff='del' at='E029'>
       and the resulting value &gr_Value0;
       </phrase>
       <phrase diff='add' at='E029'>
       and its value's text nodes are processed. The resulting sequence
       </phrase>
       must match zero-or-more attributes followed by
       zero-or-more element, text, processing-instruction or comment
       nodes.</p>

       <p>Third, the namespace bindings are concatenated with the list
       of active namespaces in the namespace environment &xq_ns_env;
       and the namespaces corresponding to the element's name and all
       attributes names.  The resulting sequence is the sequence of
       namespace bindings for the element.</p>

       <infergr>
	 <infer>
	   <prejudge>
	     <multiclause>
	       <clause>
		 <expression>&gr_Expr; = &gr_Expr0; </expression>
	       </clause>
	     </multiclause>
	     <multiclause>
	       <clause>
		 <environment>&xq_stat_envn;; &xq_dyn_env;</environment>
		 <expression> &gr_Expr0; &jd_yields; &gr_Value0; </expression>
	       </clause>
	     </multiclause>
             <multiclause diff='add' at='E029'>
               <clause>
                 <expression>&gr_Value0; &jd_with_text_nodes_processed_is; &gr_Value1;</expression>
               </clause>
             </multiclause>
	     <multiclause>
	       <clause>
		 <environment> &xq_stat_env; </environment>
                 <expression>
                 <phrase diff='del' at='E029'>&gr_Value0;</phrase>
                 <phrase diff='add' at='E029'>&gr_Value1;</phrase>
                 &jd_matches; (attribute<phrase diff='add' at='E023'>*</phrase>*, (element<phrase diff='add' at='E023'> *</phrase> | text | processing-instruction<phrase diff='add' at='E022'> *</phrase> | comment)*)
                 </expression>
	       </clause>
	     </multiclause>
	   </prejudge>
	   <postjudge>
	     <clause><environment>&xq_stat_env;; &xq_dyn_env;</environment>
	       <expression>
		     element &gr_QName; { &gr_Expr; }<phrase diff='add' at='E003'> {}</phrase> &jd_yields;
		     element &gr_QName; of type &xs_anyType; {
		     <phrase diff='del' at='E029'>&gr_Value0;</phrase>
		     <phrase diff='add' at='E029'>&gr_Value1;</phrase>
                     } { }
	       </expression>
	     </clause>
	   </postjudge>
	 </infer>
       </infergr>

       <infergr>
	 <infer>
	   <prejudge>
	     <multiclause>
	       <clause>
		 <expression> &gr_Expr; = <phrase diff='chg' at='E003'>&gr_Expr0;</phrase> </expression>
	       </clause>
	     </multiclause>

            <multiclause diff='add' at='E003'>
              <clause>
                <expression> &gr_LocalNamespaceDecls; = &gr_LocalNamespaceDecl1; ... &gr_LocalNamespaceDecln;</expression>
              </clause>
            </multiclause>

            <multiclause diff='add' at='E003'>
              <clause>
                <expression> &gr_LocalNamespaceDecl1; = namespace &gr_NCName1; { &gr_URILiteral1; }</expression>
              </clause>
            </multiclause>
            <multiclause diff='add' at='E003'>
              <clause><expression>...</expression></clause>
           </multiclause>
            <multiclause diff='add' at='E003'>
              <clause>
               <expression> &gr_LocalNamespaceDecln; = namespace &gr_NCNamen; { &gr_URILiteraln; }</expression>
              </clause>
            </multiclause>

            <multiclause diff='add' at='E003'>
              <clause>
                <environment>&xq_default_dyn_env;</environment>
                <expression>&gr_URILiteral1; &jd_has_atomic_value; &gr_URI1;</expression>
              </clause>
            </multiclause>
            <multiclause diff='add' at='E003'>
              <clause>
                <expression>...</expression>
              </clause>
            </multiclause>
            <multiclause diff='add' at='E003'>
              <clause>
                <environment>&xq_default_dyn_env;</environment>
                <expression>&gr_URILiteraln; &jd_has_atomic_value; &gr_URIn;</expression>
              </clause>
            </multiclause>

            <multiclause> 
            <clause>          
            <expression>&gr_NamespaceBinding1; = namespace &gr_NCName1; { &gr_URI1; }</expression>
            </clause>
            </multiclause>
	     <multiclause>
               <clause><expression>...</expression></clause>
             </multiclause>
            <multiclause>
            <clause>          
            <expression>&gr_NamespaceBindingn; = namespace  &gr_NCNamen; { &gr_URIn; }</expression>
            </clause>
            </multiclause>
            <multiclause>
            <clause>
            <expression>
              &xq_stat_env1; = 
              <update>
                <environment>&xq_ns_env;</environment>
                <expression>&gr_NCName1; &xt_bind; (active, &gr_URI1;)</expression>
              </update>
            </expression>
            </clause>
            </multiclause>
            <multiclause>
            <clause><expression>...</expression></clause>
            </multiclause>
            <multiclause>
            <clause>
            <expression>
              &xq_stat_envn; = 
              <update>
                <environment>&xq_ns_envnm1;</environment>
                <expression>&gr_NCNamen; &xt_bind; (active, &gr_URIn;)</expression>
              </update>
            </expression>
            </clause>
            </multiclause>

	     <multiclause>
	       <clause>
		 <environment>&xq_stat_envn;; &xq_dyn_env;</environment>
		 <expression>&gr_Expr0; &jd_yields; &gr_Value0; </expression>
	       </clause>
	     </multiclause>
             <multiclause diff='add' at='E029'>
               <clause>
                 <expression>&gr_Value0; &jd_with_text_nodes_processed_is; &gr_Value1;</expression>
               </clause>
             </multiclause>
	     <multiclause>
	       <clause>
		 <environment> &xq_stat_env; </environment>
                 <expression>
                   <phrase diff='del' at='E029'>&gr_Value0;</phrase>
                   <phrase diff='add' at='E029'>&gr_Value1;</phrase>
                   &jd_matches; (attribute<phrase diff='add' at='E023'>*</phrase>*, (element<phrase diff='add' at='E023'> *</phrase> | text | processing-instruction<phrase diff='add' at='E022'> *</phrase> | comment)*)
                 </expression>
	       </clause>
	     </multiclause>

	     <multiclause>
	       <clause>
		 <expression>&gr_NamespaceBindings; = 
		 &gr_NamespaceBinding1;,
		 ..., &gr_NamespaceBindingn;,
		 &fs_activeNS;(&xq_stat_env;),
		 &fs_ns_from_items;(&xq_stat_env;,
                 <phrase diff='del' at='E029'>&gr_Value0;</phrase>
                 <phrase diff='add' at='E029'>&gr_Value1;</phrase>
                 )</expression>
	       </clause>
	     </multiclause>

	   </prejudge>
	   <postjudge>
	     <clause><environment>&xq_stat_env;; &xq_dyn_env;</environment>
	       <expression>
		     element &gr_QName; { &gr_Expr; }<phrase diff='add' at='E003'> { &gr_LocalNamespaceDecls; }</phrase> &jd_yields;
		     element &gr_QName; of type &xs_anyType; {
		     <phrase diff='del' at='E029'>&gr_Value0;</phrase>
		     <phrase diff='add' at='E029'>&gr_Value1;</phrase>
                     } { &gr_NamespaceBindings; }
	       </expression>
	     </clause>
	   </postjudge>
	 </infer>
       </infergr>

       <p>The dynamic evaluation of an element constructor with a
       computed name is similar.  There is one additional rule that
       checks that the value of the element's name expression matches
       &xs_QName;.</p>

       <infergr>
	 <infer>
	   <prejudge>
	     <multiclause>
	       <clause>
		 <environment>&xq_dyn_env;</environment><expression>&gr_Expr1; &jd_yields; &gr_Value0;
		 </expression>
	       </clause>
	     </multiclause>
	     <multiclause>
	       <clause>
                 <environment>&xq_stat_env;</environment>
		 <expression>&gr_Value0; &jd_matches; &xs_QName;
		 </expression>
	       </clause>
	     </multiclause>
	     <multiclause>
	       <clause>
		 <expression>&gr_QName; = &fn_getprefix;(&gr_Value0;)<code>:</code>&fn_getlocalname;(&gr_Value0;)</expression>
	       </clause>
	     </multiclause>
	     <multiclause>
	     <clause><environment>&xq_dyn_env;</environment>
	       <expression>
		     element &gr_QName; { &gr_Expr2; }<phrase diff='add' at='E003'> { &gr_LocalNamespaceDecls; }</phrase> &jd_yields; &gr_Value;
	       </expression>
	     </clause>
	     </multiclause>
	   </prejudge>
	   <postjudge>
	     <clause><environment>&xq_dyn_env;</environment>
	       <expression>
		     element { &gr_Expr1; } { &gr_Expr2; } <phrase diff='add' at='E003'>{ &gr_LocalNamespaceDecls; }</phrase> &jd_yields; &gr_Value;
	       </expression>
	     </clause>
	   </postjudge>
	 </infer>
       </infergr>

    </smeval>

    </div4>

    <div4 id="sec_attribute_constructor">
      <head>Computed Attribute Constructors</head>

      <scrap>
        <head></head>
        <prodrecap id="CompAttrConstructor" ref="CompAttrConstructor" orig="xquery"/>
      </scrap>

      <smcore>
        <p>The Core grammar production for computed attribute
        constructors is:</p>

      <scrap><head>Computed Attribute Constructors</head>
      <prodrecap id="core-CompAttrConstructor" ref="CompAttrConstructor" orig="core"/>
      </scrap>
      </smcore>

      <smnorm>
        <p>Computed attribute constructors are normalized by mapping
        their name and content expression in a similar way as computed
        element constructors. The normalization rule uses the
        <phrase diff='del' at='E031'>&fs_item_seq_to_untypedAtomic;</phrase>
        <phrase diff='add' at='E031'>&fs_item_seq_to_string;</phrase>
        function.</p>

        <mapping>
         <xquery>
          <expression>
           <map>attribute &gr_QName; { }</map>&jd_map_expr;
          </expression>
         </xquery>
         <core>
          <expression>
           <map>attribute &gr_QName; { () }</map>&jd_map_expr;
          </expression>
         </core>
        </mapping>

        <mapping>
         <xquery>
          <expression>
           <map>attribute &gr_QName; { &gr_Expr; }</map>&jd_map_expr;
          </expression>
         </xquery>
         <core>
          <expression>attribute &gr_QName; { 
            <phrase diff='del' at='E031'>&fs_item_seq_to_untypedAtomic;</phrase>
            <phrase diff='add' at='E031'>&fs_item_seq_to_string;</phrase>
            ((<map>&gr_Expr;</map>&jd_map_expr;)) }
          </expression>
         </core>
        </mapping>

        <mapping>
         <xquery>
          <expression>
           <map>attribute { &gr_Expr1; } { &gr_Expr2; }</map>&jd_map_expr;
          </expression>
         </xquery>
         <core>
          <expression>
            attribute { &fn_data;((<map>&gr_Expr1;</map>&jd_map_expr;)) } { 
            <phrase diff='del' at='E031'>&fs_item_seq_to_untypedAtomic;</phrase>
            <phrase diff='add' at='E031'>&fs_item_seq_to_string;</phrase>
            ((<map>&gr_Expr2;</map>&jd_map_expr;)) }
          </expression>
         </core>
        </mapping>
    </smnorm>

    <smtype>
      <p>The normalization rules for direct attribute constructors
      leave us with only the computed form of the attribute
      constructors.  Like in a computed element constructor, a
      computed attribute constructor has two forms: one in which the
      attribute name is a literal &gr_QName;, and the other in which
      the attribute name is a computed expression.</p>

      <p>In the case of attribute constructors, the <xtermref
      spec="XQ" ref="dt-type-annotation"/> is always
      &xs_untypedAtomic;.</p>

     <infergr>
	<infer>
	  <prejudge>
	    <multiclause>
              <clause>
	        <environment>&xq_stat_env;</environment>
	        <expression> &gr_Expr; &jd_has_type; &gr_Type;</expression>
	      </clause>
	    </multiclause>
	    <multiclause>
	      <clause>
                <environment> &xq_stat_env; </environment>
                <expression>&gr_Type; &jd_subtype_of; 
                  <phrase diff='del' at='E031'>&xs_untypedAtomic;</phrase>
                  <phrase diff='add' at='E031'>&xs_string;</phrase>
                </expression>
              </clause>
	    </multiclause>
	  </prejudge>
	  <postjudge>
	    <clause>
              <environment>&xq_stat_env;</environment>
	      <expression> attribute &gr_QName; { &gr_Expr; } &jd_has_type; attribute &gr_QName; of type &xs_untypedAtomic;
	      </expression>
	    </clause>
	  </postjudge>
	</infer>
       </infergr>

      <infergr>
	<infer>
	  <prejudge>
	    <multiclause>
              <clause>
	      <environment>&xq_stat_env;</environment>
	      <expression> &gr_Expr1; &jd_has_type; &gr_Type1;</expression>
	      </clause>
	    </multiclause>
	    <multiclause>
	      <clause><environment>&xq_stat_env;</environment>
                      <expression>&gr_Type1; &jd_subtype_of;
                      (&xs_QName; | &xs_string; | &xs_untypedAtomic;) </expression>
	      </clause>
	    </multiclause>
	    <multiclause>
              <clause>
	      <environment>&xq_stat_env;</environment>
	      <expression> &gr_Expr2; &jd_has_type; &gr_Type2;</expression>
	      </clause>
	    </multiclause>
	    <multiclause>
	      <clause><environment>&xq_stat_env;</environment>
                      <expression>&gr_Type2; &jd_subtype_of; 
                        <phrase diff='del' at='E031'>&xs_untypedAtomic;</phrase>
                        <phrase diff='add' at='E031'>&xs_string;</phrase>
                      </expression>
	      </clause>
	    </multiclause>
	  </prejudge>
	  <postjudge>
	    <clause><environment>&xq_stat_env;</environment>
	            <expression> attribute { &gr_Expr1; } { &gr_Expr2; }
	            &jd_has_type; attribute<phrase diff='add' at='E023'> *</phrase> of type &xs_untypedAtomic;
	      </expression>
	    </clause>
	  </postjudge>
	</infer>
     </infergr>

     </smtype>

     <smeval>
       <p>The following rules take a computed attribute constructor
       expression and construct an attribute node.  The rules are
       similar to those rules for element constructors.  First, the
       attribute's name is expanded into a qualified name.  Second,
       <phrase diff='chg' at='E011'>the
       content expression is evaluated in the
       dynamic environment.</phrase> <phrase diff='del' at='E011'>Recall from <specref
       ref="sec_attribute_constructor"/> that during normalization, we
       do not convert the content of direct attribute constructors
       that contain one attribute-content unit.  This guarantees that
       useful type information is preserved for static analysis.
       Since the conversion function &fs_item_seq_to_untypedAtomic;
       was not applied to all attribute constructors during
       normalization, we have to apply it at evaluation time.  (As
       before, it is possible to elide the application of
       &fs_item_seq_to_untypedAtomic; injected during normalization
       and the application injected during evaluation.)</phrase></p>

       <infergr>
	 <infer>
	   <prejudge>
	     <multiclause>
	       <clause>
		 <environment>&xq_dyn_env;</environment>
		 <expression><phrase diff='chg' at='E011'>&gr_Expr;</phrase> &jd_yields; &gr_AtomicValue; </expression>
	       </clause>
	     </multiclause>
	   </prejudge>
	   <postjudge>
	     <clause><environment>&xq_dyn_env;</environment>
	       <expression>
		     attribute &gr_QName; { &gr_Expr; } &jd_yields;
		     attribute &gr_QName; of type &xs_untypedAtomic; { &gr_AtomicValue; }
	       </expression>
	     </clause>
	   </postjudge>
	 </infer>
       </infergr>

       <infergr>
	 <infer>
	   <prejudge>
	     <multiclause>
	       <clause>
		 <environment>&xq_dyn_env;</environment>
		 <expression> &gr_Expr1; &jd_yields; &gr_Value1;
		 </expression>
	       </clause>
	     </multiclause>
	     <multiclause>
	       <clause>
                 <environment>&xq_stat_env;</environment>
		 <expression>&gr_Value1; &jd_matches; &xs_QName;
		 </expression>
	       </clause>
	     </multiclause>
	     <multiclause>
	       <clause>
		 <expression>&gr_QName1; = &fn_getprefix;(&gr_Value1;)<code>:</code>&fn_getlocalname;(&gr_Value1;)</expression>
	       </clause>
	     </multiclause>
	     <multiclause>
	       <clause>
		 <environment>&xq_dyn_env;</environment>
		 <expression> <phrase diff='chg' at='E011'>&gr_Expr2;</phrase> &jd_yields; &gr_AtomicValue2;</expression>
	       </clause>
	     </multiclause>
	   </prejudge>
	   <postjudge>
	     <clause><environment>&xq_dyn_env;</environment>
	       <expression>
		 attribute { &gr_Expr1; } { &gr_Expr2; } &jd_yields;
		 attribute &gr_QName1; of type &xs_untypedAtomic; { &gr_AtomicValue2; }
	       </expression>
	     </clause>
	   </postjudge>
	 </infer>
       </infergr>
    </smeval>

    </div4>

  <div4 id="sec_documentConstructors">
    <head>Document Node Constructors</head>
 
    <scrap>
      <head></head>
      <prodrecap id="CompDocConstructor" ref="CompDocConstructor" orig="xquery"/>
    </scrap>

    <smcore>
      <p>The Core grammar production for a computed document
      constructor is:</p>

      <scrap>
        <head>Core computed document constructor</head>
        <prodrecap id="core-CompDocConstructor" ref="CompDocConstructor"  orig="core"/>
      </scrap>
    </smcore>

    <smnorm>
      <p>A document node constructor contains an expression, which
      must evaluate to a sequence of element, text, comment, or
      processing-instruction nodes.  <xspecref spec="XQ"
      ref="id-documentConstructors"/> specifies the rules for
      converting a sequence of atomic values and nodes into a sequence
      of nodes before document construction.  The built-in function
      <phrase diff='del' at='E029'><specref ref="sec_items_to_nodes_doc"/></phrase>
      <phrase diff='add' at='E029'>&fs_item_seq_to_node_seq;</phrase>
      implements
      <phrase diff='add' at='E029'>most of</phrase>
      this
      conversion.</p>

      <mapping>
       <xquery>
 	<expression>
         <map>document { &gr_Expr; }</map>&jd_map_expr;
        </expression>
       </xquery>
       <core>
        <expression>
          document {
          <phrase diff='del' at='E029'>&fs_item_seq_to_node_seq_doc;</phrase>
          <phrase diff='add' at='E029'>&fs_item_seq_to_node_seq;</phrase>
          ((<map>&gr_Expr;</map>&jd_map_expr;)) }
        </expression>
       </core>
      </mapping>
    </smnorm>

    <smtype>
      <p><phrase diff='del' at='E029'>The static typing rule does not need to check that the type
      of the argument expression is a sequence of element, text,
      processing-instruction, and comment nodes, as it is already
      checked by the &fs_item_seq_to_node_seq_doc; introduced during
      normalization.</phrase> The type of the entire expression is the most
      general <code>document</code> type, because the document
      constructor erases all <xtermref spec="XQ"
      ref="dt-type-annotation"/> on its content nodes.</p>

	<infergr>
	  <infer>
	    <prejudge>
             <multiclause>
	      <clause><environment>&xq_stat_env;</environment>
		<expression>
		  &gr_Expr; &jd_has_type; &gr_Type;
		</expression>
	      </clause>
             </multiclause>
             <multiclause diff='add' at='E029'>
              <clause>
               <environment>&xq_stat_env;</environment>
               <expression>&gr_Type; &jd_subtype_of; (element*|text|processing-instruction*|comment)*</expression>
              </clause>
             </multiclause>
	    </prejudge>
	    <postjudge>
	      <clause><environment>&xq_stat_env;</environment>
		<expression>
		  document { &gr_Expr; } &jd_has_type; document { &gr_Type; }
		</expression>
	      </clause>
	    </postjudge>
	  </infer>
	</infergr>
      </smtype>

    <smeval>
      <p>The dynamic semantics checks that the argument expression
      evaluates to a value that is a sequence of element, text,
      processing-instruction, or comment nodes. The entire expression
      evaluates to a new document node value. If the construction mode
      is set to <code>strip</code>, the <xtermref spec="XQ"
      ref="dt-type-annotation"/> for all the nodes in content of a
      document node are erased.</p>

	<infergr>
	  <infer>
	    <prejudge>
 	    <multiclause>
 	      <clause>
 	      <expression>&xq_construction_mode_env; = preserve</expression>
 	      </clause>
 	    </multiclause>
             <multiclause>
	      <clause><environment>&xq_dyn_env;</environment>
		<expression>
		      &gr_Expr; &jd_yields;
                      <phrase diff='del' at='E029'>&gr_Value;</phrase>
                      <phrase diff='add' at='E029'>&gr_Value1;</phrase>
		</expression>
	      </clause>
             </multiclause>
             <multiclause diff='add' at='E029'>
               <clause>
                 <expression>&gr_Value1; &jd_with_text_nodes_processed_is; &gr_Value2;</expression>
               </clause>
             </multiclause>
             <multiclause>
	      <clause><environment>&xq_stat_env;</environment>
		<expression>
		      <phrase diff='del' at='E029'>&gr_Value;</phrase>
		      <phrase diff='add' at='E029'>&gr_Value2;</phrase>
                      &jd_matches; (element<phrase diff='add' at='E023'> *</phrase> | text | processing-instruction<phrase diff='add' at='E022'> *</phrase> | comment)* 
		</expression>
	      </clause>
             </multiclause>
	    </prejudge>
	    <postjudge>
	      <clause><environment>&xq_dyn_env;</environment>
		<expression>
		      document { &gr_Expr; } &jd_yields; document {
                      <phrase diff='del' at='E029'>&gr_Value;</phrase>
                      <phrase diff='add' at='E029'>&gr_Value2;</phrase>
                      }
		</expression>
	      </clause>
	    </postjudge>
	  </infer>
	</infergr>

	<infergr>
	  <infer>
	    <prejudge>
	    <multiclause>
	      <clause>
	      <expression>&xq_construction_mode_env; = strip</expression>
	      </clause>
	    </multiclause>
             <multiclause>
	      <clause><environment>&xq_dyn_env;</environment>
		<expression>
		      &gr_Expr; &jd_yields; &gr_Value1;
		</expression>
	      </clause>
             </multiclause>
             <multiclause>
	      <clause>
		<expression>
   	          &gr_Value1; &jd_erases_to; &gr_Value2; 
		</expression>
	      </clause>
             </multiclause>
             <multiclause diff='add' at='E029'>
               <clause>
                 <expression>&gr_Value2; &jd_with_text_nodes_processed_is; &gr_Value3;</expression>
               </clause>
             </multiclause>
             <multiclause>
	      <clause><environment>&xq_stat_env;</environment>
		<expression>
		      <phrase diff='del' at='E029'>&gr_Value2;</phrase>
		      <phrase diff='add' at='E029'>&gr_Value3;</phrase>
                      &jd_matches; (element<phrase diff='add' at='E023'> *</phrase> | text | processing-instruction<phrase diff='add' at='E022'> *</phrase> | comment)* 
		</expression>
	      </clause>
             </multiclause>
	    </prejudge>
	    <postjudge>
	      <clause><environment>&xq_dyn_env;</environment>
		<expression>
		      document { &gr_Expr; } &jd_yields; document {
                      <phrase diff='del' at='E029'>&gr_Value2;</phrase>
                      <phrase diff='add' at='E029'>&gr_Value3;</phrase>
                      }
		</expression>
	      </clause>
	    </postjudge>
	  </infer>
	</infergr>
    </smeval>

  </div4>

  <div4 id="sec_textConstructors">
    <head>Text Node Constructors</head>

    <scrap>
      <head></head>
      <prodrecap id="CompTextConstructor" ref="CompTextConstructor" orig="xquery"/>
    </scrap>

    <smcore>
      <p>The Core grammar production for a computed text constructor
      is:</p>

      <scrap>
       <head></head>
       <prodrecap id="core-CompTextConstructor" ref="CompTextConstructor" orig="core"/>
      </scrap>
    </smcore>

    <smnorm>
      <p>A text node constructor contains an expression, which must
      evaluate to an &xs_string; value. <xspecref spec="XQ"
      ref="id-textConstructors"/> specifies the rules for converting a
      sequence of atomic values into a string prior to construction of
      a text node.  Each node is replaced by its string value. For
      each adjacent sequence of one or more atomic values returned by
      an enclosed expression, a untyped atomic value is constructed,
      containing the canonical lexical representation of all the
      atomic values, with a single blank character inserted between
      adjacent values.  As formal specification of these conversion
      rules is not instructive,
      <phrase diff='del' at='E030'><specref ref="sec_item_seq_to_untypedAtomic"/></phrase>
      <phrase diff='add' at='E030'>the &fs_item_seq_to_untypedAtomic_text; function</phrase>
      implements this
      conversion.</p>

      <mapping>
       <xquery>
 	<expression>
         <map>text { &gr_Expr; }</map>&jd_map_expr;
        </expression>
       </xquery>
       <core>
        <expression>
         text {
         (&fs_item_seq_to_untypedAtomic_text;(&fn_data;((<map>&gr_Expr;</map>&jd_map_expr;))))
         cast as &xs_string;? }
        </expression>
       </core>
      </mapping>
    </smnorm>

    <smtype>
      <p>The static semantics checks that the argument expression has
      type &xs_string; or &xt_empty;. The type of the entire
      expression is an optional text node type, as the text node
      constructor returns the empty sequence if its argument is the
      empty sequence.</p>

	<infergr>
	  <infer>
	    <prejudge>
	      <clause><environment>&xq_stat_env;</environment>
		<expression>
		      &gr_Expr; &jd_has_type; &xs_string;?
		</expression>
	      </clause>
	    </prejudge>
	    <postjudge>
	      <clause><environment>&xq_stat_env;</environment>
		<expression>
		      text { &gr_Expr; } &jd_has_type; text?
		</expression>
	      </clause>
	    </postjudge>
	  </infer>
	</infergr>
    </smtype>

    <smeval>
      <p>If the argument expression returns the empty sequence, the
      text node constructor returns the empty sequence.</p>

	<infergr>
	  <infer>
	    <prejudge>
             <multiclause>
	      <clause><environment>&xq_dyn_env;</environment>
		<expression>
                  &gr_Expr; &jd_yields; <code>()</code>
		</expression>
	      </clause>
             </multiclause>
	    </prejudge>
	    <postjudge>
	      <clause><environment>&xq_dyn_env;</environment>
		<expression>
		  text { &gr_Expr; } &jd_yields; <code>()</code>
		</expression>
	      </clause>
	    </postjudge>
	  </infer>
	</infergr>

      <p>If the argument expression returns a value of type
      &xs_string;, the text node constructor returns a text node with
      that string as content.</p>

	<infergr>
	  <infer>
	    <prejudge>
             <multiclause>
	      <clause><environment>&xq_dyn_env;</environment>
		<expression>
                  &gr_Expr; &jd_yields; &gr_Value; 
		</expression>
	      </clause>
	      <clause><environment>&xq_stat_env;</environment>
		<expression>
		  &gr_Value; &jd_matches; &xs_string; 
		</expression>
	      </clause>
             </multiclause>
	    </prejudge>
	    <postjudge>
	      <clause><environment>&xq_dyn_env;</environment>
		<expression>
		  text { &gr_Expr; } &jd_yields; text { &gr_Value; }
		</expression>
	      </clause>
	    </postjudge>
	  </infer>
	</infergr>
    </smeval>

  </div4>

  <div4 id="sec_computed-pis">
    <head>Computed Processing Instruction Constructors</head>

    <scrap>
      <head></head>
      <prodrecap id="CompPIConstructor" ref="CompPIConstructor" orig="xquery"/>
    </scrap>

    <smcore>
      <p>The Core grammar production for computed
      processing-instruction constructors is:</p>

      <scrap><head/>
        <prodrecap id="core-CompPIConstructor" ref="CompPIConstructor"  orig="core"/>
      </scrap>
    </smcore>

    <smnorm>
      <p>Computed processing-instruction constructors are normalized
      by mapping their name and content expression in the same way
      that computed element and attribute constructors are
      normalized.</p>

      <mapping>
       <xquery>
 	<expression>
         <map>processing-instruction  &gr_NCName; { }</map>&jd_map_expr;
        </expression>
       </xquery>
       <core>
 	<expression>
         <map>processing-instruction  &gr_NCName; { () }</map>&jd_map_expr;
        </expression>
       </core>
      </mapping>

      <mapping>
       <xquery>
 	<expression>
         <map>processing-instruction  &gr_NCName; { &gr_Expr; }</map>&jd_map_expr;
        </expression>
       </xquery>
       <core>
        <expression>processing-instruction &gr_NCName; { &fs_item_seq_to_untypedAtomic_PI;((<map>&gr_Expr;</map>&jd_map_expr;)) } 
        </expression>
       </core>
      </mapping>

      <mapping>
       <xquery>
 	<expression>
         <map>processing-instruction  { &gr_Expr1; } { &gr_Expr2; }</map>&jd_map_expr;
        </expression>
       </xquery>
       <core>
 	<expression>
         processing-instruction  { &fn_data;((<map>&gr_Expr1;</map>&jd_map_expr;)) } { &fs_item_seq_to_untypedAtomic_PI;((<map>&gr_Expr2;</map>&jd_map_expr;)) }
        </expression>
       </core>
      </mapping>
    </smnorm>

    <smtype>
      <p>The static typing rules for processing-instruction
      constructors are straightforward.</p>

	<infergr>
	  <infer>
	    <prejudge>
	      <clause><environment>&xq_stat_env;</environment>
		<expression>
		      &gr_Expr; &jd_has_type; &xs_untypedAtomic; 
		</expression>
	      </clause>
	    </prejudge>
	    <postjudge>
	      <clause><environment>&xq_stat_env;</environment>
		<expression>
		      processing-instruction  &gr_NCName; { &gr_Expr; }
		      &jd_has_type; processing-instruction <phrase diff='chg' at='E022'>&gr_NCName;</phrase>
		</expression>
	      </clause>
	    </postjudge>
	  </infer>
	</infergr>
	<infergr>
	  <infer>
	    <prejudge>
	      <clause><environment>&xq_stat_env;</environment>
		<expression>
	      &gr_Expr1; &jd_has_type; (&xs_NCName; | &xs_string; | &xs_untypedAtomic;)
		</expression>
	      </clause>
	      <clause><environment>&xq_stat_env;</environment>
		<expression>
	      &gr_Expr2; &jd_has_type; &xs_untypedAtomic; 
		</expression>
	      </clause>
	    </prejudge>
	    <postjudge>
	      <clause><environment>&xq_stat_env;</environment>
		<expression>
		      processing-instruction  { &gr_Expr1; } { &gr_Expr2; }
		      &jd_has_type; processing-instruction<phrase diff='add' at='E022'> *</phrase>
		</expression>
	      </clause>
	    </postjudge>
	  </infer>
	</infergr>
    </smtype>

    <smeval>
      <p>The dynamic evaluation rules for computed
      processing-instructions are straightforward.</p>

	<infergr>
	  <infer>
	    <prejudge>
             <multiclause>
	      <clause><environment>&xq_dyn_env;</environment>
		<expression>
	      &gr_Expr; &jd_yields; &gr_Value;
		</expression>
	      </clause>
       	      <clause><environment>&xq_stat_env;</environment>
		<expression>
	      &gr_Value; &jd_matches; &xs_untypedAtomic;
		</expression>
	      </clause>
             </multiclause>
	    </prejudge>
	    <postjudge>
	      <clause><environment>&xq_dyn_env;</environment>
		<expression>
	      processing-instruction  &gr_NCName; { &gr_Expr; }
	      &jd_yields; processing-instruction &gr_NCName; { &gr_Value; }
		</expression>
	      </clause>
	    </postjudge>
	  </infer>
	</infergr>

	<infergr>
	  <infer>
	    <prejudge>
             <multiclause>
	      <clause><environment>&xq_dyn_env;</environment>
		<expression>
		      &gr_Expr1; &jd_yields; &gr_Value1;
		</expression>
	      </clause>
              </multiclause>
              <multiclause>
       	      <clause>
                <environment>&xq_stat_env;</environment>
		<expression>
		      &gr_Value1; &jd_matches; (&xs_NCName; | &xs_untypedAtomic; | &xs_string;)
		</expression>
	      </clause>
              </multiclause>
              <multiclause>
       	      <clause>
		<expression>
		      &xs_NCName;(&gr_Value1;) = &gr_NCName1;
		</expression>
	      </clause>
              </multiclause>
              <multiclause>
	      <clause><environment>&xq_dyn_env;</environment>
		<expression>
		      &gr_Expr2; &jd_yields; &gr_Value2;
		</expression>
	      </clause>
       	      <clause><environment>&xq_stat_env;</environment>
		<expression>
		      &gr_Value2; &jd_matches; &xs_untypedAtomic; 
		</expression>
	      </clause>
             </multiclause>
	    </prejudge>
	    <postjudge>
	      <clause><environment>&xq_dyn_env;</environment>
		<expression>
		      processing-instruction  { &gr_Expr1; } { &gr_Expr2; }
		      &jd_yields; processing-instruction &gr_NCName1; { &gr_Value2; }
		</expression>
	      </clause>
	    </postjudge>
	  </infer>
	</infergr>
    </smeval>

  </div4>
  <div4 id="sec_computed-comments">
    <head>Computed Comment Constructors</head>

<scrap>
  <head></head>
  <prodrecap id="CompCommentConstructor" ref="CompCommentConstructor" orig="xquery"/>
</scrap>

    <smcore>
      <p>The Core grammar production for computed comment constructors
      is:</p>

<scrap><head/>
<prodrecap id="core-CompCommentConstructor" ref="CompCommentConstructor" orig="core"/>
</scrap>
    </smcore>

    <smnorm>
      <p>Computed comment constructors are normalized by mapping their
      content expression.</p>

      <mapping>
       <xquery>
 	<expression>
         <map>comment { &gr_Expr; }</map>&jd_map_expr;
        </expression>
       </xquery>
       <core>
        <expression>comment { (&fs_item_seq_to_untypedAtomic_comment;((<map>&gr_Expr;</map>&jd_map_expr;))) cast as &xs_string; } 
        </expression>
       </core>
      </mapping>
      </smnorm>

      <smtype>
        <p>The static typing rule for computed comment constructors is
        straightforward.</p>

	<infergr>
	  <infer>
	    <prejudge>
	      <clause><environment>&xq_stat_env;</environment>
		<expression>
		      &gr_Expr; &jd_has_type; &xs_string; 
		</expression>
	      </clause>
	    </prejudge>
	    <postjudge>
	      <clause><environment>&xq_stat_env;</environment>
		<expression>
		      comment { &gr_Expr; }
		      &jd_has_type; comment
		</expression>
	      </clause>
	    </postjudge>
	  </infer>
	</infergr>
</smtype>

<smeval>
<p>
The dynamic evaluation rule for computed comment constructors is
straightforward. 
</p>
	<infergr>
	  <infer>
	    <prejudge>
            <multiclause>
	      <clause><environment>&xq_dyn_env;</environment>
		<expression>
		      &gr_Expr; &jd_yields; &gr_Value; 
		</expression>
	      </clause>
       	      <clause><environment>&xq_stat_env;</environment>
		<expression>
		      &gr_Value; &jd_matches; &xs_string; 
		</expression>
	      </clause>
            </multiclause>
	    </prejudge>
	    <postjudge>
	      <clause><environment>&xq_dyn_env;</environment>
		<expression>
		      comment { &gr_Expr; }
		      &jd_yields; comment { &gr_Value; }
		</expression>
	      </clause>
	    </postjudge>
	  </infer>
	</infergr>
</smeval>

  </div4>

  </div3>

    <div3 id="id-ns-nodes-on-elements">

      <head>In-scope Namespaces of a Constructed Element</head>

      <p>The effect of in-scope namespaces on constructed elements is
      specified in <specref ref="id_element_constructor"/> and
      <specref ref="sec_comp_elem_constructor"/>. </p>
    </div3>

</div2>
  <div2 id="sec_for-expressions">
    <head>&for-name; Expressions</head> 


    <smintro>
      <p>&language; provides &for-name; expressions for iteration, for
      binding variables to intermediate results, and filtering bound
      variables according to a predicate.</p>

      <p>A &gr_FLWORExpr; in XQuery 1.0 consists of a sequence of
      &gr_ForClause;s and &gr_LetClause;s, followed by an optional
      &gr_WhereClause;, followed by an optional &gr_OrderByClause;, as
      described by the following grammar productions. Each variable
      binding is preceded by an optional type declaration which
      specify the type expected for the variable.</p>

      <p>The dynamic semantics of the ordering mode in FLWOR
      expressions is not specified formally, as it would require the
      introduction of tuples, which are not supported in the
      &language; data model.</p>

      <scrap>
    	<head>&for-name; Expressions</head>
    	<prodrecap id="FLWORExpr"       ref="FLWORExpr11"     orig="xquery"/>
    	<prodrecap id="ForClause"       ref="ForClause"       orig="xquery"/>
    	<prodrecap id="LetClause"       ref="LetClause"       orig="xquery"/>
        <prodrecap id="TypeDeclaration" ref="TypeDeclaration" orig="xquery"/>
        <prodrecap id="PositionalVar"   ref="PositionalVar"   orig="xquery"/>
    	<prodrecap id="WhereClause"     ref="WhereClause"     orig="xquery"/>
        <prodrecap id="OrderByClause"   ref="OrderByClause"   orig="xquery"/>
        <prodrecap id="OrderSpecList"   ref="OrderSpecList"   orig="xquery"/>
        <prodrecap id="OrderSpec"       ref="OrderSpec"       orig="xquery"/>
        <prodrecap id="OrderModifier"   ref="OrderModifier"   orig="xquery"/>
    	<prodrecap id="ForExpr"         ref="ForExpr"         orig="xpath" test="XPath"/>
        <prodrecap id="SimpleForClause" ref="SimpleForClause" orig="xpath" test="XPath"/>
      </scrap>
    </smintro>

      <smcore>
        <p>The Core grammar productions for FLWOR expressions are:</p>
      	<scrap>
     	  <head>For Expressions</head>
      	  <prodrecap ref="FLWORExpr10"     id="core-ForExpr"         orig="core"/>
      	  <prodrecap ref="ForClause"       id="core-ForClause"       orig="core"/>
      	  <prodrecap ref="LetClause"       id="core-LetClause"       orig="core"/>
      	  <prodrecap ref="PositionalVar"   id="core-PositionalVar"   orig="core"/>
          <prodrecap ref="TypeDeclaration" id="core-TypeDeclaration" orig="core"/>
          <prodrecap ref="OrderByClause"   id="core-OrderByClause"   orig="core"/>
          <prodrecap ref="OrderSpecList"   id="core-OrderSpecList"   orig="core"/>
          <prodrecap ref="OrderSpec"       id="core-OrderSpec"       orig="core"/>
          <prodrecap ref="OrderModifier"   id="core-OrderModifier"   orig="core"/>
      	</scrap>
      </smcore>

    <div3 id="sec_flwor-expressions">
      <head>FLWOR expressions</head>

      <smnotation>
        <p>For convenience, we introduce the following auxiliary
        grammar productions to represent optional type declarations
        and positional variables in For and Let clauses.</p>

        <scrap>
          <head></head>
          <prodrecap id="OptTypeDeclaration" ref="OptTypeDeclaration" orig="formal"/>
          <prodrecap id="OptPositionalVar"   ref="OptPositionalVar"   orig="formal"/>
        </scrap>
      </smnotation>

      <smnotation>
        <p>To facilitate the specification of normalization, we also
        introduce the following auxiliary grammar productions as an
        alternative grammar for FLWOR expressions.</p>

        <scrap>
          <head></head>
          <prodrecap id="FormalFLWORClause"  ref="FormalFLWORClause"  orig="formal"/>
          <prodrecap id="FormalReturnClause" ref="FormalReturnClause" orig="formal"/>
          <prodrecap id="FormalFLWORExpr"    ref="FormalFLWORExpr"    orig="formal"/>
        </scrap>

      </smnotation>

      <smnorm>
    	<p>Full FLWOR expressions are normalized to nested Core FLWOR
    	expressions with a single for or let clause. Note that some of
    	the normalization rules below accept ungrammatical FLWOR
    	expressions such as "where &gr_Expr1; return &gr_Expr2;". This
    	does not matter, as normalization is always applied on parsed
    	&language; expressions, and such ungrammatical FLWOR
    	expressions would be rejected by the parser beforehand.</p>

        <p>Normalized FLWOR expressions restrict a For and Let clause
        to bind only one variable. Otherwise, the Core FLWOR
        expression is the same as the XQuery FLWOR expression. The
        first normalization rule is applied on a full &for-name;
        expression, splitting it at the clause level, then applying
        further normalization on each separate clause.</p>

	<mapping>
	 <xquery>
	  <expression>
	   <map>
            <table summary="">
            <tbody>
            <tr><td>
	    for &gr_DVarName1; &gr_OptTypeDeclaration1;
	    &gr_OptPositionalVar1; in &gr_Expr1;, </td></tr>
            <tr><td>&middot;&middot;&middot;,</td></tr>
            <tr><td>&gr_DVarNamen; &gr_OptTypeDeclarationn;
	    &gr_OptPositionalVarn; in &gr_Exprn;</td></tr>
           <tr><td>&gr_FormalReturnClause;</td></tr>
            </tbody>
            </table>
	   </map>
           &jd_map_expr;
          </expression>
         </xquery>
	 <core>
	  <expression>
	   <table summary="">
	    <tbody>
	     <tr>
              <td> for &gr_DVarName1; &gr_OptTypeDeclaration1; &gr_OptPositionalVar1; in <map>&gr_Expr1;</map>&jd_map_expr; return</td>
             </tr>
             <tr>
              <td>&sp2;&middot;&middot;&middot;</td>
             </tr>
	     <tr>
              <td>&sp4; for &gr_DVarNamen; &gr_OptTypeDeclarationn;
              &gr_OptPositionalVarn;
              in <map> &gr_Exprn; </map>&jd_map_expr; return</td>
             </tr>
             <tr><td><map>&gr_FormalReturnClause;</map>&jd_map_expr;</td></tr>
            </tbody>
	   </table>
	  </expression>
	 </core>
	</mapping>

        <p>Likewise, a &gr_LetClause; clause is normalized to nested
        let expressions, each of which binds one variable:</p>

	<mapping>
	 <xquery>
	  <expression>
	   <map>
<table summary="">
<tbody>
<tr><td>let &gr_DVarName1; &gr_OptTypeDeclaration1; := &gr_Expr1;,</td></tr>
<tr><td>&middot;&middot;&middot;,</td></tr>
<tr><td>&gr_DVarNamen; &gr_OptTypeDeclarationn; := &gr_Exprn;</td></tr>
             <tr><td>&gr_FormalReturnClause;</td></tr>
</tbody>
</table></map>&jd_map_expr;
  	  </expression>
	 </xquery>
	 <core>
	  <expression>
	   <table summary="">
	    <tbody>
	     <tr>
              <td>let &gr_DVarName1; &gr_OptTypeDeclaration1; := <map>&gr_Expr1; </map>&jd_map_expr; return</td>
             </tr>
  	     <tr>
              <td>&sp2;&middot;&middot;&middot;</td>
             </tr>
	     <tr>
              <td>&sp4;let &gr_DVarNamen; &gr_OptTypeDeclarationn; := <map>&gr_Exprn;</map>&jd_map_expr; return</td>
             </tr>
             <tr><td><map>&gr_FormalReturnClause;</map>&jd_map_expr;</td></tr>
            </tbody>
           </table>
	  </expression>
	 </core>
	</mapping>

        <p>A &gr_WhereClause; is normalized to an &gr_IfExpr;, with
        the else-branch returning the empty sequence:</p>

	<mapping>
	 <xquery>
	  <expression>
	   <map> where &gr_Expr1; &gr_FormalReturnClause;</map>&jd_map_expr;
	  </expression>
	 </xquery>
	 <core>
	  <expression>
	   if ( <phrase diff='chg' at='E028'>fn:boolean(( <map>&gr_Expr1;</map>&jd_map_expr; ))</phrase> ) then <map>&gr_FormalReturnClause;</map>&jd_map_expr; else ()
	  </expression>
	 </core>
	</mapping>

        <p>The order by clause is normalized using the auxiliary
        mapping rule <map></map>&jd_map_orderspeclist; which is
        defined in <specref ref="id_orderby_clause"/>.</p>

	<mapping>
	 <xquery>
	  <expression>
	   <map> stable? order by &gr_OrderSpecList; &gr_FormalReturnClause;</map>&jd_map_expr;
	  </expression>
	 </xquery>
	 <core>
	  <expression>
	    <map>&gr_OrderSpecList;</map>&jd_map_orderspeclist; return <map>&gr_FormalReturnClause;</map>&jd_map_expr;
	  </expression>
	 </core>
	</mapping>

        <p>Finally, a stand-alone return clause is normalized into the
        corresponding expression. Recall that <code>return</code>
        keywords are introduced in the previous rule after the
        normalization of each clause.</p>

	<mapping>
	 <xquery>
	  <expression>
	   <map> return &gr_Expr; </map>&jd_map_expr;
	  </expression>
	 </xquery>
	 <core>
	  <expression>
	   <map> &gr_Expr; </map>&jd_map_expr;
	  </expression>
	 </core>
	</mapping>

      </smnorm>

      <smexample>

        <p>The following simple example illustrates how a
        &gr_FLWORExpr; is normalized. The <code>for</code> expression
        in the example below is used to iterate over two collections,
        binding variables <code>$i</code> and <code>$j</code> to items
        in these collections. It uses a <code>let</code> clause to
        bind the local variable <code>$k</code> to the sum of both
        numbers, and a <code>where</code> clause to select only those
        numbers that have a sum equal to or greater than the integer
        <code>5</code>.</p>

<eg><![CDATA[  for $i as xs:integer in (1, 2),
      $j in (3, 4)
  let $k := $i + $j
  where $k >= 5
  return
    <tuple>
       <i> { $i } </i>
       <j> { $j } </j>
    </tuple>
]]></eg>

        <p>By the first set of rules, this is normalized to (except
        for the operators and element constructor which are not
        treated here):</p>

<eg><![CDATA[  for $i as xs:integer in (1, 2) return
    for $j in (3, 4) return
      let $k := $i + $j return
        if ($k >= 5) then 
          <tuple>
            <i> { $i } </i>
            <j> { $j } </j>
          </tuple>
        else
          ()
]]></eg>

        <p>For each binding of <code>$i</code> to an item in the
        sequence <code>(1 , 2)</code> the inner <code>for</code>
        expression iterates over the sequence <code>(3 , 4)</code> to
        produce tuples ordered by the ordering of the outer sequence
        and then by the ordering of the inner sequence. This Core
        expression eventually results in the following document
        fragment:</p>

<eg><![CDATA[
  (<tuple>
      <i>1</i>
      <j>4</j>
   </tuple>,
   <tuple>
      <i>2</i>
      <j>3</j>
   </tuple>,
   <tuple>
      <i>2</i>
      <j>4</j>
   </tuple>)
]]></eg>

      </smexample>

    </div3>

    <div3 id="id-for-expression">
      <head>For expression</head>

      <smtype>

        <p>A single <code>for</code> expression is typed as follows:
        First &gr_Type1; of the iteration expression &gr_Expr1; is
        inferred. Then the <termref def="term-prime-type">prime
        type</termref> of &gr_Type1;, &jd_prime;(&gr_Type1;), is
        computed. This is a union over all item types in &gr_Type1;
        (See <specref ref="sec_factor"/>). With the variable component
        of the static environment &xq_stat_env; extended with
        &gr_DVarName1; as type &jd_prime;(&gr_Type1;), the type
        &gr_Type2; of &gr_Expr2; is inferred. Because the
        <code>for</code> expression iterates over the result of
        &gr_Expr1;, the final type of the iteration is &gr_Type2;
        multiplied with the possible number of items in &gr_Type1;
        (one, <code>?</code>, <code>*</code>, or <code>+</code>).
        This number is determined by the auxiliary type-function
        &jd_quantifier;(&gr_Type1;). Operations between quantifiers
        and types, such as &gr_Type2; &type_occurs_product;
        &jd_quantifier;(&gr_Type1;), used in the following rule, are
        defined in <specref ref="sec_factor"/>.</p>

        <infergr>
          <infer>
            <prejudge>
              <multiclause>
                <clause><environment>&xq_stat_env;</environment>
                  <expression>&gr_Expr1; &jd_has_type; &gr_Type1;</expression>
                </clause>
              </multiclause>
 	    <multiclause>
 	      <clause>
              <environment>&xq_stat_env;</environment>
 	      <expression>&gr_VarName1; &jd_var_qname_expands_to; &gr_Variable1;
 	      </expression>
 	      </clause>
 	    </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment>&xq_type_env;</environment>
                      <expression>&gr_Variable1; &xt_bind; &jd_prime;(&gr_Type1;)</expression>
                    </update>
                  </environment>
                  <expression> &gr_Expr2; &jd_has_type; &gr_Type2; </expression>
                </clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <clause><environment>&xq_stat_env;</environment>
                <expression>for &gr_DVarName1; in &gr_Expr1; return
                    &gr_Expr2; &jd_has_type; &gr_Type2; &type_occurs_product; &jd_quantifier;(&gr_Type1;)
                </expression>
              </clause>
            </postjudge>
          </infer>
        </infergr>

        <p>When a positional variable &gr_Variablepos; is present, the
        static environment is also extended with the positional
        variable typed as an &xs_integer;.</p>

        <infergr>
          <infer>
            <prejudge>
              <multiclause>
                <clause><environment>&xq_stat_env;</environment>
                  <expression>&gr_Expr1; &jd_has_type; &gr_Type1;</expression>
                </clause>
              </multiclause>
 	    <multiclause>
 	      <clause>
              <environment>&xq_stat_env;</environment>
 	      <expression>&gr_VarName1; &jd_var_qname_expands_to; &gr_Variable1;
 	      </expression>
 	      </clause>
 	    </multiclause>
 	    <multiclause>
 	      <clause>
              <environment>&xq_stat_env;</environment>
 	      <expression>&gr_VarNamepos; &jd_var_qname_expands_to; &gr_Variablepos;
 	      </expression>
 	      </clause>
 	    </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment>&xq_type_env;</environment>
                      <expression>&gr_Variable1; &xt_bind; &jd_prime;(&gr_Type1;);</expression>
                      <expression>&gr_Variablepos; &xt_bind; &xs_integer;</expression>
                    </update>
                  </environment>
                  <expression> &gr_Expr2; &jd_has_type; &gr_Type2; </expression>
                </clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <clause><environment>&xq_stat_env;</environment>
                <expression>for &gr_DVarName1; at &gr_DVarNamepos; in &gr_Expr1; return
                    &gr_Expr2; &jd_has_type; &gr_Type2; &type_occurs_product; &jd_quantifier;(&gr_Type1;)
                </expression>
              </clause>
            </postjudge>
          </infer>
        </infergr>

        <p>When a type declaration is present, the static semantics
        also checks that the type of the input expression is a subtype
        of the declared type and extends the static environment by
        typing &gr_DVarName1; with type &gr_Type0;. This semantics is
        specified by the following static typing rule.</p>

        <infergr>
          <infer>
            <prejudge>
              <multiclause>
                <clause><environment>&xq_stat_env;</environment>
                  <expression>&gr_Expr1; &jd_has_type; &gr_Type1;</expression>
                </clause>
              </multiclause>
              <multiclause>
               <clause>
                <expression>
                   &gr_Type0; = <map> &gr_SequenceType; </map>&jd_map_sequencetype;
                </expression>
               </clause>
              </multiclause>
              <multiclause>
               <clause>
                 <environment> &xq_stat_env; </environment>
                 <expression>&jd_prime;(&gr_Type1;) &jd_subtype_of; &gr_Type0; </expression></clause>
              </multiclause>
 	    <multiclause>
 	      <clause>
              <environment>&xq_stat_env;</environment>
 	      <expression>&gr_VarName1; &jd_var_qname_expands_to; &gr_Variable1;
 	      </expression>
 	      </clause>
 	    </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment>&xq_type_env;</environment>
                      <expression>&gr_Variable1; &xt_bind; &gr_Type0;</expression>
                    </update>
                  </environment>
                  <expression> &gr_Expr2; &jd_has_type; &gr_Type2; </expression>
                </clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <clause><environment>&xq_stat_env;</environment>
                <expression>for &gr_DVarName1; as &gr_SequenceType; in &gr_Expr1; return
                    &gr_Expr2; &jd_has_type; &gr_Type2; &type_occurs_product; &jd_quantifier;(&gr_Type1;)
                </expression>
              </clause>
            </postjudge>
          </infer>
        </infergr>

        <p>The last rule handles For expressions that contain a type
        declaration and a positional variable.  When the positional
        variable is present, the static environment is also extended
        with the positional variable typed as an integer.</p>

        <infergr>
          <infer>
            <prejudge>
              <multiclause>
                <clause><environment>&xq_stat_env;</environment>
                  <expression>&gr_Expr1; &jd_has_type; &gr_Type1;</expression>
                </clause>
              </multiclause>
              <multiclause>
               <clause>
                <expression>
                   &gr_Type0; = <map> &gr_SequenceType; </map>&jd_map_sequencetype;
                </expression>
               </clause>
              </multiclause>
              <multiclause>
               <clause><environment> &xq_stat_env; </environment>
                <expression>&jd_prime;(&gr_Type1;) &jd_subtype_of; &gr_Type0; </expression></clause>
              </multiclause>
 	    <multiclause>
 	      <clause>
              <environment>&xq_stat_env;</environment>
 	      <expression>&gr_VarName1; &jd_var_qname_expands_to; &gr_Variable1;
 	      </expression>
 	      </clause>
 	    </multiclause>
 	    <multiclause>
 	      <clause>
              <environment>&xq_stat_env;</environment>
 	      <expression>&gr_VarNamepos; &jd_var_qname_expands_to; &gr_Variablepos;
 	      </expression>
 	      </clause>
 	    </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment>&xq_type_env;</environment>
                      <expression>&gr_Variable1; &xt_bind; &gr_Type0;; </expression>
                      <expression>&gr_Variablepos; &xt_bind; &xs_integer;</expression>
                    </update>
                  </environment>
                  <expression> &gr_Expr2; &jd_has_type; &gr_Type2; </expression>
                </clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <clause><environment>&xq_stat_env;</environment>
                <expression>for &gr_DVarName1; as &gr_SequenceType; at &gr_DVarNamepos; in &gr_Expr1; return
                    &gr_Expr2; &jd_has_type; &gr_Type2; &type_occurs_product; &jd_quantifier;(&gr_Type1;)
                </expression>
              </clause>
            </postjudge>
          </infer>
        </infergr>

      </smtype>

      <smexample>

        <p>For example, if <code>$example</code> is bound to the
        sequence <code>10.0, 1.0E1, 10</code> of type
        <code>xs:decimal, xs:float, xs:integer</code>, then the query</p>

<eg><![CDATA[  for $s in $example
  return $s * 2]]></eg>

        <p>is typed as follows:</p>

<eg><![CDATA[  (1) prime(xs:decimal, xs:float, xs:integer) =
      xs:decimal | xs:float | xs:integer
  (2) quantifier(xs:decimal, xs:float, xs:integer) = +
  (3) $s : xs:decimal | xs:float | xs:integer
  (4) $s * 2 : 
      xs:decimal | xs:float | xs:integer
  (5) result-type :
      ( xs:decimal | xs:float | xs:integer ) +
]]></eg>

        <p>This result-type is not the most specific type possible. It
        does not take into account the order of elements in the input
        type, and it ignores the individual and overall number of
        elements in the input type. The most specific type possible
        is: <code>xs:decimal, xs:float, xs:integer</code>.  However,
        inferring such a specific type for arbitrary input types and
        arbitrary return clauses requires significantly more complex
        static typing rules. In addition, if put into the context of
        an element, the specific type violates the "unique particle
        attribution" restriction of XML schema, which requires that an
        element must have a unique content model within a particular
        context.</p>

      </smexample>

      <smeval>

        <p>The evaluation of a <code>for</code> expression
        distinguishes two cases: If the iteration expression
        &gr_Expr1; evaluates to the empty sequence, then the entire
        expression evaluates to the empty sequence:</p>

         <infergr>
 	  <infer>
 	    <prejudge>
 	      <clause><environment>&xq_dyn_env;</environment>
 		<expression>&gr_Expr1; &jd_yields; ()</expression>
 	      </clause>
 	    </prejudge>
 	    <postjudge>
 	      <clause><environment>&xq_dyn_env;</environment>
 		<expression>for &gr_DVarName1; &gr_OptTypeDeclaration; &gr_OptPositionalVar; in &gr_Expr1; return &gr_Expr2; &jd_yields; ()
 		</expression>
 	      </clause>
 	    </postjudge>
 	  </infer>
      	</infergr>

        <p>Otherwise, the iteration expression &gr_Expr1; is evaluated
        to produce the sequence &xd_item_val1;, ..., &xd_item_valn;.
        For each item &xd_item_vali; in this sequence, the body of the
        <code>for</code> expression &gr_Expr2; is evaluated in the
        dynamic environment &xq_dyn_env; extended with &gr_DVarName1;
        bound to &xd_item_vali;. This produces values &gr_Valuei;,
        ..., &gr_Valuen; which are concatenated to produce the result
        sequence. </p>

        <infergr>
          <infer>
            <prejudge>
              <multiclause>
                <clause><environment>&xq_dyn_env;</environment>
                  <expression> 
                      &gr_Expr1; &jd_yields; &xd_item_val1; ,..., &xd_item_valn;
                  </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>&xq_stat_env;
                  </environment>
                  <expression>&gr_VarName; &jd_var_qname_expands_to;
                  &gr_Variable;</expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment>&xq_val_env;</environment>
                      <expression>&gr_Variable; &xt_bind; &xd_item_val1;</expression>
                    </update>
                  </environment>
                  <expression>&gr_Expr2; &jd_yields; &gr_Value1;</expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <expression>&middot;&middot;&middot;</expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment>&xq_val_env;</environment>
                      <expression>&gr_Variable; &xt_bind; &xd_item_valn;</expression>
                    </update>
                  </environment>
                  <expression>&gr_Expr2; &jd_yields; &gr_Valuen;</expression>
                </clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <clause><environment>&xq_dyn_env;</environment>
                <expression>
                  for &gr_DVarName; in &gr_Expr1; return &gr_Expr2; 
                  &jd_yields;
                  &gr_Value1; ,..., &gr_Valuen;
                </expression>
              </clause>
            </postjudge>
          </infer>
        </infergr>

        <p>The following rule is the same as the rule above, but
        includes the optional positional variable &gr_DVarNamepos;.
        If present, &gr_DVarNamepos; is bound to the position of the
        item in the input sequence, i.e., the value
        <emph>i</emph>.</p>

        <infergr>
          <infer>
            <prejudge>
              <multiclause>
                <clause><environment>&xq_dyn_env;</environment>
                  <expression> 
                      &gr_Expr1; &jd_yields; &xd_item_val1; ,..., &xd_item_valn;
                  </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>&xq_stat_env;
                  </environment>
                  <expression>&gr_VarName; &jd_var_qname_expands_to;
                  &gr_Variable;</expression>
                </clause>
                <clause>
                  <environment>&xq_stat_env;
                  </environment>
                  <expression>&gr_VarNamepos; &jd_var_qname_expands_to;
                  &gr_Variablepos;</expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment>&xq_val_env;</environment>
                      <expression>&gr_Variable; &xt_bind; &xd_item_val1;; </expression>
                      <expression>&gr_Variablepos; &xt_bind; 1</expression>
                    </update>
                  </environment>
                  <expression>&gr_Expr2; &jd_yields; &gr_Value1;</expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <expression>&middot;&middot;&middot;</expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment>&xq_val_env;</environment>
                      <expression>&gr_Variable; &xt_bind; &xd_item_valn;; </expression>
                      <expression>&gr_Variablepos; &xt_bind; n</expression>
                    </update>
                  </environment>
                  <expression>&gr_Expr2; &jd_yields; &gr_Valuen;</expression>
                </clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <clause><environment>&xq_dyn_env;</environment>
                <expression>
                  for &gr_DVarName; at &gr_DVarNamepos; in &gr_Expr1; return &gr_Expr2; 
                  &jd_yields;
                  &gr_Value1; ,..., &gr_Valuen;
                </expression>
              </clause>
            </postjudge>
          </infer>
        </infergr>

        <p>When a type declaration is present, the dynamic semantics
        also checks that each item in the result of evaluating
        &gr_Expr1; matches the declared type.  This semantics is
        specified by the following dynamic evaluation rule.</p>

        <infergr>
          <infer>
            <prejudge>
              <multiclause>
                <clause><environment>&xq_dyn_env;</environment>
                  <expression> 
                      &gr_Expr1; &jd_yields; &xd_item_val1; ,..., &xd_item_valn;
                  </expression>
                </clause>
              </multiclause>
              <multiclause>
               <clause>
                <expression>
                   &gr_Type0; = <map> &gr_SequenceType; </map>&jd_map_sequencetype;
                </expression>
               </clause>
              </multiclause>
              <multiclause>
               <clause>
                <environment> &xq_stat_env; </environment>
                <expression>
                   &xd_item_val1;  &jd_matches; &gr_Type0;
                </expression>
               </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <expression>&middot;&middot;&middot;</expression>
                </clause>
              </multiclause>
              <multiclause>
               <clause>
                <environment> &xq_stat_env; </environment>
                <expression>
                   &xd_item_valn;  &jd_matches; &gr_Type0;
                </expression>
               </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>&xq_stat_env;
                  </environment>
                  <expression>&gr_VarName; &jd_var_qname_expands_to;
                  &gr_Variable;</expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment>&xq_val_env;</environment>
                      <expression>&gr_Variable; &xt_bind; &xd_item_val1;</expression>
                    </update>
                  </environment>
                  <expression>&gr_Expr2; &jd_yields; &gr_Value1;</expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <expression>&middot;&middot;&middot;</expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment>&xq_val_env;</environment>
                      <expression>&gr_Variable; &xt_bind; &xd_item_valn;</expression>
                    </update>
                  </environment>
                  <expression>&gr_Expr2; &jd_yields; &gr_Valuen;</expression>
                </clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <clause><environment>&xq_dyn_env;</environment>
                <expression>
                  for &gr_DVarName; as &gr_SequenceType; in &gr_Expr1;
                  return &gr_Expr2; &jd_yields;
                  &gr_Value1; ,..., &gr_Valuen;
                </expression>
              </clause>
            </postjudge>
          </infer>
        </infergr>

        <p>The last rule covers a <code>for</code> expression that
        contains a type declaration and a positional variable.</p>

        <infergr>
          <infer>
            <prejudge>
              <multiclause>
                <clause><environment>&xq_dyn_env;</environment>
                  <expression> 
                      &gr_Expr1; &jd_yields; &xd_item_val1; ,..., &xd_item_valn;
                  </expression>
                </clause>
              </multiclause>
              <multiclause>
               <clause>
                <expression>
                   &gr_Type0; = <map> &gr_SequenceType; </map>&jd_map_sequencetype;
                </expression>
               </clause>
              </multiclause>
              <multiclause>
               <clause>
                <environment> &xq_stat_env; </environment>
                <expression>
                   &xd_item_val1;  &jd_matches; &gr_Type0;
                </expression>
               </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <expression>&middot;&middot;&middot;</expression>
                </clause>
              </multiclause>
              <multiclause>
               <clause>
                <environment> &xq_stat_env; </environment>
                <expression>
                   &xd_item_valn;  &jd_matches; &gr_Type0;
                </expression>
               </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>&xq_stat_env;
                  </environment>
                  <expression>&gr_VarName; &jd_var_qname_expands_to;
                  &gr_Variable;</expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>&xq_stat_env;
                  </environment>
                  <expression>&gr_VarNamepos; &jd_var_qname_expands_to;
                  &gr_Variablepos;</expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment>&xq_val_env;</environment>
                      <expression>&gr_Variable; &xt_bind; &xd_item_val1;; </expression>
                      <expression>&gr_Variablepos; &xt_bind; 1</expression>
                    </update>
                  </environment>
                  <expression>&gr_Expr2; &jd_yields; &gr_Value1;</expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <expression>&middot;&middot;&middot;</expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment>&xq_val_env;</environment>
                      <expression>&gr_Variable; &xt_bind; &xd_item_valn;; </expression>
                      <expression>&gr_Variablepos; &xt_bind; n</expression>
                    </update>
                  </environment>
                  <expression>&gr_Expr2; &jd_yields; &gr_Valuen;</expression>
                </clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <clause><environment>&xq_dyn_env;</environment>
                <expression>
                  for &gr_DVarName; as &gr_SequenceType; at &gr_DVarNamepos;  in &gr_Expr1;
                  return &gr_Expr2; &jd_yields;
                  &gr_Value1; ,..., &gr_Valuen;
                </expression>
              </clause>
            </postjudge>
          </infer>
        </infergr>

      <p>Note that this definition allows
      <emph>non-deterministic</emph> evaluation of the resulting
      sequence, since the preconditions in the above rule can be
      evaluated in any order.</p>

    </smeval>

      <smexample>

        <p>Note that if the expression in the <code>return</code> clause 
        results in a sequence, sequences are never nested in the
        &language; data model. For instance, in the following for
        expression:</p>

<eg><![CDATA[  
  for $i in (1,2)
    return (<i> {$i} </i>, <negi> {-$i} </negi>)
]]></eg>

        <p>each iteration in the <code>for</code> results in a sequence of two
        elements, which are then concatenated and flattened in the
        resulting sequence:</p>

<eg><![CDATA[  
  (<i>1</i>,
   <negi>-1</negi>,
   <i>2</i>,
   <negi>-2</negi>)
]]></eg>

      </smexample>

    </div3>

    <div3 id="sec_lets">
      <head>Let Expression</head>

      <smtype>
        <p>A <code>let</code> expression extends the static
        environment &xq_stat_env; with &gr_Variable1; of type
        &gr_Type1; inferred from &gr_Expr1;, and infers the type of
        &gr_Expr2; in the extended environment to produce the result
        type &gr_Type2;.</p>

        <infergr>
 	  <infer>
 	   <prejudge>
              <multiclause>
 	    <clause>
 	     <environment>&xq_stat_env;</environment>
 	     <expression> &gr_Expr1; &jd_has_type; &gr_Type1; </expression>
 	    </clause>
                <clause>
                  <environment>&xq_stat_env;
                  </environment>
                  <expression>&gr_VarName; &jd_var_qname_expands_to;
                  &gr_Variable;</expression>
                </clause>
 	    <clause>
 	     <environment>
                        <update>
                          <environment>&xq_type_env;</environment>
                          <expression>&gr_Variable; &xt_bind; &gr_Type1;</expression>
                        </update>
                      </environment>
                      <expression> &gr_Expr2; &jd_has_type; &gr_Type2;</expression>
                    </clause>
              </multiclause>
                  </prejudge>
                  <postjudge>
                    <clause>
                      <environment>&xq_stat_env;</environment>
                      <expression>let &gr_DVarName; :=  &gr_Expr1;
 		    return &gr_Expr2; &jd_has_type; &gr_Type2;
                      </expression>
                    </clause>
                  </postjudge>
                </infer>
              </infergr>

        <p>When a type declaration is present, the static semantics
        also checks that the type of the input expression is a subtype
        of the declared type and extends the static environment by
        typing &gr_Variable1; with type &gr_Type0;.  This semantics is
        specified by the following static typing rule.</p>

      	<infergr>
 	  <infer>
 	    <prejudge>
              <multiclause>
 	        <clause>
 	         <environment>&xq_stat_env;</environment>
 	         <expression> &gr_Expr1; &jd_has_type; &gr_Type1; </expression>
 	        </clause>
              </multiclause>
              <multiclause>
               <clause>
                <expression>
                   &gr_Type0; = <map> &gr_SequenceType; </map>&jd_map_sequencetype;
                </expression>
               </clause>
              </multiclause>
              <multiclause>
               <clause><environment> &xq_stat_env; </environment>
               <expression>&gr_Type1; &jd_subtype_of; &gr_Type0; </expression></clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>&xq_stat_env;
                  </environment>
                  <expression>&gr_VarName; &jd_var_qname_expands_to;
                  &gr_Variable;</expression>
                </clause>
 	        <clause>
 	          <environment>
                    <update>
                      <environment>&xq_type_env;</environment>
                      <expression>&gr_Variable1; &xt_bind; &gr_Type0; </expression>
                    </update>
                  </environment>
                  <expression> &gr_Expr2; &jd_has_type; &gr_Type2;</expression>
                </clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <clause>
                <environment>&xq_stat_env;</environment>
                <expression>let &gr_DVarName1; as &gr_SequenceType; :=  &gr_Expr1;
 	      return &gr_Expr2; &jd_has_type; &gr_Type2;
                </expression>
              </clause>
            </postjudge>
          </infer>
        </infergr>

      </smtype>

      <smeval>

        <p>A <code>let</code> expression extends the dynamic environment
        &xq_dyn_env; with &gr_Variable; bound to &gr_Value1; returned by
        &gr_Expr1;, and evaluates &gr_Expr2; in the extended
        environment to produce &gr_Value2;.</p>

        <infergr>
          <infer>
            <prejudge>
              <multiclause>
                <clause>
                  <environment>&xq_dyn_env;</environment>
                  <expression>&gr_Expr1; &jd_yields; &gr_Value1;</expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>&xq_stat_env;
                  </environment>
                  <expression>&gr_VarName; &jd_var_qname_expands_to;
                  &gr_Variable;</expression>
                </clause>
                <clause>
                  <environment>
                    <update>
                      <environment>&xq_val_env;</environment>
                      <expression>&gr_Variable1; &xt_bind; &gr_Value1;</expression>
                    </update>
                  </environment>
                  <expression>&gr_Expr2; &jd_yields; &gr_Value2;</expression>
                </clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <clause>
                <environment>&xq_dyn_env;</environment>
                <expression>let &gr_DVarName1; := &gr_Expr1; return
                    &gr_Expr2; &jd_yields; &gr_Value2;
                </expression>
              </clause>
            </postjudge>
          </infer>
        </infergr>

        <p>When a type declaration is present, the dynamic semantics
        also checks that the result of evaluating &gr_Expr1; matches
        the declared type. This semantics is specified as the
        following dynamic evaluation rule.</p>

        <infergr>
          <infer>
            <prejudge>
              <multiclause>
                <clause>
                  <environment>&xq_dyn_env;</environment>
                  <expression>&gr_Expr1; &jd_yields; &gr_Value1;</expression>
                </clause>
              </multiclause>
              <multiclause>
               <clause>
                <expression>
                   &gr_Type0; = <map> &gr_SequenceType; </map>&jd_map_sequencetype;
                </expression>
               </clause>
              </multiclause>
              <multiclause>
               <clause>
                <environment> &xq_stat_env; </environment>
                <expression>
                   &gr_Value1;  &jd_matches; &gr_Type0;
                </expression>
               </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>&xq_stat_env;
                  </environment>
                  <expression>&gr_VarName; &jd_var_qname_expands_to;
                  &gr_Variable;</expression>
                </clause>
                <clause>
                  <environment>
                    <update>
                      <environment>&xq_val_env;</environment>
                      <expression>&gr_Variable1; &xt_bind; &gr_Value1;</expression>
                    </update>
                  </environment>
                  <expression>&gr_Expr2; &jd_yields; &gr_Value2;</expression>
                </clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <clause>
                <environment>&xq_dyn_env;</environment>
                <expression>let &gr_DVarName1; as &gr_SequenceType; := &gr_Expr1; return
                    &gr_Expr2; &jd_yields; &gr_Value2;
                </expression>
              </clause>
            </postjudge>
          </infer>
        </infergr>
      </smeval>

      <smexample>
        <p>Note the use of the environments to define the scope of
        each variable. For instance, in the following nested
        <code>let</code> expression:</p>

<eg><![CDATA[  let $k := 5 return
    let $k := $k + 1 return
      $k+1
]]></eg>

        <p>the outermost <code>let</code> expression binds variable 
        <code>$k</code> to the
        integer <code>5</code> in the environment, then the expression
        <code>$k+1</code> is computed, yielding value <code>6</code>, to 
        which the second variable <code>$k</code> is bound. 
        The expression then results in 
        the final integer <code>7</code>.</p>
      </smexample>

    </div3>

    <div3 id="id_orderby_clause">
      <head>Order By and Return Clauses</head>

      <smintro>
        <p>The dynamic semantics of the &gr_OrderByClause; is not
        specified formally, as doing so would require the introduction
        of tuples, which are not supported in the &language; data
        model. The dynamic semantics of the order-by clause can be
        found in <xspecref spec="XQ" ref="id-orderby-return"/>.</p>

        <p>Although an &gr_OrderByClause; does not affect the type of
        a &gr_FLWORExpr; expression, it must still undergo static
        analysis, in case this raises a static error. The static
        semantics of a &gr_FLWORExpr; expression with an
        &gr_OrderByClause; is equivalent to the static semantics of an
        equivalent &gr_FLWORExpr; in which the &gr_OrderByClause; is
        replaced by a call to the <code>gt</code> comparison over the
        corresponding &gr_OrderSpec; expression(s).</p> </smintro>

      <smnotation>
        <p id="jd_map_orderspeclist">To define normalization of
        OrderBy, the following auxiliary mapping rule is used.</p>
      
          <mapping>
           <xquery>
            <expression>
             <map>&gr_OrderSpecList;</map>&jd_map_orderspeclist;
            </expression>
           </xquery>
           <core>
            <expression>
             &gr_LetClause; ... &gr_LetClause;
            </expression>
           </core>
          </mapping>
      
        <p>This rules specifies that &gr_OrderSpecList; is mapped to a
        sequence of &gr_LetClause;s.</p>
      </smnotation>

      <smnorm>
        <p>Proper static typing for FLWOR expressions with an
        &gr_OrderByClause; is obtained by normalizing the
        &gr_OrderByClause; to a Let clause, nested For expressions,
        and atomization, then by applying the standard static typing
        rules for those expressions. Note that if evaluated
        dynamically, the normalization of &gr_OrderByClause; given
        here does not express the required sorting semantics. Notably,
        the normalization rule introduces the <code>gt</code>
        operation which is used implicitely in the semantics of order
        by.</p>

        <p>Each &gr_OrderSpec; is normalized by the following
        rules.</p>

            <mapping>
             <xquery>
              <expression>
               <map>&gr_OrderSpec1; ... &gr_OrderSpecn;</map>&jd_map_orderspeclist;
              </expression>
             </xquery>
             <core>
              <expression>
               <map>&gr_OrderSpec1;</map>&jd_map_orderspeclist;, ...
               <map>&gr_OrderSpecn;</map>&jd_map_orderspeclist;
              </expression>
             </core>
            </mapping>

	<mapping>
	 <xquery>
	  <expression>
           <map>&gr_Expr; &gr_OrderModifier;</map>&jd_map_orderspeclist;
	  </expression>
	 </xquery>
	 <core>
	  <expression>
            <table summary=""><tbody>
             <tr><td>let &xq_newvar0; := </td></tr>
             <tr><td>&sp2; let &xq_newvar1; := <map>&gr_Expr;</map>&jd_map_expr; return</td></tr>
             <tr><td>&sp2; for &xq_newvar2; in &xq_newvar1; return</td></tr>
             <tr><td>&sp2; for &xq_newvar3; in &xq_newvar1; return</td></tr>
             <tr><td>&sp4; <map>&xq_newvar2; gt &xq_newvar3;</map>&jd_map_expr;</td></tr>
             <tr><td><map>&gr_OrderSpecList;</map>&jd_map_orderspeclist;</td></tr>
            </tbody></table>
	  </expression>
	 </core>
	</mapping>

      </smnorm>
    </div3>
  </div2>
  <div2 id="sec_unordered-expressions">
    <head>Ordered and Unordered Expressions</head>

    <smintro>
      <p>The purpose of <code>ordered</code> and
      <code>unordered</code> expressions is to set the ordering mode
      in the static context to <code>ordered</code> or
      <code>unordered</code> for a certain region in a query. The
      specified ordering mode applies to the expression nested inside
      the curly braces.</p>

      <scrap>
        <head></head>
        <prodrecap id="OrderedExpr"   ref="OrderedExpr"   orig="xquery"/> 
        <prodrecap id="UnorderedExpr" ref="UnorderedExpr" orig="xquery"/>
      </scrap>

    </smintro>

    <smcore>
      <p>The Core grammar productions for ordered/unordered
      expressions are:</p>

      <scrap>
        <head></head>
        <prodrecap id="core-OrderedExpr"   ref="OrderedExpr"   orig="core"/>
        <prodrecap id="core-UnorderedExpr" ref="UnorderedExpr" orig="core"/>
      </scrap>
    </smcore>

    <smnorm>
      <p>&gr_OrderedExpr; (resp. &gr_UnorderedExpr;) expressions are
      normalized to &gr_OrderedExpr; (resp. &gr_UnorderedExpr;)
      expressions in the &language; Core.</p>

      <mapping>
       <xquery>
         <expression><map>ordered { &gr_Expr; }</map>&jd_map_expr;</expression>
       </xquery>
       <core>
         <expression>ordered { <map>&gr_Expr;</map>&jd_map_expr; }</expression>
       </core>
      </mapping>

      <mapping>
       <xquery>
         <expression><map>unordered { &gr_Expr; }</map>&jd_map_expr;</expression>
       </xquery>
       <core>
         <expression>unordered { <map>&gr_Expr;</map>&jd_map_expr; }</expression>
       </core>
      </mapping>
    </smnorm>

   <smtype>
     <p>&gr_OrderedExpr; and &gr_UnorderedExpr; expressions set the
     ordering mode in the static context to <code>ordered</code> or
     <code>unordered</code>.</p>

     <infergr>
      <infer>
       <prejudge>
        <multiclause>
          <clause>
           <expression>
             &xq_stat_env1; =
             <update>
               <environment>&xq_ordering_mode_env;</environment>
               <expression><code>ordered</code></expression>
             </update>
           </expression>
          </clause>
        </multiclause>
        <multiclause>
          <clause>
           <environment>&xq_stat_env1;</environment>
           <expression>
             &gr_Expr; &jd_has_type; &gr_Type;
           </expression>
          </clause>
        </multiclause>
       </prejudge>
       <postjudge>
        <clause>
         <environment>&xq_stat_env;</environment>
         <expression>
          ordered { &gr_Expr; } &jd_has_type; &gr_Type;
         </expression>
        </clause>
       </postjudge>
      </infer>
     </infergr>

     <infergr>
      <infer>
       <prejudge>
        <multiclause>
          <clause>
           <expression>
             &xq_stat_env1; =
             <update>
               <environment>&xq_ordering_mode_env;</environment>
               <expression><code>unordered</code></expression>
             </update>
           </expression>
          </clause>
        </multiclause>
        <multiclause>
          <clause>
           <environment>&xq_stat_env1;</environment>
           <expression>
             &gr_Expr; &jd_has_type; &gr_Type;
           </expression>
          </clause>
        </multiclause>
       </prejudge>
       <postjudge>
        <clause>
         <environment>&xq_stat_env;</environment>
         <expression>
          unordered { &gr_Expr; } &jd_has_type; &gr_Type;
         </expression>
        </clause>
       </postjudge>
      </infer>
     </infergr>

   </smtype>

   <smeval>
     <p>&gr_OrderedExpr; and &gr_UnorderedExpr; expressions only have
     an effect on the static context. The effect on the evaluation of
     its subexpression(s) is captured using the
     &fs_apply_ordering_mode; function, which introduced during
     normalization of axis steps, <code>union</code>,
     <code>intersect</code>, and <code>except</code> expressions, and
     FLWOR expressions that have no <code>order by</code> clause.</p>

     <infergr>
      <infer>
       <prejudge>
        <multiclause>
          <clause>
           <environment>&xq_dyn_env;</environment>
           <expression>
             &gr_Expr; &jd_yields; &gr_Value;
           </expression>
          </clause>
        </multiclause>
       </prejudge>
       <postjudge>
        <clause>
         <environment>&xq_dyn_env;</environment>
         <expression>
          ordered { &gr_Expr; } &jd_yields; &gr_Value;
         </expression>
        </clause>
       </postjudge>
      </infer>
     </infergr>

     <infergr>
      <infer>
       <prejudge>
        <multiclause>
          <clause>
           <environment>&xq_dyn_env;</environment>
           <expression>
             &gr_Expr; &jd_yields; &gr_Value;
           </expression>
          </clause>
        </multiclause>
       </prejudge>
       <postjudge>
        <clause>
         <environment>&xq_dyn_env;</environment>
         <expression>
          unordered { &gr_Expr; } &jd_yields; &gr_Value;
         </expression>
        </clause>
       </postjudge>
      </infer>
     </infergr>

   </smeval>

  </div2>

  <div2 id="sec_conditionals">
    <head>Conditional Expressions</head>

    <smintro>

     <p>A conditional expression supports conditional evaluation of
      one of two expressions.</p>

      <scrap>
        <head>Conditional Expression</head>
        <prodrecap id="IfExpr" ref="IfExpr" orig="xquery"/>
      </scrap>
    </smintro>

    <smcore>
      <p>The Core grammar production for the conditional expression
      is:</p>

      <scrap>
        <head>Core Conditional Expression</head>
        <prodrecap ref="IfExpr"  orig="core" id="core-IfExpr"/>
      </scrap>
    </smcore>

    <smnorm>
      <p>Conditional expressions are normalized as follows.</p>

      <mapping>
        <xquery>
          <expression>
            <map>if (&gr_Expr1;) then &gr_Expr2; else &gr_Expr3;</map>&jd_map_expr;
          </expression>
        </xquery>
        <core>
          <expression>
          <table summary=""><tbody>
            <tr><td>  &sp2;if (&fn_boolean;((<map> &gr_Expr1; </map>&jd_map_expr;))) then <map>&gr_Expr2;</map>&jd_map_expr; else <map>&gr_Expr3;</map>&jd_map_expr;</td></tr>
          </tbody></table>
          </expression>
        </core>
      </mapping>

    </smnorm>

    <smtype>
       <infergr>
         <infer>
          <prejudge>
           <clause><environment>&xq_stat_env;</environment>
            <expression>&gr_Expr1; &jd_has_type;  &xs_boolean; </expression>
           </clause>
           <clause><environment>&xq_stat_env;</environment>
            <expression>&gr_Expr2; &jd_has_type; &gr_Type2; </expression>
           </clause>
           <clause><environment>&xq_stat_env;</environment>
            <expression>&gr_Expr3; &jd_has_type; &gr_Type3; </expression>
           </clause>
          </prejudge>
          <postjudge>
           <clause><environment>&xq_stat_env;</environment>
            <expression> <code>if</code> (&gr_Expr1;) <code>then </code>
                     &gr_Expr2;  <code>else </code> &gr_Expr3; &jd_has_type;
                     (&gr_Type2; | &gr_Type3;)
            </expression>
           </clause>
          </postjudge>
         </infer>
       </infergr>
    
    </smtype>

    <smeval>
      <p>If the conditional's boolean expression &gr_Expr1; evaluates
      to true, &gr_Expr2; is evaluated and its value is produced.  If
      the conditional's boolean expression evaluates to false,
      &gr_Expr3; is evaluated and its value is produced.  Note that
      the existence of two separate dynamic evaluation rules ensures
      that only one branch of the conditional is evaluated.</p>

      <infergr>
      <infer>
        <prejudge>
          <clause><environment>&xq_dyn_env;</environment>
            <expression>&gr_Expr1; &jd_yields; true</expression>
          </clause>
          <clause><environment>&xq_dyn_env;</environment>
            <expression>&gr_Expr2; &jd_yields; &gr_Value2;</expression>
          </clause>
        </prejudge>
        <postjudge>
          <clause><environment>&xq_dyn_env;</environment>
            <expression>if (&gr_Expr1;) then &gr_Expr2; else &gr_Expr3;  &jd_yields; &gr_Value2; 
            </expression>
          </clause>
        </postjudge>
      </infer>

      <infer>
        <prejudge>
          <clause><environment>&xq_dyn_env;</environment>
            <expression>&gr_Expr1; &jd_yields; false</expression>
          </clause>
          <clause><environment>&xq_dyn_env;</environment>
            <expression>&gr_Expr3; &jd_yields; &gr_Value3; </expression>
          </clause>
        </prejudge>
        <postjudge>
          <clause><environment>&xq_dyn_env;</environment>
            <expression>if (&gr_Expr1;) then &gr_Expr2; 
                        else &gr_Expr3;  &jd_yields; &gr_Value3;
            </expression>
          </clause>
        </postjudge>
      </infer>
      </infergr>

    </smeval>

  </div2>

  <div2 id="id-quantified-expressions">
    <head>Quantified Expressions</head>

    <smintro>
      <p>&language; defines two quantification expressions:</p>

      <scrap>
        <head>Quantified Expression</head>
        <prodrecap id="QuantifiedExpr" ref="QuantifiedExpr" orig="xquery"/>
        <prodrecap                     ref="QuantifiedExpr" orig="xpath" test="XPath"/>
      </scrap>

    </smintro>

    <smcore>
      <p>The Core grammar production for quantified expressions
      is:</p>

      <scrap>
        <head></head>
        <prodrecap ref="QuantifiedExpr"  id="core-QuantifiedExpr" orig="core"/>
      </scrap>
    </smcore>

    <smnorm>
      <p>The quantified expressions are normalized into nested Core
      quantified expressions, each of which binds one variable.</p>

      <mapping>
      <xquery>
        <expression>
          <map>some &gr_DVarName1; in &gr_Expr1;, ..., &gr_DVarNamen; in
          &gr_Exprn; satisfies &gr_Expr;</map>&jd_map_expr;
        </expression>
      </xquery>
      <core>
        <expression>
          <table summary=""><tbody>
            <tr><td> some &gr_DVarName1; in <map>&gr_Expr1;</map>&jd_map_expr; satisfies</td></tr>
            <tr><td> &sp2; some &gr_DVarName2; in <map>&gr_Expr2;</map>&jd_map_expr; satisfies</td></tr>
            <tr><td> &sp4; &sp4;...</td></tr>
            <tr><td> &sp4; some &gr_DVarNamen; in <map>&gr_Exprn;</map>&jd_map_expr; satisfies</td></tr>
            <tr><td> &sp4; &fn_boolean;((<map>&gr_Expr;</map>&jd_map_expr;)) </td></tr>
          </tbody></table>
        </expression>
      </core>
      </mapping>

      <mapping>
      <xquery>
        <expression>
          <map>every &gr_DVarName1; in &gr_Expr1;, ..., &gr_DVarNamen; in
          &gr_Exprn; satisfies &gr_Expr;</map>&jd_map_expr;
        </expression>
      </xquery>
      <core>
        <expression>
          <table summary=""><tbody>
            <tr><td> every &gr_DVarName1; in <map>&gr_Expr1;</map>&jd_map_expr;  satisfies</td></tr>
            <tr><td> &sp2; every &gr_DVarName2; in <map>&gr_Expr2;</map>&jd_map_expr; satisfies</td></tr>
            <tr><td> &sp4; &sp4;...</td></tr>
            <tr><td> &sp4; every &gr_DVarNamen; in <map>&gr_Exprn;</map>&jd_map_expr; satisfies</td></tr>
            <tr><td> &sp4; &fn_boolean;((<map>&gr_Expr;</map>&jd_map_expr;)) </td></tr>
          </tbody></table>
        </expression>
      </core>
      </mapping>
    </smnorm>

    <smtype>
      <p>The static semantics of the quantified expressions uses the
      notion of <termref def="term-prime-type">prime
      type</termref>. These rules are similar to those for
      <code>for</code> expressions in <specref
      ref="id-for-expression"/>.</p>

            <infergr>
             <infer>
              <prejudge>

              <multiclause>
                <clause><environment>&xq_stat_env;</environment>
                  <expression>&gr_Expr1; &jd_has_type; &gr_Type1;</expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>&xq_stat_env;
                  </environment>
                  <expression>&gr_VarName1; &jd_var_qname_expands_to; &gr_Variable1;</expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment>&xq_type_env;</environment>
                      <expression>&gr_Variable1; &xt_bind; &jd_prime;(&gr_Type1;)</expression>
                    </update>
                  </environment>
                  <expression> &gr_Expr2; &jd_has_type; &xs_boolean; </expression>
                </clause>
              </multiclause>

              </prejudge>
              <postjudge>
               <clause><environment>&xq_stat_env;</environment>
                <expression>some &gr_DVarName1; in &gr_Expr1; satisfies
                &gr_Expr2; &jd_has_type; &xs_boolean; </expression>
               </clause>
              </postjudge>
             </infer>
            </infergr>

            <p>The next rule is for &gr_SomeExpr; with the optional
            type declaration.</p>

            <infergr>
             <infer>
              <prejudge>

              <multiclause>
                <clause><environment>&xq_stat_env;</environment>
                  <expression>&gr_Expr1; &jd_has_type; &gr_Type1;</expression>
                </clause>
              </multiclause>

              <multiclause>
               <clause>
                <expression>
                   &gr_Type0; = <map> &gr_SequenceType; </map>&jd_map_sequencetype;
                </expression>
               </clause>
              </multiclause>

              <multiclause>
               <clause><environment> &xq_stat_env; </environment>
                <expression>&jd_prime;(&gr_Type1;) &jd_subtype_of; &gr_Type0; </expression></clause>
              </multiclause>

              <multiclause>
                <clause>
                  <environment>&xq_stat_env;
                  </environment>
                  <expression>&gr_VarName1; &jd_var_qname_expands_to; &gr_Variable1;</expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment>&xq_type_env;</environment>
                      <expression>&gr_Variable1; &xt_bind; &gr_Type0;</expression>
                    </update>
                  </environment>
                  <expression> &gr_Expr2; &jd_has_type; &xs_boolean; </expression>
                </clause>
              </multiclause>

              </prejudge>
              <postjudge>
               <clause><environment>&xq_stat_env;</environment>
                <expression>some &gr_DVarName1; as &gr_SequenceType; in &gr_Expr1; satisfies
                &gr_Expr2; &jd_has_type; &xs_boolean; </expression>
               </clause>
              </postjudge>
             </infer>
            </infergr>

            <p>The next rule is for &gr_EveryExpr; without the
            optional type declaration.</p>

            <infergr>
             <infer>
              <prejudge>

              <multiclause>
                <clause><environment>&xq_stat_env;</environment>
                  <expression>&gr_Expr1; &jd_has_type; &gr_Type1;</expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>&xq_stat_env;
                  </environment>
                  <expression>&gr_VarName1; &jd_var_qname_expands_to;
                  &gr_Variable1;</expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment>&xq_type_env;</environment>
                      <expression>&gr_Variable1; &xt_bind; &jd_prime;(&gr_Type1;)</expression>
                    </update>
                  </environment>
                  <expression> &gr_Expr2; &jd_has_type; &xs_boolean; </expression>
                </clause>
              </multiclause>

              </prejudge>
              <postjudge>
               <clause><environment>&xq_stat_env;</environment>
                <expression>every &gr_DVarName1; in &gr_Expr1;
                satisfies &gr_Expr2; &jd_has_type; &xs_boolean; </expression>
               </clause>
              </postjudge>
       
             </infer>
            </infergr>

            <p>The next rule is for &gr_EveryExpr; with the optional
            type declaration.</p>

            <infergr>
             <infer>
              <prejudge>

              <multiclause>
                <clause><environment>&xq_stat_env;</environment>
                  <expression>&gr_Expr1; &jd_has_type; &gr_Type1;</expression>
                </clause>
              </multiclause>

              <multiclause>
               <clause>
                <expression>
                   &gr_Type0; = <map> &gr_SequenceType; </map>&jd_map_sequencetype;
                </expression>
               </clause>
              </multiclause>

              <multiclause>
               <clause><environment> &xq_stat_env; </environment>
                <expression>&jd_prime;(&gr_Type1;) &jd_subtype_of; &gr_Type0; </expression></clause>
              </multiclause>

              <multiclause>
                <clause>
                  <environment>&xq_stat_env;
                  </environment>
                  <expression>&gr_VarName1; &jd_var_qname_expands_to;
                  &gr_Variable1;</expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment>&xq_type_env;</environment>
                      <expression>&gr_Variable1; &xt_bind; &gr_Type0;</expression>
                    </update>
                  </environment>
                  <expression> &gr_Expr2; &jd_has_type; &xs_boolean; </expression>
                </clause>
              </multiclause>

              </prejudge>
              <postjudge>
               <clause><environment>&xq_stat_env;</environment>
                <expression>every &gr_DVarName1; as &gr_SequenceType; in &gr_Expr1;
                satisfies &gr_Expr2; &jd_has_type; &xs_boolean; </expression>
               </clause>
              </postjudge>
       
             </infer>
            </infergr>

</smtype>

          <smeval>
            <p>If its input expression returns the empty sequence, the
            &gr_SomeExpr; expression returns false.</p>

            <infergr>
             <infer>
              <prejudge>
              <multiclause>
                <clause><environment>&xq_dyn_env;</environment>
                  <expression>&gr_Expr1; &jd_yields; ()</expression>
                </clause>
              </multiclause>
              </prejudge>
              <postjudge>
               <clause><environment>&xq_dyn_env;</environment>
                <expression>some &gr_DVarName1;
                &gr_OptTypeDeclaration; in &gr_Expr1; satisfies
                &gr_Expr2; &jd_yields; false </expression>
               </clause>
              </postjudge>
             </infer>
            </infergr>

            <p>The &gr_SomeExpr; expression yields true if any
            evaluation of the satisfies expression yields true. The
            &gr_SomeExpr; expression yields false if every evaluation
            of the satisfies expression is false.  A quantified
            expression may raise an error if any evaluation of the
            satisfies expression raises an error.  The dynamic
            semantics of quantified expressions is non-deterministic.
            This non-determinism permits implementations to use
            short-circuit evaluation strategies when evaluating
            quantified expressions.</p>

            <infergr>
             <infer>
              <prejudge>

              <multiclause>
                <clause><environment>&xq_dyn_env;</environment>
                  <expression>&gr_Expr1; &jd_yields; &gr_Item1;, ..., &gr_Itemn; </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>&xq_stat_env;
                  </environment>
                  <expression>&gr_VarName1; &jd_var_qname_expands_to;
                  &gr_Variable1;</expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment>&xq_val_env;</environment>
                      <expression>&gr_Variable1; &xt_bind; &gr_Itemi;</expression>
                    </update>
                  </environment>
                  <expression> &gr_Expr2; &jd_yields; true </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                 <expression>
                   i &jd_isin; { 1,...,n }
                 </expression>
                </clause>
              </multiclause>
              </prejudge>
              <postjudge>
               <clause><environment>&xq_dyn_env;</environment>
                <expression>some &gr_DVarName1; in &gr_Expr1; satisfies
                &gr_Expr2; &jd_yields; true </expression>
               </clause>
              </postjudge>
             </infer>
            </infergr>

            <p>The next rule is for &gr_SomeExpr; with the optional
            type declaration, in which some evaluation of the
            satisfies expression yields true.</p>

            <infergr>
             <infer>
              <prejudge>

              <multiclause>
                <clause><environment>&xq_dyn_env;</environment>
                  <expression>&gr_Expr1; &jd_yields; &gr_Item1;,
                  ..., &gr_Itemn; </expression>
                </clause>
              </multiclause>

              <multiclause>
               <clause>
                <expression>
                   &gr_Type0; = <map> &gr_SequenceType; </map>&jd_map_sequencetype;
                </expression>
               </clause>
              </multiclause>


              <multiclause>
               <clause>
                <environment> &xq_stat_env; </environment>
                <expression>
                   &gr_Itemi; &jd_matches; &gr_Type0;
                </expression>
               </clause>
              </multiclause>
              <multiclause>
                <clause>
                 <expression>
                   i &jd_isin; { 1,...,n }
                 </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>&xq_stat_env;
                  </environment>
                  <expression>&gr_VarName1; &jd_var_qname_expands_to;
                  &gr_Variable1;</expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment>&xq_val_env;</environment>
                      <expression>&gr_Variable1; &xt_bind; &gr_Itemi;</expression>
                    </update>
                  </environment>
                  <expression> &gr_Expr2; &jd_yields; true </expression>
                </clause>
              </multiclause>

              </prejudge>
              <postjudge>
               <clause><environment>&xq_dyn_env;</environment>
                <expression>some &gr_DVarName1; as &gr_SequenceType; in &gr_Expr1; satisfies
                &gr_Expr2; &jd_yields; true </expression>
               </clause>
              </postjudge>

             </infer>
            </infergr>

            <p>The next rule is for &gr_SomeExpr; without the optional
            type declaration, in which all evaluations of the
            satisfies expression yield false.</p>

            <infergr>
             <infer>
              <prejudge>

              <multiclause>
                <clause><environment>&xq_dyn_env;</environment>
                  <expression>&gr_Expr1; &jd_yields; &gr_Item1;,
                  ..., &gr_Itemn; </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>&xq_stat_env;
                  </environment>
                  <expression>&gr_VarName1; &jd_var_qname_expands_to;
                  &gr_Variable1;</expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment>&xq_val_env;</environment>
                      <expression>&gr_Variable1; &xt_bind; &gr_Item1;</expression>
                    </update>
                  </environment>
                  <expression> &gr_Expr2; &jd_yields; false </expression>
                </clause>
              </multiclause>
              <multiclause><clause><expression>...</expression></clause></multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment>&xq_val_env;</environment>
                      <expression>&gr_Variable1; &xt_bind; &gr_Itemn;</expression>
                    </update>
                  </environment>
                  <expression> &gr_Expr2; &jd_yields; false </expression>
                </clause>
              </multiclause>

              </prejudge>
              <postjudge>
               <clause><environment>&xq_dyn_env;</environment>
                <expression>some &gr_DVarName1; in &gr_Expr1; satisfies
                &gr_Expr2; &jd_yields; false </expression>
               </clause>
              </postjudge>
             </infer>
            </infergr>

            <p>The next rule is for &gr_SomeExpr; with the optional
            type declaration, in which all evaluations of the
            satisfies expression yield false.</p>

            <infergr>
             <infer>
              <prejudge>

              <multiclause>
                <clause><environment>&xq_dyn_env;</environment>
                  <expression>&gr_Expr1; &jd_yields; &gr_Item1;,
                  ..., &gr_Itemn; </expression>
                </clause>
              </multiclause>

              <multiclause>
               <clause>
                <expression>
                   &gr_Type0; = <map> &gr_SequenceType; </map>&jd_map_sequencetype;
                </expression>
               </clause>
              </multiclause>


              <multiclause>
                <clause>
                  <environment>&xq_stat_env;
                  </environment>
                  <expression>&gr_VarName1; &jd_var_qname_expands_to;
                  &gr_Variable1;</expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment>&xq_val_env;</environment>
                      <expression>&gr_Variable1; &xt_bind; &gr_Item1;</expression>
                    </update>
                  </environment>
                  <expression> &gr_Expr2; &jd_yields; false </expression>
                </clause>
              </multiclause>
              <multiclause>
               <clause>
                <environment> &xq_stat_env; </environment>
                <expression>
                   &gr_Item1; &jd_matches; &gr_Type0;
                </expression>
               </clause>
              </multiclause>
              <multiclause><clause><expression>...</expression></clause></multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment>&xq_val_env;</environment>
                      <expression>&gr_Variable1; &xt_bind; &gr_Itemn;</expression>
                    </update>
                  </environment>
                  <expression> &gr_Expr2; &jd_yields; false </expression>
                </clause>
              </multiclause>
              <multiclause>
               <clause>
                <environment> &xq_stat_env; </environment>
                <expression>
                   &gr_Itemn; &jd_matches; &gr_Type0;
                </expression>
               </clause>
              </multiclause>

              </prejudge>
              <postjudge>
               <clause><environment>&xq_dyn_env;</environment>
                <expression>some &gr_DVarName1; as &gr_SequenceType; in &gr_Expr1; satisfies
                &gr_Expr2; &jd_yields; false </expression>
               </clause>
              </postjudge>
             </infer>
            </infergr>

            <p>If its input expression returns the empty sequence, the
            &gr_EveryExpr; expression returns true.</p>

            <infergr>
             <infer>
              <prejudge>
              <multiclause>
                <clause><environment>&xq_dyn_env;</environment>
                  <expression>&gr_Expr1; &jd_yields; ()</expression>
                </clause>
              </multiclause>
              </prejudge>
              <postjudge>
               <clause><environment>&xq_dyn_env;</environment>
                <expression>every &gr_DVarName1;
                &gr_OptTypeDeclaration; in &gr_Expr1; satisfies
                &gr_Expr2; &jd_yields; true </expression>
               </clause>
              </postjudge>
             </infer>
            </infergr>

            <p>The &gr_EveryExpr; expression yields false if any
            evaluation of the satisfies expression yields false.  The
            &gr_EveryExpr; expression yields true if every evaluation
            of the satisfies expression is true.</p>

            <infergr>
             <infer>
              <prejudge>

              <multiclause>
                <clause><environment>&xq_dyn_env;</environment>
                  <expression>&gr_Expr1; &jd_yields; &gr_Item1;,
                  ..., &gr_Itemn; </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>&xq_stat_env;
                  </environment>
                  <expression>&gr_VarName1; &jd_var_qname_expands_to;
                  &gr_Variable1;</expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment>&xq_val_env;</environment>
                      <expression>&gr_Variable1; &xt_bind; &gr_Itemi;</expression>
                    </update>
                  </environment>
                  <expression> &gr_Expr2; &jd_yields; false </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                 <expression>
                   i &jd_isin; { 1,...,n }
                 </expression>
                </clause>
              </multiclause>
              </prejudge>
              <postjudge>
               <clause><environment>&xq_dyn_env;</environment>
                <expression>every &gr_DVarName1; in &gr_Expr1; satisfies
                &gr_Expr2; &jd_yields; false </expression>
               </clause>
              </postjudge>

             </infer>
            </infergr>

            <p>The next rule is for &gr_EveryExpr; with the optional
            type declaration, in which some evaluation of the
            satisfies expression yields false.</p>

            <infergr>
             <infer>
              <prejudge>

              <multiclause>
                <clause><environment>&xq_dyn_env;</environment>
                  <expression>&gr_Expr1; &jd_yields; &gr_Item1;,
                  ..., &gr_Itemn; </expression>
                </clause>
              </multiclause>

              <multiclause>
               <clause>
                <expression>
                   &gr_Type0; = <map> &gr_SequenceType; </map>&jd_map_sequencetype;
                </expression>
               </clause>
              </multiclause>

              <multiclause>
               <clause>
                <environment> &xq_stat_env; </environment>
                <expression>
                   &gr_Itemi; &jd_matches; &gr_Type0;
                </expression>
               </clause>
              </multiclause>

              <multiclause>
                <clause>
                  <environment>&xq_stat_env;
                  </environment>
                  <expression>&gr_VarName1; &jd_var_qname_expands_to;
                  &gr_Variable1;</expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment>&xq_val_env;</environment>
                      <expression>&gr_Variable1; &xt_bind; &gr_Itemi;</expression>
                    </update>
                  </environment>
                  <expression> &gr_Expr2; &jd_yields; false </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                 <expression>
                   i &jd_isin; { 1,...,n }
                 </expression>
                </clause>
              </multiclause>
              </prejudge>
              <postjudge>
               <clause><environment>&xq_dyn_env;</environment>
                <expression>every &gr_DVarName1; as &gr_SequenceType; in &gr_Expr1; satisfies
                &gr_Expr2; &jd_yields; false </expression>
               </clause>
              </postjudge>

             </infer>
            </infergr>

            <p>The next rule is for &gr_EveryExpr; in which all
            evaluations of the satisfies expression yield true.</p>

            <infergr>
             <infer>
              <prejudge>

              <multiclause>
                <clause><environment>&xq_dyn_env;</environment>
                  <expression>&gr_Expr1; &jd_yields; &gr_Item1;,
                  ..., &gr_Itemn; </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>&xq_stat_env;
                  </environment>
                  <expression>&gr_VarName1; &jd_var_qname_expands_to;
                  &gr_Variable1;</expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment>&xq_val_env;</environment>
                      <expression>&gr_Variable1; &xt_bind; &gr_Item1;</expression>
                    </update>
                  </environment>
                  <expression> &gr_Expr2; &jd_yields; true </expression>
                </clause>
              </multiclause>
              <multiclause><clause><expression>...</expression></clause></multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment>&xq_val_env;</environment>
                      <expression>&gr_Variable1; &xt_bind; &gr_Itemn;</expression>
                    </update>
                  </environment>
                  <expression> &gr_Expr2; &jd_yields; true </expression>
                </clause>
              </multiclause>

              </prejudge>
              <postjudge>
               <clause><environment>&xq_dyn_env;</environment>
                <expression>every &gr_DVarName1; in &gr_Expr1; satisfies
                &gr_Expr2; &jd_yields; true </expression>
               </clause>
              </postjudge>
             </infer>
            </infergr>

            <p>The next rule is for &gr_EveryExpr; with the optional
            type declaration in which all evaluations of the satisfies
            expression yield true.</p>

            <infergr>
             <infer>
              <prejudge>

              <multiclause>
                <clause><environment>&xq_dyn_env;</environment>
                  <expression>&gr_Expr1; &jd_yields; &gr_Item1;,
                  ..., &gr_Itemn; </expression>
                </clause>
              </multiclause>

              <multiclause>
               <clause>
                <expression>
                   &gr_Type0; = <map> &gr_SequenceType; </map>&jd_map_sequencetype;
                </expression>
               </clause>
              </multiclause>


              <multiclause>
                <clause>
                  <environment>&xq_stat_env;
                  </environment>
                  <expression>&gr_VarName1; &jd_var_qname_expands_to;
                  &gr_Variable1;</expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment>&xq_val_env;</environment>
                      <expression>&gr_Variable1; &xt_bind; &gr_Item1;</expression>
                    </update>
                  </environment>
                  <expression> &gr_Expr2; &jd_yields; true </expression>
                </clause>
              </multiclause>
              <multiclause>
               <clause>
                <environment> &xq_stat_env; </environment>
                <expression>
                   &gr_Item1; &jd_matches; &gr_Type0;
                </expression>
               </clause>
              </multiclause>
              <multiclause><clause><expression>...</expression></clause></multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment>&xq_val_env;</environment>
                      <expression>&gr_Variable1; &xt_bind; &gr_Itemn;</expression>
                    </update>
                  </environment>
                  <expression> &gr_Expr2; &jd_yields; true </expression>
                </clause>
              </multiclause>
              <multiclause>
               <clause>
                <environment> &xq_stat_env; </environment>
                <expression>
                   &gr_Itemn; &jd_matches; &gr_Type0;
                </expression>
               </clause>
              </multiclause>

              </prejudge>
              <postjudge>
               <clause><environment>&xq_dyn_env;</environment>
                <expression>every &gr_DVarName1; as &gr_SequenceType; in &gr_Expr1; satisfies
                &gr_Expr2; &jd_yields; true </expression>
               </clause>
              </postjudge>
             </infer>
            </infergr>

</smeval>

  </div2>

  <div2 id="sec_sequencetype-matching">
    <head>Expressions on SequenceTypes</head>

    <!-- Corresponds to XQuery Section 2.13 - Allocated to Jerome -->

    <smintro>

      <p>Some of the expressions relying on the SequenceTypes syntax
      are called expressions on SequenceTypes. The syntax of
      SequenceTypes is described in <specref
      ref="id-sequencetype"/>.</p>

    </smintro>

    <div3 id="sec_instance-of">
      <head>Instance Of</head>

      <scrap>
        <head>SequenceType expressions</head>
        <prodrecap id="InstanceofExpr" ref="InstanceofExpr" orig="xquery"/>
      </scrap>

      <smintro>
        <p>The SequenceType expression <quote>&gr_Expr; instance of
        &gr_SequenceType;</quote> is true if and only if the result of
        evaluating expression &gr_Expr; is an instance of the type
        referred to by &gr_SequenceType;.</p>

        </smintro>

        <smnorm>
          <p>An &gr_InstanceofExpr; expression is normalized into a
          &gr_TypeswitchExpr; expression. Note that the following
          normalization rule uses a variable &xq_newvar;, which is a
          newly created variable which must not conflict with any
          variables already in scope. This variable is necessary to
          comply with the syntax of typeswitch expressions in the Core
          &language;, but is never used.</p>

        <mapping>
         <xquery>
          <expression><map>&gr_Expr; instance of &gr_SequenceType;</map>&jd_map_expr;</expression>
         </xquery>
         <core>
          <expression>
           <table summary=""><tbody>
            <tr><td>typeswitch (<map> &gr_Expr; </map>&jd_map_expr;)</td></tr>
            <tr><td>&sp2;case &xq_newvar; as &gr_SequenceType; return &fn_true;() </td></tr>
            <tr><td>&sp2;default &xq_newvar; return &fn_false;()</td></tr>
           </tbody></table>
          </expression>
         </core>
        </mapping>

        </smnorm>

        </div3>

        <div3 id="sec_typeswitch">
          <head>Typeswitch</head>

          <scrap>
            <head>SequenceType expressions</head>
            <prodrecap id="TypeswitchExpr" ref="TypeswitchExpr" orig="xquery"/>
            <prodrecap id="CaseClause"     ref="CaseClause"     orig="xquery"/>
          </scrap>

        <smintro>
          <p>The <term>typeswitch</term> expression chooses one of
          several expressions to evaluate based on the dynamic type of
          an input value.</p>

          <p>Each branch of a typeswitch expression may have an
          optional &gr_DVarName;, which is bound to the value of the
          input expression. One reason for using a variable on one of
          the branches is that it is assigned a type specific for that
          branch. This variable is optional in &language; but made
          mandatory in the &language; Core.</p>
        </smintro>

        <smcore>
          <p>The Core grammar productions for <code>typeswitch</code>
          are:</p>
      
          <scrap>
          <head></head>
            <prodrecap id="core-TypeswitchExpr" ref="TypeswitchExpr" orig="core"/>
            <prodrecap id="core-CaseClause"     ref="CaseClause"     orig="core"/>
          </scrap>
        </smcore>

        <smnotation>
          <p>For convenience, we introduce the following auxiliary
          grammar production.</p>

          <scrap>
            <head></head>
            <prodrecap id="OptVarName" ref="OptVarName" orig="formal"/>
          </scrap>
        </smnotation>

        <smnotation>
          <p id="jd_map_case">To define normalization of case clauses
          to the &language; Core, the following auxiliary mapping
          rules are used.</p>
        
            <mapping>
             <xquery>
              <expression>
               <map>&gr_CaseClause;</map>&jd_map_case;
              </expression>
             </xquery>
             <core>
              <expression>
               &gr_CaseClause;
              </expression>
             </core>
            </mapping>

          <p>specifies that &gr_CaseClause; is mapped to &gr_CaseClause;,
          in the &language; Core.</p>
        </smnotation>

        <smnorm>
          <p>Normalization of a typeswitch expression guarantees that
          every branch has an associated &gr_DVarName;.  The following
          normalization rules add newly created variables that must
          not conflict with any variables already in scope.</p>

          <mapping>
           <xquery>
            <expression>
             <map>
               &sp2;case &gr_SequenceType; return &gr_Expr;
             </map>&jd_map_case;
            </expression>
           </xquery>
           <core>
            <expression>
              &sp2;case &xq_newvar1; as &gr_SequenceType; return <map> &gr_Expr; </map>&jd_map_expr;
            </expression>
           </core>
          </mapping>

          <mapping>
           <xquery>
            <expression>
             <map>
               &sp2;case &gr_DVarName; as &gr_SequenceType; return
             &gr_Expr; </map>&jd_map_case;
            </expression>
           </xquery>
           <core>
            <expression>
              &sp2;case &gr_DVarName; as &gr_SequenceType; return <map> &gr_Expr; </map>&jd_map_expr;
            </expression>
           </core>
          </mapping>

          <mapping>
           <xquery>
            <expression>
             <map>
              default return &gr_Expr;
             </map>&jd_map_case;
            </expression>
           </xquery>
           <core>
            <expression>
              default &xq_newvar1; return <map> &gr_Expr; </map>&jd_map_expr;
            </expression>
           </core>
          </mapping>

          <mapping>
           <xquery>
            <expression>
             <map>
              default &gr_DVarName; return &gr_Expr;
             </map>&jd_map_case;
            </expression>
           </xquery>
           <core>
            <expression>
              default &gr_DVarName; return <map> &gr_Expr; </map>&jd_map_expr;
            </expression>
           </core>
          </mapping>

          <mapping>
           <xquery>
            <expression>
             <map>
              <table summary=""><tbody>
               <tr><td>typeswitch ( &gr_Expr0;  ) </td></tr>
               <tr><td>&sp2;&gr_CaseClause1; </td></tr>
               <tr><td>&sp2;&sp2;&middot;&middot;&middot;</td></tr>
               <tr><td>&sp2;&gr_CaseClausen; </td></tr>
               <tr><td>&sp2;default &gr_OptVarName; return &gr_Exprnp1;</td></tr>
              </tbody></table>
             </map>&jd_map_expr;
            </expression>
           </xquery>
           <core>
            <expression>
             <table summary=""><tbody>
              <tr><td>typeswitch ( <map> &gr_Expr0; </map>&jd_map_expr; )</td></tr>
              <tr><td><map>&gr_CaseClause1;</map>&jd_map_case;</td></tr>
              <tr><td>&sp2;&sp2;&middot;&middot;&middot;</td></tr>
              <tr><td><map>&gr_CaseClausen;</map>&jd_map_case;</td></tr>
              <tr><td><map>&sp2;default &gr_OptVarName; return &gr_Exprnp1; </map>&jd_map_case;</td></tr>
             </tbody></table>
            </expression>
           </core>
          </mapping>

        </smnorm>

        <smnotation>
          <p>For convenience, we use the following auxiliary grammar
          productions to denote case clauses in a typeswitch.</p>

          <scrap>
            <head>FormalCaseClauses</head>
            <prodrecap id="FormalCaseClauses" ref="FormalCaseClauses" orig="formal"/>
            <prodrecap id="FormalCaseClause" ref="FormalCaseClause" orig="formal"/>
            <prodrecap id="FormalDefaultCaseClause" ref="FormalDefaultCaseClause" orig="formal"/>
          </scrap>

          <p id="jd_type_case">The following judgments</p>
 
          <display>
             <clause><environment>&xq_stat_env;</environment>
                     <expression>&gr_Type1; &jd_type_case; &gr_FormalCaseClause; &jd_type_case_has_type; &gr_Type;</expression>
             </clause>
          </display>

          <display>
             <clause><environment>&xq_stat_env;</environment>
                     <expression>&gr_Type1; &jd_type_case; &gr_FormalDefaultCaseClause; &jd_type_case_has_type; &gr_Type;</expression>
             </clause>
          </display>

          <p>is used in the static semantics of typeswitch. It
          indicates that under the static environment &xq_stat_env;,
          and with the input type of the typeswitch being &gr_Type1;,
          the given case clause yields the type &gr_Type;.</p>

          <p id="jd_against">The following judgment</p>
 
        <display>
           <clause><environment>&xq_dyn_env;</environment>
                   <expression>&gr_Value1; &jd_against; &gr_FormalCaseClauses; &jd_against_yields; &gr_Value2;</expression>
           </clause>
        </display>

          <p>is used in the dynamic semantics of typeswitch. It
          indicates that under the dynamic environment &xq_dyn_env;,
          with the input value of the typeswitch being &gr_Value1;,
          the given case clauses yield the value &gr_Value2;.</p>

        </smnotation>

        <smtype>

          <p>The static typing rules for the typeswitch expression are
          simple.  Each case clause and the default clause of the
          typeswitch is typed independently. The type of the entire
          typeswitch expression is the union of the types of all the
          clauses.</p>

          <infergr>
           <infer>
            <prejudge>
              <multiclause>
               <clause><environment>&xq_stat_env;</environment>
                       <expression>&gr_Expr0; &jd_has_type; &gr_Type0; </expression>
               </clause>
              </multiclause>
             <multiclause>
              <clause><environment>&xq_stat_env;</environment>
                      <expression>&gr_Type0;
                      &jd_type_case; case &gr_DVarName1; as &gr_SequenceType1; return &gr_Expr1;
                      &jd_type_case_has_type;
                      &gr_Type1;</expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
               <expression>&sp4;&middot;&middot;&middot;</expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause><environment>&xq_stat_env;</environment>
                      <expression>&gr_Type0;
                      &jd_type_case; case &gr_DVarNamen; as &gr_SequenceTypen; return &gr_Exprn;
                      &jd_type_case_has_type;
                      &gr_Typen;</expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause><environment>&xq_stat_env;</environment>
                      <expression>&gr_Type0;
                      &jd_type_case; default &gr_DVarNamenp1; return &gr_Exprn;
                      &jd_type_case_has_type;
                      &gr_Typenp1;</expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_stat_env;</environment>
              <expression>
               <table summary=""><tbody>
                <tr>
                    <td>
                      <table summary=""><tbody> 
                      <tr><td>(typeswitch (&gr_Expr0;)</td></tr> 
                      <tr><td>&sp2;case &gr_DVarName1; as &gr_SequenceType1; return &gr_Expr1;</td></tr>
                      <tr><td>&sp4;&middot;&middot;&middot;</td></tr>
                      <tr><td>&sp2;case &gr_DVarNamen; as &gr_SequenceTypen; return &gr_Exprn;</td></tr>
                      <tr><td>&sp2;default &gr_DVarNamenp1; return &gr_Exprnp1;)</td></tr> </tbody></table>
                    </td>
                </tr>
                </tbody></table>
                &jd_has_type; (&gr_Type1; | ... | &gr_Typenp1;)
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <p>To type one case clause, the case variable is assigned
          the type of the case clause &gr_CaseType; and the body of
          the clause is typed in the extended environment.  Thus, the
          type of a case clause is independent of the type of the
          input expression.</p>

          <infergr>
           <infer>
            <prejudge>
              <multiclause>
               <clause>
                <expression>
                &gr_CaseType; = <map> &gr_SequenceType;
                </map>&jd_map_sequencetype;</expression>
               </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>&xq_stat_env;</environment>
                  <expression>&gr_VarName; &jd_var_qname_expands_to;
                  &gr_Variable;</expression>
                </clause>
              </multiclause>
              <multiclause>
               <clause><environment><update><environment>&xq_type_env;</environment>
                       <expression>&gr_Variable; &xt_bind;
                       &gr_CaseType; </expression></update></environment>
               <expression>&gr_Expr; &jd_has_type; &gr_Type;</expression>
               </clause>
              </multiclause>
            </prejudge>
            <postjudge>
             <clause>
              <environment>&xq_stat_env;</environment>
              <expression>
              &gr_Type0; &jd_type_case; case &gr_DVarName; as
              &gr_SequenceType; return &gr_Expr; &jd_type_case_has_type;  &gr_Type;
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <p>To type the default clause, the variable is assigned the
          type of the input expression and the body of the default
          clause is typed in the extended environment.</p>

          <infergr>
           <infer>
            <prejudge>
 	    <multiclause>
 	      <clause>
              <environment>&xq_stat_env;</environment>
 	      <expression>&gr_VarName; &jd_var_qname_expands_to; &gr_Variable;
 	      </expression>
 	      </clause>
 	    </multiclause>
              <multiclause>
               <clause><environment><update><environment>&xq_type_env;</environment>
                       <expression>&gr_Variable; &xt_bind;
                       &gr_Type0; </expression></update></environment>
               <expression>&gr_Expr; &jd_has_type; &gr_Type;</expression>
               </clause>
              </multiclause>
            </prejudge>
            <postjudge>
             <clause>
              <environment>&xq_stat_env;</environment>
              <expression>
              &gr_Type0; &jd_type_case; default &gr_DVarName; 
              return &gr_Expr; &jd_type_case_has_type;  &gr_Type;
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

  </smtype>

        <smeval>
          <p>The evaluation of a typeswitch proceeds as
          follows. First, the input expression is evaluated, yielding
          an input value.  The <term>effective case</term> is the
          first <code>case</code> clause such that the input value
          matches the SequenceType in the <code>case</code> clause.
          The <code>return</code> clause of the effective case is
          evaluated and the value of the <code>return</code>
          expression is the value of the typeswitch expression.</p>
          
          <infergr>
           <infer>
            <prejudge>
             <multiclause>
             <clause><environment>&xq_dyn_env;</environment>
                     <expression>&gr_Expr; &jd_yields; &gr_Value0;</expression>
             </clause>
             </multiclause>
             <multiclause>
             <clause><environment>&xq_dyn_env;</environment>
                     <expression>&gr_Value0; &jd_against; &gr_FormalCaseClauses; &jd_against_yields; &gr_Value1;</expression>
             </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
                     <expression>typeswitch (&gr_Expr;) &gr_FormalCaseClauses; &jd_yields; &gr_Value1;</expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <p>If the value matches the sequence type, the following
          rule applies: It extends the dynamic environment by binding
          the variable &gr_Variable; to &gr_Value0; and evaluates the
          body of the <code>return</code> clause.</p>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression>
                 &gr_CaseType; = <map> &gr_SequenceType; </map>&jd_map_sequencetype;
               </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
                <environment> &xq_stat_env; </environment>
                <expression>&gr_Value0; &jd_matches; &gr_CaseType;</expression>
              </clause>
             </multiclause>
             <multiclause>
                <clause>
                  <environment>&xq_stat_env;
                  </environment>
                  <expression>&gr_VarName; &jd_var_qname_expands_to;
                  &gr_Variable;</expression>
                </clause>
              </multiclause>
              <multiclause>
               <clause>
                 <environment>
                   <update>
                     <environment>&xq_val_env;</environment>
                     <expression>&gr_Variable; &xt_bind; &gr_Value0;</expression>
                   </update>
                 </environment>
                 <expression>
                   &gr_Expr; &jd_yields; &gr_Value1;
                 </expression>
               </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
                     <expression>
                     &gr_Value0; &jd_against; case &gr_DVarName; as
                     &gr_SequenceType; return &gr_Expr; &gr_FormalCaseClauses;
                     &jd_against_yields; &gr_Value1;
                     </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <p>If the value does not match the sequence type, the
          current case is not evaluated, and the remaining case
          clauses are evaluated in order by applying the inference
          rule recursively.</p>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
             <clause>
              <expression>
                &gr_CaseType; = <map> &gr_SequenceType; </map>&jd_map_sequencetype;
              </expression>
             </clause>
             <clause>
              <environment> &xq_stat_env; </environment>
              <expression>&jd_not;(&gr_Value0; &jd_matches; &gr_CaseType;)</expression>
             </clause>
             <clause><environment> &xq_dyn_env;</environment>
                     <expression>&gr_Value0; &jd_against;
                     &gr_FormalCaseClauses; &jd_against_yields;
                     &gr_Value1;</expression>
             </clause>
            </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
                     <expression> &gr_Value0; &jd_against; case
                     &gr_DVarName; as &gr_SequenceType; return &gr_Expr;
                     &gr_FormalCaseClauses; &jd_against_yields; &gr_Value1;
                     </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <p>The last rule states that the <code>default</code> branch
          of a typeswitch expression always evaluates to the value of
          its <code>return</code> clause.</p>

          <infergr>
           <infer>
            <prejudge>
              <multiclause>
                <clause>
                  <environment>&xq_stat_env;
                  </environment>
                  <expression>&gr_VarName; &jd_var_qname_expands_to;
                  &gr_Variable;</expression>
                </clause>
              </multiclause>
              <multiclause>
             <clause>
               <environment><update>
	         <environment>&xq_val_env;</environment>
	         <expression>&gr_Variable; &xt_bind; &gr_Value0;</expression>
               </update></environment>
               <expression>&gr_Expr; &jd_yields; &gr_Value1;</expression>
             </clause>
              </multiclause>
            </prejudge>
            <postjudge>
            <clause><environment>&xq_dyn_env;</environment>
                    <expression>&gr_Value0; &jd_against; default
                    &gr_DVarName; return &gr_Expr; &jd_against_yields;
                    &gr_Value1;</expression>
            </clause>
           </postjudge>
          </infer>
         </infergr>

        </smeval>

      </div3>

      <div3 id="sec_cast">
        <head>Cast</head>

        <smintro>
          <p>The <code>cast</code> expression can be used to convert a
          value to a specific datatype. It changes both the type and
          value of the result of an expression, and can only be
          applied to an atomic value.</p>
        </smintro>

        <scrap>
          <head></head>
          <prodrecap id="CastExpr"   ref="CastExpr"   orig="xquery"/>
          <prodrecap id="SingleType" ref="SingleType" orig="xquery"/>
        </scrap>

        <smcore>
          <p>The Core grammar productions for <code>cast</code>
          expressions are:</p>
      
          <scrap>
            <head></head>
            <prodrecap id="core-CastExpr"   ref="CastExpr"   orig="core"/>
            <prodrecap id="core-SingleType" ref="SingleType" orig="core"/>
          </scrap>
        </smcore>

        <smnorm>
          <p>The normalization of cast applies atomization to its
          argument. The type declaration asserts that the result is a
          single atomic value.  The second normalization rule applies
          when the target type is optional.</p>

          <mapping>
           <xquery>
            <expression><map>&gr_Expr; cast as &gr_AtomicType; </map>&jd_map_expr;</expression>
           </xquery>
           <core>
            <expression>
             <table summary=""><tbody>
              <tr><td>let $v as &xs_anyAtomicType; := &fn_data;((<map> &gr_Expr; </map>&jd_map_expr;)) return</td></tr>
              <tr><td>&sp2;$v cast as &gr_AtomicType; </td></tr>
             </tbody></table>
            </expression>
           </core>
          </mapping>

          <mapping>
           <xquery>
            <expression><map>&gr_Expr; cast as &gr_AtomicType;? </map>&jd_map_expr;</expression>
           </xquery>
           <core>
            <expression>
             <table summary=""><tbody>
              <tr><td>let $v as &xs_anyAtomicType;? := &fn_data;((<map> &gr_Expr; </map>&jd_map_expr;)) return</td></tr>
              <tr><td>&sp2;typeswitch ($v)</td></tr>
              <tr><td>&sp2;&sp2;case &xq_newvar; as empty-sequence() return ()</td></tr>
              <tr><td>&sp2;&sp2;default &xq_newvar; return $v cast as &gr_AtomicType; </td></tr>
             </tbody></table>
            </expression>
           </core>
          </mapping>

        </smnorm>

        <smtype>
          <p>The static typing rule of <code>cast</code> expression is
          as follows. The type of a Core <code>cast</code> expression
          is always the target type. Note that a <code>cast</code>
          expression can fail at run-time if the given value cannot be
          cast to the target type.</p>

          <infergr>
           <infer>
            <prejudge>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_stat_env;</environment>
              <expression>&gr_Expr; cast as &gr_AtomicType; &jd_has_type; &gr_AtomicType;</expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
        </smtype>

        <smnotation>
          <p>The dynamic semantics of <code>cast</code> expressions is
          defined in <xspecref spec="FO" ref="casting"/>. The
          semantics of cast expressions depends on the type of the
          input value and on the target type. For any source and
          target primitive types, the <emph>casting table</emph> in
          <xspecref spec="FO" ref="casting"/> indicates whether the
          cast from the source type to the target type is permitted.
          When a cast is permitted, the detailed dynamic evaluation
          rules for cast in <xspecref spec="FO" ref="casting"/> are
          applied. We refer to those rules using an auxiliary judgment
          defined as follows.</p>

          <p id="jd_cast_value_to">The judgment</p>
          <display>
            <clause>
            <expression>&gr_AtomicValue1; &jd_cast_value_to; &gr_AtomicType;
            &jd_cast_value_to_arrow; &gr_AtomicValue2;</expression>
            </clause>
          </display>
          <p>holds if &gr_AtomicValue1; can be cast to type
          &gr_AtomicType;, resulting in the new value
          &gr_AtomicValue2; according to the rules in <xspecref
          spec="FO" ref="casting"/>.</p>
        </smnotation>

        <smeval>
          <infergr>
           <infer>
            <prejudge>
            <multiclause>
              <clause>
               <environment>&xq_dyn_env;</environment>
               <expression>
                 &gr_Expr; &jd_yields; &gr_AtomicValue1;
               </expression>
              </clause>
            </multiclause>
            <multiclause>
              <clause>
              <expression>&gr_AtomicValue1; &jd_cast_value_to; &gr_AtomicType;
              &jd_cast_value_to_arrow; &gr_AtomicValue2;</expression>
              </clause>
            </multiclause>
            </prejudge>
            <postjudge>
              <clause><environment>&xq_dyn_env;</environment>
              <expression>&gr_Expr; cast as &gr_AtomicType; &jd_yields; &gr_AtomicValue2;</expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
        </smeval>

      </div3>

      <div3 id="sec_castable">
        <head>Castable</head>

        <scrap>
          <head></head>
          <prodrecap id="CastableExpr" ref="CastableExpr" orig="xquery"/>
        </scrap>

        <p>Castable expressions check whether a value can be cast to a
        given type.</p>

        <smcore>
          <p>The Core grammar production for castable is:</p>
      
          <scrap>
            <head></head>
            <prodrecap ref="CastableExpr" id="core-CastableExpr" orig="core"/>
          </scrap>
        </smcore>

        <smnorm>
          <p>The normalization of castable simply maps its expression
          argument.</p>

          <mapping diff='del' at='E032'>
           <xquery>
            <expression><map>&gr_Expr; castable as &gr_AtomicType;</map>&jd_map_expr;</expression>
           </xquery>
           <core>
            <expression>
             <table summary=""><tbody>
              <tr><td>let $v as &xs_anyAtomicType; := &fn_data;((<map> &gr_Expr; </map>&jd_map_expr;)) return</td></tr>
              <tr><td>$v castable as &gr_AtomicType;</td></tr>
             </tbody></table>
            </expression>
           </core>
          </mapping>

          <mapping diff='del' at='E032'>
           <xquery>
            <expression><map>&gr_Expr; castable as &gr_AtomicType;?</map>&jd_map_expr;</expression>
           </xquery>
           <core>
            <expression>
             <table summary=""><tbody>
              <tr><td>let $v as &xs_anyAtomicType;? := &fn_data;((<map> &gr_Expr; </map>&jd_map_expr;)) return</td></tr>
              <tr><td>$v castable as &gr_AtomicType;?</td></tr>
             </tbody></table>
            </expression>
           </core>
          </mapping>

          <mapping diff='add' at='E032'>
            <xquery>
              <expression>
                <map>&gr_Expr; castable as &gr_SingleType;</map>&jd_map_expr;
              </expression>
            </xquery>
            <core>
              <expression>
                ( <map>&gr_Expr;</map>&jd_map_expr; ) castable as &gr_SingleType;
              </expression>
            </core>
          </mapping>

        </smnorm>

        <smtype>
          <p>The type of a Core <code>castable</code> expression is
          always a boolean.</p>

          <infergr>
           <infer>
            <prejudge>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_stat_env;</environment>
              <expression>&gr_Expr; castable as &gr_AtomicType; &jd_has_type; &xs_boolean;</expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

        </smtype>

        <smnotation diff='add' at='E032'>
          <p id="jd_can_be_cast_to">The auxiliary judgment:</p>
          <display>
            <clause>
              <expression>
                &gr_Value; &jd_can_be_cast_to; &gr_SingleType;
              </expression>
            </clause>
          </display>
          <p>
          holds when &gr_Value; can be atomized and cast to &gr_SingleType;.
          Its definition depends on the &jd_cast_value_to; judgment.
          </p>

          <infergr>
            <infer>
              <prejudge>
              </prejudge>
              <postjudge>
                <multiclause>
                  <clause>
                    <expression>() &jd_can_be_cast_to; &gr_AtomicType;?</expression>
                  </clause>
                </multiclause>
              </postjudge>
            </infer>
          </infergr>

          <infergr>
            <infer>
              <prejudge>
                <multiclause>
                  <clause>
                    <expression>&gr_Value; &jd_can_be_cast_to; &gr_AtomicType;</expression>
                  </clause>
                </multiclause>
              </prejudge>
              <postjudge>
                <multiclause>
                  <clause>
                    <expression>&gr_Value; &jd_can_be_cast_to; &gr_AtomicType;?</expression>
                  </clause>
                </multiclause>
              </postjudge>
            </infer>
          </infergr>

          <infergr>
            <infer>
              <prejudge>
                <multiclause>
                  <clause>
                    <expression>fn:data(&gr_Value;) = &gr_AtomicValue1;</expression>
                  </clause>
                </multiclause>
                <multiclause>
                  <clause>
                    <expression>
                      &gr_AtomicValue1;
                      &jd_cast_value_to; &gr_AtomicType;
                      &jd_cast_value_to_arrow; &gr_AtomicValue2;
                    </expression>
                  </clause>
                </multiclause>
              </prejudge>
              <postjudge>
                <multiclause>
                  <clause>
                    <expression>&gr_Value; &jd_can_be_cast_to; &gr_AtomicType;</expression>
                  </clause>
                </multiclause>
              </postjudge>
            </infer>
          </infergr>

        </smnotation>

        <smeval>
          <p>
          <phrase diff='del' at='E032'>If casting succeeds,</phrase>
          <phrase diff='add' at='E032'>If the value of the operand expression can be cast to the given type,</phrase>
          then the <code>castable</code>
          expression evaluates to true.</p>

          <infergr>
           <infer>
            <prejudge>
             <multiclause diff='del' at='E032'>
              <clause>
               <environment>&xq_dyn_env;</environment>
               <expression>&gr_Expr; cast as &gr_AtomicType; &jd_yields; &gr_Value2;</expression>
              </clause>
             </multiclause>
             <multiclause diff='add' at='E032'>
               <clause>
                 <environment>&xq_dyn_env;</environment>
                 <expression>&gr_Expr; &jd_yields; &gr_Value;</expression>
               </clause>
             </multiclause>
             <multiclause diff='add' at='E032'>
               <clause>
                 <expression>&gr_Value; &jd_can_be_cast_to; &gr_SingleType;</expression>
               </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment>
                      <expression>&gr_Expr; castable as
                        <phrase diff='del' at='E032'>&gr_AtomicType;</phrase>
                        <phrase diff='add' at='E032'>&gr_SingleType;</phrase>
                      &jd_yields; true</expression>
              </clause>
             </multiclause>
            </postjudge>
           </infer>
          </infergr>

          <p>Otherwise, 'castable as' evaluates to false.</p>

          <infergr>
           <infer>
            <prejudge>
             <multiclause diff='del' at='E032'>
              <clause><environment>&xq_dyn_env;</environment>
                      <expression>&jd_not;(&gr_Expr; &jd_yields; &gr_Value1;)</expression></clause>
             </multiclause>
             <multiclause diff='add' at='E032'>
               <clause>
                 <environment>&xq_dyn_env;</environment>
                 <expression>&gr_Expr; &jd_yields; &gr_Value;</expression>
               </clause>
             </multiclause>
             <multiclause diff='add' at='E032'>
               <clause>
                 <expression>&jd_not;(&gr_Value; &jd_can_be_cast_to; &gr_SingleType;)</expression>
               </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment>
                      <expression>
                        <phrase diff='del' at='E032'>&gr_Expr1;</phrase>
                        <phrase diff='add' at='E032'>&gr_Expr;</phrase>
                        castable as
                        <phrase diff='del' at='E032'>&gr_AtomicType2;</phrase>
                        <phrase diff='add' at='E032'>&gr_SingleType;</phrase>
                        &jd_yields; false</expression>
              </clause>
             </multiclause>
            </postjudge>
           </infer>
          </infergr>

        </smeval>

      </div3>

      <div3 id="sec_constructor-functions">
        <head>Constructor Functions</head>

        <p>Constructor functions provide an alternative syntax for
        casting.</p>

        <smnotation diff='add' at='E008'>

          <p id='jd_denotes_a_constructor_function'>
            Calls to constructor functions
            are normalized differently from other function calls,
            so we introduce an auxiliary judgment
            to detect whether the function being called
            is a constructor function.
          </p>

          <display>
            <clause>
              <environment>&xq_stat_env;</environment>
              <expression>
                &xd_qname; &jd_denotes_a_constructor_function;
              </expression>
            </clause>
          </display>

          <p>
            This judgment holds when the expanded function name
            maps to an atomic type in the in-scope schema types.
          </p>

          <infergr>
            <infer>
              <prejudge>
                <multiclause>
                  <clause>
                    <expression>
                      &xq_type_defn;(&xd_qname;) = define type &gr_QName; &gr_AtomicTypeDerivation;
                    </expression>
                  </clause>
                </multiclause>
              </prejudge>
              <postjudge>
                <clause>
                  <environment>&xq_stat_env;</environment>
                  <expression>
                    &xd_qname; &jd_denotes_a_constructor_function;
                  </expression>
                </clause>
              </postjudge>
            </infer>
          </infergr>

        </smnotation>

        <smnorm>
          <p>Constructor functions for atomic types are normalized to
          explicit <code>cast as</code> expressions. Note that the
          following normalization rule requires to resolve the name of
          the function call and <phrase diff='chg' at='E008'>confirm that it
          denotes a constructor function</phrase> in the static context.</p>

         <infergr>
          <infer>
           <prejudge>
            <multiclause>
              <clause><environment>&xq_stat_env;</environment>
                <expression>&gr_QName; &jd_func_qname_expands_to; &xd_qname;</expression>
              </clause>
            </multiclause>
            <multiclause>
             <clause diff='chg' at='E008'>
              <environment>&xq_stat_env;</environment>
              <expression>
                &xd_qname; &jd_denotes_a_constructor_function;
              </expression>
             </clause>
            </multiclause>
           </prejudge>
          <postjudge>
           <clause>
            <environment>&xq_stat_env;</environment>
            <expression>
              <map>&gr_QName;(&gr_ExprSingle1;)</map>&jd_map_expr;
              =
              <map>&gr_ExprSingle1; cast as &gr_QName;?</map>&jd_map_expr;
            </expression>
           </clause>
          </postjudge>
         </infer>
         </infergr>
        </smnorm>

      </div3>

        <div3 id="sec_treat">
          <head>Treat</head>

<scrap>
<head></head>
   <prodrecap id="TreatExpr" ref="TreatExpr" orig="xquery"/>
</scrap>

          <smintro>
            <p>The expression <quote>&gr_Expr; treat as
            &gr_SequenceType;</quote>, can be used to change the
            static type of the result of an expression without
            changing its value.  The treat-as expression raises a
            dynamic error if the dynamic type of the input value does
            not match the specified type.</p>
          </smintro>

          <smnorm>
            <p>Treat as expressions are normalized to typeswitch
            expressions. Note that the following normalization rule
            uses a variable &xq_newvar;, which is a newly created
            variable that does not conflict with any variables already
            in scope.</p>

            <mapping>
             <xquery>
              <expression><map>&gr_Expr; treat as &gr_SequenceType;</map>&jd_map_expr;</expression>
             </xquery>
             <core>
              <expression>
               <table summary=""><tbody>
                <tr><td>typeswitch (<map> &gr_Expr; </map>&jd_map_expr;)</td></tr>
                <tr><td>&sp2;case &xq_newvar; as &gr_SequenceType; return &xq_newvar;</td></tr>
                <tr><td>&sp2;default &xq_newvar; return &fn_error;()</td></tr>
               </tbody></table>
              </expression>
             </core>
            </mapping>
          </smnorm>

      </div3>

    </div2>

    <div2 id="sec_validate_expr">
      <head>Validate Expressions</head>

      <scrap>
        <head></head>
        <prodrecap id="ValidateExpr"   ref="ValidateExpr"        orig="xquery"/>
        <prodrecap id="ValidationMode" ref="ValidationMode"      orig="xquery"/>
      </scrap>

      <smcore>
        <p>The Core grammar productions for validate are:</p>
      
    <scrap>
        <head></head>
        <prodrecap id="core-ValidateExpr"   ref="ValidateExpr"   orig="core"/>
        <prodrecap id="core-ValidationMode" ref="ValidationMode" orig="core"/>
    </scrap>
      </smcore>

      <p>A <code>validate</code> expression validates its argument
      with respect to the <term>in-scope schema definitions</term>,
      using the schema validation process described in
      &xq_xmlschema1;. The argument to a validate expression must be
      either an element or a document node. Validation replaces all
      nodes with new nodes that have their own identity, the <xtermref
      spec="XQ" ref="dt-type-annotation"/>, and default values created
      during the validation process.</p>

      <smnorm>
        <p>A validate expression with no validation mode is normalized
        into a validate expression with the validation mode set to
        strict.</p>

        <mapping>
        <xquery>
        <expression>
          <map>validate { &gr_Expr; }</map>&jd_map_expr;
        </expression>
        </xquery>
        <core>
        <expression>
          validate strict { <map>&gr_Expr;</map>&jd_map_expr; }
        </expression>
        </core>
        </mapping>

        <mapping>
        <xquery>
        <expression>
          <map>validate &gr_ValidationMode; { &gr_Expr; }</map>&jd_map_expr;
        </expression>
        </xquery>
        <core>
        <expression>
          validate &gr_ValidationMode; { <map>&gr_Expr;</map>&jd_map_expr; }
        </expression>
        </core>
        </mapping>

      </smnorm>

      <smtype>
        <p>Static typing of the validate operation is defined by the
        following rule.  Note the use of a subtyping check to ensure
        that the type of the expression to validate is either an
        element or a well-formed document node (i.e., with only one
        root element and no text nodes).  The type of the expression
        to validate may be a union of more than one element type.  We
        apply the &jd_with_mode; judgment to each element type to
        determine the meaning of that element type with the given
        validation mode, which yields a new element type.  The result
        type is the union over all new element types.</p>

        <infergr>
         <infer>
          <prejudge>
           <multiclause>
           <clause>
            <environment>&xq_stat_env;</environment>
            <expression>&gr_Expr; &jd_has_type; &gr_Type;</expression>
           </clause>
           </multiclause>

           <multiclause>
           <clause>
            <environment>&xq_stat_env;</environment>
            <expression>&gr_Type; &jd_subtype_of; (element<phrase diff='add' at='E023'> *</phrase> | document { &gr_ElementType; })</expression>
           </clause>
           </multiclause>

           <multiclause>
           <clause>
            <environment>&xq_stat_env;</environment>
            <expression>&jd_prime;(&gr_Type;) =  &gr_ElementType1; |
            ... | &gr_ElementTypen; </expression>
           </clause>
           </multiclause>

           <multiclause>
           <clause>
            <expression>&gr_ElementType1; = element &gr_ElementNameOrWildcard1; &gr_OptTypeSpecifier1;</expression>
           </clause>
           </multiclause>

           <multiclause>
           <clause>
            <expression>&middot;&middot;&middot;</expression>
           </clause>
           </multiclause>

           <multiclause>
           <clause>
            <expression>&gr_ElementTypen; = element &gr_ElementNameOrWildcardn;  &gr_OptTypeSpecifiern;</expression>
           </clause>
           </multiclause>

           <multiclause>
           <clause>
            <environment>&xq_stat_env;</environment>
            <expression>&gr_ElementNameOrWildcard1; &jd_with_mode; &gr_ValidationMode; 
             &jd_context_resolves; &gr_ElementType1; </expression>
           </clause>
           </multiclause>
           <multiclause>
           <clause>
            <expression>&middot;&middot;&middot;</expression>
           </clause>
           </multiclause>

           <multiclause>
           <clause>
            <environment>&xq_stat_env;</environment>
            <expression>&gr_ElementNameOrWildcardn; &jd_with_mode; &gr_ValidationMode; 
             &jd_context_resolves; &gr_ElementTypen; </expression>
           </clause>
           </multiclause>


           <multiclause>
           <clause>
            <expression>&gr_Type1; = &gr_ElementType1; | ... | &gr_ElementTypen;</expression>
           </clause>
           </multiclause>
          </prejudge>
          <postjudge>
           <clause><environment>&xq_stat_env;</environment>
                   <expression>validate &gr_ValidationMode; { &gr_Expr; } &jd_has_type; &gr_Type1;
                   </expression>
           </clause>
          </postjudge>
         </infer>
        </infergr>
      </smtype>

    <div3 id="sec_validating_element">
      <head>Validating an Element Node</head>
      <smeval>

        <p>The normative dynamic semantics of validation is specified
        in <xspecref spec="XQ" ref="id-validate"/>.  The effect of
        validation of a data model value is equivalent to:

        <ulist>
          <item><p>serialization of the data model, as described in
          &xq_datamodel_serialization;, followed by</p></item>
          <item><p>validation of the serialized value into a Post-Schema
          Validated Infoset, as described in &xq_xmlschema1;, followed by</p></item>
          <item><p>construction of a new data model value, as described in
          &xq_datamodel;.</p></item>
        </ulist>
        </p>

        <p>The above steps are expressed formally by the "erasure" and
        "annotation" judgments.  Formally, validation removes existing
        type annotations from nodes ("erasure"), and it re-validates
        the corresponding data model instance, possibly adding new
        type annotations to nodes ("annotation"). Both erasure and
        annotation are described formally in <specref
        ref="sec_validation_judgments"/>. Indeed, the conjunction of
        erasure and annotation provides a formal model for a large
        part of actual schema validation. The semantics of the
        <code>validate</code> expression is specified as follows.</p>

        <p>In the first premise below, the expression to validate is
        evaluated. The resulting value must be an element or document
        node. The second premise constructs a new value in which all
        existing type annotations have been erased. The third premise
        determines the element type that corresponds to the element
        node's name in the given validation mode. The last premise
        validates erased element node with the type against which it
        is validated, using the &jd_annotate_as; judgment, yielding
        the final validated element.</p>

        <infergr>
         <infer>
          <prejudge>
           <multiclause>
           <clause>
             <environment>
               &xq_stat_env;; &xq_dyn_env;
             </environment>
             <expression>
               &gr_Expr; &jd_yields; &gr_ElementValue1;
             </expression>
           </clause>
           </multiclause>

           <multiclause>
           <clause>
            <expression>&gr_ElementValue1; &jd_erases_to; &gr_ElementValue2; 
            </expression>
           </clause>
           </multiclause>

           <multiclause>
           <clause>
            <expression>
            &gr_ElementValue2; = element &gr_ElementName2; of type &gr_TypeName2; { &gr_Value; }
</expression>
           </clause>
           </multiclause>

           <multiclause>
           <clause>
            <environment>&xq_stat_env;</environment>
            <expression>&gr_ElementName2; &jd_with_mode; &gr_ValidationMode; 
             &jd_context_resolves; &gr_ElementType2; </expression>
           </clause>
           </multiclause>

           <multiclause>
           <clause>
            <environment>&xq_stat_env;</environment>
            <expression>&jd_annotate_as; &gr_ElementType2; ( &gr_ElementValue2;) &jd_annotate_as_arrow;
             &gr_ElementValue3; </expression>
           </clause>
           </multiclause>
          </prejudge>
          <postjudge>
           <clause><environment>&xq_dyn_env;</environment>
                   <expression>validate &gr_ValidationMode; { &gr_Expr; } &jd_yields;
                   &gr_ElementValue3; 
                   </expression>
           </clause>
          </postjudge>
         </infer>
        </infergr>
</smeval>
    </div3>

    <div3 id="sec_validating_document">
      <head>Validating a Document Node</head>

      <p>The rule for validating a document node is similar to that
      for validating an element node.</p>

       <smeval>
        <infergr>
         <infer>
          <prejudge>
           <multiclause>
           <clause>
             <environment>
               &xq_stat_env;; &xq_dyn_env;
             </environment>
             <expression>
               &gr_Expr; &jd_yields; document { &gr_ElementValue1; }
             </expression>
           </clause>
           </multiclause>

           <multiclause>
           <clause>
            <expression>document { &gr_ElementValue1; } &jd_erases_to;
            document { &gr_ElementValue2; }</expression>
           </clause>
           </multiclause>

           <multiclause>
           <clause>
            <expression>
            &gr_ElementValue2; = element &gr_ElementName2; of type &gr_TypeName2; { &gr_Value; }
</expression>
           </clause>
           </multiclause>

           <multiclause>
           <clause>
            <environment>&xq_stat_env;</environment>
            <expression>&gr_ElementName2; &jd_with_mode;
            &gr_ValidationMode; &jd_context_resolves;
            &gr_ElementType2; </expression>
           </clause>
           </multiclause>

           <multiclause>
           <clause>
            <environment>&xq_stat_env;</environment>
            <expression>&jd_annotate_as; document { &gr_ElementType2; } (document { &gr_ElementValue2; }) &jd_annotate_as_arrow;
            document { &gr_ElementValue3; }</expression>
           </clause>
           </multiclause>
          </prejudge>
          <postjudge>
           <clause><environment>&xq_dyn_env;</environment>
                   <expression>validate &gr_ValidationMode; { &gr_Expr; } &jd_yields;
                   document { &gr_ElementValue3; }
                   </expression>
           </clause>
          </postjudge>
         </infer>
        </infergr>

      </smeval>
      
  </div3>

 </div2>

 <div2 id="id-extension-expressions" role="xquery">
   <head>Extension Expressions</head>

   <smintro>
     <p>An extension expression is an expression whose semantics are
     implementation-defined. An extension expression consists of one
     or more pragmas, followed by an expression enclosed in curly
     braces.</p>

     <scrap>
       <head></head>

       <prodrecap id="ExtensionExpr"  ref="ExtensionExpr"  orig="xquery"/>
       <prodrecap id="Pragma"         ref="Pragma"         orig="xquery"/>
       <prodrecap id="PragmaContents" ref="PragmaContents" orig="xquery"/>
     </scrap>
   </smintro>

   <smcore>
     <p>The Core grammar productions for ExtensionExpr are:</p>

     <scrap>
       <head></head>

       <prodrecap id="core-ExtensionExpr"  ref="ExtensionExpr"  orig="core"/>
       <prodrecap id="core-Pragma"         ref="Pragma"         orig="core"/>
       <prodrecap id="core-PragmaContents" ref="PragmaContents" orig="core"/>
     </scrap>
   </smcore>

    <smnorm>
      <p>Extension expressions are normalized as extension expressions
      in the &language; Core.</p>

      <mapping>
       <xquery>
         <expression><map>&gr_Pragma;+ { &gr_Expr; }</map>&jd_map_expr;</expression>
       </xquery>
       <core>
         <expression>&gr_Pragma;+ { <map>&gr_Expr;</map>&jd_map_expr; }</expression>
       </core>
      </mapping>

      <p>If the extension expression does not contain any expression,
      this is normalized into an extension expression with a call to
      the &fn_error; function.</p>

      <mapping>
       <xquery>
         <expression><map>&gr_Pragma;+ { }</map>&jd_map_expr;</expression>
       </xquery>
       <core>
         <expression>&gr_Pragma;+ { &fn_error;() }</expression>
       </core>
      </mapping>

   </smnorm>

   <smtype>
     <p>If at least one of the pragmas is recognized, the static
     semantics are implementation-defined.</p>

     <p>If none of the pragmas is recognized, the static semantics
     are the same as for the input expression. In both cases, the
     static typing must be applied on the input expression, possibly
     raising the corresponding type errors.</p>

     <infergr>
      <infer>
       <prejudge>
        <multiclause>
          <clause>
           <environment>&xq_stat_env;</environment>
           <expression>
             &gr_Expr; &jd_has_type; &gr_Type1;
           </expression>
          </clause>
        </multiclause>
        <multiclause>
          <clause>
           <environment>&xq_stat_env;</environment>
           <expression>
             A &gr_Pragma; is recognized, yielding the
             implementation-defined static type &gr_Type2;.
           </expression>
          </clause>
        </multiclause>
       </prejudge>
       <postjudge>
        <clause>
         <environment>&xq_stat_env;</environment>
         <expression>
          &gr_Pragma;+ { &gr_Expr; } &jd_has_type; &gr_Type2;
         </expression>
        </clause>
       </postjudge>
      </infer>
     </infergr>

     <infergr>
      <infer>
       <prejudge>
        <multiclause>
          <clause>
           <environment>&xq_stat_env;</environment>
           <expression>
             &gr_Expr; &jd_has_type; &gr_Type1;
           </expression>
          </clause>
        </multiclause>
        <multiclause>
          <clause>
           <environment>&xq_stat_env;</environment>
           <expression>
             No &gr_Pragma; is recognized.
           </expression>
          </clause>
        </multiclause>
       </prejudge>
       <postjudge>
        <clause>
         <environment>&xq_stat_env;</environment>
         <expression>
          &gr_Pragma;+ { &gr_Expr; } &jd_has_type; &gr_Type1;
         </expression>
        </clause>
       </postjudge>
      </infer>
     </infergr>

   </smtype>

   <smeval>
     <p>The QName of a pragma must resolve to a namespace URI and
     local name, using the statically known namespaces. If at least
     one of the pragmas is recognized, the dynamic semantics is
     implementation-defined.</p>

     <infergr>
      <infer>
       <prejudge>
        <multiclause>
          <clause>
           <environment>&xq_dyn_env;</environment>
           <expression>
             Some &gr_Pragma; are recognized, yielding the
             implementation-defined value &gr_Value;.
           </expression>
          </clause>
        </multiclause>
       </prejudge>
       <postjudge>
        <clause>
         <environment>&xq_dyn_env;</environment>
         <expression>
          &gr_Pragma;+ { &gr_Expr; } &jd_yields; &gr_Value;
         </expression>
        </clause>
       </postjudge>
      </infer>
     </infergr>

     <p>If none of the pragmas is recognized, the dynamic semantics of
     an &gr_ExtensionExpr; are the same as evaluating the given
     expression.</p>

     <infergr>
      <infer>
       <prejudge>
        <multiclause>
          <clause>
           <expression>
             No &gr_Pragma; is recognized.
           </expression>
          </clause>
          <clause>
           <environment>&xq_dyn_env;</environment>
           <expression>
             &gr_Expr; &jd_yields; &gr_Value;
           </expression>
          </clause>
        </multiclause>
       </prejudge>
       <postjudge>
        <clause>
         <environment>&xq_dyn_env;</environment>
         <expression>
          &gr_Pragma;+ { &gr_Expr; } &jd_yields; &gr_Value;
         </expression>
        </clause>
       </postjudge>
      </infer>
     </infergr>

   </smeval>

 </div2>

</div1>

<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-indent-step:2
indent-tabs-mode:nil
sgml-parent-document:("XPathXQuerySemantics.xml" "body" "div1")
End:
-->

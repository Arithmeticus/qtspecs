<?xml version="1.0" encoding="UTF-8"?>

<!-- Current changes labelled at="S" -->
<fos:functions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://www.w3.org/xpath-functions/spec/namespace ../../xpath-functions-30/src/fos.xsd"
   xmlns:fos="http://www.w3.org/xpath-functions/spec/namespace">
   <fos:global-variables>
      <fos:variable name="po" as="element()">&lt;PurchaseOrder&gt; &lt;line-item&gt;
         &lt;description&gt;Large widget&lt;/description&gt; &lt;price&gt;8.95&lt;/price&gt;
         &lt;quantity&gt;5.0&lt;/quantity&gt; &lt;/line-item&gt; &lt;line-item&gt;
         &lt;description&gt;Small widget&lt;/description&gt; &lt;price&gt;3.99&lt;/price&gt;
         &lt;quantity&gt;2.0&lt;/quantity&gt; &lt;/line-item&gt; &lt;line-item&gt;
         &lt;description&gt;Tiny widget&lt;/description&gt; &lt;price&gt;1.49&lt;/price&gt;
         &lt;quantity&gt;805&lt;/quantity&gt; &lt;/line-item&gt;
         &lt;/PurchaseOrder&gt;</fos:variable>
      <fos:variable name="item1" select="$po/line-item[1]"/>
      <fos:variable name="item2" select="$po/line-item[2]"/>
      <fos:variable name="item3" select="$po/line-item[3]"/>
   </fos:global-variables>



   <fos:function name="current">
      <fos:signatures>
         <fos:proto name="current" return-type="item()"/>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-dependent</fos:property>
         <fos:property>focus-dependent</fos:property>
         <fos:property>special-streaming-rules</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the item that is the context item for the evaluation of the containing XPath
            expression</p>
      </fos:summary>
      <fos:rules>

         <p>The <function>current</function> function, used within an XPath <termref
               def="dt-expression">expression</termref>, returns the item that was the <termref
               def="dt-context-item">context item</termref> at the point where the expression was
            invoked from the XSLT <termref def="dt-stylesheet">stylesheet</termref>. This is
            referred to as the current item. For an outermost expression (an expression not
            occurring within another expression), the current item is always the same as the context
            item. Thus,</p>
         <eg xml:space="preserve"><![CDATA[<xsl:value-of select="current()"/>]]></eg>
         <p>means the same as</p>
         <eg xml:space="preserve"><![CDATA[<xsl:value-of select="."/>]]></eg>
         <p>However, within square brackets, or on the right-hand side of the <code>/</code>
            operator, the current item is generally different from the context item.</p>
         <p>If the <function>current</function> function is used within a <termref def="dt-pattern"
               >pattern</termref>, its value is the <phrase diff="chg" at="C">item</phrase> that is
            being matched against the pattern.</p>

      </fos:rules>
      <fos:errors>
         <p>
            <error spec="XT" type="dynamic" class="DE" code="1360">
               <p>If the <function>current</function> function is evaluated within an expression
                  that is evaluated when the context item is absent, a <termref
                     def="dt-dynamic-error"><phrase diff="del" at="N">non-recoverable</phrase>
                     dynamic error</termref> occurs.</p>
            </error>
         </p>
         <p diff="add" at="Q-bug23631">When the <function>current</function> is called by means of a
            dynamic function call (for example, <code>current#0()</code>), it is evaluated as if the
            context item is absent (<errorref spec="XT" type="dynamic" class="DE" code="1360"
            />).</p>

      </fos:errors>
      <fos:examples>

         <fos:example>
            <p>The instruction:</p>
            <eg xml:space="preserve"><![CDATA[<xsl:apply-templates select="//glossary/entry[@name=current()/@ref]"/>]]></eg>
            <p>will process all <code>entry</code> elements that have a <code>glossary</code> parent
               element and that have a <code>name</code> attribute with value equal to the value of
               the current item's <code>ref</code> attribute. This is different from</p>
            <eg xml:space="preserve"><![CDATA[<xsl:apply-templates select="//glossary/entry[@name=./@ref]"/>]]></eg>
            <p>which means the same as</p>
            <eg xml:space="preserve"><![CDATA[<xsl:apply-templates select="//glossary/entry[@name=@ref]"/>]]></eg>
            <p>and so would process all <code>entry</code> elements that have a
                  <code>glossary</code> parent element and that have a <code>name</code> attribute
               and a <code>ref</code> attribute with the same value.</p>
         </fos:example>

      </fos:examples>


   </fos:function>


   <fos:function name="current-group">
      <fos:signatures>
         <fos:proto name="current-group" return-type="item()*"/>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
         <fos:property>special-streaming-rules</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the group currently being processed by an <elcode>xsl:for-each-group</elcode>
            <phrase diff="del" at="K">or <elcode>xsl:merge</elcode></phrase> instruction.</p>
      </fos:summary>
      <fos:rules>
         <p> The evaluation context for XPath <termref def="dt-expression">expressions</termref>
            includes a component called the <termref def="dt-current-group">current group</termref>,
            which is a sequence. </p>

         <p diff="add" at="C">The function <function>current-group</function> returns the sequence
            of items making up the current group.</p>

         <p diff="add" at="C">The current group is bound during evaluation of the
               <elcode>xsl:for-each-group</elcode> instruction. If no
               <elcode>xsl:for-each-group</elcode> instruction is being evaluated, the current group
            will be <termref def="dt-absent"/>: that is, any reference to it will cause a dynamic
            error.</p>

         <p diff="add" at="R-bug24150">The effect of <termref def="dt-invocation-construct"
               >invocation constructs</termref> on the <termref def="dt-current-group"/> is as
            follows:</p>

         <ulist diff="add" at="R-bug24150">
            <item>
               <p>If the <termref def="dt-invocation-construct"/> is contained within a <termref
                     def="dt-declared-streamable"/>
                  <termref def="dt-construct"/> (for example, if it is within an
                     <elcode>xsl:source-document</elcode> instruction with the attribute <code>streamable="yes"</code>, 
                  or within a streamable template), then the
                  invocation construct sets the current group to <termref def="dt-absent"/>. In this
                  situation the scope of the current group is effectively static; it can only be
                  referenced within the body of the <elcode>xsl:for-each-group</elcode> instruction
                  to which it applies.</p>
            </item>

            <item>
               <p>If the <termref def="dt-invocation-construct"/> is a (static or dynamic) function
                  call, then the invocation construct sets the current group to <termref
                     def="dt-absent"/>.</p>
            </item>

            <item>
               <p>Otherwise the <termref def="dt-invocation-construct"/> leaves the current group
                  unchanged. In this situation the scope of the current group is effectively
                  dynamic: it can be referenced within called templates and attribute sets.</p>
            </item>
         </ulist>

         <p diff="chg" at="R-bug24150">The current group is initially <termref def="dt-absent"/>
            during the evaluation of global variables and stylesheet parameters, during the
         evaluation of the <code>use</code> attribute or contained sequence constructor of <elcode>xsl:key</elcode>,
         and during the evaluation of the <code>initial-value</code> attribute of <elcode>xsl:accumulator</elcode>
         and the <code>select</code> attribute of contained sequence constructor of <elcode>xsl:accumulator-rule</elcode>.</p>




      </fos:rules>
      <fos:errors>
         <p>
            <error spec="XT" type="static" class="SE" code="1060">
               <p>It is a <termref def="dt-static-error">static error</termref> if the
                     <function>current-group</function> function is used within a <termref
                     def="dt-pattern">pattern</termref>.</p>
            </error>
         </p>
         <p diff="add" at="K">
            <error spec="XT" type="dynamic" class="DE" code="1061">
               <p>It is a <termref def="dt-dynamic-error">dynamic error</termref> if the
                     <function>current-group</function> function is used when the current group is
                     <termref def="dt-absent">absent</termref>
                  <phrase diff="add" at="N">, or when it is invoked in the course of evaluating a
                     pattern</phrase>. The error <rfc2119>may</rfc2119> be reported statically if it
                  can be detected statically.</p>
            </error>
         </p>
      </fos:errors>
      <fos:notes>
         <p diff="chg" at="R-bug24621">Like other XSLT extensions to the dynamic evaluation context,
            the <termref def="dt-current-group"/> is not retained as part of the closure of a
            function value. This means that the expression <code>current-group#0</code> is valid and
            returns a function value, but any invocation of this function will fail with a dynamic
            error <errorref spec="XT" class="DE" code="1061"/>. </p>

      </fos:notes>
   </fos:function>

   <fos:function name="current-grouping-key">
      <fos:signatures>
         <fos:proto name="current-grouping-key" return-type="xs:anyAtomicType*"/>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
         <fos:property>special-streaming-rules</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the grouping key of the group currently being processed using the
               <elcode>xsl:for-each-group</elcode>
            <phrase diff="del" at="K">or <elcode>xsl:merge</elcode></phrase> instruction.</p>
      </fos:summary>
      <fos:rules>
         <p> The evaluation context for XPath <termref def="dt-expression">expressions</termref>
            includes a component called the <termref def="dt-current-grouping-key">current grouping
               key</termref>, which is <phrase diff="chg" at="C">a sequence of atomic
               values</phrase>. The current grouping key is the <termref def="dt-grouping-key"
               >grouping key</termref> shared in common by all the items within the <termref
               def="dt-current-group">current group</termref>. </p>

         <p>The function <function>current-grouping-key</function> returns the <termref
               def="dt-current-grouping-key">current grouping key</termref>.</p>

         <p diff="add" at="C">The current grouping key is bound during evaluation of an
               <elcode>xsl:for-each-group</elcode> instruction that has a <code>group-by</code> or
               <code>group-adjacent</code> attribute<phrase diff="del" at="K"> and during evaluation
               of the <elcode>xsl:merge</elcode> instruction</phrase>. If <phrase>no
                  <elcode>xsl:for-each-group</elcode> instruction is being evaluated, the current
               grouping key will be <termref def="dt-absent"/>, which means that any reference to it
               causes a dynamic error. The current grouping key is also set to <termref
                  def="dt-absent"/> during the evaluation of an <elcode>xsl:for-each-group</elcode>
               instruction with a <code>group-starting-with</code> or <code>group-ending-with</code>
               attribute</phrase>.</p>

         <p diff="add" at="R-bug24150">The effect of <termref def="dt-invocation-construct"
               >invocation constructs</termref> on the <termref def="dt-current-grouping-key"/> is
            as follows:</p>

         <ulist diff="add" at="R-bug24150">
            <item>
               <p>If the <termref def="dt-invocation-construct"/> is contained within a <termref
                     def="dt-declared-streamable"/>
                  <termref def="dt-construct"/> (for example, if it is within an
                     <elcode>xsl:source-document</elcode> instruction with the attribute <code>streamable="yes"</code>, 
                  or within a streamable template), then the
                  invocation construct sets the current grouping key to <termref def="dt-absent"/>.
                  In this situation the scope of the current group is effectively static; it can
                  only be referenced within the body of the <elcode>xsl:for-each-group</elcode>
                  instruction to which it applies.</p>
            </item>

            <item>
               <p>If the <termref def="dt-invocation-construct"/> is a (static or dynamic) function
                  call, then the invocation construct sets the current grouping key to <termref
                     def="dt-absent"/>.</p>
            </item>

            <item>
               <p>Otherwise the <termref def="dt-invocation-construct"/> leaves the current grouping
                  key unchanged. In this situation the scope of the current group is effectively
                  dynamic: it can be referenced within called templates and attribute sets.</p>
            </item>
         </ulist>

         
         <p diff="chg" at="R-bug24150">The current grouping key is initially <termref def="dt-absent"/>
            during the evaluation of global variables and stylesheet parameters, during the
            evaluation of the <code>use</code> attribute or contained sequence constructor of <elcode>xsl:key</elcode>,
            and during the evaluation of the <code>initial-value</code> attribute of <elcode>xsl:accumulator</elcode>
            and the <code>select</code> attribute of contained sequence constructor of <elcode>xsl:accumulator-rule</elcode>.</p>


         <p>While an <elcode>xsl:for-each-group</elcode> instruction with a <code>group-by</code> or
               <code>group-adjacent</code> attribute is being evaluated, the <termref
               def="dt-current-grouping-key">current grouping key</termref> will be a single atomic
            value <phrase diff="add" at="G">if <code>composite="no"</code> is specified (explicitly
               or implicitly), or a sequence of atomic values if <code>composite="yes"</code> is
               specified.</phrase>
         </p>

         <p diff="del" at="K">While the <elcode>xsl:merge-action</elcode> part of an
               <elcode>xsl:merge</elcode> instruction is being evaluated, the current grouping key
            will be a sequence of atomic values, one for each component of the grouping key, as
            defined by the <elcode>xsl:merge-key</elcode> elements.</p>

         <p>At other times, the current grouping key will be <termref def="dt-absent"
               >absent</termref>.</p>



         <p><phrase diff="chg" at="D">The <termref def="dt-grouping-key">grouping keys</termref> of
               all items in a group are not necessarily identical. For example, one might be an
                  <code>xs:float</code> while another is a numerically equal
               <code>xs:decimal</code></phrase>. The <function>current-grouping-key</function>
            function <phrase diff="chg" at="F">returns</phrase> the grouping key of the <termref
               def="dt-initial-item">initial item</termref> in the group, after atomization and
            casting of <code>xs:untypedAtomic</code> values to <code>xs:string</code>.</p>

         <p>The function takes no arguments.</p>


      </fos:rules>
      <fos:errors>
         <p>
            <error spec="XT" type="static" class="SE" code="1070">
               <p>It is a <termref def="dt-static-error">static error</termref> if the
                     <function>current-grouping-key</function> function is used within a <termref
                     def="dt-pattern">pattern</termref>.</p>
            </error>
         </p>
         <p diff="add" at="K">
            <error spec="XT" type="dynamic" class="DE" code="1071">
               <p>It is a <termref def="dt-dynamic-error">dynamic error</termref> if the
                     <function>current-grouping-key</function> function is used when the current
                  grouping key is <termref def="dt-absent">absent</termref>, <phrase diff="add"
                     at="N">or when it is invoked in the course of evaluating a pattern.</phrase>
                  The error <rfc2119>may</rfc2119> be reported statically if it can be detected
                  statically.</p>
            </error>
         </p>
      </fos:errors>
      <fos:notes>
         <p diff="chg" at="R-bug24621">Like other XSLT extensions to the dynamic evaluation context,
            the <termref def="dt-current-grouping-key"/> is not retained as part of the closure of a
            function value. This means that the expression <code>current-grouping-key#0</code> is
            valid and returns a function value, but any invocation of this function will fail with a
            dynamic error <errorref spec="XT" class="DE" code="1071"/>. </p>
      </fos:notes>
   </fos:function>

   <fos:function name="current-merge-group">
      <fos:signatures>
         <fos:proto name="current-merge-group" return-type="item()*"/>
         <fos:proto name="current-merge-group" return-type="item()*">
            <fos:arg name="source" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
         <fos:property>special-streaming-rules</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the group of items currently being processed by an <elcode>xsl:merge</elcode>
            instruction.</p>
      </fos:summary>
      <fos:rules>
         <p diff="chg" at="T-bug29697">The <termref def="dt-current-merge-group"/> is bound during evaluation of the
               <elcode>xsl:merge-action</elcode> child of an <elcode>xsl:merge</elcode> instruction. 
            If no <elcode>xsl:merge-action</elcode> is being
            evaluated, then the current merge group is <termref def="dt-absent"/>, in which case the
            function raises a dynamic error (see below).</p>

         <p>The <termref def="dt-current-merge-group"/> (if not absent) is a <termref def="dt-map"
            />. It contains the set of items, from all merge inputs, that share a common value for
            the merge key. This is structured as a map so that the items from each merge source can
            be identified. The key in the map is the value of the <code>name</code> attribute of the
            corresponding <elcode>xsl:merge-source</elcode> element (or an invented name, in its
            absence), and the associated value is the set of items contributed by that merge
            group.</p>

         <p>The map itself is not made visible, but this function returns values derived from the
            map. Specifically, if the map is denoted by <var>$G</var>:</p>

         <ulist>
            <item>
               <p>The single-argument form of this function returns the value of the expression
                     <code>if (map:contains($source)) then $G($source) else error()</code>.
                  Informally, if there is an <elcode>xsl:merge-source</elcode> element whose
                     <code>name</code> attribute matches <code>$source</code>, the function returns
                  the items in the current merge group that are contributed by this merge source;
                  otherwise it raises a dynamic error (see below).</p>
            </item>
            <item>
               <p>The zero-argument form of the function returns the value of the expression
                     <code>sort(map:keys($G))!$G(.)</code>, where the <code>sort()</code> function
                  sorts the names of <elcode>xsl:merge-source</elcode> elements into the document
                  order of the <elcode>xsl:merge-source</elcode> elements in the stylesheet.
                  Informally, it returns all the items in the current merge group regardless of
                  which merge source they derive from.</p>
            </item>
         </ulist>

         <p>Within the <termref def="dt-current-merge-group"/>, the ordering of items from the input
            sequences is as follows, in major-to-minor order:</p>

         <ulist>
            <item>
               <p>Items are first ordered by the <elcode>xsl:merge-source</elcode> element that
                  defined the input sequence from which the item was taken; items from
                     <elcode>xsl:merge-source</elcode>
                  <var>A</var> precede items from <elcode>xsl:merge-source</elcode>
                  <var>B</var> if <var>A</var> precedes <var>B</var> in document order within the
                  stylesheet.</p>
            </item>
            <item>
               <p>Items from different input sequences selected by the same
                     <elcode>xsl:merge-source</elcode> element are then ordered based on the order
                  of the anchor items in the sequence selected by evaluating the <code>select</code>
                  attribute of the <elcode>xsl:merge-source</elcode> element.</p>
            </item>
            <item>
               <p>Finally, duplicate items from the same input sequence retain their order from the
                  input sequence.</p>
            </item>
         </ulist>

         <p diff="add" at="L">Duplicates are not eliminated: for example, if the same node is
            selected in more than one input sequence, it may appear twice in the current 
            <phrase diff="chg" at="R-bug26680">merge</phrase> group.</p>

         



      </fos:rules>
      <fos:errors>
         <p>
            <error spec="XT" type="static" class="SE" code="3470">
               <p>It is a <termref def="dt-static-error">static error</termref> if the
                     <function>current-merge-group</function> function is used within a <termref
                     def="dt-pattern">pattern</termref>.</p>
            </error>
         </p>
         <p>
            <error spec="XT" type="dynamic" class="DE" code="3480">
               <p>It is a <termref def="dt-dynamic-error">dynamic error</termref> if the
                     <function>current-merge-group</function> function is used when the current
                  merge group is <termref def="dt-absent">absent</termref>. The error
                     <rfc2119>may</rfc2119> be reported statically if it can be detected
                  statically.</p>
            </error>
         </p>
         <p>
            <error spec="XT" type="dynamic" class="DE" code="3490">
               <p>It is a <termref def="dt-dynamic-error">dynamic error</termref> if the
                     <code>$source</code> argument of the <function>current-merge-group</function>
                  function does not match the <code>name</code> attribute of any
                     <elcode>xsl:merge-source</elcode> element for the current merge operation. The
                  error <rfc2119>may</rfc2119> be reported statically if it can be detected
                  statically.</p>
            </error>
         </p>
      </fos:errors>
      <fos:notes>
         <p>Because the <termref def="dt-current-merge-group"/> is cleared by function calls and
            template calls, the <function>current-merge-group</function> function only has useful
            effect when the call appears as a descendant of an <elcode>xsl:merge-action</elcode>
            element.</p>
         <p>If an <elcode>xsl:merge-source</elcode> element has no <code>name</code> attribute, then
            it is not possible to discover the items in the current merge group that derive
            specifically from that source, but these items will still be present in the current
            merge group, and will be included in the result when the function is called with no
            arguments.</p>
         <p>Like other XSLT extensions to the dynamic evaluation context, the <termref
               def="dt-current-merge-group"/> is not retained as part of the closure of a function
            value. This means that the expression <code>current-merge-group#0</code> is valid and
            returns a function value, but any invocation of this function will fail with a dynamic
            error <errorref spec="XT" class="DE" code="3480"/>. </p>

      </fos:notes>
   </fos:function>

   <fos:function name="current-merge-key">
      <fos:signatures>
         <fos:proto name="current-merge-key" return-type="xs:anyAtomicType*"/>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
         <fos:property>special-streaming-rules</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the <phrase diff="chg" at="R-bug26680">merge</phrase> key of the 
            <phrase diff="add" at="R-bug26680">merge</phrase> group currently being processed using the
               <elcode>xsl:merge</elcode> instruction.</p>
      </fos:summary>
      <fos:rules>
         <p>The evaluation context for XPath <termref def="dt-expression">expressions</termref>
            includes a component called the <termref def="dt-current-merge-key"/>, which is a
            sequence of atomic values. The current merge key is the <termref
               def="dt-composite-merge-key-value">composite merge key value</termref> shared in common by all
            the items within the <termref def="dt-current-merge-group">current merge
            group</termref>. </p>

         <p>The function <function>current-merge-key</function> returns the <termref
               def="dt-current-merge-key">current merge key</termref>.</p>


      
         <p diff="chg" at="T-bug29697">While the <elcode>xsl:merge-action</elcode> child of an 
            <elcode>xsl:merge</elcode> instruction is being evaluated, the <phrase diff="chg" at="R-bug26680"><termref
               def="dt-current-merge-key"/></phrase> will be a single atomic
            value if there is a single merge key, or a sequence of atomic values if there are
            multiple merge keys.</p>



         <p>At other times, the current merge key will be <termref def="dt-absent"
            >absent</termref>.</p>

         
         <p><phrase diff="chg" at="D">The <phrase diff="chg" at="R-bug26680"><termref def="dt-composite-merge-key-value">merge keys</termref></phrase> of
               all items in a group are not necessarily identical. For example, one might be an
                  <code>xs:float</code> while another is a numerically equal
            <code>xs:decimal</code></phrase>. The <phrase diff="chg" at="R-bug26680"><function>current-merge-key</function></phrase>
            function <phrase diff="chg" at="F">returns</phrase> the <phrase diff="chg" at="R-bug26680">merge</phrase> key of the 
            first item in the group, after atomization and
            casting of <code>xs:untypedAtomic</code> values to <code>xs:string</code>.</p>




      </fos:rules>
      <fos:errors>
         <p>
            <error spec="XT" type="static" class="SE" code="3500">
               <p>It is a <termref def="dt-static-error">static error</termref> if the
                     <function>current-merge-key</function> function is used within a <termref
                     def="dt-pattern">pattern</termref>.</p>
            </error>
         </p>
         <p diff="add" at="K">
            <error spec="XT" type="dynamic" class="DE" code="3510">
               <p>It is a <termref def="dt-dynamic-error">dynamic error</termref> if the
                     <function>current-merge-key</function> function is used when the current
                  <phrase diff="chg" at="R-bug26680">merge</phrase> key is <termref def="dt-absent">absent</termref>, or when it is invoked
                  in the course of evaluating a pattern. The error <rfc2119>may</rfc2119> be
                  reported statically if it can be detected statically.</p>
            </error>
         </p>
      </fos:errors>
      <fos:notes>
         <p>Like other XSLT extensions to the dynamic evaluation context, the <termref
               def="dt-current-merge-key"/> is not retained as part of the closure of a function
            value. This means that the expression <phrase diff="chg" at="R-bug26680"><code>current-merge-key#0</code></phrase> is valid and
            returns a function value, but any invocation of this function will fail with a dynamic
            error <errorref spec="XT" class="DE" code="3510"/>. </p>
      </fos:notes>
   </fos:function>
   
   <fos:function name="current-output-uri">
      <fos:signatures>
         <fos:proto name="current-output-uri" return-type="xs:anyURI?"/>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>focus-independent</fos:property>
         <fos:property>context-dependent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the value of the <termref def="dt-current-output-uri"/>.</p></fos:summary>
      <fos:rules>
         <p>On initial invocation of a stylesheet component, the current output uri is set to the
         <termref def="dt-base-output-uri"/>.</p>
         <p>During execution of an <elcode>xsl:result-document</elcode> instruction with an <code>href</code>
         attribute, the current output URI changes to the absolute URI obtained by resolving the <termref def="dt-effective-value"/>
         of the <code>href</code> attribute against the base output URI.</p>
         
         <p diff="chg" at="R-bug24551">The current output URI is cleared (set to <termref def="dt-absent"/>) while evaluating stylesheet functions, 
            dynamic function calls, evaluation of global variables, stylesheet parameters, and patterns. 
            If the function is called when the current output URI is absent, the function returns the empty sequence.
         </p>
         <p diff="del" at="R-bug24551">When the <termref def="dt-output-state"/> is <termref def="dt-temporary-output-state"/>, for example while evaluating
         variables and functions, the current output URI is <termref def="dt-absent"/>, in which case the function returns the empty sequence.</p>
         <p>The current output URI may also be <termref def="dt-absent"/> in the event that a stylesheet is invoked without supplying a
         <termref def="dt-base-output-uri"/>.</p>
      </fos:rules>
      <fos:notes>
         <p>The current output URI is not cleared when evaluating a local variable, even though <elcode>xsl:result-document</elcode>
            cannot be used while evaluating a local variable. 
            The reason for this is to allow the value of <code>current-output-uri</code> to be set as the value of a 
            tunnel parameter, so that the original
            base output URI is accessible even when writing nested result documents.</p>
      </fos:notes>
   </fos:function>
   
   <fos:function name="regex-group">
      <fos:signatures>
         <fos:proto name="regex-group" return-type="xs:string">
            <fos:arg name="group-number" type="xs:integer"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the string captured by a parenthesized subexpression of the regular expression
            used during evaluation of the <elcode>xsl:analyze-string</elcode> instruction.</p>
      </fos:summary>
      <fos:rules>
         <p>
            <termdef id="dt-current-captured-substrings" term="current captured substrings">While
               the <elcode>xsl:matching-substring</elcode> instruction is active, a set of
                  <term>current captured substrings</term> is available, corresponding to the
               parenthesized subexpressions of the regular expression.</termdef> These captured
            substrings are accessible using the function <function>regex-group</function>. This
            function takes an integer argument to identify the group, and returns a string
            representing the captured substring.</p>
         <p>The <var>N</var>th captured substring (where <var>N</var> &gt; 0) is the string matched
            by the subexpression contained by the <var>N</var>th left parenthesis in the regex,
               <phrase diff="add" at="C">excluding any non-capturing groups, which are written as
                  <code>(?:xxx)</code></phrase>. The zeroth captured substring is the string that
            matches the entire regex. This means that the value of <code>regex-group(0)</code> is
            initially the same as the value of <code>.</code> (dot).</p>
         <p>The function returns the zero-length string if there is no captured substring with the
            relevant number. This can occur for a number of reasons:</p>
         <olist>
            <item>
               <p>The number is negative.</p>
            </item>
            <item>
               <p>The regular expression does not contain a parenthesized subexpression with the
                  given number.</p>
            </item>
            <item>
               <p>The parenthesized subexpression exists, and did not match any part of the input
                  string.</p>
            </item>
            <item>
               <p>The parenthesized subexpression exists, and matched a zero-length substring of
                  the input string.</p>
            </item>
         </olist>
         <p>The set of captured substrings is a context variable with dynamic scope. It is initially
            an empty sequence. During the evaluation of an <elcode>xsl:matching-substring</elcode>
            instruction it is set to the sequence of matched substrings for that regex match. During
            the evaluation of an <elcode>xsl:non-matching-substring</elcode> instruction or a
               <termref def="dt-pattern">pattern</termref> or a <termref
               def="dt-stylesheet-function">stylesheet function</termref> it is set to an empty
            sequence. On completion of an instruction that changes the value, the variable reverts
            to its previous value.</p>
         <p>The value of the <termref def="dt-current-captured-substrings">current captured
               substrings</termref> is unaffected through calls of
               <elcode>xsl:apply-templates</elcode>, <elcode>xsl:call-template</elcode>,
               <elcode>xsl:apply-imports</elcode> or <elcode>xsl:next-match</elcode>, or by
            expansion of named <termref def="dt-attribute-set">attribute sets</termref>.</p>

      </fos:rules>
   </fos:function>

   <fos:function name="copy-of">
      <fos:signatures>
         <fos:proto name="copy-of" return-type="item()"/>
         <fos:proto name="copy-of" return-type="item()*">
            <fos:arg name="input" type="item()*" default="." usage="absorption"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="0">
         <fos:property>nondeterministic</fos:property>
         <fos:property>focus-dependent</fos:property>
         <fos:property>context-independent</fos:property>
      </fos:properties>
      <fos:properties arity="1">
         <fos:property>nondeterministic</fos:property>
         <fos:property>focus-independent</fos:property>
         <fos:property>context-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns a deep copy of the <phrase diff="chg" at="S-bug29141">sequence</phrase> supplied as the <code>$input</code> argument, or of the
            context <phrase diff="chg" at="S-bug29141">item</phrase> if the argument is absent.</p>
      </fos:summary>
      <fos:rules>
         
         <p>The zero-argument form of this function is defined so that <code>copy-of()</code>
         returns the value of <code>internal:copy-item(.)</code>, where <code>internal:copy-item</code> (which
            exists only for the purpose of this exposition) is defined below. Informally, <code>copy-of()</code>
         copies the context item.</p>

         <p>The single argument form of this function is defined in terms of the
         <code>internal:copy-item</code> as follows: <code>copy-of($input)</code> is equivalent
            to <code>$input ! internal:copy-item(.)</code>. Informally, <code>copy-of($input)</code> copies each item in the
         input sequence in turn.</p>
            
            <p>The <code>internal:copy-item</code> function is defined as follows:</p>
         <eg><![CDATA[
<xsl:function name="internal:copy-item" as="item()" 
              new-each-time="maybe">
  <xsl:param name="input" as="item()"/>
  <xsl:copy-of select="$input" 
               copy-namespaces="yes"
               copy-accumulators="yes"
               validation="preserve"/>
</xsl:function>]]></eg>

         <p>The streamability analysis, however, is different: see <specref
               ref="classifying-built-in-functions"/>.</p>

         <p>The use of <code>new-each-time="maybe"</code> in the above definition means that 
            if the <code>internal:copy-item</code> function is called more than once with the same node as argument 
            (whether or not these calls are part of the same call on <code>copy-of</code>), then it is <termref
               def="dt-implementation-dependent">implementation-dependent</termref> whether each
            call returns the same node, or whether multiple calls return different nodes.
           Returning the original node, however, is not allowed, except as an optimization when the processor
         can determine that this is equivalent.</p>
         
         <note><p>One case where such optimization might be possible is when the copy is immediately atomized.</p></note>
            
      </fos:rules>
      <fos:notes>
         <p>The <function>copy-of</function> function is available for use (and is primarily
            intended for use) when a source document is processed using streaming. It can also be
            used when not streaming. The effect, 
            <phrase diff="add" at="S-bug29141">when applied to element and document nodes,</phrase>
            is to take a copy of the subtree rooted at the
            current node, and to make this available as a normal tree: one that can be processed without
            any of the restrictions that apply while streaming, for example only being able to
            process children once. The copy, of course, does not include siblings or ancestors of
            the context node, so any attempt to navigate to siblings or ancestors will result in an
            empty sequence being returned.</p>
         <p diff="add" at="29141">All nodes in the result sequence will be parentless.</p>
         <p diff="add" at="29141">If atomic values or functions (including maps and arrays) are present in the input sequence,
         they will be included unchanged at the corresponding position of the result sequence.</p>
         <p><phrase diff="add" at="S-bug28130">Accumulator values are taken from the copied
            document as described in <specref ref="copying-accumulators"/>.</phrase></p>
      </fos:notes>

      <fos:examples>
         <fos:example>
            <p>Using <code>copy-of()</code> while streaming:</p>
            <p>This example copies from the source document all employees who work in marketing and
               are based in Dubai. Because there are two accesses using the child axis, it is not
               possible to do this without buffering each employee in memory, which can be achieved
               using the <function>copy-of</function> function.</p>
            <eg xml:space="preserve"><![CDATA[<xsl:source-document streamable="yes" href="employees.xml">
  <xsl:sequence select="copy-of(employees/employee)
                          [department='Marketing' and location='Dubai']"/>
</xsl:source-document>]]></eg>
         </fos:example>
      </fos:examples>

   </fos:function>

   <fos:function name="snapshot">
      <fos:signatures>
         <fos:proto name="snapshot" return-type="item()"/>
         <fos:proto name="snapshot" return-type="item()*">
            <fos:arg name="input" type="item()*" default="." usage="absorption"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="0">
         <fos:property>nondeterministic</fos:property>
         <fos:property>focus-dependent</fos:property>
         <fos:property>context-independent</fos:property>
      </fos:properties>
      <fos:properties arity="1">
         <fos:property>nondeterministic</fos:property>
         <fos:property>focus-independent</fos:property>
         <fos:property>context-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p diff="chg" at="S-bug29141">Returns a copy of a sequence, retaining copies of the ancestors and descendants of any node in the input sequence, together with their
            attributes and namespaces.</p>
      </fos:summary>
      <fos:rules>

         <p diff="chg" at="S-bug29141">The zero-argument form of this function is defined so that <code>snapshot()</code>
            returns the value of <code>internal:snaphot-item(.)</code>, where <code>internal:snapshot-item</code> (which
            exists only for the purpose of this exposition) is defined below. Informally, <code>snapshot()</code>
            takes a snapshot of the context item.</p>
         
         <p diff="chg" at="S-bug29141">The single argument form of this function is defined in terms of the
            <code>internal:snapshot-item</code> as follows: <code>snapshot($input)</code> is equivalent
            to <code>$input ! internal:snapshot-item(.)</code>. Informally, <code>snapshot($input)</code> takes a snapshot of each item in the
            input sequence in turn.</p>

         
         <p diff="chg" at="S-bug29141">The <code>internal:snapshot-item</code> function behaves as follows:</p>
         
         <ulist>
            <item><p diff="add" at="S-bug29141">If the supplied item is an atomic value or a function item (including maps
            and arrays), then it returns that item unchanged.</p></item>
            <item><p>If the supplied item is a node, then it returns a <termref def="dt-snapshot"/>
            of that node, as defined below.</p></item>
         </ulist>
         
         <p>
            <termdef id="dt-snapshot" term="snapshot">A <term>snapshot</term> of a node <var>N</var>
               is a deep copy of <var>N</var>, as produced by the <elcode>xsl:copy-of</elcode>
               instruction with <code>copy-namespaces</code> set to <code>yes</code>,
               <phrase diff="add" at="S-bug28130"><code>copy-accumulators</code> set to <code>yes</code>,</phrase> and
                  <code>validation</code> set to <code>preserve</code>, with the additional property
               that for every ancestor of <var>N</var>, the copy also has a corresponding ancestor
               whose name, node-kind, and base URI are the same as the corresponding ancestor of
               <var>N</var>, and that has copies of the attributes, namespaces <phrase diff="add" at="S-bug28130">and accumulator values</phrase> of the
               corresponding ancestor of <var>N</var>. But the ancestor has a type annotation of
                  <code>xs:anyType</code>, has the properties <code>nilled</code>,
                  <code>is-id</code>, and <code>is-idref</code> set to false, and has no children
               other than the child that is a copy of <var>N</var> or one of its
               ancestors.</termdef>
         </p>
         
         
         <p>If the function is called more than once with the same argument, it is <termref
            def="dt-implementation-dependent">implementation-dependent</termref> whether each
            call returns the same node, or whether multiple calls return different nodes. That is,
            the result of the expression <code>snapshot($X) is snapshot($X)</code> is <termref
               def="dt-implementation-dependent">implementation-dependent</termref>.</p>
         
         <p><phrase diff="chg" at="S-bug28130">Except for the effect on accumulators</phrase>, the <code>internal:snapshot-item</code> function can be expressed
            as follows:</p>
         <eg xml:space="preserve"><![CDATA[
    <xsl:function name="internal:snapshot-item" as="item()">
        <xsl:param name="input" as="item()"/>
        <xsl:apply-templates select="$input" mode="internal:snapshot"/>
    </xsl:function>
    
    <!-- for atomic values and function items, return the item unchanged -->
    
    <xsl:template match="." mode="internal:snapshot" priority="1">
        <xsl:sequence select="."/>
    </xsl:template>
    
    <!-- for a document node, or any other root node, return a deep copy -->
    
    <xsl:template match="root()" mode="internal:snapshot" priority="5">
        <xsl:copy-of select="."/>
    </xsl:template>
    
    <!-- for an element, comment, text node, or processing instruction: -->
    
    <xsl:template match="node()" mode="internal:snapshot" 
                                 as="node()" priority="3">
        <xsl:sequence select="internal:graft-to-parent(
                                ., .., function($n){$n/node()})"/>
    </xsl:template>
    
    <!-- for an attribute: -->
    
    <xsl:template match="@*" mode="internal:snapshot" 
                             as="attribute()" priority="3">
        <xsl:variable name="name" select="node-name(.)"/>
        <xsl:sequence select="internal:graft-to-parent(., .., 
                                function($n){$n/@*[node-name(.) = $name]})"/>
    </xsl:template>
    
    <!-- for a namespace node: -->
    
    <xsl:template match="namespace-node()" mode="internal:snapshot" 
                  as="namespace-node()" priority="3">
        <xsl:variable name="name" select="local-name(.)"/>
        <xsl:sequence select="internal:graft-to-parent(., .., 
                  function($n){$n/namespace-node()[local-name(.) = $name]})"/>
    </xsl:template>
    
    <!-- make a copy C of a supplied node N, grafting it to a shallow copy of 
         C's original parent, and returning the copy C -->
    
    <xsl:function name="internal:graft-to-parent" as="node()">
        <xsl:param name="n" as="node()"/>
        <xsl:param name="original-parent" as="node()?"/>
        <xsl:param name="down-function" as="function(node()) as node()"/>
        <xsl:choose>
            <xsl:when test="exists($original-parent)">
                <xsl:variable name="p" as="node()">
                    <xsl:copy select="$original-parent">
                        <xsl:copy-of select="@*"/>
                        <xsl:copy-of select="$n"/>
                    </xsl:copy>
                </xsl:variable>
                <xsl:variable name="copied-parent" 
                     select="internal:graft-to-parent(
                        $p, $original-parent/.., function($n){$n/node()}))"/>
                <xsl:sequence select="$down-function($copied-parent)"/>              
            </xsl:when>
            <xsl:otherwise>
                <xsl:sequence select="$n"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>
    
]]></eg>
      </fos:rules>
      <fos:notes>
         <p>The <function>snapshot</function> function is available for use (and is primarily
            intended for use) when a source document is processed using streaming. It can also be
            used when not streaming. The effect is to take a copy of the subtree rooted at the
            current node, along with copies of the ancestors and their attributes, and to make this
            available as a normal tree, that can be processed without any of the restrictions that
            apply while streaming, for example only being able to process children once. The copy,
            of course, does not include siblings of the context node or of its ancestors, so any
            attempt to navigate to these siblings will result in an empty sequence being
            returned.</p>
         <p>For parentless nodes, the effect of <code>snapshot($x)</code> is identical to the effect
         of <code>copy-of($x)</code>.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <p>Using <code>snapshot()</code> while streaming:</p>
            <p>This example copies from the source document all employees who work in marketing and
               are based in Dubai. It assumes that employees are grouped by location. Because there
               are two accesses using the child axis (referencing <code>department</code> and
                  <code>salary</code>), it is not possible to do this without buffering each
               employee in memory. The <function>snapshot</function> function is used in preference
               to the simpler <function>copy-of</function> so that access to attributes of the
               parent <code>location</code> element remains possible.</p>
            <eg xml:space="preserve"><![CDATA[<xsl:source-document streamable="yes" href="employees.xml">
  <xsl:for-each select="snapshot(locations/location[@name='Dubai']
                          /employee)[department='Marketing']">
    <employee>
      <location code="{../@code}"/>
      <salary value="{salary}"/>
    </employee>
  </xsl:for-each>
</xsl:source-document>]]></eg>
         </fos:example>
      </fos:examples>
   </fos:function>






   <fos:function name="document">
      <fos:signatures>
         <fos:proto name="document" return-type="node()*">
            <fos:arg name="uri-sequence" type="item()*" usage="absorption"/>
         </fos:proto>
         <fos:proto name="document" return-type="node()*">
            <fos:arg name="uri-sequence" type="item()*" usage="absorption"/>
            <fos:arg name="base-node" type="node()" usage="inspection"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="1">
         <fos:property>deterministic</fos:property>
         <fos:property>focus-independent</fos:property>
         <fos:property dependency="static-base-uri">context-dependent</fos:property>
      </fos:properties>
      <fos:properties arity="2">
         <fos:property>deterministic</fos:property>
         <fos:property>focus-independent</fos:property>
         <fos:property>context-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Provides access to XML documents identified by a URI.</p>
      </fos:summary>
      <fos:rules>
         <p>The <function>document</function> function allows access to XML documents identified by
            a URI.</p>
         <p>The first argument contains a sequence of URI references. The second argument, if
            present, is a node whose base URI is used to resolve any relative URI references
            contained in the first argument.</p>
         <p>A sequence of absolute URI references is obtained as follows.</p>
         <ulist>
            <item>
               <p>For an item in <code>$uri-sequence</code> that is an instance of
                     <code>xs:string</code>, <code>xs:anyURI</code>, or
                     <code>xs:untypedAtomic</code>, the value is cast to <code>xs:anyURI</code>. If
                  the resulting URI reference is an absolute URI reference then it is used <emph>as
                     is</emph>. If it is a relative URI reference, then it is resolved as follows:</p>
               <olist diff="chg" at="T-bug29461">
                  <item><p>If <code>$base-node</code> is supplied, then it is resolved against the base URI
                  of <code>$base-node</code>.</p></item>
                  <item><p>Otherwise it is resolved against the static base URI from the static context of the
                  expression containing the call to the <function>document</function> function. In cases where the source
                  code of the stylesheet is available at execution time, this will typically be the location of the
                  relevant stylesheet module.</p></item>
               </olist>
     
            </item>
            <item>
               <p>For an item in <code>$uri-sequence</code> that is a node, the node is <termref
                     def="dt-atomization">atomized</termref>. The result <rfc2119>must</rfc2119> be
                  a sequence whose items are all instances of <code>xs:string</code>,
                     <code>xs:anyURI</code>, or <code>xs:untypedAtomic</code>. Each of these values
                  is cast to <code>xs:anyURI</code>, and if the resulting URI reference is an
                  absolute URI reference then it is used <emph>as is</emph>. If it is a relative URI
                  reference, then it is resolved against the base URI of <code>$base-node</code> if
                  supplied, or against the base URI of the node that contained it otherwise.</p>
            </item>
            <item>
               <p diff="chg" at="T-bug29461">A relative URI is resolved against a base URI using the rules of the <xfunction>resolve-uri</xfunction>
                  function. A dynamic error occurs (see below) if no base URI is available.</p>
               
            </item>
            <item diff="add" at="R-bug7353">
               <p> If <code>$uri-sequence</code> (after atomizing any nodes) contains an 
                  <phrase diff="chg" at="S-bug28153">item other than an atomic value of type</phrase> <code>xs:string</code>, <code>xs:anyURI</code>, or
                     <code>xs:untypedAtomic</code> then a type error is raised <xerrorref spec="XP30"
                     class="TY" code="0004"/>. </p>
            </item>
         </ulist>

         <p>Each of these absolute URI references is then processed as follows. Any fragment
            identifier that is present in the URI reference is removed, and the resulting absolute
            URI is cast to a string and then passed to the <xfunction>doc</xfunction> function
            defined in <bibref ref="xpath-functions-30"/>. This returns a document node. If an error
            occurs during evaluation of the <xfunction>doc</xfunction> function, the processor
               <rfc2119>may</rfc2119> either signal this error in the normal way, or
               <rfc2119>may</rfc2119> recover by ignoring the failure, in which case the failing URI
            will not contribute any nodes to the result of the <function>document</function>
            function.</p>
         <p>If the URI reference contained no fragment identifier, then this document node is
            included in the sequence of nodes returned by the <function>document</function>
            function.</p>
         <p>If the URI reference contained a fragment identifier, then the fragment identifier is
            interpreted according to the rules for the media type of the resource representation
            identified by the URI, and is used to select zero or more nodes that are
            descendant-or-self nodes of the returned document node. As described in <specref
               ref="initiating"/>, the media type is available as part of the evaluation context for
            a transformation.</p>


         <p>The sequence of nodes returned by the function is in document order, with no duplicates.
            This order has no necessary relationship to the order in which URIs were supplied in the
               <code>$uri-sequence</code> argument.</p>

      </fos:rules>
      <fos:errors>
         <p>
            <error spec="XT" type="dynamic" class="DE" code="1160">
               <p>When a URI reference <error.extra>supplied to the <function>document</function>
                     function</error.extra> contains a fragment identifier, it is a <termref
                     def="dt-dynamic-error"/> if the media type is not one that is recognized by the
                  processor, or if the fragment identifier does not conform to the rules for
                  fragment identifiers for that media type, or if the fragment identifier selects
                  something other than a sequence of nodes (for example, if it selects a range of
                  characters within a text node). </p>
            </error>
         </p>
         <p diff="add" at="Q">A processor <rfc2119>may</rfc2119> provide an option which, if
            selected, causes the processor instead of signaling this error, to ignore the fragment
            identifier and return the document node.</p>
         <p>The set of media types recognized by a processor is <termref
               def="dt-implementation-defined">implementation-defined</termref>.</p>
         <imp-def-feature>The set of media types recognized by the processor, for the purpose of
            interpreting fragment identifiers in URI references passed to the
               <function>document</function> function, is implementation-defined.</imp-def-feature>
         <p diff="add" at="G">
            <!-- bug 10109 -->
            <error spec="XT" type="dynamic" class="DE" code="1162">
               <p>When a URI reference <error.extra>supplied to the <function>document</function>
                     function</error.extra> is a relative reference, it is a <termref
                     def="dt-dynamic-error">dynamic error</termref> if no base URI is available to
                  resolve the relative reference. This can arise for example when the URI is
                  contained in a node that has no base URI (for example a parentless text node), or
                  when the second argument to the function is a node that has no base URI, or when
                  the base URI from the static context is undefined. </p>
            </error>
         </p>
      </fos:errors>
      <fos:notes>
         
         <p>One effect of these rules is that <phrase diff="add" at="T-bug29461">in an interpreted environment 
            where the source code of the stylesheet is available and its base URI is known</phrase>, then unless
            XML entities or <code>xml:base</code> are used, the expression <code>document("")</code> refers 
            to the document node of the containing stylesheet module (the definitive rules are in <bibref ref="RFC3986"/>). 
            The XML resource containing the stylesheet module is then processed exactly as if it were any 
            other XML document, for example there is no special recognition of <elcode>xsl:text</elcode> elements, 
            and no special treatment of comments and processing instructions.</p>

         <p>The XPath rules for function calling ensure that it is a type error if the supplied
            value of the second argument is anything other than a single node. If <termref
               def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref> is enabled, then a
            sequence of nodes may be supplied, and the first node in the sequence will be used.</p>

      </fos:notes>
   </fos:function>

   <fos:function name="unparsed-entity-uri">
      <fos:signatures>
         <fos:proto name="unparsed-entity-uri" return-type="xs:anyURI">
            <fos:arg name="entity-name" type="xs:string" usage="absorption"/>
         </fos:proto>
         <fos:proto name="unparsed-entity-uri" return-type="xs:anyURI"  diff="add" at="S-bug27839">
            <fos:arg name="entity-name" type="xs:string" usage="absorption"/>
            <fos:arg name="doc" type="node()" usage="inspection" default="/"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>focus-dependent</fos:property>
         <fos:property>context-dependent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the URI (system identifier) of an unparsed entity</p>
      </fos:summary>
      <fos:rules>
         <p diff="add" at="S-bug27839">Calling the single-argument form of this function has the same effect as calling the
         two-argument form with the context item as the second argument<phrase diff="del" at="S-bug29221">, except that a different error code is used
         in error situations</phrase>.</p>
         <p>The <phrase diff="add" at="S-bug27839">two-argument</phrase> <function>unparsed-entity-uri</function> 
            function returns the URI of the unparsed
            entity whose name is given by the value of the <code>$entity-name</code> argument, in
            the document containing <phrase diff="chg" at="S-bug27839">the node supplied as the 
               value of the <code>$doc</code> argument</phrase>. It
            returns the zero-length <code>xs:anyURI</code> if there is no such entity. This function
            maps to the <code>dm:unparsed-entity-system-id</code> accessor defined in <bibref
               ref="xpath-datamodel-30"/>.</p>

      </fos:rules>
      <fos:errors>
         <p diff="chg" at="S-bug29221">
            <error spec="XT" type="dynamic" class="DE" code="1370">
               <p>It is a <termref def="dt-dynamic-error"/> if <code>$node</code>,
                  or the context item if the second argument is omitted,
                  is a node in a tree whose root is not a document node.</p>
            </error>
         </p>  
            <p>The following errors may be raised when <code>$node</code> is omitted:</p>
            
            <ulist>
               <item><p>If the context item is absent, <termref def="dt-dynamic-error"/> 
                  <xerrorref spec="XP30" class="DY" code="0002"/>.</p></item>
               <item><p>If the context item is not a node, <termref def="dt-type-error"/> 
                  <xerrorref spec="XP30" class="TY" code="0004"/>.</p></item>
            </ulist>
            
         
 
      </fos:errors>
      <fos:notes>
         <p diff="add" at="S-bug27061">The XDM accessor <code>dm:unparsed-entity-system-id</code> is defined to return an absolute URI,
            obtained by resolving the system identifier as written against the base URI of the document. If no
            base URI is available for the document, the <function>unparsed-entity-uri</function> function
            <rfc2119>should</rfc2119> return the system identifier as written, without any attempt to make
            it absolute.</p>
         <p diff="add" at="S-bug27369">XML permits more than one unparsed entity declaration with the same name to appear,
         and says that the first declaration is the one that should be used. This rule <rfc2119>should</rfc2119> be 
         respected during construction of the data model; the data model instance should not contain more than one
         unparsed entity with the same name.</p>
      </fos:notes>
   </fos:function>

   <fos:function name="unparsed-entity-public-id">
      <fos:signatures>
         <fos:proto name="unparsed-entity-public-id" return-type="xs:string">
            <fos:arg name="entity-name" type="xs:string" usage="absorption"/>
         </fos:proto>
         <fos:proto name="unparsed-entity-public-id" return-type="xs:string"  diff="add" at="S-bug27839">
            <fos:arg name="entity-name" type="xs:string" usage="absorption"/>
            <fos:arg name="doc" type="node()" usage="inspection" default="/"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>focus-dependent</fos:property>
         <fos:property>context-dependent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the public identifier of an unparsed entity</p>
      </fos:summary>
      <fos:rules>
         <p diff="add" at="S-bug27839">Calling the single-argument form of this function has the same effect as calling the
            two-argument form with the context item as the second argument<phrase diff="del" at="S-bug29221">, except that a different error code is used
            in error situations</phrase>.</p>
         
         <p>The <phrase diff="add" at="S-bug27839">two-argument</phrase> <function>unparsed-entity-public-id</function> 
            function returns the public
            identifier of the unparsed entity whose name is given by the value of the
            <code>$entity-name</code> argument, in the document containing <phrase diff="chg" at="S-bug27839">the node supplied as the 
               value of the <code>$doc</code> argument</phrase>. It returns the zero-length string if
            there is no such entity, or if the entity has no public identifier. This function maps
            to the <code>dm:unparsed-entity-public-id</code> accessor defined in <bibref
               ref="xpath-datamodel-30"/>.</p>

      </fos:rules>
      <fos:errors>
         <p diff="chg" at="S-bug29221">
            <error spec="XT" type="dynamic" class="DE" code="1380">
               <p>It is a <termref def="dt-dynamic-error"/> if <code>$node</code>,
                  or the context item if the second argument is omitted,
                  is a node in a tree whose root is not a document node.</p>
            </error>
         </p>
           
            <p>The following errors may be raised when <code>$node</code> is omitted:</p>
            
            <ulist>
               <item><p>If the context item is absent, <termref def="dt-dynamic-error"/> 
                  <xerrorref spec="XP30" class="DY" code="0002"/>.</p></item>
               <item><p>If the context item is not a node, <termref def="dt-type-error"/> 
                  <xerrorref spec="XP30" class="TY" code="0004"/>.</p></item>
            </ulist>
            
         
      </fos:errors>
      <fos:notes>
         
         <p diff="add" at="S-bug27369">XML permits more than one unparsed entity declaration with the same name to appear,
            and says that the first declaration is the one that should be used. This rule <rfc2119>should</rfc2119> be 
            respected during construction of the data model; the data model instance should not contain more than one
            unparsed entity with the same name.</p>
      </fos:notes>
   </fos:function>


   <fos:function name="key">
      <fos:signatures>
         <fos:proto name="key" return-type="node()*">
            <fos:arg name="key-name" type="xs:string"/>
            <fos:arg name="key-value" type="xs:anyAtomicType*"/>
         </fos:proto>
         <fos:proto name="key" return-type="node()*">
            <fos:arg name="key-name" type="xs:string"/>
            <fos:arg name="key-value" type="xs:anyAtomicType*"/>
            <fos:arg name="top" type="node()" default="/" usage="navigation"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="2">
         <fos:property>deterministic</fos:property>
         <fos:property>focus-dependent</fos:property>
         <fos:property>context-dependent</fos:property>
      </fos:properties>
      <fos:properties arity="3">
         <fos:property>deterministic</fos:property>
         <fos:property>focus-independent</fos:property>
         <fos:property>context-dependent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the nodes that match a supplied key value.</p>
      </fos:summary>
      <fos:rules>
         <p>The <function>key</function> function does for keys what the <phrase diff="chg" at="D"
                  ><xfunction>element-with-id</xfunction></phrase> function does for IDs.</p>
         <p>The <code>$key-name</code> argument specifies the name of the <termref def="dt-key"
               >key</termref>. The value of the argument <rfc2119>must</rfc2119> be a <phrase
               diff="chg" at="Q">string containing an <termref def="dt-eqname"/>.</phrase> If it is
            a <termref def="dt-lexical-qname">lexical QName</termref>, then it is expanded as
            described in <specref ref="qname"/> (no prefix means no namespace).</p>

         <p>The <code>$key-value</code> argument to the <function>key</function> function is
            considered as a sequence. <phrase diff="add" at="G">The effect depends on the value of
               the <code>composite</code> attribute of the corresponding <code>xsl:key</code>
               declaration.</phrase></p>

         <ulist>
            <item>
               <p><phrase diff="add" at="G">If <code>composite</code> is <code>no</code> or
                     absent,</phrase> the set of requested key values is formed by atomizing the
                  supplied value of the argument, using the standard <termref
                     def="dt-function-conversion-rules">function conversion rules</termref>. Each of
                  the resulting atomic values is considered as a requested key value. The result of
                  the function is a sequence of nodes, in document order and with duplicates
                  removed, comprising those nodes in the selected subtree (see below) that are
                  matched by an <elcode>xsl:key</elcode> declaration whose name is the same as the
                  supplied key name, where the result of evaluating the <termref
                     def="dt-key-specifier">key specifier</termref> contains a value that is equal
                  to one of these requested key values, under the rules appropriate to the XPath
                     <code>eq</code> operator for the two values in question, using the
                     <code>collation</code> attributes of the <elcode>xsl:key</elcode> declaration
                  when comparing strings. No error is reported if two values are encountered that
                  are not comparable; they are regarded for the purposes of this function as being
                  not equal. </p>
               <p>If the second argument is an empty sequence, the result of the function will be an
                  empty sequence.</p>
            </item>
            <item>
               <p diff="add" at="G">If <code>composite</code> is <code>yes</code>, the requested key
                  value is the sequence formed by atomizing the supplied value of the argument,
                  using the standard <termref def="dt-function-conversion-rules">function conversion
                     rules</termref>. The result of the function is a sequence of nodes, in document
                  order and with duplicates removed, comprising those nodes in the selected subtree
                  (see below) that are matched by an <elcode>xsl:key</elcode> declaration whose name
                  is the same as the supplied key name, where the result of evaluating the <termref
                     def="dt-key-specifier">key specifier</termref> is deep-equal to the requested
                  key value, under the rules appropriate to the <xfunction>deep-equal</xfunction>
                  function applied to the two values in question, using the <code>collation</code>
                  attributes of the <elcode>xsl:key</elcode> declaration when comparing strings.
                  Note that the <xfunction>deep-equal</xfunction> function reports no error if two
                  values are encountered that are not comparable; they are regarded for the purposes
                  of this function as being not equal.</p>
               <p diff="add" at="G">If the second argument is an empty sequence, the result of the
                  function will be the set of nodes having an empty sequence as the value of the key
                  specifier.</p>
            </item>
         </ulist>


         <p>Different rules apply when <phrase diff="chg" at="D"><termref def="dt-xslt-10-behavior"
                  >XSLT 1.0 compatible behavior</termref> is enabled.</phrase></p>

         <p diff="chg" at="P-erratumE33">A key (that is, a set of <elcode>xsl:key</elcode>
            declarations sharing the same key name) is processed in backwards compatible mode if (a)
            at least one of the xsl:key elements in the definition of the key enables backwards
            compatible behavior, and (b) the effective value of the <code>composite</code> attribute
            is <code>no</code>.</p>

         <p diff="chg" at="P-erratumE33">When a key is processed in backwards compatible mode,
            then:</p>

         <ulist diff="chg" at="P-erratumE33">

            <item><p>The result of evaluating the key specifier in any <elcode>xsl:key</elcode>
               declaration having this key name is converted after atomization to a sequence of
               strings, by applying a cast to each item in the sequence.</p></item>

            <item><p>When the first argument to the <function>key</function> function specifies this key
               name, then the value of the second argument is converted after atomization to a
               sequence of strings, by applying a cast to each item in the sequence. The values are
               then compared as strings.</p></item>
         </ulist>


         <p>The third argument is used to identify the selected subtree. If the argument is present,
            the selected subtree is the set of nodes that have <var>$top</var> as an
            ancestor-or-self node. If the argument is omitted, the selected subtree is the document
            containing the context node. This means that the third argument effectively defaults to
               <code>/</code>.</p>

         <p>The result of the <function>key</function> function can be described more specifically
            as follows. The result is a sequence containing every node <var>$N</var> that satisfies
            the following conditions:</p>
         <ulist>
            <item>
               <p>
                  <code>$N/ancestor-or-self::node() intersect $top</code> is non-empty. (If the
                  third argument is omitted, <code>$top</code> defaults to <code>/</code>)</p>
            </item>
            <item>
               <p>
                  <var>$N</var> matches the pattern specified in the <code>match</code> attribute of
                  an <elcode>xsl:key</elcode> declaration whose <code>name</code> attribute matches
                  the name specified in the <code>$key-name</code> argument.</p>
            </item>
            <item>
               <p><phrase diff="add" at="G">When <code>composite="no"</code>, </phrase> and the
                     <termref def="dt-key-specifier">key specifier</termref> of that
                     <elcode>xsl:key</elcode> declaration is evaluated with a <termref
                     def="dt-singleton-focus">singleton focus</termref> based on <var>$N</var>, the
                     <termref def="dt-atomization">atomized</termref> value of the resulting
                  sequence includes a value that compares equal to at least one item in the atomized
                  value of the sequence supplied as <code>$key-value</code>, under the rules of the
                     <code>eq</code> operator with the collation selected as described above.</p>
               <p><phrase diff="add" at="G">When <code>composite="yes"</code>, </phrase> and the
                     <termref def="dt-key-specifier">key specifier</termref> of that
                     <elcode>xsl:key</elcode> declaration is evaluated with a <termref
                     def="dt-singleton-focus">singleton focus</termref> based on <var>$N</var>, the
                     <termref def="dt-atomization">atomized</termref> value of the resulting
                  sequence compares equal to the atomized value of the sequence supplied as
                     <code>$key-value</code>, under the rules of the
                     <xfunction>deep-equal</xfunction> function with the collation selected as
                  described above.</p>
            </item>
         </ulist>
         <p>The sequence returned by the <function>key</function> function will be in document
            order, with duplicates (that is, nodes having the same identity) removed. </p>
      </fos:rules>
      <fos:errors>
         <p>
            <error spec="XT" type="dynamic" class="DE" code="1260">
               <p>It is a <termref def="dt-dynamic-error"><phrase diff="del" at="N"
                        >non-recoverable</phrase> dynamic error</termref> if the value
                     <error.extra>of the first argument to the <function>key</function>
                     function</error.extra> is not a valid QName, or if there is no namespace
                  declaration in scope for the prefix of the QName, or if the name obtained by
                  expanding the QName is not the same as the expanded name of any
                     <elcode>xsl:key</elcode> declaration in the <phrase diff="chg" at="I"
                     >containing <termref def="dt-package">package</termref></phrase>. If the
                  processor is able to detect the error statically (for example, when the argument
                  is supplied as a string literal), then the processor <rfc2119>may</rfc2119>
                  optionally signal this as a <termref def="dt-static-error">static
                  error</termref>.</p>
            </error>
         </p>
         <p>
            <error spec="XT" type="dynamic" class="DE" code="1270">
               <p>It is a <phrase diff="chg" at="P"><termref def="dt-dynamic-error">dynamic
                        error</termref></phrase> to call the <function>key</function> function with
                  two arguments if there is no <termref def="dt-context-node">context
                  node</termref>, or if the root of the tree containing the context node is not a
                  document node; or to call the function with three arguments if the root of the
                  tree containing the node supplied in the third argument is not a document
                  node.</p>
            </error>
         </p>

      </fos:errors>
      <fos:notes>

         <p>Untyped atomic values are converted to strings, not to the type of the other operand.
            This means, for example, that if the expression in the <code>use</code> attribute
            returns a date, supplying an untyped atomic value in the call to the
               <function>key</function> function will return an empty sequence.</p>

      </fos:notes>
      <fos:examples>
         <fos:example>
            <example>
               <head>Using a Key to Follow Cross-References</head>
               <p>Given a declaration</p>
               <eg xml:space="preserve"><![CDATA[<xsl:key name="idkey" match="div" use="@id"/>]]></eg>
               <p>an expression <code>key("idkey",@ref)</code> will return the same nodes as
                     <code>id(@ref)</code>, assuming that the only ID attribute declared in the XML
                  source document is:</p>
               <eg xml:space="preserve"><![CDATA[<!ATTLIST div id ID #IMPLIED>]]></eg>
               <p>and that the <code>ref</code> attribute of the context node contains no
                  whitespace.</p>
            </example>
         </fos:example>
         <fos:example>
            <example>
               <head>Using a Key to Generate Hyperlinks</head>

               <p>Suppose a document describing a function library uses a <code>prototype</code>
                  element to define functions</p>
               <eg xml:space="preserve"><![CDATA[<prototype name="sqrt" return-type="xs:double">
  <arg type="xs:double"/>
</prototype>]]></eg>
               <p>and a <code>function</code> element to refer to function names</p>
               <eg xml:space="preserve"><![CDATA[<function>sqrt</function>]]></eg>
               <p>Then the stylesheet could generate hyperlinks between the references and
                  definitions as follows:</p>
               <eg xml:space="preserve"><![CDATA[<xsl:key name="func" match="prototype" use="@name"/>

<xsl:template match="function">
<b>
  <a href="#{generate-id(key('func',.))}">
    <xsl:apply-templates/>
  </a>
</b>
</xsl:template>

<xsl:template match="prototype">
  <p>
    <a name="{generate-id()}">
      <b>Function: </b>
      ...
    </a>
  </p>
  </xsl:template>]]></eg>
            </example>
         </fos:example>
         <fos:example>
            <p>When called with two arguments, the <function>key</function> function always returns
               nodes that are in the same document as the context node. To retrieve a node from any
               other document, it is necessary either to change the context node, or to supply a
               third argument.</p>
            <example>
               <head>Using Keys to Reference other Documents</head>
               <p>For example, suppose a document contains bibliographic references in the form
                     <code>&lt;bibref&gt;XSLT&lt;/bibref&gt;</code>, and there is a separate XML
                  document <code>bib.xml</code> containing a bibliographic database with entries in
                  the form:</p>
               <eg xml:space="preserve"><![CDATA[<entry name="XSLT">...</entry>]]></eg>
               <p>Then the stylesheet could use the following to transform the <code>bibref</code>
                  elements:</p>
               <eg xml:space="preserve"><![CDATA[<xsl:key name="bib" match="entry" use="@name"/>

<xsl:template match="bibref">
  <xsl:variable name="name" select="."/>
  <xsl:apply-templates select="document('bib.xml')/key('bib',$name)"/>
</xsl:template>]]></eg>
               <note>
                  <p>This relies on the ability in XPath 2.0 to have a function call on the
                     right-hand side of the <code>/</code> operator in a path expression.</p>
               </note>
               <p>The following code would also work:</p>
               <eg xml:space="preserve"><![CDATA[<xsl:key name="bib" match="entry" use="@name"/>

<xsl:template match="bibref">
  <xsl:apply-templates select="key('bib', ., document('bib.xml'))"/>
</xsl:template>]]></eg>
            </example>
         </fos:example>
         <fos:example>
            <example>
               <head>Using a Composite Key</head>
               <p>This example uses a composite key consisting of first name and last name to locate
                  employees in an employee file.</p>
               <p>The key can be defined like this:</p>
               <eg><![CDATA[
<xsl:key name="emp-name-key" 
         match="employee" 
         use="name/first, name/last" 
         composite="yes"/>                     
         ]]></eg>
               <p>A particular employee can then be located using the function call:</p>
               <eg>key('emp-name-key', ('Tim', 'Berners-Lee'), doc('employees.xml'))</eg>
            </example>
         </fos:example>

      </fos:examples>
   </fos:function>

   <fos:function name="system-property">
      <fos:signatures>
         <fos:proto name="system-property" return-type="xs:string">
            <fos:arg name="property-name" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>focus-independent</fos:property>
         <fos:property dependency="namespaces">context-dependent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the value of a system property</p>
      </fos:summary>
      <fos:rules>

         
         <p diff="chg" at="S-bug29113">The value of the <code>$property-name</code> argument 
            <rfc2119>must</rfc2119> be a string containing an <termref def="dt-eqname"
               >EQName</termref>. If it is a <termref def="dt-lexical-qname">lexical QName</termref>
            with a prefix, then it is expanded into an <termref def="dt-expanded-qname">expanded
               QName</termref> using the namespace declarations in the static context of the
            <termref def="dt-expression">expression</termref>. If there is no prefix, the name is
            taken as being in no namespace.</p>
            
 

         <p>The <function>system-property</function> function returns a string representing the
            value of the system property identified by the name. If there is no such system
            property, the zero-length string is returned.</p>
         <p>Implementations <rfc2119>must</rfc2119> provide the following system properties, which
            are all in the <termref def="dt-xslt-namespace">XSLT namespace</termref>:</p>
         <ulist>
            <item>
               <p>
                  <code>xsl:version</code>, a number giving the version of XSLT implemented by the
                     <termref def="dt-processor">processor</termref>; for implementations conforming
                  to the version of XSLT specified by this document, this is the string <phrase
                     diff="chg" at="A"><code>"3.0"</code></phrase>. The value will always be a
                  string in the lexical space of the decimal datatype defined in XML Schema (see
                     <bibref ref="xmlschema-2"/>). This allows the value to be converted to a number
                  for the purpose of magnitude comparisons.</p>
            </item>
            <item>
               <p>
                  <code>xsl:vendor</code>, a string identifying the implementer of the <termref
                     def="dt-processor">processor</termref>
               </p>
            </item>
            <item>
               <p>
                  <code>xsl:vendor-url</code>, a string containing a URL identifying the implementer
                  of the <termref def="dt-processor">processor</termref>; typically this is the host
                  page (home page) of the implementer's Web site.</p>
            </item>
            <item>
               <p>
                  <code>xsl:product-name</code>, a string containing the name of the implementation,
                  as defined by the implementer. This <rfc2119>should</rfc2119> normally remain
                  constant from one release of the product to the next. It <rfc2119>should</rfc2119>
                  also be constant across platforms in cases where the same source code is used to
                  produce compatible products for multiple execution platforms.</p>
            </item>
            <item>
               <p>
                  <code>xsl:product-version</code>, a string identifying the version of the
                  implementation, as defined by the implementer. This <rfc2119>should</rfc2119>
                  normally vary from one release of the product to the next, and at the discretion
                  of the implementer it <rfc2119>may</rfc2119> also vary across different execution
                  platforms.</p>
            </item>
            <item>
               <p>
                  <code>xsl:is-schema-aware</code>, returns the string <code>"yes"</code> in the
                  case of a processor that claims conformance as a <termref
                     def="dt-schema-aware-xslt-processor">schema-aware XSLT processor</termref>, or
                     <code>"no"</code> in the case of a <termref def="dt-basic-xslt-processor">basic
                     XSLT processor</termref>.</p>
            </item>
            <item>
               <p>
                  <code>xsl:supports-serialization</code>, returns the string <code>"yes"</code> in
                  the case of a processor that offers the <termref def="dt-serialization-feature"
                     >serialization feature</termref>, or <code>"no"</code> otherwise.</p>
            </item>
            <item>
               <p>
                  <code>xsl:supports-backwards-compatibility</code>, returns the string
                     <code>"yes"</code> in the case of a processor that offers the <phrase
                     diff="chg" at="E"><termref def="dt-1.0-compatibility-feature"/></phrase>, or
                     <code>"no"</code> otherwise.</p>
            </item>
            <item>
               <p diff="add" at="A">
                  <code>xsl:supports-namespace-axis</code>, returns the string <code>"yes"</code> in
                  the case of a processor that offers the XPath namespace axis even when not in
                  backwards compatible mode, or <code>"no"</code> otherwise. Note that a processor
                  that supports backwards compatible mode must support the namespace axis when in
                  that mode, so this property is not relevant to that case.</p>
            </item>
            <item>
               <p diff="add" at="A">
                  <code>xsl:supports-streaming</code>, returns the string <code>"yes"</code> in the
                  case of a processor that offers the streaming feature (see <specref
                     ref="streaming-feature"/>), or <code>"no"</code> otherwise.</p>

            </item>
            <item>
               <p diff="add" at="N">
                  <code>xsl:supports-dynamic-evaluation</code>, returns the string
                     <code>"yes"</code> in the case of a processor that offers the dynamic
                  evaluation feature (see <specref ref="dynamic-evaluation-feature"/>), or
                     <code>"no"</code> otherwise.</p>

            </item>
            <item>
               <p diff="add" at="S-bug29251">
                  <code>xsl:supports-higher-order-functions</code>, returns the string
                  <code>"yes"</code> in the case of a processor that offers the <termref def="dt-hof-feature"/>, or
                  <code>"no"</code> otherwise.</p>
               
            </item>
            <item>
               <p diff="add" at="S-bug24266">
                  <code>xsl:xpath-version</code>, a number giving the version of XPath implemented by the
                  <termref def="dt-processor">processor</termref>. The value will always be a
                  string in the lexical space of the decimal datatype defined in XML Schema (see
                  <bibref ref="xmlschema-2"/>). This allows the value to be converted to a number
                  for the purpose of magnitude comparisons. Typical values are <code>"3.0"</code> or <code>"3.1"</code>.
                  The value <code>"3.0"</code> indicates that the processor implements XPath 3.0 plus the extensions
                  defined in <specref ref="map"/> and <specref ref="json"/>.
               </p>
            </item>
            <item>
               <p diff="add" at="S-bug24266">
                  <code>xsl:xsd-version</code>, a number giving the version of XSD (XML Schema) implemented by the
                  <termref def="dt-processor">processor</termref>. The value will always be a
                  string in the lexical space of the decimal datatype defined in XML Schema (see
                  <bibref ref="xmlschema-2"/>). This allows the value to be converted to a number
                  for the purpose of magnitude comparisons. Typical values are <code>"1.0"</code> or <code>"1.1"</code>.
                  This property is relevant even when the processor is not schema-aware, since the built-in datatypes
                  for XSD 1.1 differ from those in XSD 1.0.
               </p>
            </item>
         </ulist>
         <p>Some of these properties relate to the conformance levels and features offered by the
               <termref def="dt-processor">processor</termref>: these options are described in
               <specref ref="conformance"/>.</p>
         <p>The actual values returned for the above properties are <termref
               def="dt-implementation-defined">implementation-defined</termref>.</p>
         <p>The set of system properties that are supported, in addition to those listed above, is
            also <termref def="dt-implementation-defined">implementation-defined</termref>.
            Implementations <rfc2119>must not</rfc2119> define additional system properties in the
            XSLT namespace.</p>
         <imp-def-feature>The values returned by the <function>system-property</function> function,
            and the names of the additional properties that are recognized, are
            implementation-defined.</imp-def-feature>

      </fos:rules>
      <fos:errors>
         <p>
            <error spec="XT" type="dynamic" class="DE" code="1390">
               <p>It is a <termref def="dt-dynamic-error"><phrase diff="del" at="N"
                        >non-recoverable</phrase> dynamic error</termref> if the value supplied as
                  the <code>$property-name</code> argument <error.extra>to the
                        <function>system-property</function> function</error.extra> is not a valid
                  QName, or if there is no namespace declaration in scope for the prefix of the
                  QName. If the processor is able to detect the error statically (for example, when
                  the argument is supplied as a string literal), then the processor
                     <rfc2119>may</rfc2119> optionally signal this as a <termref
                     def="dt-static-error">static error</termref>. </p>
            </error>
         </p>
      </fos:errors>
      <fos:notes>
         <p>An implementation must not return the value <code>
               <phrase diff="chg" at="A">3.0</phrase>
            </code> as the value of the <code>xsl:version</code> system property unless it is
            conformant to XSLT <phrase diff="chg" at="A">3.0</phrase>.</p>
         <p>It is recognized that vendors who are enhancing XSLT 1.0 <phrase diff="chg" at="A">or
               2.0</phrase> processors may wish to release interim implementations before all the
            mandatory features of this specification are implemented. Since such products are not
            conformant to XSLT 3.0, this specification cannot define their behavior. However,
            implementers of such products are encouraged to return a value for the
               <code>xsl:version</code> system property that is intermediate between 1.0 and 3.0,
            and to provide the <function>element-available</function> and
               <function>function-available</function> functions to allow users to test which
            features have been fully implemented.</p>
      </fos:notes>
   </fos:function>
   
   <fos:function name="available-system-properties">
      <fos:signatures>
         <fos:proto name="available-system-properties" return-type="xs:QName*"/>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns a list of system property names that are suitable for passing to
            the <function>system-property</function> function, as a sequence of QNames.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns a sequence of QNames, being the names of the system properties
            recognized by the processor, in some <termref def="dt-implementation-dependent"
               >implementation-dependent</termref> order.</p>
         <p diff="add" at="T-bug29988">The prefix part of a returned QName is <termref def="dt-implementation-dependent"/>.</p>
         
         <p>The function is <xtermref spec="FO30" ref="dt-deterministic"
            >deterministic</xtermref>: that is, the
            set of available system properties does not vary during the course of a transformation.</p>
      </fos:rules>
      <fos:notes>
         <p>The function returns a list of QNames, containing no duplicates.</p>
         <p>It is intended that the QNames in this list should be suitable for passing to
            <function>system-property</function>. <phrase diff="chg" at="T-bug29988">However, they must first be converted to
            the form expected by the <function>system-property</function> function, which is either
            a lexical QName or to an EQName in the form <code>Q{uri}local</code>. Because the prefix 
            of the returned QName is unpredictable, the <code>Q{uri}local</code> is likely
            to be more convenient. Conversion of an <code>xs:QName</code> value to an EQName in 
            <code>Q{uri}local</code> format can be achieved using the function:</phrase></p>
         
         <eg><![CDATA[
<xsl:function name="f:QName-to-brace-notation" as="xs:string">
  <xsl:param name="qname" as="xs:QName"/>
  <xsl:sequence select="'Q{' || namespace-uri-from-QName($qname) || '}' 
                             || local-name-from-QName($qname)"/>
</xsl:function>  
            ]]></eg>
         
      </fos:notes>
   </fos:function>


   <fos:function name="deep-equal">
      <fos:signatures>
         <fos:proto name="deep-equal" return-type="xs:boolean">
            <fos:arg name="parameter1" type="item()*" usage="absorption"/>
            <fos:arg name="parameter2" type="item()*" usage="absorption"/>
         </fos:proto>
         <fos:proto name="deep-equal" return-type="xs:boolean">
            <fos:arg name="parameter1" type="item()*" usage="absorption"/>
            <fos:arg name="parameter2" type="item()*" usage="absorption"/>
            <fos:arg name="collation" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="2">
         <fos:property>deterministic</fos:property>
         <fos:property dependency="collations implicit-timezone">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:properties arity="3">
         <fos:property>deterministic</fos:property>
         <fos:property dependency="collations static-base-uri implicit-timezone">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>

      <fos:summary>
         <p>This function assesses whether two sequences are deep-equal to each other. The function
            as described here extends the definition of the XPath 3.0
               <xfunction>deep-equal</xfunction> to explain how it should handle maps; it is
            intended to replace the existing <xfunction>deep-equal</xfunction> function at some
            stage in the future.</p>
      </fos:summary>
      <fos:rules>
         <p diff="add" at="I">The function delivers the same result as
               <xfunction>deep-equal</xfunction> except when (at some level of recursion) it is
            necessary to compare two function items. In the case of
               <xfunction>deep-equal</xfunction>, comparing two function items raises a dynamic
            error. In the case of this function, two function items that are both maps are compared
            as follows.</p>

         <p diff="add" at="I">If two items <code>$i1</code> and <code>$i2</code> to be compared are
            both <termref def="dt-map">maps</termref>, the result is <code>true</code> if and only
            if all the following conditions apply:</p>
         <olist diff="add" at="I">
            <item>
               <p>Both maps have the same number of entries.</p>
            </item>
            <item diff="del" at="P">
               <p>Both maps have the same collation.</p>
            </item>
            <item>
               <p>For every entry in the first map, there is an entry in the second map that:</p>
               <olist>
                  <item>
                     <p>has the <termref def="dt-same-key">same key</termref> (note that the
                        collation is not used when comparing keys), and </p>
                  </item>
                  <item>
                     <p>has the same associated value (compared using the <code>fn:deep-equal</code>
                        function, under the collation supplied in the original call to
                           <code>fn:deep-equal</code>).</p>
                  </item>
               </olist>
            </item>
         </olist>

      </fos:rules>
      <fos:errors>
         <p diff="add" at="B">An error is raised <xerrorref spec="FO30" class="TY" code="0015"/> if
            either input sequence contains a function item <phrase diff="add" at="I">that is not a
               map.</phrase>
         </p>
      </fos:errors>

      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:deep-equal(map{}, map{})</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:deep-equal(map{"a":1, "b":2}, map{"b":2,
                  "a":1.0})</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:deep-equal(map{"a":xs:double('NaN')},
                  map{"a":xs:float('NaN')})</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:variable name="at" as="element()"><![CDATA[
<attendees>
  <name last='Parker' first='Peter'/>
  <name last='Barker' first='Bob'/>
  <name first='Peter' last='Parker'/>
</attendees>]]></fos:variable>
         <fos:example>
            <fos:test>
               <fos:expression>fn:deep-equal($at, $at/*)</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:deep-equal($at/name[1], $at/name[2])</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:deep-equal($at/name[1], $at/name[3])</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:deep-equal($at/name[1], 'Peter Parker')</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>


<fos:function name="same-key" prefix="op">
      <fos:signatures>
         <fos:proto name="same-key" return-type="xs:boolean">
            <fos:arg name="k1" type="xs:anyAtomicType"/>
            <fos:arg name="k2" type="xs:anyAtomicType"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Determines whether two atomic values can coexist as separate keys within a map.</p>
      </fos:summary>
      <fos:rules>
         <p>The internal function <code>op:same-key</code> (which is not available at the user level) is used to assess whether two atomic
            values are considered to be duplicates when used as keys in a map. A map cannot
         contain two separate entries whose keys are <term>the same</term> as defined by this function. 
         The function is also used when matching keys in functions such as <code>map:get</code>
         and <code>map:remove</code>.</p>
         
         <p>The function returns true if and only if one of the following conditions is true:</p>
         
         <olist>
            <item><p>All of the following conditions are true:</p>
               <olist>
                  <item><p><code>$k1</code> is an instance of <code>xs:string</code>, <code>xs:anyURI</code>, or <code>xs:untypedAtomic</code></p></item>
                  <item><p><code>$k2</code> is an instance of <code>xs:string</code>, <code>xs:anyURI</code>, or <code>xs:untypedAtomic</code></p></item>
                  <item><p><code>fn:codepoint-equal($k1, $k2)</code></p></item>
               </olist>
               <note><p>Strings are compared without any dependency on collations.</p></note>
            </item>
            <item><p>All of the following conditions are true:</p>
               <olist>
                  <item><p><code>$k1</code> is an instance of <code>xs:decimal</code>, <code>xs:double</code>, or <code>xs:float</code></p></item>
                  <item><p><code>$k2</code> is an instance of <code>xs:decimal</code>, <code>xs:double</code>, or <code>xs:float</code></p></item>
                  <item><p>One of the following conditions is true:</p>
                     <olist>
                        <item><p>Both <code>$k1</code> and <code>$k2</code> are <code>NaN</code></p>
                        <note><p><code>xs:double('NaN')</code> is the same key as <code>xs:float('NaN')</code></p></note></item>
                        <item><p>Both <code>$k1</code> and <code>$k2</code> are positive infinity</p>
                           <note><p><code>xs:double('INF')</code> is the same key as <code>xs:float('INF')</code></p></note></item>
                        <item><p>Both <code>$k1</code> and <code>$k2</code> are negative infinity</p>
                           <note><p><code>xs:double('-INF')</code> is the same key as <code>xs:float('-INF')</code></p></note></item>
                        <item><p><code>$k1</code> and <code>$k2</code> when converted to decimal numbers with no rounding or loss of precision
                           are mathematically equal.</p>
                           <note><p>Every instance of <code>xs:double</code>, <code>xs:float</code>, and <code>xs:decimal</code> can be represented
                              exactly as a decimal number provided enough digits are available both before and after the decimal point. Unlike the <code>eq</code>
                              relation, which converts both operands to <code>xs:double</code> values, possibly losing precision in the process, this
                              comparison is transitive.</p></note>
                           <note><p>Positive and negative zero are the same key.</p></note>
                        </item>
                     </olist>
                  </item>                
               </olist>
               
            </item>
            <item><p>All of the following conditions are true:</p>
               <olist>
                  <item><p><code>$k1</code> is an instance of <code>xs:date</code>, <code>xs:time</code>, <code>xs:dateTime</code>,
                     <code>xs:gYear</code>, <code>xs:gYearMonth</code>, <code>xs:gMonth</code>, <code>xs:gMonthDay</code>, or <code>xs:gDay</code></p></item>
                  <item><p><code>$k2</code> is an instance of <code>xs:date</code>, <code>xs:time</code>, <code>xs:dateTime</code>,
                     <code>xs:gYear</code>, <code>xs:gYearMonth</code>, <code>xs:gMonth</code>, <code>xs:gMonthDay</code>, or <code>xs:gDay</code></p></item>
                  <item><p>One of the following conditions is true:</p>
                        <olist>
                           <item><p>Both <code>$k1</code> and <code>$k2</code> have a timezone</p></item>
                           <item><p>Neither <code>$k1</code> nor <code>$k2</code> has a timezone</p></item>
                        </olist>
                  </item>
                  <item><p><code>fn:deep-equal($k1, $k2)</code></p>
                  <note><p>The use of <code>deep-equal</code> rather than <code>eq</code> ensures that comparing values of different
                  types yields <code>false</code> rather than an error.</p></note></item>
                  
               </olist>
               <note><p>Unlike the <code>eq</code> operator, this comparison has no dependency on the implicit timezone, which means that
                  the question of whether or not a map contains duplicate keys is not dependent on this aspect of the dynamic context.</p></note>
            </item>
            <item>
               <p>All of the following conditions are true:</p>
               <olist>
                  <item><p><code>$k1</code> is an instance of <code>xs:boolean</code>, <code>xs:hexBinary</code>, <code>xs:base64Binary</code>,
                     <code>xs:duration</code>, <code>xs:QName</code>, or <code>xs:NOTATION</code></p></item>
                  <item><p><code>$k2</code> is an instance of <code>xs:boolean</code>, <code>xs:hexBinary</code>, <code>xs:base64Binary</code>,
                     <code>xs:duration</code>, <code>xs:QName</code>, or <code>xs:NOTATION</code></p></item>
                  <item><p><code>fn:deep-equal($k1, $k2)</code></p>
                     <note><p>The use of <code>deep-equal</code> rather than <code>eq</code> ensures that comparing values of different
                        types yields <code>false</code> rather than an error.</p></note></item>
               </olist>
            </item>
         </olist>
         
      </fos:rules>
      
      <fos:notes>
         <p>The rules for comparing keys in a map are chosen to ensure that the comparison is:</p>
         <ulist>
            <item><p><term>Context-free</term>: there is no dependency on the static or dynamic context</p></item>
            <item><p><term>Error-free</term>: any two atomic values can be compared, and the result is either true or false, never an error</p></item>
            <item><p><term>Transitive</term>: if A is the same key as B, and B is the same key as C, then A is the same key as C.</p></item>
         </ulist>
         <p>As always, any algorithm that delivers the right result is acceptable. For example, when testing whether an <code>xs:double</code>
            value <var>D</var> is the same key as an <code>xs:decimal</code> value that has <var>N</var> significant digits, it is not
            necessary to know all the digits in the decimal expansion of <var>D</var> to establish the result: computing the first <var>N+1</var> 
            significant digits (or indeed, simply knowing that there are more than <var>N</var> significant digits) is sufficient.</p>
      </fos:notes>
      
   </fos:function>

   <fos:function name="merge" prefix="map" diff="chg" at="T-bug29723">
      <fos:signatures>
         <fos:proto name="merge" return-type="map(*)">
            <fos:arg name="maps" type="map(*)*" usage="inspection"/>
         </fos:proto>
         <fos:proto name="merge" return-type="map(*)">
            <fos:arg name="maps" type="map(*)*" usage="inspection"/>
            <fos:arg name="options" type="map(*)" usage="inspection"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns a map that combines the entries from a number of existing maps.</p>
      </fos:summary>
      <fos:rules>
         <p>The function <code>map:merge</code> returns a map that
            is formed by combining the contents of the maps supplied in the <code>$maps</code>
            argument.</p>
         
         
         <p>Informally, the supplied maps are combined as follows:</p>
         
         <olist>
            <item>
               <p>There is one entry in the returned map for each distinct key present in the union
                  of the input maps, where two keys are distinct if they are not the <phrase
                     diff="chg" at="N"><termref def="dt-same-key">same key</termref></phrase>.</p>
            </item>
            <item>
               <p diff="chg" at="E">If there are duplicate keys, that is, if two or more maps contain entries having the
                  <termref def="dt-same-key">same key</termref>, then the way this is handled is
                  controlled by the second (<code>$options</code>) argument.</p>
            </item>
         </olist>
         
         <p>The definitive specification is as follows.</p>
         
         <olist>
            <item><p>The effect of calling the single-argument function is the same as the effect of
               calling the two-argument function with an empty map as the value of <code>$options</code>.</p></item>
            <item><p>The <code>$options</code> argument can be used to control the way in which duplicate keys are handled. 
               The <termref def="option-parameter-conventions">option parameter conventions</termref> apply.
            </p></item>
            <item><p>The entries that may appear in the <code>$options</code> map are as follows:</p>
               
               <table class="data">
                  <thead>
                     <tr>
                        <th>Key</th>
                        <th>Value</th>
                        <th>Meaning</th>
                     </tr>
                  </thead>
                  <tbody>
                     
                     
                     <tr>
                        <td rowspan="6">
                           <code>duplicates</code>
                        </td>
                        <td colspan="2">Determines the policy for handling duplicate keys: specifically, the action to be
                           taken if two maps in the input sequence <code>$maps</code> contain entries with key values
                           <var>K1</var> and <var>K2</var> where <var>K1</var> and <var>K2</var> are the <termref def="dt-same-key">same key</termref>.
                           The required type is <code>xs:string</code>. The default value is <code>use-first</code>.</td>
                     </tr>
                     <tr>
                        <td>
                           <code>reject</code>
                        </td>
                        <td>An error is raised <xerrorref spec="FO31" class="JS" code="0003"/> if duplicate keys are encountered.</td>
                     </tr>
                     <tr>
                        <td>
                           <code>use-first</code>
                        </td>
                        <td>If duplicate keys are present, all but the first of a set of duplicates are ignored, 
                           where the ordering is based on the order of maps in the <code>$maps</code> argument.</td>
                     </tr>
                     <tr>
                        <td>
                           <code>use-last</code>
                        </td>
                        <td>If duplicate keys are present, all but the last of a set of duplicates are ignored, 
                           where the ordering is based on the order of maps in the <code>$maps</code> argument.</td>
                     </tr>
                     <tr>
                        <td>
                           <code>combine</code>
                        </td>
                        <td>If duplicate keys are present, the result map includes an entry for the key whose 
                           associated value is the sequence-concatenation of all the values associated with the key, 
                           retaining order based on the order of maps in the <code>$maps</code> argument.
                           The key value in the result map that corresponds to such a set of duplicates must
                           be the <termref def="dt-same-key">same key</termref> as each of the duplicates, but it is
                           otherwise unconstrained: for example if the duplicate keys are <code>xs:byte(1)</code>
                           and <code>xs:short(1)</code>, the key in the result could legitimately be <code>xs:long(1)</code>.
                        </td>
                     </tr>
                     <tr>
                        <td>
                           <code>unspecified</code>
                        </td>
                        <td>If duplicate keys are present, all but one of a set of duplicates are ignored, 
                           and it is <termref def="dt-implementation-dependent">implementation-dependent</termref>
                           which one is retained. 
                        </td>
                     </tr>
                     
                     
                     
                     
                  </tbody>
               </table>
            </item>
         </olist>
         <p>The result of the function call <code>map:merge($MAPS, $OPTIONS)</code>
            is defined to be consistent with the result of the expression:</p>
         
         <eg><![CDATA[
let $FOJS0003 := QName("http://www.w3.org/2005/xqt-errors", "FOJS0003"),

$duplicates-handler := map {
  "use-first":   function($a, $b) {$a},
  "use-last":    function($a, $b) {$b},
  "combine":     function($a, $b) {$a, $b},
  "reject":      function($a, $b) {fn:error($FOJS0003)},
  "unspecified": function($a, $b) {fn:random-number-generator()?permute(($a, $b))[1]}
},

$combine-maps := function($A as map(*), $B as map(*), $deduplicator as function(*)) {
    fn:fold-left(map:keys($B), $A, function($z, $k){ 
        if (map:contains($z, $k))
        then map:put($z, $k, $deduplicator($z($k), $B($k)))
        else map:put($z, $k, $B($k))
    })
}
return fn:fold-left($MAPS, map{}, 
    $combine-maps(?, ?, $duplicates-handler(($OPTIONS?duplicates, "use-first")[1]))
            
            ]]></eg>
         
         <note>
            <p>By way of explanation, <code>$combine-maps</code> is a function that combines
               two maps by iterating over the keys of the second map, adding each key and its corresponding
               value to the first map as it proceeds. The second call of <code>fn:fold-left</code>
               in the <code>return</code> clause then iterates over the maps supplied in the call
               to <code>map:merge</code>, accumulating a single map that absorbs successive maps
               in the input sequence by calling <code>$combine-maps</code>.</p>
            
            
            <p>This algorithm processes the supplied maps in a defined order, but processes the keys within
               each map in implementation-dependent order.</p>
            
            <p>The use of <code>fn:random-number-generator</code> represents one possible conformant
               implementation for <code>"duplicates":"unspecified"</code>, but it is not the only conformant
               implementation and is not necessarily a realistic implementation.</p>
         </note>
         
         
      </fos:rules>
      <fos:errors>
         <p>An error is raised <xerrorref spec="FO31" class="JS" code="0003"/> if the value of 
            <code>$options</code> indicates that duplicates are to be rejected, and a duplicate key is encountered.</p>
         <p>An error is raised <xerrorref spec="FO31" class="JS" code="0005"/> if the value of 
            <code>$options</code> includes an entry whose key is defined 
            in this specification, and whose value is not a permitted value for that key.</p>
      </fos:errors>
      <fos:notes>
         <p diff="add" at="R-bug24726">If the input is an empty sequence, the result is an empty map.</p>
         <p diff="add" at="R-bug24726">If the input is a sequence of length one, the result map is 
            <phrase diff="chg" at="C">indistinguishable from the supplied map</phrase>.</p>
         <p>There is no requirement that the supplied input maps should have the same or compatible
            types. The type of a map (for example <code>map(xs:integer, xs:string)</code>) is
            descriptive of the entries it currently contains, but is not a constraint on how the map
            may be combined with other maps.</p>
      </fos:notes>
      <fos:examples>
         <fos:variable name="week"
            select="map{0:&quot;Sonntag&quot;, 1:&quot;Montag&quot;, 2:&quot;Dienstag&quot;, &#xa;     3:&quot;Mittwoch&quot;, 4:&quot;Donnerstag&quot;, 5:&quot;Freitag&quot;, &#xa;     6:&quot;Samstag&quot;}"/>
         <fos:example>
            <fos:test>
               <fos:expression>map:merge(())</fos:expression>
               <fos:result>map{}</fos:result>
               <fos:postamble>Returns an empty map</fos:postamble>
            </fos:test>
            <fos:test>
               <fos:expression>map:merge((map:entry(0, "no"), map:entry(1, "yes")))</fos:expression>
               <fos:result>map{0:"no", 1:"yes"}</fos:result>
               <fos:postamble>Returns a map with two entries</fos:postamble>
            </fos:test>
            <fos:test>
               <fos:expression>map:merge(($week, map{7:"Unbekannt"}))</fos:expression>
               <fos:result>map{0:"Sonntag", 1:"Montag", 2:"Dienstag", 3:"Mittwoch", 4:"Donnerstag",
                  5:"Freitag", 6:"Samstag", 7:"Unbekannt"}</fos:result>
               <fos:postamble>The value of the existing map is unchanged; the <phrase diff="chg" at="C">returned map 
                  contains</phrase> all the entries from <code>$week</code>, supplemented with an additional
                  entry.</fos:postamble>
            </fos:test>
            <fos:test>
               <fos:expression>map:merge(($week, map{6:"Sonnabend"}), map{"duplicates":"use-last"})</fos:expression>
               <fos:result>map{0:"Sonntag", 1:"Montag", 2:"Dienstag", 3:"Mittwoch", 4:"Donnerstag",
                  5:"Freitag", 6:"Sonnabend"}</fos:result>
               <fos:postamble>The value of the existing map is unchanged; the returned map
                  contains all the entries from <code>$week</code>, with one entry replaced by a
                  new entry. Both input maps contain an entry with the key <code>6</code>; the
                  one used in the result is the one that comes last in the input
                  sequence.</fos:postamble>
            </fos:test>
            <fos:test>
               <fos:expression>map:merge(($week, map{6:"Sonnabend"}), map{"duplicates":"use-first"})</fos:expression>
               <fos:result>map{0:"Sonntag", 1:"Montag", 2:"Dienstag", 3:"Mittwoch", 4:"Donnerstag",
                  5:"Freitag", 6:"Samstag"}</fos:result>
               <fos:postamble>The value of the existing map is unchanged; the returned map
                  contains all the entries from <code>$week</code>, with one entry replaced by a
                  new entry. Both input maps contain an entry with the key <code>6</code>; the
                  one used in the result is the one that comes first in the input
                  sequence.</fos:postamble>
            </fos:test>
            <fos:test>
               <fos:expression>map:merge(($week, map{6:"Sonnabend"}), map{"duplicates":"combine"})</fos:expression>
               <fos:result>map{0:"Sonntag", 1:"Montag", 2:"Dienstag", 3:"Mittwoch", 4:"Donnerstag",
                  5:"Freitag", 6:("Samstag", "Sonnabend")}</fos:result>
               <fos:postamble>The value of the existing map is unchanged; the returned map
                  contains all the entries from <code>$week</code>, with one entry replaced by a
                  new entry. Both input maps contain an entry with the key <code>6</code>; the
                  entry that appears in the result is the sequence-concatenation of the entries
                  in the input maps, retaining order.</fos:postamble>
            </fos:test>
            
         </fos:example>
      </fos:examples>
   </fos:function>

   <fos:function name="keys" prefix="map">
      <fos:signatures>
         <fos:proto name="keys" return-type="xs:anyAtomicType*">
            <fos:arg name="map" type="map(*)" usage="inspection"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns a sequence containing all the keys present in a map</p>
      </fos:summary>
      <fos:rules>
         <p>The function <code>map:keys</code> takes any <termref def="dt-map">map</termref>
            as its <code>$map</code> argument and returns the keys that are present in the map as
            a sequence of atomic values, in <termref def="dt-implementation-dependent"
               >implementation-dependent</termref> order.</p>
         <p diff="add" at="D">The function is <term>non-deterministic with respect to ordering</term>
            (see <xspecref spec="FO31" ref="properties-of-functions"/>). This means that two calls with the same argument
            are not guaranteed to produce the results in the same order.</p>
      </fos:rules>
      <fos:notes>
         <p diff="add" at="P">The number of items in the result will be the same as the number of
            entries in the map, and the result sequence will contain no duplicate values.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>map:keys(map{1:"yes", 2:"no"})</fos:expression>
               <fos:result allow-permutation="true">(1,2)</fos:result>
               <fos:postamble>The result is in <termref def="dt-implementation-dependent"
                     >implementation-dependent</termref> order.</fos:postamble>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>

   <fos:function name="contains" prefix="map" diff="add" at="MAP">
      <fos:signatures>
         <fos:proto name="contains" return-type="xs:boolean">
            <fos:arg name="map" type="map(*)" usage="inspection"/>
            <fos:arg name="key" type="xs:anyAtomicType"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Tests whether a supplied map contains an entry for a given key</p>
      </fos:summary>
      <fos:rules>
         <p>The function <code>map:contains</code> returns true if the <termref def="dt-map"
               >map</termref> supplied as <code>$map</code> contains an entry with <phrase
               diff="chg" at="N">the <termref def="dt-same-key">same key</termref> as</phrase> the
            supplied value of <code>$key</code>; otherwise it returns false.</p>


      </fos:rules>
      

      <fos:examples>
         <fos:variable name="week"
            select="map{0:&quot;Sonntag&quot;, 1:&quot;Montag&quot;, 2:&quot;Dienstag&quot;, &#xa;    3:&quot;Mittwoch&quot;, 4:&quot;Donnerstag&quot;, 5:&quot;Freitag&quot;, 6:&quot;Samstag&quot;}"/>
         <fos:example>
            <fos:test>
               <fos:expression>map:contains($week, 2)</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>map:contains($week, 9)</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>map:contains(map{}, "xyz")</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>map:contains(map{"xyz":23}, "xyz")</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>map:contains(map{"abc":23, "xyz":()}, "xyz")</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="get" prefix="map" diff="add" at="MAP">
      <fos:signatures>
         <fos:proto name="get" return-type="item()*">
            <fos:arg name="map" type="map(*)" usage="inspection"/>
            <fos:arg name="key" type="xs:anyAtomicType"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the value associated with a supplied key in a given map.</p>
      </fos:summary>
      <fos:rules>
         <p>The function <code>map:get</code> attempts to find an entry within the <termref
               def="dt-map">map</termref> supplied as <code>$map</code> that has <phrase diff="chg"
               at="N">the <termref def="dt-same-key">same key</termref> as</phrase> the supplied
            value of <code>$key</code>. If there is such an entry, it returns the associated value;
            otherwise it returns an empty sequence.</p>

         

         
      </fos:rules>
      <fos:notes>
         <p>A return value of <code>()</code> from <code>map:get</code> could indicate that
            the key is present in the map with an associated value of <code>()</code>, or it could
            indicate that the key is not present in the map. The two cases can be distinguished by
            calling <code>map:contains</code>.</p>

         <p>Invoking the <termref def="dt-map">map</termref> as a function item has the same effect
            as calling <code>get</code>: that is, when <code>$map</code> is a map, the expression
               <code>$map($K)</code> is equivalent to <code>map:get($map, $K)</code>. Similarly, the
            expression <code>map:get(map:get(map:get($map, 'employee'), 'name'), 'first')</code> can
            be written as <code>$map('employee')('name')('first')</code>. </p>
         
      </fos:notes>
      <fos:examples>
         <fos:variable name="week"
            select="map{0:&quot;Sonntag&quot;, 1:&quot;Montag&quot;, 2:&quot;Dienstag&quot;,
&#xa;     3:&quot;Mittwoch&quot;, 4:&quot;Donnerstag&quot;, 5:&quot;Freitag&quot;, 
&#xa;     6:&quot;Samstag&quot;}"/>
         <fos:example>
            <fos:test>
               <fos:expression>map:get($week, 4)</fos:expression>
               <fos:result>"Donnerstag"</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>map:get($week, 9)</fos:expression>
               <fos:result>()</fos:result>
               <fos:postamble>When the key is not present, the function returns an empty
                  sequence.</fos:postamble>
            </fos:test>
            <fos:test>
               <fos:expression>map:get(map:entry(7,()), 7)</fos:expression>
               <fos:result>()</fos:result>
               <fos:postamble>An empty sequence as the result can also signify that the key is
                  present and the associated value is an empty sequence.</fos:postamble>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   
   <fos:function name="find" prefix="map" diff="add" at="MAP">
      <fos:signatures>
         <fos:proto name="find" return-type="array(*)">
            <fos:arg name="input" type="item()*" usage="inspection"/>
            <fos:arg name="key" type="xs:anyAtomicType"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Searches the supplied input sequence and any contained maps and arrays for a map entry with the supplied key,
            and returns the corresponding values.</p>
      </fos:summary>
      <fos:rules>
         <p>The function <code>map:find</code> searches the sequence supplied as <code>$input</code>
            looking for map entries whose key is the <termref def="dt-same-key">same key</termref>
            as <code>$key</code>. The associated value in any such map entry (each being in general a sequence)
            is returned as a member of the result array.</p>
         
         <p>The search processes the <code>$input</code> sequence using the following recursively-defined rules 
            (any equivalent algorithm may be used provided it delivers
            the same result, respecting those rules that constrain the order of the result):</p>
         
         <olist>
            <item><p>To process a sequence, process each of its items in order.</p></item>
            <item><p>To process an item that is an array, process each of the array's members in order 
               (each member is, in general, a sequence).</p></item>
            <item><p>To process an item that is a map, then for each key-value entry (<var>K</var>, <var>V</var>)
               in the map (in <termref def="dt-implementation-dependent">implementation-dependent</termref> order)
               perform both of the following steps, in order:</p>
               <olist>
                  <item><p>If <var>K</var> is the <termref def="dt-same-key">same key</termref> as <code>$key</code>, 
                     then add <var>V</var> as a new member to the end of the result array.</p></item>
                  <item><p>Process <var>V</var> (which is, in general, a sequence).</p></item>
               </olist></item>
            <item><p>To process an item that is neither a map nor an array, do nothing. (Such items are ignored).</p></item>
         </olist>
         
      </fos:rules>
      <fos:notes>
         <p>If <code>$input</code> is an empty sequence, map, or array, or if the requested <code>$key</code> is not found,
            the result will be a zero-length array.</p>
         
      </fos:notes>
      <fos:examples>
         <fos:variable name="responses"
            select="[map{0:'no', 1:'yes'}, 
 &#xa;     map{0:'non', 1:'oui'}, 
 &#xa;     map{0:'nein', 1:('ja', 'doch')}]"/>
         <fos:example>
            <fos:test>
               <fos:expression>map:find($responses, 0)</fos:expression>
               <fos:result>['no', 'non', 'nein']</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>map:find($responses, 1)</fos:expression>
               <fos:result>['yes', 'oui', ('ja', 'doch')]</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>map:find($responses, 2)</fos:expression>
               <fos:result>[]</fos:result>
            </fos:test>
            
         </fos:example>
         <fos:variable name="inventory"
            select='map{"name":"car", "id":"QZ123", 
 &#xa;     "parts": [map{name":"engine", "id":"YW678", "parts":[]}]}'/>
         <fos:example>
            <fos:test>
               <fos:expression>map:find($inventory, "parts")</fos:expression>
               <fos:result>[[map{name":"engine", "id":"YW678", "parts":[]}], []]</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   
   <fos:function name="put" prefix="map" diff="add" at="R-bug24726">
      <fos:signatures>
         <fos:proto name="put" return-type="map(*)">
            <fos:arg name="map" type="map(*)" usage="inspection"/>
            <fos:arg name="key" type="xs:anyAtomicType"/>
            <fos:arg name="value" type="item()*" usage="navigation"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns a map containing all the contents of the supplied map, but with an additional entry, which replaces
         any existing entry for the same key.</p>
      </fos:summary>
      <fos:rules>
         <p>The function <code>map:put</code> returns <phrase diff="chg" at="C">a <termref def="dt-map"
            >map</termref> that</phrase> contains all entries from the supplied <code>$map</code>,
            with the exception of any entry whose key is the <termref def="dt-same-key">same key</termref> as <code>$key</code>, together with a new
         entry whose key is <code>$key</code> and whose associated value is <code>$value</code>.</p>
         
         <p>The effect of the function call <code>map:put($MAP, $KEY, $VALUE)</code> is equivalent
         to the result of the following steps:</p>
         
         <olist>
            <item>
               <p><code>let $MAP2 := map:remove($MAP, $KEY)</code></p>
               <p>This returns a map in which all entries with the same key as <code>$KEY</code> have been removed.</p>
            </item>
            <item>
               <p>Construct and return a map containing:</p>
               <olist>
                  <item><p>All the entries (key/value pairs) in <code>$MAP2</code>, and</p></item>
                  <item><p>The entry <code>map:entry($KEY, $VALUE)</code></p></item>
               </olist>
            </item>
         </olist>
       
      </fos:rules>
      
      <fos:notes>
         <p>There is no requirement that the type of <code>$key</code> and <code>$value</code> be consistent with the types
         of any existing keys and values in the supplied map.</p>
         
      </fos:notes>

      <fos:examples>
         <fos:variable name="week"
            select="map{0:&quot;Sonntag&quot;, 1:&quot;Montag&quot;, 2:&quot;Dienstag&quot;, &#xa;     3:&quot;Mittwoch&quot;, 4:&quot;Donnerstag&quot;, 5:&quot;Freitag&quot;, &#xa;     6:&quot;Samstag&quot;}"/>
         <fos:example>
            <fos:test>
               <fos:expression>map:put($week, 6, "Sonnabend")</fos:expression>
               <fos:result>map{0:"Sonntag", 1:"Montag", 2:"Dienstag", 3:"Mittwoch", 4:"Donnerstag",
                  5:"Freitag", 6:"Sonnabend"}</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>map:put($week, -1, "Unbekannt")</fos:expression>
               <fos:result>map{0:"Sonntag", 1:"Montag", 2:"Dienstag", 3:"Mittwoch", 4:"Donnerstag",
                  5:"Freitag", 6:"Samstag", -1:"Unbekannt"}</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="entry" prefix="map" diff="add" at="MAP">
      <fos:signatures>
         <fos:proto name="entry" return-type="map(*)">
            <fos:arg name="key" type="xs:anyAtomicType"/>
            <fos:arg name="value" type="item()*" usage="navigation"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p><phrase diff="chg" at="C">Returns</phrase> a map that contains a single entry (a key-value pair).</p>
      </fos:summary>
      <fos:rules>
         <p>The function <code>map:entry</code> returns a <termref def="dt-map"
               >map</termref> which <phrase diff="del" at="P">normally</phrase> contains a single
            entry. <phrase diff="del" at="N">The collation of the new map is the default collation
               from the static context. </phrase>The key of the entry in the new map is
               <code>$key</code>, and its associated value is <code>$value</code>.</p>

         <p diff="del" at="N">If the supplied key is the <code>xs:float</code> or
               <code>xs:double</code> value <code>NaN</code>, the supplied <code>$map</code> is
            empty (that is, it contains no entries).</p>

         <p diff="del" at="N">If the supplied key is <code>xs:untypedAtomic</code>, it is converted
            to <code>xs:string</code>.</p>
      </fos:rules>
      <fos:notes>
         <p>The function <code>map:entry</code> is intended primarily for use in conjunction with
            the function <code>map:merge</code>. For example, a map containing seven entries may be
            constructed like this:</p>

         <eg><![CDATA[
map:merge((
   map:entry("Su", "Sunday"),
   map:entry("Mo", "Monday"),
   map:entry("Tu", "Tuesday"),
   map:entry("We", "Wednesday"),
   map:entry("Th", "Thursday"),
   map:entry("Fr", "Friday"),
   map:entry("Sa", "Saturday")
   ))]]></eg>
         <p>Unlike the map expression (<code>map{...}</code>), this technique can be used to construct
            a map with a variable number of entries, for example:</p>
         <eg><![CDATA[
map:merge(for $b in //book return map:entry($b/isbn, $b))]]></eg>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>map:entry("M", "Monday")</fos:expression>
               <fos:result>{"M":"Monday"}</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="remove" prefix="map">
      <fos:signatures>
         <fos:proto name="remove" return-type="map(*)">
            <fos:arg name="map" type="map(*)" usage="inspection"/>
            <fos:arg name="keys" type="xs:anyAtomicType*"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns a map containing all the entries from a supplied map, except <phrase diff="chg" at="T-bug29660">those having a specified key</phrase>.</p>
      </fos:summary>
      <fos:rules>
         <p>The function <code>map:remove</code> returns a <termref def="dt-map"
            >map</termref> containing all the entries in <code>$map</code> except for any entry whose key is 
            the <termref def="dt-same-key">same key</termref> as <phrase diff="chg" at="T-bug29660">an item in</phrase> <code>$keys</code>.</p>
         <p>No failure occurs <phrase diff="chg" at="T-bug29660">if an item in <code>$keys</code> does not correspond to any entry in <code>$map</code>;
            that key value is simply ignored</phrase>.</p>
         <p>The effect of the function call <code>map:remove($MAP, $KEY)</code> can be described more formally as the result of the expression below:</p>
         
         <eg diff="chg" at="T-bug29660"><![CDATA[
map:merge (
    map:for-each (
       $MAP, function($k, $v) { 
               if (some $key in $KEY satisfies op:same-key($k, $key)) 
               then () 
               else map:entry($k, $v)
             } ) ) ]]></eg>
      </fos:rules>
      
      <fos:examples>
         <fos:variable name="week"
            select="map{0:&quot;Sonntag&quot;, 1:&quot;Montag&quot;, 2:&quot;Dienstag&quot;,&#xa;     3:&quot;Mittwoch&quot;, 4:&quot;Donnerstag&quot;, 5:&quot;Freitag&quot;, 6:&quot;Samstag&quot;}"/>
         <fos:example>
            <fos:test>
               <fos:expression>map:remove($week, 4)</fos:expression>
               <fos:result>map{0:"Sonntag", 1:"Montag", 2:"Dienstag", 3:"Mittwoch", 5:"Freitag",
                  6:"Samstag"}</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>map:remove($week, 23)</fos:expression>
               <fos:result>map{0:"Sonntag", 1:"Montag", 2:"Dienstag", 3:"Mittwoch", 4:"Donnerstag",
                  5:"Freitag", 6:"Samstag"}</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>map:remove($week, (0, 6 to 7))</fos:expression>
               <fos:result>map{1:"Montag", 2:"Dienstag", 3:"Mittwoch", 4:"Donnerstag", 5:"Freitag"}</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>map:remove($week, ())</fos:expression>
               <fos:result>>map{0:"Sonntag", 1:"Montag", 2:"Dienstag", 3:"Mittwoch", 4:"Donnerstag", 5:"Freitag",
                  6:"Samstag"}</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="for-each" prefix="map" diff="chg" at="B">
      <fos:signatures>
         <fos:proto name="for-each" return-type="item()*">
            <fos:arg name="map" type="map(*)" usage="inspection"/>
            <fos:arg name="action" type="function(xs:anyAtomicType, item()*) as item()*" usage="inspection"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
         <!--<fos:property>higher-order</fos:property>-->
      </fos:properties>
      <fos:summary>
         <p>Applies a supplied function to every entry in a map, returning the concatenation of the
            results.</p>
      </fos:summary>
      <fos:rules>
         <p>The function <code>map:for-each</code> takes any <termref def="dt-map"
               >map</termref> as its <code>$map</code> argument and applies the supplied function
            to each entry in the map, in <termref def="dt-implementation-dependent"
               >implementation-dependent</termref> order; the result is the sequence obtained by
            concatenating the results of these function calls.</p>
         <p diff="add" at="D">The function is <term>non-deterministic with respect to ordering</term>
            (see <xspecref spec="FO31" ref="properties-of-functions"/>). This means that two calls with the same arguments
            are not guaranteed to process the map entries in the same order.</p>
         <p>The function supplied as <code>$action</code> takes two arguments. It is called
            supplying the key of the map entry as the first argument, and the associated value as
            the second argument.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>map:for-each(map{1:"yes", 2:"no"}, function($k,
                  $v){$k})</fos:expression>
               <fos:result allow-permutation="true">(1,2)</fos:result>
               <fos:postamble>This function call is equivalent to calling <code>map:keys</code>. The
                  result is in implementation-dependent order.</fos:postamble>
            </fos:test>
            <fos:test>
               <fos:expression>distinct-values(map:for-each(map{1:"yes", 2:"no"}, function($k,
                  $v){$v}))</fos:expression>
               <fos:result allow-permutation="true">("yes", "no")</fos:result>
               <fos:postamble>This function call returns the distinct values present in the map, in
                  implementation-dependent order.</fos:postamble>
            </fos:test>
            <fos:test>
               <fos:expression>map:merge(map:for-each(map{"a":1, "b":2}, function($k,
                  $v){map:entry($k, $v+1)}))</fos:expression>
               <fos:result>map{"a":2, "b":3}</fos:result>
               <fos:postamble>This function call returns a map with the same keys as the input map,
                  with the value of each entry increased by one.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <example>
               <head>Converting a Map to an Element Node</head>
               <p>This XQuery example converts the entries in a map to attributes on a newly constructed
                  element node.</p>
               
               <eg><![CDATA[
let
  $dimensions := map{'height': 3, 'width': 4, 'depth': 5};
return
  <box>{
     map:for-each($dimensions, function ($k, $v) { attribute {$k} {$v} })
  }</box>]]></eg>

               <p>The result is the element <code>&lt;box height="3" width="4"
                  depth="5"/></code>.</p>
            </example>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="size" prefix="map" diff="add" at="MAP">
      <fos:signatures>
         <fos:proto name="size" return-type="xs:integer">
            <fos:arg name="map" type="map(*)" usage="inspection"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the number of entries in the supplied map.</p>
      </fos:summary>
      <fos:rules>
         <p>The function <code>map:size</code> takes any <termref def="dt-map">map</termref>
            as its <code>$map</code> argument and returns the number of entries that are present
            in the map.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>map:size(map{})</fos:expression>
               <fos:result>0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>map:size(map{"true":1, "false":0})</fos:expression>
               <fos:result>2</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>

   <fos:function name="collation-key" prefix="fn" diff="add" at="A">
      <fos:signatures>
         <fos:proto name="collation-key" return-type="xs:base64Binary">
            <fos:arg name="key" type="xs:string"/>
         </fos:proto>
         <fos:proto name="collation-key" return-type="xs:base64Binary">
            <fos:arg name="key" type="xs:string"/>
            <fos:arg name="collation" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property dependency="collations">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p diff="chg" at="B-bug25446">Given a string value and a collation, generates an internal value called a collation key, with the property that
            the matching and ordering of collation keys reflects the matching and ordering of strings under the specified collation.</p>
      </fos:summary>
      <fos:rules>
         <p>Calling the one-argument version of this function is equivalent to calling the
            two-argument version supplying the default collation as the second argument.</p>
         <p>The function returns an <phrase diff="add" at="B-bug25446"><termref def="dt-implementation-dependent">implementation-dependent</termref></phrase> 
            value with the property that,
            for any two strings <code>$K1</code> and <code>$K2</code>:</p>
         <ulist>
            <item><p><code>collation-key($K1, $C) eq collation-key($K2, $C)</code> if and only if
               <code>compare($K1, $K2, $C) eq 0</code></p></item>
            <item diff="add" at="B-bug25446"><p><code>collation-key($K1, $C) lt collation-key($K2, $C)</code> if and only if
               <code>compare($K1, $K2, $C) lt 0</code></p></item>
         </ulist>
         
         <p>The collation used by this function is determined in the same way as for other functions
            accepting a collation URI argument. <phrase diff="add" at="T-bug29853">Collation keys are defined as <code>xs:base64Binary</code> values
            to ensure unambiguous and context-free comparison semantics.</phrase></p>
         <p>An implementation is free to generate a collation key in any convenient way provided
            that it always generates the same collation key for two strings that are equal under the
            collation, and different collation keys for strings that are not equal. This holds only
            within a single <xtermref spec="FO30" ref="execution-scope">execution scope</xtermref>;
            an implementation is under no obligation to generate the same collation keys during a
            subsequent unrelated query or transformation.</p>
         <p>It is possible to define collations that do not have the ability to generate collation
            keys. Supplying such a collation will cause the function to fail. The ability to
            generate collation keys is an <termref def="dt-implementation-defined">implementation-defined</termref> property of the
            collation.</p>
      </fos:rules>
      <fos:errors>
         <p>An error is raised <xerrorref spec="FO31" class="CH" code="0004"/> if the specified
            collation does not support the generation of collation keys. </p>
      </fos:errors>
      <fos:notes>
         <p>The function is provided primarily for use with maps. If a map is required where
            codepoint equality is inappropriate for comparing keys, then a common technique is to
            normalize the key so that equality matching becomes feasible. There are many ways
            keys can be normalized, for example by use of functions such as
            <code>fn:upper-case</code>, <code>fn:lower-case</code>,
            <code>fn:normalize-space</code>, or <code>fn:normalize-unicode</code>, but this
            function provides a way of normalizing them according to the rules of a specified
            collation. For example, if the collation ignores accents, then the function will
            generate the same collation key for two input strings that differ only in their use of
            accents.</p>
         <p diff="add" at="T-bug29853">The result of the function is defined to be an <code>xs:base64Binary</code> value. Binary values
            are chosen because they have unambiguous and context-free comparison semantics, because the value space
            is unbounded, and because the ordering rules are such that between any two values in the ordered value space, an
            arbitrary number of further values can be interpolated. The choice between <code>xs:base64Binary</code>
            and <code>xs:hexBinary</code> is arbitrary; the only operation that behaves differently between the two binary
            data types is conversion to/from a string, and this operation is not one that is normally required for
            effective use of collation keys.
         </p>
         <p>For collations based on the Unicode Collation Algorithm, an algorithm for computing
            collation keys is provided in <bibref ref="UNICODE-TR10"/>. Implementations are
            <rfc2119>not required</rfc2119> to use this algorithm.</p>
         <p diff="del" at="B-bug25446">This specification does not mandate that collation keys should retain ordering. This is
            partly because the primary use case is for maps, where only equality comparisons are
            required, and partly to allow the use of binary data types (which are currently
            unordered types) for the result. The specification may be revised in a future release to
            specify that ordering is preserved.</p>
         <p diff="add" at="B-bug25446">The fact that collation keys are ordered can be exploited in XQuery, whose <code>order by</code>
            clause does not allow the collation to be selected dynamically. This restriction can be circumvented
            by rewriting the clause <code>order by $e/@key collation "URI"</code> as <code>order by fn:collation-key($e/@key, $collation)</code>,
            where <code>$collation</code> allows the collation to be chosen dynamically.</p>
         <p diff="chg" at="T-bug29853">Note that <code>xs:base64Binary</code> becomes an ordered type
            in XPath 3.1, making binary collation keys possible. In an implementation that adheres strictly to XPath 3.0,
            collation keys can be used only for equality matching, not for ordering operations.</p>
         
      </fos:notes>
      <fos:examples>
         <fos:variable name="C" id="v-collation-key-C" select="'http://www.w3.org/2013/collation/UCA?strength=primary'"/>
         <fos:example>
            <fos:test use="v-collation-key-C">
               <fos:expression>map:merge((map{collation-key("A", $C):1}, map{collation-key("a",
                  $C):2}), map{"duplicates":"use-last"})(collation-key("A", $C))</fos:expression>
               <fos:result>2</fos:result>
               <fos:postamble>Given that the keys of the two entries are equal under the rules of
                  the chosen collation, only one of the entries can appear in the result; the one
                  that is chosen is the one from the last map in the input sequence.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test use="v-collation-key-C">
               <fos:expression>let $M := map{collation-key("A", $C):1, collation-key("B", $C):2}
                  return $M(collation-key("a", $C))</fos:expression>
               <fos:result>1</fos:result>
               <fos:postamble>The strings "A" and "a" have the same collation key under this
                  collation.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <p>As the above examples illustrate, it is important that when the
               <code>collation-key</code> function is used to add entries to a map, then it must
               also be used when retrieving entries from the map. This process can be made less
               error-prone by encapsulating the map within a function: <code>function($k)
                  {$M(collation-key($k, $collation)}</code>.</p>
         </fos:example>
      </fos:examples>
   </fos:function>
   <!--
   <fos:function name="parse-json" prefix="fn" diff="add" at="MAP">
      <fos:signatures>
         <fos:proto name="parse-json" return-type="item()?">
            <fos:arg name="json-text" type="xs:string"/>
         </fos:proto>
         <fos:proto name="parse-json" return-type="item()?">
            <fos:arg name="json-text" type="xs:string"/>
            <fos:arg name="options" type="map(*)"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Parses a string supplied in the form of a JSON text, returning the results in the form
            of a map.</p>
      </fos:summary>
      <fos:rules>
         <p>The effect of the one-argument form of this function is the same as calling the
            two-argument form with an empty map as the value of the <code>$options</code>
            argument.</p>

         <p>The first argument is a JSON-text (see below) in the form of a string. The function
            parses this string to return an XPath value.</p>

         <p>The <code>$options</code> argument can be used to control the way in which the parsing
            takes place. The value of the argument is a map. The options defined in this 
            specification have keys that are strings. The effect of any map entries whose 
            keys are not defined in this specification is implementation-defined; 
            implementation-defined options <rfc2119>should</rfc2119> use QNames as keys. 
            Implementations <rfc2119>must</rfc2119> ignore any entries in the map whose keys 
            are not defined in this specification, unless the key has a specific 
            <termref def="dt-implementation-defined">implementation-defined</termref> meaning. </p>

         <p>If the <code>$options</code> map contains an entry whose key is the <code>xs:string</code>
            value "spec", the
            value determines the specification of JSON that is to be used. The value <rfc2119>must</rfc2119>
            be a string; the effect of supplying any value other than <code>"RFC4627"</code>, <code>"ECMA-404"</code>, or <code>"liberal"</code> is
            <termref def="dt-implementation-defined"/>. </p>
            
            <ulist>
               <item><p>The value <code>"RFC4627"</code>
               denotes <bibref ref="rfc4627"/>, with no deviations from the grammar permitted.</p></item>
               <item><p>The value <code>"ECMA-404"</code>
                  denotes the specification in <bibref ref="ecma-404"/> (section 15.12 in the 5th Edition).</p></item>
               <item><p>The value
                  <code>"liberal"</code> indicates any implementation-defined superset of RFC4627 (or equivalently, an
                  implementation that recovers from some or all errors in the input). </p></item>
            </ulist>
            <p>The default is <code>"RFC4627"</code>.</p>

         <p>If the <code>$options</code> map contains an entry with the key <code>"unescape"</code>,
            the value determines whether escape sequences (marked by a backslash) in the input are
            expanded. The value is a boolean: <code>true</code> indicates that escape sequences are
            expanded into the characters they represent, while <code>false</code> indicates that
            they remain as escape sequences. The default is <code>true</code>. If the value is
               <code>true</code> and the input contains escape sequences representing characters or
            codepoints that are not valid characters in the version of XML supported by the
            implementation, <phrase diff="chg" at="N">such characters are replaced by the Unicode
            replacement character (xFFFD), or as described in the next paragraph</phrase>.</p>
         
         <p diff="add" at="N">If the <code>$options</code> map contains an entry with the key <code>"fallback"</code>,
         the value must be a function with the signature <code>function(xs:string) as xs:string</code>. If present, then when
         an invalid character is encountered, as described in the previous paragraph, this function is called supplying the
         escaped form of the character as the argument. The function returns a string which is inserted into the result in
         place of the invalid character. The function also has the option of raising a dynamic error.</p>

         <p>The various structures that can occur in JSON are transformed recursively to XDM values
            as follows:</p>

         <olist>
            <item>
               <p>A JSON <emph>object</emph> is converted to a map. <phrase diff="del" at="N">The collation of the map is the
                  Unicode codepoint collation. </phrase>The entries in the map correspond to the key/value
                  pairs in the JSON object. The key is always of type <code>xs:string</code>; the
                  associated value may be of any type, and is the result of converting the JSON
                  value by recursive application of these rules. For example, the JSON text
                     <code>{"x":2, "y":5}</code> is transformed to the <phrase diff="chg" at="N">XDM map value <code>map{"x":2,
                     "y":5}</code></phrase>.</p>
               <p diff="add" at="O">If the JSON object contains duplicate keys, then all duplicates except the last are ignored.</p>
            </item>
            <item>
               <p>A JSON <emph>array</emph> is transformed to a map whose keys are consecutive
                  integers starting at one, and whose associated values are the result of converting
                  the corresponding member of the array by recursive application of these rules. For
                  example, the JSON text <code>["a", "b", null]</code> is transformed to the <phrase diff="chg" at="N">XDM map value
                     <code>map{1:"a", 2:"b", 3:()}</code></phrase>.</p>
               
               <p diff="del" at="N">The collation of the map is a special collation with the URI 
                  <code>http://www.w3.org/2005/xpath-functions/collation/integer-map</code>, 
                  which is intended to be used only for a map having integer keys. 
                  The use of this collation distinguishes an map representing an empty 
                  JSON array from a map representing an empty JSON object. This 
                  collation is not intended to be used when comparing strings; if it 
                  ever is so used, the result of string comparisons is <termref def="dt-implementation-dependent">implementation-dependent</termref>. </p>
               <issue><p>We need a way to distinguish an empty map from an empty array. Work on arrays is ongoing.
               A possibility is to make array a subtype of map.</p></issue>
            </item>
            <item>
               <p>A JSON <emph>string</emph> is converted to an <code>xs:string</code> value. If the
                     <code>unescape</code> option is set to <code>true</code> (or omitted), then
                  escaped characters are expanded (for example, <code>\n</code> becomes a single x0A
                  character, while <code>\u20AC</code> becomes the character <code>&#x20ac;</code>),
                  provided that the expansion is a valid XML character. A character that is not
                  valid in the version of XML used by the processor is then a dynamic error. If the
                     <code>unescape</code> option is set to <code>false</code>, escaped characters
                  are retained in their escaped form, and no error can then occur.</p>
            </item>
            <item>
               <p>A JSON <emph>number</emph> is converted to an <code>xs:double</code> value using
                  the rules for casting from <code>xs:string</code> to <code>xs:double</code>.</p>
            </item>
            <item>
               <p>The JSON <emph>boolean</emph> values <code>true</code> and <code>false</code> are
                  converted to the corresponding <code>xs:boolean</code> values.</p>
            </item>
            <item>
               <p>The JSON value <emph>null</emph> is converted to the empty sequence.</p>
            </item>
         </olist>


      </fos:rules>
      <fos:errors>

         <p><error  spec="XT" type="dynamic" class="DE" code="3240">
            <p>It is a <termref def="dt-dynamic-error"><phrase diff="del" at="N">non-recoverable</phrase> dynamic
            error</termref> if the value of
               <code>$input</code> does not conform to the JSON grammar, as selected using the
            explicit or implicit <code>spec</code> option.</p></error></p>
         
         <p><error  spec="XT" type="dynamic" class="DE" code="3250">
            <p>It is a <termref def="dt-dynamic-error"><phrase diff="del" at="N">non-recoverable</phrase> dynamic
               error</termref> if the value of
               <code>$input</code> contains an escaped representation of a character (or codepoint)
            that is not a valid character in the version of XML supported by the implementation,
            unless the <code>unescape</code> option is set to false.</p></error></p>
         <p><error  spec="XT" type="dynamic" class="DE" code="3260">
            <p>It is a <termref def="dt-dynamic-error"><phrase diff="del" at="N">non-recoverable</phrase> dynamic
               error</termref> if the value of
            <code>$options</code> includes an entry whose key is <code>"spec"</code> and whose value is not
            a single <code>xs:string</code>, or an entry whose key is <code>"unescape"</code> and whose value
            is not a single <code>xs:boolean</code>.</p></error></p>
      </fos:errors>
      <fos:notes>
         <p>To read a JSON file, this function can be
            used in conjunction with the <xfunction>unparsed-text</xfunction> function.</p>
         <p>ECMA-404 differs from RFC 4627 in two respects: it does not allow the input to depart
            from the JSON grammar, but it does allow the top-level construct in the input to be a
            string, boolean, number, or null, rather than requiring an object or array.</p>
         <p>Many JSON implementations allow commas to be used after the last item in an object or
            array, although the specification does not permit it. The option
               <code>spec="liberal"</code> is provided to allow such deviations from the
            specification to be accepted. Some JSON implementations also allow constructors such as
               <code>new Date("2000-12-13")</code> to appear as values: specifying
               <code>spec="liberal"</code> allows such extensions to be accepted, but does not
            guarantee it. If such extensions are accepted, the resulting value is
            implementation-defined.</p>
         <p>The result of the function will be an instance of one of the following types. An
               <code>instance of</code> test (or in XQuery, <code>typeswitch</code>) can 
            in most cases be used to distinguish them: </p>
         <ulist>
            <item>
               <p><code>map(xs:string, xs:anyAtomicType)</code> for a JSON object</p>
            </item>
            <item>
               <p><code>map(xs:integer, xs:anyAtomicType)</code> for a JSON array</p>
            </item>
            <item>
               <p><code>xs:string</code> for a JSON string</p>
            </item>
            <item>
               <p><code>xs:double</code> for a JSON number</p>
            </item>
            <item>
               <p><code>xs:boolean</code> for a JSON boolean</p>
            </item>
            <item>
               <p><code>empty-sequence()</code> for a JSON null</p>
            </item>
         </ulist>
         <p>The only exception is that an empty map might represent either an empty JSON object or 
         an empty JSON array.<phrase diff="del" at="N"> These can be distinguished if need be by the special collation used
         to represent an empty array.</phrase></p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>parse-json('{"x":1, "y":[3,4,5]}')</fos:expression>
               <fos:result>map{"x":1e0,"y":map{1:3e0,2:4e0,3:5e0}}</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>parse-json('"abcd"', {'spec':'RFC4627'})</fos:expression>
               <fos:error-result error-code="FOJS0001"/>
            </fos:test>
            <fos:test>
               <fos:expression>parse-json('"abcd"', {'spec':'ECMA-404'})</fos:expression>
               <fos:result>"abcd"</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>parse-json('{"x":"\\", "y":"\u0025"}')</fos:expression>
               <fos:result>map{"x":"\","y":"%"}</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>parse-json('{"x":"\\", "y":"\u0025"}',
                  {'unescape':false()})</fos:expression>
               <fos:result>map{"x":"\\","y":"\u0025"}</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <p diff="add" at="O">The following example illustrates use of the fallback function to handle characters
            that are invalid in XML.</p>
            <eg diff="add" at="O"><![CDATA[
 <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:err="http://example.com/ns/errors"
                xmlns:f="http://example.com/ns/functions"
                xmlns:xs="http://www.w3.org/2001/XMLSchema"
                exclude-result-prefixes="xs err f"
                version="3.0">

<xsl:template match="someElement">
  <xsl:variable name="jsonstr" 
                select="unparsed-text('http://example.com/endpoint')"/>
  <xsl:variable name="options" 
                select="map{'spec':'liberal', 'fallback':f:convert#1}"/>
  <xsl:variable name="json" 
                select="parse-json($jsonstr, $options)"/>

  <!- - now do something with that json - ->
</xsl:template>

<xsl:function name="f:convert" as="xs:string">
  <xsl:param name="char" as="xs:string"/>
    <xsl:variable name="c0chars" select="{
     '\u0000':'[NUL]',
     '\u0001':'[SOH]',
     '\u0002':'[STX]',
     ...
     '\u001E':'[RS]',
     '\u001F':'[US]'}"/>
  <xsl:variable name="replacement" select="$c0chars($char)"/>
  <xsl:sequence select="if (exists($replacement)) then $replacement
      else error(xs:QName('err:invalid-char'),
                  concat('Error: ', $char, ' is not a terminal control char.'))"/>
</xsl:function>
</xsl:stylesheet>]]></eg>
         </fos:example>
      </fos:examples>
   </fos:function>-->

   <fos:function name="json-to-xml" prefix="fn" diff="add" at="O">
      <fos:signatures>
         <fos:proto name="json-to-xml" return-type="document-node()">
            <fos:arg name="json-text" type="xs:string"/>
         </fos:proto>
         <fos:proto name="json-to-xml" return-type="document-node()">
            <fos:arg name="json-text" type="xs:string"/>
            <fos:arg name="options" type="map(*)" usage="inspection"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>nondeterministic</fos:property>
         <fos:property dependency="static-base-uri">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Parses a string supplied in the form of a JSON text, returning the results in the form
            of an XML <phrase diff="chg" at="P">document node</phrase>.</p>
      </fos:summary>
      <fos:rules>
         <p>The effect of the one-argument form of this function is the same as calling the
            two-argument form with an empty map as the value of the <code>$options</code>
            argument.</p>

         <p>The first argument is a JSON-text (see below) in the form of a string. The function
            parses this string to return an XDM node.</p>

         <p>The <code>$options</code> argument can be used to control the way in which the parsing
            takes place. The value of the argument is a map. The options defined in this
            specification have keys that are strings. The effect of any map entries whose keys are
            not defined in this specification is implementation-defined; implementation-defined
            options <rfc2119>should</rfc2119> use QNames as keys. Implementations
               <rfc2119>must</rfc2119> ignore any entries in the map whose keys are not defined in
            this specification, unless the key has a specific <termref
               def="dt-implementation-defined">implementation-defined</termref> meaning. </p>

         <p>The entries that may appear in the <code>$options</code> map are as follows. The keys
            are <code>xs:string</code> values:</p>

         <table class="data">
            <thead>
               <tr>
                  <th>Key</th>
                  <th>Value</th>
                  <th>Meaning</th>
               </tr>
            </thead>
            <tbody>
               <tr diff="chg" at="R-bug23594">
                  <td rowspan="3">
                     <code>liberal</code>
                  </td>
                  <td colspan="2">Determines whether deviations from the syntax of RFC7159 are permitted. The value
                     <rfc2119>must</rfc2119> be a boolean.</td>
               </tr>
               <tr>
                  <td>
                     <code>false</code>
                  </td>
                  <td>The input <rfc2119>must</rfc2119> consist of an optional byte order mark (which is ignored) followed by a string
                     that conforms to the grammar of <code>JSON-text</code> in <bibref ref="rfc7159"/>. 
                     An error <rfc2119>must</rfc2119> be raised
                     (see below) if the input does not conform to the grammar.</td>
               </tr>
               <tr>
                  <td>
                     <code>true</code>
                  </td>
                  <td>The input <rfc2119>may</rfc2119> contain deviations from the grammar of <bibref ref="rfc7159"/>,
                     which are handled in an <termref def="dt-implementation-defined"/> way. (Note: some popular
                     extensions include allowing quotes on keys to be omitted, allowing a comma
                     to appear after the last item in an array, allowing leading zeroes in numbers, and allowing control characters such as
                     tab and newline to be present in unescaped form.) Since the extensions accepted
                     are implementation-defined, an error <rfc2119>may</rfc2119> be raised
                     (see below) if the input does not conform to the grammar.</td>
               </tr>
               
               <tr>
                  <td rowspan="3">
                     <code>validate</code>
                  </td>
                  <td colspan="2">If the <code>$options</code> map contains an entry with the key
                        <code>"validate"</code>, then the value <rfc2119>must</rfc2119> be an
                        <code>xs:boolean</code>. The default is <code>true</code> for a schema-aware
                     processor, <code>false</code> for a non-schema-aware processor. If the value
                        <code>true</code> is supplied and the processor is not schema-aware, a
                     dynamic error results <errorref spec="XT" class="DE" code="3245"/>. It is not
                     necessary that the containing stylesheet should import the relevant
                     schema.</td>
               </tr>
               <tr>
                  <td>
                     <code>true</code>
                  </td>
                  <td>Indicates that the resulting XDM instance must be typed; that is, the element
                     and attribute nodes must carry the type annotations that result from validation
                     against the schema given at <specref ref="schema-for-json"/>, or against an
                        <termref def="dt-implementation-defined"/> schema if the <phrase diff="chg" at="r-bug23594"><code>liberal</code>
                     option has the value <code>yes</code></phrase>.</td>
               </tr>
               <tr>
                  <td>
                     <code>false</code>
                  </td>
                  <td>Indicates that the XDM instance must be untyped.</td>
               </tr>
               <tr>
                  <td rowspan="3">
                     <code>escape</code>
                  </td>
                  <td colspan="2">Determines whether special characters are represented in the XDM output 
                     in backslash-escaped form. 
                     The required type is <code>xs:boolean</code>.
                  </td>
               </tr>
               <tr>
                  <td>
                     <phrase diff="chg" at="D"><code>false</code> (default)</phrase>
                  </td>
                  <td diff="chg" at="D">All characters in the input that are valid
                     in the version of XML supported by the implementation, whether or not they are represented 
                     in the input by means of an escape sequence, are represented as unescaped characters in the result. Any
                     characters or codepoints that are not valid XML characters 
                     (for example, unpaired surrogates) <phrase diff="add" at="D">are passed to the <code>fallback</code> function
                        as described below; in the absence of a fallback function, they are replaced by
                        the Unicode <code>REPLACEMENT CHARACTER</code> (<code>xFFFD</code>)</phrase>.
                     The attributes <code>escaped</code> and <code>escaped-key</code> will not be present in the XDM output.</td>
               </tr>
               <tr>
                  <td>
                     <phrase><code>true</code></phrase>
                  </td>
                  <td>JSON escape sequences are used in the result to represent special characters in the JSON input, as defined below, 
                     whether or not they were represented using JSON escape sequences in the input.
                     The characters that are considered "special" for this purpose are:
                     <ulist>
                        <item><p>all codepoints in the range <code>x00</code> to <code>x1F</code> 
                           or <code>x7F</code> to <code>x9F</code>;</p></item>
                        <item><p>all codepoints that do not represent characters that are valid in the version of XML supported by the processor,
                           including codepoints representing unpaired surrogates;</p></item>
                        <item><p>the backslash character itself (<code>x5C</code>).</p></item>
                     </ulist>
                     
                     Such characters are represented using a two-character
                     escape sequence where available (for example, <code>\t</code>), or a six-character escape sequence otherwise
                     (for example <code>\uDEAD</code>). Characters other than these will not be escaped in the result,
                     even if they were escaped in the input. In the result:
                     
                     <ulist>
                        <item><p>Any <code>string</code> element whose string value contains a
                           backslash character must have the attribute value <code>escaped="true"</code>.</p></item>
                        <item><p>Any element that contains a <code>key</code> attribute whose string value
                           contains a backslash character must have the attribute
                           <code>escaped-key="true"</code>.</p></item>
                        <item><p>The values of the <code>escaped</code> and
                           <code>escaped-key</code> attributes are immaterial when there is no backslash
                           present, and it is never necessary to include either attribute when its value
                           is <code>false</code>.</p></item>
                     </ulist></td>
                  
                  
               </tr>
               <tr>
                  <td rowspan="2">
                     <code>fallback</code>
                  </td>
                  <td colspan="2">Provides a function which is called when an invalid character is
                     encountered.</td>
               </tr>
               <tr>
                  <td>Function with signature <code>function(xs:string) as xs:string</code></td>
                  <td>When an invalid character is encountered this function is called supplying the
                     escaped form of the character as the argument. The function returns a string
                     which is inserted into the result in place of the invalid character. The
                     function also has the option of raising a dynamic error.</td>
               </tr>
            </tbody>
         </table>


         <p>The various structures that can occur in JSON are transformed recursively to XDM values
            according to the rules given in <specref ref="json-to-xml-mapping"/>.</p>

         <p>The function returns <phrase diff="add" at="P">a document node, whose only child
               is</phrase> the element node representing the outermost construct in the JSON
            text.</p>

         <p>The function is not <xtermref spec="FO30" ref="dt-deterministic"
               >deterministic</xtermref>: that is, if the function is called twice with the same
            arguments, it is <termref def="dt-implementation-dependent"
               >implementation-dependent</termref> whether the same node is returned on both
            occasions.</p>

         <p>The base URI of the returned document node is taken from the static base URI of the
            function call.</p>

      </fos:rules>
      <fos:errors>

         <p>
            <error spec="XT" type="dynamic" class="DE" code="3240">
               <p>It is a <termref def="dt-dynamic-error">dynamic error</termref> if the value of
                     <code>$input</code> does not conform to the JSON grammar<phrase diff="chg" at="R-bug23594"> as defined
               by <bibref ref="rfc7159"/>, allowing implementation-defined extensions
               if the <code>liberal</code> option is set to <code>yes</code></phrase>.</p>
            </error>
         </p>
         <p diff="add" at="P">
            <error spec="XT" type="dynamic" class="DE" code="3245">
               <p>It is a <termref def="dt-dynamic-error">dynamic error</termref> if the value of
                  the <code>validate</code> option is <code>true</code> and the processor is not
                  schema-aware.</p>
            </error>
         </p>
         <p>
            <error spec="XT" type="dynamic" class="DE" code="3250">
               <p>It is a <termref def="dt-dynamic-error">dynamic error</termref> if the value of
                     <code>$input</code> contains an escaped representation of a character (or
                  codepoint) that is not a valid character in the version of XML supported by the
                  implementation, unless the <code>unescape</code> option is set to false.</p>
            </error>
         </p>
         <p>
            <error spec="XT" type="dynamic" class="DE" code="3260">
               <p>It is a <termref def="dt-dynamic-error">dynamic error</termref> if the value of
                  <code>$options</code> includes an entry whose key is <phrase diff="chg" at="R-bug23594"><code>liberal</code>, 
                  <code>validate</code>, <code>unescape</code>, or <code>fallback</code>,
                  and whose value is not a permitted value for that key</phrase>.</p>
            </error>
         </p>
      </fos:errors>
      <fos:notes>
         <p>To read a JSON file, this function can be used in conjunction with the
               <xfunction>unparsed-text</xfunction> function.</p>
         <p diff="del" at="R-bug23594">ECMA-404 differs from RFC 4627 in two respects: it does not allow the input to depart
            from the JSON grammar, but it does allow the top-level construct in the input to be a
            string, boolean, number, or null, rather than requiring an object or array.</p>
         <p>Many JSON implementations allow commas to be used after the last item in an object or
            array, although the specification does not permit it. The option
               <code>spec="liberal"</code> is provided to allow such deviations from the
            specification to be accepted. Some JSON implementations also allow constructors such as
               <code>new Date("2000-12-13")</code> to appear as values: specifying
               <code>spec="liberal"</code> allows such extensions to be accepted, but does not
            guarantee it. If such extensions are accepted, the resulting value is
            implementation-defined, and will not necessarily conform to the schema at <specref
               ref="schema-for-json"/>.</p>

      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>json-to-xml('{"x": 1, "y": [3,4,5]}')</fos:expression>
               <fos:result><![CDATA[
<map xmlns="http://www.w3.org/2005/xpath-functions">
  <number key="x">1</number>
  <array key="y">
   <number>3</number>
   <number>4</number>
   <number>5</number>
  </array>
</map>]]></fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>json-to-xml('"abcd"', map{'liberal': false()})</fos:expression>
               <fos:result><![CDATA[<string xmlns="http://www.w3.org/2005/xpath-functions">abcd</string>]]></fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>json-to-xml('{"x": "\\", "y": "\u0025"}')</fos:expression>
               <fos:result><![CDATA[
<map xmlns="http://www.w3.org/2005/xpath-functions">
  <string key="x">\</string>
  <string key="y">%</string>
</map>]]></fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>json-to-xml('{"x": "\\", "y": "\u0025"}', map{'escape': true()})</fos:expression>
               <fos:result><![CDATA[
<map xmlns="http://www.w3.org/2005/xpath-functions">
  <string escaped="true" key="x">\\</string>
  <string key="y">%</string>
</map>]]></fos:result>
               <fos:postamble>But see the detailed rules for alternative values of the <code>escaped</code> attribute
                  on the second <code>string</code> element.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <p>The following example illustrates use of the fallback function to
               handle characters that are invalid in XML.</p>
            <eg diff="add" at="D"><![CDATA[
 let 
   $jsonstr := unparsed-text('http://example.com/endpoint'),
   $options := map {
     'liberal': true(),
     'fallback': function($char as xs:string) as xs:string {
       let 
         $c0chars := map {
           '\u0000':'[NUL]',
           '\u0001':'[SOH]',
           '\u0002':'[STX]',
           ...
           '\u001E':'[RS]',
           '\u001F':'[US]'
         },
         $replacement := $c0chars($char)
      return 
        if (exists($replacement))
        then $replacement
        else error(xs:QName('err:invalid-char'), 
          'Error: ' || $char || ' is not a C0 control character.')
     }
   }
 return json-to-xml($jsonstr, $options)]]></eg>
         </fos:example>
      </fos:examples>
  
   </fos:function>
   
   <fos:function name="xml-to-json" prefix="fn" diff="chg" at="T-bug29602">
      <fos:signatures>
         <fos:proto name="xml-to-json" return-type="xs:string?">
            <fos:arg name="input" type="node()?" usage="absorption"/>
         </fos:proto>
         <fos:proto name="xml-to-json" return-type="xs:string?">
            <fos:arg name="input" type="node()?" usage="absorption"/>
            <fos:arg name="options" type="map(*)" usage="inspection"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Converts an XML tree, whose format corresponds to the XML representation of JSON defined
            in this specification, into a string conforming to the JSON grammar.</p>
      </fos:summary>
      <fos:rules>
         <p>The effect of the one-argument form of this function is the same as calling the
            two-argument form with an empty map as the value of the <code>$options</code>
            argument.</p>
         
         <p>The first argument <code>$input</code> is a node; the subtree rooted at this node will typically be
            the XML representation of a JSON document as defined in <specref ref="json-to-xml-mapping"/>.</p>
         
         <p>If <code>$input</code> is the empty sequence, the function returns the empty sequence.</p>
         
         <p diff="chg" at="D">The <code>$options</code> argument can be used to control the way in which the conversion
            takes place. The <termref def="option-parameter-conventions">option parameter conventions</termref> apply.</p>
         
         <p>The entries that may appear in the <code>$options</code> map are as follows:</p>
         
         <table class="data">
            <thead>
               <tr>
                  <th>Key</th>
                  <th>Value</th>
                  <th>Meaning</th>
               </tr>
            </thead>
            <tbody>
               <tr>
                  <td rowspan="3">
                     <code>indent</code>
                  </td>
                  <td colspan="2">Determines whether additional whitespace should be added to the output to improve readability. 
                     The required type is <code>xs:boolean</code>.</td>
               </tr>
               <tr>
                  <td>
                     <code>false</code>
                  </td>
                  <td>The processor must not insert any insignificant whitespace between JSON tokens.</td>
               </tr>
               <tr>
                  <td>
                     <code>true</code>
                  </td>
                  <td>The processor <rfc2119>may</rfc2119> insert whitespace between JSON tokens in order to improve readability.
                     The specification imposes no constraints on how this is done.</td>
               </tr>
               
               
            </tbody>
         </table>
         
         <p>The node supplied as <code>$input</code> must be one of the following: <xerrorref spec="FO31" class="JS" code="0006"/></p>
         
         <olist>
            <item><p>An element node whose name matches the name of a global element declaration in the schema given in 
               <specref ref="schema-for-json"/> and whose type annotation matches the type of that element declaration
               (indicating that the element has been validated against this schema).</p></item>
            <item><p>An element node whose name matches the name of a global element declaration in the schema given in 
               <specref ref="schema-for-json"/>, 
               <phrase diff="del" at="D">whose type annotation is <code>xs:untyped</code>, </phrase>and whose content
               after stripping all attributes (at any depth) in namespaces other than <code>http://www.w3.org/2005/xpath-functions</code>
               is such that validation against the schema given in <specref ref="schema-for-json"/> would succeed.</p>
               <note><p>The reason attributes in alien namespaces are stripped is to avoid the need for a non-schema-aware
                  processor to take into account the effect of attributes such as <code>xsi:type</code> and <code>xsi:nil</code>
                  that would affect the outcome of schema validation.</p></note>
            </item>
            <item diff="add" at="T-bug29917"><p>An element node <var>E</var> having a <code>key</code> attribute and/or an <code>escaped-key</code> attribute 
               provided that <var>E</var> would satisfy one of the above
               conditions if the <code>key</code> and/or <code>escaped-key</code> attributes were removed.</p></item>             
            
            <item><p>A document node having exactly one element child and no text node children, 
               where the element child satisfies any of the conditions above.</p></item>
         </olist>
         
         <p diff="add" at="T-bug29588">Furthermore, <code>$input</code> must satisfy the following constraint
            (which cannot be conveniently expressed in the schema). Every element <var>M</var> that is a descendant-or-self of 
            <code>$input</code> and has local name <code>map</code> and namespace URI <code>http://www.w3.org/2005/xpath-functions</code>
            must satisfy the following rule: there must not be two distinct children of <var>M</var> (say <var>C1</var> and <var>C2</var>) 
            such that the normalized key of <var>C1</var> is equal to the normalized key of <var>C2</var>. The normalized key 
            of an element <var>C</var> is as follows:</p>
         
         <ulist diff="add" at="T-bug29588">
            <item><p>If <var>C</var> has the attribute value <code>escaped-key="true"</code>, then the value of the 
               <code>key</code> attribute of <var>C</var>, with all JSON escape sequences replaced by the corresponding Unicode characters 
               according to the JSON escaping rules.
            </p></item>
            <item><p>Otherwise (the <code>escaped-key</code> attribute of <var>C</var> is absent or set to false), 
               the value of the <code>key</code> attribute of <var>C</var>.</p></item>
         </ulist>
         
         <p>Nodes in the input tree are handled by applying the following rules, recursively. In these rules the term
            "an element named <var>N</var>" means "an element node whose local name is <var>N</var> and whose namespace URI is 
            <code>http://www.w3.org/2005/xpath-functions</code>".</p>
         
         <olist>
            <item><p>A document node having a single element node child is processed by processing that child.</p></item>
            <item><p>An element named <code>null</code> results in the output <code>null</code>.</p></item>
            <item><p>An element <code>$E</code> named <code>boolean</code> results in the output <code>true</code> or <code>false</code>
               depending on the result of <phrase diff="chg" at="D"><code>xs:boolean(fn:string($E))</code></phrase>.</p></item>
            <item><p>An element <code>$E</code> named <code>number</code> results in the output of the string 
               <phrase diff="chg" at="D">result of <code>xs:string(xs:double(fn:string($E)))</code></phrase>
            </p>
            </item>
            <item><p>An element named <code>string</code> results in the output of the string value of the element, enclosed in
               quotation marks, with any special characters in the string escaped as described below.</p></item>
            <item><p>An element named <code>array</code> results in the output of the children of the <code>array</code> element, 
               each processed by applying these rules recursively: the items in the resulting list are enclosed between square brackets, 
               and separated by commas.</p></item>
            <item><p>An element named <code>map</code> results in the output of a sequence of map entries corresponding to 
               the children of the <code>map</code> element, enclosed between curly braces and separated by commas. 
               Each entry comprises the value of the <code>key</code> attribute of the child element, enclosed in quotation marks 
               and escaped as described below, followed by a colon, followed by the result of processing the child element 
               by applying these rules recursively.</p>
            </item>
            <item><p>Comments, processing instructions, and whitespace text node children of <code>map</code> and <code>array</code>
               are ignored.</p></item>
            
         </olist>
         
         <p>Strings are escaped as follows:</p>
         
         <olist>
            <item><p>If the attribute <code>escaped="true"</code> is present for a string value, or <code>escaped-key="true"</code> for a key value, then:</p>
               
               <olist>
                  <item><p>any valid JSON escape sequence present in the string is copied unchanged to the output;</p></item>
                  
                  <item><p>any invalid JSON escape sequence results in a dynamic error <xerrorref spec="FO31" class="JS" code="0007"/>;</p></item>
                  
                  <item><p>any unescaped occurrence of quotation mark, backspace, form-feed, newline, carriage return, tab, <phrase diff="add" at="T-bug29665">or solidus</phrase> is replaced by
                     <code>\"</code>, <code>\b</code>, <code>\f</code>, <code>\n</code>, <code>\r</code>, <code>\t</code> <phrase diff="add" at="T-bug29665">or <code>\/</code></phrase> respectively; </p></item>
                  
                  <item><p>any other codepoint in the range 1-31 or 127-159 is replaced by an escape in the form \uHHHH where HHHH 
                     is the upper-case hexadecimal representation of the codepoint value.</p></item>
               </olist>
            </item>
            <item><p>Otherwise (that is, in the absence of the attribute <code>escaped="true"</code> for a string value, 
               or <code>escaped-key="true"</code> for a key value):</p>
               
               <olist>
                  <item><p>any occurrence of backslash is replaced by <code>\\</code></p></item>
                  
                  <item><p>any occurrence of quotation mark, backspace, form-feed, newline, carriage return, or tab is 
                     replaced by <code>\"</code>, <code>\b</code>, <code>\f</code>, <code>\n</code>, <code>\r</code>, or <code>\t</code> respectively; </p></item>
                  
                  <item><p>any other codepoint in the range 1-31 or 127-159 is replaced by an escape in 
                     the form <code>\uHHHH</code> where <code>HHHH</code> is the upper-case hexadecimal representation of the codepoint value.</p></item>
               </olist>
            </item>
         </olist>
         
      </fos:rules>
      <fos:errors>
         
         <p>A dynamic error is raised <xerrorref spec="FO31" class="JS" code="0005"/> if the value of
            <code>$options</code> includes an entry whose key is defined in this specification, 
            and whose value is not a permitted value for that key.</p>
         
         <p>A dynamic error is raised <xerrorref spec="FO31" class="JS" code="0006"/> if the value of
            <code>$input</code> is not a document or element node or is not valid according to the schema for the XML representation of
            JSON<phrase diff="add" at="T-bug29588">, or if a <code>map</code> element has two children whose normalized key values are the same.</phrase></p>
         
         
         
         <p>A dynamic error is raised <xerrorref spec="FO31" class="JS" code="0007"/> if the value of
            <code>$input</code> includes a string labeled with <code>escaped="true"</code>, or
            a key labeled with <code>escaped-key="true"</code>, where the content of the string or key
            contains an invalid JSON escape sequence: specifically, where it contains a backslash (<code>\</code>) that is not followed by one
            of the characters <code>"</code>, <code>\</code>, <code>/</code>, <code>b</code>, <code>f</code>, <code>n</code>, 
            <code>r</code>, <code>t</code>, or <code>u</code>, or or where it contains the characters <code>\u</code>
            not followed by four hexadecimal digits (that is <code>[0-9A-Fa-f]{4}</code>).
         </p>
         
      </fos:errors>
      <fos:notes>
         <p>The rule requiring schema validity has a number of consequences, including the following:</p>
         <olist>
            <item><p>The input cannot contain no-namespace attributes, or attributes in the namespace <code>http://www.w3.org/2005/xpath-functions</code>,
               except where explicitly allowed by the schema. Attributes in other namespaces, however, are ignored.</p></item>
            <item><p>Nodes that do not affect schema validity, such as comments, processing instructions, namespace nodes, and whitespace text node
               children of <code>map</code> and <code>array</code>, are ignored.</p></item>
            <item><p>Numeric values are restricted to those that are valid in JSON: 
               the schema disallows positive and negative infinity and NaN.</p></item>
            <item><p>Duplicate keys within a map are disallowed. <phrase diff="add" at="T-bug29588">Most cases of duplicate keys are prevented by the rules in the schema; 
               additional cases (where the keys are equal only after expanding JSON escape sequences) are prevented by the prose rules 
               of this function. For example, the key values <code>\n</code> and <code>\u000A</code> are treated as duplicates even though
               the rules in the schema do not treat them as such.</phrase></p></item>
         </olist>
         <p diff="add" at="T-bug29917">The rule allowing the top-level element to have a <code>key</code> attribute (which is ignored)
            allows any element in the output of the <code>fn:json-to-xml</code> function
            to be processed: for example, it is possible to take a JSON document, convert it to XML, select
            a subtree based on the value of a <code>key</code> attribute, and then convert this subtree
            back to JSON, perhaps after a transformation. The rule means that an element with the appropriate name will be 
            accepted if it has been validated against one of the 
            types <code>mapWithinMapType</code>, <code>arrayWithinMapType</code>, <code>stringWithinMapType</code>, 
            <code>numberWithinMapType</code>, <code>booleanWithinMapType</code>, or <code>nullWithinMapType</code>.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <p>The input <code><![CDATA[<array xmlns="http://www.w3.org/2005/xpath-functions"><number>1</number><string>is</string><boolean>1</boolean></array>]]></code>
               produces the result <code>[1,"is",true]</code>.</p>
         </fos:example>
         <fos:example>
            <p>The input <code><![CDATA[<map xmlns="http://www.w3.org/2005/xpath-functions"><number key="Sunday">1</number><number key="Monday">2</number></map>]]></code>
               produces the result <code>{"Sunday":1,"Monday":2}</code>.</p>
         </fos:example>
      </fos:examples>
   </fos:function>
   
 
   <fos:function name="function-available" prefix="fn">
      <fos:signatures>
         <fos:proto name="function-available" return-type="xs:boolean">
            <fos:arg name="function-name" type="xs:string"/>
         </fos:proto>
         <fos:proto name="function-available" return-type="xs:boolean">
            <fos:arg name="function-name" type="xs:string"/>
            <fos:arg name="arity" type="xs:integer"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property dependency="namespaces known-function-signatures">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Determines whether a particular function is or is not available for use. The function is
            particularly useful for calling within an <code>[xsl:]use-when</code> attribute (see
               <specref ref="conditional-inclusion"/>) to test whether a particular <termref
               def="dt-extension-function"/> is available.</p>
      </fos:summary>
      <fos:rules>

         <p>A function is said to be available within an XPath expression if it is present in the
               <xtermref spec="XP30" ref="dt-known-func-signatures">statically known function
               signatures</xtermref> for that expression (see <specref ref="static-context"/>).
            Functions in the static context are uniquely identified by the name of the function (a
            QName) in combination with its <termref def="dt-arity">arity</termref>.</p>
         <p>The value of the <code>$function-name</code> argument <rfc2119>must</rfc2119> be a
            string containing an <termref def="dt-eqname">EQName</termref>. The lexical QName is
            expanded into an <termref def="dt-expanded-qname">expanded QName</termref> using the
            namespace declarations in scope for the <termref def="dt-expression"
               >expression</termref>. If the value is an unprefixed lexical QName, then the <termref
               def="dt-standard-function-namespace">standard function namespace</termref> is used in
            the expanded QName.</p>
         <p>The two-argument version of the <function>function-available</function> function returns
            true if and only if there is an available function whose name matches the value of the
               <code>$function-name</code> argument and whose <termref def="dt-arity"
               >arity</termref> matches the value of the <code>$arity</code> argument. </p>
         <p>The single-argument version of the <function>function-available</function> function
            returns true if and only if there is at least one available function (with some arity)
            whose name matches the value of the <code>$function-name</code> argument. </p>



         <p><phrase diff="chg" at="D">When the containing expression is evaluated with <termref
                  def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref> set to
               true</phrase>, the <function>function-available</function> function returns false in
            respect of a function name and arity for which no implementation is available (other
            than the fallback error function that raises a dynamic error whenever it is called).
            This means that it is possible (as in XSLT 1.0) to use logic such as the following to
            test whether a function is available before calling it:</p>
         <example>
            <head>Calling an extension function with backwards compatibility enabled</head>
            <eg xml:space="preserve"><![CDATA[
<summary xsl:version="1.0">
  <xsl:choose>
    <xsl:when test="function-available('my:summary')">
      <xsl:value-of select="my:summary()"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:text>Summary not available</xsl:text>
    </xsl:otherwise>
  </xsl:choose>
</summary>]]></eg>
         </example>




      </fos:rules>
      <fos:errors>
         <p>
            <error spec="XT" type="dynamic" class="DE" code="1400">
               <p diff="chg" at="K">It is a <termref def="dt-dynamic-error"><phrase diff="del"
                        at="N">non-recoverable</phrase> dynamic error</termref> if the argument
                     <error.extra>passed to the <function>function-available</function>
                     function</error.extra> does not evaluate to a string that is a valid <termref
                     def="dt-eqname">EQName</termref>, or if the value is a <termref
                     def="dt-lexical-qname">lexical QName</termref> with a prefix for which no
                  namespace declaration is present in the static context. If the processor is able
                  to detect the error statically (for example, when the argument is supplied as a
                  string literal), then the processor <rfc2119>may</rfc2119> optionally signal this
                  as a <termref def="dt-static-error">static error</termref>.</p>
            </error>
         </p>
      </fos:errors>
      <fos:notes>
         <p>The fact that a function with a given name is available gives no guarantee that any
            particular call on the function will be successful. For example, it is not possible to
            determine the types of the arguments expected.</p>
         <p diff="add" at="L">The introduction of the <xfunction>function-lookup</xfunction>
            function in XPath 3.0 reduces the need for <function>function-available</function>,
            since <xfunction>function-lookup</xfunction> not only tests whether a function is
            available, but also returns a function item that enables it to be dynamically
            called.</p>
         <p diff="add" at="M">If a function is present in the static context but with no useful
            functionality (for example, if the system has been configured for security reasons so
            that <xfunction>available-environment-variables</xfunction> returns no information),
            then <function>function-available</function> when applied to that function should return
            false.</p>
         <p diff="add" at="Q">It is not necessary that there be a direct equivalence between the
            results of <function>function-available</function> and
               <xfunction>function-lookup</xfunction> in all cases. For example, there may be
               <termref def="dt-extension-function">extension functions</termref> whose side-effects
            are such that for security reasons, dynamic calls to the function are disallowed;
               <xfunction>function-lookup</xfunction> might then not provide access to the function.
            The main use-case for <function>function-available</function>, by contrast, is for use
            in <code>[xsl:]use-when</code> conditions to test whether static calls on the function
            are possible.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <example>
               <head>Stylesheet portable between XSLT 1.0, XSLT 2.0, and XSLT 3.0</head>
               <p>A stylesheet that is designed to use XSLT 2.0 facilities when running under an
                     <phrase diff="chg" at="F">XSLT 2.0 or XSLT 3.0 processor</phrase>, but to fall
                  back to XSLT 1.0 capabilities when not, might be written using the code:</p>
               <eg xml:space="preserve"><![CDATA[
<out xsl:version="2.0">
  <xsl:choose>
    <xsl:when test="function-available('matches')">
      <xsl:value-of select="matches(/doc/title, '[a-z]*')"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="string-length(
	        translate(/doc/title, 'abcdefghijklmnopqrstuvwxyz', '')) = 0"/>
    </xsl:otherwise>
  </xsl:choose>
</out>]]></eg>
               <p>Here an <phrase diff="chg" at="F">XSLT 2.0 or XSLT 3.0</phrase> processor will
                  always take the <elcode>xsl:when</elcode> branch, while a 1.0 processor will
                  follow the <elcode>xsl:otherwise</elcode> branch. The single-argument version of
                  the <function>function-available</function> function is used here, because that is
                  the only version available in XSLT 1.0. Under the rules of XSLT 1.0, the call on
                  the <code>matches</code> function is not an error, because it is never
                  evaluated.</p>
            </example>
         </fos:example>
         <fos:example>
            <example>
               <head>Stylesheet portable between XSLT 3.0 and a future version of XSLT</head>
               <p>A stylesheet that is designed to use facilities in some future XSLT version when
                  they are available, but to fall back to <phrase diff="chg" at="F">XSLT 2.0 or XSLT
                     3.0</phrase> capabilities when not, might be written using code such as the
                  following. This hypothesizes the availability in some future version of a function
                     <code>pad</code> which pads a string to a fixed length with spaces:</p>
               <eg xml:space="preserve"><![CDATA[
 <xsl:value-of select="pad(/doc/title, 10)" 
               use-when="function-available('pad', 2)"/>
 <xsl:value-of select="concat(/doc/title, string-join(
                          for $i in 1 to 10 - string-length(/doc/title) 
						  return ' ', ''))"
               use-when="not(function-available('pad', 2))"/>
 ]]></eg>
               <p>In this case the two-argument version of <function>function-available</function>
                  is used, because there is no requirement for this code to run under XSLT 1.0.</p>
            </example>
         </fos:example>
      </fos:examples>

   </fos:function>

   <fos:function name="element-available" prefix="fn">
      <fos:signatures>
         <fos:proto name="element-available" return-type="xs:boolean">
            <fos:arg name="element-name" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property dependency="namespaces">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Determines whether a particular instruction is or is not available for use. The function
            is particularly useful for calling within an <code>[xsl:]use-when</code> attribute (see
               <specref ref="conditional-inclusion"/>) to test whether a particular <termref
               def="dt-extension-instruction"/> is available.</p>
      </fos:summary>
      <fos:rules>




         <p diff="chg" at="K">The value of the <code>$element-name</code> argument
               <rfc2119>must</rfc2119> be a string containing an <termref def="dt-eqname"
               >EQName</termref>. If it is a <termref def="dt-lexical-qname">lexical QName</termref>
            with a prefix, then it is expanded into an <termref def="dt-expanded-qname">expanded
               QName</termref> using the namespace declarations in the static context of the
               <termref def="dt-expression">expression</termref>. If there is a default namespace in
            scope, then it is used to expand an unprefixed <termref def="dt-lexical-qname">lexical
               QName</termref>.</p>

         <p diff="add" at="N"> If the resulting <termref def="dt-expanded-qname">expanded
               QName</termref> is in the <termref def="dt-xslt-namespace"/>, the function returns
            true if and only if the local name matches the name of an XSLT element that is defined
            in this specification and implemented by the XSLT processor.</p>

         <p>If the <termref def="dt-expanded-qname">expanded QName</termref> has a null namespace
            URI, the <function>element-available</function> function will return false. </p>

         <p>If the <termref def="dt-expanded-qname">expanded QName</termref> is not in the <termref
               def="dt-xslt-namespace">XSLT namespace</termref>, the function returns true if and
            only if the processor has an implementation available of an <termref
               def="dt-extension-instruction">extension instruction</termref> with the given
            expanded QName. This applies whether or not the namespace has been designated as an
               <termref def="dt-extension-namespace">extension namespace</termref>.</p>
         <p>If the processor does not have an implementation of a particular extension instruction
            available, and such an extension instruction is evaluated, then the processor
               <rfc2119>must</rfc2119> perform fallback for the element as specified in <specref
               ref="fallback"/>. An implementation <rfc2119>must not</rfc2119> signal an error
            merely because the stylesheet contains an extension instruction for which no
            implementation is available.</p>

      </fos:rules>
      <fos:errors>
         <p diff="chg" at="K">
            <error spec="XT" type="dynamic" class="DE" code="1440">
               <p>It is a <termref def="dt-dynamic-error"><phrase diff="del" at="N"
                        >non-recoverable</phrase> dynamic error</termref> if the argument
                     <error.extra>passed to the <function>element-available</function>
                     function</error.extra> does not evaluate to a string that is a valid <termref
                     def="dt-eqname">EQName</termref>, or if the value is a <termref
                     def="dt-lexical-qname">lexical QName</termref> with a prefix for which no
                  namespace declaration is present in the static context. If the processor is able
                  to detect the error statically (for example, when the argument is supplied as a
                  string literal), then the processor <rfc2119>may</rfc2119> optionally signal this
                  as a <termref def="dt-static-error">static error</termref>.</p>
            </error>
         </p>
      </fos:errors>
      <fos:notes>
         <p>For element names in the XSLT namespace:</p>

         <ulist>
            <item>
               <p diff="add" at="N"><phrase diff="del" at="T-bug29747">Where conformance rules make some features of the specification
                  optional, for example the <code>xsl:stream</code> element, this function can
                  be used (typically in a <code>use-when</code> expression) to determine whether the
                  feature is available in a particular processor. </phrase>This function can be useful to
                  distinguish processors that implement XSLT 3.0 from processors that implement
                  other (older or newer) versions of the specification, and to distinguish full
                  implementations from incomplete implementations. (Incomplete implementations,
                  of course, cannot be assumed to behave as described in this specification.)</p>
            </item>
            <item>
               <p diff="add" at="N">In earlier versions of this specification,
                     <function>element-available</function> was defined to return true only for
                  elements classified as instructions. The distinction between instructions and
                  other elements, however, is sometimes rather technical, and in XSLT 3.0 the effect
                  of the function has therefore been aligned to do what its name might suggest.</p>
            </item>
            <item>
               <p diff="add" at="M">If an instruction is recognized but offers no useful
                  functionality (for example, if the system has been configured for security reasons
                  so that <elcode>xsl:evaluate</elcode> always raises an error), then
                     <function>element-available</function> when applied to that instruction
                     <rfc2119>should</rfc2119> return false.</p>
            </item>

         </ulist>

         <p>For element names in other namespaces:</p>

         <ulist>
            <item>
               <p>The result of the <function>element-available</function> does not depend on
                  whether or not the namespace of the supplied instruction name has been designated
                  as an extension element namespace; it tests whether the instruction would be
                  available if the namespace were designated as such.</p>
            </item>
         </ulist>





      </fos:notes>
   </fos:function>

   <fos:function name="type-available" prefix="fn">
      <fos:signatures>
         <fos:proto name="type-available" return-type="xs:boolean">
            <fos:arg name="type-name" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property dependency="namespaces schema-definitions">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <!--Text replaced by erratum E15 change 1"-->
         <p>Used to control how a stylesheet behaves if a particular schema type is or is not
            available in the static context.</p>
         <!--End of text replaced by erratum E15-->
      </fos:summary>
      <fos:rules>

         <p>A schema type (that is, a simple type or a complex type) is said to be available within
            an XPath expression if it is a type definition that is present in the <xtermref
               spec="XP30" ref="dt-is-types">in-scope schema types</xtermref> for that expression
            (see <specref ref="static-context"/>). This includes built-in types, types imported
            using <elcode>xsl:import-schema</elcode>, and extension types defined by the
            implementation.</p>
         <p>The value of the <code>$type-name</code> argument <rfc2119>must</rfc2119> be a string
            containing an <phrase diff="chg" at="K"><termref def="dt-eqname"
               >EQName</termref></phrase>. The EQName is expanded into an <termref
               def="dt-expanded-qname">expanded QName</termref> using the namespace declarations in
            scope for the <termref def="dt-expression">expression</termref>. If the value is an
            unprefixed lexical QName, then the default namespace is used in the expanded QName.</p>
         <p>The function returns true if and only if there is an available type whose name matches
            the value of the <code>$type-name</code> argument. </p>


      </fos:rules>
      <fos:errors>
         <p diff="chg" at="K">
            <error spec="XT" type="dynamic" class="DE" code="1428">
               <p>It is a <termref def="dt-dynamic-error"><phrase diff="del" at="N"
                        >non-recoverable</phrase> dynamic error</termref> if the argument
                     <error.extra>passed to the <function>type-available</function>
                     function</error.extra> does not evaluate to a string that is a valid <termref
                     def="dt-eqname">EQName</termref>, or if the value is a <termref
                     def="dt-lexical-qname">lexical QName</termref> with a prefix for which no
                  namespace declaration is present in the static context. If the processor is able
                  to detect the error statically (for example, when the argument is supplied as a
                  string literal), then the processor <rfc2119>may</rfc2119> optionally signal this
                  as a <termref def="dt-static-error">static error</termref>.</p>
            </error>
         </p>
      </fos:errors>
      <fos:notes>
         <!--Text inserted by erratum E15 change 2"-->

         <p>The <function>type-available</function> function is of limited use within an
               <code>[xsl:]use-when</code> expression, because the static context for the expression
            does not include any user-defined types.</p>

         <!--End of text inserted by erratum E15-->
      </fos:notes>
   </fos:function>
   
   <fos:function name="stream-available" prefix="fn">
      <fos:signatures>
         <fos:proto name="stream-available" return-type="xs:boolean">
            <fos:arg name="uri" type="xs:string?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>nondeterministic</fos:property>
         <fos:property dependency="available-documents">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Determines, as far as possible, whether a document is available for streamed processing using <elcode>xsl:source-document</elcode>.</p>
      </fos:summary>
      <fos:rules>
         
         <p>The intent of the <function>stream-available</function> function is to allow a stylesheet author to determine,
            before calling <elcode>xsl:source-document</elcode> with <code>streamable="yes"</code> and 
            with a particular URI as the value of its <code>href</code>
         attribute, whether a document is available at that location for streamed processing.</p>
         
         <p>If the <code>$uri</code> argument is an empty sequence then the function returns <code>false</code>.</p>
         
         <p>If the function returns <code>true</code> then the caller can conclude that the following conditions are true:</p>
         
         <olist>
            <item><p>The supplied URI is valid;</p></item>
            <item><p>A resource can be retrieved at that URI;</p></item>
            <item><p>An XML representation of the resource can be delivered, which is well-formed at least to the extent
            that some initial sequence of octets can be decoded into characters and matched against the production:</p>
               <p><code>prolog (EmptyElemTag | STag )</code></p>
            <p>as defined in the XML 1.0 or XML 1.1 Recommendation.</p>
            <note>That is, the XML is well-formed at least as far as the end of the first element start tag; to establish this,
               a parser will typically retrieve any external entities referenced in the Doctype declaration or DTD.</note></item>
         </olist>
         
         <p>If the function returns <code>false</code>, the caller can conclude that either one of the above conditions is not satisfied, or
         the processor detected some other condition that would prevent a call on <elcode>xsl:source-document</elcode> with
            <code>streamable="yes"</code> executing successfully.</p>
         
         <p>Like <elcode>xsl:source-document</elcode> itself, the function is not deterministic, which means that multiple calls during the execution
         of a stylesheet will not necessarily return the same result. The caller cannot make any inferences about the point in time at which
         the input conditions for <function>stream-available</function> are present, and in particular there is no guarantee that because
         <function>stream-available</function> returns true, <elcode>xsl:source-document</elcode> will necessarily succeed.</p>
         
         <p>The value of the <code>$uri</code> argument <rfc2119>must</rfc2119> be a URI in the form of a string. If it is a relative URI,
            it is resolved relative to the static base URI of the <phrase diff="chg" at="T-bug29461">function call</phrase>.</p>
 
         
         
      </fos:rules>
      <fos:errors>
         <p>If the URI is invalid, such that a call on <xfunction>doc-available</xfunction> would signal an error, then 
            <function>stream-available</function> signals the same error: <xerrorref spec="FO30" class="DC" code="0005"/>.</p>
      </fos:errors>
 
   </fos:function>
   <fos:function name="accumulator-before">
      <fos:signatures>
         <fos:proto name="accumulator-before" return-type="item()*">
            <fos:arg name="name" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-dependent</fos:property>
         <fos:property>focus-dependent</fos:property>
         <fos:property>special-streaming-rules</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the pre-descent value of the selected accumulator at the context node.</p>
      </fos:summary>
      <fos:rules>
         <p>The <code>$name</code> argument specifies the name of the <termref def="dt-accumulator"
            />. The value of the argument <rfc2119>must</rfc2119> be a <phrase diff="chg" at="Q"
               >string containing an <termref def="dt-eqname"/>.</phrase> If it is a <termref
               def="dt-lexical-qname">lexical QName</termref>, then it is expanded as described in
               <specref ref="qname"/> (no prefix means no namespace).</p>
         <p>The function returns the pre-descent value <var>B(N)</var>of the selected accumulator
            where <var>N</var> is the context node, as defined in <specref
               ref="accumulator-formal-rules"/>.</p>
         <p diff="add" at="R-bug26328">If the context item is a node in a streamed document, then the accumulator 
            must be declared with <code>streamable="yes"</code>.</p>
         <note diff="add" at="R-bug26328"><p>The converse is not true: an accumulator declared to be streamable is available on both
         streamed and unstreamed nodes.</p></note>
 
      </fos:rules>
      <fos:errors>
         <p>
            <error spec="XT" type="dynamic" class="DE" code="3340">
               <p>It is a <termref def="dt-dynamic-error"/> if the value of the first
                     argument to the <function>accumulator-before</function> or
                        <function>accumulator-after</function> function is not a valid
                     <termref def="dt-eqname"/>, or if there is no namespace declaration in scope
                  for the prefix of the QName, or if the name obtained by expanding the QName is not
                  the same as the expanded name of any <elcode>xsl:accumulator</elcode> declaration
                  <phrase diff="chg" at="S-bug27648">appearing</phrase> in the <termref def="dt-package">package</termref> in which the function
                  call appears. If the processor is able to detect the error statically (for
                  example, when the argument is supplied as a string literal), then the processor
                     <rfc2119>may</rfc2119> optionally signal this as a <termref
                     def="dt-static-error">static error</termref>.</p>
            </error>
         </p>
         <p>
            <error spec="XT" type="dynamic" class="DE" code="3350">
               <p>It is a <termref def="dt-dynamic-error">dynamic error</termref> to call the
                     <function>accumulator-before</function> or
                     <function>accumulator-after</function> function when there is no <termref
                     def="dt-context-item"/>.</p>
            </error>
         </p>        
         <p>
            <error spec="XT" type="dynamic" class="TE" code="3360">
               <p>It is a <termref def="dt-type-error">type error</termref> to call the
                     <function>accumulator-before</function> or
                     <function>accumulator-after</function> function when the <termref
                     def="dt-context-item"/> is not a node, or when it is an attribute or namespace
                  node.</p>
            </error>
         </p>

     <p diff="chg" at="R-bug26328">
            <error spec="XT" type="dynamic" class="DE" code="3362">
               <p>It is a <termref def="dt-dynamic-error">dynamic error</termref> to call the
                     <function>accumulator-before</function> or
                     <function>accumulator-after</function> function when the context
                  item is a node in a tree to which the selected accumulator is not
                  <phrase diff="add" at="S-bug27660">applicable (including the case where it is not applicable
                     because the document is streamed and the accumulator is not </phrase>
                  declared with <code>streamable="yes"</code>). <phrase diff="add" at="S-bug27273">Implementations
                  <rfc2119>may</rfc2119> raise this error but are <rfc2119>not required</rfc2119> to do so,
                  if they are capable of streaming documents without imposing this restriction.</phrase></p>
            </error>
         </p>
         
         <p>
            <error spec="XT" type="dynamic" class="DE" code="3400">
               <p diff="chg" at="R-bug26328">It is an error if there is a cyclic set of dependencies among accumulators such
                  that the (pre- or post-descent) value of an accumulator depends directly or indirectly on itself.
                  A processor <rfc2119>may</rfc2119> report this as a <termref def="dt-static-error"/> if it
                  can be detected statically. Alternatively a processor <rfc2119>may</rfc2119> report this as a 
                  <termref def="dt-dynamic-error"/>. As a further option, a processor may fail catastrophically when
                  this error occurs.</p></error></p>
         <note><p>The term <term>catastrophic failure</term> here means a failure similar to infinite function or template
         recursion, which might result in stack overflow or even in non-termination of the transformation, rather than in 
         a dynamic error of the kind that can be processed using <elcode>xsl:try</elcode> and <elcode>xsl:catch</elcode>.</p></note>
                  
     
         

      </fos:errors>
      <fos:notes>
         <p diff="add" at="S-bug27273">The <function>accumulator-before</function> function can be applied to a node whether or not the accumulator
            has a <code>phase="start"</code> rule for that node. In effect, there is a <code>phase="start"</code> rule
            for every node, where the default rule is to leave the accumulator value unchanged; the 
            <function>accumulator-before</function> function delivers the value of the accumulator after processing
            the explicit or implicit <code>phase="start"</code> rule.</p>
      </fos:notes>
      <fos:examples>

         <fos:example>
            <p>Given the accumulator:</p>
            <eg diff="chg" at="R-bug26737"><![CDATA[
<xsl:accumulator name="a" initial-value="0">
   <xsl:accumulator-rule match="section" select="$value + 1"/>
</xsl:accumulator>]]></eg>
            <p>and the template rule:</p>
            <eg><![CDATA[
<xsl:template match="section">
   <xsl:value-of select="accumulator-before('a')"/>
   <xsl:apply-templates/>
</xsl:template>]]></eg>
            <p>The stylesheet will precede the output from processing each section with a section
               number that runs sequentially 1, 2, 3... irrespective of the nesting of sections.</p>
         </fos:example>

      </fos:examples>


   </fos:function>

   <fos:function name="accumulator-after">
      <fos:signatures>
         <fos:proto name="accumulator-after" return-type="item()*">
            <fos:arg name="name" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-dependent</fos:property>
         <fos:property>focus-dependent</fos:property>
         <fos:property>special-streaming-rules</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the post-descent value of the selected accumulator at the context node.</p>
      </fos:summary>
      <fos:rules>

         <p>The <code>$name</code> argument specifies the name of the <termref def="dt-accumulator"
            />. The value of the argument <rfc2119>must</rfc2119> be a <phrase diff="chg" at="Q"
               >string containing an <termref def="dt-eqname">EQName</termref>.</phrase> If it is a
               <termref def="dt-lexical-qname">lexical QName</termref>, then it is expanded as
            described in <specref ref="qname"/> (no prefix means no namespace).</p>
         <p>The function returns the post-descent value <var>A(N)</var> of the selected accumulator
            where <var>N</var> is the context node, as defined in <specref
               ref="accumulator-formal-rules"/>.</p>
         
         <p diff="add" at="S-bug27273">If the context item is a node in a streamed document, then the accumulator 
            must be declared with <code>streamable="yes"</code>.</p>
         <note diff="add" at="S-bug27273"><p>The converse is not true: an accumulator declared to be streamable is available on both
            streamed and unstreamed nodes.</p></note>
         
         
      </fos:rules>
      <fos:errors>
         <p>The following errors apply: <errorref spec="XT" type="dynamic" class="DE" code="3340"/>,
               <errorref spec="XT" type="dynamic" class="DE" code="3350"/>, <errorref spec="XT"
               type="type" class="TE" code="3360"/>, <errorref spec="XT" type="dynamic" class="DE"
               code="3362"/>, <errorref spec="XT" type="dynamic"
               class="DE" code="3400"/>. </p>
         <p>For constraints on the use of <function>accumulator-after</function> when streaming, see
         <specref ref="streamability-fn-accumulator-after"/>.</p>
      </fos:errors>
      
      <fos:notes>
         <p diff="add" at="S-bug27273">The <function>accumulator-after</function> function can be applied to a node whether or not the accumulator
            has a <code>phase="end"</code> rule for that node. In effect, there is a <code>phase="end"</code> rule
            for every node, where the default rule is to leave the accumulator value unchanged; the 
            <function>accumulator-after</function> function delivers the value of the accumulator after processing
            the explicit or implicit <code>phase="end"</code> rule.</p>
      </fos:notes>

      <fos:examples>

         <fos:example>
            <p>Given the accumulator:</p>
            <eg><![CDATA[
<xsl:accumulator name="w" initial-value="0" streamable="true" as="xs:integer">
   <xsl:accumulator-rule match="text()" 
                         select="$value + count(tokenize(.))"/>
</xsl:accumulator>]]></eg>
            <p>and the template rule:</p>
            <eg><![CDATA[
<xsl:template match="section">
   <xsl:apply-templates/>
   (words: <xsl:value-of select="accumulator-after('w') - accumulator-before('w')"/>)
</xsl:template>]]></eg>
            <p>The stylesheet will output at the end of each section a (crude) count of the number of words
               in that section<phrase diff="del" at="S-bug27273">, irrespective of the nesting of sections</phrase>.</p>
            <p><emph>Note: the call on <code>tokenize(.)</code> relies on XPath 3.1</emph></p>
         </fos:example>

      </fos:examples>


   </fos:function>


</fos:functions>

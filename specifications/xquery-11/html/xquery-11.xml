<!--XSLT Processor: Apache Software Foundation--><!--XSLT Processor: Apache Software Foundation--><spec xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax" id="spec-top" w3c-doctype="wd" status="int-review">

<header id="id-spec-header">

<title>XQuery 1.1: An XML Query Language</title>
<version>("Internal Last Call")</version>
<w3c-designation>WD-xquery-11</w3c-designation>
<w3c-doctype>W3C Working Draft</w3c-doctype>
<pubdate>
 <day>13</day>
 <month>July</month>
 <year>2010</year>
</pubdate>

<publoc>
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2010/WD-xquery-11-20100713/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2010/WD-xquery-11-20100713/</loc>
</publoc>

<!-- These altlocs URIs are computed from the concatenation of doc.public, doc.shortname, and either '.xml' or
     '-diff-from-yyyymmdd.html', where 'yyyymmdd' is the earlier version of the spec from which a diff has been produced -->
<altlocs>
   <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2010/WD-xquery-11-20100713/xquery-11.xml" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML</loc>
   <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2010/WD-xquery-11-20100713/xquery-11-diff-from-20070123.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Change markings relative to first edition</loc>
</altlocs>

<!-- The latestloc URI is computed from doc.latestloc -->
<latestloc>
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/xquery-11/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xquery-11/</loc>
</latestloc>

<!-- These prevlocs URIs are always hard-coded and are never computed from entities -->
<prevlocs role="xquery">
<!-- Pubrules doesn't like FPWD to have a prevloc, not even a previous Recommendation
<loc role="xpath" xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2007/REC-xpath-20070123/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2007/REC-xpath-20070123/</loc>
<loc role="xquery" xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2007/REC-xquery-20070123/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2007/REC-xquery-20070123/</loc>
-->
<loc xmlns:xlink="http://www.w3.org/1999/xlink" role="xquery" href="http://www.w3.org/TR/2008/WD-xquery-11-20080711/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2008/WD-xquery-11-20080711/</loc>
<loc xmlns:xlink="http://www.w3.org/1999/xlink" role="xquery" href="http://www.w3.org/TR/2008/WD-xquery-11-20081203/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2008/WD-xquery-11-20081203/</loc>
</prevlocs>

<authlist>
<author>
<name>Jonathan Robie</name>
<affiliation>
          <phrase>
            <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.redhat.com" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Red Hat</loc>
          </phrase>
        </affiliation>
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.ibiblio.org/jwrobie/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.ibiblio.org/jwrobie/</loc>
</author>

<author> <name>Don Chamberlin</name>
<email xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:dchamber@us.ibm.com" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">dchamber@us.ibm.com</email>
</author>

<author>
<name>Michael Dyck</name>
<affiliation>Invited Expert</affiliation>
<email xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:jmdyck@ibiblio.org" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">jmdyck@ibiblio.org</email>
</author>

<author>
<name>
          <phrase>
            <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://snelson.org.uk/john" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">John Snelson</loc>
          </phrase>
        </name>
<affiliation>MarkLogic</affiliation>
<email xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:john.snelson@marklogic.com" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">john.snelson@marklogic.com</email>
</author>
</authlist>

<!--* N.B. the value of the errataloc href attribute is set in 
    * ../style/assemble-spec.xsl
    * when the XQuery or XPath spec is assembled.  If it changes,
    * change it THERE.
    *-->
<!-- No errata for a document until it reaches Recommendation status
<errataloc 
 role="spec-conditional"
 href="http://www.w3.org/XML/2007/qt-errata/xquery-errata.html" 
 xlink:type="simple"/>
 -->

<translationloc xmlns:xlink="http://www.w3.org/1999/xlink" role="spec-conditional" href="http://www.w3.org/2003/03/Translations/byTechnology?technology=xquery" xlink:type="simple"/>

<!--* Common status section for QT specs.
    * Use is currently not required, but it simplifies things.
    * 
    * Revisions:
    * 2007-01-15 : CMSMcQ : made file, to simplify publication of Rec.
    * 2008-02-15 : JimMelton : cloned from MSM's REC-only material
                     to generalize for all stages
    *-->

    <status id="status">

<!-- ************************************************************************** -->
<!-- * All Status sections must start with the standard boilerplate paragraph * -->
<!-- *   This entity is defined in status-entities.dtd                        * -->
<!-- ************************************************************************** -->
      <p>
        <emph>This section describes the status of this
         document at the time of its publication.
         Other documents may supersede this document.
         A list of current W3C publications and the latest
         revision of this technical report can be found in the
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">W3C technical reports index</loc>
         at http://www.w3.org/TR/.</emph>
      </p>

<!-- ************************************************************************** -->
<!-- * QT publishes suites of documents, which must be described in the       * -->
<!--     Status section of each document within such a suite.                 * -->
<!-- *   This entity is defined in the host document.                         * -->
<!-- ************************************************************************** -->
      <p>This is one document
in a set of seven documents that are being progressed to
Recommendation together (XQuery 1.1, XQueryX 1.1, XSLT 2.1,
Data Model 1.1, Functions and Operators 1.1,
Serialization 1.1, XPath 2.1). </p>

<!-- ************************************************************************** -->
<!-- * There is a lot of detailed customization based on the document stage   * -->
<!-- *   This entity is defined in the host document.                         * -->
<!-- ************************************************************************** -->
      <p>This is a <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2005/10/Process-20051014/tr.html#maturity-levels" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Working Draft</loc> as described in the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2005/10/Process-20051014/tr.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Process Document</loc>.
It has been developed by the W3C <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/Query/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML Query Working Group</loc>,
which is part of the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/Activity" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML Activity</loc>.
The Working Group expects to advance this specification to <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2005/10/Process-20051014/tr.html#RecsW3C" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Recommendation</loc> Status.</p>

<!-- ************************************************************************** -->
<!-- * CR documents must cite features at risk                                * -->
<!-- *   This entity is defined in the host document.                         * -->
<!-- ************************************************************************** -->
      

<!-- ************************************************************************** -->
<!-- * Every Status section must have a customized paragraph                  * -->
<!-- *   This entity is defined completely in the host document.              * -->
<!-- ************************************************************************** -->
      
<p>This is an "internal last call working draft" of XQuery 1.1.  The
purpose of this publication is for members of the XML Query and XSL
WGs to review the content and identify all issues that they believe
would inhibit progression of the document to Proposed Recommendation
status.  Ideally, WG members will identify all such issues in the
document before it is progressed to Last Call Working Draft status and
will not submit large numbers of issues during the (public) Last Call
review period.  WG members' comments on this document should be
submitted, using the ordinary Bugzilla reporting mechanism, no later
than Friday, 2010-07-09, so they may be considered by the Joint
face-to-face meeting scheduled to begin on 2010-07-12. </p>

<p>The following items have been resolved, but are not not completely
implemented in this internal last call document.</p>

<olist>
  <item>
          <p>A formal definition for resolving a URI will be supplied,
  consistent with the resolution of <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Bugs/Public/show_bug.cgi?id=8810#c2" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug
  8810, Comment #2</loc>.</p>
        </item>
</olist>

<p>The following items are incompletely implemented or likely to change before the Last Call document:</p>

<olist>
  <item>
          <p>Specification of serialization parameters in a query is
  likely to change in resolution of <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="   http://www.w3.org/Bugs/Public/show_bug.cgi?id=9302" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug
  9302</loc>
          </p>
        </item>
  <item>
          <p>Discussion of determinism, stability, and related concepts
  may be modified per <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://lists.w3.org/Archives/Member/w3c-xsl-query/2010Jun/0077.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">w3c-xsl-query/2010Jun/0077.html</loc>.</p>
        </item>
  <item>
          <p>Handling of static errors in switch expressions needs to be
  specified, as discussed in <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Bugs/Public/show_bug.cgi?id=9252#c5" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug
  9259, Comment #5</loc>.</p>
        </item>
</olist>


<!-- ************************************************************************** -->
<!-- * CR docs should, and PR docs must, have a pointer to an implementation  * -->
<!-- *   report.  We also want to point to the test suite.                    * -->
<!-- *   This entity is defined in the host document.                         * -->
<!-- ************************************************************************** -->
      <p>No implementation report currently exists.
However, a Test Suite for XQuery 1.1 is under development.</p>

<!-- ************************************************************************** -->
<!-- * The Status section should point to a changelog                         * -->
<!-- *   This entity is defined in the host document.                         * -->
<!-- ************************************************************************** -->
      <p>This document incorporates changes made against the previous publication
  of the Working Draft of 03 December 2008.
  Changes to this document since the previous publication of the Working Draft
  are detailed in <specref ref="id-revision-log"/>.</p>

<!-- ************************************************************************** -->
<!-- * The Status section must tell readers where to send comments            * -->
<!-- *   This entity is defined in status-entities.dtd                        * -->
<!-- ************************************************************************** -->
      <p>Please report errors in this document using W3C's
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Bugs/Public/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public Bugzilla system</loc>
         (instructions can be found at
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/2005/04/qt-bugzilla" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/XML/2005/04/qt-bugzilla</loc>).
         If access to that system is not feasible, you may send your comments
         to the W3C XSLT/XPath/XQuery public comments mailing list,
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:public-qt-comments@w3.org" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public-qt-comments@w3.org</loc>.
         It will be very helpful if you include the string 
         “[XQuery11]”
         in the subject line of your report, whether made in Bugzilla or in email.
         Please use multiple Bugzilla entries (or, if necessary, multiple email messages)
         if you have more than one comment to make.
         Archives of the comments and responses are available at
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://lists.w3.org/Archives/Public/public-qt-comments/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://lists.w3.org/Archives/Public/public-qt-comments/</loc>. </p>

<!-- ************************************************************************** -->
<!-- Status sections must state the stability (not stable, or REC) of the document -->
<!-- *   This entity is defined in the host document.                         * -->
<!-- ************************************************************************** -->
      <p>Publication as a Working Draft
does not imply endorsement by the W3C Membership. 
This is a draft document and may be updated, replaced or obsoleted
by other documents at any time. 
It is inappropriate to cite this document as other than work in progress.</p>

<!-- ************************************************************************** -->
<!-- * Finally, all Status sections must end with the appropriate IPR para    * -->
<!-- *   This entity is defined in status-entities.dtd                        * -->
<!-- ************************************************************************** -->
       <p>This document was produced by a group operating under the
  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Consortium/Patent-Policy-20040205/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">5 February 2004
  W3C Patent Policy</loc>.
  W3C maintains a 
  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2004/01/pp-impl/18797/status#disclosures" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public list of any patent disclosures</loc>
  made in connection with the deliverables of the group; 
  that page also includes instructions for disclosing a patent.
  An individual who has actual knowledge of a patent 
  which the individual believes contains
  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Essential Claim(s)</loc>
  must disclose the information in accordance with
  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
  section 6 of the W3C Patent Policy</loc>. </p>


    </status> 

<abstract id="id-abstract"> 

<p role="xquery">XML is a versatile markup language, capable of labeling the
information content of diverse data sources including structured and
semi-structured documents, relational databases, and object
repositories. A query language that uses the structure of XML
intelligently can express queries across all these kinds of data,
whether physically stored in XML or viewed as XML via middleware.
This specification describes a query language called XQuery, which is
designed to be broadly applicable across many types of XML data
sources.</p>

<p role="xquery">XQuery 1.1 is an extended version of the XQuery 1.0
Recommendation published on 23 January 2007. A list of changes made
since XQuery 1.0 can be found in <specref ref="id-revision-log"/>. Here are some of the new features in XQuery 1.1:
</p>
<olist role="xquery">
<item>
          <p>
            <code>group by</code> clause in FLWOR Expressions (<specref ref="id-group-by"/>).</p>
        </item>
<item>
          <p>
            <code>tumbling window</code> and <code>sliding window</code> in FLWOR Expressions (<specref ref="id-windows"/>).</p>
        </item>
<item>
          <p>
            <code>count</code> clause in FLWOR Expressions (<specref ref="id-count"/>).</p>
        </item>
<item>
          <p>
            <code>allowing empty</code> in <specref ref="id-xquery-for-clause"/>, for functionality similar to outer joins in SQL.</p>
        </item>
<item>
          <p>
            <code>try</code>/<code>catch</code> expressions (<specref ref="id-try-catch"/>).</p>
        </item>
<item>
          <p>Dynamic function invocation (<specref ref="id-dynamic-function-invocation"/>).</p>
        </item>
<item>
          <p>Inline functions (<specref ref="id-inline-func"/>).</p>
        </item>
<item>
          <p>Private functions (<specref ref="FunctionDeclns"/>).</p>
        </item>
<item>
          <p>Nondeterministic functions (<specref ref="FunctionDeclns"/>)</p>
        </item>
<item>
          <p>Switch expressions (<specref ref="id-switch"/>)</p>
        </item>
<item>
          <p>Computed namespace constructors (<specref ref="id-computed-namespaces"/>).</p>
        </item>
<item>
          <p>Output declarations (<specref ref="id-serialization"/>).</p>
        </item>
<item>
          <p>Annotations (<specref ref="id-annotations"/>).</p>
        </item>
<item>
          <p>
            <termref def="dt-annotation-assertion">Annotation assertions</termref> in <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-FunctionTest" xlink:type="simple">function tests</nt>.</p>
        </item>
</olist>
</abstract>

<langusage>
<language id="EN">English</language>
<language id="ebnf">EBNF</language>
</langusage>
<revisiondesc>
<slist>
<sitem>XQuery 1.1 First Public Working Draft. (2008-07-11)</sitem>
<sitem>XQuery 1.1 Working Draft (2008-12-03)</sitem>
<sitem>XQuery 1.1 Working Draft and XPath 2.1 First Public Working Draft (2009-12-04)</sitem>
</slist>
</revisiondesc>
</header>

<body>

<div1 id="id-introduction">

	<head>Introduction</head> 

	<p role="xquery">As increasing amounts of information are
	stored, exchanged, and presented using XML, the ability to
	intelligently query XML data sources becomes increasingly
	important. One of the great strengths of XML is its
	flexibility in representing many different kinds of
	information from diverse sources. To exploit this flexibility,
	an XML query language must provide features for retrieving and
	interpreting information from these diverse sources.</p> 

	<p role="xquery">XQuery is designed to meet the requirements
	identified by the W3C XML Query Working Group <bibref ref="xquery-11-requirements"/>
  and the use cases in <bibref ref="UseCases"/>. 
  It is designed to be a language in which queries are concise and easily
	understood. It is also flexible enough to query a broad
	spectrum of XML information sources, including both databases
	and documents. The Query Working Group has identified a
	requirement for both a non-XML query syntax and an
	XML-based query syntax. XQuery is designed to meet the first
	of these requirements.  XQuery is derived from an XML query
	language called Quilt <bibref ref="Quilt"/>, which in turn
	borrowed features from several other languages, including
	XPath 1.0 <bibref ref="xpath"/>, XQL <bibref ref="XQL"/>,
	XML-QL <bibref ref="XML-QL"/>, SQL <bibref ref="SQL"/>, and
	OQL <bibref ref="ODMG"/>. </p>

	

<p>
        <termdef id="dt-datamodel" term="data model">XQuery 1.1 operates on the abstract,
	logical structure of an XML document, rather than its surface
	syntax.  This logical structure, known as the <term>data
	model</term>,  is defined in <bibref ref="xpath-datamodel-11"/>.</termdef>
      </p>

	

	<p>XQuery Version 1.1 is an extension of XPath Version
	2.1. 

	In general, any expression that is syntactically valid and executes
	successfully in both XPath 2.1 and XQuery 1.1 will return the
	same result in both languages. There are a few exceptions to this
	rule:

	<ulist>
	<item>
            <p>Because XQuery expands 
<phrase role="xquery">
 <termref def="dt-predefined-entity-reference">predefined entity references</termref> and <termref def="dt-character-reference">character references</termref>
</phrase>

 and XPath does not, expressions containing these produce different results in the two languages. For instance, the value of the string literal <code role="parse-test">"&amp;amp;"</code> is <code>&amp;</code> in XQuery, and <code>&amp;amp;</code> in XPath. (XPath is often embedded in other languages, which may expand predefined entity references or character references before the XPath expression is evaluated.)</p>
          </item>
	<item>
            <p>If XPath 1.0 compatibility mode is enabled, XPath behaves differently from XQuery in a number of ways, 

<phrase role="xquery">which are discussed in <bibref ref="xpath-21"/>.</phrase>
            </p>
          </item>
	</ulist>
      </p>

	<p>Because these languages are so closely related, their grammars
	and language descriptions are generated from a common source
	to ensure consistency, and the editors of these specifications
	work together closely.</p>

	<p>XQuery 1.1 also depends on and is closely related to the
	following specifications:</p>

	<ulist>
	  <item>
            <p>
            <bibref ref="xpath-datamodel-11"/> defines the data model that underlies all XQuery 1.1 expressions.</p>
	  </item>

          <item>
	  <p>The type system of XQuery 1.1 is based on <bibref ref="XMLSchema"/>.</p>
	  </item>

	  <item>
	  <p>The built-in function library  and the operators supported by
	  XQuery 1.1 are defined in <bibref ref="xpath-functions-11"/>.</p>
	  </item>

	  <item role="xquery">
	  <p>One requirement in <bibref ref="xquery-11-requirements"/> is that
	  an XML query language have both a human-readable syntax and
	  an XML-based syntax.  The XML-based syntax for XQuery is
	  described in <bibref ref="xqueryx-11"/>. </p> 
          </item>

        </ulist>

<p>
        <termdef id="dt-xquery-11-processor" term="XQuery 1.1 Processor">An
<term>XQuery 1.1 Processor</term> processes a query according to the
XQuery 1.1 specification.</termdef>
      </p>
<p>
        <termdef id="dt-xquery-10-processor" term="XQuery 1.0 Processor">An
<term>XQuery 1.0 Processor</term> processes a query according to the
XQuery 1.0 specification.</termdef>
      </p>

	
	<p>This document specifies a grammar for XQuery 1.1, using the
		same basic EBNF notation used in <bibref ref="XML"/>. 
    Unless otherwise noted (see <specref ref="lexical-structure"/>), 
    whitespace is not significant in <phrase role="xquery">queries</phrase>. 
    Grammar productions are introduced together with the features that they describe,
    and a complete grammar is also presented in the appendix [<specref ref="nt-bnf"/>]. 
    The appendix is the normative version.</p>
      <p>In the grammar productions in this document,
    named symbols are underlined and literal text is enclosed in double quotes. 
    For example, the following  production describes the syntax of a function call:</p>
      <scrap headstyle="show"> 
		  <head/> 
		  <prod num="134" id="fakeid_doc-xquery11-FunctionCall">
          <lhs>FunctionCall</lhs>
          <rhs>
            <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-EQName" xlink:type="simple">EQName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ArgumentList" xlink:type="simple">ArgumentList</nt>
          </rhs>
        </prod> 
		</scrap>
      <p>The production should be read as follows: A
		function call consists of an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-EQName" xlink:type="simple">EQName</nt> followed by an
		open-parenthesis. The open-parenthesis is followed by
		an optional argument list. The argument list (if
		present) consists of one or more expressions,
		separated by commas. The optional argument list is
		followed by a close-parenthesis. </p>


<p>This document normatively defines the static and dynamic semantics of
XQuery 1.1. In this document, examples and material labeled as "Note"
are provided for explanatory purposes and are not normative.</p>


		<p>Certain aspects of language
		processing are described in this specification as
		<term>implementation-defined</term> or
		<term>implementation-dependent</term>.</p>

<ulist>
  <item>
    <p>
            <termdef id="dt-implementation-defined" term="implementation defined">
              <term>Implementation-defined</term>
		indicates an aspect that may differ between
		implementations, but must be specified by the
		implementor for each particular
		implementation.</termdef>
          </p>
  </item>
  <item>
    <p>
      <termdef id="dt-implementation-dependent" term="implementation   dependent">
              <term>Implementation-dependent</term>
		indicates an aspect that may differ between
		implementations, is not specified by this or any W3C
		specification, and is not required to be specified by
		the implementor for any particular
		implementation.</termdef>
          </p>
  </item>
</ulist>




</div1>


<!--
====================================================================
 $Log: xquery-11.xml,v $
 Revision 1.102  2010/11/11 17:11:50  jrobie3
 Current html directory.

 Revision 1.90  2010/09/03 20:36:47  jrobie3
 Implemented ACTION A-444-15: Jonathan to close 9252 to reflect the decision not to require errors to be raised in non-matching case operands.

 Revision 1.89  2010/07/13 14:17:50  jrobie3
 Added support for EQNames.
 Resolves: http://www.w3.org/Bugs/Public/show_bug.cgi?id=6131

 Revision 1.88  2010/07/08 14:47:00  jsnelson
 Updated my affiliation to MarkLogic.

 Revision 1.87  2010/06/30 01:41:41  jrobie3
 Added annotation assertions, per http://lists.w3.org/Archives/Member/w3c-xsl-query/2010Mar/0180.html.

 Revision 1.86  2010/06/27 21:41:06  jrobie3
 Implemented Bug 9252 Error handling in switch expression, adapting for significant changes made to the text in the meantime. Reopened the bug to resolve the question regarding static detection of errors.

 Revision 1.85  2010/06/27 20:09:51  jrobie3
 Fixed organizational issues raised by Mike Kay here:
 http://lists.w3.org/Archives/Member/w3c-xsl-query/2010Mar/0170.html

 Revision 1.84  2010/06/27 18:55:02  jrobie3
 Bugzilla Bug 9298, [XPath21] namespace-node() as a KindTest

 Implement decision contained in comment #2:
 http://www.w3.org/Bugs/Public/show_bug.cgi?id=9298#c2

 Revision 1.83  2010/06/27 18:33:04  jrobie3
 Implemented typeswitch proposal from w3c-xsl-query/2010Feb/0220.html

 Revision 1.82  2010/06/27 17:33:56  jrobie3
 Rebuilt html, fixed a few typos.

 Revision 1.81  2010/06/27 17:12:58  jrobie3
 - Implemented Bug 8662 - extra-grammatical constraint for occurrence indicators w/ sequence type
 - Processed mdyck feedback in 2009Nov/0075.html per resolution in Teleconference #425 2010-02-02
 - Implemented % annotation proposal per Teleconference #434 2010-04-27, c.f. w3c-xsl-query/2010May/0013.html
 - Implemented resolution of Bug 9757 per Teleconference #441 2010-06-22

 Revision 1.80  2010/04/15 13:38:57  jsnelson
 Implemented solution for Bug #9183, approved at meeting #432.

 Revision 1.79  2010/04/15 11:56:49  jsnelson
 Implemented solution to bug #9139, adopted at meeting #432.

 Revision 1.78  2010/03/26 16:47:03  jrobie3
 Removed misplaced <item> from discussion of 0096

 Revision 1.77  2010/03/23 23:32:44  jsnelson
 Moved Dynamic Function Invocations to the Postfix Expressions section.

 Revision 1.76  2010/03/23 03:23:27  jrobie3
 Closed the following action items and bugs - see revision log for details.


 * DONE ACTION A-423-02
   CLOSED: [2010-03-22 Mon 22:03]

 * DONE ACTION A-427-04:
   CLOSED: [2010-03-22 Mon 10:13]

 ** DONE Check E19
    CLOSED: [2010-03-21 Sun 13:36]

 ** DONE Bug 8564
    CLOSED: [2010-03-22 Mon 10:15]
    http://www.w3.org/Bugs/Public/show_bug.cgi?id=8564

 ** DONE Bug 8537
    http://www.w3.org/Bugs/Public/show_bug.cgi?id=8537

 * DONE ACTION A-427-09:
   CLOSED: [2010-03-22 Mon 20:49]
   JR to implement change in 8502 comment #1.

 * DONE ACTION A-427-12:
   CLOSED: [2010-03-22 Mon 20:04]
   [ In Appendix C of the Working Draft ]


 Brought revision log up to date.


 Known problem: change to function call also affects the explanatory
 text of our BNF:

      In the grammar productions in this document, named symbols are
      underlined and literal text is enclosed in double quotes. For
      example, the following production describes the syntax of a
      function call:

      [134]    	FunctionCall 	   ::=    	QName ArgumentList

      The production should be read as follows: A function call
      consists of a QName followed by an open-parenthesis. The
      open-parenthesis is followed by an optional argument list. The
      argument list (if present) consists of one or more expressions,
      separated by commas. The optional argument list is followed by a
      close-parenthesis.

 Revision 1.75  2010/03/03 02:28:06  jsnelson
 Implemented partial apply syntax proposal, and reorganized the "Function Call" section.

 Revision 1.74  2010/03/02 01:38:22  mdyck
 Previous commit left the document in a bad state.
 Move a comment-end to make it well-formed.
 Move an </olist> tag to make it valid.

 Revision 1.73  2010/02/18 13:43:41  jrobie3
 Fixed Bug 7450, 7048.

 Revision 1.72  2010/02/03 13:47:06  jrobie3
 'switch' is now a reserved word.

 Revision 1.71  2009/12/01 14:36:15  jrobie3
 Merged in Jim's changes (including stylesheets).

 Revision 1.70  2009/11/25 00:05:24  jrobie3
 Completely removed Formal Semantics from normative reference.

 Consistently applied outstanding XPath 2ed Errata where missing.

 Processed http://lists.w3.org/Archives/Member/w3c-xsl-query/2009Nov/0092.html,
 except for Appendix G, which is a bit hairy ...

 Revision 1.69  2009/11/24 07:14:13  mdyck
 Make A.4 Precedence Order truly non-normative
 by adding associativity-related statements to
 3.3.3 Combining Node Sequences (intersect, except, union)
 and
 3.4 Arithmetic Expressions (+, -, *, div, idiv, mod)

 (Step 1 of Action A-417-16)

 Revision 1.68  2009/11/19 08:21:36  mdyck
 Fix some spelling mistakes.

 Revision 1.66  2009/11/17 23:42:28  mdyck
 2.4.2 Atomization:
 Add 'group by' clauses and Switch expressions
 to the list of expressions that use atomization.

 See:
 http://lists.w3.org/Archives/Member/w3c-xsl-query/2009Nov/0076.html

 (Completes ACTION A-418-04)

 Revision 1.65  2009/11/17 19:40:26  mdyck
 Fix small typo in section on static type analysis.

 Revision 1.64  2009/11/15 22:44:31  jrobie3
 * DONE [2009-11-14 Sat]ACTION-417-07: Jonathan to process #4,
 * DONE [2009-11-14 Sat]also adding new feature highlights to the introduction,

 grouping
 windowing
 count clause
 AllowingEmpty production in the for clause

 try-catch
 higher order functions
 - 3.1.6 Literal Function Items
 - 3.1.7 Inline Functions
 - 3.1.8 Dynamic Function Invocation

 private functions
 nondeterministic functions

 output declarations
 computed namespace constructors
 -
 full axis is mandatory
 * DONE [2009-11-14 Sat] and process #5.

 ACTION-417-08: Jim to ensure that all normative and non-normative
 references are updated for XPath/XQuery version numbers.

 ACTION-417-09: John Snelson to process #6, #7, #8

 * DONE ACTION-417-10: Jonathan to process #9

 9) 3.8 FLWOR Expressions, editorial

 This section says, "The complete syntax of a FLWOR expression is shown
 here, and relevant parts of the syntax are repeated in subsequent sections
 of this document." The definitions of LetBinding, ForBinding, and perhaps
 others are missing.


 ACTION-417-11: John Snelson to process #10, #11, #12, pushing
 back if there are issues.

 * DONE ACTION-417-12: Jonathan to process #13, #14 (at discretion), #15


 13) 3.7.3.7 Computed Namespace Constructors, editorial

 "namespace" is misspelled when we say, "A computed namespace constructor
 creates a new namespacee node, ..."


 14) 3.7.3.7 Computed Namespace Constructors, editorial

 I suggest that the rules for evaluation be bulleted, as they are in
 previous sections, when we say, "If the constructor specifies a
 PrefixExpr, the prefix expression is evaluated as follows: ..."


 15) 3.7.3.7 Computed Namespace Constructors, editorial

 I suggest replacing "who" with "that" where we say, "Like all nodes who do
 not share a common parent, ..."


 * DONE ACTION-417-13: Jonathan to process #16, along these lines: [[

 A special rule applies to propagation of dynamic errors by switch
 expressions. The case clauses of a switch expression do not raise any
 dynamic errors except in the effective case, or the default clause if
 there is no effective case. Dynamic errors raised in the operand
 expressions of the switch or the case clauses are propagated. An
 implementation must not raise errors in the operand expressions of case
 clauses that occur after the effective case.

 (Also: define "case operand expression" and "switch operand expression".)
 ]]

 * DONE ACTION-417-14: Jonathan to fix example in #17,

 * DONE ACTION-417-15: Jonathan to fix #18,

 * DONE #20,

 20) A.2.2 Terminal Delimitation, editorial

 The first sentence contains "&version;". Also, there is missing space in
 "symbolsand".

 "XQuery 1.1: An XML Query Language &version; expressions consist of
 terminal symbolsand symbol separators."

 * DONE #21

 21) 5.3 Data Model Conformance

 This section begins with, "All XQuery implementations process data
 represented in the data model as specified in [XQuery/XPath Data Model
 (XDM)]." I believe that XDM 1.1/2.1 should be specified.


 NE <2009-11-14 Sat> ACTION-417-25: Jonathan to fix repeated text in 2.5.4 after "Some of
 the rules for SequenceType matching require determining whether a
 given schema type encountered as a type annotation..."

 * DONE ACTION-417-27: Jonathan to make 3.1.8 of XPath to refer to rules
 1 through 3, not 1 through 5.  Also in first def of 3.1.8, fix
 unresolved [TERMDEFs.

 Revision 1.63  2009/11/12 00:16:00  jrobie3
 * DONE Merge expressions.xml
 * DONE Mdyck Switch comments (see Tomboy)
 * DONE ACTION-417-13: Jonathan to process #16, along these lines: [[

 A special rule applies to propagation of dynamic errors by switch
 expressions. The case clauses of a switch expression do not raise any
 dynamic errors except in the effective case, or the default clause if
 there is no effective case. Dynamic errors raised in the operand
 expressions of the switch or the case clauses are propagated. An
 implementation must not raise errors in the operand expressions of case
 clauses that occur after the effective case.

 (Also: define "case operand expression" and "switch operand expression".)
 ]]

 * DONE ACTION-417-22: Jonathan to make switch use equivalence of two
 values V1 and V2 as defined in Group By

 DONE ACTION-417-24: Jonathan to reword the text in the definition
 of effective case to use one or other of the two proposals
 to address Mike kay's comments 3 and 5.

 Revision 1.62  2009/11/11 19:58:09  mdyck
 In the "Inline Functions" section,
 remove the 'role="xquery"' attribute on the <scrap>:
 the grammar's xpath21-Lbrace problem is now fixed.
 (Was fixed a few days ago, actually.)

 Revision 1.61  2009/11/10 15:12:14  jsnelson
 Made an inline function example XPath 2.1 friendly, and fixed the "primes" in another example.

 Revision 1.60  2009/11/10 00:42:26  mdyck
 Change
     <bibref ref="xslt-query-serialization-11"/>
 to
     <bibref ref="xslt-xquery-serialization-11"/>
 (i.e., add 'x')
 to match
     <bibl id="xslt-xquery-serialization-11" ...

 Revision 1.59  2009/11/09 21:52:05  jmelton
 Updated <bibl> and <bibref> elements to reflect overhaul of all <bibl>s in QT x.1 specs

 Revision 1.58  2009/11/09 13:05:19  jsnelson
 Applied Andrew Eisenberg's editorial changes to the HOF sections.

 Revision 1.57  2009/11/09 04:18:19  mdyck
 In section 2.2.4 "Serialization", in the example, on each line,
 remove the illegal '=' between QName and StringLiteral.

 Revision 1.56  2009/11/09 03:26:24  mdyck
 In the "Return Clause" section,
 at the very end of the second example,
 add &gt; to close an end-tag.

 Revision 1.55  2009/11/09 02:47:06  mdyck
 Add attributes to many <code> and <eg> elements:
 mostly
     role="parse-test"
 but also a few
     role="frag-prolog-parse-test"

 Revision 1.54  2009/10/26 21:57:48  jrobie3
 XPath 2.1 now builds again.

 Revision 1.53  2009/10/26 16:44:38  jrobie3
 For review.  Limitations:

 1. Some problems with whitespace in examples.
 2. Not done: Context Free Paths http://www.w3.org/Bugs/Public/show_bug.cgi?id=6131
 3. Note done: Removing ambiguities in Schema Import http://www.w3.org/Bugs/Public/show_bug.cgi?id=7737#c1
 4. Not done: Modify typeswitch for consistency
 http://lists.w3.org/Archives/Member/w3c-xsl-query/2009Jul/0047.html
 "Also allow typeswitch to have multiple cases before a return, for consistency."
 5. Example Applications now has some examples that should be removed, it's easier to do these with XQuery 1.1 features.

 Revision 1.52  2009/10/26 14:15:49  jrobie3
 See revision log.

 Revision 1.51  2009/10/21 22:04:05  jrobie3
 Preliminary text for derives-from(). Needs phrase level markup.

 !!!! FELLOW EDITORS !!! Please do not remove comments that indicate
 changes, the change element is not yet in the schema, I'm saving
 changes in comments for later diff markup.

 Revision 1.50  2009/10/21 17:33:47  mdyck
 Remove role="parse-test" from some code that isn't valid syntax
 (and isn't meant to be).

 Revision 1.49  2009/10/21 16:20:43  jrobie3
 Got rid of parse tests that evaluate to comments and raise a syntax
 error (empty query!). Added some parse tests for edge cases from ebnf.xml.

 Revision 1.48  2009/10/21 16:05:39  jrobie3
 Added a few new parse-tests - mainly in high order functions, ebnf

 Revision 1.47  2009/10/20 21:29:06  jrobie3
 "define function local:thrice" => "declare function local:thrice"

 Revision 1.46  2009/10/13 14:46:34  jsnelson
 Refer to the data model term "function signature".

 Revision 1.45  2009/10/13 14:30:43  jsnelson
 Discovered <xtermref/>, and used it to clean up function item references to the data model spec.

 Revision 1.44  2009/10/12 22:23:46  jsnelson
 Added function items to the data model spec, and cross-linked from the XQuery / XPath specs.

 Revision 1.43  2009/10/09 19:15:21  jrobie3
 .

 Revision 1.42  2009/10/09 18:41:00  jrobie3
 Checking in for Jim

 Revision 1.41  2009/09/30 15:12:02  jsnelson
 Implemented Mike Kay's function coercion proposal approved meeting #412.

 Revision 1.40  2009/09/28 21:20:51  jsnelson
 Reapplying revisions 1.37 and 1.38.

 Revision 1.38  2009/09/28 14:09:30  jsnelson
 Change AnyFunctionTest from function() to function(*).

 Revision 1.37  2009/09/28 13:48:59  jsnelson
 Editorial changes to higher order functions, and added more examples.

 Revision 1.39  2009/09/28 14:22:18  jrobie3
 Complete set of lang-2ed changes have now been applied.

 Revision 1.36  2009/09/07 16:42:09  jsnelson
 Added the higher order functions proposal to XQuery 1.1 and XPath 2.1.

 Revision 1.35  2009/09/02 03:13:28  mdyck
 Change
     <prodrecap id="FLWORExpr11" ref="FLWORExpr11"/>
 to
     <prodrecap id="FLWORExpr" ref="FLWORExpr11"/>

 and
     <nt def="FLWORExpr11">
 to
     <nt def="FLWORExpr">...

 (which undoes some of the previous commit).

 See:
 http://lists.w3.org/Archives/Member/w3c-query-editors/2009Sep/0000.html

 Revision 1.34  2009/09/01 12:59:41  jrobie3
 Matches work list 24 Aug 09

 Revision 1.33  2009/01/02 00:57:04  jmelton
 Deleted a few unnecessary blank lines

 Revision 1.32  2009/01/01 01:05:33  jmelton
 Added a new role attribute to the div2 for Try/Catch:
    <div2 id="id-try-catch" role="xquery">
 so this wouldn't be pulled in for an XPath 2.1 build.

 Also made a few minor typographical corrections.

 Revision 1.31  2008/11/25 15:57:20  jrobie3
 Fixed two errors in examples for context item declarations.

 Revision 1.30  2008/11/13 19:58:37  jrobie3
 Error codes added, date changed, ready for WG review.

 Revision 1.29  2008/11/13 14:02:16  jrobie3
 Filled in static context for decimal formatting, modified description of decimal format declarations to leverage the static context.

 Revision 1.28  2008/11/12 22:06:06  jrobie3
 Checking in just prior to working on the static context items for decimal formats.

 *   Unique names for windowing variables

     In a FLWOR, all nine of the variables bound by a window clause must
     have distinct names. Requires a new error code.  Decided in Telcon
     376, 9/9/08.

 *   Definition of Internal Functions

     Adopt improvements in definition of internal functions, function
     body, as proposed in
     http://www.w3.org/Bugs/Public/show_bug.cgi?id=6133.


 *   XQuery 1.1: Module imports

     M.Kay proposal for relaxing constraints on module imports, in
     Query/2007Oct/0038. Some concerns relating to formal semantics, to
     be addressed later along with many other concerns about the future
     of the FS document. Approved in Telcon 373, 7/8/08.

 *   Atomization in grouping clauses

     In a group-by clause, the grouping variables should be bound to
     the pre-atomization values of the grouping keys. Requires change
     to explanation and example in group-by section. Editor is also
     instructed to insert an editor's note requesting public feedback
     on this (pre-atomization vs. post-atomization) issue.  Decided in
     Telcon 376, 9/9/08.
     http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2008Sep/0033.html

 *   Try/catch catches dynamic type errors

     Try/catch catches type errors raised during dynamic
     evaluation. Decided at XML Query WG Face-To-Face Meeting #381
     http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2008Oct/0152.html


 *   Incorporated Mike Kay's feedback on the validate expression found here:

     http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2008Oct/0127.html

 Revision 1.27  2008/11/07 22:11:58  jrobie3
 *** empty log message ***

 Revision 1.26  2008/10/25 00:31:41  jrobie3
 (1) XQuery 1.1: Number formatting
 Proposal relating to number formatting as specified here:
 http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2008Jun/0111.html
 Adds "format declaration" to query prolog (impacts XQuery grammar).
 Approved in F2F at Edinburgh, week of 6/23/08.
 - Grammar added, clarification sought:
   http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2008Sep/0143.html
 - Description TODO

 (16)  Implement Snelson proposal on XQuery version declarations found
 at http://www.w3.org/Bugs/Public/show_bug.cgi?id=5804#c1. Change the
 definition so that an XQuery 1.1 processor must also provide an XQuery 1.0
 processor (which it uses if there's an XQuery 1.0 declaration). (Changes
 item i.) Change to iii - remove the part that allows an XQuery 1.1 processor
 to reject a module with an XQuery 1.0 declaration.
 - Undefined behavior if version is not 1.1 or 1.0.

 (6) XQuery 1.1: Context item declaration:
 Accepted this proposal:
 http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2008Jun/0157.html
 Requires two new error codes.
 Decided in F2F at Edinburgh, week of 6/23/08.
 - Grammar ###

 (7) XQuery 1.1: Computed namespace constructor:
 Accepted this proposal:
 http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2008Jun/0179.html
 Proposal contains some errors in examples. Should specify an error
 if the parent of a computed namespace constructor is a document node
 (add this to 3.7.3.3, Document Node Constructors, Rule 3.)
 Also add a new node-kind: "namespace-node()" to node tests.


 (13) XQuery 1.1: In a FLWOR, the count clause should be accepted as
 intermediate clause only (not initial clause). Requires change to grammar
 and draft document. Snelson was not present, will be given a chance to object.
 Decided in Telcon 376, 9/9/08.
 - Grammar done

 Revision 1.25  2008/10/01 21:40:10  jrobie3
 Made the following changes:

 (1) XQuery 1.1: Try/catch
 JR try/catch proposal in Query/2008Jun/0170. Group approved the
 proposal, with minor revisions, to be added to XQuery 1.1. Text and
 examples relating to updates and/or scripting should be changed to
 non-normative notes (or deleted) since XQuery 1.1 does not include
 updates or scripting. Approved in F2F at Edinburgh, week of 6/23/08.

 (2) XQuery 1.1: Bug 5472
 M.Kay proposal to extend the "validate" expression to add
 optional ("as" typename)? following ValidationMode. As now, the operand
 expression must return exactly one document or element node.
 Approved in F2F at Oracle, week of 3/31/08.

 (3) XQuery 1.1: Nondeterministic Functions
 DC proposal in Query/2008Mar/0084, as amended: Allow keywords
 on external function decls only. Support both "deterministic" and
 "nondeterministic". Default is nondeterministic. The compiler infers
 the property of internal functions by static analysis.
 Approved in F2F at Oracle, week of 3/31/08.

 (4) XQuery 1.1: Defaults for external variables
 DC proposal in Query/2008Mar/0092, as amended: Change "default" to ":=".
 Approved in F2F at Oracle, week of 3/31/08.

 Revision 1.24  2008/09/30 12:30:28  jrobie3
 Added try/catch expression.

 Revision 1.23  2008/09/17 22:00:26  dchamber
 Applied errata XP.E11 and XQ.E20. Unable to build html files due to disfunctional tools.

 Revision 1.22  2008/09/03 19:17:41  dchamber
 Corrected the resolution of Bug 5290 (rules for comparing ordering-keys in order-by clause). Fixed an error identified by Mike Kay (see Bugzilla 5290).

 Revision 1.21  2008/09/02 23:39:48  dchamber
 Correcting errors found by Mike Kay's review of grouping and windowing sections. Work in progress.

 Revision 1.20  2008/08/30 00:27:48  dchamber
 Made some improvements to the windowing section, suggested by Tim Kraska.

 Revision 1.19  2008/08/29 17:39:21  dchamber
 Applied Errata XQ.E9, XQ.E10, XQ.E11, XQ.E12; also XP.E1 and XP.E7

 Revision 1.18  2008/08/27 17:45:57  dchamber
 Applied errata XQ.E6, XQ.E7, and XQ.E8.

 Revision 1.17  2008/08/22 00:10:51  dchamber
 Corrected minor markup errors discovered when applying XQ.E4 and XP.E4.

 Revision 1.16  2008/08/21 23:01:48  dchamber
 Applied Errata XQ.E3, XQ.E4, XQ.E5
 (same as Errata XP.E3, XP.E4, XP.E5).

 Revision 1.15  2008/08/21 18:11:15  dchamber
 Applied Errata XQ.E1 and XQ.E2.

 Revision 1.14  2008/08/19 23:17:53  dchamber
 Made a few small revisions to the window and count clauses, suggested by John Snelson.

 Revision 1.13  2008/08/15 23:59:30  dchamber
 (1) Implemented Snelson proposal for simplified FLWOR expression.
 (2) Implemented count clause as approved in Edinburgh F2F on 23 June 2008.
 (3) Implemented outer-for feature as approved in Oracle F2F on 31 March 2008.
 (4) Added example to group-by section as required by action A-373-06.

 Revision 1.12  2008/08/14 18:51:34  dchamber
 Implementing Snelson proposal for simplified FLWOR expression (work in progress.)

 Revision 1.11  2008/08/14 00:12:49  dchamber
 Implementing Snelson proposal for simplified FLWOR expression (work in progress).

 Revision 1.10  2008/08/07 23:49:24  dchamber
 Partial work on simplified FLWOR expression (relaxes order of clauses, adds "count" clause.) Work in progress.

 Revision 1.9  2008/07/09 18:37:43  jrobie3
 In grouping, changed the following phrase:

 Original:
   but these values may not be identical
 Mistaken disambiguation:
   but these values must not be identical
 Corrected disambiguation:
   but these values are not necessarily identical

 Revision 1.8  2008/06/30 19:16:23  jrobie3
 Minor editorial cleanup. Also, changed "may not" to "must not" where
 this clarifies the meaning.

 Revision 1.7  2008/06/10 14:47:02  jrobie3
 *** empty log message ***

 Revision 1.6  2008/06/02 23:40:00  jrobie3
 For WG review before publishing as a first WD.

 Revision 1.5  2008/04/16 21:12:25  dchamber
 Finished integrating group-by feature into XQuery 1.1, including two new error conditions.

 Revision 1.4  2008/04/16 18:34:40  dchamber
 Partial integration of group-by feature into XQuery 1.1. Still work in progress.

 Revision 1.3  2008/04/16 00:28:52  dchamber
 Partial completion of group-by section. Work in progress.

 Revision 1.2  2008/04/14 13:23:48  jrobie3
 Added productions to XQuery 1.1 grammar.

 Revision 1.1  2007/03/13 20:48:59  NormanWalsh
 Initial checkin

 Revision 1.62  2007/01/05 17:18:27  sboag
 Repared CR/LFs for Don.

 Revision 1.61  2006/11/09 15:19:34  NormanWalsh
 Updated by Norm and Don

 Revision 1.58  2005/10/25 20:27:38  sboag
 Removed role-"parse-test" from element that holds a clearly incomplete expression.

 Revision 1.57  2005/10/21 04:27:02  sboag
 Don's latest changes.

 Revision 1.56  2005/09/01 20:36:35  NormanWalsh
 Edits from Don

 Revision 1.55  2005/07/27 02:47:41  sboag
 Added a validate of the unassembled doc for target xquery.html, as a sanity check,
 Removed <nt> brackets around QName and NCName, since the don't work and
 I'm not sure how to fix them, of if they should be fixed, at the moment, and
 added xpath- prefix to to id's that were xpath only, but had xquery equivelents
 elsewhere (escapeQuot and escapeAPos).

 Revision 1.54  2005/07/10 07:13:41  sboag
 July 10 draft.

 Revision 1.52  2005/07/08 16:53:30  sboag
 Don's latest edits.  See changes.txt for details.

 Revision 1.51  2005/03/28 14:16:14  NormanWalsh
 Updates from DC

 Revision 1.42  2004/10/26 17:23:48  NormanWalsh
 Pubrules tweaks

 Revision 1.41  2004/10/18 14:56:39  sboag
 Don's checkin.  See changes.txt (1.5) for this checkin for more info.

 Revision 1.40  2004/07/14 21:02:20  NormanWalsh
 Updated function/datatype namespaces; tweaked status; 23 July draft, pubrules clean

 Revision 1.39  2004/07/13 12:20:39  NormanWalsh
 Log update, I think. Not signficant anyway.

 Revision 1.35  2004/06/07 08:27:13  sboag
 Change of Validation stuff, according to request note from Don.

 Revision 1.33  2004/05/31 18:32:21  sboag
 Latest grammar changes, part of last call comments response.  (Sorry for lack
 of fine-grained detail, but CVS has been down for a week.)  The EBNF is a proposal,
 with change markings.

 Revision 1.31  2004/05/14 20:15:52  sboag
 Latest integration effort between Don and Scott.

 Revision 1.27  2003/12/05 01:04:09  sboag
 Change name of Predicates production to PredicateList.  Approved at Oracle F2F, 11/5/03

 Revision 1.26  2003/12/04 21:54:00  sboag
 Global search-replace: DC requests to change the production-names of
 SchemaMode and SchemaContext to ValidationMode and ValidationContext, to more closely match the explanatory text. Editorial change only. Names of other related productions (SchemaContextLoc etc.) remain unchanged.

 Revision 1.25  2003/12/04 16:45:21  sboag
 Change FilterStep to FilterExpr as per http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Nov/0014.html

 Revision 1.24  2003/11/07 01:58:07  NormanWalsh
 Added xpath-dt-static-typing-feature link

 Revision 1.23  2003/11/04 19:23:32  NormanWalsh
 Added required class attributes; added new informative bibl entries

 Revision 1.22  2003/10/30 04:25:50  sboag
 Changed ComputedXMLComment to CompXMLComment, as per http://lists.w3.org/Archives/Public/public-qt-comments/2003Oct/0056.html (editorial discretion taken)

 Revision 1.21  2003/10/28 19:29:20  NormanWalsh
 Tweaked document order per Jeni

 Revision 1.20  2003/10/28 19:25:16  NormanWalsh
 Ran through crlf to get rid of DOS line breaks...sigh.

 Revision 1.19  2003/10/28 13:55:28  NormanWalsh
 Final edits from Don

 Revision 1.16  2003/08/27 01:52:17  sboag
 Fed through dos2unix, to clean up extra CRs.

 Revision 1.15  2003/08/13 18:31:47  NormanWalsh
 Updates from Don on 7 Aug

 Revision 1.13  2003/07/31 18:09:48  sboag
 Don's latest edits, along with the module namespace changed originally outlined in http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jul/0218.html, and approved by XQuery July 30.

 Revision 1.12  2003/07/22 17:59:09  sboag
 Reduce production names to max 20:
 Original Name	Len	New Name	Len
 MustUnderstandExtension	23	MUExtension	11
 QuoteAttributeContentChar	25	QuotAttrContentChar	18
 AposAttributeContentChar	24	AposAttrContentChar	18
 AbbreviatedForwardStep	22	AbbrevForwardStep	17
 AbbreviatedReverseStep	22	AbbrevReverseStep	17
 ComputedDocumentConstructor	27	CompDocConstructor	18
 ComputedElementConstructor	26	CompElemConstructor	19
 ComputedAttributeConstructor	28	CompAttrConstructor	19
 ComputedNamespaceConstructor	28	LocalNamespaceDecl	17
 ComputedXmlProcessingInstruction	32	CompPIConstructor	9
 ComputedTextConstructor	23	CompTextConstructor	19
 XmlProcessingInstruction	24	DirPIConstructor	5
 QuoteAttributeValueContent	26	QuotAttrValueContent	20
 AposAttributeValueContent	25	AposAttrValueContent	20
 ProcessingInstructionTest	25	PITest	6
 SchemaContextLocation	21	SchemaContextLoc	16
 
 Revision 1.11  2003/07/22 14:26:31  sboag
 Latest edits from Don.  Pre production name reduction.

 Revision 1.10  2003/07/08 15:59:35  sboag
 Fixed 2 obvious expression bugs.

 Revision 1.9  2003/07/01 15:21:19  sboag
 Fixed validation, which includes fixing LF problems, termref/termdef attribute mess, and nt fixes.  (stylesheet fix needs to come with this).

 Revision 1.8  2003/06/30 16:18:23  sboag
 Fix double-dash problems inside comments that Mary entered.

 Revision 1.7  2003/06/26 02:37:00  mfernand

 June 25, 2003 - Mary

 Changes to documents:
 =========================
   Modified files:
     lang/XPathXQuery.xml
     lang/expressions.xml
     lang/introduction.xml
     lang/query-prolog.xml
     lang/shared.html
     lang/xquery.html
     lang/xpath.html

   Added file:
     lang/errors.xml

   o Added markup for error definitions and references in all sections.

     - Error definitions are in new file: lang/errors.xml.

   o Added term definitions and references.

     - Additions required some minor editing to sentences/paragraphs so
       that term definitions were self-contained in Glossary.

     - All term definitions in Secs 1 & 2 should be complete.

       Exceptions: definitions of "Optional Features" are not pithy, thus
       not amenable to definition in a glossary.

     - All references in Secs 1 - 4 to terms defined in Secs 1 and 2
       are marked-up.

     - A smattering of term definitions in Secs 3 & 4 are done.
       Whomever continues with term markup should begin here.

     NB: I did not add any new term definitions - - I simply converted as
     many <term> elements as possible to <termdef>s or <termref>s.
     I did not change any term definitions other than to make them
     self-contained.

 Known styling problems (need help from Norm):
 =============================
   o Need to add "spec" attribute to <termdef> to scope term
     definitions within a particular document (e.g., "XP" or "XQ")

     - Current bug: terms that should only be defined in XQuery book
       also appear in XPath book.

   o Glossary should probably be emitted in alphabetic order.

   o Not sure what to do about errors of this kind:

     "style/issues-spec.xsl:248:20: Warning! Cannot point to resolved
     issue: #xquery-abstract-syntax"

 Issues/Questions:
 =============================
   o Should Glossary be labeled as normative?

   o Should Summary of Error Codes be labeled as normative?

 Revision 1.6  2003/06/12 22:31:50  jrobie

 Made the documents consistent with the following grammar changes:

 (a) Use "declare" consistently in prolog (replacing "define") and get
 rid of all uses of "=" except between prefix and URI. See Issue
 547. Changed terminology accordingly - "function definitions" are now
 "function declarations", "user-defined functions" are now
 "user-declared functions", etc.


 (b) Limit comments, pragmas, and extensions to places inside XQuery
 expressions where insignificant whitespace is allowed. See Issue 550.

 (c) Change if-expr so both then-clause and else-clause take ExprSingle,
 not Expr. See Query/May/0006.

 (d) New clause in Prolog: "declare" "base-uri" StringLiteral
 Scope is the module in which it is declared. Proposed by M. Rys in
 Query/Apr/0001 and adopted by Query WG telcon, 5/7/03.


 (h) Change "." to be a primary expr rather than an abbreviated step.
 See http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Apr/0200.html.

 (i) Change to PITest so it allows an NCName as well as a
 StringLiteral, as proposed by JR.
 See http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Apr/0256.html.

 (16) Change to Prolog syntax: function declarations can now be mixed
 with variable and other declarations. Approved, Query WG F2F, 5/16/03.

 Revision 1.5  2003/06/10 20:53:47  jrobie
 Processing model diagrams.

 Revision 1.4  2003/06/10 20:48:09  jrobie
 *** empty log message ***

 Revision 1.3  2003/04/18 22:01:52  NormanWalsh
 Editorial nits for pubrules

 Revision 1.2  2003/04/18 19:22:04  sboag
 Don's latest revisions, responding to comments from the working groups.

 Revision 1.1  2003/04/07 22:18:05  sboag
 Initial checkin of language build and parser build.

 Revision 1.29  2002/11/07 21:45:36  sboag
 Integrated new XSL from http://www.w3.org/2002/xmlspec/html/1.4/xmlspec.xsl,
 Fixed a couple minor bugs that this helpful stylesheet flagged.

 Revision 1.28  2002/11/07 19:30:56  sboag
 changed to 2.2 xmlspec, and deleted all xmlspec-v21.xxx.  Fixed BNF
 problem with OcurrenceIndicator.  Fixed prevdoc problem.

 Revision 1.27  2002/11/07 00:27:14  sboag
 Minor changes specified by today's editorial meeting, dictated by Don to me over the phone.

 Revision 1.24  2002/11/05 16:18:45  sboag
 Minor parse test fixes.

 Revision 1.23  2002/11/05 16:13:01  sboag
 Don's final Nov. 15 drafts.

 Revision 1.20  2002/08/14 16:06:35  sboag
 Fixed up example URLs to use example.org.

 Revision 1.18  2002/08/12 03:02:22  sboag
 Fixed problems with comments from previous check-in.

 Revision 1.17  2002/08/12 02:40:48  sboag
 Check for role="parse-test" for all legitimate expression examples.  ***status: Did the best I could with <code> and <eg> examples.
 -> fixed discovered bug in grammar where document {...} constructor did not work.
 -> fixed bug with processing instruction content... I had to add a PROCESSING_INSTRUCTION_CONTENT state.
 -> fixed minor bug with end tag not being closed in expressions.xml (ugh, took me 30 minutes to track down).
 -> in section on "Other Constructors", broke samples into separate <eg>s, so they will parse (otherwise they expect an operator between them).
 -> fixed problem with CDataSection outside of element content.  (...if PI, XMLComments work, so should CDataSection, I guess).
 -> broke some/every examples in section on "Quantified Expressions" into two <eg> tags, since they can process sequentially.
      -> Also had to conditionalize these examples for XPath, so that the TypeDeclaration wasn't
           used (actually, it seems useless here).
 -> Fixed many problems with "validate".  However, see note on '"validate" seems to be reserved'.  Two of the fragments currently won't parse.

 Revision 1.15  2002/08/10 22:01:47  sboag
 Changed "default collation at" to "default collation ="

 Revision 1.14  2002/08/04 21:06:21  sboag
 The following changes from the last F2F:

 (1) Delete "precedes" and "follows" operators from OrderComp.

 (2) Change name of TypeAssertion production to TypeDeclaration.

 (3) Add the following new production:

 DefaultCollationDecl ::= "default" "collation" StringLiteral

 (A collation is identified by a URI, so you can use a more specific symbol in place of StringLiteral that indicates that a URI is expected, if you want to.)

 (4) Delete the production for ResultTypeDecl.

 (5) QueryProlog should now include DefaultCollationDecl but not ResultTypeDecl, as follows:

 QueryProlog ::= (NamespaceDecl | DefaultNamespaceDecl | SchemaImport | XMLSpaceDecl
    | DefaultCollationDecl)* FunctionDefn*

 Revision 1.13  2002/07/28 19:53:05  sboag
 Don's new documents.

 Revision 1.12  2002/07/04 18:29:22  sboag
 Simply made prerecap ref refer to itself.  This was a regression, because at one
 point I had deleted this production.

 Revision 1.11  2002/06/28 09:02:07  sboag
 Merged Don's latest work with new grammar proposal.  Changes too numerous
 to detail.

 Revision 1.10  2002/04/24 22:48:30  sboag
 Fixed minor problem with lists-within-lists-within-paragraphs.

 Revision 1.9  2002/04/24 22:21:18  sboag
 Don's changes assigned to him by this morning's telcon.

 Revision 1.8  2002/04/24 02:48:08  sboag
 CSS, HTML, Link validation passes.  Parser tests pass.  Updated to target
 pub date of April 30.

 Revision 1.6  2002/04/23 17:20:33  sboag
 Removed DocumentElement from production 61, as per WG decision.
 Fixed Dana's company and email address.
 Added section on reserved words (list is mechanically generated).
 Addressed the following issues in the lexical section from
 (http://lists.w3.org/Archives/Public/www-xml-query-comments/2002Jan/0002.html),
 lengthy Michael Dyck.  Not all issues have been addressed yet.
 

  <item priority="2" status="done"> <description>para 1: "Whitespace may be
 		  freely added within patterns" What do you mean by "patterns"? Presumably,
 		  you're either talking about adding the symbol 'Whitespace' to grammar
 		  productions, or adding whitespace (i.e., sequences of characters) to queries.
 		  Don't confuse the two.</description></item>
 

  <item priority="2" status="done"> <description>"before or after any
 		  token" But you never actually define what a token is. It's not even clear what
 		  the set of token-types is. (Is it the set of left-hand-sides of producbtions 75
 		  through 216? Is it the set of symbols that appear in the "tokens" column of the
 		  TRANITION STATES table? The two are different, and both contain symbols that
 		  probably shouldn't be considered token-types.)</description></item>
 

  <item status="done"> <description>para 1 and bullets 1 and 2: Note that
 		  the Whitespace symbol derives the empty string, but phrases like "must always
 		  be followed by whitespace" and "whitespace may not occur" obviously mean
 		  "whitespace" in the sense of "a non-empty string of whitespace-characters". I
 		  think this shows correct usage, and there's no reason for Whitespace to be
 		  nullable. (That is, it should be the same as S.)</description></item>
 

  <item status="done"> <description>bullet 3: "A space" We're interested in
 		  whitespace, not just a space.</description></item>
 

  <item status="done"> <description>"may be significant" Don't tell us that
 		  it *may* be significant. Tell us exactly when it *is*
 		  significant.</description></item>
 

  <item status="done"> <description>para 2: "Tokens may be often only
 		  recognized" "may be often only" is clunky.</description></item>
 

  <item status="done"> <description>"in a specific state" You haven't
 		  defined states yet.</description></item>
 

  <item status="done"> <description>"within the evaluation": Does
 		  evaluation of a query include its parsing/lexing?</description></item>
 

  <item status="done"> <description>"may cause the grammar to transition to
 		  a different state" Grammars don't have states or transitions. Automata
 		  do.</description></item>
 

  <item status="done"> <description>"following the enumeration of tokens"
 		  Change "tokens" to "token-types".</description></item>
 

  <item status="done"> <description>para 3: "When tokenizing, the longest
 		  possible token is always returned" Issue 109 says this means "the longest
 		  sequence that would form a token in the token-space of the grammar, not the
 		  longest that would be valid in the current syntactic context." Does
 		  it?</description></item>
 

  <item status="done"> <description>"If there is an ambiguity between two
 		  tokens, ..." Presumably, you mean an ambiguity that isn't resolved by the
 		  longest-match rule.</description></item>
 

  <item status="done"> <description>"the token that an lower grammar
 		  number" Change "an" to "a".</description></item>
 

  <item status="done"> <description>is more specific than" Why do we care
 		  which is "more specific"? We want to know which is the right one. I'll assume
 		  that's what you mean.</description></item>

 Revision 1.5  2002/04/22 15:23:24  sboag
 Don says: I believe that these drafts contain all the substantive comments
 that were raised at the Cambridge task force meetings and subsequent
 telcons. These are the drafts that will be reviewed for publication. Additional
 minor editorial changes may be made before the documents are actually
 submitted to w3c.

 Revision 1.1  2002/04/01 20:10:30  sboag
 Jonathan Robie changes, including removal of fragment.xml and inclusion of
 expressions.xml, etc.
 Merge of his grammar with latest.


 Revision 1.42  2001/12/17 20:27:29  sboag
 Fixes for every-header-has-to-have-an-id.

 Revision 1.41  2001/12/16 06:31:59  sboag
 Minor fix to the comment ednote.

 Revision 1.37  2001/12/14 20:47:43  sboag
 Fixed some bad links.

 Revision 1.36  2001/12/14 17:21:26  sboag
 Fixed link.

 Revision 1.28  2001/12/11 17:09:44  sboag
 Don's suggested modifications to the grammar.  Also temporarily commented
 out the pathx1 build, 'till I get it fixed.

 Revision 1.27  2001/12/10 02:45:49  sboag
 Fixed some of the code examples that read <p><code>some example</code></p>.

 Revision 1.25  2001/12/09 22:07:16  sboag
 Fixed problem with comments from previous checkin.

 Revision 1.24  2001/12/09 21:39:37  sboag
 [batch checkin] Added {- - comment - -} type comments.  Added ";" list 
 query processing.  Added some stuff for ^char handling in reg 
 expressions, in order to support CharData better, but backed 
 out of this (but left some of the support in.  Removed old type def 
 and group stuff (can look to previous versions if we want to add this 
 back in).  Changed to case sensitivity in grammar, and updated 
 fragment.xml.  Added optional (AT schemaLocation)? to SchemaImport.  
 Other minor changes in support of WG decisions.

 Revision 1.23  2001/12/08 15:15:25  sboag
 Jonathan and Scott tweaked paragraph about QName escape.

 Revision 1.22  2001/12/07 23:34:28  sboag
 Add note about escaping QNames in the Basics section, pending resolution
 of the issue about what to do about possible EQName token.  Don needs to review.
 Removed paragraph again about enclosed expressions in element constructors. 

 Revision 1.20  2001/12/07 08:55:45  sboag
 Made rule about space before "<" be xquery spec only.

 Revision 1.19  2001/12/07 08:29:26  sboag
 Added ednote about space before "<" rule.

 Revision 1.18  2001/12/07 08:19:17  sboag
 Add <{foo}/> syntax, as per direction of XQuery WG.  Need to check about the
 enclosed expression syntax for attribute names, which I also added.

 Revision 1.17  2001/12/07 07:36:15  sboag
 Fix data-type section for XPath (remove Typeswitch, CaseClause).

 Revision 1.16  2001/12/07 07:06:38  sboag
 Changed BuiltInType to SimpleType in grammar and text.
 Removed Remove *:*.
 Defined IntegerLiteral, DecimalLiteral, and DoubleLiteral.
 Took a shot at fixing the "-" lexical rule in arithmatic section.
 Defined IntegerLiteral, DecimalLiteral, and DoubleLiteral. 

==================================================================== 
-->
<!-- 

float*date

send a value to a function that is expecting a node

"make a list of the errors that can be determined statically"

-->
<div1 id="id-basics"> 
  <head>     Basics</head> 
	 <p>The basic  building block of XQuery 1.1 is the
	 <term>expression</term>, which is a string of <bibref ref="Unicode"/> characters (the version of Unicode to be used is <termref def="dt-implementation-defined">implementation-defined</termref>.)
	 The language provides several kinds of expressions which may be constructed
	 from keywords, symbols, and operands. In general, the operands of an expression
	 are other expressions. XQuery 1.1 allows expressions to be nested with full
generality. <phrase role="xquery">(However, unlike a pure functional
language, it does not allow variable substitution if the variable
declaration contains construction of new nodes.)</phrase>
      </p> 
	 <note>
        <p>This specification contains no 
assumptions or requirements regarding the character set encoding of strings 
of <bibref ref="Unicode"/> characters.</p>
      </note>
      <p>Like XML, XQuery 1.1 is a case-sensitive language. Keywords in
	 XQuery 1.1 use lower-case characters and are not reserved—that is, names in XQuery 1.1 expressions are allowed to be the same as language keywords, except for certain unprefixed function-names listed in <specref ref="id-reserved-fn-names"/>.</p> 
	  
	 <p>
        <termdef term="value" id="dt-value">In the <termref def="dt-datamodel">data model</termref>, a <term>value</term> is always a <termref def="dt-sequence">sequence</termref>.</termdef> <termdef id="dt-sequence" term="sequence">A
<term>sequence</term> is an ordered collection of zero or more
<termref def="dt-item">items</termref>.</termdef>
<termdef id="dt-item" term="item">An
	 <term>item</term> is either an <termref def="dt-atomic-value">atomic value</termref> or a <termref def="dt-node">node</termref>.</termdef>
<termdef id="dt-atomic-value" term="atomic value">An <term>atomic
	 value</term> is a value in the value space of an <term>atomic
	 type</term>, as defined in <bibref ref="XMLSchema"/>.</termdef>
<termdef id="dt-node" term="node">A <term>node</term> is an instance of one of the
	  <term>node kinds</term> defined in <bibref ref="xpath-datamodel-11"/>.</termdef>
Each node has a unique <term>node identity</term>, a <term>typed value</term>, and a <term>string value</term>. In addition, some nodes have a <term>name</term>. The <term>typed value</term> of a node is a sequence
	 of zero or more atomic values. The <term>string value</term> of a node is a
	 value of type <code>xs:string</code>. The <term>name</term> of a node is a value of type <code>xs:QName</code>.
<termdef id="dt-undefined" term="undefined" diff="add" at="XQ.E23 and XP.E15"> In certain situations a value is said to be     
        <term>undefined</term> (for
	example, the value of the context item, or the typed value of an element node).
	This term indicates that the property in question has no value and that any
	attempt to use its value results in an error.</termdef>
</p> 
	 <p>
        <termdef id="dt-singleton" term="singleton">A sequence containing exactly one item is called a
	 <term>singleton</term>.</termdef> An item is identical to a singleton sequence
	 containing that item. Sequences are never nested—for example, combining the
	 values 1, (2, 3), and ( ) into a single sequence results in the sequence (1, 2,
	 3). <termdef id="dt-empty-sequence" term="empty sequence">A sequence containing zero items is called an <term>empty sequence</term>.</termdef>
      </p>
	  <p>
        <termdef id="dt-data-model-instance" term="XDM instance">The term <term>XDM instance</term> is used, synonymously with the term <term>value</term>, to denote an unconstrained sequence of <termref def="dt-node">nodes</termref> and/or <termref def="dt-atomic-value">atomic values</termref> in the <termref def="dt-datamodel">data model</termref>.</termdef> </p>


	  <p>Names in XQuery 1.1 can be bound to namespaces, and are
	  based on the syntax and semantics defined in <bibref ref="XMLNAMES"/>. <termdef id="dt-qname" term="lexical QName">A
	  <term>lexical QName</term> is a name that conforms to the syntax of
	  <xnt xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/REC-xml-names/#NT-QName" xlink:type="simple">
	  [http://www.w3.org/TR/REC-xml-names/#NT-QName]</xnt>.</termdef>
	  A <termref def="dt-qname">lexical QName</termref> consists of an optional namespace prefix and a local
	  name. If the namespace prefix is present, it is separated
	  from the local name by a colon. A <termref def="dt-qname">lexical QName</termref> can be
	  converted into an <termref def="dt-expanded-qname">expanded
	  QName</termref> by resolving its namespace prefix to a
	  namespace URI, using the <termref def="dt-static-namespaces">statically known
	  namespaces</termref> <errorref code="0081" class="ST"/>. In the
	  XQuery 1.1 grammar, most names are specified using the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-EQName" xlink:type="simple">EQName</nt> production, which allows <termref def="dt-qname">lexical QNames</termref>,
	  and also allows a namespace URI to be specified as a
	  literal:</p>

	  <scrap headstyle="show"> 
	    <head/> 
	    <prod num="196" id="doc-xquery11-EQName">
          <lhs>EQName</lhs>
          <rhs>
            <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-QName" xlink:type="simple">QName</nt>  |  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-URILiteral" xlink:type="simple">URILiteral</nt>  ":"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-NCName" xlink:type="simple">NCName</nt>)</rhs>
        </prod> 
	    <prod num="NaN" id="noid_N104B1.doc-xquery11-QName">
          <lhs>QName</lhs>
          <rhs>
            <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="Names" ref="NT-QName" xlink:type="simple">[http://www.w3.org/TR/REC-xml-names/#NT-QName]</xnt>
          </rhs>
        </prod> 
	    <prod num="NaN" id="noid_N104B4.doc-xquery11-NCName">
          <lhs>NCName</lhs>
          <rhs>
            <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="Names" ref="NT-NCName" xlink:type="simple">[http://www.w3.org/TR/REC-xml-names/#NT-NCName]</xnt>
          </rhs>
        </prod> 
	    <prod num="195" id="noid_N104B7.doc-xquery11-URILiteral">
          <lhs>URILiteral</lhs>
          <rhs>
            <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-StringLiteral" xlink:type="simple">StringLiteral</nt>
          </rhs>
        </prod> 
	  </scrap>

	  <p>
        <termdef id="dt-expanded-qname" term="expanded QName">An
	  <term>expanded QName</term> consists of an optional
	  namespace URI and a local name. An expanded QName also
	  retains its original namespace prefix (if any), to
	  facilitate casting the expanded QName into a
	  string.</termdef> The namespace URI value is whitespace
	  normalized according to the rules for the
	  <code>xs:anyURI</code> type in <bibref ref="XMLSchema"/>. Two <termref def="dt-expanded-qname">expanded QNames</termref> are equal if their
	  namespace URIs are equal and their local names are equal
	  (even if their namespace prefixes are not equal). Namespace
	  URIs and local names are compared on a codepoint basis,
	  without further normalization.</p>

<p role="xquery">Certain namespace prefixes are predeclared by XQuery and bound to fixed namespace URIs. These namespace prefixes are as follows:</p>
      <p/>  
<ulist>

  <item role="xquery">
          <p>
            <code>xml = http://www.w3.org/XML/1998/namespace</code>
          </p>
        </item>

  <item>
          <p>
            <code>xs = http://www.w3.org/2001/XMLSchema</code>
          </p>
        </item>

  <item role="xquery">
          <p>
            <code>xsi = http://www.w3.org/2001/XMLSchema-instance</code>
          </p>
        </item>

  <item>
          <p>
            <code>fn = http://www.w3.org/2005/xpath-functions</code>
          </p>
        </item>

  <item role="xquery">
          <p>
            <code>local = http://www.w3.org/2005/xquery-local-functions</code> (see <specref ref="FunctionDeclns"/>.)</p>
        </item>

  

  <item role="xquery">
          <p>
            <code>output = http://www.w3.org/2009/xquery-serialization</code> (see <specref ref="id-serialization"/>.)</p>
        </item>

</ulist>
      <p role="xquery">In addition to the prefixes in the above list, this document uses the prefix <code>err</code> to represent the namespace URI <code>http://www.w3.org/2005/xqt-errors</code> (see <specref ref="id-identifying-errors"/>). This namespace prefix is not predeclared and its use in this document is not normative.</p> 
	 <p>Element nodes have a property called <term>in-scope namespaces</term>. <termdef term="in-scope namespaces" id="dt-in-scope-namespaces">The <term>in-scope namespaces</term> property of an element node is a set of <term>namespace bindings</term>, each of which associates a namespace prefix with a URI, thus defining the set of namespace prefixes that are available for interpreting <termref def="dt-qname">lexical QNames</termref> within the scope of the element. For a given element, one namespace binding may have an empty prefix; the URI of this namespace binding is the default namespace within the scope of the element.</termdef>
      </p>
      <note role="xquery">
        <p>In <bibref ref="xpath"/>, the in-scope namespaces of an element node are represented by a collection of <term>namespace nodes</term> arranged on a <term>namespace axis</term>, which is optional and deprecated in <bibref ref="xpath-21"/>. XQuery does not support the namespace axis and does not represent namespace bindings in the form of nodes. However, where other specifications such as <bibref ref="xslt-xquery-serialization-11"/> refer to namespace nodes, these nodes may be synthesized from the in-scope namespaces of an element node by interpreting each namespace binding as a namespace node.</p>
      </note>
      <p>
        <termdef term="URI" id="dt-URI">Within this specification, the term <term>URI</term> refers to a Universal Resource Identifier as
defined in <bibref ref="RFC3986"/> and extended in <bibref ref="RFC3987"/> with the new name <term>IRI</term>.</termdef>  The term URI has been retained in preference to IRI to avoid introducing new names for concepts such as "Base URI" that are defined or referenced across the whole family of XML specifications.</p>
      <div2 id="context"> 
		<head>Expression Context</head> 
		<p>
          <termdef id="dt-expression-context" term="expression context">The <term>expression context</term> for a given expression consists of
		all the information that can affect the result of the expression.</termdef> This
		information is organized into two categories called
	 the <termref def="dt-static-context">static
		context</termref> and the <termref def="dt-dynamic-context">dynamic context</termref>.</p> 
		 
		<div3 id="static_context"> 
		  <head>Static Context</head> 
		  <p>
            <termdef id="dt-static-context" term="static context">The <term>static context</term> of an expression is
		  the information that is available during static analysis of the expression, prior
		  to its evaluation.</termdef> This information can be used to decide whether the
		  expression contains a <termref def="dt-static-error">static error</termref>.
		  If analysis of an 
expression relies on some component of the <termref def="dt-static-context">static context</termref> that has not been 
assigned a value, a <termref def="dt-static-error">static
		  error</termref> is raised <errorref code="0001" class="ST"/>.</p> 
		  <p>The individual components of the <termref def="dt-static-context">static context</termref> are summarized below.  <phrase role="xquery">Rules governing the scope and initialization of  these components can be found in  <specref ref="id-xq-static-context-components" role="xquery"/>.</phrase>
          </p> 
		   
		  <ulist> 
			 

  <item>
              <p>
                <termdef id="dt-xpath-compat-mode" term="XPath 1.0 compatibility     mode">
                  <term>XPath 1.0 compatibility
			 mode.</term> <phrase role="xquery">This
			 component must be set by all host languages
			 that include XPath 2.1  as a subset,
			 indicating whether rules for compatibility
			 with XPath 1.0 are in effect.
			 XQuery sets the value of this component to
			 <code>false</code>.
                         </phrase> </termdef>
              </p>
            </item> 
			 

  <item> 
				<p>
                <termdef id="dt-static-namespaces" term="statically known namespaces">
                  <term>Statically known namespaces.</term> This is a set of (prefix,
				URI) pairs that define all the namespaces that are known during static processing of a given expression.</termdef> The URI value is 
whitespace normalized according to the rules for the <code>xs:anyURI</code> type in <bibref ref="XMLSchema"/>. Note the difference between <termref def="dt-in-scope-namespaces">in-scope namespaces</termref>, which is a dynamic property of an element node, and <termref def="dt-static-namespaces">statically known namespaces</termref>, which is a static property of an expression.</p>
              <p role="xquery">Some namespaces are predefined; additional  namespaces can be added to the statically known namespaces by <termref def="dt-namespace-declaration">namespace declarations</termref> in a <termref def="dt-prolog">Prolog</termref> and by <termref def="dt-namespace-decl-attr">namespace declaration attributes</termref> in <termref def="dt-direct-elem-const">direct element constructors</termref>.</p> 
			 </item> 
			 

  <item> 
				<p>
                <termdef id="dt-def-elemtype-ns" term="default element/type namespace">
                  <term>Default element/type namespace.</term> This is a
				namespace URI or "none". The namespace URI, if present, is used for any unprefixed QName appearing in a
				position where an element or type name is expected.</termdef> The URI value is 
whitespace normalized according to the rules for the <code>xs:anyURI</code> type in <bibref ref="XMLSchema"/>.</p> 
			 </item> 
			 

  <item> 
				<p>
                <termdef id="dt-def-fn-ns" term="default function namespace">
                  <term>Default function namespace.</term> This is a
				namespace URI or "none". The namespace URI, if present, is used for any unprefixed QName appearing in a position where a function name is expected.</termdef> The URI value is 
whitespace normalized according to the rules for the <code>xs:anyURI</code> type in <bibref ref="XMLSchema"/>.</p> 
			  </item> 
			 

  <item> 
				<p>
                <termdef id="dt-issd" term="in-scope schema definitions">
                  <term>In-scope schema
			 definitions.</term> This is a generic term
			 for all the element declarations, attribute declarations, and schema type
			 definitions that are in scope during
			 processing of an expression.</termdef> It includes the
			 following three
			 parts:</p>
<ulist>

  <item>
                  <p>

			        <termdef id="dt-is-types" term="in-scope schema type">
                      <term>In-scope schema types.</term> Each schema type
			        definition is identified either by an <termref def="dt-expanded-qname">expanded
			        QName</termref> (for a <term>named type</term>)
			        or by an <termref def="dt-implementation-dependent">implementation-dependent</termref> type
			        identifier (for an <term>anonymous
			        type</term>). The in-scope schema types include the predefined schema types described in <specref ref="id-predefined-types"/>.

                                <phrase role="xquery">If the
                                <termref def="dt-schema-import-feature">Schema Import Feature</termref> is
                                supported, in-scope schema types
                                also include all type definitions
                                found in imported schemas.</phrase>

                         </termdef>
                  </p>

</item>




  <item>
                  <p>
                    <termdef id="dt-is-elems" term="in-scope element declarations">
                      <term>In-scope element declarations.</term> Each element
declaration is identified either by an <termref def="dt-expanded-qname">expanded QName</termref> (for a top-level element
declaration) or by an <termref def="dt-implementation-dependent">implementation-dependent</termref> element identifier (for a
local element declaration). <phrase role="xquery"> If the <termref def="dt-schema-import-feature">Schema Import Feature</termref> is
supported, in-scope element declarations include all element
declarations found in imported schemas. </phrase>
                    </termdef> An element
declaration includes information about the element's <termref def="dt-substitution-group">substitution group</termref> affiliation.</p>
                  <p>
                    <termdef term="substitution group" id="dt-substitution-group">
                      <term>Substitution groups</term> are defined in <bibref ref="XMLSchema"/> Part 1,  Section 2.2.2.2. Informally, the substitution group headed by a given element (called the <term>head element</term>) consists of  the set of elements that can be substituted for the head element without affecting the outcome of schema validation.</termdef>
                  </p>
                </item>

  <item>
                  <p>
                    <termdef id="dt-is-attrs" term="in-scope attribute declarations">
                      <term>In-scope attribute
declarations.</term> Each attribute declaration is identified either
by an <termref def="dt-expanded-qname">expanded QName</termref> (for a top-level attribute declaration) or by an
<termref def="dt-implementation-dependent">implementation-dependent</termref> attribute identifier (for a local attribute
declaration).  <phrase role="xquery">If the <termref def="dt-schema-import-feature">Schema Import Feature</termref> is
supported, in-scope attribute declarations include all attribute
declarations found in imported
schemas.</phrase>
                    </termdef>
                  </p>
                </item>
              </ulist> </item> 

  <item> <p>
<termdef id="dt-in-scope-variables" term="in-scope variables">
                  <term>In-scope variables.</term> This is a set of (<termref def="dt-expanded-qname">expanded QName</termref>, type) pairs. It defines the
set of variables that are available for reference within an
expression. The <termref def="dt-expanded-qname">expanded QName</termref> is the name of the variable, and the type is the
<termref def="dt-static-type">static type</termref> of the
variable.</termdef>
              </p>

<p>
                <phrase role="xquery">Variable declarations in a <termref def="dt-prolog">Prolog</termref> are added to <termref def="dt-in-scope-variables">in-scope variables</termref>.</phrase> An
expression that binds a variable (such as a <code>let</code>, <code>for</code>,
<code>some</code>, or <code>every</code> expression) extends the
<termref def="dt-in-scope-variables">in-scope variables</termref> of
its subexpressions with the new bound variable and its type. <phrase role="xquery">Within a <term>function declaration</term>, the <termref def="dt-in-scope-variables">in-scope variables</termref> are extended
by the names and types of the <term>function
parameters</term>.</phrase>
              </p>

<p role="xquery">The static type of a variable may either be declared in a query or 
inferred by static type inference as discussed in  <specref ref="id-static-typing-feature"/>.</p>
				 
			 </item>

  <item>
              <p>
                <termdef term="context item static type" id="dt-context-item-static-type">
                  <term>Context item static type.</term> This component defines the <termref def="dt-static-type">static type</termref> of the context item within the scope of a given expression.</termdef>
              </p>
            </item> 
			 

  <item> 
				<p>
                <termdef id="dt-function-signature" term="function signature">
                  <term>Function signatures.</term> This component defines the set of functions that are available
				to be called from within an
			 expression. Each function is uniquely
			 identified by its <termref def="dt-expanded-qname">expanded QName</termref> and its arity (number
			 of parameters).</termdef> In addition to the name and arity, each function signature specifies the <termref def="dt-static-type">static types</termref> of the function parameters and  result.</p>

                         <p>The <termref def="dt-function-signature">function signatures</termref> include the signatures of <termref def="dt-constructor-function">constructor functions</termref>, which are
                         discussed in <specref ref="id-constructor-functions"/>.</p>

			 </item> 
			 

  <item> 
				<p> <termdef id="dt-static-collations" term="statically known collations">
                  <term>Statically known collations.</term> This is an <termref def="dt-implementation-defined">implementation-defined</termref> set of (URI,
				collation) pairs. It defines the names of the collations that are available for
				use in processing <phrase role="xquery">queries and</phrase> expressions.</termdef> <termdef term="collation" id="dt-collation">A <term>collation</term> is a specification of the manner in which strings and URIs are compared and, by extension, ordered. For a more complete definition of collation, see <bibref ref="xpath-functions-11"/>.</termdef>
              </p> 
			 </item> 
			 

  <item> 

				<p> <termdef id="dt-def-collation" term="default collation">
                  <term>Default
				collation.</term> This identifies one of the collations in <termref def="dt-static-collations">statically known collations</termref> as the  collation to be
				used by functions and operators for comparing and ordering values of type <code>xs:string</code> and <code>xs:anyURI</code> (and types derived from them) when no
				explicit collation is
				specified.</termdef>
              </p>

			 </item>

  <item role="xquery">
              <p>
                <termdef id="dt-construction-mode" term="construction mode">
                  <term>Construction mode.</term> The
			 construction mode governs the behavior of element and document node constructors. If construction mode is <code>preserve</code>, the type of a constructed element node is <code>xs:anyType</code>, and all attribute and element nodes copied during node construction    retain their original types. If construction mode is <code>strip</code>, the type of a constructed element node is <code>xs:untyped</code>; all element nodes copied during node construction receive the type <code>xs:untyped</code>, and all attribute nodes copied during node construction receive the type <code>xs:untypedAtomic</code>.</termdef>
              </p>
            </item>

  <item role="xquery">
              <p>
                <termdef id="dt-ordering-mode" term="ordering mode">
                  <term>Ordering mode.</term> Ordering mode, which has the value <code>ordered</code> or <code>unordered</code>, affects the ordering of the result sequence returned by certain <termref def="dt-path-expression">path expressions</termref>, FLWOR expressions, and <code>union</code>, <code>intersect</code>, and <code>except</code> expressions.</termdef> Details are provided in the descriptions of these expressions.</p>
            </item>

  <item role="xquery">
              <p>
                <termdef id="dt-default-empty-order" term="default order for empty sequences">
                  <term>Default order for empty sequences.</term> This component controls the processing of empty sequences and <code>NaN</code> values as ordering keys in an <code>order by</code> clause in a FLWOR expression, as described in <specref ref="id-order-by-clause"/>.</termdef>  Its value may be <code>greatest</code> or <code>least</code>.</p>
            </item>

  <item role="xquery">
<p>
                <termdef id="dt-boundary-space-policy" term="boundary-space policy">
                  <term>Boundary-space
			 policy.</term> This component controls the processing of <termref def="dt-boundary-whitespace">boundary whitespace</termref>
			 by <termref def="dt-direct-elem-const">direct element constructors</termref>, as described in <specref ref="id-whitespace"/>.</termdef> Its value may be <code>preserve</code> or <code>strip</code>.</p>
            </item> 
			 

  <item role="xquery">
              <p>
                <termdef id="dt-copy-namespaces-mode" term="copy-namespaces mode">
                  <term>Copy-namespaces mode.</term> This component controls the namespace bindings that 
are assigned when an existing element node is copied by an element 
constructor, as described in <specref ref="id-element-constructor"/>. Its value consists of two parts: <code>preserve</code> or <code>no-preserve</code>, and <code>inherit</code> or <code>no-inherit</code>.</termdef>
              </p>
            </item>

  <item> 
    <p>
                <termdef id="dt-base-uri" term="base URI">
                  <term>Base
    URI.</term> This is an absolute URI, used when necessary to
    <termref def="dt-resolve-relative-uri">resolve a relative
    URI</termref>.</termdef> The URI value is whitespace normalized
    according to the rules for the <code>xs:anyURI</code> type in
    <bibref ref="XMLSchema"/>.</p>
  </item>


  <item>
              <p> <termdef id="dt-known-docs" term="statically known  documents">
                  <term>Statically known documents.</term> This is a mapping
from strings onto types.  The string represents the absolute URI of a
resource that is potentially available using the <code>fn:doc</code>
function.  The type is the <termref def="dt-static-type">static type</termref> of a call to <code>fn:doc</code>  with the given URI as its
literal argument. </termdef> 
If the argument to <code>fn:doc</code> is a
string literal that is not present in <term>statically known documents</term>, then the
<termref def="dt-static-type">static type</termref> of
<code>fn:doc</code> is <code>document-node()?</code>.</p>
<note>
                <p>The purpose of the <term>statically known
documents</term> is to provide static type information, not to determine
which documents are available. A URI need not be found in the
<term>statically known documents</term> to be accessed using
<code>fn:doc</code>. </p>
              </note>
</item>



  <item>
              <p>
                <termdef id="dt-known-collections" term="statically known  collections">
                  <term>Statically known collections.</term> This is a
mapping from strings onto types.  The string represents the absolute
URI of a resource that is potentially available using the
<code>fn:collection</code> function.  The type is the type of the
sequence of nodes that would result from calling the
<code>fn:collection</code> function with this URI as its
argument.</termdef> If the argument to
<code>fn:collection</code> is a string literal that is not present in
<term>statically known collections</term>, then the <termref def="dt-static-type">static type</termref> of
<code>fn:collection</code> is <code>node()*</code>.</p>
              <note>
                <p>The purpose of the <term>statically known
collections</term> is to provide static type information, not to determine
which collections are available. A URI need not be found in the
<term>statically known collections</term> to be accessed using
<code>fn:collection</code>. 
</p>
              </note>
            </item>

  <item>
              <p>
                <termdef id="dt-known-default-collection" term="statically known default collection type">
                  <term>Statically known default collection type.</term> This is the type of the sequence of nodes that would result from calling the <code>fn:collection</code> function with no arguments.</termdef> Unless initialized to some other value by an implementation, the value of <term>statically known default collection type</term> is <code>node()*</code>.</p>
            </item>


  <item>
              <p>
                <termdef id="dt-static-decimal-formats" term="statically   known decimal formats">
                  <term>Statically known decimal
  formats.</term> This is the set of known decimal formats. Each
  format is used for serializing decimal numbers using <code>fn:format-number()</code>.</termdef> 

  Each format is identified by an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-EQName" xlink:type="simple">EQName</nt>, except
  for the default format, which has no visible name.  Each format
  contains the properties described in the following paragraphs.</p>

  <p>The following properties control the interpretation of characters
  in the picture string supplied to the <code>fn:format-number</code>
  function, and also specify characters that may appear in the result
  of formatting the number. In each case the value must be a single
  character (see <errorref class="ST" code="0100"/>):</p>

  <ulist>
  <item>
                  <p>
                    <termdef id="id-static-decimal-separator" term="decimal-separator">
                      <term>decimal-separator</term>
  specifies the character used for the decimal-separator-sign; the
  default value is the period character (.)</termdef>
                  </p>
                </item>

    <item>
                  <p>
                    <termdef id="id-static-decimal-format-grouping-separator" term="grouping-separator">
                      <term>grouping-separator</term>
    specifies the character used for the grouping-sign, which is
    typically used as a thousands separator; the default value is the
    comma character (,)</termdef>
                  </p>
                </item>

    <item>
                  <p>
                    <termdef id="id-static-decimal-format-percent-sign" term="percent-sign">
                      <term>percent-sign</term>
    specifies the character used for the percent-sign; the default
    value is the percent character (%)</termdef>
                  </p>
                </item>

    <item>
                  <p>
                    <termdef id="id-static-decimal-format-per-mille-sign" term="per-mille-sign">
                      <term>per-mille-sign</term>
    specifies the character used for the per-mille-sign; the default
    value is the Unicode per-mille character
    (#x2030)</termdef>
                  </p>
                </item>

    <item>
                  <p>
                    <termdef id="id-static-decimal-format-zero-digit" term="zero-digit">
                      <term>zero-digit</term>
    specifies the character used for the digit-zero-sign; the default
    value is the digit zero (0). This character must be a digit
    (category Nd in the Unicode property database), and it must have
    the numeric value zero. This attribute implicitly defines the
    Unicode character that is used to represent each of the values 0
    to 9 in the final result string: Unicode is organized so that each
    set of decimal digits forms a contiguous block of characters in
    numerical sequence.</termdef>
                  </p>
                </item>
  </ulist>

  <p>The following attributes control the interpretation of
  characters in the picture string supplied to the format-number
  function. In each case the value must be a single character 
  (see <errorref class="ST" code="0100"/>).
  </p>
 
  <ulist>
    <item>
                  <p>
                    <termdef id="id-static-decimal-format-digit-sign" term="digit-sign">
                      <term>digit-sign</term> specifies the character used for the digit-sign in the picture string; the default value is the number sign character (#)</termdef>
                  </p>
                </item>
    <item>
                  <p>
                    <termdef id="id-static-decimal-format-pattern-separator-sign" term="pattern-separator-sign">
                      <term>pattern-separator-sign</term> specifies the character used for the
pattern-separator-sign, which separates positive and negative sub-pictures
in a picture string; the default value is the semi-colon character (;)</termdef>
                  </p>
                </item>
  </ulist>

  <p>The following attributes specify characters or strings that
  may appear in the result of formatting the number:</p>

  <ulist>
    <item>
                  <p>
                    <termdef id="id-static-decimal-format-infinity" term="infinity">
                      <term>infinity</term> specifies the string used for the infinity-symbol; the
default value is the string Infinity</termdef>
                  </p>
                </item>
    <item>
                  <p>
                    <termdef id="id-static-decimal-format-NaN" term="NaN">
                      <term>NaN</term> specifies the string used for the NaN-symbol, which is used to
represent the value NaN (not-a-number); the default value is the string NaN</termdef>
                  </p>
                </item>
    <item>
                  <p>
                    <termdef id="id-static-decimal-format-minus-sign" term="minus-sign">
                      <term>minus-sign</term> specifies the character used for the minus-symbol; the
default value is the hyphen-minus character (-, #x2D). The value must be a
single character.</termdef>
                  </p>
                </item>
  </ulist>
  </item>		 

</ulist> 


</div3>
<div3 id="eval_context"> <head>Dynamic Context</head> <p>
            <termdef id="dt-dynamic-context" term="dynamic context">The <term>dynamic
context</term> of an expression is defined as information that is
available at the time the expression is evaluated.</termdef> If
evaluation of an expression relies on some part of the <termref def="dt-dynamic-context">dynamic context</termref> that has not been
assigned a value, a <termref def="dt-dynamic-error">dynamic
error</termref> is raised <errorref class="DY" code="0002"/>.</p>
          <p>The individual
components of the <termref def="dt-dynamic-context">dynamic
context</termref> are summarized below. Further rules governing the
semantics of these components can be found in <specref ref="id-xq-evaluation-context-components" role="xquery"/>.</p>
          <p>The
<termref def="dt-dynamic-context">dynamic context</termref> consists
of all the components of the <termref def="dt-static-context">static
context</termref>, and the additional components listed below.</p>
<p>
            <termdef id="dt-focus" term="focus">The first three components of
the <termref def="dt-dynamic-context">dynamic context</termref>
(context item, context position, and context size) are called the
<term>focus</term> of the expression. </termdef> The focus enables the
processor to keep track of which items are being processed by the
expression.</p> <p>Certain language constructs, notably the <termref def="dt-path-expression">path
expression</termref> <code role="parse-test">E1/E2</code> and the <termref def="dt-predicate">predicate</termref> <code role="parse-test">E1[E2]</code>, create a new focus
for the evaluation of a sub-expression. In these constructs, <code role="parse-test">E2</code> is evaluated once for each item in the
sequence that results from evaluating <code role="parse-test">E1</code>. Each time <code role="parse-test">E2</code> is evaluated, it is evaluated with a
different focus. The focus for evaluating <code role="parse-test">E2</code> is referred to below as the <term>inner
focus</term>, while the focus for evaluating <code role="parse-test">E1</code> is referred to as the <term>outer
focus</term>. The inner focus exists only while <code role="parse-test">E2</code> is being evaluated. When this evaluation
is complete, evaluation of the containing expression continues with
its original focus unchanged.</p> 
<ulist> 

  <item> <p>
                <termdef id="dt-context-item" term="context item">The <term>context item</term>
is the item currently being processed. An item is
either an atomic value or a node.</termdef>
                <termdef id="dt-context-node" term="context node">When the context item is a
node, it can also be referred to as the <term>context
node</term>.</termdef> The context item is returned by an expression
consisting of a single dot (<code role="parse-test">.</code>). When an expression <code role="parse-test">E1/E2</code> or <code role="parse-test">E1[E2]</code> is evaluated, each item in the
sequence obtained by evaluating <code role="parse-test">E1</code>
becomes the context item in the inner focus for an evaluation of <code role="parse-test">E2</code>. </p> </item> 

  <item> <p>
                <termdef id="dt-context-position" term="context position">The <term>context
position</term> is the position of the context item within the
sequence of items currently being processed.</termdef> It changes whenever the context item
changes. When the focus is defined, the value of the context position is an integer greater than zero. The context
position is returned by the expression <code role="parse-test">fn:position()</code>. When an expression <code role="parse-test">E1/E2</code> or <code role="parse-test">E1[E2]</code> is evaluated, the context position in
the inner focus for an evaluation of <code role="parse-test">E2</code>
is the position of the context item in the sequence obtained by
evaluating <code role="parse-test">E1</code>. The position of the
first item in a sequence is always 1 (one). The context position is
always less than or equal to the context size.</p> </item> 

  <item>
<p>
                <termdef id="dt-context-size" term="context size">The <term>context
size</term> is the number of items in the sequence of items currently
being processed.</termdef> Its value is always an
integer greater than zero. The context size is returned by the
expression <code role="parse-test">fn:last()</code>. When an expression
<code role="parse-test">E1/E2</code> or <code role="parse-test">E1[E2]</code> is evaluated, the context size in the
inner focus for an evaluation of <code role="parse-test">E2</code> is
the number of items in the sequence obtained by evaluating <code role="parse-test">E1</code>. </p> </item>
			  
			 

  <item> 
				<p> <termdef id="dt-variable-values" term="variable values">
                  <term>Variable values</term>. This is a set of
				(<termref def="dt-expanded-qname">expanded QName</termref>, value) pairs. It contains the
				same <termref def="dt-expanded-qname">expanded QNames</termref> as the <termref def="dt-in-scope-variables">in-scope variables</termref> in the
				<termref def="dt-static-context">static context</termref> for the expression. The <termref def="dt-expanded-qname">expanded QName</termref> is the name of the variable and the value is the dynamic value of the variable, which includes its <termref def="dt-dynamic-type">dynamic type</termref>.</termdef>
              </p> 
				 
				 
			 </item>

  <item>
              <p>
                <termdef term="function implementation" id="dt-function-implementation">
                  <term>Function implementations</term>. Each function in <termref def="dt-function-signature">function signatures</termref> has a function implementation that enables the function to map instances of its parameter types into an instance of its result type. <phrase role="xquery">For a
			 <termref def="dt-udf">user-defined function</termref>, the
			 function implementation is an XQuery
			 expression. For a <termref def="dt-built-in-function">built-in function</termref> or <termref def="dt-external-function">external
			 function</termref>, the function implementation is
			 <termref def="dt-implementation-dependent">implementation-dependent</termref>.</phrase>
                </termdef>
              </p>
            </item> 
			 

  <item> 
				<p> <termdef id="dt-date-time" term="current dateTime">
                  <term>Current dateTime.</term> This information represents
				an <termref def="dt-implementation-dependent">implementation-dependent</termref> point in time during the processing of <phrase role="xquery">a query</phrase>, and includes an explicit timezone. It can be retrieved by the  <code>fn:current-dateTime</code> function. If invoked multiple times during the execution of <phrase role="xquery">a query</phrase>,
				this function always returns the same result.</termdef>
              </p> 
			 </item>

  <item>
              <p>
                <termdef id="dt-timezone" term="implicit timezone">
                  <term>Implicit timezone.</term> This is the timezone to be used when a date,
time, or dateTime value that does not have a timezone is used in a
comparison or arithmetic operation. The implicit timezone is an  <termref def="dt-implementation-defined">implementation-defined</termref> value of type
<code>xs:dayTimeDuration</code>. See <bibref ref="XMLSchema"/> for the range of legal values
                         of a timezone.</termdef>
              </p>
            </item>
                         

  <item>
              <p>
                <termdef id="dt-available-docs" term="available documents">
                  <term>Available
                         documents.</term> This is a mapping of
                         strings onto document nodes.  The string
                         represents the absolute URI of a
                         resource. The document node is the root of a tree that represents that resource using the <termref def="dt-datamodel">data model</termref>. The document node is returned by the <code>fn:doc</code> function when applied to that URI.</termdef> The set of available
                         documents is not limited to the set of <termref def="dt-known-docs">statically known
                         documents</termref>, and it may be
                         empty.</p>
              <p>If there are one or more URIs in <termref def="dt-available-docs">available documents</termref> that map to a document
node <code>D</code>, then the document-uri property of <code>D</code> must either be absent, or must
be one of these URIs.</p>
              <note>
                <p>This means that given a document node <code>$N</code>, the result of
<code role="parse-test">fn:doc(fn:document-uri($N)) is $N</code> will always be True, unless
<code role="parse-test">fn:document-uri($N)</code> is an empty sequence.</p>
              </note>
            </item>

  <item>
              <p>
                <termdef id="dt-available-collections" term="available collections">
                  <term>Available
                         collections.</term> This is a mapping of
                         strings onto sequences of nodes. The string
                         represents the absolute URI of a
                         resource. The sequence of nodes represents
                         the result of the <code>fn:collection</code>
                         function when that URI is supplied as the
                         argument. </termdef> The set of available
                         collections is not limited to the set of <termref def="dt-known-collections">statically known
                         collections</termref>, and it may be empty.</p>
              <p>For every document node <code>D</code> that is in the target of a mapping in <termref def="dt-available-collections">available collections</termref>, or that is the root of a tree containing such a node, the document-uri property of <code>D</code> must either be absent, or must be a
URI <code>U</code> such that <termref def="dt-available-docs">available documents</termref> contains a mapping from <code>U</code> to <code>D</code>."

</p>
              <note>
                <p>This means that for any document node <code>$N</code> retrieved using the
<code>fn:collection</code> function, either directly or by navigating to the root of a
node that was returned, the result of <code role="parse-test">fn:doc(fn:document-uri($N)) is $N</code>
will always be True, unless <code>fn:document-uri($N)</code> is an empty sequence. This
implies a requirement for the <code>fn:doc</code> and <code>fn:collection</code> functions to be
consistent in their effect. If the implementation uses catalogs or
user-supplied URI resolvers to dereference URIs supplied to the <code>fn:doc</code>
function, the implementation of the <code>fn:collection</code> function must take these
mechanisms into account. For example, an implementation might achieve this
by mapping the collection URI to a set of document URIs, which are then
resolved using the same catalog or URI resolver that is used by the <code>fn:doc</code> function.</p>
              </note>
            </item>
                         

  <item>
              <p>
                <termdef id="dt-default-collection" term="default collection">
                  <term>Default collection.</term> This is the sequence of nodes that would result from calling the <code>fn:collection</code> function with no arguments.</termdef> The value of <term>default collection</term> may be initialized by the implementation.</p>
            </item>
          </ulist> </div3> </div2>
      <div2 id="id-processing-model">
        <head>Processing
                         Model</head>
        <p>XQuery 1.1 is defined in terms
                         of the <termref def="dt-datamodel">data
                         model</termref> and the <termref def="dt-expression-context">expression
                         context</termref>.</p> <graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="ProcMod-XQuery.gif" alt="Processing                          Model Overview" role="xquery" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/>
        <p>Figure 1:
                         Processing Model Overview</p>

<p>Figure 1 provides a schematic overview of the processing steps that
are discussed in detail below. Some of these steps are completely
outside the domain of XQuery 1.1; in Figure 1, these are depicted
outside the line that represents the boundaries of the language, an
area labeled <term>external processing</term>. The external processing
domain includes generation of an <termref def="dt-data-model-instance">XDM instance</termref> that represents the data to be queried (see <specref ref="id-data-model-generation"/>), schema import processing (see
<specref ref="id-schema-import-processing"/>) and serialization (see
<specref ref="id-serialization"/>). The area inside the boundaries of
the language is known as the <phrase role="xquery">
            <term>query processing domain</term>
          </phrase>, which includes the static
analysis and dynamic evaluation phases (see <specref ref="id-expression-processing"/>).  Consistency constraints on the
<phrase role="xquery">query</phrase> processing domain are defined in <specref ref="id-consistency-constraints"/>.</p>


<div3 id="id-data-model-generation">
          <head>Data Model Generation</head>

<p>Before <phrase role="xquery">a query</phrase> can be processed, its input data must be represented as an <termref def="dt-data-model-instance">XDM instance</termref>. This process occurs outside
the domain of XQuery 1.1, which is why Figure 1 represents it in the
external processing domain. Here are some steps by which an XML
document might be converted to an <termref def="dt-data-model-instance">XDM instance</termref>:</p>

<olist>

  <item>
              <p>A document may be parsed using an XML parser that
generates an <term>XML Information Set</term> (see <bibref ref="XINFO"/>). The parsed document may then be validated against one
or more schemas. This process, which is described in <bibref ref="XMLSchema"/>, results in an abstract information structure called
the <term>Post-Schema Validation Infoset</term> (PSVI). If a document
has no associated schema, its Information Set is preserved. (See DM1
in Fig. 1.)</p> </item>

  <item>
              <p>The Information Set or PSVI may be
transformed into an <termref def="dt-data-model-instance">XDM instance</termref>
by a process described in <bibref ref="xpath-datamodel-11"/>. (See DM2 in
Fig. 1.)</p> </item>
          </olist>
          <p>The above steps provide an example of how an <termref def="dt-data-model-instance">XDM instance</termref> might be constructed. An XDM instance might
also be synthesized directly from a relational database, or
constructed in some other way (see DM3 in Fig. 1.) XQuery 1.1 is defined in terms
of the <termref def="dt-datamodel">data model</termref>,
but it does not place any constraints on how XDM instances are constructed.</p>

<p>
            <termdef term="type annotation" id="dt-type-annotation">Each element node and attribute node in an <termref def="dt-data-model-instance">XDM instance</termref> has a <term>type annotation</term> (referred to in <bibref ref="xpath-datamodel-11"/> as its <code>type-name</code> property.) The type annotation of a node is a <termref def="dt-schema-type">schema type</termref> that describes the relationship between the <termref def="dt-string-value">string value</termref> of the node and its <termref def="dt-typed-value">typed value</termref>.</termdef>  If the <termref def="dt-data-model-instance">XDM instance</termref> was derived from a validated XML document as described in <xspecref spec="DM" ref="const-psvi"/>, the type annotations of the element and attribute nodes are derived from schema
validation. XQuery 1.1 does
not provide a way to directly access the type annotation of an element
or attribute node.</p>
          <p>The value of an attribute is represented directly within the
attribute node. An attribute node whose type is unknown (such as might
occur in a schemaless document) is given the <termref def="dt-type-annotation">type annotation</termref>
<code>xs:untypedAtomic</code>.</p>

<p>The value of an element is represented by the children of the
element node, which may include text nodes and other element
nodes. The <termref def="dt-type-annotation">type annotation</termref> of an element node indicates how the values in
its child text nodes are to be interpreted. An element that has not been validated (such as might occur in a schemaless document) is annotated
with the schema type <code>xs:untyped</code>. An element that has been validated and found to be partially valid is annotated with the schema type <code>xs:anyType</code>. If an element node is annotated as <code>xs:untyped</code>, all its descendant element nodes are also annotated as <code>xs:untyped</code>. However, if an element node is annotated as <code>xs:anyType</code>, some of its descendant element nodes may have a more specific <termref def="dt-type-annotation">type annotation</termref>.</p>




</div3>

<div3 id="id-schema-import-processing">
<head>Schema Import Processing</head>
<p role="xquery">The <termref def="dt-issd">in-scope
schema definitions</termref> in the <termref def="dt-static-context">static context</termref> may be extracted from
actual XML schemas (see step SI1 in Figure 1) or may be
generated by some other mechanism (see step SI2 in Figure 1). In
either case, the result must satisfy the consistency constraints
defined in <specref ref="id-consistency-constraints"/>.</p>

</div3>
        <div3 id="id-expression-processing">
          <head>Expression
Processing</head>
          <p>XQuery 1.1 defines two phases of processing called
the <termref def="dt-static-analysis">static analysis phase</termref>
and the <termref def="dt-dynamic-evaluation">dynamic evaluation
phase</termref> (see Fig. 1).  During the static analysis phase, <termref def="dt-static-error">static errors</termref>,  <termref def="dt-dynamic-error">dynamic errors</termref>, or <termref def="dt-type-error">type errors</termref> may be raised. During the dynamic evaluation phase, only <termref def="dt-dynamic-error">dynamic errors</termref> or <termref def="dt-type-error">type errors</termref> may be raised. These kinds of errors are defined in <specref ref="id-kinds-of-errors"/>.  </p>
          <p>Within each phase, an implementation is free to use any
strategy or algorithm whose result conforms to the
specifications in this document.</p>

<div4 id="id-static-analysis">
            <head>Static Analysis Phase</head>
            <p>
              <termdef id="dt-static-analysis" term="static analysis phase">The
<term>static analysis phase</term> depends on the expression itself
and on the <termref def="dt-static-context">static context</termref>. The <term>static analysis phase</term> does
not depend on input data (other than schemas).</termdef>
            </p>
<p>During the static analysis phase, the <phrase role="xquery">query</phrase> is parsed into an
internal representation called the <term>operation tree</term> (step
SQ1 in Figure 1).  A parse error is raised as a <termref def="dt-static-error">static error</termref> <errorref class="ST" code="0003"/>. The <termref def="dt-static-context">static context</termref> is initialized by the implementation (step SQ2). <phrase role="xquery">The <termref def="dt-static-context">static context</termref> is then changed and augmented based on information in the  <term>prolog</term> (step SQ3). If the <termref def="dt-schema-import-feature">Schema Import Feature</termref> is supported, the <termref def="dt-issd">in-scope schema definitions</termref> are populated with information from imported schemas. If the <termref def="dt-module-feature">Module 
Feature</termref> is supported, the static context is extended with function 
declarations and variable declarations from imported modules.</phrase> The <termref def="dt-static-context">static context</termref> is used to resolve schema type names, function names, namespace prefixes, and variable names (step
SQ4). 
If a name of one of these kinds in the <term>operation tree</term> is
not found in the <termref def="dt-static-context">static context</termref>, a <termref def="dt-static-error">static error</termref> (<errorref class="ST" code="0008"/> or <errorref class="ST" code="0017"/>) is raised (however, see exceptions to this rule in <specref ref="id-element-test"/> and <specref ref="id-attribute-test"/>.)</p>

<p>The <term>operation tree</term> is then
<term>normalized</term> by making explicit the implicit operations
such as <termref def="dt-atomization">atomization</termref> and extraction of <termref def="dt-ebv">Effective Boolean Values</termref> (step SQ5).</p>

<p>During the <termref def="dt-static-analysis">static analysis
phase</termref>, an XQuery processor may perform type analysis. The
effect of type analysis is to assign a <termref def="dt-static-type">static type</termref> to each expression in the
operation tree. <termdef id="dt-static-type" term="static type">The
<term>static type</term> of an expression is the best inference that
the processor is able to make statically about the type of the result
of the expression.</termdef> This specification does not define the
rules for type analysis nor the static types that are assigned to
particular expressions: the only constraint is that the inferred type
must match all possible values that the expression is capable of
returning.</p>

<p>Examples of inferred static types might be:</p>

<ulist>
  <item>
    <p>For the expression <code>concat(a,b)</code> the inferred static type is <code>xs:string</code>
                </p>
  </item>

  <item>
    <p>For the expression <code>$a = $v</code> the inferred static type is <code>xs:boolean</code>
                </p>
  </item>


  <item>
    <p>For the expression <code>$s[exp]</code> the inferred static
    type has the same item type as the static type of <code>$s</code>,
    but a cardinality that allows the empty sequence even if the
    static type of <code>$s</code> does not allow an empty
    sequence.</p>
  </item>


  <item>
    <p>The inferred static type of the expression <code>data($x)</code> (whether written
    explicitly or inserted into the operation tree in places where atomization
    is implicit) depends on the inferred static type of <code>$x</code>: for example, if <code>$x</code>
    has type <code>element(*, xs:integer)</code> then <code>data($x)</code> has static type <code>xs:integer</code>.</p>
  </item>
</ulist>


<p>In XQuery 1.0, rules for static type inferencing were published
normatively in <bibref ref="xquery-semantics"/>, but implementations were allowed to
refine these rules to infer a more precise type where possible. With
XQuery 1.1, the rules are entirely implementation-defined.</p>

<p>Every kind of expression also imposes requirements on the type of its
operands. For example, with the expression <code>substring($a, $b, $c)</code>, <code>$a</code> must be
of type <code>xs:string</code> (or something that can be converted to <code>xs:string</code> by the
function calling rules), while <code>$b</code> and <code>$c</code> must be of type <code>xs:double</code>.</p>

<p>If the Static Typing Feature is in effect, an XQuery processor must signal a
type error during static analysis if the inferred static type of an
expression is not subsumed by the required type of the context where the
expression is used. For example, the call of substring above would cause a
type error if the inferred static type of <code>$a</code> is <code>xs:integer</code>; equally, a type
error would be reported during static analysis if the inferred static type
is <code>xs:anyAtomicType</code>.</p>

<p>If the Static Typing Feature is not in effect, a processor may signal a type
error during static analysis only if the inferred static type of an
expression has no overlap (intersection) with the required type: so for the
first argument of substring, the processor may report an error if the
inferred type is <code>xs:integer</code>, but not if it is <code>xs:anyAtomicType</code>.
Alternatively, if the Static Typing Feature is not in effect, the processor
may defer all type checking until the dynamic evaluation phase.</p>


</div4>
          <div4 id="id-dynamic-evaluation">
            <head>Dynamic Evaluation Phase</head>
            <p>
              <termdef id="dt-dynamic-evaluation" term="dynamic evaluation phase">The <term>dynamic evaluation phase</term> is the phase during which the value of an expression is computed.</termdef> It occurs after completion of the <termref def="dt-static-analysis">static analysis phase</termref>.</p>
            <p>The dynamic evaluation phase can occur only if no errors were detected during the <termref def="dt-static-analysis">static analysis phase</termref>. If the <termref def="dt-static-typing-feature" role="xquery">Static Typing Feature</termref> is in effect, all <termref def="dt-type-error">type errors</termref> are detected during static analysis and serve to inhibit the dynamic evaluation phase.</p>
            <p>The dynamic evaluation phase depends on the <term>operation
tree</term> of the expression being evaluated (step DQ1), on the input
data (step DQ4), and on the <termref def="dt-dynamic-context">dynamic context</termref> (step DQ5), which in turn draws information from  the external environment (step DQ3) and the <termref def="dt-static-context">static context</termref> (step DQ2). The dynamic evaluation phase may create new data-model values (step DQ4) and it may extend the <termref def="dt-dynamic-context">dynamic context</termref> (step DQ5)—for example, by binding values to variables.</p>

<p>
              <termdef term="dynamic type" id="dt-dynamic-type">A <term>dynamic type</term> is associated with each value as it is computed. The dynamic type of a value may be more specific than the <termref def="dt-static-type">static type</termref> of the expression that computed it (for example, the  static type of an expression might be <code>xs:integer*</code>, denoting a sequence of zero or more integers, but at evaluation time its value may have the dynamic type <code>xs:integer</code>, denoting exactly one integer.)</termdef>
            </p>
            <p> If an operand of an expression is found
to have a <termref def="dt-dynamic-type">dynamic type</termref> that is not appropriate for that operand, a
<termref def="dt-type-error">type error</termref> is
raised <errorref class="TY" code="0004"/>.</p>
            <p>Even though static typing can catch many <termref def="dt-type-error">type errors</termref> before an expression is executed, it is possible for an expression to raise an error during evaluation that was not detected by static  analysis. For example, an expression may contain a cast of a string into an integer, which is statically valid. However, if the actual value of the string at run time cannot be cast into an integer, a <termref def="dt-dynamic-error">dynamic error</termref> will result. Similarly, an expression may apply an arithmetic operator to a value whose <termref def="dt-static-type">static type</termref> is <code>xs:untypedAtomic</code>. This is not a <termref def="dt-static-error">static error</termref>, but at run time, if the value cannot be successfully cast to a <termref def="dt-numeric">numeric</termref> type, a <termref def="dt-dynamic-error">dynamic error</termref> will be raised.</p>
            <p>When the <termref def="dt-static-typing-feature" role="xquery">Static Typing Feature</termref> is in effect, it is also possible for static analysis of an expression to raise a <termref def="dt-type-error">type error</termref>, even though execution of the expression on certain inputs would be successful. For example, an expression might contain a function that requires an element as its parameter, and the static analysis phase might infer the <termref def="dt-static-type">static type</termref> of the function parameter to be an optional element. This case is treated as a <termref def="dt-type-error">type error</termref> and inhibits evaluation, even though the function call would have been successful for input data in which the optional element is present.</p>
          </div4>
        </div3>

<div3 id="id-serialization">
<head>Serialization</head>

<p>
            <termdef id="dt-serialization" term="serialization">
              <term>Serialization</term> is the process of
converting an <termref def="dt-data-model-instance">XDM
instance</termref> into a sequence of octets (step DM4 in Figure
1.) </termdef> The general framework for serialization is described in
<bibref ref="xslt-xquery-serialization-11"/>.</p>



<p role="xquery">An XQuery implementation is not required to provide a
serialization interface. For example, an implementation may only
provide a DOM interface (see <bibref ref="DOM"/>) or an interface
based on an event stream. In these cases, serialization would be
outside of the scope of this specification.</p>

<p role="xquery">
            <bibref ref="xslt-xquery-serialization-11"/> defines a set
of <term>serialization parameters</term> that govern the serialization
process. If an XQuery implementation provides a serialization
interface, it may support (and may expose to users) any of the
serialization parameters listed (with default values) in
<specref ref="id-xq-serialization-parameters"/>. </p>
 
<p role="xquery">
<termdef id="dt-output-declaration" term="output declaration">An <term>output declaration</term>
is an option declaration in the predeclared namespace associated with
the <code>output</code> prefix; it is used to declare an output
parameter for serializing the output of the query.</termdef>

When the application requests serialization of the output, the
processor may use these parameters to control the way in which the
serialization takes place.  Processors may also allow external
mechanisms for specifying serialization parameters, which may or may
not override serialization parameters specified in the query prolog.</p>

<example role="xquery">
<eg role="frag-prolog-parse-test" xml:space="preserve">
declare option output:method   "xml"; 
declare option output:encoding "iso-8859-1"; 
declare option output:indent   "yes"; 
</eg>
</example>

<p role="xquery">An <term>output declaration</term> may appear only in a main
module; it is a static error  <errorref class="ST" code="0108"/> if an output declaration appears in a <termref def="dt-library-module">library module</termref>. It is a static error  <errorref class="ST" code="0110"/> if
the same serialization parameter is declared more than once.

It is a <termref def="dt-static-error">static error</termref> <errorref class="ST" code="0109"/> if the local name of an output declaration in the <code>http://www.w3.org/2009/xquery-serialization</code> namespace is not  one of
the serialization parameter names listed in <specref ref="id-xq-serialization-parameters"/>.

The default value for the method parameter is "xml". An
implementation may define additional <termref def="dt-implementation-defined">implementation-defined</termref>
serialization parameters in its own namespaces. 
</p>

<!--
* An "enumerated value" is represented as an unprefixed QName, for example

  byte-order-mark = yes

* A "expanded QName" or "list of expanded QNames" is represented either as a
single QName or as a comma-separated sequence of QNames. Any unprefixed
QNames are taken as referring to names in no namespace.

* A "string of Unicode characters" is represented as a StringLiteral

* The value "absent" is represented as "()"
-->

<p role="xquery">A serialization parameter that is not applicable to the chosen output method
must be ignored, except that if its value is not a valid value for that
parameter, the error may be reported.</p>

<p role="xquery">A processor that is performing serialization must report a
serialization error if the values of any serialization parameters
(other than any that are ignored under the previous paragraph) are
incorrect. </p>

<p role="xquery">A processor that is not performing serialization may report errors if any
serialization parameters are incorrect, or may ignore such parameters.</p>

<p role="xquery">Specifying serialization parameters in a query does not by itself demand
that the output be serialized. It merely defines the desired form of the
serialized output for use in situations where the processor has been asked
to perform serialization. </p>

<note role="xquery">
            <p>The <termref def="dt-datamodel">data
model</termref> permits an element node to have
fewer <termref def="dt-in-scope-namespaces">in-scope
namespaces</termref> than its parent. Correct serialization of such an
element node would require "undeclaration" of namespaces, which is a
feature of <bibref ref="XMLNAMES11"/>. An implementation that does not
support <bibref ref="XMLNAMES11"/> is permitted to serialize such an
element without "undeclaration" of namespaces, which effectively
causes the element to inherit the in-scope namespaces of its
parent.</p>
          </note>

</div3>



<div3 id="id-consistency-constraints">

<head>Consistency Constraints</head>
          <p>In order for XQuery 1.1 to
be well defined, the input <termref def="dt-data-model-instance">XDM instance</termref>, the <termref def="dt-static-context">static context</termref>, and the <termref def="dt-dynamic-context">dynamic context</termref> must be mutually
consistent. The consistency constraints listed below are prerequisites
for correct functioning of an XQuery 1.1 implementation. Enforcement
of these consistency constraints is beyond the scope of this
specification. This specification does not
define the result of  <phrase role="xquery">a query</phrase>  under any condition in which one
or more of these constraints is not satisfied.</p>
          <p>Some of the consistency constraints use the term
<term>data model schema</term>. <termdef id="dt-data-model-schema" term="data model schema">For a given node in an <termref def="dt-data-model-instance">XDM instance</termref>, the
<term>data model schema</term> is defined as the schema from which the
<termref def="dt-type-annotation">type annotation</termref> of that node was derived.</termdef> For a node that was constructed by some
process other than schema validation, the <term>data model schema</term>
consists simply of the schema type definition that is represented by the <termref def="dt-type-annotation">type annotation</termref> of the node.</p>

<ulist>





  <item>
              <p>For every  node that has a type annotation, if that type annotation is found in the <termref def="dt-issd">in-scope schema definitions</termref> (ISSD), then its definition in the ISSD must be equivalent to its definition in the <termref def="dt-data-model-schema">data model schema</termref>. Furthermore, all types that are derived by extension from the given type in the <termref def="dt-data-model-schema">data model schema</termref> must also be known by equivalent definitions in the ISSD.</p>
            </item>

  <item>
              <p>For every element name <emph>EN</emph> that is found both in an <termref def="dt-data-model-instance">XDM instance</termref> and in the <termref def="dt-issd">in-scope schema definitions</termref> (ISSD), all elements that are known in the <termref def="dt-data-model-schema">data model schema</termref> to be in the <termref def="dt-substitution-group">substitution group</termref> headed by <emph>EN</emph> must also be known in the ISSD to be in the <termref def="dt-substitution-group">substitution group</termref> headed by <emph>EN</emph>.</p>
            </item>

  <item>
              <p>Every element name, attribute name, or schema type name referenced in <termref def="dt-in-scope-variables">in-scope variables</termref> or <termref def="dt-function-signature">function signatures</termref> must be in the <termref def="dt-issd">in-scope schema definitions</termref>, unless it is an element name referenced as part of an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ElementTest" xlink:type="simple">ElementTest</nt> or an attribute name referenced as part of an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AttributeTest" xlink:type="simple">AttributeTest</nt>.</p>
            </item>

  <item>
              <p>Any reference to a global element, attribute, or type name in
the <termref def="dt-issd">in-scope schema definitions</termref> must have a corresponding element, attribute or type
definition in the <termref def="dt-issd">in-scope schema definitions</termref>.</p>
            </item>




  <item>
              <p> For each mapping of a string to a
document node in <termref def="dt-available-docs">available
documents</termref>, if there exists a mapping of the same string to a document type in <termref def="dt-known-docs">statically known documents</termref>, the document node must match the document type, using the matching rules in <specref ref="id-sequencetype-matching"/>.</p>
            </item>


  <item>
              <p> For each mapping of a string to a sequence of nodes in
<termref def="dt-available-collections">available
collections</termref>, if there exists a mapping of the same string to
a type in <termref def="dt-known-collections">statically known collections</termref>, the sequence of nodes must match the type, using the matching rules in  <specref ref="id-sequencetype-matching"/>.</p>
            </item>

  <item>
              <p>The sequence of nodes in the <termref def="dt-default-collection">default collection</termref> must match the <termref def="dt-known-default-collection">statically known default collection type</termref>, using the matching rules in  <specref ref="id-sequencetype-matching"/>.</p>
            </item>

  <item>
              <p>The value of the <termref def="dt-context-item">context item</termref> must match the <termref def="dt-context-item-static-type">context item static type</termref>, using the
matching rules in <specref ref="id-sequencetype-matching"/>.</p>
            </item>


  <item>
              <p>For each (variable, type) pair in <termref def="dt-in-scope-variables">in-scope variables</termref> and the corresponding (variable, value) pair in <termref def="dt-variable-values">variable values</termref> such that the variable names are equal, the value must match the type, using the matching rules in  <specref ref="id-sequencetype-matching"/>.</p>
            </item>

  <item role="xquery">
              <p>For each variable declared as <code>external</code>: If the variable declaration includes a declared type, the external environment must provide a value for the variable that matches the declared type,  using the matching rules in  <specref ref="id-sequencetype-matching"/>. If the variable declaration does not include a declared type, the external environment must provide a type and a matching value, using the same matching rules.</p>
            </item>

  <item role="xquery">
              <p>For each function declared as external: the <termref def="dt-function-implementation">function
implementation</termref> must either return a value that matches the declared result type, 
using the matching rules in <specref ref="id-sequencetype-matching"/>, or raise an
<termref def="dt-implementation-defined">implementation-defined</termref> error.</p>
            </item>

  <item role="xquery">
              <p>For a given query, define a <term>participating ISSD</term> as the <termref def="dt-issd">in-scope schema definitions</termref> of a module that is used in evaluating the query. If two participating ISSDs contain a definition for the same schema type, element name, or attribute name, the definitions must be equivalent in both ISSDs. Furthermore, if two participating ISSDs each contain a definition of a schema type <emph>T</emph>, the set of types derived by extension from <emph>T</emph> must be equivalent in both ISSDs. Also, if two participating ISSDs each contain a definition of an element name <emph>E</emph>, the substitution group headed by <emph>E</emph> must be equivalent in both ISSDs.</p>
            </item>

  <item>
              <p>In the <termref def="dt-static-namespaces">statically known namespaces</termref>, the prefix <code>xml</code> must not be bound to any namespace URI other than <code>http://www.w3.org/XML/1998/namespace</code>, and no prefix other than <code>xml</code> may be bound to this namespace URI.</p>
            </item>
</ulist>
</div3>
      </div2>

<div2 id="errors">
<head>Error Handling</head>

<div3 id="id-kinds-of-errors">
          <head>Kinds of Errors</head>
          <p>
As described in <specref ref="id-expression-processing"/>, XQuery 1.1
defines a <termref def="dt-static-analysis">static analysis phase</termref>, which does not depend on input
data, and a <termref def="dt-dynamic-evaluation">dynamic evaluation
phase</termref>, which does depend on input
data.  Errors may be raised during each phase.</p>

<p>
            <termdef id="dt-static-error" term="static error">
A <term>static error</term> is an 
error that
must be detected during the static analysis phase.
A syntax error is an example of a <termref def="dt-static-error">static error</termref>.</termdef>
          </p>
<p>
<termdef id="dt-dynamic-error" term="dynamic error">A <term>dynamic
error</term> is an error that
must be detected during the dynamic evaluation phase and may be detected
during the static analysis phase.
Numeric overflow is an example of a dynamic error. 
</termdef>
</p>
<p>
<termdef id="dt-type-error" term="type error">A <term>type
error</term> may be raised during the static analysis phase or the dynamic evaluation phase.
During the static analysis phase, a <termref def="dt-type-error">type error</termref> occurs
when the <termref def="dt-static-type">static type</termref> of an expression does not match the expected type
of the context in which the expression occurs.
During the dynamic evaluation phase, a <termref def="dt-type-error">type error</termref> occurs 
when the <termref def="dt-dynamic-type">dynamic type</termref> of a value does not match the expected type of 
the context in which the value occurs.</termdef>
          </p>

<p>The outcome of the <termref def="dt-static-analysis">static analysis
phase</termref> is either success or one or more <termref def="dt-type-error">type errors</termref>, <termref def="dt-static-error">static errors</termref>, or statically-detected <termref def="dt-dynamic-error">dynamic errors</termref>. The result of the <termref def="dt-dynamic-evaluation">dynamic evaluation
phase</termref> is either a result value, a <termref def="dt-type-error">type
error</termref>, or a <termref def="dt-dynamic-error">dynamic error</termref>.</p>
          <p>If more than one error is present, or if an error condition comes within the
scope of more than one error defined in this specification, then any non-empty
subset of these errors may be reported.</p>

<p> During the <termref def="dt-static-analysis">static
analysis phase</termref>, if the <termref def="dt-static-typing-feature" role="xquery">Static Typing Feature</termref> is in effect and the <termref def="dt-static-type">static type</termref> assigned to an expression other than <code>()</code> or <code>data(())</code> is <code>empty-sequence()</code>, a <termref def="dt-static-error">static error</termref> is raised <errorref class="ST" code="0005"/>. This catches cases in which a query refers to an element or attribute that is not present in the <termref def="dt-issd">in-scope schema definitions</termref>, possibly because of a spelling error.</p>
          <p>Independently of whether the <termref def="dt-static-typing-feature" role="xquery">Static Typing Feature</termref> is in effect, if an implementation can determine during the 
<termref def="dt-static-analysis">static
analysis phase</termref> that an expression, if evaluated, would necessarily 
raise a <termref def="dt-type-error">type
error</termref> or a <termref def="dt-dynamic-error">dynamic error</termref>, the implementation may (but is not required to) report that 
error during the <termref def="dt-static-analysis">static
analysis phase</termref>. However, the
<code>fn:error()</code> function must not be evaluated during the
<termref def="dt-static-analysis">static analysis
phase</termref>.</p>
          <p>
            <termdef id="dt-warning" term="warning">In addition to <termref def="dt-static-error">static errors</termref>, <termref def="dt-dynamic-error">dynamic errors</termref>, and <termref def="dt-type-error">type
errors</termref>, an XQuery 1.1
implementation may raise <term>warnings</term>, either during the <termref def="dt-static-analysis">static analysis
phase</termref> or the
<termref def="dt-dynamic-evaluation">dynamic evaluation
phase</termref>. The circumstances in which warnings are raised, and
the ways in which warnings are handled, are <termref def="dt-implementation-defined">implementation-defined</termref>.</termdef>
          </p>
          <p>In addition to the errors defined in this
specification, an implementation may raise a <termref def="dt-dynamic-error">dynamic error</termref> for a reason beyond the scope of this specification. For
example, limitations may exist on the maximum
numbers or sizes of various objects. Any such  limitations, and the
consequences of exceeding them, are <termref def="dt-implementation-dependent">implementation-dependent</termref>.</p>
        </div3>
        <div3 id="id-identifying-errors">
          <head>Identifying and Reporting Errors</head>
          <p>The errors defined in this specification are identified by QNames that have the form <code role="xquery">err:XXYYnnnn</code>, where:</p>
<ulist>

  <item>
              <p>
                <code>err</code> denotes the namespace for XPath and XQuery errors, <code>http://www.w3.org/2005/xqt-errors</code>. This binding of the namespace prefix <code>err</code> is used for convenience in this document, and is not normative.</p>
            </item>

  

  <item role="xquery">
              <p>
                <code>XX</code> denotes the language in which the error is defined, using the following encoding:</p>

<ulist role="xquery">

  <item>
                  <p>
                    <code>XP</code> denotes an error defined by XPath. Such an error may also occur XQuery since XQuery  includes XPath as a subset.</p>
                </item>

  <item>
                  <p>
                    <code>XQ</code> denotes an error defined by XQuery.</p>
                </item>
              </ulist>
            </item>

  <item>
              <p>
                <code>YY</code> denotes the error category, using the following encoding:</p>
<ulist>

  <item>
                  <p>
                    <code>ST</code> denotes a static error.</p>
                </item>

  <item>
                  <p>
                    <code>DY</code> denotes a dynamic error.</p>
                </item>

  <item>
                  <p>
                    <code>TY</code> denotes a type error.</p>
                </item>
              </ulist>
            </item>

  <item>
              <p>
                <code>nnnn</code> is a unique numeric code.</p>
            </item>
          </ulist>
          <note>
            <p>The namespace URI for  XPath and XQuery errors is not expected to 
change from one version of XQuery 1.1 to another. However, the contents of this 
namespace may be extended to include additional error definitions.</p>
          </note>
          <p>The method by which an XQuery 1.1 processor reports error information to the external environment is <termref def="dt-implementation-defined">implementation-defined</termref>.</p>
          <p>An error can be represented by a URI reference that is derived from the error QName as follows: an error with namespace URI <emph>
              <code>NS</code>
            </emph> and local part <emph>
              <code>LP</code>
            </emph> can be represented as the URI reference <emph>
              <code>NS</code>
            </emph>
            <code>#</code>
            <emph>
              <code>LP</code>
            </emph>. For example, an error whose QName is <code>err:XPST0017</code> could be represented as <code>http://www.w3.org/2005/xqt-errors#XPST0017</code>.</p>
          <note>
            <p>Along with a code identifying an error, implementations may wish to return additional information, such 
as the location of the error or the processing phase in which it was detected. If an implementation chooses to do so, then the mechanism that 
it uses to return this information is <termref def="dt-implementation-defined">implementation-defined</termref>.</p>
          </note>
        </div3>

<div3 id="id-handling-dynamic">
          <head>Handling Dynamic Errors</head>
<p>Except as noted in this document, if any operand of an expression
raises a <termref def="dt-dynamic-error">dynamic error</termref>, the expression also raises a <termref def="dt-dynamic-error">dynamic error</termref>.
If an expression can validly return a value or raise a dynamic
error, the implementation may choose to return the value or raise
the dynamic error.  For example, the logical expression 
<code>expr1 and expr2</code> may return the value <code>false</code> 
if either operand returns <code>false</code>,
or may raise a dynamic error if either operand raises a dynamic
error.</p>
          <p> If more than one operand of an expression raises 
an error, the
implementation may choose which error is raised by the expression.
For example, in this expression:

</p>
          <eg role="parse-test" xml:space="preserve">($x div $y) + xs:decimal($z)</eg>
          <p>

both the sub-expressions <code role="parse-test">($x div $y)</code> and <code role="parse-test">xs:decimal($z)</code> may 
raise an error.  The
implementation may choose which error is raised by the "<code>+</code>"
expression.  Once one operand raises an error, the implementation is
not required, but is permitted, to evaluate any other operands.</p>

<p>
            <termdef id="dt-error-value" term="error value">In addition to its identifying QName, a dynamic error may also carry a descriptive string and one or more additional values called <term>error values</term>.</termdef> An implementation 
may provide a mechanism whereby an
application-defined error handler can process error values and
produce diagnostic messages.</p>

<p>A dynamic error may be raised by a <termref def="dt-built-in-function">built-in 
function</termref> or operator.  For example,
the <code>div</code> operator raises an error if its operands are <code>xs:decimal</code> values and its second operand
is equal to zero. Errors raised by built-in functions and operators are defined in <bibref ref="xpath-functions-11"/>.</p>

<p>A dynamic error can also be raised explicitly by calling the
<code>fn:error</code> function, which only raises an error and never
returns a value.  This function is defined in <bibref ref="xpath-functions-11"/>. For example, the following
function call raises a dynamic
error, providing a QName that identifies the error, a descriptive string, and a diagnostic value (assuming that the prefix <code>app</code> is bound to a namespace containing application-defined error codes):</p>

<eg role="parse-test" xml:space="preserve">fn:error(xs:QName("app:err057"), "Unexpected value", fn:string($v))</eg>

</div3>
        <div3 id="id-errors-and-opt">
          <head>Errors and
      Optimization</head>
          <p>Because different implementations may
      choose to evaluate or optimize an expression in different ways,
      certain aspects of the detection and reporting of <termref def="dt-dynamic-error">dynamic errors</termref> are <termref def="dt-implementation-dependent">implementation-dependent</termref>, as described in this section.</p>
          <p>An implementation is always free to evaluate the operands of an operator in any order.</p>
          <p>In some cases,  a processor can determine the result of an expression without accessing all the data that would be implied by the formal expression semantics. For example, the formal description of <termref def="dt-filter-expression">filter expressions</termref> suggests that <code role="parse-test">$s[1]</code> should be evaluated by examining all the items in sequence <code>$s</code>, and selecting all those that satisfy the predicate <code role="parse-test">position()=1</code>. In practice, many implementations will recognize that they can evaluate this expression by taking the first item in the sequence and then exiting. If <code>$s</code> is defined by an expression such as <code role="parse-test">//book[author eq 'Berners-Lee']</code>, then this strategy may avoid a complete scan of a large document and may therefore greatly improve performance. However, a consequence of this strategy is that a dynamic error or type error that would be detected if the expression semantics were followed literally might not be detected at all if the evaluation exits early. In this example, such an error might occur if there is a <code>book</code> element in the input data with more than one <code>author</code> subelement.</p>
          <p>The extent to which a processor may optimize its access to data, at the cost of not detecting errors, is defined by the following rules.</p>
          <p>Consider an expression <emph>Q</emph> that has an operand (sub-expression) <emph>E</emph>. In general the value of <emph>E</emph> is a sequence. At an intermediate stage during evaluation of the sequence, some of its items will be known and others will be unknown. If, at such an intermediate stage of evaluation, a processor is able to establish that there are only two possible outcomes of evaluating <emph>Q</emph>, namely the value <emph>V</emph> or an error, then the processor may deliver the result <emph>V</emph> without evaluating further items in the operand <emph>E</emph>. For this purpose, two values are considered to represent the same outcome if their items are pairwise the same, where nodes are the same if they have the same identity, and values are the same if they are equal and have exactly the same type.</p>
          <p>There is an exception to this rule: If a processor evaluates an operand <emph>E</emph> (wholly or in part), then it  is required to establish that the actual value of the operand <emph>E</emph> does not violate any constraints on its cardinality. For example, the expression <code role="parse-test">$e eq 0</code> results in a type error if the value of <code>$e</code> contains two or more items. A processor is not allowed to decide, after evaluating the first item in the value of <code>$e</code> and finding it equal to zero, that the only possible outcomes are the value <code>true</code> or a type error caused by the cardinality violation. It must establish that the value of <code>$e</code> contains no more than one item.</p>
<p>These rules apply to all the operands of an expression considered in combination: thus if an expression has two operands <emph>E1</emph> and <emph>E2</emph>, it may be evaluated using any samples of the respective sequences that satisfy the above rules.</p>
          <p>The rules cascade: if <emph>A</emph> is an operand of <emph>B</emph> and <emph>B</emph> is an operand of <emph>C</emph>, then the processor needs to evaluate only a sufficient sample of <emph>B</emph> to determine the value of <emph>C</emph>, and needs to evaluate only a sufficient sample of <emph>A</emph> to determine this sample of <emph>B</emph>.</p>
          <p>The effect of these rules is that the processor is free to stop examining further items in a sequence as soon as it can establish that further items would not affect the result except possibly by causing an error. For example, the processor may return <code>true</code> as the result of the expression <code role="parse-test">S1 = S2</code> as soon as it finds a pair of equal values from the two sequences.</p>
          <p>Another consequence of these rules is that where none of the items in a sequence contributes to the result of an expression, the processor is not obliged to evaluate any part of the sequence. Again, however, the processor cannot dispense with a required cardinality check: if an empty sequence is not permitted in the relevant context, then the processor must ensure that the operand is not an empty sequence.</p>
          <p>Examples:</p>


<ulist>

  <item>
              <p>If an implementation can find (for example, by using an index) that at 
least one item returned by <code>$expr1</code> in the following example has the value <code>47</code>, it is allowed to 
return <code>true</code> as the result of the <code>some</code> expression, without searching for 
another item returned by <code>$expr1</code> that would raise an error if it were evaluated.
</p>
              <eg role="parse-test" xml:space="preserve">some $x in $expr1 satisfies $x = 47</eg>
            </item>

  <item>
              <p>In the following example, if an implementation can find (for example, by using an index) the 
<code>product</code> element-nodes that have an <code>id</code> child with the value <code>47</code>, it is allowed to return these nodes as the 
result of the <termref def="dt-path-expression">path expression</termref>, without searching for another <code>product</code> node that 
would raise an error because it has an <code>id</code> child whose value is not an integer.</p>
              <eg role="parse-test" xml:space="preserve">//product[id = 47]</eg>
            </item>
          </ulist>

<!-- <change diff="chg" at="XQ.E4 and XP.E4"> -->
          <p>For a variety of reasons, including optimization, implementations 
          may rewrite expressions into a different
          form. There are a number of rules that limit the extent of this freedom:
          </p>
          <ulist>
             <item>
              <p>
                Other than the raising or not raising of errors, the result 
                of evaluating a rewritten expression must 
                conform to the semantics 
                defined in this specification for the original expression. 
             </p>
             <note>
                <p>
                This allows an implementation to return a result in cases where the
                original expression would have raised an error, or to raise an error in cases
                where the original expression would have returned a result. The main cases
                where this is likely to arise in practice are (a) where a rewrite changes the
                order of evaluation, such that a subexpression causing an error is evaluated
                when the expression is written one way and is not evaluated when the expression
                is written a different way, and (b) where intermediate results of the
                evaluation cause overflow or other out-of-range conditions. 
             </p>
              </note>
              <note>
                <p>
                This rule does not mean that the result of the expression will always
                be the same in non-error cases as if it had not been rewritten, because there
                are many cases where the result of an expression is to some degree
                <termref def="dt-implementation-dependent">implementation-dependent</termref>
                or <termref def="dt-implementation-defined">implementation-defined</termref>.
             </p>
              </note>
             </item>
            <item>
              <p>
                Conditional and typeswitch expressions 
                must not raise a dynamic error in
                respect of subexpressions occurring in a branch that is not selected,
                and must not 
                return the value delivered by a branch unless that branch is selected.
                Thus, the following example must not raise a 
                dynamic error if the document <code>abc.xml</code> does not exist:
             </p>
             <eg xml:space="preserve" role="parse-test">if (doc-available('abc.xml')) then doc('abc.xml') else ()</eg>
             </item>
            <item>
              <p>
                As stated earlier, an expression 
                must not be rewritten to dispense with a
                required cardinality check: for example, <code role="parse-test">string-length(//title)</code> 
                must raise an
                error if the document contains more than one title element.
             </p>
            </item>
            <item>
              <p>
                Expressions must not be rewritten in such a way 
                as to create or remove static errors.
                For example, there is a rule that in casting a
                string to a QName the operand must be a string literal. This rule applies to
                the original expression and not to any rewritten form of the expression.
             </p>
            </item>
          </ulist>
          <p>
          Expression rewrite is illustrated by the following examples.
          </p>
<!-- </change> -->

<ulist>

  <item>
              <p>Consider the expression <code role="parse-test">//part[color eq "Red"]</code>. An implementation might 
choose to rewrite this expression as <code role="parse-test">//part[color = "Red"][color eq 
"Red"]</code>. The implementation might then process the expression as follows: 
First process the "<code>=</code>" predicate by probing an index on parts by color to 
quickly find all the parts that have a Red color; then process the "<code>eq</code>" 
predicate by checking each of these parts to make sure it has only a 
single color. The result would be as follows: 

<ulist>

  <item>
                    <p>Parts that have exactly one color that is Red are returned.</p>
                  </item>

  <item>
                    <p>If some part has color Red together with some other color, an error is 
raised.</p>
                  </item>

  <item>
                    <p>The existence of some part that has no color Red but has multiple non-Red 
colors does not trigger an error.</p>
                  </item>
                </ulist>
              </p>
            </item>

  <item>
              <p>The expression in the following example cannot raise a casting error if it is evaluated
exactly as written (i.e., left to right). Since neither predicate depends on the context position, an implementation might choose to reorder the predicates to achieve better
performance (for example, by taking advantage of an index). This
reordering could cause the expression to raise an
error.</p>
              <eg role="parse-test" xml:space="preserve">$N[@x castable as xs:date][xs:date(@x) gt xs:date("2000-01-01")]</eg>

<p diff="chg" at="XQ.E4 and XP.E4">To avoid unexpected errors caused by expression rewrite,
tests that are designed to prevent dynamic errors should be expressed
using conditional <phrase role="xquery">or <code>typeswitch</code>
                </phrase> expressions. For example, the above expression can be written as
follows:</p>


<eg role="parse-test" xml:space="preserve">$N[if (@x castable as xs:date)
   then xs:date(@x) gt xs:date("2000-01-01")
   else false()]</eg>
            </item>
          </ulist>

</div3>
      </div2>
      <div2 id="id-important-concepts">
        <head>Concepts</head>

<p>This section explains some concepts that are important to the processing of XQuery 1.1 expressions.</p>

<div3 id="id-document-order">
          <head>Document Order</head>

        <p>An ordering called <term>document order</term> is defined among all the nodes accessible during processing of a given <phrase role="xquery">query</phrase>, which may consist of one or more <term>trees</term> (documents or fragments). Document order is defined in <bibref ref="xpath-datamodel-11"/>, and its definition is repeated here for convenience. <termdef term="reverse document order" id="dt-reverse-document-order">The node ordering that is the reverse of document order is called <term>reverse document order</term>.</termdef>
          </p>

<p>Document order is a total ordering, although the relative order of some nodes is <termref def="dt-implementation-dependent">implementation-dependent</termref>.  <termdef term="document order" id="dt-document-order">Informally, <term>document order</term> is the order in
which nodes appear in the XML serialization of a document.</termdef>  <termdef term="stable" id="stable">Document order is <term>stable</term>, which means that the relative order of two nodes will not change during the processing of a given <phrase role="xquery">query</phrase>, even if this order is <termref def="dt-implementation-dependent">implementation-dependent</termref>.</termdef>
          </p>

<p>Within a tree, document order satisfies the following constraints:</p>

<olist>


  <item>
              <p>The root node is the first node.</p>
            </item>



  <item>
              <p>Every node occurs before all of its children and descendants.</p>
            </item>



  



  <item>
              <p>Attribute nodes immediately follow the  element node with which they are associated. The relative order of
attribute nodes is stable but <termref def="dt-implementation-dependent">implementation-dependent</termref>.</p>
            </item>



  <item>
              <p>The relative order of siblings is the order in which they occur
in the <code>children</code> property of their parent node.</p>
            </item>

  <item>
              <p>Children and descendants occur before following siblings.</p>
            </item>
</olist>

<p>The relative order of nodes in distinct trees is stable but
<termref def="dt-implementation-dependent">implementation-dependent</termref>,
subject to the following constraint: If any node in a given tree T1 is before
any node in a different tree T2, then all nodes in tree T1 are before all nodes in
tree T2.</p>

        </div3>

	 <div3 id="id-atomization">
          <head>Atomization</head>
          <p>The semantics of some
XQuery 1.1 operators depend on a process called <termref def="dt-atomization">atomization</termref>. Atomization is
applied to a value when the value is used in a context in which a
sequence of atomic values is required. The result of atomization is
either a sequence of atomic values or a <termref def="dt-type-error">type error</termref>  [err:FOTY0012].  <termdef id="dt-atomization" term="atomization">
              <term>Atomization</term> of a sequence
is defined as the result of invoking the <code>fn:data</code> function
on the sequence, as defined in <bibref ref="xpath-functions-11"/>.</termdef>
          </p> <p> The semantics of
<code>fn:data</code> are repeated here for convenience. The result of
<code>fn:data</code> is the sequence of atomic values produced by
applying the following rules to each item in the input
sequence:</p>
<ulist> 

  <item>
              <p>If the item is an atomic value, it is
returned.</p>
            </item>

  <item>
              <p>If the item is a node, 
its <termref def="dt-typed-value">typed value</termref> is returned (err:FOTY0012 is raised if the node has no typed value.)</p>
            </item>

  <item>
              <p>If the item is a <xtermref spec="DM11" ref="dt-function-item">function item</xtermref> [err:FOTY0012] is raised.</p>
            </item>
			  
			 </ulist>
          <p>Atomization is  used in
processing the following types of expressions: </p>
<ulist>

  <item>
              <p>Arithmetic expressions</p>
            </item>

  <item>
              <p>Comparison expressions</p>
            </item>

  <item>
              <p>Function calls and returns</p>
            </item>

  <item>
              <p>Cast expressions</p>
            </item>

  <item role="xquery">
              <p>Constructor expressions for various kinds of nodes</p>
            </item>

  <item role="xquery">
              <p>
                <code>order by</code> clauses in FLWOR expressions</p>
            </item>

  <item role="xquery">
              <p>
                <code>group by</code> clauses in FLWOR expressions</p>
            </item>

  <item role="xquery">
              <p>Switch expressions</p>
            </item>

</ulist>
</div3>
  
<div3 id="id-ebv">
          <head>Effective Boolean Value</head>
          <p>Under certain circumstances (listed below), it is necessary to find
the <termref def="dt-ebv">effective boolean value</termref> of a
value. <termdef id="dt-ebv" term="effective boolean value">The
<term>effective boolean value</term> of a value is defined as the result
of applying the <code>fn:boolean</code> function to the value, as
defined in <bibref ref="xpath-functions-11"/>.</termdef>
          </p>

<p> The dynamic semantics of <code>fn:boolean</code> are repeated here for convenience:</p>

<olist>

  <item>
              <p>If its operand is an empty sequence, <code>fn:boolean</code> returns <code>false</code>.</p>
            </item>

  <item>
              <p>If its operand is a sequence whose first item is a node, <code>fn:boolean</code> returns <code>true</code>.</p>
            </item>

  <item>
              <p>If its operand is a <termref def="dt-singleton">singleton</termref> value of type <code>xs:boolean</code> or derived from <code>xs:boolean</code>, <code>fn:boolean</code> returns the value of its operand unchanged.</p>
            </item>

  <item>
              <p>If its operand is a <termref def="dt-singleton">singleton</termref> value of type <code>xs:string</code>, <code>xs:anyURI</code>, <code>xs:untypedAtomic</code>, or a type derived from one of these, <code>fn:boolean</code> returns <code>false</code> if the operand value has zero length; otherwise it returns <code>true</code>.</p>
            </item>

  <item>
              <p>If its operand is a <termref def="dt-singleton">singleton</termref> value of any <termref def="dt-numeric">numeric</termref> type or derived from a numeric type, <code>fn:boolean</code> returns <code>false</code> if the operand value is <code>NaN</code> or is numerically equal to zero; otherwise it returns <code>true</code>.</p>
            </item>

  <item>
              <p>



In all other cases, <code>fn:boolean</code> raises a type error [err:FORG0006].
</p>
            </item>
          </olist>

<note role="xquery">
            <p>The <termref def="dt-ebv">effective boolean value</termref> of a sequence that contains at least one node and at least one atomic value may be nondeterministic in regions of a query where <termref def="dt-ordering-mode">ordering mode</termref> is <code>unordered</code>.</p>
          </note>
          <p>The <termref def="dt-ebv">effective boolean value</termref> of a sequence is computed implicitly during  processing of the following types of expressions: </p>
<ulist>

  <item>
              <p>Logical expressions (<code>and</code>, <code>or</code>)</p>
            </item>

  <item>
              <p>The <code>fn:not</code> function</p>
            </item>

  <item role="xquery">
              <p>The <code>where</code> clause of a FLWOR expression</p>
            </item>

  <item>
              <p>Certain types of <termref def="dt-predicate">predicates</termref>, such as <code>a[b]</code>
              </p>
            </item>

  <item>
              <p>Conditional expressions (<code>if</code>)</p>
            </item>

  <item>
              <p>Quantified expressions (<code>some</code>, <code>every</code>)</p>
            </item>

  </ulist>
          <note>
            <p>The definition of <termref def="dt-ebv">effective boolean value</termref> is <emph>not</emph> used when casting a value to the type <code>xs:boolean</code>, for example in a <code>cast</code> expression or when passing a value to a function whose expected parameter is of type <code>xs:boolean</code>.</p>
          </note>
        </div3>


<div3 id="id-input-sources">
          <head>Input Sources</head>
          <p>XQuery 1.1 has a set of functions that provide access to
    input data. These functions are of particular importance because they provide a way in which an expression can reference a document or a collection of documents. The  input functions are described informally here; they are defined in <bibref ref="xpath-functions-11"/>.</p>

    <p>An expression can access input data either by calling one
    of the input functions or by referencing some part of the
    <termref def="dt-dynamic-context">dynamic context</termref> that is initialized by the external
    environment, such as a <termref def="dt-variable-values">variable</termref> or 
    <termref def="dt-context-item">context item</termref>.</p>

    <p>The input functions supported by XQuery 1.1 are as follows:</p>

    
<ulist>

  <item>
              <p>The <code>fn:doc</code> function takes a string containing a URI. If that URI is associated with a document in <termref def="dt-available-docs">available documents</termref>, <code>fn:doc</code> returns a document node whose content is the <termref def="dt-datamodel">data model</termref> representation of the given document; otherwise it raises a <termref def="dt-dynamic-error">dynamic error</termref> (see <bibref ref="xpath-functions-11"/> for details).</p>
            </item>

  <item>
              <p>The <code>fn:collection</code> function with one argument takes a string containing a URI. If that URI is associated with a collection in <termref def="dt-available-collections">available collections</termref>, <code>fn:collection</code> returns the data model representation of that collection; otherwise it raises a <termref def="dt-dynamic-error">dynamic error</termref> (see <bibref ref="xpath-functions-11"/> for details).  A collection may be any sequence of nodes. For example, the expression
    <code role="parse-test">fn:collection("http://example.org")//customer</code>
    identifies all the <code>customer</code> elements that are
    descendants of nodes found in the collection whose URI is
    <code>http://example.org</code>.</p>
            </item>

  <item>
              <p>The <code>fn:collection</code> function with zero arguments returns the <termref def="dt-default-collection">default collection</termref>, an <termref def="dt-implementation-dependent">implementation-dependent</termref> sequence of nodes.</p>
            </item>
          </ulist>

    

    </div3>

    <div3 id="id-uri-literals">
      <head>URI Literals</head>
      <p>In certain places in the XQuery 1.1 grammar, a statically known
      valid URI is required. These places are denoted by the
      grammatical symbol <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-URILiteral" xlink:type="simple">URILiteral</nt>. For
      example, URILiterals are used to specify namespaces and
      collations, both of which must be statically known.</p>
      <scrap headstyle="show"> 
	<head/> <prod num="195" id="doc-xquery11-URILiteral">
              <lhs>URILiteral</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-StringLiteral" xlink:type="simple">StringLiteral</nt>
              </rhs>
            </prod> 
      </scrap>
	<p>Syntactically, a URILiteral is identical to a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-StringLiteral" xlink:type="simple">StringLiteral</nt>: a sequence of zero or
	more characters enclosed in single or double quotes. However,
	an implementation may raise a <termref def="dt-static-error">static error</termref> <errorref class="ST" code="0046"/> if the value of a URILiteral is of
	nonzero length and is not in the lexical space of
	<code>xs:anyURI</code>.</p>

    <p>
            <termdef id="dt-resolve-relative-uri" term="resolve"> to
    <term>resolve a relative URI</term> is to expand it to an absolute
    URI, by reference to a <termref def="dt-base-uri">base
    URI</termref>, as if by calling the function
    <code>fn:resolve-uri()</code>
            </termdef>.</p>

	<p role="xquery">As in a string literal, any <termref def="dt-predefined-entity-reference">predefined entity
	reference</termref> (such as <code>&amp;amp;</code>), <termref def="dt-character-reference">character reference</termref>
	(such as <code>&amp;#x2022;</code>), or <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-EscapeQuot" xlink:type="simple">EscapeQuot</nt> or <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-EscapeApos" xlink:type="simple">EscapeApos</nt> (for example,
	<code>""</code>) is replaced by its appropriate
	expansion. Certain characters, notably the ampersand, can only
	be represented using a <termref def="dt-predefined-entity-reference">predefined entity
	reference</termref> or a <termref def="dt-character-reference">character
	reference</termref>.</p>

	<p>The URILiteral is subjected to whitespace normalization as
	defined for the <code>xs:anyURI</code> type in <bibref ref="XMLSchema"/>: this means that leading and trailing
	whitespace is removed, and any other sequence of whitespace
	characters is replaced by a single space (#x20)
	character. <phrase role="xquery">Whitespace normalization is done after the
	expansion of <termref def="dt-character-reference">character
	references</termref>, so writing a newline (for example) as
	<code>&amp;#xA;</code> does not prevent its being normalized
	to a space character.</phrase>
          </p>
          <p>The URILiteral is not
	automatically subjected to percent-encoding or decoding as
	defined in <bibref ref="RFC3986"/>. Any process that attempts
	to <termref def="dt-resolve-relative-uri">resolve the URI</termref>
    against a base URI, or to dereference the
	URI, may however apply percent-encoding or decoding as defined
	in the relevant RFCs.  </p>
          <note>
            <p>The <code>xs:anyURI</code>
	type is designed to anticipate the introduction of
	Internationalized Resource Identifiers (IRI's) as defined in
	<bibref ref="RFC3987"/>.</p>
          </note>
          <p>The following is an
	example of a valid
	URILiteral:</p>
          <eg xml:space="preserve">"http://www.w3.org/2005/xpath-functions/collation/codepoint"</eg>
    </div3>

  </div2>
  <div2 id="id-types"> 
		<head>Types</head> 
		<p> The type system of XQuery 1.1 is based on
		<bibref ref="XMLSchema"/>.</p>

<p>
          <termdef id="dt-sequence-type" term="sequence type">A <term>sequence type</term> is a type that can be expressed using the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SequenceType" xlink:type="simple">SequenceType</nt>
syntax. Sequence types are used whenever it is necessary to refer to a type in an XQuery 1.1 expression. The term <term>sequence type</term> suggests that this syntax is used to describe the type of an XQuery 1.1 value, which is always a sequence.</termdef>
        </p>
        <p>
          <termdef id="dt-schema-type" term="schema type">A <term>schema type</term> is a type that is (or could be) defined using the facilities of <bibref ref="XMLSchema"/> (including the built-in types of <bibref ref="XMLSchema"/>).</termdef> A schema type  can be used as a type annotation on an
element or attribute node (unless it is a non-instantiable type such as <code>xs:NOTATION</code> or <code>xs:anyAtomicType</code>, in which case its derived
types can be so used). Every schema type is either a <term>complex type</term> or a
<term>simple type</term>; simple types are further subdivided into <term>list types</term>, <term>union
types</term>, and <term>atomic types</term> (see <bibref ref="XMLSchema"/> for definitions and explanations of these terms.)</p>
        <p>Atomic types represent the intersection between the categories of <termref def="dt-sequence-type">sequence type</termref> and <termref def="dt-schema-type">schema type</termref>. An
atomic type, such as <code>xs:integer</code> or <code>my:hatsize</code>, is both a <termref def="dt-sequence-type">sequence type</termref> and a
<termref def="dt-schema-type">schema type</termref>.</p> 
		 
	
		<div3 id="id-predefined-types">
          <head>Predefined Schema Types</head>


                 


                   <p role="xquery">The <termref def="dt-is-types">in-scope schema types</termref> in the <termref def="dt-static-context">static context</termref>
                   are initialized with certain predefined schema types,
                   including the built-in schema types in the namespace
                   <code>http://www.w3.org/2001/XMLSchema</code>,
                   which has the predefined namespace prefix
                   <code>xs</code>.  The schema types in this namespace are defined in <bibref ref="XMLSchema"/>
                 and augmented by additional types defined in <bibref ref="xpath-datamodel-11"/>.  Element and attribute
                   declarations in the <code>xs</code> namespace are
                   not implicitly included in the static context. The schema types defined in  <bibref ref="xpath-datamodel-11"/> are summarized below.</p>

<olist>

  <item>
              <p>
                <termdef term="xs:untyped" id="dt-untyped">
                  <code>xs:untyped</code> is  used as the <termref def="dt-type-annotation">type annotation</termref> of an element node that has not been validated, or has been validated in <code>skip</code> mode.</termdef> No predefined schema types are derived from <code>xs:untyped</code>.</p>
            </item>

  <item>
              <p>
                <termdef id="dt-untypedAtomic" term="xs:untypedAtomic">
                  <code>xs:untypedAtomic</code>
is an atomic type that is used to denote untyped atomic data, such as text that has not been assigned a more specific type.</termdef> An attribute that has been validated in <code>skip</code> mode is represented in the <termref def="dt-datamodel">data model</termref> by an attribute node with the <termref def="dt-type-annotation">type annotation</termref> <code>xs:untypedAtomic</code>. No predefined schema types are derived from <code>xs:untypedAtomic</code>.</p>
            </item>

  <item>
              <p>
                <termdef term="xs:dayTimeDuration" id="dt-dayTimeDuration">
                  <code>xs:dayTimeDuration</code> is derived by restriction from <code>xs:duration</code>. The  lexical representation of <code>xs:dayTimeDuration</code>
is restricted to contain only day, hour, minute, and second
components.</termdef>
              </p>
            </item>

  <item>
              <p>
                <termdef term="xs:yearMonthDuration" id="dt-yearMonthDuration">
                  <code>xs:yearMonthDuration</code> is derived by restriction from <code>xs:duration</code>. The lexical representation of <code>xs:yearMonthDuration</code> is
restricted to contain only year and month
components.</termdef>
              </p>
            </item>

  <item>
              <p>
                <termdef term="xs:anyAtomicType" id="dt-anyAtomicType" diff="chg" at="XQ.E20 and XP.E11">
                  <code>xs:anyAtomicType</code> is an atomic type that includes all atomic values (and no values that
are not atomic). Its base type is
<code>xs:anySimpleType</code> from which all simple types, including atomic,
list, and union types, are derived. All primitive atomic types, such as
<code>xs:decimal</code> and <code>xs:string</code>, have <code>xs:anyAtomicType</code> as their base type.</termdef>
              </p>
              <note>
                <p>
                  <code>xs:anyAtomicType</code>  will not appear as the type of an actual value in an <termref def="dt-data-model-instance">XDM instance</termref>.</p>
              </note>
            </item>
          </olist>
          <p>The relationships among the schema types in the <code>xs</code> namespace are illustrated in Figure 2. A more complete description of the XQuery 1.1 type hierarchy can be found in <bibref ref="xpath-functions-11"/>.</p>
          <graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="types.jpg" alt="Type Hierarchy Diagram" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/>
          <p>Figure 2: Hierarchy of Schema Types used in XQuery 1.1.</p>
        </div3>


<div3 id="id-typed-value">
          <head>Typed Value and String Value</head>

<p>Every node
has a <term>typed value</term> and a <term>string value</term>.

<termdef term="typed value" id="dt-typed-value">The <term>typed value</term> of a node is a sequence of atomic values
and can be extracted by applying the <code>fn:data</code> function to
the node.</termdef>  <termdef id="dt-string-value" term="string value">The <term>string
 value</term> of a node is a string and 
 can be extracted by applying the <code>fn:string</code>
 function to the node.</termdef>
Definitions of <code>fn:data</code> and <code>fn:string</code> can be found in <bibref ref="xpath-functions-11"/>.</p>


<p>An implementation may store both the <termref def="dt-typed-value">typed value</termref> and the <termref def="dt-string-value">string value</termref> of a node, or it may store only one of these and derive the other as needed. The string value of a node must be a valid lexical representation of the typed value of the node, but the node is not required to preserve the string representation from the original source document. For example, if the typed value of a node is the <code>xs:integer</code> value <code>30</code>, its string value might be "<code>30</code>" or "<code>0030</code>".</p>
          <p role="xquery">The <termref def="dt-typed-value">typed value</termref>, <termref def="dt-string-value">string value</termref>, and <termref def="dt-type-annotation">type annotation</termref> of a node are closely related, and are defined by rules found in the following locations:</p>

<ulist role="xquery">

  <item>
              <p> If the node was created by mapping from an Infoset or PSVI, see rules in <bibref ref="xpath-datamodel-11"/>.</p>
            </item>

  <item>
              <p>If the node was created by an XQuery node constructor, see rules in <specref ref="id-element-constructor"/>, <specref ref="id-computedElements"/>, or <specref ref="id-computedAttributes"/>.</p>
            </item>

  <item>
              <p>If the node was created by a <code>validate</code> expression, see rules in <specref ref="id-validate"/>.</p>
            </item>
          </ulist>
          <p>As a convenience to the reader, the relationship between <termref def="dt-typed-value">typed value</termref> and
 <termref def="dt-string-value">string value</termref> for various kinds of nodes is summarized and illustrated
 by examples below.</p>

<olist>

  <item>
              <p>For text and document nodes, the typed value of the node is the same as its
string value, as an instance of  the type <code>xs:untypedAtomic</code>. The
string value of a document node is formed by concatenating the string
values of all its descendant text nodes, in <termref def="dt-document-order">document
order</termref>.</p>
            </item>

  <item>
              <p>The typed value of a comment or processing instruction node is the same as its string value. It is an instance of the type <code>xs:string</code>.</p>
            </item>

  <item>
              <p>The typed value of an attribute node with
the <termref def="dt-type-annotation">type annotation</termref> <code>xs:anySimpleType</code> or <code>xs:untypedAtomic</code> is the same as its
string value, as an instance of <code>xs:untypedAtomic</code>. The
typed value of an attribute node with any other type annotation is
derived from its string value and type annotation using the lexical-to-value-space mapping defined in <bibref ref="XMLSchema"/> Part 2 for
the relevant type.</p>
              <p>Example: A1 is an attribute
having string value <code>"3.14E-2"</code> and type annotation
<code>xs:double</code>.  The typed value of A1 is the
<code>xs:double</code> value whose lexical representation is
<code>3.14E-2</code>. </p>
              <p>Example: A2 is an attribute with type
annotation <code>xs:IDREFS</code>, which is a list datatype whose item type is the atomic datatype <code>xs:IDREF</code>. Its string value is
"<code>bar baz faz</code>". The typed value of A2 is a sequence of
three atomic values ("<code>bar</code>", "<code>baz</code>",
"<code>faz</code>"), each of type <code>xs:IDREF</code>. The typed
value of a node is never treated as an instance of a named list
type. Instead, if the type annotation of a node is a list type (such
as <code>xs:IDREFS</code>), its typed value is treated as a sequence
of the atomic type from which it is derived (such as
<code>xs:IDREF</code>).</p>
            </item>

  <item>
              <p>For an element node, the
relationship between typed value and string value depends on the
node's <termref def="dt-type-annotation">type annotation</termref>, as follows:</p>

<olist>



  <item>

<p>If the type annotation is <code>xs:untyped</code> or <code>xs:anySimpleType</code> or
denotes a complex type with mixed content (including <code>xs:anyType</code>), then the typed value of the
node is equal to its string value, as an instance of
<code>xs:untypedAtomic</code>.  However, if the <code>nilled</code> 
property of the node is <code>true</code>, then its typed value is the empty sequence.</p>



<p>Example: E1 is an element node
having type annotation <code>xs:untyped</code> and string value
"<code>1999-05-31</code>". The typed value of E1 is
"<code>1999-05-31</code>", as an instance of
<code>xs:untypedAtomic</code>.</p>


<p>Example: E2 is an element node
with the type annotation <code>formula</code>, which is a complex type
with mixed content. The content of E2 consists of the character
"<code>H</code>", a child element named <code>subscript</code> with
string value "<code>2</code>", and the character "<code>O</code>". The
typed value of E2 is "<code>H2O</code>" as an instance of
<code>xs:untypedAtomic</code>.</p>
                </item>



  <item>
                  <p>If the type
annotation denotes a simple type or a complex type with simple
content, then the typed value of the node is derived from its string
value and its type annotation in a way that is consistent with schema
validation. However, if the <code>nilled</code> 
property of the node is <code>true</code>, then its typed value is the empty sequence.</p>
                  <p>Example: E3 is an element node with the type
annotation <code>cost</code>, which is a complex type that has several
attributes and a simple content type of <code>xs:decimal</code>. The
string value of E3 is "<code>74.95</code>". The typed value of E3 is
<code>74.95</code>, as an instance of
<code>xs:decimal</code>.</p>
                  <p>Example: E4 is an element node with the
type annotation <code>hatsizelist</code>, which is a simple type
derived from the atomic type <code>hatsize</code>, which in turn is
derived from <code>xs:integer</code>. The string value of E4 is
"<code>7 8 9</code>". The typed value of E4 is a sequence of three
values (<code>7</code>, <code>8</code>, <code>9</code>), each of type
<code>hatsize</code>.</p>
                  <p>Example: E5 is an element node with the type annotation <code>my:integer-or-string</code> which is a union type with member types <code>xs:integer</code> and <code>xs:string</code>. The string value of E5 is "<code>47</code>". The typed value of E5 is <code>47</code> as an <code>xs:integer</code>, since <code>xs:integer</code> is the member type that validated the content of E5. In general, when the type annotation of a node is a union type, the typed value of the node will be an instance of one of the member types of the union.</p>
                  <note>
                    <p>If an implementation stores only the string value of a node, and the type annotation of the node is a union type, the implementation must be able to deliver the typed value of the node as an instance of the appropriate member type.</p>
                  </note>
                </item>

  <item>
                  <p>If the type annotation
denotes a complex type with empty content, then the typed value of the
node is the empty sequence and its string value is the zero-length string.</p>
                </item>

  <item>
                  <p>If the type annotation
denotes a complex type with element-only content, then the typed value
of the node is undefined. The <code>fn:data</code> function raises a
<termref def="dt-type-error">type error</termref> [err:FOTY0012] when applied to such a node. The string value of such a node is equal to the concatenated string values of all its text node descendants, in document order.</p>
                  <p>Example: E6 is an
element node with the type annotation <code>weather</code>, which is a
complex type whose content type specifies
<code>element-only</code>. E6 has two child elements named
<code>temperature</code> and <code>precipitation</code>. The typed
value of E6 is undefined, and the <code>fn:data</code> function
applied to E6 raises an error.
</p>
                </item>
              </olist>
            </item>
          </olist>
        </div3>


<div3 id="id-sequencetype-syntax">
          <head>SequenceType Syntax</head>
          <p>Whenever it is necessary to refer to a type in an XQuery 1.1 expression, the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SequenceType" xlink:type="simple">SequenceType</nt> syntax is used.</p> 
		  <scrap headstyle="show"> 
			 <head/> 
			 <prod num="169" id="doc-xquery11-SequenceType">
              <lhs>SequenceType</lhs>
              <rhs>("empty-sequence"  "("  ")")<br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ItemType" xlink:type="simple">ItemType</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt>?)</rhs>
            </prod> 
			 <prod num="171" id="doc-xquery11-ItemType">
              <lhs>ItemType</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-KindTest" xlink:type="simple">KindTest</nt>  |  ("item"  "("  ")")  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-FunctionTest" xlink:type="simple">FunctionTest</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AtomicType" xlink:type="simple">AtomicType</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ParenthesizedItemType" xlink:type="simple">ParenthesizedItemType</nt>
              </rhs>
            </prod>
            <prod num="170" id="doc-xquery11-OccurrenceIndicator">
              <lhs>OccurrenceIndicator</lhs>
              <rhs>"?"  |  "*"  |  "+"</rhs>
            </prod>
            <prod num="172" id="doc-xquery11-AtomicType">
              <lhs>AtomicType</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-EQName" xlink:type="simple">EQName</nt>
              </rhs>
            </prod> 
			 <prod num="173" id="doc-xquery11-KindTest">
              <lhs>KindTest</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-DocumentTest" xlink:type="simple">DocumentTest</nt>
                <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ElementTest" xlink:type="simple">ElementTest</nt>
                <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AttributeTest" xlink:type="simple">AttributeTest</nt>
                <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt>
                <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SchemaAttributeTest" xlink:type="simple">SchemaAttributeTest</nt>
                <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-PITest" xlink:type="simple">PITest</nt>
                <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-CommentTest" xlink:type="simple">CommentTest</nt>
                <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TextTest" xlink:type="simple">TextTest</nt>
                <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-NamespaceNodeTest" xlink:type="simple">NamespaceNodeTest</nt>
                <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AnyKindTest" xlink:type="simple">AnyKindTest</nt>
              </rhs>
            </prod> 
			  
			 <prod num="175" id="doc-xquery11-DocumentTest">
              <lhs>DocumentTest</lhs>
              <rhs>"document-node"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ElementTest" xlink:type="simple">ElementTest</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt>)?  ")"</rhs>
            </prod> 
			  
			  
			 <prod num="184" id="doc-xquery11-ElementTest">
              <lhs>ElementTest</lhs>
              <rhs>"element"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ElementNameOrWildcard" xlink:type="simple">ElementNameOrWildcard</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TypeName" xlink:type="simple">TypeName</nt>  "?"?)?)?  ")"</rhs>
            </prod> 
		         <prod num="186" id="doc-xquery11-SchemaElementTest">
              <lhs>SchemaElementTest</lhs>
              <rhs>"schema-element"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ElementDeclaration" xlink:type="simple">ElementDeclaration</nt>  ")"</rhs>
            </prod>
            <prod num="187" id="doc-xquery11-ElementDeclaration">
              <lhs>ElementDeclaration</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ElementName" xlink:type="simple">ElementName</nt>
              </rhs>
            </prod>
            <prod num="180" id="doc-xquery11-AttributeTest">
              <lhs>AttributeTest</lhs>
              <rhs>"attribute"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AttribNameOrWildcard" xlink:type="simple">AttribNameOrWildcard</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TypeName" xlink:type="simple">TypeName</nt>)?)?  ")"</rhs>
            </prod>

                  
                  
                  

                  <prod num="182" id="doc-xquery11-SchemaAttributeTest">
              <lhs>SchemaAttributeTest</lhs>
              <rhs>"schema-attribute"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AttributeDeclaration" xlink:type="simple">AttributeDeclaration</nt>  ")"</rhs>
            </prod>
            <prod num="183" id="doc-xquery11-AttributeDeclaration">
              <lhs>AttributeDeclaration</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AttributeName" xlink:type="simple">AttributeName</nt>
              </rhs>
            </prod>
            <prod num="185" id="doc-xquery11-ElementNameOrWildcard">
              <lhs>ElementNameOrWildcard</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ElementName" xlink:type="simple">ElementName</nt>  |  "*"</rhs>
            </prod>
                  <prod num="189" id="doc-xquery11-ElementName">
              <lhs>ElementName</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-EQName" xlink:type="simple">EQName</nt>
              </rhs>
            </prod>
            <prod num="181" id="doc-xquery11-AttribNameOrWildcard">
              <lhs>AttribNameOrWildcard</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AttributeName" xlink:type="simple">AttributeName</nt>  |  "*"</rhs>
            </prod>
                  <prod num="188" id="doc-xquery11-AttributeName">
              <lhs>AttributeName</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-EQName" xlink:type="simple">EQName</nt>
              </rhs>
            </prod>


                         
			 
			 
			 		 

                             
<prod num="190" id="doc-xquery11-TypeName">
              <lhs>TypeName</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-EQName" xlink:type="simple">EQName</nt>
              </rhs>
            </prod>
            <prod num="179" id="doc-xquery11-PITest">
              <lhs>PITest</lhs>
              <rhs>"processing-instruction"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-NCName" xlink:type="simple">NCName</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-StringLiteral" xlink:type="simple">StringLiteral</nt>)?  ")"</rhs>
            </prod> 
			 <prod num="177" id="doc-xquery11-CommentTest">
              <lhs>CommentTest</lhs>
              <rhs>"comment"  "("  ")"</rhs>
            </prod> 
			 <prod num="176" id="doc-xquery11-TextTest">
              <lhs>TextTest</lhs>
              <rhs>"text"  "("  ")"</rhs>
            </prod>
			 <prod num="174" id="doc-xquery11-AnyKindTest">
              <lhs>AnyKindTest</lhs>
              <rhs>"node"  "("  ")"</rhs>
            </prod>
			 <prod num="191" id="doc-xquery11-FunctionTest">
              <lhs>FunctionTest</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Annotation" xlink:type="simple">Annotation</nt>*  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AnyFunctionTest" xlink:type="simple">AnyFunctionTest</nt>
                <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TypedFunctionTest" xlink:type="simple">TypedFunctionTest</nt>)</rhs>
            </prod>
			 <prod num="192" id="doc-xquery11-AnyFunctionTest">
              <lhs>AnyFunctionTest</lhs>
              <rhs>"function"  "("  "*"  ")"</rhs>
            </prod>
			 <prod num="193" id="doc-xquery11-TypedFunctionTest">
              <lhs>TypedFunctionTest</lhs>
              <rhs>"function"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SequenceType" xlink:type="simple">SequenceType</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SequenceType" xlink:type="simple">SequenceType</nt>)*)?  ")"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SequenceType" xlink:type="simple">SequenceType</nt>
              </rhs>
            </prod>
			 <prod num="194" id="doc-xquery11-ParenthesizedItemType">
              <lhs>ParenthesizedItemType</lhs>
              <rhs>"("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ItemType" xlink:type="simple">ItemType</nt>  ")"</rhs>
            </prod>
     </scrap> 
		  


<p>With the exception of the special type
<code>empty-sequence()</code>, a <termref def="dt-sequence-type">sequence type</termref> consists of an
<term>item type</term> that constrains the type of each item in the
sequence, and a <term>cardinality</term> that constrains the number of
items in the sequence. Apart from the item type <code>item()</code>,
which permits any kind of item, item types divide into <term>node
types</term> (such as <code>element()</code>), <term>atomic
types</term> (such as <code>xs:integer</code>) and function types
(such as function() as item()*).</p>
          <p>Item types representing element
and attribute nodes may specify the required <termref def="dt-type-annotation">type annotations</termref> of those nodes, in
the form of a <termref def="dt-schema-type">schema
type</termref>. Thus the item type <code>element(*, us:address)</code>
denotes any element node whose type annotation is (or is derived from)
the schema type named <code>us:address</code>.</p>

<p>Any occurrence of '+' and '*', as well as '?' immediately following
a sequence type is assumed to be an occurrence indicator, which binds
to the last <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ItemType" xlink:type="simple">ItemType</nt> in the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SequenceType" xlink:type="simple">SequenceType</nt>, as described in <specref ref="parse-note-occurrence-indicators"/>.</p>

<p>Here are some examples of <termref def="dt-sequence-type">sequence types</termref> that
		  might be used in XQuery 1.1 expressions:</p>

		  <ulist> 
			 <item> 
				<p> <code>xs:date</code> refers to the built-in atomic schema type named <code>xs:date</code>
              </p> 
			 </item> 
			 <item> 
				<p> <code>attribute()?</code> refers to an optional attribute node</p> 
			 </item> 
			 <item> 
				<p> <code>element()</code> refers to any element node</p> 
			 </item> 
			 <item> 
				<p> <code>element(po:shipto, po:address)</code> refers to an element node that has the name <code>po:shipto</code> and has the type annotation <code>po:address</code> (or a schema type derived from <code>po:address</code>)</p> 
			 </item>
            <item> 
				<p> <code>element(*, po:address)</code> refers to an element node of any name that has the type annotation <code>po:address</code> (or a type derived from <code>po:address</code>)</p> 
			 </item>

  <item>
              <p>
                <code>element(customer)</code> refers to an element node named <code>customer</code> with any type annotation</p>
            </item> 
			  
			 

  <item>
              <p>
                <code>schema-element(customer)</code> refers to an element node whose name is <code>customer</code> (or is in the substitution group headed by <code>customer</code>) and whose type annotation matches the schema type declared for a <code>customer</code> element in the <termref def="dt-is-elems">in-scope element declarations</termref>
              </p>
            </item>

  <item> 
				<p> <code>node()*</code> refers to a sequence of zero or more nodes of any kind</p> 
			 </item> 
			 <item> 
				<p> <code>item()+</code> refers to a sequence of one or more nodes or atomic values</p> 
			 </item> 
		  </ulist>

		  <p>Sequence types can also specify the type of a
		  <xtermref spec="DM11" ref="dt-function-item">function item</xtermref>,
		  including function annotations.</p>

		  <ulist>
			 <item> 
				<p> <code>function(*)</code> refers to any <xtermref spec="DM11" ref="dt-function-item">function item</xtermref>, regardless of arity or type</p> 
			 </item> 
			 <item> 
				<p> <code>function(node()) as xs:string*</code> refers to a <xtermref spec="DM11" ref="dt-function-item">function item</xtermref> that takes a single argument whose value is a single node,
        and returns a sequence of zero or more xs:string values</p> 
			 </item> 
			 <item> 
				<p> <code>(function(node()) as xs:string)*</code> refers to a sequence of zero or more <xtermref spec="DM11" ref="dt-function-item">function items</xtermref>, each of which takes a single
        argument whose value is a single node, and returns as its result a single xs:string value</p>
			 </item> 
		  </ulist>

		  <p id="id-annotation-assertion">
            <termdef id="dt-annotation-assertion" term="annotation assertion">If an annotation is present in a FunctionTest, it is called an <term>annotation assertion</term>.</termdef>  Annotation assertions further restrict the set of function items that are matched by a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-FunctionTest" xlink:type="simple">FunctionTest</nt>.  XQuery 1.1 defines two annotation assertions:  <code>%fn:deterministic</code> matches function items that are deterministic. <code>%fn:nondeterministic</code> matches both function items that are deterministic and function items that are not deterministic. Implementations can define further annotation assertions, which are implementation-defined.  There are no annotation assertions that correspond to the <code>%public</code> and <code>%private</code> annotations. Annotation assertions are not automatically defined as a side effect of creating an annotation.</p>

		  <note>
            <p>Other specifications in the XQuery family
		  will also use annotation assertions. For instance,
		  in the XQuery Update Facility,
		  <code>%fn:updating</code> matches function items
		  with a <code>%fn:simple</code> or
		  <code>%fn:updating</code> annotation. In the XQuery
		  Scripting Extension, <code>%fn:sequential</code>
		  matches function items with a
		  <code>%fn:simple</code> or
		  <code>%fn:sequential</code> annotation, and
		  <code>%fn:simple</code> matches function items with
		  a <code>%fn:simple annotation</code>. If no
		  <code>%fn:updating</code> or
		  <code>%fn:sequential</code> annotation
		  assertion is present, this is the default
		  matching behaviour.</p>
		  </note>

		  <p>Implementations can provide a way for XQuery
		  users to create their own annotation assertions.
		  Users should avoid creating annotation assertions in
		  the <code>fn</code> namespace, since this namespace
		  is reserved for future language extensions. </p>

		</div3>


		<div3 id="id-sequencetype-matching"> 
		  <head>SequenceType Matching</head> 
		  <p> <termdef id="dt-sequencetype-matching" term="SequenceType matching">During evaluation of an expression, it is sometimes necessary to determine whether a value with a known <termref def="dt-dynamic-type">dynamic type</termref> "matches" an expected  <termref def="dt-sequence-type">sequence type</termref>. This process is known as <term>SequenceType matching</term>.</termdef> For example, an <code>instance of</code> expression returns <code>true</code> if the <termref def="dt-dynamic-type">dynamic type</termref> of a given value matches a given <termref def="dt-sequence-type">sequence type</termref>, or <code>false</code> if
it does not.</p>





<p>
            <termref def="dt-qname">Lexical QNames</termref> appearing in a <termref def="dt-sequence-type">sequence type</termref> have their
		  prefixes expanded to namespace URIs by means of the
		  <termref def="dt-static-namespaces">statically known namespaces</termref> and (where applicable) the
		  <termref def="dt-def-elemtype-ns">default element/type
		  namespace</termref>. 

                  An unprefixed attribute QName is in no namespace. Equality of QNames is defined by the <code>eq</code> operator.</p>
          <p>The rules for <termref def="dt-sequencetype-matching">SequenceType
matching</termref> compare the <termref def="dt-dynamic-type">dynamic type</termref> of a value
with an expected <termref def="dt-sequence-type">sequence type</termref>.</p>


<p diff="add">Some of the rules for <termref def="dt-sequencetype-matching">SequenceType matching</termref> require
determining whether a given schema type encountered as a type
annotation in an instance document is the same as or derived from an
expected schema type. This determination is done by reference to a
schema <emph>S</emph> (that is, a set of schema components). This
schema <emph>S</emph> is the union of:</p>

<olist diff="add">
<item>
              <p>the in-scope schema definitions in the static context of the
query module</p>
            </item> 

<item>
              <p>potentially, the schema used for validating the instance
document; whether a processor adds this schema to <emph>S</emph> is
<termref def="dt-implementation-defined">implementation-defined</termref>.</p>
            </item>

<item>
              <p>potentially, further schema components that have been made
available to the processor in an <termref def="dt-implementation-defined">implementation-defined</termref>
way.</p>
            </item>
</olist>

<p diff="add">A type error <errorref class="TY" code="0004"/> may be raised if
this union does not constitute a valid schema (for example, if there
are conflicts between types present in the static context and types
used dynamically for validating instances.)</p>

<p diff="add">
Whether the schema used to validate the instance document is in
<emph>S</emph> is implementation-defined. Whether the implementation
provides further schema components in <emph>S</emph> is also
implementation-defined.</p>

<p>
            <termdef term="subtype substitution" id="dt-subtype-substitution">The use of a value whose <termref def="dt-dynamic-type">dynamic type</termref> is derived from an
expected type is known as <term>subtype substitution</term>.</termdef>
Subtype substitution does not change the actual type of a value. For
example, if an <code>xs:integer</code> value is used where an
<code>xs:decimal</code> value is expected, the value retains its type
as <code>xs:integer</code>.</p>

<p>The definition of <termref def="dt-sequencetype-matching">SequenceType matching</termref> relies
on a pseudo-function named <code>derives-from(</code>
            <emph>AT</emph>,
<emph>
              <emph>ET</emph>
            </emph>
            <code>)</code>, which takes an actual simple or complex
schema type <emph>AT</emph> and an expected simple or complex schema
type <emph>
              <emph>ET</emph>
            </emph>, and either returns a boolean value or raises a
<termref def="dt-type-error">type error</termref> <errorref class="TY" code="0004"/>.  <phrase diff="add">This function is defined as follows:</phrase>
          </p>

<ulist diff="add">
<item>
              <p>
                <code>derives-from(</code>
                <emph>AT</emph>, <emph>ET</emph>
                <code>)</code> raises a type error <errorref class="TY" code="0004"/> if either <emph>AT</emph> or <emph>ET</emph> is
not present in <emph>S</emph>
              </p>
            </item>

<item>
              <p>
                <code>derives-from(</code>
                <emph>AT</emph>,
<emph>ET</emph>
                <code>)</code> returns true if <emph>AT</emph> is
derived from <emph>ET</emph> by restriction or extension, or if
<emph>ET</emph> is a union type of which <emph>AT</emph> is a member
type.</p>

<p>Formally, it returns true if <emph>AT</emph> and <emph>ET</emph>
are both present in <emph>S</emph> and <emph>AT</emph> is validly
derived from <emph>ET</emph> given the empty set, as defined in
<bibref ref="XMLSchema"/> Part 1 constraints Type Derivation OK
(Complex) (§3.4.6) (if <emph>AT</emph> is a complex type), or Type
Derivation OK (Simple) (§3.14.6) (if <emph>AT</emph> is a simple
type). The phrase "given the empty set" is used because the rules in
the XML Schema specification are parameterized: the parameter is a
list of the kinds of derivation that are not allowed, and in this case
the list is always empty.</p>

<note>
                <p>The current (second) edition of XML Schema 1.0 contains an error in
respect of the substitutability of a union type by one of its members: it fails
to recognize that this is unsafe if the union is derived by restriction from
another union. This problem is fixed in the current working draft of XML Schema
1.1, and implementers are advised to adopt the solution given there. It is
likely that this specification will be updated to refer normatively to XML
Schema 1.1 when that specification reaches Recommendation status. </p>
              </note>

</item>
<!--
<item><p><code>derives-from(</code><emph>AT</emph>, <emph>ET</emph><code>)</code> returns true <emph>AT</emph> and <emph>ET</emph> are both present in <emph>S</emph>, and if one
or more of the following three conditions is true:</p>
<ulist>
<item><p><emph>AT</emph> is the same type as <emph>ET</emph> </p></item>
<item><p><emph>AT</emph> is derived by restriction or extension from <emph>ET</emph></p>
<note><p>Some members of the XML Query Working Group believe that
   matching types derived by restriction should be required, but
   extension from <emph>ET</emph> should be implementation-defined, others
   believe matching types derived by extension from <emph>ET</emph> should be
   required of all implementations.</p>

   <p>Some implementations that do static analysis may do
   optimizations that would be invalidated by allowing
   dynamically encountered types derived by extension from <emph>ET</emph>.</p>

   <p>If these implementations do not add such types to <emph>S</emph>, they will
   not encounter such types. Some implementers argue that they
   would like the freedom to use dynamic schema information in
   queries, but still want to be able to optimize
   statically. Some Working Group members suggest that it is a
   clearer model to either use all schema information from
   dynamically encountered schemas, including derivation by
   extension, or not place it in <emph>S</emph>.</p>

   <p>The XML Query Working Group has not reached consensus on this
   question, and we welcome feedback. </p>
</note>
</item>
<item><p><emph>S</emph> contains some schema type <emph>IT</emph> such that <code>derives-from(</code><emph>IT</emph>, <emph>ET</emph><code>)</code> and
<code>derives-from(</code><emph>AT</emph>, <emph>IT</emph><code>)</code> are true.</p></item>
</ulist>
</item>
-->
<item>
              <p>Otherwise, <code>derives-from(</code>
                <emph>AT</emph>, <emph>ET</emph>
                <code>)</code> returns false</p>
            </item>
</ulist>

<!-- DEL
<code>derives-from(</code><emph>AT</emph>,
<emph>ET</emph><code>)</code> raises a <termref
def="dt-type-error">type error</termref> <errorref class="TY"
code="0004"/> if either <emph>AT</emph> or <emph>ET</emph> is not
present in <emph>S</emph>.

<code>derives-from(</code><emph>AT</emph>,
<emph>ET</emph><code>)</code> returns <code>true</code> if
<emph>AT</emph> and <emph>ET</emph> are both present in
<emph>S</emph>, and one or more of the following three conditions is
true:</p>

<olist>
<item><p><emph>AT</emph> is the same type as <emph>ET</emph></p></item>

<item><p><emph>AT</emph> is derived by restriction or extension from <emph>ET</emph></p>
<ednote>
<edtext>
The XML Query Working Group not decided whether recognizing derivation
by extension should be required or optional for types not statically
known to the query processor.
</edtext>
</ednote>
</item>

<item><p><emph>S</emph> contains some schema type <emph>IT</emph> such
that <code>derives-from(</code><emph>IT</emph>,
<emph>ET</emph><code>)</code> and
<code>derives-from(</code><emph>AT</emph>,
<emph>IT</emph><code>)</code> are true.</p></item>
</olist>

<p>Otherwise, <code>derives-from(</code><emph>AT</emph>,
<emph>ET</emph><code>)</code> returns <code>false</code>.</p>
		  		  
<ulist>

  <item><p><code>derives-from(</code><emph>AT</emph>, <emph>ET</emph><code>)</code> returns <code>true</code> if <emph>ET</emph> is a known type and any of the following three conditions is true:</p>

<olist>

  <item><p><emph>AT</emph> is a schema type found in the <termref def="dt-issd">in-scope schema definitions</termref>, and is the same as
<emph>ET</emph> or is derived by restriction or
extension from <emph>ET</emph></p></item>

  <item><p><emph>AT</emph>
is a schema type not found in the <termref def="dt-issd">in-scope schema definitions</termref>, and an <termref def="dt-implementation-dependent">implementation-dependent</termref> mechanism is able
to determine that <emph>AT</emph> is derived by restriction from
<emph>ET</emph></p></item>

  <item><p>There exists some schema type <emph>IT</emph> such that 
       <code>derives-from(</code><emph>IT, ET</emph><code>)</code> and <code>derives-from(</code><emph>AT, IT</emph><code>)</code> are true. 
</p></item></olist></item>

  <item><p><code>derives-from(</code><emph>AT</emph>,
<emph>ET</emph><code>)</code> returns <code>false</code>
if <emph>ET</emph> is a known type and either the first and third or the second and third of the following conditions are true:</p>

<olist>

  <item><p><emph>AT</emph> is a schema type found in the <termref def="dt-issd">in-scope schema definitions</termref>, and is not the same as
<emph>ET</emph>, and is not derived by restriction or
extension from <emph>ET</emph></p></item>

  <item><p><emph>AT</emph>
is a schema type not found in the <termref def="dt-issd">in-scope schema definitions</termref>, and an <termref def="dt-implementation-dependent">implementation-dependent</termref> mechanism is able
to determine that <emph>AT</emph> is not derived by restriction from
<emph>ET</emph></p></item>

  <item><p>No schema type <emph>IT</emph> exists such that 
       <code>derives-from(</code><emph>IT, ET</emph><code>)</code> and <code>derives-from(</code><emph>AT, IT</emph><code>)</code> are true. 
</p></item></olist></item>

  <item><p><code>derives-from(</code><emph>AT</emph>,
<emph>ET</emph><code>)</code> raises a <termref def="dt-type-error">type error</termref> <errorref class="TY" code="0004"/>
if:</p>

<olist>

  <item><p><emph>ET</emph> is an unknown type,
or</p></item>

  <item><p><emph>AT</emph> is an unknown type, and the
implementation is not able to determine whether <emph>AT</emph> is
derived by restriction from
<emph>ET</emph>.</p></item></olist></item></ulist>

<note role="xquery"><p>The <code>derives-from</code> pseudo-function cannot be
written as a real XQuery function, because types are not valid
function parameters. </p></note>

-->

<p>The rules for <termref def="dt-sequencetype-matching">SequenceType
matching</termref> are given below, with examples (the examples are
for purposes of illustration, and do not cover all possible
cases).</p>
		   
		   
		  <div4 id="id-matching-value">
            <head>Matching a SequenceType and a Value</head>
<ulist>

  <item>
                <p>The <termref def="dt-sequence-type">sequence type</termref> <code>empty-sequence()</code> matches a value that is the empty sequence.</p>
              </item>

  <item>
                <p>An <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ItemType" xlink:type="simple">ItemType</nt> with no <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt> matches any value that contains exactly one item if the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ItemType" xlink:type="simple">ItemType</nt> matches that item (see <specref ref="id-matching-item"/>).</p>
              </item>

  <item>
                <p>An <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ItemType" xlink:type="simple">ItemType</nt> with an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt> matches a value if the number of items in the value matches the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt> and the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ItemType" xlink:type="simple">ItemType</nt> matches each of the items in the value.</p>
              </item>
            </ulist>
            <p>An <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt> specifies the number of items in
		  a sequence, as follows:</p> 
		  
<ulist> 
			 

  <item> 
				<p> <code>?</code> matches zero or one items</p> 
			 </item> 
			 <item> 
				<p> <code>*</code> matches zero or more items</p> 
			 </item> 
			 <item> 
				<p> <code>+</code> matches one or more items</p> 
			 </item> 
		  </ulist>

<p>As a consequence of these rules, any <termref def="dt-sequence-type">sequence type</termref> whose
<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt> is <code>*</code> or <code>?</code> matches a
value that is an empty sequence.</p>
          </div4>
          <div4 id="id-matching-item">
            <head>Matching an ItemType and an
Item</head>
<ulist>

  <item>
                <p>An <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ItemType" xlink:type="simple">ItemType</nt> consisting simply of an EQName is
interpreted as an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AtomicType" xlink:type="simple">AtomicType</nt>. An AtomicType
<emph>AtomicType</emph> matches an atomic value whose actual type is
<emph>AT</emph> if <code>derives-from(</code>
                  <emph>AT, AtomicType</emph>
                  <code>)</code> is <code>true</code>. If the <termref def="dt-expanded-qname">expanded QName</termref> of an 
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AtomicType" xlink:type="simple">AtomicType</nt> is not defined as an atomic
                  type in the <termref def="dt-is-types">in-scope schema types</termref>, a <termref def="dt-static-error">static error</termref> is
                  raised <errorref class="ST" code="0051"/>.</p>
                <p>Example: The
<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AtomicType" xlink:type="simple">AtomicType</nt> <code>xs:decimal</code> matches the value
<code>12.34</code> (a decimal literal). <code>xs:decimal</code> also
matches a value whose type is <code>shoesize</code>, if
<code>shoesize</code> is an atomic type derived by restriction from
<code>xs:decimal</code>.</p>

<note>
                  <p> The names of non-atomic
types such as <code>xs:IDREFS</code> are not accepted in this context,
but can often be replaced by an atomic type with an occurrence
indicator, such as
<code>xs:IDREF+</code>.</p>
                </note>
              </item>

  <item>
                <p>
                  <code>item()</code> matches
any single item.</p>
                <p>Example: <code>item()</code> matches the atomic
value <code>1</code> or the element
<code>&lt;a/&gt;</code>.</p>
              </item>

  <item>
                <p>
                  <code>node()</code>
matches any node.</p>
              </item>

  <item>
                <p>
                  <code>function(*)</code>
matches any <xtermref spec="DM11" ref="dt-function-item">function item</xtermref>.</p>
              </item>

  <item>
                <p>
                  <code>text()</code> matches any
text node.</p>
              </item>

  <item>
                <p>
                  <code>processing-instruction()</code>
matches any processing-instruction
node.</p>
              </item>

  <item>
                <p diff="chg" at="XQ.E27 and XP.E19">
                  <code>processing-instruction(</code>
                  <emph>N</emph>
                  <code>)</code>
matches any processing-instruction node whose PITarget is equal to <code role="parse-test">fn:normalize-space(N)</code>. If <code>fn:normalize-space(N)</code> is not in the lexical space of NCName, a type error is raised <errorref class="TY" code="0004"/>
                </p> 

<p>Example:
<code role="parse-test">processing-instruction(xml-stylesheet)</code> matches any
processing instruction whose PITarget is
<code>xml-stylesheet</code>.</p>

<p>For backward compatibility with
                                XPath 1.0, the PITarget of a
                                processing instruction may also be expressed as a
                                string literal, as in this example:
				<code role="parse-test">processing-instruction("xml-stylesheet")</code>.</p>
                <p>If the specified PITarget is not a syntactically valid NCName, a type error is raised <errorref class="TY" code="0004"/>.</p>
              </item>


  <item>
                <p>
                  <code role="parse-test">comment()</code> matches any comment node.</p>
              </item>


                  

  <item>
                <p>
                  <code role="parse-test">namespace-node()</code> matches any
		  namespace node.</p>
              </item>




  <item>
                <p>
                  <code role="parse-test">document-node()</code> matches any document
node.</p>
              </item>

  <item>
                <p>
                  <code>document-node(</code>
                  <emph>E</emph>
                  <code>)</code>
matches any document node that contains exactly one element node, optionally accompanied by one or more comment and processing instruction nodes, if
<emph>E</emph> is an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ElementTest" xlink:type="simple">ElementTest</nt> or <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt> that matches the element node (see
<specref ref="id-element-test"/> and <specref ref="id-schema-element-test"/>).</p>
                <p>Example:
<code role="parse-test">document-node(element(book))</code> matches a document node
containing
exactly one element node that is matched by the ElementTest
<code role="parse-test">element(book)</code>.</p>
              </item>

  <item>
                <p>A <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TypedFunctionTest" xlink:type="simple">TypedFunctionTest</nt> matches an item if it is a <xtermref spec="DM11" ref="dt-function-item">function item</xtermref>,
  and the function item's type signature (as defined in <xspecref spec="DM11" ref="function-items"/>) is a <termref def="dt-subtype">subtype</termref> of the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TypedFunctionTest" xlink:type="simple">TypedFunctionTest</nt>.
  </p>
              </item>

  <item>
                <p>An <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ItemType" xlink:type="simple">ItemType</nt> that is an
  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ElementTest" xlink:type="simple">ElementTest</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AttributeTest" xlink:type="simple">AttributeTest</nt>, or
  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SchemaAttributeTest" xlink:type="simple">SchemaAttributeTest</nt> matches an item as described in the following sections.
  </p>
              </item>

</ulist>
</div4>

<div4 id="id-element-test">
            <head>Element Test</head>
            <p>An <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ElementTest" xlink:type="simple">ElementTest</nt> is used to match an
element node by its name and/or <termref def="dt-type-annotation">type annotation</termref>. An <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ElementTest" xlink:type="simple">ElementTest</nt> may take any of the following forms. In these forms, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ElementName" xlink:type="simple">ElementName</nt> need not be present in the <termref def="dt-is-elems">in-scope element declarations</termref>, but  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TypeName" xlink:type="simple">TypeName</nt> must be present in the <termref def="dt-is-types">in-scope schema types</termref> <errorref class="ST" code="0008"/>. Note that <termref def="dt-substitution-group">substitution groups</termref> do not affect the semantics of <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ElementTest" xlink:type="simple">ElementTest</nt>.</p>

<olist>

  <item>
                <p>
                  <code role="parse-test">element()</code> and

<code role="parse-test">element(*)</code>  match any
single element node, regardless of its name or
type annotation.</p>
              </item>

  <item>
                <p>
                  <code>element(</code>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ElementName" xlink:type="simple">ElementName</nt>
                  <code>)</code>
matches any element node whose name is <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ElementName" xlink:type="simple">ElementName</nt>, regardless of its type annotation or <code>nilled</code> property.</p>
                <p>Example: <code role="parse-test">element(person)</code> matches any element node whose name is <code>person</code>.</p>







</item>

  <item>
                <p>
                  <code>element(</code>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ElementName" xlink:type="simple">ElementName</nt>
                  <code>,</code> <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TypeName" xlink:type="simple">TypeName</nt>
                  <code>)</code>
matches an element node whose name is <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ElementName" xlink:type="simple">ElementName</nt> if <code>derives-from(</code>
                  <emph>AT</emph>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TypeName" xlink:type="simple">TypeName</nt> <code>)</code> is <code>true</code>, where <emph>AT</emph> is the type annotation of the element node, and the <code>nilled</code> property of the node is <code>false</code>.</p>
                <p>Example: <code role="parse-test">element(person, surgeon)</code> matches a
non-nilled element node whose name is <code>person</code> and whose
type annotation is <code>surgeon</code> (or is derived from <code>surgeon</code>). </p>
              </item>

  <item>
                <p>
                  <code>element(</code>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ElementName" xlink:type="simple">ElementName</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TypeName" xlink:type="simple">TypeName</nt>
                  <code> ?)</code>
matches an element node whose name is <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ElementName" xlink:type="simple">ElementName</nt> if <code>derives-from(</code>
                  <emph>AT</emph>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TypeName" xlink:type="simple">TypeName</nt>
                  <code>)</code> is <code>true</code>, where <emph>AT</emph> is the type annotation of the element node. The <code>nilled</code> property of the node may be either <code>true</code> or  <code>false</code>.</p>
                <p>Example: <code role="parse-test">element(person, surgeon?)</code> matches a nilled or non-nilled element node whose name is <code>person</code> and whose type
annotation is <code>surgeon</code> (or is derived from <code>surgeon</code>).</p>
              </item>





  <item>
                <p>
                  <code>element(*,
</code>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TypeName" xlink:type="simple">TypeName</nt>
                  <code>)</code> matches an element
node regardless of its name, if
<code>derives-from(</code>
                  <emph>AT</emph>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TypeName" xlink:type="simple">TypeName</nt> <code>)</code> is
<code>true</code>, where <emph>AT</emph> is the type annotation of the element node, and the <code>nilled</code> property of the node is <code>false</code>.</p>

<p>Example: <code role="parse-test">element(*, surgeon)</code>
matches any non-nilled element node whose type annotation is
<code>surgeon</code> (or is derived from <code>surgeon</code>), regardless of its name.</p>
              </item>

  <item>
                <p>
                  <code>element(*,
</code>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TypeName" xlink:type="simple">TypeName</nt>
                  <code> ?)</code> matches an element
node regardless of its name, if
<code>derives-from(</code>
                  <emph>AT</emph>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TypeName" xlink:type="simple">TypeName</nt> <code>)</code> is
<code>true</code>, where <emph>AT</emph> is the type annotation of the element node. The <code>nilled</code> property of the node may be either <code>true</code> or  <code>false</code>.</p>

<p>Example: <code role="parse-test">element(*, surgeon?)</code>
matches any nilled or non-nilled element node whose type annotation is
<code>surgeon</code> (or is derived from <code>surgeon</code>), regardless of its name.</p>
              </item>
            </olist>

</div4>



<div4 id="id-schema-element-test">
            <head>Schema Element Test</head>
            <p>A <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt> matches an element node against a corresponding
element declaration found in the <termref def="dt-is-elems">in-scope element declarations</termref>.
It takes the following form:</p>
            <p>
              <code>schema-element(</code>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ElementName" xlink:type="simple">ElementName</nt>
              <code>)</code>
            </p>
            <p>If the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ElementName" xlink:type="simple">ElementName</nt> specified in the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt> is not found in the <termref def="dt-is-elems">in-scope element declarations</termref>, a <termref def="dt-static-error">static error</termref> is raised
<errorref class="ST" code="0008"/>.</p>
            <p>A <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt> matches a candidate element node if all three of the
following conditions are satisfied:</p>

<olist>

  <item>
                <p>The name of the candidate node matches the specified <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ElementName" xlink:type="simple">ElementName</nt> or matches the name of an element in a
<termref def="dt-substitution-group">substitution group</termref> headed by an element named <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ElementName" xlink:type="simple">ElementName</nt>.</p>
              </item>

  <item>
                <p>
                  <code>derives-from(</code>
                  <emph>AT, ET</emph>
                  <code>)</code> is <code>true</code>, where <emph>AT</emph> is the type annotation of the candidate node and <emph>ET</emph> is the schema type declared for element <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ElementName" xlink:type="simple">ElementName</nt> in the <termref def="dt-is-elems">in-scope element declarations</termref>.</p>
              </item>

  <item>
                <p>If the element declaration for 
<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ElementName" xlink:type="simple">ElementName</nt> in the <termref def="dt-is-elems">in-scope element declarations</termref> is not <code>nillable</code>, then the 
<code>nilled</code> property of the candidate node is <code>false</code>.</p>
              </item>
            </olist>
            <p>Example: The <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt> <code role="parse-test">schema-element(customer)</code> matches a candidate element node if <code>customer</code> is a top-level element declaration in the <termref def="dt-is-elems">in-scope element declarations</termref>, the name of the candidate node is <code>customer</code> or is in a <termref def="dt-substitution-group">substitution group</termref> headed by <code>customer</code>, the type annotation of the candidate node  is the same as or derived from the schema type declared for the <code>customer</code> element, and either the candidate node is not <code>nilled</code> or <code>customer</code> is declared to be <code>nillable</code>.</p>
          </div4>
          <div4 id="id-attribute-test">
            <head>Attribute Test</head>




<p>An <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AttributeTest" xlink:type="simple">AttributeTest</nt> is used to match an
attribute node by its name and/or <termref def="dt-type-annotation">type annotation</termref>. An <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AttributeTest" xlink:type="simple">AttributeTest</nt> any take any of the following forms. In these forms, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AttributeName" xlink:type="simple">AttributeName</nt> need not be present in the <termref def="dt-is-attrs">in-scope attribute declarations</termref>, but  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TypeName" xlink:type="simple">TypeName</nt> must be present in the <termref def="dt-is-types">in-scope schema types</termref> <errorref class="ST" code="0008"/>.</p>

<olist>



  <item>
                <p>
                  <code role="parse-test">attribute()</code> and <code role="parse-test">attribute(*)</code> match any single attribute node,
regardless of its name or type annotation.</p>
              </item>



  <item>
                <p>
                  <code>attribute(</code>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AttributeName" xlink:type="simple">AttributeName</nt>
                  <code>)</code>
matches any attribute node whose name is <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AttributeName" xlink:type="simple">AttributeName</nt>, regardless of its type annotation.</p>
                <p>Example: <code role="parse-test">attribute(price)</code>
matches any attribute node whose name is <code>price</code>.</p>
              </item>

  <item>
                <p>
                  <code>attribute(</code>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AttributeName" xlink:type="simple">AttributeName</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TypeName" xlink:type="simple">TypeName</nt>
                  <code>)</code>
matches an attribute node whose name is <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AttributeName" xlink:type="simple">AttributeName</nt> if <code>derives-from(</code>
                  <emph>AT</emph>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TypeName" xlink:type="simple">TypeName</nt> <code>)</code> is <code>true</code>, where <emph>AT</emph> is the type annotation of the attribute node.</p>

<p>Example: <code role="parse-test">attribute(price, currency)</code> matches an
attribute node whose name is <code>price</code> and whose type
annotation is
<code>currency</code> (or is derived from <code>currency</code>).</p>
              </item>

  <item>
                <p>
                  <code>attribute(*,
</code>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TypeName" xlink:type="simple">TypeName</nt>
                  <code>)</code> matches an attribute
node regardless of its name, if
<code>derives-from(</code>
                  <emph>AT</emph>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TypeName" xlink:type="simple">TypeName</nt>
                  <code>)</code> is
<code>true</code>, where <emph>AT</emph> is the type annotation of the attribute node.</p>
                <p>Example:
<code role="parse-test">attribute(*, currency)</code> matches any attribute node whose
type annotation is <code>currency</code> (or is derived from <code>currency</code>), regardless of its
name.</p>
              </item>

</olist>
          </div4>

<div4 id="id-schema-attribute-test">
            <head>Schema Attribute Test</head>
            <p>A <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SchemaAttributeTest" xlink:type="simple">SchemaAttributeTest</nt> matches an attribute node against a corresponding
attribute declaration found in the <termref def="dt-is-attrs">in-scope attribute declarations</termref>.
It takes the following form:</p>
            <p>
              <code>schema-attribute(</code>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AttributeName" xlink:type="simple">AttributeName</nt>
              <code>)</code>
            </p>
            <p>If the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AttributeName" xlink:type="simple">AttributeName</nt> specified in the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SchemaAttributeTest" xlink:type="simple">SchemaAttributeTest</nt> is not found in the <termref def="dt-is-attrs">in-scope attribute declarations</termref>, a <termref def="dt-static-error">static error</termref> is raised
<errorref class="ST" code="0008"/>.</p>
            <p>A <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SchemaAttributeTest" xlink:type="simple">SchemaAttributeTest</nt> matches a candidate attribute node if both of the
following conditions are satisfied:</p>

<olist>

  <item>
                <p>The name of the candidate node matches the specified <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AttributeName" xlink:type="simple">AttributeName</nt>.</p>
              </item>

  <item>
                <p>
                  <code>derives-from(</code>
                  <emph>AT, ET</emph>
                  <code>)</code> is <code>true</code>, where <emph>AT</emph> is the type annotation of the candidate node and <emph>ET</emph> is the schema type declared for attribute <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AttributeName" xlink:type="simple">AttributeName</nt> in the <termref def="dt-is-attrs">in-scope attribute declarations</termref>.</p>
              </item>
            </olist>
            <p>Example: The <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SchemaAttributeTest" xlink:type="simple">SchemaAttributeTest</nt> <code role="parse-test">schema-attribute(color)</code> matches a candidate attribute node if <code>color</code> is a top-level attribute declaration in the <termref def="dt-is-attrs">in-scope attribute declarations</termref>, the name of the candidate node is <code>color</code>, and the type annotation of the candidate node  is the same as or derived from the schema type declared for the <code>color</code> attribute.</p>
          </div4>

</div3>
		 
<div3 id="id-sequencetype-subtype">
	<head>SequenceType Subtype Relationships</head>

  <p>
  Given two <termref def="dt-sequence-type">sequence types</termref>, it is possible to determine if one is a subtype of the other.
  <termdef term="subtype" id="dt-subtype">A <termref def="dt-sequence-type">sequence type</termref> <code>A</code> is a <term>subtype</term> of a sequence type <code>B</code>
  if and only if, for every value <code>V</code>, if <code>V</code> matches <code>A</code> according to the rules of <termref def="dt-sequencetype-matching">SequenceType matching</termref>,
  then <code>V</code> also matches <code>B</code>.</termdef>
  The subtype relationship can be computed using the <code>subtype(A, B)</code>, <code>subtype-itemtype(Ai, Bi)</code>, and <code>derives-from(AT, ET)</code> judgements.
  </p>

  <div4 id="id-seqtype-subtype">
    <head>The SequenceType Subtype Judgement</head>

    <p>The judgement <code>subtype(A, B)</code> determines if the <termref def="dt-sequence-type">sequence type</termref> <code>A</code>
    is a <termref def="dt-subtype">subtype</termref> of the sequence type <code>B</code>.
    

    <code>A</code> can either be <code>empty-sequence()</code> or an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ItemType" xlink:type="simple">ItemType</nt>, <code>Ai</code>, possibly followed by an occurrence indicator. Similarly
    <code>B</code> can either be <code>empty-sequence()</code> or an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ItemType" xlink:type="simple">ItemType</nt>, <code>Bi</code>, possibly followed by an occurrence indicator.
    The result of the <code>subtype(A, B)</code> judgement can be determined from the table below, which makes use of the auxiliary judgement <code>subtype-itemtype(Ai, Bi)</code> defined
    in <specref ref="id-itemtype-subtype"/>.
    </p>
		  
    <table border="1" summary="Special characters">
              <tbody>
      <tr>
                  <th rowspan="2" colspan="2"/>
                  <th colspan="5" rowspan="1">
                    <termref def="dt-sequence-type">Sequence type</termref> <code>B</code>
                  </th>
                </tr>
      <tr>
                  <th rowspan="1" colspan="1">
                    <code>empty-sequence()</code>
                  </th>
                  <th rowspan="1" colspan="1">
                    <code>Bi?</code>
                  </th>
                  <th rowspan="1" colspan="1">
                    <code>Bi*</code>
                  </th>
                  <th rowspan="1" colspan="1">
                    <code>Bi</code>
                  </th>
                  <th rowspan="1" colspan="1">
                    <code>Bi+</code>
                  </th>
                </tr>
      <tr>
                  <th rowspan="5" colspan="1">
                    <termref def="dt-sequence-type">Sequence type</termref> <code>A</code>
                  </th>
                  <th rowspan="1" colspan="1">
                    <code>empty-sequence()</code>
                  </th>
                  <td rowspan="1" colspan="1">true</td>
                  <td rowspan="1" colspan="1">true</td>
                  <td rowspan="1" colspan="1">true</td>
                  <td rowspan="1" colspan="1">false</td>
                  <td rowspan="1" colspan="1">false</td>
                </tr>
      <tr>
                  <th rowspan="1" colspan="1">
                    <code>Ai?</code>
                  </th>
                  <td rowspan="1" colspan="1">false</td>
                  <td rowspan="1" colspan="1">
                    <code>subtype-itemtype(Ai, Bi)</code>
                  </td>
                  <td rowspan="1" colspan="1">
                    <code>subtype-itemtype(Ai, Bi)</code>
                  </td>
                  <td rowspan="1" colspan="1">false</td>
                  <td rowspan="1" colspan="1">false</td>
                </tr>
      <tr>
                  <th rowspan="1" colspan="1">
                    <code>Ai*</code>
                  </th>
                  <td rowspan="1" colspan="1">false</td>
                  <td rowspan="1" colspan="1">false</td>
                  <td rowspan="1" colspan="1">
                    <code>subtype-itemtype(Ai, Bi)</code>
                  </td>
                  <td rowspan="1" colspan="1">false</td>
                  <td rowspan="1" colspan="1">false</td>
                </tr>
      <tr>
                  <th rowspan="1" colspan="1">
                    <code>Ai</code>
                  </th>
                  <td rowspan="1" colspan="1">false</td>
                  <td rowspan="1" colspan="1">
                    <code>subtype-itemtype(Ai, Bi)</code>
                  </td>
                  <td rowspan="1" colspan="1">
                    <code>subtype-itemtype(Ai, Bi)</code>
                  </td>
                  <td rowspan="1" colspan="1">
                    <code>subtype-itemtype(Ai, Bi)</code>
                  </td>
                  <td rowspan="1" colspan="1">
                    <code>subtype-itemtype(Ai, Bi)</code>
                  </td>
                </tr>
      <tr>
                  <th rowspan="1" colspan="1">
                    <code>Ai+</code>
                  </th>
                  <td rowspan="1" colspan="1">false</td>
                  <td rowspan="1" colspan="1">false</td>
                  <td rowspan="1" colspan="1">
                    <code>subtype-itemtype(Ai, Bi)</code>
                  </td>
                  <td rowspan="1" colspan="1">false</td>
                  <td rowspan="1" colspan="1">
                    <code>subtype-itemtype(Ai, Bi)</code>
                  </td>
                </tr>
    </tbody>
            </table>

  </div4>

  <div4 id="id-itemtype-subtype">
    <head>The ItemType Subtype Judgement</head>

    <p>The judgement <code>subtype-itemtype(Ai, Bi)</code> determines if the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ItemType" xlink:type="simple">ItemType</nt> <code>Ai</code>
    is a <termref def="dt-subtype">subtype</termref> of the ItemType <code>Bi</code>. <code>Ai</code> is a subtype of <code>Bi</code>
    if and only if at least one of the following conditions applies:
    </p>
		  
    <ulist>
      <item>
                <p>
      <code>Ai</code> and <code>Bi</code> are <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AtomicType" xlink:type="simple">AtomicTypes</nt>, and <code>derives-from(Ai, Bi)</code> returns true.
      </p>
              </item>
      <item>
                <p>
      <code>Bi</code> is <code>item()</code>.
      </p>
              </item>
      <item>
                <p>
      <code>Bi</code> is <code>node()</code>, and <code>Ai</code> is a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-KindTest" xlink:type="simple">KindTest</nt>.
      </p>
              </item>
      <item>
                <p>
      <code>Bi</code> is <code>function(*)</code>, and <code>Ai</code> is a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-FunctionTest" xlink:type="simple">FunctionTest</nt>.
      </p>
              </item>
      <item>
                <p>
      <code>Bi</code> is <code>text()</code> and <code>Ai</code> is also <code>text()</code>.
      </p>
              </item>
      <item>
                <p>
      <code>Bi</code> is <code>comment()</code> and <code>Ai</code> is also <code>comment()</code>.
      </p>
              </item>
      <item>
                <p>
      <code>Bi</code> is <code>namespace-node()</code> and <code>Ai</code> is also <code>namespace-node()</code>.
      </p>
              </item>
      <item>
                <p>
      <code>Bi</code> is <code>processing-instruction()</code> and <code>Ai</code> is either <code>processing-instruction()</code> or
      <code>processing-instruction(N)</code> for any name N..
      </p>
              </item>
      <item>
                <p>
      <code>Bi</code> is <code>processing-instruction(Bn)</code>, and <code>Ai</code> is also <code>processing-instruction(Bn)</code>.
      </p>
              </item>
      <item>
                <p>
      <code>Bi</code> is <code>document-node()</code> and <code>Ai</code> is either <code>document-node()</code> or
      <code>document-node(E)</code> for any <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ElementTest" xlink:type="simple">ElementTest</nt> E.
      </p>
              </item>
      <item>
                <p>
      <code>Bi</code> is <code>document-node(Be)</code> and <code>Ai</code> is <code>document-node(Ae)</code>, and <code>subtype-itemtype(Ae, Be)</code>.
      </p>
              </item>

      <item>
                <p>
      <code>Bi</code> is either <code>element()</code> or <code>element(*)</code>, and <code>Ai</code> is an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ElementTest" xlink:type="simple">ElementTest</nt>.
      </p>
              </item>
      <item>
                <p>
      <code>Bi</code> is either <code>element(Bn)</code> or <code>element(Bn, xs:anyType)</code>, and <code>Ai</code> is either <code>element(Bn)</code>, or <code>element(Bn, T)</code> for any type T.
      </p>
              </item>
      <item>
                <p>
      <code>Bi</code> is <code>element(Bn, Bt)</code>, <code>Ai</code> is <code>element(Bn, At)</code>, and <code>derives-from(At, Bt)</code> returns true.
      </p>
              </item>
      <item>
                <p>
      <code>Bi</code> is <code>element(Bn, Bt?)</code>, <code>Ai</code> is either <code>element(Bn, At)</code>, or <code>element(Bn, At?)</code>, and <code>derives-from(At, Bt)</code> returns true.
      </p>
              </item>
      <item>
                <p>
      <code>Bi</code> is <code>element(*, Bt)</code>, <code>Ai</code> is either <code>element(*, At)</code>, or <code>element(N, At)</code> for any name N, and <code>derives-from(At, Bt)</code> returns true.
      </p>
              </item>
      <item>
                <p>
      <code>Bi</code> is <code>element(*, Bt?)</code>, <code>Ai</code> is either <code>element(*, At)</code>, <code>element(*, At?)</code>, <code>element(N, At)</code>, or <code>element(N, At?)</code> for any name N, and <code>derives-from(At, Bt)</code> returns true.
      </p>
              </item>

      <item>
                <p>
      <code>Bi</code> is <code>schema-element(Bn)</code>, <code>Ai</code> is <code>schema-element(An)</code>, and either the <termref def="dt-expanded-qname">expanded QName</termref> <code>An</code> equals the <termref def="dt-expanded-qname">expanded QName</termref> <code>Bn</code>
      or the element declaration named <code>An</code> is in the substitution group of the element declaration named <code>Bn</code>.
      </p>
              </item>

      <item>
                <p>
      <code>Bi</code> is either <code>attribute()</code> or <code>attribute(*)</code>, and <code>Ai</code> is an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AttributeTest" xlink:type="simple">AttributeTest</nt>.
      </p>
              </item>
      <item>
                <p>
      <code>Bi</code> is either <code>attribute(Bn)</code> or <code>attribute(Bn, xs:anyType)</code>, and <code>Ai</code> is either <code>attribute(Bn)</code>, or <code>attribute(Bn, T)</code> for any type T.
      </p>
              </item>
      <item>
                <p>
      <code>Bi</code> is <code>attribute(Bn, Bt)</code>, <code>Ai</code> is <code>attribute(Bn, At)</code>, and <code>derives-from(At, Bt)</code> returns true.
      </p>
              </item>
      <item>
                <p>
      <code>Bi</code> is <code>attribute(*, Bt)</code>, <code>Ai</code> is either <code>attribute(*, At)</code>, or <code>attribute(N, At)</code> for any name N, and <code>derives-from(At, Bt)</code> returns true.
      </p>
              </item>

      <item>
                <p>
      <code>Bi</code> is <code>schema-attribute(Bn)</code> and <code>Ai</code> is also <code>schema-attribute(Bn)</code>.
      </p>
              </item>

      <item>
                <p>
      <code>Bi</code> is <code>function(Ba_1, Ba_2, ... Ba_N) as Br</code>, <code>Ai</code> is <code>function(Aa_1, Aa_2, ... Aa_M) as Ar</code>,
      <code>N</code> (arity of Bi) equals <code>M</code> (arity of Ai), <code>subtype(Ar, Br)</code>,
      and for values of <code>I</code> between 1 and <code>N</code>, <code>subtype(Ba_I, Aa_I)</code>.
      </p>
              </item>

    </ulist>

  </div4>

</div3>
		 
	 </div2> 

<div2 id="comments">
        <head>Comments</head>
        <scrap headstyle="suppress">
          <head/>
          <prod num="207" id="doc-xquery11-Comment">
            <lhs>Comment</lhs>
            <rhs>"(:"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-CommentContents" xlink:type="simple">CommentContents</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Comment" xlink:type="simple">Comment</nt>)*  ":)"</rhs>
          </prod>
          <prod num="215" id="doc-xquery11-CommentContents">
            <lhs>CommentContents</lhs>
            <rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Char" xlink:type="simple">Char</nt>+ - (Char* ('(:' | ':)') Char*))</rhs>
          </prod>
        </scrap>
        <p>Comments may be used to provide informative annotation for <phrase role="xquery">a query, either in the <termref def="dt-prolog">Prolog</termref> or in the <termref def="dt-queryBody">Query Body</termref>
          </phrase>. Comments are lexical constructs only, and do not affect  <phrase role="xquery">query</phrase> processing.</p>
        <p>Comments are strings, delimited by the symbols <code>(:</code> and <code>:)</code>. Comments may be nested.</p>
		
		 
		<p>A comment may be used anywhere <termref def="IgnorableWhitespace">ignorable whitespace</termref> is allowed (see <specref ref="DefaultWhitespaceHandling"/>).</p>
        <p>The following is an example of a comment:</p> 
		<eg xml:space="preserve">(: Houston, we have a problem :)</eg>
      </div2>
    </div1>  

<div1 id="id-expressions">
 <head>Expressions</head>  
  <p>This section discusses each of the basic kinds of expression. Each kind of expression has a name such as <code>PathExpr</code>, which is introduced on the left side of the grammar production that defines the expression. Since XQuery 1.1 is a composable language, each kind of expression is defined in terms of other expressions whose operators have a higher precedence. In this way, the precedence of operators is represented explicitly in the grammar.</p>
      <p>The order in which expressions are discussed in this document does not reflect the order of operator precedence. In general, this document introduces the simplest kinds of expressions first, followed by more complex expressions.  For the complete grammar, see Appendix [<specref ref="nt-bnf"/>].</p>
      <p>  <phrase role="xquery">
          <termdef id="dt-query" term="query">A <term>query</term> consists of one or more <termref def="dt-module">modules</termref>.</termdef>  If a query is executable, one of its modules has a <termref def="dt-queryBody">Query Body</termref>  containing an expression whose value is the result of the query. An expression is represented in the XQuery grammar by the symbol <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Expr" xlink:type="simple">Expr</nt>.</phrase>
      </p>
      <scrap headstyle="show"> 
		<head/> <prod num="39" id="doc-xquery11-Expr">
          <lhs>Expr</lhs>
          <rhs>
            <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>)*</rhs>
        </prod> 
	 <prod num="40" id="doc-xquery11-ExprSingle">
          <lhs>ExprSingle</lhs>
          <rhs>
            <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-FLWORExpr" xlink:type="simple">FLWORExpr</nt>
            <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-QuantifiedExpr" xlink:type="simple">QuantifiedExpr</nt>
            <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SwitchExpr" xlink:type="simple">SwitchExpr</nt>
            <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TypeswitchExpr" xlink:type="simple">TypeswitchExpr</nt>
            <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-IfExpr" xlink:type="simple">IfExpr</nt>
            <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TryCatchExpr" xlink:type="simple">TryCatchExpr</nt>
            <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-OrExpr" xlink:type="simple">OrExpr</nt>
          </rhs>
        </prod>
      </scrap>
      <p>The XQuery 1.1 operator that has lowest precedence is the <termref def="dt-comma-operator">comma operator</termref>, which is used to combine two operands to form a sequence. As shown in the grammar, a general expression (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Expr" xlink:type="simple">Expr</nt>) can consist of multiple <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt> operands, separated by commas. The name <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt> denotes an expression that does not contain a top-level <termref def="dt-comma-operator">comma operator</termref> (despite its name, an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt> may evaluate to a sequence containing more than one item.)</p>
      <p>The symbol <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt> is used in various places in the grammar where an expression is not allowed to contain a top-level comma. For example, each of the arguments of a function call must be an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>, because commas are used to separate the arguments of a function call.</p>
      <p>After the comma, the expressions that have next lowest precedence are <phrase role="xquery">
          <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-FLWORExpr" xlink:type="simple">FLWORExpr</nt>,</phrase> <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-QuantifiedExpr" xlink:type="simple">QuantifiedExpr</nt>, <phrase role="xquery">
          <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TypeswitchExpr" xlink:type="simple">TypeswitchExpr</nt>, </phrase>
        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-IfExpr" xlink:type="simple">IfExpr</nt>, and <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-OrExpr" xlink:type="simple">OrExpr</nt>. Each of these expressions is described in a separate section of this document.</p> 
	 <div2 id="id-primary-expressions"> 
	 <head>Primary Expressions</head> 
	 <p> <termdef id="dt-primary-expression" term="primary expression">
            <term>Primary expressions</term> are the basic primitives of the
	 language. They include literals, variable references,  context item expressions, <phrase role="xquery">constructors, </phrase> and function calls. A primary expression may also be created by enclosing any expression in parentheses, which is sometimes helpful in controlling the precedence of operators.</termdef>  <phrase role="xquery">Constructors are described in <specref ref="id-constructors"/>.</phrase>
        </p> 
	 <scrap headstyle="show"> 
		 <head/>
     <prod num="125" id="doc-xquery11-PrimaryExpr">
            <lhs>PrimaryExpr</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Literal" xlink:type="simple">Literal</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-VarRef" xlink:type="simple">VarRef</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ParenthesizedExpr" xlink:type="simple">ParenthesizedExpr</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ContextItemExpr" xlink:type="simple">ContextItemExpr</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-FunctionCall" xlink:type="simple">FunctionCall</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-OrderedExpr" xlink:type="simple">OrderedExpr</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-UnorderedExpr" xlink:type="simple">UnorderedExpr</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Constructor" xlink:type="simple">Constructor</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-FunctionItemExpr" xlink:type="simple">FunctionItemExpr</nt>
            </rhs>
          </prod>
     <prod num="164" id="doc-xquery11-FunctionItemExpr">
            <lhs>FunctionItemExpr</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-LiteralFunctionItem" xlink:type="simple">LiteralFunctionItem</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-InlineFunction" xlink:type="simple">InlineFunction</nt>
            </rhs>
          </prod>
	 </scrap> 
	 <div3 id="id-literals"> 
		<head>Literals</head> 
		<p> <termdef id="dt-literal" term="literal">A <term>literal</term> is a direct syntactic representation of an
		atomic value.</termdef> XQuery 1.1 supports two kinds of literals: numeric literals and
		string literals.</p> 
		<scrap headstyle="show"> 
		  <head/> <prod num="126" id="doc-xquery11-Literal">
              <lhs>Literal</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-NumericLiteral" xlink:type="simple">NumericLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-StringLiteral" xlink:type="simple">StringLiteral</nt>
              </rhs>
            </prod> 
		  <prod num="127" id="doc-xquery11-NumericLiteral">
              <lhs>NumericLiteral</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-IntegerLiteral" xlink:type="simple">IntegerLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-DecimalLiteral" xlink:type="simple">DecimalLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-DoubleLiteral" xlink:type="simple">DoubleLiteral</nt>
              </rhs>
            </prod> 
		  <prod num="197" id="doc-xquery11-IntegerLiteral">
              <lhs>IntegerLiteral</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Digits" xlink:type="simple">Digits</nt>
              </rhs>
            </prod> 
		  <prod num="198" id="doc-xquery11-DecimalLiteral">
              <lhs>DecimalLiteral</lhs>
              <rhs>("."  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Digits" xlink:type="simple">Digits</nt>)  |  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Digits" xlink:type="simple">Digits</nt>  "."  [0-9]*)</rhs>
            </prod> 
		  <prod num="199" id="doc-xquery11-DoubleLiteral">
              <lhs>DoubleLiteral</lhs>
              <rhs>(("."  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Digits" xlink:type="simple">Digits</nt>)  |  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Digits" xlink:type="simple">Digits</nt>  ("."  [0-9]*)?))  [eE]  [+-]?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Digits" xlink:type="simple">Digits</nt>
              </rhs>
            </prod> 
		  <prod num="200" id="doc-xquery11-StringLiteral">
              <lhs>StringLiteral</lhs>
              <rhs>('"'  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-PredefinedEntityRef" xlink:type="simple">PredefinedEntityRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-CharRef" xlink:type="simple">CharRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-EscapeQuot" xlink:type="simple">EscapeQuot</nt>  |  [^"&amp;])*  '"')  |  ("'"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-PredefinedEntityRef" xlink:type="simple">PredefinedEntityRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-CharRef" xlink:type="simple">CharRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-EscapeApos" xlink:type="simple">EscapeApos</nt>  |  [^'&amp;])*  "'")</rhs>
            </prod> 
		<prod num="201" id="doc-xquery11-PredefinedEntityRef">
              <lhs>PredefinedEntityRef</lhs>
              <rhs>"&amp;"  ("lt"  |  "gt"  |  "amp"  |  "quot"  |  "apos")  ";"</rhs>
            </prod>
    
    
    <prod num="214" id="doc-xquery11-Digits">
              <lhs>Digits</lhs>
              <rhs>[0-9]+</rhs>
            </prod>
          </scrap> 
		<p> The value of a <term>numeric literal</term> containing no "<code>.</code>" and no <code>e</code> or <code>E</code> character is  an atomic value of type <code>xs:integer</code>. The value of a numeric literal containing "<code>.</code>" but no <code>e</code> or <code>E</code> character is an atomic value of type <code>xs:decimal</code>. The value of a numeric literal containing an <code>e</code> or <code>E</code> character is an atomic value of type <code>xs:double</code>. The value of the numeric literal is determined by casting it to the 
appropriate type according to the rules for casting from <code>xs:untypedAtomic</code> 
to a numeric type as specified in <xspecref spec="FO" ref="casting-from-strings"/>.</p>
          <p>The value of a <term>string literal</term> is an atomic value whose  type is <code>xs:string</code> and whose value is the string denoted by the characters between the 
		delimiting apostrophes or quotation marks. If the literal is delimited by apostrophes, two adjacent apostrophes within the literal are interpreted as a single apostrophe. Similarly, if the literal is delimited by quotation marks, two adjacent quotation marks within the literal are interpreted as one quotation mark.</p>

<p role="xquery">A string literal may contain a <term>predefined entity reference</term>. <termdef term="predefined entity reference" id="dt-predefined-entity-reference">A <term>predefined entity reference</term> is a short sequence of characters, beginning with an ampersand, that represents a single character that might otherwise have syntactic significance.</termdef> Each predefined entity reference is replaced by the character it represents when the string literal is processed. The predefined entity references recognized by XQuery are as follows:</p>
<table width="60%" border="1" role="xquery" summary="Special characters">
            <tbody>
              <tr>
                <td align="center" rowspan="1" colspan="1">Entity Reference</td>
                <td align="center" rowspan="1" colspan="1">Character Represented</td>
              </tr>
              <tr>
                <td align="center" rowspan="1" colspan="1">
                  <code>&amp;lt;</code>
                </td>
                <td align="center" rowspan="1" colspan="1">
                  <code>&lt;</code>
                </td>
              </tr>
              <tr>
                <td align="center" rowspan="1" colspan="1">
                  <code>&amp;gt;</code>
                </td>
                <td align="center" rowspan="1" colspan="1">
                  <code>&gt;</code>
                </td>
              </tr>
              <tr>
                <td align="center" rowspan="1" colspan="1">
                  <code>&amp;amp;</code>
                </td>
                <td align="center" rowspan="1" colspan="1">
                  <code>&amp;</code>
                </td>
              </tr>
              <tr>
                <td align="center" rowspan="1" colspan="1">
                  <code>&amp;quot;</code>
                </td>
                <td align="center" rowspan="1" colspan="1">
                  <code>"</code>
                </td>
              </tr>
              <tr>
                <td align="center" rowspan="1" colspan="1">
                  <code>&amp;apos;</code>
                </td>
                <td align="center" rowspan="1" colspan="1">
                  <code>'</code>
                </td>
              </tr>
            </tbody>
          </table>
          <p role="xquery">A string literal may also contain a <term>character reference</term>. <termdef term="character reference" id="dt-character-reference">A <term>character reference</term> is an XML-style reference to a <bibref ref="Unicode"/> character, identified by its decimal or hexadecimal codepoint.</termdef> For example, the Euro symbol (€) can be represented by the character reference <code>&amp;#8364;</code>. Character references are normatively defined in Section 4.1 of the XML specification (it is <termref def="dt-implementation-defined">implementation-defined</termref> whether the rules in   <bibref ref="XML"/> or <bibref ref="XML1.1"/> apply.) A <termref def="dt-static-error">static error</termref> <errorref class="ST" code="0090"/> is raised if a character reference does not identify a valid character in the version of XML that is in use.</p> 
		 
		<p>Here are some examples of literal expressions:</p> 
		
<ulist> 
		  

  <item> 
			 <p> <code role="parse-test">"12.5"</code> denotes the string containing the characters '1', '2', '.', and
			 '5'.</p> 
		  </item> 
		  

  <item> 
			 <p> <code role="parse-test">12</code> denotes the <code>xs:integer</code> value twelve.</p> 
		  </item> 
		  

  <item> 
			 <p> <code role="parse-test">12.5</code> denotes the <code>xs:decimal</code> value twelve and one half.</p> 
		  </item> 
		  

  <item> 
			 <p> <code role="parse-test">125E2</code> denotes the <code>xs:double</code> value twelve thousand, five hundred.</p> 
		  </item>

  <item>
              <p>
                <code role="parse-test">"He said, ""I don't like it."""</code> denotes a string containing two quotation marks and one apostrophe.</p>
            </item>

  <item role="xquery">
              <p>
                <code role="parse-test">"Ben &amp;amp; Jerry&amp;apos;s"</code> denotes the <code>xs:string</code> value  "<code>Ben &amp; Jerry's</code>".</p> </item>

  <item role="xquery">
              <p>
                <code role="parse-test">"&amp;#8364;99.50"</code> denotes the <code>xs:string</code>  value "<code>€99.50</code>".</p>
            </item> 
		</ulist> 
		<p>The <code>xs:boolean</code> values <code>true</code> and <code>false</code> can be represented by calls to the <termref def="dt-built-in-function">built-in functions</termref> <code>fn:true()</code> and <code>fn:false()</code>, respectively.</p>
          <p>Values of other atomic types can be constructed by
		calling the <termref def="dt-constructor-function">constructor function</termref> for the given type. The constructor functions for XML Schema
		built-in types are defined in <bibref ref="xpath-functions-11"/>. In general, the name of a constructor function for a given type is the same as the name of the type (including its namespace). For
		example:</p> 
		
<ulist> 
		   
		  

  <item> 
			 <p> <code role="parse-test">xs:integer("12")</code> returns the integer value twelve.</p> 
		  </item> 
		  

  <item> 
			 <p> <code role="parse-test">xs:date("2001-08-25")</code> returns an item whose type is <code>xs:date</code> and whose value represents the date 25th August 2001.</p> 
		  </item>

  <item>
              <p>
                <code role="parse-test">xs:dayTimeDuration("PT5H")</code> returns an item whose type is <code>xs:dayTimeDuration</code> and whose value represents a duration of five hours.</p> </item> 
		</ulist> 
		<p>Constructor functions can also be used to create special values that have no literal representation, as in the following examples:
<ulist>

  <item>
                <p>
                  <code role="parse-test">xs:float("NaN")</code> returns the special floating-point value, "Not a Number."</p>
              </item>

  <item>
                <p>
                  <code role="parse-test">xs:double("INF")</code> returns the special double-precision value, "positive infinity."</p>
              </item>
            </ulist>
          </p>
          <p>It is also possible to construct values of various types by using a <code>cast</code> expression. For example:</p> 
		
<ulist> 
		  

  <item> 
			 <p> <code role="parse-test">9 cast as
                        hatsize</code> returns the atomic value <code>9</code> 
			 whose type is  <code>hatsize</code>.</p> 
		  </item> 
		</ulist> 
	 </div3> 
	 <div3 id="id-variables"> 
		<head>Variable References</head> 
		<scrap headstyle="show"> 
		<head/>  
	 <prod num="128" id="doc-xquery11-VarRef">
              <lhs>VarRef</lhs>
              <rhs>"$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-VarName" xlink:type="simple">VarName</nt>
              </rhs>
            </prod>
            <prod num="129" id="doc-xquery11-VarName">
              <lhs>VarName</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-EQName" xlink:type="simple">EQName</nt>
              </rhs>
            </prod>
          </scrap>
          <p> <termdef id="dt-variable-reference" term="variable reference">A <term>variable reference</term> is an EQName preceded by a $-sign.</termdef> Two variable references are equivalent if their local names are the same and their namespace prefixes are bound to the same namespace URI in the <termref def="dt-static-namespaces">statically known namespaces</termref>. An unprefixed variable reference is in no namespace.</p>
          <p>Every variable reference must match a name in the <termref def="dt-in-scope-variables">in-scope variables</termref>, which include variables from the following sources:

<olist>

  <item role="xquery">
                <p>A variable may be declared in a <termref def="dt-prolog">Prolog</termref>, in the current <termref def="dt-module">module</termref> or an <term>imported module</term>. See <specref ref="id-query-prolog"/> for a discussion of modules and Prologs.</p>
              </item>

  <item>
                <p>The <termref def="dt-in-scope-variables">in-scope variables</termref> may be augmented by <termref def="dt-implementation-defined">implementation-defined</termref> variables.</p>
              </item>

  <item>
                <p>A variable may be bound by an XQuery 1.1 expression. <phrase role="xquery">The kinds of expressions that can bind variables are FLWOR expressions (<specref ref="id-flwor-expressions"/>), quantified expressions (<specref ref="id-quantified-expressions"/>), and <code>typeswitch</code> expressions (<specref ref="id-typeswitch"/>).  Function calls also bind values to the formal parameters of functions before executing the function body. </phrase>
                </p>
              </item>
            </olist>
          </p> 
		 
		 
		 
		 
	 <p>Every variable binding has a static scope. The scope defines where
references to the variable can validly occur.

It is a <termref def="dt-static-error">static error</termref> <errorref class="ST" code="0008"/> to reference a variable that is not in scope. If a variable is bound in the <termref def="dt-static-context">static context</termref> for an expression, that variable is in scope for the entire expression.</p>
          <p role="xquery">A reference to a variable that was declared <code>external</code>, but was not bound to a value by the external environment, raises a dynamic error <errorref code="0002" class="DY"/>.</p>
          <p>If a variable reference matches two or more variable bindings that are in scope,
then the reference is taken as referring to the
inner binding, that is, the one whose scope is smaller.

At evaluation time, the value of a variable reference is the value of
the expression to which the relevant variable is bound.

The scope of a variable binding is defined separately for each kind of
expression that can bind variables.</p>
        </div3> 
	 <div3 id="id-paren-expressions"> 
		<head>Parenthesized Expressions</head> 
		<scrap headstyle="show"> 
<head/> <prod num="130" id="doc-xquery11-ParenthesizedExpr">
              <lhs>ParenthesizedExpr</lhs>
              <rhs>"("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Expr" xlink:type="simple">Expr</nt>?  ")"</rhs>
            </prod> 
 
 
</scrap>
          <p>Parentheses may be used to enforce a particular evaluation order in
		expressions that contain multiple operators. For example, the expression <code role="parse-test">(2 + 4)
		    * 5</code> evaluates to thirty, since the parenthesized expression <code role="parse-test">(2 + 4)</code> is evaluated first and its result is multiplied by five. Without
			 parentheses, the expression <code role="parse-test">2 + 4 * 5</code> evaluates to twenty-two, because the multiplication operator has higher
			 precedence than the addition operator.</p> 
		 
		<p>Empty parentheses are used to denote an empty sequence, as
		described in <specref ref="construct_seq"/>.</p> 
	 </div3> 

         <div3 id="id-context-item-expression">
              <head>Context Item Expression</head>
              <scrap headstyle="show"> <head/>
            <prod num="131" id="doc-xquery11-ContextItemExpr">
              <lhs>ContextItemExpr</lhs>
              <rhs>"."</rhs>
            </prod> </scrap>

              <p>A <term>context item expression</term> evaluates to
              the <termref def="dt-context-item">context item</termref>, which may be either a node (as in the
              expression
              <code role="parse-test">fn:doc("bib.xml")/books/book[fn:count(./author)&gt;1]</code>)
              or an atomic value (as in the expression <code role="parse-test">(1 to
              100)[. mod 5 eq 0]</code>).</p>
          <p>If the <termref def="dt-context-item">context item</termref> is undefined, a context item expression raises a dynamic error <errorref class="DY" code="0002"/>.</p>

         </div3>

	 <div3 id="id-function-calls"> 
		<head>Function Calls</head> 
		<p> <termdef term="built-in function" id="dt-built-in-function">The <term>built-in functions</term> supported by XQuery 1.1 are defined in <bibref ref="xpath-functions-11"/>.</termdef> 

		<phrase role="xquery">Additional functions may be declared in a
		  <termref def="dt-prolog">Prolog</termref>, imported
		  from a <termref def="dt-library-module">library module</termref>, or provided by
		  the external environment as part of the <termref def="dt-static-context">static
		  context</termref>.</phrase>
          </p>
          <scrap headstyle="show"> 
		  <head/> 
		  <prod num="134" id="doc-xquery11-FunctionCall">
              <lhs>FunctionCall</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-EQName" xlink:type="simple">EQName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ArgumentList" xlink:type="simple">ArgumentList</nt>
              </rhs>
            </prod> 
		  <prod num="135" id="doc-xquery11-Argument">
              <lhs>Argument</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ArgumentPlaceholder" xlink:type="simple">ArgumentPlaceholder</nt>
              </rhs>
            </prod> 
		  <prod num="136" id="doc-xquery11-ArgumentPlaceholder">
              <lhs>ArgumentPlaceholder</lhs>
              <rhs>"?"</rhs>
            </prod> 
		</scrap>
          <p>A <term>function call</term> consists of a EQName followed by a
		parenthesized list of zero or more arguments. <termdef term="argument expression" id="dt-arg-expr">An argument to a function call is either an
    <term>argument expression</term> or an ArgumentPlaceholder ("?").</termdef> If the EQName in the function
		call has no namespace prefix, it is considered to be
		in the <termref def="dt-def-fn-ns">default function
		namespace.</termref>
          </p>
          <p> If the <termref def="dt-expanded-qname">expanded QName</termref>
    and number of arguments in a function call do not match the name and arity
		of a <termref def="dt-function-signature">function signature</termref> in the
    <termref def="dt-static-context">static context</termref>,  a
    <termref def="dt-static-error">static error</termref> is raised <errorref class="ST" code="0017"/>.</p> 
		 
		<p>
      <termdef term="partial function application" id="dt-partial-function-application">A function call is a <term>partial function application</term>
      if one or more arguments is an ArgumentPlaceholder.</termdef>
      Evaluation of partial function applications is described in <specref ref="id-partial-function-application"/>, while
      evaluation of (non-partial) function calls is described in <specref ref="id-eval-function-call"/>.
    </p>

<p>Since the arguments of a function call are separated by commas, any
<termref def="dt-arg-expr">argument expression</termref> that contains a top-level <termref def="dt-comma-operator">comma operator</termref> must be
enclosed in parentheses. Here are some illustrative examples of
function calls:</p>
		
<ulist> 
		  

  <item> 
			 <p> <code role="parse-test">my:three-argument-function(1,
			2, 3)</code> denotes a function call with three arguments.</p> 
		  </item> 
		  

  <item> 
			 <p> <code role="parse-test">my:two-argument-function((1,
			2), 3)</code> denotes a function call with two arguments, the first of which is a
			 sequence of two values.</p> 
		  </item> 
		  

  <item> 
			 <p> <code role="parse-test">my:two-argument-function(1,
			())</code> denotes a function call with two arguments, the second of which is an
			 empty sequence.</p> 
		  </item> 
		  

  <item> 
			 <p> <code role="parse-test">my:one-argument-function((1, 2,
			3))</code> denotes a function call with one argument that is a sequence of three
			 values. </p> 
		  </item> 
		

  <item> 
			 <p> <code role="parse-test">my:one-argument-function(( ))</code> denotes a function call with one argument that is an empty sequence.</p> 
		  </item>

  <item> 
			 <p> <code role="parse-test">my:zero-argument-function( )</code> denotes a function call with zero arguments.</p> 
		  </item>
          </ulist> 


<div4 id="id-eval-function-call">
	<head>Evaluating Function Calls</head> 
		
  <p>The result of a function call on a function or <xtermref spec="DM11" ref="dt-function-item">function item</xtermref> <code>$f</code> is calculated as follows:</p>
		

<olist> 
		  

  <item> 
		<p>
                  <termdef term="argument value" id="dt-arg-value">
                    <termref def="dt-arg-expr">Argument expressions</termref> are evaluated, producing <term>argument
			 values</term>.</termdef> The order of argument evaluation is <termref def="dt-implementation-dependent">implementation-dependent</termref> and a function need not evaluate an argument if the function can evaluate its body without evaluating that argument.</p> 
		  </item> 
		  

  <item> 
			 <p>Each argument value is converted by applying the
			 <termref def="dt-function-conversion">function conversion rules</termref>.</p> 
		  </item>

  <item>
                <p>
    If $f is a <xtermref spec="DM11" ref="dt-function-item">function item</xtermref>, then
    the set of variable values from the function item's closure are added to the dynamic context with a scope of the invocation of the function.
  </p>
              </item>

  <item>
                <p>If <code>$f</code> is a built-in function, it is evaluated using the converted argument values. The result is either an instance of the function's declared return type or a dynamic error. Errors raised by built-in functions are defined in <bibref ref="xpath-functions-11"/>.</p>
              </item> 

  <item>
			 <p>If <code>$f</code> is a user-declared
		  function that has a body, the converted argument values are bound to
		  the formal parameters of <code>$f</code>, and the
		  function body is evaluated. The value returned by
		  the function body is then converted to the declared
		  return type of <code>$f</code> by applying the <termref def="dt-function-conversion">function
		  conversion rules</termref>.</p>
                <p>When a converted argument
		  value is bound to a function parameter, the argument
		  value retains its most specific <termref def="dt-dynamic-type">dynamic type</termref>, even
		  though this type may be derived from the type of the
		  formal parameter. For example, a function with a
		  parameter <code>$p</code> of type
		  <code>xs:decimal</code> can be invoked with an
		  argument of type <code>xs:integer</code>, which is
		  derived from <code>xs:decimal</code>. During the
		  processing of this function invocation, the <termref def="dt-dynamic-type">dynamic
		  type</termref> of <code>$p</code> inside the body of the
		  function is considered to be
		  <code>xs:integer</code>. Similarly, the value
		  returned by a function retains its most specific
		  type, which may be derived from the declared return
		  type of <code>$f</code>. For example, a function that
		  has a declared return type of
		  <code>xs:decimal</code> may in fact return a value
		  of dynamic type <code>xs:integer</code>.</p>
                <p>During evaluation of a function body, the <termref def="dt-static-context">static context</termref> and <termref def="dt-dynamic-context">dynamic context</termref> for expression evaluation are defined by the <phrase role="xquery">
                    <termref def="dt-module">module</termref> or</phrase> expression in which the function is declared, which is not necessarily the same as the context in which the function is called. For example, the variables in scope while
evaluating a function body are defined by the in-scope variables where it is declared, rather than
those in scope where the function is called. During
		  evaluation of a function body, the <termref def="dt-focus">focus</termref>
		  (context item, context position, and context size) is
		  undefined, except where it is defined by some expression inside the function body.</p> 
		  </item>

  <item role="xquery">
                <p>If <code>$f</code>
is a user-declared external function, its <termref def="dt-function-implementation">function
implementation</termref> is 
invoked with the converted argument values. The result is either a value
of the declared type or an <termref def="dt-implementation-defined">implementation-defined</termref> error (see <specref ref="id-consistency-constraints"/>).</p>
              </item> 
		</olist> 

</div4>

<div4 id="id-function-conversion-rules">
	<head>Function Conversion Rules</head> 

		<p>
              <termdef term="function conversion rules" id="dt-function-conversion">The <term>function conversion rules</term> are used to convert an
		argument value <phrase role="xquery">or a return value </phrase> to its expected type; that is, to
		the declared type of the function <phrase role="xquery">parameter or return.</phrase>
              </termdef> The expected type is expressed as a <termref def="dt-sequence-type">sequence type</termref>. The function conversion rules are applied to a given value
		as follows:</p> 
		
<ulist>

  

  <item>
                <p>If the
		expected type is a sequence of an atomic type
		(possibly with an occurrence indicator <code>*</code>,
		<code>+</code>, or <code>?</code>), the following
		conversions are applied:</p>

<olist>

  <item>
                    <p>
                      <termref def="dt-atomization">Atomization</termref> is applied
		to the given value, resulting in a sequence of atomic
		values.</p>
                  </item>

  <item>
                    <p>Each item in the atomic
		sequence that is of type
		<code>xs:untypedAtomic</code> is cast to the expected
		atomic type. For <termref def="dt-built-in-function">built-in functions</termref> where the expected type is specified as <termref def="dt-numeric">numeric</termref>, arguments of type <code>xs:untypedAtomic</code> are cast to <code>xs:double</code>.</p>
                  </item>

  <item>
                    <p>For each <termref def="dt-numeric">numeric</termref> item
		in the atomic sequence that can be
		<termref def="dt-type-promotion">promoted</termref> to the expected atomic type
		using numeric promotion as described in <specref ref="promotion"/>, the promotion is
		done.</p>
                  </item>

  <item>
                    <p>For each item of type <code>xs:anyURI</code>
		in the atomic sequence that can be
		<termref def="dt-type-promotion">promoted</termref> to the expected atomic type
		using URI promotion as described in <specref ref="promotion"/>, the promotion is
		done.</p>
                  </item>
                </olist>
              </item>

  <item>
                <p>If the
		expected type is a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TypedFunctionTest" xlink:type="simple">TypedFunctionTest</nt> (possibly with an occurrence indicator <code>*</code>,
		<code>+</code>, or <code>?</code>), <termref def="dt-function-item-coercion">function item coercion</termref> is applied to each function item in the given value.</p>
  </item>

  <item>
                <p> If, after the
		above conversions, the resulting value does not match
		the expected type according to the rules for <termref def="dt-sequencetype-matching">SequenceType
		Matching</termref>, a <termref def="dt-type-error">type error</termref> is
		raised <errorref class="TY" code="0004"/>.
		<phrase role="xquery">If the function call takes place in a <termref def="dt-module">module</termref> other
		than the <termref def="dt-module">module</termref> in which the function is defined, this
		rule must be satisfied in both the module where the
		function is called and the module where the function
		is defined (the test is repeated because the two
		modules may have different <termref def="dt-issd">in-scope schema definitions</termref>.)</phrase>
		Note that the rules for <termref def="dt-sequencetype-matching">SequenceType
		Matching</termref> permit a value of a derived type to
		be substituted for a value of its base
		type. </p>
              </item>
            </ulist>
</div4>

		 
<div4 id="id-function-coercion">
	<head>Function Item Coercion</head> 

      <p>
        Function item coercion is a transformation applied to <xtermref spec="DM11" ref="dt-function-item">function items</xtermref> during application of the
        <termref def="dt-function-conversion">function conversion rules</termref>.
        <termdef term="function item coercion" id="dt-function-item-coercion">
                <term>Function item coercion</term> wraps a <xtermref spec="DM11" ref="dt-function-item">function item</xtermref>
        in a new <termref def="dt-inline-func">inline function</termref> with signature the same as the expected type. This effectively delays the checking
        of the argument and return types until the function item is invoked.</termdef>
      </p>

      <p>
        Function item coercion is only defined to operate on <xtermref spec="DM11" ref="dt-function-item">function items</xtermref>. Given a function item, <code>$function</code>,
        function item coercion returns a new function item with the following properties (as defined in <xspecref spec="DM11" ref="function-items"/>):

        <ulist>
          <item>
                  <p>
            An empty set of variable values.
          </p>
                </item>
          <item>
                  <p>
            The name of <code>$function</code>.
          </p>
                </item>
          <item>
                  <p>
            A <xtermref spec="DM11" ref="dt-signature">function signature</xtermref> equal to the expected type for the function argument or return type.
          </p>
                </item>
          <item>
                  <p>
            A new function, whose result is calculated by
            invoking <code>$function</code> with the arguments that were specified at the new
            function's invocation.
          </p>
                </item>
        </ulist>
      </p>

      <p>
        If the result of invoking the new function item would
        necessarily result in a type error, that
        error may be raised during
        function coercion. It is implementation dependent whether this
        happens or not.
      </p>

      <p>
        These rules have the following consequences:

        <ulist>
          <item>
                  <p>
            SequenceType matching of the function item's arguments and result are delayed until that function item is invoked.
          </p>
                </item>
          <item>
                  <p>
            The function conversion rules applied to the function item's arguments and result are defined by the SequenceType
            it has most recently been coerced to. Additional function conversion rules could apply when the wrapped function
            item is invoked.
          </p>
                </item>
          <item>
                  <p>
            If an implementation has static type information about a function item, that can be used to type check the
            function item's argument and return types during static analysis.
          </p>
                </item>
        </ulist>

        For instance, consider the following query:
      </p>

      <eg role="parse-test" xml:space="preserve">
declare function local:filter($s as item()*, $p as function(xs:string) as xs:boolean) as item()*
{
  $s[$p(.)]
};

let $f := function($a) { starts-with($a, "E") }
return
  local:filter(("Ethel", "Enid", "Gertrude"), $f)
      </eg>

      <p>
        The function item <code>$f</code> has a static type of <code>function(item()*) as item()*</code>. When the <code>local:filter()</code> function
        is called, the following occurs to the function item:

        <olist>
          <item>
                  <p>
            The function conversion rules result in applying function coercion to <code>$function</code>, wrapping $f in a new inline function ($p)
            with the signature <code>function(xs:string) as xs:boolean</code>.
          </p>
                </item>          
          <item>
                  <p>
            $p is matched against the SequenceType of <code>function(xs:string) as xs:boolean</code>, and succeeds.
          </p>
                </item>
          <item>
                  <p>
            When $p is invoked inside the predicate, function conversion and SequenceType matching rules are applied to the context item argument,
            resulting in a <code>xs:string</code> value or a type error.
          </p>
                </item>
          <item>
                  <p>
            $f is invoked with the <code>xs:string</code>, which returns a <code>xs:boolean</code>.
          </p>
                </item>
          <item>
                  <p>
            $p applies function conversion rules to the result sequence from $f, which already matches its declared return type of <code>xs:boolean</code>.
          </p>
                </item>
          <item>
                  <p>
            The <code>xs:boolean</code> is returned as the result of $p.
          </p>
                </item>
        </olist>
      </p>

      <note>
              <p>
        Although the semantics of function item coercion are specified in terms of wrapping the function items,
        static typing will often be able to reduce the number of places where this is actually necessary.
      </p>
            </note>

</div4>

<div4 id="id-partial-function-application">
	<head>Evaluating Partial Function Applications</head> 

  <p>The result of a <termref def="dt-partial-function-application">partial function application</termref> of a function or
  <xtermref spec="DM11" ref="dt-function-item">function item</xtermref> $f is a single function item <code>$new</code> with the
  following properties (as defined in <xspecref spec="DM11" ref="function-items"/>):</p>

  <ulist>
    <item>
                <p>
      If <code>$f</code> is a function item, the set of variable values is the same as the variable values of <code>$f</code>, otherwise it is empty.
    </p>
              </item>
    <item>
                <p>
      An absent name.
    </p>
              </item>
    <item>
                <p>
      The <xtermref spec="DM11" ref="dt-signature">function signature</xtermref> of <code>$new</code> is the same as <code>$f</code>,
      removing the parameters in the positions for which any <termref def="dt-arg-expr">argument expressions</termref> have been provided to the partial
      function application. The function arity of <code>$new</code> is the arity of <code>$f</code> minus the number of argument expressions provided.
    </p>
              </item>
    <item>
                <p>
      The result of invoking <code>$new</code> is the result of invoking <code>$f</code>
      with the arguments from the invocation of <code>$new</code>, inserting any <termref def="dt-arg-value">argument values</termref> from
      the partial function application in their respective positions.
    </p>
              </item>
  </ulist>

  <p>
    If the value of any <termref def="dt-arg-expr">argument expression</termref> specified to a partial function application
    cannot be converted to the required type of the corresponding argument of <code>$f</code> by applying the
    <termref def="dt-function-conversion">function conversion rules</termref>,
    then a type error <errorref class="TY" code="0004"/> MAY be raised.
    (If a type error is not raised at this stage, it will be raised later when the new function is invoked.)
  </p>

  <p>
    The static context for evaluation of the function item <code>$f</code> is inherited from the location of the partial function application expression,
    with the exception of the static type of the context item which is initially undefined.
  </p>

  <p>
    Partially applied function items cannot access the <termref def="dt-focus">focus</termref> (context item, context position, and
    context size), which is undefined when they are <xtermref spec="DM11" ref="dt-invoke">invoked</xtermref>.
    It is a <termref def="dt-static-error">static error</termref> to partially apply a function which accesses the
    focus <errorref class="ST" code="0112"/>.
  </p>

</div4>

	 </div3> 

   <!-- ******************************************************************** -->

        <div3 id="id-literal-func-ref">
          <head>Literal Function Items</head>

          <scrap headstyle="show">
            <head/>
		        <prod num="165" id="doc-xquery11-LiteralFunctionItem">
              <lhs>LiteralFunctionItem</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-EQName" xlink:type="simple">EQName</nt>  "#"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-IntegerLiteral" xlink:type="simple">IntegerLiteral</nt>
              </rhs>
            </prod> 
		      </scrap>

          <p>
          <termdef term="literal function item" id="dt-literal-func-item">A <term>literal function item</term> creates a
          <xtermref spec="DM11" ref="dt-function-item">function item</xtermref> that represents a <termref def="tm-named-func">named function</termref>.</termdef>
          <termdef term="named function" id="tm-named-func">A <term>named function</term> is a function defined in the
          static context for the query. To uniquely identify a particular named function, both its name as a QName
          and its arity are required.</termdef>
          </p>

          <p>If the EQName is a <termref def="dt-qname">lexical QName</termref> that has no namespace prefix, it is considered to be in the default function namespace.</p>

          <p>If the <termref def="dt-expanded-qname">expanded QName</termref> and arity in a literal function item do not match the name and arity of a function signature in the
          static context, a static error is raised <errorref class="ST" code="0017"/>.</p>

          <p>The result of a literal function item is a single function item with the following properties (as defined in <xspecref spec="DM11" ref="function-items"/>):

          <ulist>
            <item>
                <p>
              An empty set of variable values.
            </p>
              </item>
            <item>
                <p>
              The name specified in the literal function item.
            </p>
              </item>
            <item>
                <p>
              The <xtermref spec="DM11" ref="dt-signature">function signature</xtermref> of the function from the static context that matches the name and arity given.
            </p>
              </item>
            <item>
                <p>
              The function from the static context that matches the name and arity given.
            </p>
              </item>
          </ulist>
            
          </p>

          <p>
            The static context for evaluation of the function item is inherited from the location of the literal function item expression,
            with the exception of the static type of the context item which is initially undefined.
          </p>

          <p>
            Literal function items cannot access the <termref def="dt-focus">focus</termref> (context item, context position, and
            context size), which is undefined when they are <xtermref spec="DM11" ref="dt-invoke">invoked</xtermref>.
            It is a <termref def="dt-static-error">static error</termref> to create a function item for a function which accesses the
            focus <errorref class="ST" code="0112"/>.
          </p>

          <note>
            <p>
              User-declared functions cannot access the focus, so this error only applies to built-in functions like:
              <ulist>
                <item>
                  <p>
                    <code>fn:position#0</code>
                  </p>
                </item>
                <item>
                  <p>
                    <code>fn:last#0</code>
                  </p>
                </item>
                <item>
                  <p>
                    <code>fn:name#0</code>
                  </p>
                </item>
                <item>
                  <p>
                    <code>fn:namespace-uri#0</code>
                  </p>
                </item>
                <item>
                  <p>
                    <code>fn:local-name#0</code>
                  </p>
                </item>
                <item>
                  <p>
                    <code>fn:number#0</code>
                  </p>
                </item>
                <item>
                  <p>
                    <code>fn:string#0</code>
                  </p>
                </item>
                <item>
                  <p>
                    <code>fn:string-length#0</code>
                  </p>
                </item>
                <item>
                  <p>
                    <code>fn:normalize-space#0</code>
                  </p>
                </item>
                <item>
                  <p>
                    <code>fn:root#0</code>
                  </p>
                </item>
                <item>
                  <p>
                    <code>fn:id#1</code>
                  </p>
                </item>
                <item>
                  <p>
                    <code>fn:idref#1</code>
                  </p>
                </item>
                <item>
                  <p>
                    <code>fn:lang#1</code>
                  </p>
                </item>
                <item>
                  <p>
                    <code>fn:base-uri#0</code>
                  </p>
                </item>
              </ulist>
            </p>            
          </note>

          <p>
            Certain functions in the <bibref ref="xpath-functions-11"/> specification are defined to be polymorphic.
            These are denoted as accepting parameters of "numeric" type, or returning "numeric" type. Here "numeric" is a pseudonym
            for the four primitive numeric types xs:decimal, xs:integer, xs:float, and xs:double. The functions in question
            are:

            <ulist>
              <item>
                <p>
                  <code>fn:abs</code>
                </p>
              </item>
              <item>
                <p>
                  <code>fn:ceiling</code>
                </p>
              </item>
              <item>
                <p>
                  <code>fn:floor</code>
                </p>
              </item>
              <item>
                <p>
                  <code>fn:round</code>
                </p>
              </item>
              <item>
                <p>
                  <code>fn:round-half-to-even</code>
                </p>
              </item>
            </ulist>

            For the purposes of literal function items, these functions are regarded as taking arguments and producing results
            of type xs:anyAtomicType, with a type error raised at runtime if the argument value provided is not of the correct
            numeric type.
          </p>

          <note>
            <p>
            The above way of modeling polymorphic functions is semantically backwards compatible with XQuery 1.0. 
            An implementation that supports static typing can choose to model the types of these functions more accurately if
            desired.
          </p>
          </note>

          <p>The following are examples of some literal function item expressions:
          </p>

          <ulist>
            <item>
			        <p>
                <code role="parse-test">fn:abs#1</code> references the fn:abs function which takes a single argument.</p> 
		        </item>
            <item>
			        <p>
                <code role="parse-test">fn:concat#5</code> references the fn:concat function which takes 5 arguments.</p> 
		        </item>
            <item>
			        <p>
                <code role="parse-test">local:myfunc#2</code> references a function named local:myfunc which takes 2 arguments.</p> 
		        </item>
          </ulist>

        </div3>

        <div3 id="id-inline-func">
          <head>Inline Functions</head>

          <scrap headstyle="show">
            <head/>
		        <prod num="166" id="doc-xquery11-InlineFunction">
              <lhs>InlineFunction</lhs>
              <rhs>"function"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ParamList" xlink:type="simple">ParamList</nt>?  ")"  ("as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SequenceType" xlink:type="simple">SequenceType</nt>)?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-EnclosedExpr" xlink:type="simple">EnclosedExpr</nt>
              </rhs>
            </prod> 
		         
		         
		         
		         
		      </scrap>

          <p>
          <termdef term="inline function" id="dt-inline-func">An <term>inline function</term> expression creates a
          <xtermref spec="DM11" ref="dt-function-item">function item</xtermref> that represents an anonymous function defined directly in the
          inline function expression itself.</termdef> An inline function specifies the names and SequenceTypes of the parameters to the function,
          the SequenceType of the result, and the body of the function.
          </p>

          <p>
          If a function parameter is declared using a name but no type, its default type is item()*. If the result type is omitted from a
          function declaration, its default result type is item()*.
          </p>

          <p>
          The parameters of a function declaration are considered to be variables whose scope is the function body. It is a static error
          <errorref class="ST" code="0039"/> for a function declaration to have more than one parameter with the same name.
          </p>

          <p>
          The static context for the function body is inherited from the location of the inline function expression, with the exception of the
          static type of the context item which is initially undefined.
          </p>

          <p>
          The variables in scope for the function body include all variables representing the function parameters, as well as all variables that
          are in scope for the inline function expression.

          <note>
              <p>
            Function parameter names can mask variables that would otherwise be in scope for the function body.
          </p>
            </note>
          </p>

          <p>The result of an inline function is a single function item with the following properties (as defined in <xspecref spec="DM11" ref="function-items"/>):

          <ulist>
            <item>
                <p>
              The set of variable values for any variables referenced by the inline function's body.
            </p>
              </item>
            <item>
                <p>
              An absent name.
            </p>
              </item>
            <item>
                <p>
              The <xtermref spec="DM11" ref="dt-signature">function signature</xtermref> of the inline function.
            </p>
              </item>
            <item>
                <p>
              The inline function itself.
            </p>
              </item>
          </ulist>

          </p>

          <p>The following are examples of some inline functions:</p>

          <ulist>
            <item>
			        <p>This example creates an inline function that takes no arguments and returns a sequence of the first 6 primes:
                <eg role="parse-test" xml:space="preserve">function() as xs:integer+ { 2, 3, 5, 7, 11, 13 }</eg>
              </p>
		        </item>
            <item>
			        <p>This example creates an inline function that takes two xs:double arguments and returns their product:
                <eg role="parse-test" xml:space="preserve">function($a as xs:double, $b as xs:double) as xs:double { $a * $b }</eg>
              </p>
		        </item>
            <item>
			        <p>This example creates an inline function that returns its item()* argument:
                <eg role="parse-test" xml:space="preserve">function($a) { $a }</eg>
              </p>
		        </item>
            <item>
			        <p>This example creates an inline function that returns the xs:integer value 7, i.e.: the value of the variable $a from the scope of the inline function expression:
                <eg role="parse-test" xml:space="preserve">
let $a := 7
return
let $f := function() { $a }
return
let $a := 8
return $f()
</eg>
              </p>
		        </item>
          </ulist>

        </div3>

  </div2> 
  <div2 id="id-postfix-expression">
    <head>Postfix Expressions</head>
	  
    <scrap headstyle="show"> 
      <head/> 
      <prod num="121" id="doc-xquery11-PostfixExpr">
            <lhs>PostfixExpr</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-PrimaryExpr" xlink:type="simple">PrimaryExpr</nt>  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Predicate" xlink:type="simple">Predicate</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ArgumentList" xlink:type="simple">ArgumentList</nt>)*</rhs>
          </prod>
      <prod num="124" id="noid_N12B8C.doc-xquery11-Predicate">
            <lhs>Predicate</lhs>
            <rhs>"["  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Expr" xlink:type="simple">Expr</nt>  "]"</rhs>
          </prod>
      <prod num="122" id="noid_N12B8F.doc-xquery11-ArgumentList">
            <lhs>ArgumentList</lhs>
            <rhs>"("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Argument" xlink:type="simple">Argument</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Argument" xlink:type="simple">Argument</nt>)*)?  ")"</rhs>
          </prod>		   
    </scrap> 

    <p>
          <termdef term="filter expression" id="dt-filter-expression">An
    expression followed by a predicate (that is, <code>E1[E2]</code>)
    is referred to as a <term>filter expression</term>: its effect is
    to return those items from the value of <code>E1</code> that
    satisfy the predicate in E2.</termdef> Filter expressions are
    described in <specref ref="id-filter-expression"/>
        </p>

    <p>
          <termdef id="dt-dynamic-function-invoction" term="dynamic     function invocation">An expression (other than a raw EQName)
    followed by an argument list in parentheses (that is, <code>E1(E2,
    E3, ...)</code>) is referred to as a <term>dynamic function
    invocation</term>. Its effect is to evaluate <code>E1</code> to
    obtain a function item, and then call the function represented by
    that function item, with <code>E2</code>, <code>E3</code>,
    <code>...</code> as arguments.</termdef> Dynamic function
    invocations are described in <specref ref="id-dynamic-function-invocation"/>.</p>

    <div3 id="id-filter-expression">
      <head>Filter Expressions</head>

      <scrap headstyle="show">
            <head/>
		    <prod num="121" id="noid_N12BCB.doc-xquery11-PostfixExpr">
              <lhs>PostfixExpr</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-PrimaryExpr" xlink:type="simple">PrimaryExpr</nt>  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Predicate" xlink:type="simple">Predicate</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ArgumentList" xlink:type="simple">ArgumentList</nt>)*</rhs>
            </prod>
        <prod num="124" id="doc-xquery11-Predicate">
              <lhs>Predicate</lhs>
              <rhs>"["  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Expr" xlink:type="simple">Expr</nt>  "]"</rhs>
            </prod>
		  </scrap>

      <p>A filter expression consists of a base expression followed by
      a predicate, which is an expression written in square
      brackets. The result of the filter expression consists of the
      items returned by the base expression, filtered by applying the
      predicate to each item in turn. The ordering of the items
      returned by a filter expression is the same as their order in
      the result of the primary expression.</p>

      <note>
            <p>Where the expression before the square brackets is a
      <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ReverseStep" xlink:type="simple">ReverseStep</nt> or <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ForwardStep" xlink:type="simple">ForwardStep</nt>, the expression is technically not a
      filter expression but an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AxisStep" xlink:type="simple">AxisStep</nt>. There are minor differences
      in the semantics: see <specref ref="id-predicate"/>
            </p>
          </note>


 
      <p>Here are some examples of filter expressions:</p>

      <ulist>
	
	<item>
              <p>Given a sequence of products in a variable, return only those products whose price is greater than 100.</p>
              <eg role="parse-test" xml:space="preserve">$products[price gt 100]</eg>
            </item>
	
	<item>
              <p>List all the integers from 1 to 100 that are divisible by 5. (See <specref ref="construct_seq"/> for an explanation of the <code>to</code> operator.)</p>
              <eg role="parse-test" xml:space="preserve">(1 to 100)[. mod 5 eq 0]</eg>
            </item>
	
	<item>
              <p>The result of the following expression is the integer 25:</p>
              <eg role="parse-test" xml:space="preserve">(21 to 29)[5]</eg>
            </item>
	
	<item>
              <p>The following example returns the fifth through ninth items in the sequence bound to variable <code>$orders</code>.</p>
              <eg role="parse-test" xml:space="preserve">$orders[fn:position() = (5 to 9)]</eg>
            </item>
	
	<item>
              <p>The following example illustrates the use of a filter expression as a <termref def="dt-step">step</termref> in a <termref def="dt-path-expression">path expression</termref>. It returns the last chapter or appendix within the book bound to variable <code>$book</code>:</p>
              <eg role="parse-test" xml:space="preserve">$book/(chapter | appendix)[fn:last()]</eg>
            </item>
	
	<item>
              <p>The following example also illustrates the use of a filter expression as a <termref def="dt-step">step</termref> in a <termref def="dt-path-expression">path expression</termref>. It returns the element node within the specified document whose ID value is <code>tiger</code>:</p>
              <eg role="parse-test" xml:space="preserve">fn:doc("zoo.xml")/fn:id('tiger')</eg>
            </item>
      </ulist>

      <p>For each item in the input sequence, the predicate expression
      is evaluated using an <term>inner focus</term>, defined as
      follows: The context item is the item currently being tested
      against the predicate. The context size is the number of items
      in the input sequence. The context position is the position of
      the context item within the input sequence. </p>

      <p>For each item in the input sequence, the result of the
      predicate expression is coerced to an <code>xs:boolean</code>
      value, called the <term>predicate truth value</term>, as
      described below. Those items for which the predicate truth value
      is <code>true</code> are retained, and those for which the
      predicate truth value is <code>false</code> are discarded.</p>


       <p>The predicate truth value is derived by applying the following rules,
       in order:</p> 
       
       <olist> 
	 
	 <item> 
	   <p>If the value of the predicate expression is a <termref def="dt-singleton">singleton</termref> atomic value of a
	   <termref def="dt-numeric">numeric</termref> type or derived
	   from a <termref def="dt-numeric">numeric</termref> type,
	   the predicate truth value is <code>true</code> if the value
	   of the predicate expression is equal (by the
	   <code>eq</code> operator) to the <term>context
	   position</term>, and is <code>false</code>
	   otherwise. <termdef term="numeric predicate" id="dt-numeric-predicate">A predicate whose predicate
	   expression returns a numeric type is called a <term>numeric
	   predicate</term>.</termdef>
              </p>

	 <note role="xquery">
                <p>In a region of a query where <termref def="dt-ordering-mode">ordering mode</termref> is
	 <code>unordered</code>, the result of a numeric predicate is
	 nondeterministic, as explained in <specref ref="id-unordered-expressions"/>.</p>
              </note>
            </item>
	 

	 <item> 
	   <p>Otherwise, the predicate truth value is the <termref def="dt-ebv">effective boolean value</termref> of the
	   predicate expression.</p>
	 </item> 
	 
       </olist> 
    </div3>

        <div3 id="id-dynamic-function-invocation">
          <head>Dynamic Function Invocation</head>

          <scrap headstyle="show">
            <head/>
		        <prod num="121" id="noid_N12CA6.doc-xquery11-PostfixExpr">
              <lhs>PostfixExpr</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-PrimaryExpr" xlink:type="simple">PrimaryExpr</nt>  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Predicate" xlink:type="simple">Predicate</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ArgumentList" xlink:type="simple">ArgumentList</nt>)*</rhs>
            </prod>
		        <prod num="122" id="doc-xquery11-ArgumentList">
              <lhs>ArgumentList</lhs>
              <rhs>"("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Argument" xlink:type="simple">Argument</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Argument" xlink:type="simple">Argument</nt>)*)?  ")"</rhs>
            </prod>
		        <prod num="135" id="noid_N12CAD.doc-xquery11-Argument">
              <lhs>Argument</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ArgumentPlaceholder" xlink:type="simple">ArgumentPlaceholder</nt>
              </rhs>
            </prod> 
		        <prod num="136" id="noid_N12CB0.doc-xquery11-ArgumentPlaceholder">
              <lhs>ArgumentPlaceholder</lhs>
              <rhs>"?"</rhs>
            </prod> 
		      </scrap>

          <p>
            <termdef term="dynamic function invocation" id="dt-dynamic-function-invocation">A <term>dynamic function invocation</term>
            consists of a PrimaryExpr that returns the function item and a
            parenthesized list of zero or more arguments (<termref def="dt-arg-expr">argument expressions</termref> or
            ArgumentPlaceholders).</termdef>
          </p>

          <p>If the PrimaryExpr does not return a sequence consisting of a single function item with the same
          arity as the number of specified arguments, a type error is raised <errorref class="TY" code="0004"/>.</p>

          <p>
            A dynamic function invocation is a
            <termref def="dt-partial-function-application">partial function application</termref> if at least one
            of the arguments is an ArgumentPlaceholder ("?"), and is evaluated according to the rules in
            <specref ref="id-partial-function-application"/>.
          </p>

          <p>
            A dynamic function invocation that is not a <termref def="dt-partial-function-application">partial function application</termref>
            <xtermref spec="DM11" ref="dt-invoke">invokes</xtermref> the <xtermref spec="DM11" ref="dt-function-item">function item</xtermref>,
            calling the function it represents, and is evaluated as described in <specref ref="id-eval-function-call"/>.
          </p>

          <p>The following are examples of some dynamic function invocations:</p>

          <ulist>
            <item>
			        <p>This example invokes the function item contained in $f, passing the arguments 2 and 3:
                <eg role="parse-test" xml:space="preserve">$f(2, 3)</eg>
              </p>
		        </item>
            <item>
			        <p>This example fetches the second item from sequence $f, treats it as a function item and invokes it, passing a xs:string argument:
                <eg role="parse-test" xml:space="preserve">$f[2]("Hi there")</eg>
              </p>
		        </item>
            <item>
			        <p>This example invokes the function item $f passing no arguments, and filters the result with a positional predicate:
                <eg role="parse-test" xml:space="preserve">$f()[2]</eg>
              </p>
		        </item>
          </ulist>

        </div3>

	  
<!--

[164]  ArgumentList ::=  "(" (ExprSingle ("," ExprSingle)*)? ")"

{productions 121 and 164 are renamed, but otherwise unchanged)

{and production 133 can become [133] FunctionCall ::= QName ArgumentList}

      Argh! Messes up description of the BNF syntax:

       In the grammar productions in this document, named symbols are
       underlined and literal text is enclosed in double quotes. For
       example, the following production describes the syntax of a
       function call:

-->

  </div2>
  <div2 id="id-path-expressions"> 
	 <head>Path Expressions</head> 
	  
	 <scrap headstyle="show"> 
		<head/> <prod num="108" id="doc-xquery11-PathExpr">
            <lhs>PathExpr</lhs>
            <rhs>("/"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt>?)<br/>|  ("//"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt>)<br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt>
            </rhs>
          </prod>
          <prod num="109" id="doc-xquery11-RelativePathExpr">
            <lhs>RelativePathExpr</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-StepExpr" xlink:type="simple">StepExpr</nt>  (("/"  |  "//")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-StepExpr" xlink:type="simple">StepExpr</nt>)*</rhs>
          </prod> 
		   
	 </scrap> 
	 <p>
          <termdef id="dt-path-expression" term="path expression">A <term>path expression</term> can be used to locate nodes
	 within trees. A path expression consists of a series of one or more
	 <termref def="dt-step">steps</termref>, separated by "<code>/</code>" or
	 "<code>//</code>", and optionally beginning with
	 "<code>/</code>" or "<code>//</code>".</termdef> An initial
	 "<code>/</code>" or "<code>//</code>" is an abbreviation for
	 one or more initial steps that are implicitly added to the
	 beginning of the path expression, as described below.</p>
        <p>A
	 path expression consisting of a single step is evaluated as
	 described in <specref ref="id-steps"/>.</p>
        <p>A "<code>/</code>"
	 at the beginning of a path expression is an abbreviation for
	 the initial step <code>
            <phrase diff="chg" at="XQ.E3 and XP.E3">(fn:root(self::node()) treat as document-node())</phrase>/</code> (however, if the 
	 "<code>/</code>" is the entire path expression, the trailing "<code>/</code>" is omitted from the expansion.) The effect
	 of this initial step is to begin the path at the root node of
	 the tree that contains the context node. If the context item
	 is not a node, a <termref def="dt-type-error">type
	 error</termref> is raised <errorref class="TY" code="0020"/>. At
	 evaluation time, if the root node above the context node is
	 not a document node, a <termref def="dt-dynamic-error">dynamic error</termref> is
	 raised <errorref class="DY" code="0050"/>.</p>

	 <p>A "<code>//</code>" at the beginning of a path expression
	 is an abbreviation for the initial steps
	 <code>
            <phrase diff="chg" at="XQ.E3 and XP.E3">(fn:root(self::node()) treat as
	 document-node())</phrase>/descendant-or-self::node()/</code> (however, "<code>//</code>" by itself is not a valid path expression <errorref class="ST" code="0003"/>.)  The
	 effect of these initial steps is to establish an initial node
	 sequence that contains the root of the tree in which the
	 context node is found, plus all nodes descended from this
	 root.
	 This node sequence is used as the input to subsequent steps
	 in the path expression. If the context item is not a node, a
	 <termref def="dt-type-error">type error</termref> is
	 raised <errorref class="TY" code="0020"/>. At evaluation time, if the
	 root node above the context node is not a document node, a
	 <termref def="dt-dynamic-error">dynamic error</termref> is
	 raised <errorref class="DY" code="0050"/>.</p>
	  
	 <note>
          <p>The descendants of a node do not include attribute
	 nodes .</p>
        </note>
        <p>Each
	 non-initial occurrence of "<code>//</code>" in a path expression is
	 expanded as described in <specref ref="abbrev"/>, leaving a
	 sequence of steps separated by "<code>/</code>". This sequence
	 of steps is then evaluated from left to right. Each operation
	 <code role="parse-test">E1/E2</code> is evaluated as follows:
	 Expression <code role="parse-test">E1</code> is evaluated,
	 and if the result is not a (possibly empty) sequence of nodes, a <termref def="dt-type-error">type error</termref> is raised <errorref class="TY" code="0019"/>. Each node resulting from the evaluation of
	 <code>E1</code> then serves in turn to provide an <term>inner
	 focus</term> for an evaluation of <code>E2</code>, as
	 described in <specref ref="eval_context"/>. The sequences resulting from all the evaluations of <code>E2</code> are combined as follows:</p>

<olist>

  <item>
            <p>If every evaluation of <code>E2</code> returns a (possibly empty) sequence of 
nodes, these sequences are combined, and duplicate nodes are eliminated 
based on node identity.  <phrase role="xquery">If <termref def="dt-ordering-mode">ordering mode</termref> is <code>ordered</code>, the resulting node sequence is returned in <termref def="dt-document-order">document
	 order</termref>; otherwise it is returned in <termref def="dt-implementation-dependent">implementation-dependent</termref> order.</phrase>
            </p>
          </item>

  <item>
            <p>If every evaluation of <code>E2</code> returns a (possibly empty) sequence of 
non-nodes, these sequences are concatenated and returned. <phrase role="xquery">If <termref def="dt-ordering-mode">ordering mode</termref> is <code>ordered</code>, the returned sequence preserves the orderings within and among the subsequences generated by the evaluations of <code>E2</code>; otherwise the order of the returned sequence is <termref def="dt-implementation-dependent">implementation-dependent</termref>.</phrase>
            </p>
          </item>

  <item>
            <p>If the multiple evaluations of <code>E2</code> return at least 
one node and at least one non-node, a <termref def="dt-type-error">type
	 error</termref> is raised <errorref class="TY" code="0018"/>.</p>
          </item>
        </olist>
        <note>
          <p>Since each step in a path provides context nodes for the following 
step, in effect, only the last step in a path is allowed to return a 
sequence of non-nodes.</p>
        </note>
        <p>As an example of a path expression, <code role="parse-test">child::div1/child::para</code> selects the
	 <code>para</code> element children of the <code>div1</code>
	 element children of the context node, or, in other words, the
	 <code>para</code> element grandchildren of the context node
	 that have <code>div1</code> parents.</p>
	  
	 <note>
          <p id="Chg-slash-note">The "<code>/</code>" character
	 can be used either as a complete path expression or as the
	 beginning of a longer path expression such as
	 "<code>/*</code>".  Also, "<code role="parse-test">*</code>"
	 is both the multiply operator and a wildcard in path
	 expressions.  This can cause parsing difficulties when
	 "<code>/</code>" appears on the left hand side of
	 "<code>*</code>".  This is resolved using the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-leading-lone-slash" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">leading-lone-slash
	 </loc> constraint.  For example, "<code role="parse-test">/*</code>" and "<code role="parse-test">/
	 *</code>" are valid path expressions containing wildcards,
	 but "<code>/*5</code>" and "<code>/ * 5</code>" raise syntax
	 errors. Parentheses must be used when "<code>/</code>" is
	 used on the left hand side of an operator, as in "<code role="parse-test">(/) * 5</code>". Similarly, "<code>4 + / *
	 5</code>" raises a syntax error, but "<code role="parse-test">4 + (/) * 5</code>" is a valid expression.
	 The expression "<code role="parse-test">4 + /</code>" is also
	 valid, because <code>/</code> does not occur on the left hand
	 side of the operator.</p>

	 <p>Similarly, in the expression <code role="parse-test">/
	 union /*</code>, "union" is interpreted as an element name
	 rather than an operator. For it to be parsed as an operator,
	 the expression should be written <code role="parse-test">(/)
	 union /*</code>.</p>
	 
	 </note>

	 <div3 id="id-steps"> 
		<head>Steps</head> 
		<scrap headstyle="show"> 
		  <head/> <prod num="110" id="doc-xquery11-StepExpr">
              <lhs>StepExpr</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-PostfixExpr" xlink:type="simple">PostfixExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AxisStep" xlink:type="simple">AxisStep</nt>
              </rhs>
            </prod> 
			 <prod num="111" id="noid_N12E81.doc-xquery11-AxisStep">
              <lhs>AxisStep</lhs>
              <rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ReverseStep" xlink:type="simple">ReverseStep</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ForwardStep" xlink:type="simple">ForwardStep</nt>)  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-PredicateList" xlink:type="simple">PredicateList</nt>
              </rhs>
            </prod>
            <prod num="112" id="doc-xquery11-ForwardStep">
              <lhs>ForwardStep</lhs>
              <rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ForwardAxis" xlink:type="simple">ForwardAxis</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-NodeTest" xlink:type="simple">NodeTest</nt>)  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AbbrevForwardStep" xlink:type="simple">AbbrevForwardStep</nt>
              </rhs>
            </prod> 
			 <prod num="115" id="doc-xquery11-ReverseStep">
              <lhs>ReverseStep</lhs>
              <rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ReverseAxis" xlink:type="simple">ReverseAxis</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-NodeTest" xlink:type="simple">NodeTest</nt>)  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AbbrevReverseStep" xlink:type="simple">AbbrevReverseStep</nt>
              </rhs>
            </prod> 
		<prod num="123" id="noid_N12E8B.doc-xquery11-PredicateList">
              <lhs>PredicateList</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Predicate" xlink:type="simple">Predicate</nt>*</rhs>
            </prod>
          </scrap> 
		<p>
            <termdef term="step" id="dt-step">A <term>step</term> is a part of a <termref def="dt-path-expression">path expression</termref> that generates a sequence of items
		and then filters the sequence by zero or more
		<termref def="dt-predicate">predicates</termref>. The value of the step
		consists of those items that satisfy the
		predicates, working from left to right. A step may be either an <termref def="dt-axis-step">axis step</termref> or a postfix expression.</termdef> Postfix expressions are described in <specref ref="id-postfix-expression"/>.</p>
          <p>
            <termdef term="axis step" id="dt-axis-step">An <term>axis step</term> returns a sequence of nodes that are reachable from the context node via a specified axis. Such a step has two parts: an
		<term>axis</term>, which defines the "direction of
		movement" for the step, and a <termref def="dt-node-test">node test</termref>,
		which selects nodes based on their kind, name, and/or
		<termref def="dt-type-annotation">type annotation</termref>.</termdef> If the context item is a node, an axis
		step returns a sequence of zero or more
		nodes; otherwise, a <termref def="dt-type-error">type error</termref> is
		raised <errorref class="TY" code="0020"/>.    <phrase role="xquery">If <termref def="dt-ordering-mode">ordering mode</termref> is <code>ordered</code>, the resulting node sequence is returned in <termref def="dt-document-order">document
	 order</termref>; otherwise it is returned in <termref def="dt-implementation-dependent">implementation-dependent</termref> order.</phrase> An axis step may be either a <term>forward
		step</term> or a <term>reverse step</term>, followed
		by zero or more <termref def="dt-predicate">predicates</termref>.</p>
		 
		<p>In the <term>abbreviated syntax</term> for a step, the axis can
		be omitted and other shorthand notations can be used as described in
		<specref ref="abbrev"/>.</p> 
		<p>The unabbreviated syntax for an axis step consists of the axis name
		and node test separated by a double colon. The result of the step consists of the nodes
		reachable from the context node via the specified axis that have the node kind, name,
		and/or <termref def="dt-type-annotation">type annotation</termref> specified by the node test. For example, the
		step <code role="parse-test">child::para</code> selects the <code>para</code> element children of the context node: <code>child</code> is the name of the axis, and <code>para</code> is the name of the element nodes to be selected on this axis. The available axes are described in <specref ref="axes"/>. The
		available node tests are described in <specref ref="node-tests"/>. Examples of 
		steps are provided in <specref ref="unabbrev"/> and <specref ref="abbrev"/>.</p> 

		<div4 id="axes"> 
		  <head>Axes</head> 
		  <scrap headstyle="show"> 
			 <head/> <prod num="113" id="doc-xquery11-ForwardAxis">
                <lhs>ForwardAxis</lhs>
                <rhs>("child"  "::")<br/>|  ("descendant"  "::")<br/>|  ("attribute"  "::")<br/>|  ("self"  "::")<br/>|  ("descendant-or-self"  "::")<br/>|  ("following-sibling"  "::")<br/>|  ("following"  "::")</rhs>
              </prod> 
				<prod num="116" id="doc-xquery11-ReverseAxis">
                <lhs>ReverseAxis</lhs>
                <rhs>("parent"  "::")<br/>|  ("ancestor"  "::")<br/>|  ("preceding-sibling"  "::")<br/>|  ("preceding"  "::")<br/>|  ("ancestor-or-self"  "::")</rhs>
              </prod> 
		  </scrap> 




		   

		  <p role="xquery">XQuery supports the following axes<!-- <phrase diff="del"/>
		  (subject to limitations as described in <specref ref="id-full-axis-feature"/>)-->:</p>

		  
<ulist> 
			 

  <item> 

				<p>The <code>child</code> axis
				contains the children of the context
				node, which are the nodes returned by
				the <code>dm:children</code> accessor
				in <bibref ref="xpath-datamodel-11"/>. </p>

                                                   <note>

                                                  <p>Only document
                                                  nodes and element
                                                  nodes have
                                                  children. If the
                                                  context node is any
                                                  other kind of node,
                                                  or if the context
                                                  node is an empty
                                                  document or element
                                                  node, then the child
                                                  axis is an empty
                                                  sequence.  The
                                                  children of a
                                                  document node or
                                                  element node may be
                                                  element, processing
                                                  instruction,
                                                  comment, or text
                                                  nodes.  Attribute and
                                                  document nodes can
                                                  never appear as
                                                  children.</p>
                </note>

			 </item> 

  <item> <p>the <code>descendant</code>
			 axis is defined as the transitive closure of
			 the child axis; it contains the descendants
			 of the context node (the children, the children of the children, and so on)</p>

			 </item> 

                                       

  <item> 

                                          <p>the <code>parent</code>
                                          axis contains the sequence
                                          returned by the
                                          <code>dm:parent</code>
                                          accessor in <bibref ref="xpath-datamodel-11"/>, which returns
                                          the parent of the context
                                          node, or an empty sequence
                                          if the context node has no
                                          parent</p>

			 <note>
                  <p>An attribute node may have an element node as its parent, even though the attribute node is not a child of the element node.</p>
                </note>
              </item> 

                                        

  <item> <p>the
                                        <code>ancestor</code> axis is
                                        defined as the transitive
                                        closure of the parent axis; it
                                        contains the ancestors of the
                                        context node (the parent, the
                                        parent of the parent, and so
                                        on)</p>

                                        <note>
                  <p>The ancestor axis
                                        includes the root node of the
                                        tree in which the context node
                                        is found, unless the context
                                        node is the root node.</p>
                </note>

			 </item> 

			 

  <item> <p>the <code>following-sibling</code>
			 axis contains the context node's following
			 siblings, those children of the context
			 node's parent that occur after the context
			 node in <termref def="dt-document-order">document order</termref>; if the context node
			 is an attribute  node, the
			 <code>following-sibling</code> axis is
			 empty</p>
                                                   </item>

			 

  <item> <p>the <code>preceding-sibling</code>
			 axis contains the context node's preceding
			 siblings, those children of the context
			 node's parent that occur before the context
			 node in <termref def="dt-document-order">document order</termref>; if the context node
			 is an attribute  node, the
			 <code>preceding-sibling</code> axis is
			 empty</p> </item>

			 

  <item> 

				<p>the <code>following</code> axis
				contains all nodes that are
				descendants of the root of the tree in
				which the context node is found, are
				not descendants of the context node,
				and occur after the context node in
				<termref def="dt-document-order">document order</termref>
                </p>

			 </item> 

			 

  <item> 

				<p>the <code>preceding</code> axis
				contains all nodes that are
				descendants of the root of the tree in
				which the context node is found, are
				not ancestors of the context node, and
				occur before the context node in
				<termref def="dt-document-order">document order</termref>
                </p>

			 </item> 

			 

  <item> <p>the <code>attribute</code> axis
			 contains the attributes of the context node,
			 which are the nodes returned by the
			 <code>dm:attributes</code> accessor in
			 <bibref ref="xpath-datamodel-11"/>; the axis will be
			 empty unless the context node is an
			 element</p>

			 </item> 
			  
			 

  <item> 
				<p>the <code>self</code> axis contains just the context node itself</p> 
			 </item> 
			 

  <item> 
				<p>the <code>descendant-or-self</code> axis contains the context node and the descendants of the context
				node</p> 
			 </item> 
			 

  <item> 
				<p>the <code>ancestor-or-self</code> axis contains the context node and the ancestors of the context node;
				thus, the ancestor-or-self axis will always include the root node</p> 
			 </item> 

		  

  </ulist> 
		  <p>Axes can be categorized as <term>forward axes</term> and
		  <term>reverse axes</term>. An axis that only ever contains the context node or
		  nodes that are after the context node in <termref def="dt-document-order">document order</termref> is a forward axis. An
		  axis that only ever contains the context node or nodes that are before the
		  context node in <termref def="dt-document-order">document order</termref> is a reverse axis.</p> 
		  <p>The <code>parent</code>, <code>ancestor</code>, <code>ancestor-or-self</code>, <code>preceding</code>, and <code>preceding-sibling</code> axes are reverse axes; all other axes are forward axes. The <code>ancestor</code>, <code>descendant</code>, <code>following</code>, <code>preceding</code> and <code>self</code> axes partition a document (ignoring attribute  nodes):
		  they do not overlap and together they contain all the nodes in the
		  document.</p> 
		   
		<p>
              <termdef id="dt-principal-node-kind" term="principal node kind">Every axis has a <term>principal node kind</term>. If an axis can
		  contain elements, then the principal node kind is element; otherwise, it is the
		  kind of nodes that the axis can contain.</termdef> Thus:</p> 
		  
<ulist> 
			 

  <item> 
				<p>For the attribute axis, the principal node kind is
				attribute.</p> 
			 </item> 
			 

   
			 

  <item> 
				<p>For all other axes, the principal node kind is element.</p> 
			 </item> 
		  </ulist>

		</div4> 
		<div4 id="node-tests"> 
		  <head>Node Tests</head> 
		  <p>
              <termdef id="dt-node-test" term="node test">A <term>node test</term> is a condition that must
		  be true for each node selected by a <termref def="dt-step">step</termref>.</termdef> The
		  condition may be based on the kind of the node
		  (element, attribute, text, document, comment,
		  or processing instruction), the name of
		  the node, or (in the case of element, attribute, and document
		  nodes), the <termref def="dt-type-annotation">type annotation</termref> of the node.</p>
		  <scrap headstyle="show"> 
			 <head/> <prod num="118" id="doc-xquery11-NodeTest">
                <lhs>NodeTest</lhs>
                <rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-KindTest" xlink:type="simple">KindTest</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-NameTest" xlink:type="simple">NameTest</nt>
                </rhs>
              </prod> 
				<prod num="119" id="doc-xquery11-NameTest">
                <lhs>NameTest</lhs>
                <rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-EQName" xlink:type="simple">EQName</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Wildcard" xlink:type="simple">Wildcard</nt>
                </rhs>
              </prod> 
				<prod num="120" id="doc-xquery11-Wildcard">
                <lhs>Wildcard</lhs>
                <rhs>"*"<br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-NCName" xlink:type="simple">NCName</nt>  ":"  "*")<br/>|  ("*"  ":"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-NCName" xlink:type="simple">NCName</nt>)</rhs>
              </prod> 
				 
		  </scrap> 
		   
		  <p>
              <termdef id="dt-name-test" term="name test">A node test that consists only of a EQName or a
		  Wildcard is called a <term>name test</term>.</termdef> A name
		  test is true if and only if the <term>kind</term> of
		  the node is the <termref def="dt-principal-node-kind">principal node kind</termref> for the step axis and the
		  <termref def="dt-expanded-qname">expanded QName</termref> of the node is equal (as defined by the <code>eq</code> operator) to the
		  <termref def="dt-expanded-qname">expanded QName</termref> specified by the name test. For
		  example, <code role="parse-test">child::para</code>
		  selects the <code>para</code> element children of
		  the context node; if the context node has no
		  <code>para</code> children, it selects an empty set
		  of nodes. <code role="parse-test">attribute::abc:href</code> selects
		  the attribute of the context node with the QName
		  <code>abc:href</code>; if the context node has no
		  such attribute, it selects an empty set of
		  nodes.</p>
		  <p>If the EQName is a <termref def="dt-qname">lexical QName</termref>, it is resolved into an <termref def="dt-expanded-qname">expanded QName</termref> using the
		  <termref def="dt-static-namespaces">statically known namespaces</termref> in the expression
		  context. It is a <termref def="dt-static-error">static error</termref> <errorref class="ST" code="0081"/> if the QName has a prefix that does not
		  correspond to any statically known namespace. An unprefixed QName, when used as a
		  name test on an axis whose <termref def="dt-principal-node-kind">principal node kind</termref> is
		  element, has the namespace URI of the <termref def="dt-def-elemtype-ns">default element/type namespace</termref> in
		  the expression context; otherwise, it has no namespace URI. </p>
            <p>A name test is not satisfied by an element node whose name does not match the <termref def="dt-expanded-qname">expanded QName</termref> of the name test, even if it is in a <termref def="dt-substitution-group">substitution group</termref> whose head is the named element.</p> 
		  <p>A node test <code>*</code> is true for any node of the <termref def="dt-principal-node-kind">principal node kind</termref> of the step axis. For example, <code role="parse-test">child::*</code> will select all element children of the context node, and <code role="parse-test">attribute::*</code> will select all attributes of the context node.</p> 
		  <p>A node test can have the form
		  <code role="parse-test">NCName:*</code>. In this case, the prefix is
		  expanded in the same way as with a <termref def="dt-qname">lexical QName</termref>, using the
		  <termref def="dt-static-namespaces">statically known
		  namespaces</termref> in the <termref def="dt-static-context">static context</termref>. If
		  the prefix is not found in the statically known namespaces,
		  a <termref def="dt-static-error">static
		  error</termref> is raised <errorref class="ST" code="0081"/>.
		  The node test is true for any node of the <termref def="dt-principal-node-kind">principal
		  node kind</termref> of the step axis whose <termref def="dt-expanded-qname">expanded QName</termref> has the namespace URI
		  to which the prefix is bound, regardless of the
		  local part of the name.</p> <p>A node test can also
		  have the form <code role="parse-test">*:NCName</code>. In this case,
		  the node test is true for any node of the <termref def="dt-principal-node-kind">principal
		  node kind</termref> of the step axis whose local name matches the given NCName,
		  regardless of its namespace or lack of a namespace.</p> <p>
              <termdef term="kind test" id="dt-kind-test">An alternative
		  form of a node test called a
		  <term>kind test</term> can select nodes based
		  on their kind, name, and <termref def="dt-type-annotation">type annotation</termref>.</termdef> The syntax
		  and semantics of a kind test are described in
		  <specref ref="id-sequencetype-syntax"/> and <specref ref="id-sequencetype-matching"/>. When a kind test is used
		  in a <termref def="dt-node-test">node test</termref>, only those nodes on the designated
		  axis that match the kind test are selected. Shown
		  below are several examples of kind tests that might
		  be used in path
		  expressions:</p>
<ulist>

  <item>
                <p>
                  <code role="parse-test">node()</code>
		  matches any
		  node.</p>
              </item>

  <item>
                <p>
                  <code role="parse-test">text()</code> matches
		  any text
		  node.</p>
              </item>

  <item>
                <p>
                  <code role="parse-test">comment()</code>
		  matches any comment
		  node.</p>
              </item>
                  

  <item>
                <p>
                  <code role="parse-test">namespace-node()</code> matches any
		  namespace node.</p>
              </item>

		  

  <item>
                <p>
                  <code role="parse-test">element()</code>
		  matches any element
		  node.</p>
              </item>

  <item>
                <p>
                  <code role="parse-test">schema-element(person)</code>
		  matches any element node whose name is
		  <code>person</code> (or is in the <termref def="dt-substitution-group">substitution group</termref>
		  headed by <code>person</code>), and whose type
		  annotation is the same as (or is derived from) the declared type of the <code>person</code>
		  element in the <termref def="dt-is-elems">in-scope element declarations</termref>.</p>
              </item>

  <item>
                <p>
                  <code role="parse-test">element(person)</code> matches any element node whose name is
		  <code>person</code>, regardless of its type annotation.</p>
              </item>

  <item>
                <p>
                  <code role="parse-test">element(person, surgeon)</code> matches any non-nilled element node whose name
		  is <code>person</code>, and whose type
		  annotation is
		  <code>surgeon</code> or is derived from <code>surgeon</code>.</p>
              </item>

  <item>
                <p>
                  <code role="parse-test">element(*,
		  surgeon)</code> matches any non-nilled element node whose type
		  annotation is <code>surgeon</code> (or is derived from <code>surgeon</code>), regardless of
		  its
		  name.</p>
              </item>

                  
                  

  <item>
                <p>
                  <code role="parse-test">attribute()</code> matches any
                  attribute node.</p>
              </item>

                  

  <item>
                <p>
                  <code role="parse-test">attribute(price)</code> matches
                  any attribute whose name is <code>price</code>,
                  regardless of its type annotation.</p>
              </item>

  <item>
                <p>
                  <code role="parse-test">attribute(*,
                  xs:decimal)</code> matches any attribute whose type
                  annotation is <code>xs:decimal</code> (or is derived from <code>xs:decimal</code>), regardless of
                  its
                  name.</p>
              </item>

  <item>
                <p>
                  <code role="parse-test">document-node()</code>
                  matches any document
                  node.</p>
		  </item>

  <item>
                <p>
                  <code role="parse-test">document-node(element(book))</code>
                  matches any document node whose content consists of
                  a single element node that satisfies the <termref def="dt-kind-test">kind test</termref>
                  <code role="parse-test">element(book)</code>, interleaved with zero or more
                  comments and processing
                  instructions.</p>
              </item>

		</ulist>
          </div4> </div3>
	  
  <div3 id="id-predicate"> 
	 <head>Predicates within Steps</head> 
	  
	 <scrap headstyle="show"> 
		 <head/>  
     <prod num="111" id="doc-xquery11-AxisStep">
              <lhs>AxisStep</lhs>
              <rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ReverseStep" xlink:type="simple">ReverseStep</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ForwardStep" xlink:type="simple">ForwardStep</nt>)  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-PredicateList" xlink:type="simple">PredicateList</nt>
              </rhs>
            </prod>
	   <prod num="123" id="doc-xquery11-PredicateList">
              <lhs>PredicateList</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Predicate" xlink:type="simple">Predicate</nt>*</rhs>
            </prod>
	   <prod num="124" id="noid_N13208.doc-xquery11-Predicate">
              <lhs>Predicate</lhs>
              <rhs>"["  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Expr" xlink:type="simple">Expr</nt>  "]"</rhs>
            </prod>
   </scrap> 
	 <p id="dt-predicate">A predicate within a Step has similar syntax and semantics
	 to a predicate within a <termref def="id-filter-expression">filter expression</termref>.  The
	 only difference is in the way the context position is set for
	 evaluation of the predicate.</p>

	 <p>For the purpose of evaluating the context position within
	 a predicate, the input sequence is considered to be sorted as
	 follows: into document order if the predicate is in a
	 forward-axis step, into reverse document order if the
	 predicate is in a reverse-axis step, or in its original order
	 if the predicate is not in a step.</p>
	 
		<p>Here are some examples of <termref def="dt-axis-step">axis steps</termref> that contain predicates:</p> 
		
<ulist> 
		  

  <item> 
			 <p>This example selects the second <code>chapter</code> element that is a child
			 of the context node:</p> 
			 <eg role="parse-test" xml:space="preserve">child::chapter[2]</eg> 
		</item> 
		

  <item> 
		  <p>This example selects all the descendants of the
		  context node that are elements named
		  <code>"toy"</code> and whose <code>color</code>
		  attribute has the value <code>"red"</code>:</p>
		  <eg role="parse-test" xml:space="preserve">descendant::toy[attribute::color = "red"]</eg> 
	 </item> 
	 

  <item> 
		<p>This example selects all the <code>employee</code> children of the context node
		that have both a <code>secretary</code> child element and an <code>assistant</code> child element:</p> 
		<eg role="parse-test" xml:space="preserve">child::employee[secretary][assistant]</eg> 
  </item> 
</ulist> 




 
 
<note>
            <p>When using <termref def="dt-predicate">predicates</termref> with a sequence of nodes selected using a
<term>reverse axis</term>, it is important to remember that the the
context positions for such a sequence are assigned in <termref def="dt-reverse-document-order">reverse
document order</termref>. For example, <code role="parse-test">preceding::foo[1]</code>
returns the first qualifying <code>foo</code> element in <termref def="dt-reverse-document-order">reverse document order</termref>, because the predicate is part of an <termref def="dt-axis-step">axis step</termref> using a reverse axis. By
contrast, <code role="parse-test">(preceding::foo)[1]</code> returns the first qualifying <code>foo</code>
element in <termref def="dt-document-order">document order</termref>, because the parentheses cause  <code role="parse-test">(preceding::foo)</code> to be parsed as a <termref def="dt-primary-expression">primary expression</termref> in which context positions are assigned in document order. Similarly, <code role="parse-test">ancestor::*[1]</code>
returns the nearest ancestor element, because the <code>ancestor</code> axis is a
reverse axis, whereas <code role="parse-test">(ancestor::*)[1]</code> returns the root element (first ancestor in document order).</p>
            <p>The fact that a reverse-axis step assigns context positions in reverse 
document order for the purpose of evaluating predicates does not alter the 
fact that the final result of the step <phrase role="xquery">(when in ordered mode) </phrase> is always in document order.</p>
          </note>
        </div3> 
<div3 id="unabbrev"> 
<head>Unabbreviated Syntax</head> 
<p>This section provides a number of examples of path expressions in which the
axis is explicitly specified in each <termref def="dt-step">step</termref>. The syntax used in these examples is
called the <term>unabbreviated syntax</term>. In many common cases, it is
possible to write path expressions more concisely using an <term>abbreviated
syntax</term>, as explained in <specref ref="abbrev"/>.</p> 

<ulist> 


  <item> 
<p> <code role="parse-test">child::para</code> selects 
the <code>para</code> element children of the context node</p> 
</item> 


  <item> 
<p> <code role="parse-test">child::*</code> selects all element children of the context node</p> 
</item> 


  <item> 
<p> <code role="parse-test">child::text()</code> selects all text node children of the context node</p> 
</item> 


  <item> 
<p> <code role="parse-test">child::node()</code> selects all the children of the context node. Note that no attribute nodes are returned, because attributes are not children.</p> 
</item> 


  <item> 
<p> <code role="parse-test">attribute::name</code> selects the <code>name</code> attribute of the context node</p> 
</item> 


  <item> 
<p> <code role="parse-test">attribute::*</code> selects all the attributes of the context node</p> 
</item>

  <item>
              <p>
                <code role="parse-test">parent::node()</code> selects the parent of the context node. If the context node is an attribute node, this expression returns the element node (if any) to which the attribute node is attached.</p>
            </item> 


  <item> 
<p> <code role="parse-test">descendant::para</code> selects the <code>para</code> element descendants of the context node</p> 
</item> 


  <item> 
<p> <code role="parse-test">ancestor::div</code> selects all <code>div</code> ancestors of the context node</p> 
</item> 


  <item> 
<p> <code role="parse-test">ancestor-or-self::div</code> selects the <code>div</code> ancestors of the context node and, if the context node is a <code>div</code> element, the context node as well</p> 
</item> 


  <item> 
<p> <code role="parse-test">descendant-or-self::para</code> selects the <code>para</code> element descendants of the context node and, if the context node is a <code>para</code> element, the context node as well</p> 
</item> 


  <item> 
<p> <code role="parse-test">self::para</code> selects the context node if it is a <code>para</code> element, and otherwise returns an empty sequence</p> 
</item> 


  <item> 
<p> <code role="parse-test">child::chapter/descendant::para</code> selects the <code>para</code> element 
descendants of the <code>chapter</code> element children of the context node</p> 
</item> 


  <item> 
<p> <code role="parse-test">child::*/child::para</code> selects all <code>para</code> grandchildren of the context node</p> 
</item> 


  <item> 
<p> <code role="parse-test">/</code> selects the root of the tree that contains the context node, but raises a dynamic error if this root is not a document node</p> 
</item> 


  <item> 
<p> <code role="parse-test">/descendant::para</code> selects all the <code>para</code> elements in the same document as the context node</p> 
</item> 


  <item> 
<p> <code role="parse-test">/descendant::list/child::member</code> selects all 
the <code>member</code> elements that have a <code>list</code> parent and that are in the same document as the context node</p> 
 
</item> 


  <item> 
<p> <code role="parse-test">child::para[fn:position() = 1]</code> selects the first <code>para</code> child of the context node</p> 
</item> 


  <item> 
<p> <code role="parse-test">child::para[fn:position() = fn:last()]</code> selects the last <code>para</code> child of the context node</p> 
</item> 


  <item> 
<p> <code role="parse-test">child::para[fn:position() = fn:last()-1]</code> selects the last but one <code>para</code> child of the context node</p> 
</item> 


  <item> 
<p> <code role="parse-test">child::para[fn:position() &gt; 1]</code> selects all the <code>para</code> children of the context node other than the first <code>para</code> child of the context node</p> 
</item> 


  <item> 
<p> <code role="parse-test">following-sibling::chapter[fn:position() = 1]</code> selects the next <code>chapter</code> sibling of the context node</p> 
</item> 


  <item> 
<p> <code role="parse-test">preceding-sibling::chapter[fn:position() = 1]</code> selects the previous <code>chapter</code> sibling of the context node</p> 
</item> 


  <item> 
<p> <code role="parse-test">/descendant::figure[fn:position() = 42]</code> selects the forty-second <code>figure</code> element in the document containing the context node</p> 
</item> 


  <item> 
<p> <code role="parse-test">/child::book/child::chapter[fn:position() = 5]/child::section[fn:position() = 2]</code> selects the 
second <code>section</code> of the fifth <code>chapter</code> of the <code>book</code> whose parent is the document node that contains the context node</p> 
</item> 


  <item> 
<p> <code role="parse-test">child::para[attribute::type eq "warning"]</code> selects 
all <code>para</code> children of the context node that have a <code>type</code> attribute with value <code>warning</code> </p> 
</item> 


  <item> 
<p> <code role="parse-test">child::para[attribute::type eq 'warning'][fn:position() = 5]</code> selects the fifth <code>para</code> child of the context node that has a <code>type</code> attribute with value <code>warning</code> </p> 
</item> 


  <item> 
<p> <code role="parse-test">child::para[fn:position() = 5][attribute::type eq "warning"]</code> selects the fifth <code>para</code> child of the context node if that child has a <code>type</code> attribute with value <code>warning</code> </p> 
</item> 



  <item> 
<p> <code role="parse-test">child::chapter[child::title = 'Introduction']</code> selects
the <code>chapter</code> children of the context node that have one or
more <code>title</code> children whose <termref def="dt-typed-value">typed value</termref> is equal to the
string <code>Introduction</code> </p>
</item> 



  <item> 
<p> <code role="parse-test">child::chapter[child::title]</code> selects the <code>chapter</code> children of the context node that have one or more <code>title</code> children</p> 
</item> 


  <item> 
<p> <code role="parse-test">child::*[self::chapter or self::appendix]</code> 
selects the <code>chapter</code> and <code>appendix</code> children of the context node</p> 
</item> 


  <item> 
<p> <code role="parse-test">child::*[self::chapter or
self::appendix][fn:position() = fn:last()]</code> selects the 
last <code>chapter</code> or <code>appendix</code> child of the context node</p> 
</item> 
</ulist> 
</div3> 
<div3 id="abbrev"> 
<head>Abbreviated Syntax</head> 
<scrap headstyle="show"> 
<head/> <prod num="114" id="doc-xquery11-AbbrevForwardStep">
              <lhs>AbbrevForwardStep</lhs>
              <rhs>"@"?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-NodeTest" xlink:type="simple">NodeTest</nt>
              </rhs>
            </prod> 
<prod num="117" id="doc-xquery11-AbbrevReverseStep">
              <lhs>AbbrevReverseStep</lhs>
              <rhs>".."</rhs>
            </prod>
</scrap> 
<p>The abbreviated syntax permits the following abbreviations:</p> 


<olist> 


  <item> 
    <p>The attribute axis <code>attribute::</code> can be 
    abbreviated by <code>@</code>. For example, a path expression <code role="parse-test">para[@type="warning"]</code> is short 
    for <code role="parse-test">child::para[attribute::type="warning"]</code> and 
    so selects <code>para</code> children with a <code>type</code> attribute with value 
    equal to <code>warning</code>.</p> 
  </item>

  <item> 
    <p>If the axis name is omitted from an <termref def="dt-axis-step">axis step</termref>, the default axis is
    <code>child</code>, with two exceptions: 

    if the axis step contains an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AttributeTest" xlink:type="simple">AttributeTest</nt> or <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SchemaAttributeTest" xlink:type="simple">SchemaAttributeTest</nt> then the
    default axis is <code>attribute</code>;

    if the axis step contains <code>namespace-node()</code> then the default axis is <code>namespace</code>.

    <note>
                  <p>In an implementation that does not support the namespace
    axis, an attempt to access it it always raises an error. Thus, an
    XQuery implementation will always raise an error in this case,
    since XQuery does not support the namespace axis. The namespace
    axis is deprecated in XPath 2.1, but required in some languages
    that use XPath, including XSLT.</p>
                </note>

    For example, the path expression <code role="parse-test">section/para</code> is an abbreviation for <code role="parse-test">child::section/child::para</code>, and the path
    expression <code role="parse-test">section/@id</code> is an
    abbreviation for <code role="parse-test">child::section/attribute::id</code>.  Similarly,
    <code role="parse-test">section/attribute(id)</code> is an
    abbreviation for <code role="parse-test">child::section/attribute::attribute(id)</code>. Note
    that the latter expression contains both an axis specification and
    a <termref def="dt-node-test">node test</termref>.</p>
  </item> 


  <item> 
<p> Each non-initial occurrence of <code>//</code> is effectively replaced by  <code>/descendant-or-self::node()/</code> during processing of a path expression. For example, <code role="parse-test">div1//para</code> is 
short for <code role="parse-test">child::div1/descendant-or-self::node()/child::para</code> and so will select all <code>para</code> descendants of <code>div1</code> children.</p> 
<note>
                <p>The path expression <code role="parse-test">//para[1]</code> does <emph>not</emph> mean the same as the path 
expression <code role="parse-test">/descendant::para[1]</code>. The latter selects the first descendant <code>para</code> element; the former 
selects all descendant <code>para</code> elements that are the first <code>para</code> children of their respective parents.</p>
              </note> 
</item> 


  <item> 
<p>A step consisting 
of <code role="parse-test">..</code> is short 
for <code role="parse-test">parent::node()</code>. For example, <code role="parse-test">../title</code> is short for <code role="parse-test">parent::node()/child::title</code> and so will select the <code>title</code> children of the parent of the context node.</p> 
<note>
   <p>The expression <code>.</code>, known as a <term>context item
   expression</term>, is a <termref def="dt-primary-expression">primary expression</termref>,
   and is described in <specref ref="id-context-item-expression"/>.</p>
</note>
            </item> 
</olist>



<p>Here are some examples of path expressions that use the abbreviated
syntax:</p> 

<ulist> 


  <item> 
<p> <code>para</code> selects the <code>para</code> element children of the context node</p> 
</item> 


  <item> 
<p> <code role="parse-test">*</code> selects all element children of the context node</p> 
</item> 


  <item> 
<p> <code role="parse-test">text()</code> selects all text node children of the context node</p> 
</item> 


  <item> 
<p> <code role="parse-test">@name</code> selects 
the <code>name</code> attribute of the context node</p> 
</item> 


  <item> 
<p> <code role="parse-test">@*</code> selects all the attributes of the context node</p> 
</item> 


  <item> 
<p> <code role="parse-test">para[1]</code> selects the first <code>para</code> child of the context node</p> 
</item> 


  <item> 
<p> <code role="parse-test">para[fn:last()]</code> selects the last <code>para</code> child of the context node</p> 
</item> 


  <item> 
<p> <code role="parse-test">*/para</code> selects 
all <code>para</code> grandchildren of the context node</p> 
</item> 


  <item> 
<p> <code role="parse-test">/book/chapter[5]/section[2]</code> selects the 
second <code>section</code> of the fifth <code>chapter</code> of the <code>book</code> whose parent is the document node that contains the context node</p> 
</item> 


  <item> 
<p> <code role="parse-test">chapter//para</code> selects the <code>para</code> element descendants of the <code>chapter</code> element children of the context node</p> 
</item> 


  <item> 
<p> <code role="parse-test">//para</code> selects all 
the <code>para</code> descendants of the root document node and thus selects all <code>para</code> elements in the same document as the context node</p> 
</item>

  <item>
              <p>
                <code role="parse-test">//@version</code> selects all the <code>version</code> attribute nodes that are in the same document as the context node</p>
            </item> 


  <item> 
<p> <code role="parse-test">//list/member</code> selects all the <code>member</code> elements in the same document as the context node that have a <code>list</code> parent</p> 
 
</item> 
 


  <item> 
<p> <code role="parse-test">.//para</code> selects 
the <code>para</code> element descendants of the context node</p> 
</item> 


  <item> 
<p> <code role="parse-test">..</code> selects the parent of the context node</p> 
</item> 


  <item> 
<p> <code role="parse-test">../@lang</code> selects 
the <code>lang</code> attribute of the parent of the context node</p> 
</item> 


  <item> 
<p> <code role="parse-test">para[@type="warning"]</code> selects all <code>para</code> children of the context node that have a <code>type</code> attribute with value <code>warning</code> </p> 
</item> 


  <item> 
<p> <code role="parse-test">para[@type="warning"][5]</code> selects the fifth <code>para</code> child of the context node that has a <code>type</code> attribute with value <code>warning</code> </p> 
</item> 


  <item> 
<p> <code role="parse-test">para[5][@type="warning"]</code> selects the fifth <code>para</code> child of the context node if that child has a <code>type</code> attribute with value <code>warning</code> </p> 
</item> 


  <item> 
<p> <code role="parse-test">chapter[title="Introduction"]</code> selects the <code>chapter</code> children of the context node that have one 
or more <code>title</code> children whose <termref def="dt-typed-value">typed value</termref> is equal to the string <code>Introduction</code> </p> 
</item> 


  <item> 
<p> <code role="parse-test">chapter[title]</code> selects the <code>chapter</code> children of the context node that have one or more <code>title</code> children</p> 
</item> 


  <item> 
<p> <code role="parse-test">employee[@secretary and @assistant]</code> selects all 
the <code>employee</code> children of the context node that have both a <code>secretary</code> attribute and 
an <code>assistant</code> attribute</p> 
</item> 


  <item> 
<p> <code role="parse-test">book/(chapter|appendix)/section</code> selects 
every <code>section</code> element that has a parent that is either a <code>chapter</code> or an <code>appendix</code> element, that in turn is a child of a <code>book</code> element that is a child of the context node.</p> 
</item> 


  <item>
              <p>If <code>E</code> is any expression that returns a sequence of nodes, then the expression <code role="parse-test">E/.</code> returns the same nodes in <termref def="dt-document-order">document order</termref>, with duplicates eliminated based on node identity.</p>
            </item> 
</ulist> 
</div3>	
</div2>	
<div2 id="id-sequence-expressions"> 
<head>Sequence Expressions</head> 
<p>XQuery 1.1 supports operators to construct, filter,  and combine
<termref def="dt-sequence">sequences</termref> of <termref def="dt-item">items</termref>.
Sequences are never nested—for
example, combining the values <code>1</code>, <code>(2, 3)</code>, and <code>( )</code> into a single sequence results
in the sequence <code>(1, 2, 3)</code>.</p> 
<div3 id="construct_seq"> 
<head>Constructing Sequences</head> 
<scrap headstyle="show"> 
<head/>  
<prod num="39" id="noid_N136E5.doc-xquery11-Expr">
              <lhs>Expr</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>)*</rhs>
            </prod> 
<prod num="89" id="doc-xquery11-RangeExpr">
              <lhs>RangeExpr</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AdditiveExpr" xlink:type="simple">AdditiveExpr</nt> ( "to"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AdditiveExpr" xlink:type="simple">AdditiveExpr</nt> )?</rhs>
            </prod> 
</scrap> 
<p>
            <termdef term="comma operator" id="dt-comma-operator">One way to construct a sequence is by using the <term>comma operator</term>, which evaluates each of its operands and concatenates the resulting sequences, in order, into a single result sequence.</termdef> Empty parentheses can be used to denote an empty sequence.</p>
          <p>A sequence may contain duplicate
atomic values or nodes, but a sequence is never an item in another sequence. When a
new sequence is created by concatenating two or more input sequences, the new
sequence contains all the items of the input sequences and its length is the
sum of the lengths of the input sequences.</p> 
<note>
            <p>In places where the grammar calls for <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>, such as the arguments of a function call, any expression that contains a top-level comma operator must be enclosed in parentheses.</p>
          </note>
          <p>Here are some examples of expressions that construct sequences:
</p>

<ulist> 


  <item> 
<p>The result of this expression is a sequence of five integers:</p> 
<eg role="parse-test" xml:space="preserve">(10, 1, 2, 3, 4)</eg> 
</item> 


  <item> 
<p>This expression combines four sequences of length one, two, zero, and two, respectively, into a single sequence of length five. The result of this expression is the sequence <code>10, 1, 2, 3, 4</code>.</p> 
<eg role="parse-test" xml:space="preserve">(10, (1, 2), (), (3, 4))</eg> 
 
 
</item> 


  <item> 
<p>The result of this expression is a sequence containing 
all <code>salary</code> children of the context node followed by all <code>bonus</code> children.</p> 
<eg role="parse-test" xml:space="preserve">(salary, bonus)</eg> 
</item> 


  <item> 
<p>Assuming that <code>$price</code> is bound to 
the value <code>10.50</code>, the result of this expression is the sequence <code>10.50, 10.50</code>.</p> 
<eg role="parse-test" xml:space="preserve">($price, $price)</eg> 
 
 
</item> 
</ulist> 
<p>A <term>range expression</term> can be used to construct a sequence of consecutive
integers. Each of the operands of the <code>to</code> operator is
converted as though it was an argument of a function with the expected
parameter type <code>xs:integer?</code>.
If either operand is an empty sequence, or if the integer derived from the first operand is greater than the integer derived from the second operand, the result of the range expression is an empty sequence. If the two operands convert to the same integer, the result of the range expression is that integer. Otherwise, the result is a sequence containing the two integer operands and
every integer between the two operands, in increasing order. </p> 

<ulist> 


  <item> 
<p>This example uses a range expression as one operand in constructing a sequence. It evaluates to the sequence <code>10, 1, 2, 3, 4</code>.</p> 
<eg role="parse-test" xml:space="preserve">(10, 1 to 4)</eg> 
 
</item>

  <item>
              <p>This example constructs a sequence of length one containing the single integer <code>10</code>.</p>
              <eg role="parse-test" xml:space="preserve">10 to 10</eg>
            </item>

  <item>
              <p>The result of this example is a sequence of length zero.</p>
              <eg role="parse-test" xml:space="preserve">15 to 10</eg>
            </item>

  <item>
              <p>This example uses the <code>fn:reverse</code> function to construct a sequence of six integers in decreasing order. It evaluates to the sequence <code>15, 14, 13, 12, 11, 10</code>.</p>
              <eg role="parse-test" xml:space="preserve">fn:reverse(10 to 15)</eg>
            </item> 
</ulist> 
</div3> 


<div3 id="combining_seq"> 
<head>Combining Node Sequences</head> 
<scrap headstyle="show"> 
<head/> <prod num="92" id="doc-xquery11-UnionExpr">
              <lhs>UnionExpr</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-IntersectExceptExpr" xlink:type="simple">IntersectExceptExpr</nt> ( ("union"  |  "|")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-IntersectExceptExpr" xlink:type="simple">IntersectExceptExpr</nt> )*</rhs>
            </prod> 
<prod num="93" id="doc-xquery11-IntersectExceptExpr">
              <lhs>IntersectExceptExpr</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-InstanceofExpr" xlink:type="simple">InstanceofExpr</nt> ( ("intersect"  |  "except")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-InstanceofExpr" xlink:type="simple">InstanceofExpr</nt> )*</rhs>
            </prod> 
</scrap> 
<p>XQuery 1.1 provides the following operators for combining sequences of
nodes:</p>
<ulist>

  <item>
              <p>The <code>union</code> and <code>|</code> operators are equivalent. They take two node sequences as operands and
return a sequence containing all the nodes that occur in either of the
operands.</p>
            </item>

  <item>
              <p>The <code>intersect</code> operator takes two node sequences as operands and returns a sequence
containing all the nodes that occur in both operands.</p>
            </item>

  <item>
              <p>The <code>except</code> operator takes two node sequences as operands and returns a sequence
containing all the nodes that occur in the first operand but not in the second
operand.</p>
            </item>
          </ulist>
          <p>   
 All these operators eliminate duplicate nodes from their result sequences based on node identity. <phrase role="xquery">If <termref def="dt-ordering-mode">ordering mode</termref> is <code>ordered</code>, the resulting sequence is returned in <termref def="dt-document-order">document
	 order</termref>; otherwise it is returned in <termref def="dt-implementation-dependent">implementation-dependent</termref> order.</phrase>
          </p>
          <p>If an operand 
of <code>union</code>, <code>intersect</code>, or <code>except</code> contains an item that is not a node, a <termref def="dt-type-error">type error</termref> is raised <errorref class="TY" code="0004"/>.</p> 

<p>
If an IntersectExceptExpr contains more than two InstanceofExprs,
they are grouped from left to right.
With a UnionExpr, it makes no difference how operands are grouped,
the results are the same.
</p>

<p>Here are some examples of expressions that combine sequences. Assume the existence of three element nodes that we will refer to by symbolic names A, B, and C. Assume that the variables <code>$seq1</code>,  <code>$seq2</code>  and <code>$seq3</code> are bound to the following sequences of these nodes:</p>
<ulist>

  <item>
              <p>
                <code>$seq1</code> is bound to (A, B)</p>
            </item>

  <item>
              <p>
                <code>$seq2</code> is bound to (A, B)</p>
            </item>

  <item>
              <p>
                <code>$seq3</code> is bound to (B, C)</p>
            </item>
          </ulist>
          <p>Then: </p> 

<ulist> 


  <item> 
<p> <code role="parse-test">$seq1 union $seq2</code>  evaluates to the sequence (A, B). </p> 
</item> 


  <item> 
<p> <code role="parse-test">$seq2 union $seq3</code>   evaluates to the sequence (A, B, C). </p> 
</item> 


  <item> 
<p> <code role="parse-test">$seq1 intersect $seq2</code>  evaluates to the sequence (A, B). </p> 
</item> 


  <item> 
<p> <code role="parse-test">$seq2 intersect $seq3</code>  evaluates to the sequence containing B only.</p> 
</item> 


  <item> 
<p> <code role="parse-test">$seq1 except $seq2</code>   evaluates to the empty sequence.</p> 
</item> 


  <item> 
<p> <code role="parse-test">$seq2 except $seq3</code>  evaluates to the sequence containing A only.</p> 
</item> 
</ulist> 
<p>In addition to the sequence operators described here, <bibref ref="xpath-functions-11"/> includes functions for indexed access to items or
sub-sequences of a sequence, for indexed insertion or removal of items in a
sequence, and for removing duplicate items from a sequence.</p> 
</div3>	
</div2>
      <div2 id="id-arithmetic"> 
<head>Arithmetic Expressions</head> 
<p>XQuery 1.1 provides arithmetic operators for addition, subtraction,
multiplication, division, and modulus, in their usual binary and unary
forms.</p> 
<scrap headstyle="show"> 
<head/> 
<prod num="90" id="doc-xquery11-AdditiveExpr">
            <lhs>AdditiveExpr</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-MultiplicativeExpr" xlink:type="simple">MultiplicativeExpr</nt> ( ("+"  |  "-")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-MultiplicativeExpr" xlink:type="simple">MultiplicativeExpr</nt> )*</rhs>
          </prod> 
<prod num="91" id="doc-xquery11-MultiplicativeExpr">
            <lhs>MultiplicativeExpr</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-UnionExpr" xlink:type="simple">UnionExpr</nt> ( ("*"  |  "div"  |  "idiv"  |  "mod")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-UnionExpr" xlink:type="simple">UnionExpr</nt> )*</rhs>
          </prod> 
<prod num="98" id="doc-xquery11-UnaryExpr">
            <lhs>UnaryExpr</lhs>
            <rhs>("-"  |  "+")* <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ValueExpr" xlink:type="simple">ValueExpr</nt>
            </rhs>
          </prod> 
<prod num="99" id="doc-xquery11-ValueExpr">
            <lhs>ValueExpr</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ValidateExpr" xlink:type="simple">ValidateExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-PathExpr" xlink:type="simple">PathExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExtensionExpr" xlink:type="simple">ExtensionExpr</nt>
            </rhs>
          </prod>
        </scrap> 
<p>A subtraction operator must be preceded by whitespace if
it could otherwise be interpreted as part of the previous token. For
example, <code role="parse-test">a-b</code> will be interpreted as a
name, but <code role="parse-test">a - b</code> and <code role="parse-test">a -b</code> will be interpreted as arithmetic expressions. (See <specref ref="whitespace-rules"/> for further details on whitespace handling.)</p>

<p>
If an AdditiveExpr contains more than two MultiplicativeExprs, 
they are grouped from left to right. So, for instance,
<eg role="parse-test" xml:space="preserve">A - B + C - D</eg>
is equivalent to
<eg role="parse-test" xml:space="preserve">((A - B) + C) - D</eg>
Similarly, the operands of a MultiplicativeExpr are grouped from left to right.
</p>

<p>The first step in evaluating an arithmetic expression is to evaluate its operands. The order in which the operands are evaluated is <termref def="dt-implementation-dependent">implementation-dependent</termref>.</p>


<p>
          <phrase role="xquery">Each</phrase> operand is evaluated by applying the following steps, in order:</p>

<olist>

  <item>
            <p>
              <termref def="dt-atomization">Atomization</termref> is applied to the operand. The result of this
    operation is called the <term>atomized operand</term>.</p>
          </item>

  <item>
            <p>If the atomized operand is an empty sequence, the result of
    the arithmetic expression is an empty sequence, and the implementation
    need not evaluate the other operand or apply the operator. However,
    an implementation may choose to evaluate the other operand in order
    to determine whether it raises an error.</p>
          </item>

  <item>
            <p> If the atomized operand is a sequence of
length greater than one, a <termref def="dt-type-error">type error</termref> is raised <errorref class="TY" code="0004"/>.</p>
          </item>

  <item>
            <p>If the atomized operand is of type <code>xs:untypedAtomic</code>, it is cast to  <code>xs:double</code>. If
the cast fails, a <termref def="dt-dynamic-error">dynamic
error</termref> is raised. [err:FORG0001]</p>
          </item>
        </olist>
        <p>After evaluation of the operands, if the types of the operands are a valid combination
for the given arithmetic operator, the operator is applied to the operands,
resulting in an atomic value or a <termref def="dt-dynamic-error">dynamic error</termref> (for example, an error
might result from dividing by zero.) The combinations of atomic types
that are accepted by the various arithmetic operators, and their
respective result types, are listed in <specref ref="mapping"/>
together with the <termref def="dt-operator-function">operator functions</termref>
that define the semantics of the operator for each
type combination, including the dynamic errors that can be raised by the operator. The definitions of the operator functions are found in <bibref ref="xpath-functions-11"/>.</p>
        <p>If the types of the operands, after evaluation, are not a valid combination for the given operator, according to the rules in <specref ref="mapping"/>, a <termref def="dt-type-error">type error</termref> is raised <errorref class="TY" code="0004"/>.</p>
<p>XQuery 1.1 supports two division operators named <code>div</code> and <code>idiv</code>. Each of these operators accepts two operands of any <termref def="dt-numeric">numeric</termref> type. As described in <bibref ref="xpath-functions-11"/>, <code role="parse-test">$arg1 idiv $arg2</code> is equivalent to <code role="parse-test">($arg1 div $arg2) cast as xs:integer?</code> except for error cases.</p>
        <p>Here are some examples of arithmetic expressions:</p> 

<ulist> 


  <item> 
<p>The first expression below returns the <code>xs:decimal</code> value <code role="parse-test">-1.5</code>, and the second expression returns the <code>xs:integer</code> value <code role="parse-test">-1</code>:</p> 
<eg role="parse-test" xml:space="preserve">-3 div 2
-3 idiv 2</eg> 
 </item> 


  <item> 
<p>Subtraction of two date values results in a value of type <code>xs:dayTimeDuration</code>:</p> 
<eg role="parse-test" xml:space="preserve">$emp/hiredate - $emp/birthdate</eg> 
</item> 
 


  <item> 
<p>This example illustrates the difference between a subtraction operator and a
hyphen:</p> 
<eg role="parse-test" xml:space="preserve">$unit-price - $unit-discount</eg> 
</item> 


  <item> 
<p>Unary operators have higher precedence than binary operators, subject of
course to the use of parentheses. Therefore, the following two examples have different meanings:</p> 
<eg xml:space="preserve">-$bellcost + $whistlecost
-($bellcost + $whistlecost)</eg> 
</item> 
</ulist>	
<note>
          <p id="note-consecutive-unary-ops">Multiple consecutive unary arithmetic operators are permitted by XQuery 1.1 for compatibility with <bibref ref="xpath"/>.</p>
        </note>
      </div2>	
<div2 id="id-comparisons"> 
<head>Comparison Expressions</head> 
<p>Comparison expressions allow two values to be compared. XQuery 1.1 provides
three kinds of comparison expressions, called value comparisons, general
comparisons, and node comparisons.</p> 
<scrap headstyle="show"> 
<head/> <prod num="88" id="doc-xquery11-ComparisonExpr">
            <lhs>ComparisonExpr</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-RangeExpr" xlink:type="simple">RangeExpr</nt> ( (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ValueComp" xlink:type="simple">ValueComp</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-GeneralComp" xlink:type="simple">GeneralComp</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-NodeComp" xlink:type="simple">NodeComp</nt>)  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-RangeExpr" xlink:type="simple">RangeExpr</nt> )?</rhs>
          </prod>
<prod num="101" id="doc-xquery11-ValueComp">
            <lhs>ValueComp</lhs>
            <rhs>"eq"  |  "ne"  |  "lt"  |  "le"  |  "gt"  |  "ge"</rhs>
          </prod>
          <prod num="100" id="doc-xquery11-GeneralComp">
            <lhs>GeneralComp</lhs>
            <rhs>"="  |  "!="  |  "&lt;"  |  "&lt;="  |  "&gt;"  |  "&gt;="</rhs>
          </prod> 
<prod num="102" id="doc-xquery11-NodeComp">
            <lhs>NodeComp</lhs>
            <rhs>"is"  |  "&lt;&lt;"  |  "&gt;&gt;"</rhs>
          </prod> 
 
</scrap> 




<div3 id="id-value-comparisons"> 
<head>Value Comparisons</head> 
<p>The value comparison operators are <code>eq</code>, <code>ne</code>, <code>lt</code>, <code>le</code>, <code>gt</code>, and <code>ge</code>. Value comparisons are used for comparing single values.</p> 
<p>The first step in evaluating a value comparison is to evaluate its operands. The order in which the operands are evaluated is <termref def="dt-implementation-dependent">implementation-dependent</termref>. Each operand is evaluated by applying the following steps, in order:</p>

<olist>

  <item>
              <p>
                <termref def="dt-atomization">Atomization</termref> is applied to the operand. The result of this
    operation is called the <term>atomized operand</term>.</p>
            </item>

  <item>
              <p>If the atomized operand is an empty sequence, the result of
    the value comparison is an empty sequence, and the implementation
    need not evaluate the other operand or apply the operator. However,
    an implementation may choose to evaluate the other operand in order
    to determine whether it raises an error.</p>
            </item>

  <item>
              <p> If the atomized operand is a sequence of
length greater than one, a <termref def="dt-type-error">type error</termref> is raised <errorref class="TY" code="0004"/>.</p>
            </item>

  <item>
              <p>If the atomized operand is of type <code>xs:untypedAtomic</code>, it is cast to  <code>xs:string</code>.</p>
              <note>
                <p>The purpose of this rule is to make value comparisons transitive. Users should be aware that the general comparison operators have a different rule for casting of <code>xs:untypedAtomic</code> operands. Users should also be aware that transitivity of value comparisons may be compromised by loss of precision during type conversion (for example, two <code>xs:integer</code> values that differ slightly may both be considered equal to the same <code>xs:float</code> value because <code>xs:float</code> has less precision than <code>xs:integer</code>).</p>
              </note>
            </item>
          </olist>
          <p>Next, if possible, the two operands are converted to their least common 
type by a combination of <termref def="dt-type-promotion">type promotion</termref> and <termref def="dt-subtype-substitution">subtype substitution</termref>.  For 
example, if the operands are of type <code>hatsize</code> (derived from <code>xs:integer</code>) and 
<code>shoesize</code> (derived from <code>xs:float</code>), their least common type is <code>xs:float</code>.</p>
          <p>Finally, if the types of the operands are a valid combination for the 
given operator, the operator is applied to the operands. The combinations of atomic types
that are accepted by the various value comparison operators, and their
respective result types, are listed in <specref ref="mapping"/>
together with the <termref def="dt-operator-function">operator functions</termref>
that define the semantics of the operator for each
type combination. The definitions of the operator functions are found in <bibref ref="xpath-functions-11"/>.</p>
          <p>Informally, if both atomized operands consist of exactly one atomic
value, then the result of the comparison is <code>true</code> if the value of the
first operand is (equal, not equal, less than, less than or equal,
greater than, greater than or equal) to the value of the second
operand; otherwise the result of the comparison is <code>false</code>.</p>
          <p>If the types of the operands, after evaluation, are not a valid combination for the given operator, according to the rules in <specref ref="mapping"/>, a <termref def="dt-type-error">type error</termref> is raised <errorref class="TY" code="0004"/>.</p> 
<p>Here are some examples of value comparisons:</p> 

<ulist> 


  <item> 
<p>The following comparison atomizes the node(s) that are returned by the expression <code>$book/author</code>. The comparison is true only if the result of atomization is the value "Kennedy" as an instance of <code>xs:string</code> or <code>xs:untypedAtomic</code>. If the result of atomization is an empty sequence, the result of the comparison is an empty sequence. If the result of atomization is a sequence containing more than one value, a <termref def="dt-type-error">type error</termref> is raised <errorref class="TY" code="0004"/>.</p> 
<eg role="parse-test" xml:space="preserve">$book1/author eq "Kennedy"</eg> 
</item>

  <item>
              <p>The following <termref def="dt-path-expression">path expression</termref> contains a predicate that selects products whose weight is greater than 100. For any product that does not have a <code>weight</code> subelement, the value of the predicate is the empty sequence, and the product is not selected. This example assumes that <code>weight</code> is a validated element with a numeric type.</p>
              <eg role="parse-test" xml:space="preserve">//product[weight gt 100]</eg>
            </item>

  <item role="xquery">
              <p>The following comparisons are true because, in each case, the two constructed nodes have the same value after atomization, even though they have different identities and/or names:</p>
              <eg role="parse-test" xml:space="preserve">&lt;a&gt;5&lt;/a&gt; eq &lt;a&gt;5&lt;/a&gt;</eg>
              <eg role="parse-test" xml:space="preserve">&lt;a&gt;5&lt;/a&gt; eq &lt;b&gt;5&lt;/b&gt;</eg>
            </item>

  <item>
              <p>The following comparison is true if <code>my:hatsize</code> and <code>my:shoesize</code> are both user-defined types that are derived by restriction from a primitive <termref def="dt-numeric">numeric</termref> type:</p>
              <eg role="parse-test" xml:space="preserve">my:hatsize(5) eq my:shoesize(5)</eg>
            </item> 


  <item>
              <p>The following comparison is true. The <code>eq</code> operator compares two QNames by performing codepoint-comparisons of their namespace URIs and their local names, ignoring their namespace prefixes.</p>
              <eg role="parse-test" xml:space="preserve">fn:QName("http://example.com/ns1", "this:color")
   eq fn:QName("http://example.com/ns1", "that:color")</eg>
            </item>
          </ulist> 
</div3> 
<div3 id="id-general-comparisons"> 
<head>General Comparisons</head> 
<p>The general comparison operators are <code>=</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>. General comparisons are existentially quantified comparisons that may be applied to operand sequences of any length. The result of a general comparison that does not raise an error is 
always <code>true</code> or <code>false</code>.</p>

<p>
            <phrase role="xquery">A</phrase> general comparison is evaluated by applying the following rules, in order:</p>

<olist>

  <item>
              <p>
                <termref def="dt-atomization">Atomization</termref> is applied to each operand. After atomization, each operand is a sequence of atomic values.</p>
            </item>

  <item>
              <p>The result of the comparison is <code>true</code> if and only if there is a pair of
atomic values, one in the first operand sequence and the other in the second operand sequence, that have the required
<term>magnitude relationship</term>. Otherwise the result of the  comparison is
<code>false</code>. The <term>magnitude relationship</term> between two atomic values is determined by
applying the following rules. If a <code>cast</code> operation called for by these rules is not successful, a dynamic error is raised. [err:FORG0001]</p>
              <note role="xquery">
                <p>The purpose of these rules is to preserve compatibility with XPath 1.0, in which (for example) <code role="parse-test">x &lt; 17</code> is a numeric comparison if <code>x</code> is an untyped value. Users should be aware that the value comparison operators have different rules for casting of <code>xs:untypedAtomic</code> operands.</p>
              </note>

<olist>

           <item diff="chg" at="XQ.E18 and XP.E10">
             <p>If both atomic values are instances of <code>xs:untypedAtomic</code>, 
                then the values are cast to the type <code>xs:string</code>.
             </p>
          </item>
	  <item diff="chg" at="XQ.E18 and XP.E10">
             <p>If exactly one of the atomic values is an instance of 
                <code>xs:untypedAtomic</code>, it is cast to a type depending on 
                the other value's dynamic type T according to the following rules, 
                in which V denotes the value to be cast:
             </p>
             <olist>
                <item>
                   <p>If T is a numeric type or is derived from a numeric type, 
                      then V is cast to <code>xs:double</code>.</p>
                </item>
                    <item>
                   <p>If T is <code>xs:dayTimeDuration</code> or is derived from
                      <code>xs:dayTimeDuration</code>, 
                      then V is cast to <code>xs:dayTimeDuration</code>.</p>
                </item>
                    <item>
                   <p>If T is <code>xs:yearMonthDuration</code> or is derived from
                      <code>xs:yearMonthDuration</code>, 
                      then V is cast to <code>xs:yearMonthDuration</code>.</p>
                </item>
                    <item>
                   <p>In all other cases, V is cast to the primitive base type of T.</p>
                </item>
             </olist>
             <note>
                    <p>
                The special treatment of the duration types is required to avoid 
                errors that may arise when comparing the primitive type 
                <code>xs:duration</code> with any duration type.
             </p>
                  </note>
          </item>
  <item>
                  <p>After performing the conversions described above, the atomic values are
compared using one of the value comparison operators <code>eq</code>, <code>ne</code>, <code>lt</code>, <code>le</code>, <code>gt</code>, or
<code>ge</code>, depending on whether the general comparison operator was <code>=</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>,
<code>&gt;</code>, or <code>&gt;=</code>. The values have the required <term>magnitude relationship</term> if and only if the result
of this value comparison is <code>true</code>.</p>
                </item>
              </olist>
            </item>
          </olist>
          <p>When evaluating a general comparison in which either operand is a sequence of items, an implementation may return <code>true</code> as soon as it finds an item in the first operand and an item in the second operand that have the required <term>magnitude relationship</term>. Similarly, a general comparison may raise a <termref def="dt-dynamic-error">dynamic error</termref> as soon as it encounters an error in evaluating either operand, or in comparing a pair of items from the two operands. As a result of these rules, the result of a general comparison is not deterministic in the presence of errors.</p> 
 
 
<p>Here are some examples of  general comparisons:</p> 

<ulist> 


  <item> 
<p>The following comparison is true if the <termref def="dt-typed-value">typed value</termref> of any
<code>author</code> subelement of <code>$book1</code> is "Kennedy" as an instance of <code>xs:string</code> or <code>xs:untypedAtomic</code>:</p>
<eg role="parse-test" xml:space="preserve">$book1/author = "Kennedy"</eg> 
</item>

  <item>
              <p>The following example contains three general comparisons. The value of the first two comparisons is <code>true</code>, and the value of the third comparison is <code>false</code>. This example illustrates the fact that general comparisons are not transitive.</p>
              <eg xml:space="preserve">(1, 2) = (2, 3)
(2, 3) = (3, 4)
(1, 2) = (3, 4)</eg>
            </item>

  <item>
              <p>The following example contains two general comparisons, both of which are <code>true</code>. This example illustrates the fact that the <code>=</code> and <code>!=</code> operators are not inverses of each other.</p>
              <eg xml:space="preserve">(1, 2) = (2, 3)
(1, 2) != (2, 3)</eg>
            </item>

  <item>
              <p>Suppose that <code>$a</code>, <code>$b</code>, and <code>$c</code> are bound to element nodes with type annotation <code>xs:untypedAtomic</code>, with <termref def="dt-string-value">string values</termref> "<code>1</code>", "<code>2</code>", and "<code>2.0</code>" respectively. Then <code role="parse-test">($a, $b) = ($c, 3.0)</code> returns <code>false</code>, because <code>$b</code> and <code>$c</code> are compared as strings. However, <code role="parse-test">($a, $b) = ($c, 2.0)</code> returns <code>true</code>, because <code>$b</code> and <code>2.0</code> are compared as numbers.</p>
            </item> 
</ulist> 
</div3> 
<div3 id="id-node-comparisons"> 
<head>Node Comparisons</head> 
<p>Node comparisons are used to compare two nodes, by their identity or by their <termref def="dt-document-order">document order</termref>. The result of a node comparison is defined by the following rules:</p> 


<olist> 


  <item> 
<p>The operands of a node comparison are evaluated in <termref def="dt-implementation-dependent">implementation-dependent</termref> order.</p>
            </item> 


  <item> 
<p>If either operand is an empty sequence, the result of the
    comparison is an empty sequence, and the implementation need not
    evaluate the other operand or apply the operator. However, an
    implementation may choose to evaluate the other operand in order to
    determine whether it raises an error.</p> 
</item> 


  <item>
              <p> Each operand must be either a single node or an empty sequence; otherwise
a <termref def="dt-type-error">type error</termref> is raised <errorref class="TY" code="0004"/>.</p> 
</item>

  <item> 
<p>A comparison with the <code>is</code> operator is <code>true</code> if the two operand nodes have the same identity, and are thus the same node; otherwise it
is <code>false</code>. See <bibref ref="xpath-datamodel-11"/> for a definition of node identity.</p> 
</item> 


  <item> 
<p>A comparison with the <code>&lt;&lt;</code> operator returns <code>true</code> if the left operand node precedes the right operand node in
<termref def="dt-document-order">document order</termref>; otherwise it returns <code>false</code>.</p> 
</item> 


  <item> 
<p>A comparison with the <code>&gt;&gt;</code> operator returns <code>true</code> if the left operand node follows the right operand node in
<termref def="dt-document-order">document order</termref>; otherwise it returns <code>false</code>.</p> 
</item>
          </olist> 
<p>Here are some examples of node comparisons:</p> 

<ulist> 


  <item> 
<p>The following comparison is true only if the left and right sides each
evaluate to exactly the same single node:</p> 
<eg role="parse-test" xml:space="preserve">/books/book[isbn="1558604820"] is /books/book[call="QA76.9 C3845"]</eg> 
</item>

  <item role="xquery">
              <p>The following comparison is false because each constructed node has its own identity:</p>
              <eg role="parse-test" xml:space="preserve">&lt;a&gt;5&lt;/a&gt; is &lt;a&gt;5&lt;/a&gt;</eg>
            </item> 


  <item> 
<p>The following comparison is true only if the node identified by the left
side occurs before the node identified by the right side in document order:</p>
<eg role="parse-test" xml:space="preserve">/transactions/purchase[parcel="28-451"] 
   &lt;&lt; /transactions/sale[parcel="33-870"]</eg> 
</item>
          </ulist> 
</div3> 
	
</div2>	
<div2 id="id-logical-expressions"> 
<head>Logical Expressions</head> 
<p>A <term>logical expression</term> is either an <term>and-expression</term> or
an <term>or-expression</term>. If a logical expression does not raise an error, its value is always one
of the boolean values <code>true</code> or <code>false</code>.</p> 
<scrap headstyle="show"> 
<head/> <prod num="86" id="doc-xquery11-OrExpr">
            <lhs>OrExpr</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AndExpr" xlink:type="simple">AndExpr</nt> ( "or"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AndExpr" xlink:type="simple">AndExpr</nt> )*</rhs>
          </prod> 
<prod num="87" id="doc-xquery11-AndExpr">
            <lhs>AndExpr</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ComparisonExpr" xlink:type="simple">ComparisonExpr</nt> ( "and"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ComparisonExpr" xlink:type="simple">ComparisonExpr</nt> )*</rhs>
          </prod> 
</scrap> 
<p>The first step in evaluating a logical expression is to find the  <termref def="dt-ebv">effective boolean value</termref> of each of its operands (see <specref ref="id-ebv"/>).</p> 
 
<p>The value of an and-expression is determined by the effective
boolean values (EBV's) of its operands, as shown in the following table:</p>
        <table border="1" cellpadding="4" cellspacing="1" width="80%" summary="AND EBV">
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">AND:</td>
              <td rowspan="1" colspan="1">EBV<sub>2</sub> =
<code>true</code>
              </td>
              <td rowspan="1" colspan="1">EBV<sub>2</sub> = <code>false</code>
              </td>
              <td rowspan="1" colspan="1">error in EBV<sub>2</sub>
</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">EBV<sub>1</sub> =
<code>true</code>
              </td>
              <td rowspan="1" colspan="1">
                <code>true</code>
              </td>
              <td rowspan="1" colspan="1">
                <code>false</code>
              </td>
              <td rowspan="1" colspan="1">error</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">EBV<sub>1</sub>
= <code>false</code>
              </td>
              <td rowspan="1" colspan="1">
                <code>false</code>
              </td>
              <td rowspan="1" colspan="1">
                <code>false</code>
              </td>
              <td rowspan="1" colspan="1">
                <phrase role="xquery">either <code>false</code> or
error</phrase>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">error in EBV<sub>1</sub>
</td>
              <td rowspan="1" colspan="1">error</td>
              <td rowspan="1" colspan="1">
                <phrase role="xquery">either <code>false</code> or
error</phrase>
              </td>
              <td rowspan="1" colspan="1">error</td>
            </tr>
          </tbody>
        </table>
        <p>The value of an
or-expression is determined by the effective boolean values (EBV's) of
its operands, as shown in
the following table:</p>
        <table border="1" cellpadding="4" cellspacing="1" width="80%" summary="OR EBV">
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">OR:</td>
              <td rowspan="1" colspan="1">EBV<sub>2</sub> =
<code>true</code>
              </td>
              <td rowspan="1" colspan="1">EBV<sub>2</sub> = <code>false</code>
              </td>
              <td rowspan="1" colspan="1">error in
EBV<sub>2</sub>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">EBV<sub>1</sub> =
<code>true</code>
              </td>
              <td rowspan="1" colspan="1">
                <code>true</code>
              </td>
              <td rowspan="1" colspan="1">
                <code>true</code>
              </td>
              <td rowspan="1" colspan="1">
                <phrase role="xquery">either <code>true</code> or
error</phrase>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">EBV<sub>1</sub> =
<code>false</code>
              </td>
              <td rowspan="1" colspan="1">
                <code>true</code>
              </td>
              <td rowspan="1" colspan="1">
                <code>false</code>
              </td>
              <td rowspan="1" colspan="1">error</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">error
in EBV<sub>1</sub>
              </td>
              <td rowspan="1" colspan="1">
                <phrase role="xquery">either <code>true</code> or
error</phrase>
              </td>
              <td rowspan="1" colspan="1">error</td>
              <td rowspan="1" colspan="1">error</td>
            </tr>
          </tbody>
        </table>
        <p>
          <phrase role="xquery">The
order in which the operands of a logical expression are evaluated is
<termref def="dt-implementation-dependent">implementation-dependent</termref>. The tables above are defined in such a way
that</phrase> an or-expression can return <code>true</code> if the first
expression evaluated is true, and it can raise an error if evaluation
of the first expression raises an error. Similarly, an and-expression
can return <code>false</code> if the first expression evaluated is
false, and it can raise an error if evaluation of the first expression
raises an error. As a result of these rules, a logical expression is
not deterministic in the presence of errors, as illustrated in the examples
below.</p>
        <p>Here are some examples of logical expressions:</p>
 

<ulist>

  <item>
            <p>The following expressions return
<code>true</code>:</p>
            <eg role="parse-test" xml:space="preserve">1 eq 1 and 2 eq 2</eg>
            <eg role="parse-test" xml:space="preserve">1 eq 1 or 2 eq 3</eg>
          </item>

  <item>
            <p>The following
expression may return either <code>false</code> or raise a <termref def="dt-dynamic-error">dynamic error</termref>:</p>
            <eg role="parse-test" xml:space="preserve">1 eq 2 and 3 idiv 0 = 1</eg>
          </item>

  <item>
            <p>The
following expression may return either <code>true</code> or raise a
<termref def="dt-dynamic-error">dynamic error</termref>:</p>
            <eg role="parse-test" xml:space="preserve">1 eq 1 or 3 idiv 0 = 1</eg>
          </item>

  <item>
            <p>The
following expression must raise a <termref def="dt-dynamic-error">dynamic error</termref>:</p>
            <eg role="parse-test" xml:space="preserve">1 eq 1 and 3 idiv 0 = 1</eg>
          </item>
        </ulist>

<p>In addition to and- and or-expressions, XQuery 1.1 provides a
function named <code>fn:not</code> that takes a general sequence as
parameter and returns a boolean value.  The <code>fn:not</code> function
is defined in <bibref ref="xpath-functions-11"/>. The
<code>fn:not</code> function reduces its parameter to an <termref def="dt-ebv">effective boolean value</termref>. It then returns
<code>true</code> if the effective boolean value of its parameter is
<code>false</code>, and <code>false</code> if the effective boolean
value of its parameter is <code>true</code>. If an error is
encountered in finding the effective boolean value of its operand,
<code>fn:not</code> raises the same error.</p>

	
</div2>	
<div2 role="xquery" id="id-constructors"> 
<head role="xquery">Constructors</head> 
<p>XQuery provides constructors that can create XML structures within a query.
Constructors are provided for element, attribute, document, text, comment, and processing instruction nodes. Two kinds of constructors are provided: <term>direct constructors</term>, which use an XML-like notation, and <term>computed constructors</term>, which use a notation based on enclosed expressions.</p> 
<scrap headstyle="show"> 
<head/> <prod num="137" id="doc-xquery11-Constructor">
            <lhs>Constructor</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-DirectConstructor" xlink:type="simple">DirectConstructor</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ComputedConstructor" xlink:type="simple">ComputedConstructor</nt>
            </rhs>
          </prod> 
<prod num="138" id="doc-xquery11-DirectConstructor">
            <lhs>DirectConstructor</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-DirElemConstructor" xlink:type="simple">DirElemConstructor</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-DirCommentConstructor" xlink:type="simple">DirCommentConstructor</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-DirPIConstructor" xlink:type="simple">DirPIConstructor</nt>
            </rhs>
          </prod>
          <prod num="139" id="doc-xquery11-DirElemConstructor">
            <lhs>DirElemConstructor</lhs>
            <rhs>"&lt;"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-QName" xlink:type="simple">QName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-DirAttributeList" xlink:type="simple">DirAttributeList</nt>  ("/&gt;"  |  ("&gt;"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-DirElemContent" xlink:type="simple">DirElemContent</nt>*  "&lt;/"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-QName" xlink:type="simple">QName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-S" xlink:type="simple">S</nt>?  "&gt;"))</rhs>
          </prod> 
<prod num="144" id="doc-xquery11-DirElemContent">
            <lhs>DirElemContent</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-DirectConstructor" xlink:type="simple">DirectConstructor</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-CDataSection" xlink:type="simple">CDataSection</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-CommonContent" xlink:type="simple">CommonContent</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ElementContentChar" xlink:type="simple">ElementContentChar</nt>
            </rhs>
          </prod>
          <prod num="204" id="doc-xquery11-ElementContentChar">
            <lhs>ElementContentChar</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Char" xlink:type="simple">Char</nt> - [{}&lt;&amp;]</rhs>
          </prod> 
<prod num="145" id="doc-xquery11-CommonContent">
            <lhs>CommonContent</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-PredefinedEntityRef" xlink:type="simple">PredefinedEntityRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-CharRef" xlink:type="simple">CharRef</nt>  |  "{{"  |  "}}"  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-EnclosedExpr" xlink:type="simple">EnclosedExpr</nt>
            </rhs>
          </prod>
          <prod num="150" id="doc-xquery11-CDataSection">
            <lhs>CDataSection</lhs>
            <rhs>"&lt;![CDATA["  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-CDataSectionContents" xlink:type="simple">CDataSectionContents</nt>  "]]&gt;"</rhs>
          </prod>
          <prod num="151" id="doc-xquery11-CDataSectionContents">
            <lhs>CDataSectionContents</lhs>
            <rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Char" xlink:type="simple">Char</nt>* - (Char* ']]&gt;' Char*))</rhs>
          </prod>
          <prod num="140" id="doc-xquery11-DirAttributeList">
            <lhs>DirAttributeList</lhs>
            <rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-S" xlink:type="simple">S</nt>  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-QName" xlink:type="simple">QName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-S" xlink:type="simple">S</nt>?  "="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-S" xlink:type="simple">S</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-DirAttributeValue" xlink:type="simple">DirAttributeValue</nt>)?)*</rhs>
          </prod> 
<prod num="141" id="doc-xquery11-DirAttributeValue">
            <lhs>DirAttributeValue</lhs>
            <rhs>('"'  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-EscapeQuot" xlink:type="simple">EscapeQuot</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-QuotAttrValueContent" xlink:type="simple">QuotAttrValueContent</nt>)*  '"')<br/>|  ("'"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-EscapeApos" xlink:type="simple">EscapeApos</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AposAttrValueContent" xlink:type="simple">AposAttrValueContent</nt>)*  "'")</rhs>
          </prod> 
 
<prod num="142" id="doc-xquery11-QuotAttrValueContent">
            <lhs>QuotAttrValueContent</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-QuotAttrContentChar" xlink:type="simple">QuotAttrContentChar</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-CommonContent" xlink:type="simple">CommonContent</nt>
            </rhs>
          </prod>
          <prod num="143" id="doc-xquery11-AposAttrValueContent">
            <lhs>AposAttrValueContent</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AposAttrContentChar" xlink:type="simple">AposAttrContentChar</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-CommonContent" xlink:type="simple">CommonContent</nt>
            </rhs>
          </prod>
          <prod num="205" id="doc-xquery11-QuotAttrContentChar">
            <lhs>QuotAttrContentChar</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Char" xlink:type="simple">Char</nt> - ["{}&lt;&amp;]</rhs>
          </prod>
          <prod num="206" id="doc-xquery11-AposAttrContentChar">
            <lhs>AposAttrContentChar</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Char" xlink:type="simple">Char</nt> - ['{}&lt;&amp;]</rhs>
          </prod>
          <prod num="202" id="doc-xquery11-EscapeQuot">
            <lhs>EscapeQuot</lhs>
            <rhs>'""'</rhs>
          </prod>
          <prod num="203" id="doc-xquery11-EscapeApos">
            <lhs>EscapeApos</lhs>
            <rhs>"''"</rhs>
          </prod>
          <prod num="36" id="doc-xquery11-EnclosedExpr">
            <lhs>EnclosedExpr</lhs>
            <rhs>"{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Expr" xlink:type="simple">Expr</nt>  "}"</rhs>
          </prod> 
</scrap> 
	
<p>This section contains a conceptual description of the semantics of various kinds of constructor expressions. An XQuery implementation is free to use any implementation technique that produces the same result as the processing steps described in this section.</p>
        <div3 id="id-element-constructor">
          <head>Direct Element Constructors</head>
          <p>An <term>element constructor</term> creates an element node. <termdef term="direct element constructor" id="dt-direct-elem-const">A <term>direct element constructor</term> is a form of element constructor in which the name of the constructed element is a constant.</termdef> Direct element constructors are based on standard XML notation. For example, the following expression is a direct element constructor
that creates a <code>book</code> element containing an attribute and some nested elements:</p> 
<eg role="parse-test" xml:space="preserve">&lt;book isbn="isbn-0060229357"&gt;
    &lt;title&gt;Harold and the Purple Crayon&lt;/title&gt;
    &lt;author&gt;
        &lt;first&gt;Crockett&lt;/first&gt;
        &lt;last&gt;Johnson&lt;/last&gt;
    &lt;/author&gt;
&lt;/book&gt;</eg> 
<p>If the element name in a direct element constructor has a namespace prefix, the namespace prefix is resolved to a namespace URI using the <termref def="dt-static-namespaces">statically known namespaces</termref>. If the element name  has no namespace prefix, it is implicitly qualified by the <termref def="dt-def-elemtype-ns">default element/type namespace</termref>. Note that both the statically known namespaces and the default element/type namespace may be affected by <termref def="dt-namespace-decl-attr">namespace declaration attributes</termref> found inside the element constructor. The namespace prefix of the element name is retained after expansion of the <termref def="dt-qname">lexical QName</termref> , as described in <bibref ref="xpath-datamodel-11"/>. The resulting <termref def="dt-expanded-qname">expanded QName</termref> becomes the <code>node-name</code> property of the constructed element node.</p>
          <p>In a direct element constructor, the name used in the end tag must exactly match the name
used in the corresponding start tag, including its prefix or absence of a prefix.</p> 
 
<p>In a direct element constructor, curly braces { } delimit <term>enclosed
expressions</term>, distinguishing them from literal text. Enclosed expressions
are evaluated and replaced by their value, as illustrated by the following
example:</p> 
<eg role="parse-test" xml:space="preserve">&lt;example&gt;
   &lt;p&gt; Here is a query. &lt;/p&gt;
   &lt;eg&gt; $b/title &lt;/eg&gt;
   &lt;p&gt; Here is the result of the query. &lt;/p&gt;
   &lt;eg&gt;{ $b/title }&lt;/eg&gt;
&lt;/example&gt;</eg> 
<p>The above query might generate the following result (whitespace has been added for readability to this result and other result examples in this document):</p> 
<eg role="parse-test" xml:space="preserve">
&lt;example&gt;
  &lt;p&gt; Here is a query. &lt;/p&gt;
  &lt;eg&gt; $b/title &lt;/eg&gt;
  &lt;p&gt; Here is the result of the query. &lt;/p&gt;
  &lt;eg&gt;&lt;title&gt;Harold and the Purple Crayon&lt;/title&gt;&lt;/eg&gt;
&lt;/example&gt;</eg>
          <p>Since XQuery uses curly braces to denote enclosed expressions, some
convention is needed to denote a curly brace used as an ordinary character. For
this purpose, a pair of identical curly brace characters within the content of an element or attribute are interpreted by XQuery  as a single curly brace
character (that is, the pair "<code>{{</code>" represents the
  character "<code>{</code>" and the pair "<code>}}</code>" represents
  the character "<code>}</code>".) Alternatively, the <termref def="dt-character-reference">character references</termref> <code>&amp;#x7b;</code> and <code>&amp;#x7d;</code> can be used to denote curly brace characters.  A single left curly brace
  ("<code>{</code>") is interpreted as the beginning delimiter for an
  enclosed expression. A single right curly brace ("<code>}</code>")
  without a matching left curly brace is treated as a <termref def="dt-static-error">static error</termref> <errorref class="ST" code="0003"/>.</p>
          <p>The result of an element constructor is a new element node, with its own node identity. All the attribute and descendant nodes of the new element node are also new nodes with their own identities, even if they are copies of existing nodes.</p>
          <div4 id="id-attributes">
            <head>Attributes</head>
            <p>The start tag of a direct element constructor may contain one or more attributes. As in XML, each attribute is specified by a name and a value. In a direct element constructor, the name of each attribute is specified by a constant <termref def="dt-qname">lexical QName</termref>, and the value of the attribute is specified by a string of characters enclosed in single or double quotes. As in the main content of the element constructor, an attribute value may contain expressions enclosed in curly braces, which are evaluated and replaced by their value during processing of the element constructor.</p>
            <p>Each attribute in a direct element constructor creates a new attribute node, with its own node identity, whose parent is the constructed element node. However, note that <termref def="dt-namespace-decl-attr">namespace declaration attributes</termref> (see <specref ref="id-namespaces"/>) do not create attribute nodes.</p>
            <p>If an attribute name has a namespace prefix, the prefix is resolved to a namespace URI using the <termref def="dt-static-namespaces">statically known namespaces</termref>. If the attribute name  has no namespace prefix, the attribute is in no namespace. Note that the statically known namespaces used in  resolving an attribute name may be affected by <termref def="dt-namespace-decl-attr">namespace declaration attributes</termref> that are found inside the same element constructor. The namespace prefix of the attribute name is retained after expansion of the <termref def="dt-qname">lexical QName</termref>, as described in <bibref ref="xpath-datamodel-11"/>. The resulting <termref def="dt-expanded-qname">expanded QName</termref> becomes the <code>node-name</code> property of the constructed attribute node.</p>
            <p>If the attributes in a direct element constructor do not have distinct <termref def="dt-expanded-qname">expanded
			        QNames</termref> as their respective <code>node-name</code> properties, a <termref def="dt-static-error">static error</termref> is raised <errorref class="ST" code="0040"/>.</p>
            <p>Conceptually, an attribute (other than a namespace declaration attribute) in a direct element constructor is processed by the following steps:</p>

<olist>

<item diff="chg" at="XQ.E13">
	
	<p>Each consecutive sequence of literal characters in the attribute 
          content is treated as a string containing those characters, with
          the following exceptions:</p>
          <olist>
             <item>
                    <p>Each occurrence of two consecutive <code>{</code>
             characters is replaced by a single <code>{</code> character.
             </p>
                  </item>
             <item>
                    <p>Each occurrence of two consecutive <code>}</code>
             characters is replaced by a single <code>}</code> character.
             </p>
                  </item>
             <item>
                    <p>Each occurrence of two consecutive <code>"</code>
             characters is replaced by a single <code>"</code> character.
             </p>
                  </item>
             <item>
                    <p>Each occurrence of two consecutive <code>'</code>
             characters is replaced by a single <code>'</code> character.
             </p>
                  </item>
          </olist>

          <p>Attribute value normalization is then applied to
          normalize whitespace and expand <termref def="dt-character-reference">character references</termref>
          and <termref def="dt-predefined-entity-reference">predefined
          entity references</termref>. An XQuery processor that
          supports XML 1.0 uses the rules for attribute value
          normalization in Section 3.3.3 of <bibref ref="XML"/>; an
          XQuery processor that supports XML 1.1 uses the rules for
          attribute value normalization in Section 3.3.3 of <bibref ref="XML1.1"/>. In either case, the normalization rules are
          applied as though the type of the attribute were CDATA
          (leading and trailing whitespace characters are not
          stripped.) The choice between XML 1.0 and XML 1.1 rules is
          <termref def="dt-implementation-defined">implementation-defined</termref>.
          </p>
</item>


  <item>
                <p>Each enclosed expression is converted to a string as follows:</p>

<olist>

  <item>
                    <p>
                      <termref def="dt-atomization">Atomization</termref> is applied to the value of the enclosed expression, converting it to a sequence of atomic values.</p>
                  </item>

  <item>
                    <p>If the result of atomization is an empty sequence, the result is the zero-length string. Otherwise, each atomic value in the atomized sequence is cast into a string.</p>
                  </item>

  <item>
                    <p>The individual strings resulting from the previous step are merged into a single string by concatenating them with a single space character between each pair.</p>
                  </item>
                </olist>
              </item>

  <item>
                <p>Adjacent strings resulting from the above steps are concatenated with no intervening blanks. The resulting string becomes the <code>string-value</code> property of the attribute node. The attribute node is given a <termref def="dt-type-annotation">type annotation</termref> (<code>type-name</code> property) of <code>xs:untypedAtomic</code> (this type annotation may change if the parent element is validated). The <code>typed-value</code> property of the attribute node is the same as its <code>string-value</code>, as an instance of <code>xs:untypedAtomic</code>.</p>
              </item>

  <item>
                <p>The <code>parent</code> property of the attribute node is set to the element node constructed by the direct element constructor that contains this attribute.</p>
              </item>

  <item>
                <p>If the attribute name is <code>xml:id</code>, then <code>xml:id</code> processing is performed as defined in <bibref ref="XMLID"/>. This ensures that the attribute has the type <code>xs:ID</code> and that its value is properly normalized. If an error is encountered during <code>xml:id</code> processing, an implementation may raise a <termref def="dt-dynamic-error">dynamic error</termref> <errorref class="DY" code="0091"/>.</p>
              </item>

  <item>
                <p>If the attribute name is <code>xml:id</code>, the <code>is-id</code> property of the resulting attribute node is set to <code>true</code>; otherwise the <code>is-id</code> property is set to <code>false</code>. The <code>is-idrefs</code> property of the attribute node is unconditionally set to <code>false</code>.</p>
              </item>
            </olist>
<ulist>

  <item>
                <p>Example:</p>
                <eg role="parse-test" xml:space="preserve">&lt;shoe size="7"/&gt;</eg>
                <p>The string value of the <code>size</code> attribute is "<code>7</code>".</p>
              </item>

  <item>
                <p>Example:</p>
                <eg role="parse-test" xml:space="preserve">&lt;shoe size="{7}"/&gt;</eg>
                <p>The string value of the <code>size</code> attribute is "<code>7</code>".</p>
              </item>

  <item>
                <p>Example:</p>
                <eg role="parse-test" xml:space="preserve">&lt;shoe size="{()}"/&gt;</eg>
                <p>The string value of the <code>size</code> attribute is the zero-length string.</p>
              </item>

  <item>
                <p>Example:</p>
                <eg role="parse-test" xml:space="preserve">&lt;chapter ref="[{1, 5 to 7, 9}]"/&gt;</eg>
                <p>The string value of the <code>ref</code> attribute is "<code>[1 5 6 7 9]</code>".</p>
              </item>

  <item>
                <p>Example:</p>
                <eg role="parse-test" xml:space="preserve">&lt;shoe size="As big as {$hat/@size}"/&gt;</eg>
                <p>The string value of the <code>size</code> attribute is the 
string "<code>As big as </code>", concatenated with the string value of the 
node denoted by the expression
  <code>$hat/@size</code>.</p>
              </item>
            </ulist>
          </div4>
          <div4 id="id-namespaces">
            <head>Namespace Declaration Attributes</head>
            <p>The names of
  a constructed element and its attributes may be <termref def="dt-qname">lexical QNames</termref> that
  include <term>namespace prefixes</term>. Namespace prefixes can be
  bound to namespaces in the <termref def="dt-prolog">Prolog</termref> or by  <term>namespace
  declaration attributes</term>. It is a
  <termref def="dt-static-error">static error</termref> to use a
  namespace prefix that has not been bound to a namespace <errorref class="ST" code="0081"/>.</p>

<p diff="chg" at="XQ.E13">
              <termdef term="namespace declaration attribute" id="dt-namespace-decl-attr">A <term>namespace declaration
attribute</term> is used inside a direct element constructor. Its
purpose is to bind a namespace prefix or to set the <termref def="dt-def-elemtype-ns">default element/type namespace</termref> for
the constructed element node, including its attributes.</termdef>
Syntactically, a namespace declaration attribute has the form of an
attribute with namespace prefix <code>xmlns</code>, or with name
<code>xmlns</code> and no namespace prefix. All the namespace
declaration attributes of a given element must have distinct names
<errorref class="ST" code="0071"/>. Each namespace declaration
attribute is processed as follows:</p>


<ulist>

  <item diff="add" at="XQ.E13">
                <p>The value of the namespace declaration attribute (a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-DirAttributeValue" xlink:type="simple">DirAttributeValue</nt>) is processed as
  follows. If the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-DirAttributeValue" xlink:type="simple">DirAttributeValue</nt>
  contains an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-EnclosedExpr" xlink:type="simple">EnclosedExpr</nt>, a static error
  is raised <errorref class="ST" code="0022"/>. Otherwise, it is
  processed as described in rule 1 of <specref ref="id-attributes"/>. An implementation MAY raise a static error
  <errorref class="ST" code="0046"/> if the resulting value is of
  nonzero length and is not in the lexical space of
  <code>xs:anyURI</code>. The resulting value is used as the namespace
  URI in the following rules.
  </p>
  </item>

          <item diff="chg" at="XQ.E13">
             <p>If the prefix of the attribute name is <code>xmlns</code>, then the 
                local part of the attribute name is interpreted as a namespace prefix. 
                This prefix and the namespace URI are added to the 
                <termref def="dt-static-namespaces">statically known namespaces</termref> 
                of the constructor expression (overriding any existing binding of 
                the given prefix), and are also added as a namespace binding to the 
                <termref def="dt-in-scope-namespaces">in-scope namespaces</termref> 
                of the constructed element. If the namespace URI is a zero-length 
                string and the implementation supports <bibref ref="XMLNAMES11"/>, 
                any existing namespace binding for the given prefix is removed from the 
                <termref def="dt-in-scope-namespaces">in-scope namespaces</termref> 
                of the constructed element and from the 
                <termref def="dt-static-namespaces">statically known namespaces</termref> 
                of the constructor expression. If the namespace URI is a zero-length 
                string and the implementation does not support <bibref ref="XMLNAMES11"/>,
                a static error is raised <errorref code="0085" class="ST"/>. It is 
                <termref def="dt-implementation-defined">implementation-defined</termref> 
                whether an implementation supports <bibref ref="XMLNAMES"/> or 
                <bibref ref="XMLNAMES11"/>.
             </p>
          </item>

          <item diff="chg" at="XQ.E13">
             <p>If the name of the namespace declaration attribute is <code>xmlns</code> 
                with no prefix, then the namespace URI specifies the 
                <termref def="dt-def-elemtype-ns">default element/type namespace</termref>
                of the constructor expression (overriding any existing default), 
                and is added (with no prefix) to the 
                <termref def="dt-in-scope-namespaces">in-scope namespaces</termref> 
                of the constructed element (overriding any existing namespace binding 
                with no prefix). If the namespace URI is a zero-length string, the 
                <termref def="dt-def-elemtype-ns">default element/type namespace</termref> 
                of the constructor expression is set to "none," and any no-prefix 
                namespace binding is removed from the 
                <termref def="dt-in-scope-namespaces">in-scope namespaces</termref> 
                of the constructed element.
             </p>
          </item>

          <item diff="chg" at="XQ.E19">
             <p>It is a <termref def="dt-static-error">static error</termref> 
                <errorref class="ST" code="0070"/> if a namespace declaration 
                attribute attempts to do any of the following:
                <ulist>
                   <item>
                      <p>Bind the prefix <code>xml</code> to some namespace URI 
                      other than <code>http://www.w3.org/XML/1998/namespace</code>.
                   </p>
                    </item>
                   <item>
                      <p>Bind a prefix other than <code>xml</code> to the namespace 
                      URI <code>http://www.w3.org/XML/1998/namespace</code>.
                   </p>
                    </item>
                   <item>
                      <p>Bind the prefix <code>xmlns</code> to any namespace URI.
                   </p>
                    </item>
                   <item>
                      <p>Bind a prefix to the namespace 
                      URI <code>http://www.w3.org/2000/xmlns/</code>.
                   </p>
                    </item>
                </ulist>
             </p>
          </item>

</ulist>

<p> A namespace declaration attribute does not cause an attribute node to be created. </p>
            <p>The following examples illustrate namespace declaration attributes:</p>
<ulist>

  <item>
                <p>In this element constructor, a namespace declaration attribute is used to set the <termref def="dt-def-elemtype-ns">default element/type namespace</termref> to <code>http://example.org/animals</code>:<eg role="parse-test" xml:space="preserve">&lt;cat xmlns = "http://example.org/animals"&gt;
  &lt;breed&gt;Persian&lt;/breed&gt;
&lt;/cat&gt;</eg>
                </p>
              </item>

  <item>
                <p>In this element constructor, namespace declaration attributes are used to bind the namespace prefixes <code>metric</code> and <code>english</code>:</p> 
<eg role="parse-test" xml:space="preserve">&lt;box xmlns:metric = "http://example.org/metric/units"
     xmlns:english = "http://example.org/english/units"&gt;
  &lt;height&gt; &lt;metric:meters&gt;3&lt;/metric:meters&gt; &lt;/height&gt;
  &lt;width&gt; &lt;english:feet&gt;6&lt;/english:feet&gt; &lt;/width&gt;
  &lt;depth&gt; &lt;english:inches&gt;18&lt;/english:inches&gt; &lt;/depth&gt;
&lt;/box&gt;</eg>
              </item>
            </ulist>
          </div4>
          <div4 id="id-content">
            <head>Content</head>
            <p>The part of a direct element constructor between the start tag and the end tag is called the <term>content</term> of the element constructor. This content may consist of text characters (parsed as <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ElementContentChar" xlink:type="simple">ElementContentChar</nt>), nested direct constructors, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-CDataSection" xlink:type="simple">CdataSections</nt>, character and <termref def="dt-predefined-entity-reference">predefined entity references</termref>, and expressions enclosed in curly braces. In general, the value of an enclosed expression may be any sequence of nodes and/or atomic values. Enclosed expressions can be used in the content of an element  constructor to compute both the content and the attributes of the constructed node.</p> 
 
<p>Conceptually, the content of an element constructor is processed as
follows:</p>

<olist>

  <item>
                <p>The content is evaluated to produce a
sequence of nodes called the <term>content sequence</term>, as
follows:</p>

<olist>

  <item>
                    <p>If the <termref def="dt-boundary-space-policy">boundary-space policy</termref> in the <termref def="dt-static-context">static context</termref> is <code>strip</code>, <termref def="dt-boundary-whitespace">boundary whitespace</termref> is identified and deleted (see <specref ref="id-whitespace"/> for a definition of boundary whitespace.)</p>
                  </item>

  <item>
                    <p>
                      <termref def="dt-predefined-entity-reference">Predefined entity references</termref>
and <termref def="dt-character-reference">character references</termref> are expanded into their
referenced strings, as described in <specref ref="id-literals"/>. Characters inside a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-CDataSection" xlink:type="simple">CDataSection</nt>, including special characters such as <code>&lt;</code> and <code>&amp;</code>, are treated as literal characters rather than as markup characters (except for the sequence <code>]]&gt;</code>, which terminates the CDataSection).</p>
                  </item>

  <item>
                    <p>Each consecutive sequence of
literal characters evaluates to a single text node containing the
characters.</p>
                  </item>

  <item>
                    <p>Each nested direct constructor is evaluated according to the rules in <specref ref="id-element-constructor"/> or <specref ref="id-otherConstructors"/>, resulting in a new element, comment, or processing instruction node. Then:</p>

<olist>

  <item>
                        <p>The <code>parent</code> property of the resulting node is then set to the newly constructed element node.</p>
                      </item>

  <item>
                        <p>The <code>base-uri</code> property of the
resulting node, and of each of its descendants, is set to be the same as that
of its new parent, unless it (the child node) has an <code>xml:base</code> attribute, in
which case its <code>base-uri</code> property is set to the value of that attribute,
 <termref def="dt-resolve-relative-uri">resolved (if it is relative)</termref> against the <code>base-uri</code> property of its new parent
node.</p>
                      </item>
                    </olist>
                  </item>

  <item>
                    <p>Enclosed expressions are evaluated as follows: </p>

<olist>

  <item>
                        <p>If an enclosed expression returns a <xtermref spec="DM11" ref="dt-function-item">function item</xtermref>, a type error is raised <errorref class="TY" code="0105"/>.</p>
                      </item>

  <item>
                        <p>For each adjacent sequence of one or more atomic values returned by an enclosed expression, a new text node is constructed, containing the result of casting each atomic value to a string, with a single space character inserted between adjacent values.</p>
                        <note>
                          <p>The insertion of blank characters between adjacent values applies even if one or both of the values is a zero-length string.</p>
                        </note>
                      </item>

  <item>
                        <p>For each node returned by an enclosed expression, a new copy is made of the given node and all nodes that have the given node as an ancestor,  collectively referred to as <term>copied nodes</term>. The properties of the copied nodes are as follows:</p>

<olist>

  <item>
                            <p>Each copied node receives a new node identity.</p>
                          </item>

  <item>
                            <p>The <code>parent</code>, <code>children</code>, and <code>attributes</code> properties of the copied nodes are set so as to preserve their inter-node relationships. For the topmost node (the node directly returned by the enclosed expression), the <code>parent</code> property is set to the node constructed by this constructor.</p>
                          </item>

  <item>
                            <p>If <termref def="dt-construction-mode">construction mode</termref> in the <termref def="dt-static-context">static context</termref> is <code>strip</code>:</p>

<olist>

  <item>
                                <p>If the copied node is an element node, its <code>type-name</code> property is set to  <code>xs:untyped</code>. Its <code>nilled</code>, <code>is-id</code>, and <code>is-idrefs</code> properties are set to <code>false</code>.</p>
                              </item>

  <item>
                                <p>If the copied node is an attribute node, its <code>type-name</code> property  is set to <code>xs:untypedAtomic</code>. Its <code>is-idrefs</code> property is set to <code>false</code>. Its <code>is-id</code> property is set to <code>true</code> if the qualified name of the attribute node is <code>xml:id</code>; otherwise it is set to <code>false</code>.</p> </item>

  <item>
                                <p>The <code>string-value</code> of each copied element and attribute node remains unchanged, and its <code>typed-value</code> becomes equal to its <code>string-value</code> as an instance of <code>xs:untypedAtomic</code>.<note>
                                    <p> Implementations that store only the <termref def="dt-typed-value">typed value</termref> of a node are required at this point to convert the typed value to a string form.</p>
                                  </note>
                                </p>
                              </item>
                            </olist>
                            <p>On the other hand, if <termref def="dt-construction-mode">construction mode</termref> in the <termref def="dt-static-context">static context</termref> is <code>preserve</code>, the <code>type-name</code>, <code>nilled</code>, <code>string-value</code>, <code>typed-value</code>, <code>is-id</code>, and <code>is-idrefs</code> properties of the copied nodes are preserved.</p>
                          </item>

  <item>
                            <p>The <code>in-scope-namespaces</code> property of a copied element node is 
determined by the following rules. In applying these rules, the default 
namespace or absence of a default namespace is treated like any other 
namespace binding:</p>

<olist>

<item diff="chg" at="XQ.E1">
                                <p>If <termref def="dt-copy-namespaces-mode">copy-namespaces mode</termref> specifies <code>preserve</code>, all in-scope-namespaces of the original element are
retained in the new copy. 
If <termref def="dt-copy-namespaces-mode">copy-namespaces mode</termref> specifies <code>no-preserve</code>, the new copy retains only those in-scope namespaces of the original element that are used in the names of the element and its
attributes.</p>
                              </item>

<item diff="chg" at="XQ.E1">
                                <p>If <termref def="dt-copy-namespaces-mode">copy-namespaces mode</termref> specifies <code>inherit</code>, the copied node inherits all the in-scope namespaces of the constructed node, augmented and overridden by the in-scope namespaces of the original element that were preserved by the preceding rule. If <termref def="dt-copy-namespaces-mode">copy-namespaces mode</termref> specifies <code>no-inherit</code>, the copied node does not inherit any in-scope namespaces from the constructed node.</p>
</item>

</olist>
                          </item>
     


<item diff="add" at="XQ.E1">
<p>An enclosed expression in the content of an element constructor may cause one or more existing nodes to be copied. Type error 
<errorref class="TY" code="0086"/>
is raised in the following cases:</p>
<olist>
 <item>
                                <p>
An element node is copied, and the 
<termref def="dt-typed-value">typed value</termref> of the element node or one of its attributes is 
<termref def="dt-namespace-sensitive">namespace-sensitive</termref>, 
and <termref def="dt-construction-mode">construction mode</termref>
is <code>preserve</code>, and 
<termref def="dt-copy-namespaces-mode">copy-namespaces mode</termref> 
is <code>no-preserve</code>. 
</p>
                              </item>
<item>
                                <p>
An attribute node is copied but its parent element node is not
copied, and the <termref def="dt-typed-value">typed value</termref> 
of the copied attribute node is 
<termref def="dt-namespace-sensitive">namespace-sensitive</termref>, 
and <termref def="dt-construction-mode">construction mode</termref> 
is <code>preserve</code>.</p>
                              </item>
</olist>
             <p>
                <termdef term="namespace-sensitive" id="dt-namespace-sensitive">A 
                value is <term>namespace-sensitive</term> if it includes an item 
                whose <termref def="dt-dynamic-type">dynamic type</termref> is 
                <code>xs:QName</code> or <code>xs:NOTATION</code> or is
                derived by restriction from <code>xs:QName</code> or 
                <code>xs:NOTATION</code>.</termdef>
                            </p>
             <note>
                              <p>
                The rationale for error <errorref class="TY" code="0086"/> is as follows: 
                It is not possible to preserve the type of a QName without also preserving
                the namespace binding that defines the prefix of the QName.</p>
                            </note>
</item>
     
     

  <item>
                            <p>When an element or processing instruction node is copied, its <code>base-uri</code>
property is set to be the same as that of its new parent,
with the following exception: if a copied element node has an <code>xml:base</code> attribute, its <code>base-uri</code> property is set to
the value of that attribute,  <termref def="dt-resolve-relative-uri">resolved (if it is relative)</termref> against
the <code>base-uri</code> property of the new parent node.</p>
                          </item>

  <item>
                            <p>All other properties of the copied nodes are preserved.</p>
                          </item>
                        </olist>
                      </item>
                    </olist>
                  </item>
                </olist>
              </item>

  <item>
                <p> If the content sequence contains a document node, the document node is replaced in the content sequence by its children.</p>
              </item>

  <item>
                <p>Adjacent text nodes in the content sequence are merged into a single text node by concatenating their contents, with no intervening blanks. After concatenation, any text node whose content is a zero-length string is deleted from the content sequence.</p>
              </item>



  <item>
                <p>If the content sequence contains an attribute node or a
namespace node following a node that is not an attribute node or a
namespace node, a <termref def="dt-type-error">type error</termref> is
raised <errorref class="TY" code="0024"/>.</p>
              </item>




  <item>
                <p>The properties of the newly constructed element node are determined as follows:</p>

<olist>

  <item>
                    <p>
                      <code>node-name</code> is the <termref def="dt-expanded-qname">expanded QName</termref> resulting from resolving the element name in the start tag, including its original namespace prefix (if any), as described in <specref ref="id-element-constructor"/>.</p>
                  </item>

  <item>
                    <p>
                      <code>parent</code> is set to empty.</p>
                  </item>

  <item>
                    <p>
                      <code>attributes</code> consist of all the attributes specified in the start tag as described in <specref ref="id-attributes"/>, together with all the attribute nodes in the content sequence, in <termref def="dt-implementation-dependent">implementation-dependent</termref> order. Note that the <code>parent</code> property of each of these attribute nodes has been set to the newly constructed element node. If two or more attributes have the same <code>node-name</code>,  a <termref def="dt-dynamic-error">dynamic error</termref> is raised <errorref class="DY" code="0025"/>. If an attribute named <code>xml:space</code> has a value other than <code>preserve</code> or <code>default</code>, a dynamic error may be raised <errorref code="0092" class="DY"/>.</p>
                  </item>

  <item>
                    <p>
                      <code>children</code> consist of all the element, text, comment, and processing
   instruction nodes in the content sequence. Note that the <code>parent</code> property of each of these nodes has been set to the newly constructed element node.</p>
                  </item>

  <item>
                    <p>
                      <code>base-uri</code> is set to the following value:

<olist>

  <item>
                          <p>If the constructed node has an
attribute named <code>xml:base</code>, then the value of this attribute,  <termref def="dt-resolve-relative-uri">resolved (if it is relative)</termref> against the <termref def="dt-base-uri">base URI</termref> in the <termref def="dt-base-uri">static context</termref>. The value of the <code>xml:base</code> attribute is normalized as described in <bibref ref="XMLBASE"/>.</p>
                        </item>

  <item>
                          <p>Otherwise, the value of the <termref def="dt-base-uri">base URI</termref> in the <termref def="dt-base-uri">static context</termref>.</p>
                        </item>
                      </olist>
                    </p>
                  </item>

  <item>
                    <p>
                      <code>in-scope-namespaces</code> consist of all the namespace bindings resulting from namespace declaration attributes as described in <specref ref="id-namespaces"/>, and possibly additional namespace bindings as described in <specref ref="id-ns-nodes-on-elements"/>.</p>
                  </item>

  <item>
                    <p>The <code>nilled</code> property is <code>false</code>.</p>
                  </item>

  <item>
                    <p>The <code>string-value</code> property is equal to the concatenated contents of the text-node descendants in document order. If there are no text-node descendants, the <code>string-value</code> property is a zero-length string.</p>
                  </item>

  <item>
                    <p>The <code>typed-value</code> property is equal to the <code>string-value</code> property, as an instance of <code>xs:untypedAtomic</code>.</p>
                  </item>

  <item>
                    <p>If <termref def="dt-construction-mode">construction mode</termref> in the <termref def="dt-static-context">static context</termref> is <code>strip</code>, the <code>type-name</code> property is <code>xs:untyped</code>. On the other hand, if construction mode is <code>preserve</code>, the <code>type-name</code> property is <code>xs:anyType</code>.</p>
                  </item>

  <item>
                    <p>The <code>is-id</code> and <code>is-idrefs</code> properties are set to <code>false</code>.</p>
                  </item>
                </olist>
              </item>
            </olist>
<ulist>

  <item>
                <p>Example:</p>
                <eg role="parse-test" xml:space="preserve">&lt;a&gt;{1}&lt;/a&gt;</eg>
                <p>The constructed element node has one child, a text node containing the value "<code>1</code>".</p>
              </item>

  <item>
                <p>Example:</p>
                <eg role="parse-test" xml:space="preserve">&lt;a&gt;{1, 2, 3}&lt;/a&gt;</eg>
                <p>The constructed element node has one child, a text node containing the value "<code>1 2 3</code>".</p>
              </item>

  <item>
                <p>Example:</p>
                <eg role="parse-test" xml:space="preserve">&lt;c&gt;{1}{2}{3}&lt;/c&gt;</eg>
                <p>The constructed element node has one child, a text node containing the value "<code>123</code>".</p>
              </item>

  <item>
                <p>Example:</p>
                <eg role="parse-test" xml:space="preserve">&lt;b&gt;{1, "2", "3"}&lt;/b&gt;</eg>
                <p>The constructed element node has one child, a text node containing the value "<code>1 2 3</code>".</p>
              </item>

  <item>
                <p>Example:</p>
                <eg role="parse-test" xml:space="preserve">&lt;fact&gt;I saw 8 cats.&lt;/fact&gt;</eg>
                <p>The constructed element node has one child, a text node containing the value "<code>I saw 8 cats.</code>".</p>
              </item>

  <item>
                <p>Example:</p>
                <eg role="parse-test" xml:space="preserve">&lt;fact&gt;I saw {5 + 3} cats.&lt;/fact&gt;</eg>
                <p>The constructed element node has one child, a text node containing the value "<code>I saw 8 cats.</code>".</p>
              </item>

  <item>
                <p>Example:</p>
                <eg role="parse-test" xml:space="preserve">&lt;fact&gt;I saw &lt;howmany&gt;{5 + 3}&lt;/howmany&gt; cats.&lt;/fact&gt;</eg>
                <p>The constructed element node has three children: a text node containing "<code>I saw </code> ", a child element node named <code>howmany</code>, and a text node containing "<code> cats.</code>". The child element node in turn has a single text node child containing the value "<code>8</code>".</p>
              </item>
            </ulist>
          </div4>
          <div4 id="id-whitespace">
            <head>Boundary Whitespace</head>
            <p>In a direct element constructor, whitespace characters may appear in the content of the constructed element. In some cases, enclosed expressions and/or nested elements may be separated only by whitespace characters.   For 
example, in the expression below, the end-tag 
<code>&lt;/title&gt;</code> and the start-tag <code>&lt;author&gt;</code> are separated by a newline character and four space 
characters:</p>
<eg role="parse-test" xml:space="preserve">&lt;book isbn="isbn-0060229357"&gt;
    &lt;title&gt;Harold and the Purple Crayon&lt;/title&gt;
    &lt;author&gt;
        &lt;first&gt;Crockett&lt;/first&gt;
        &lt;last&gt;Johnson&lt;/last&gt;
    &lt;/author&gt;
&lt;/book&gt;</eg>
            <p>
              <termdef term="boundary whitespace" id="dt-boundary-whitespace">
                <term>Boundary whitespace</term> is a
sequence of consecutive whitespace characters within the content of a <termref def="dt-direct-elem-const">direct element constructor</termref>, that is delimited at each end either by the start or
end of the content, or by a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-DirectConstructor" xlink:type="simple">DirectConstructor</nt>, or by an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-EnclosedExpr" xlink:type="simple">EnclosedExpr</nt>. For this purpose, characters generated by
   <termref def="dt-character-reference">character references</termref> such as <code>&amp;#x20;</code> or by <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-CDataSection" xlink:type="simple">CdataSections</nt> are not
   considered to be whitespace characters.</termdef>
            </p>
            <p>The <termref def="dt-boundary-space-policy">boundary-space policy</termref> in the <termref def="dt-static-context">static context</termref> controls whether boundary whitespace is
   preserved by element constructors. If boundary-space policy is <code>strip</code>, boundary whitespace is not considered significant and
   is discarded. On the other hand, if boundary-space policy is <code>preserve</code>, boundary whitespace is
   considered significant and is
   preserved.</p>
<ulist>

  <item>
                <p>Example:</p>
                <eg role="parse-test" xml:space="preserve">&lt;cat&gt; 
   &lt;breed&gt;{$b}&lt;/breed&gt;
   &lt;color&gt;{$c}&lt;/color&gt; 
&lt;/cat&gt;</eg>
                <p>The constructed
   <code>cat</code> element node has two child element nodes named
   <code>breed</code> and <code>color</code>. Whitespace surrounding
   the child elements will be stripped away by the element
   constructor if boundary-space policy is
   <code>strip</code>.</p>
              </item>

  <item>
                <p>Example:</p>
                <eg role="parse-test" xml:space="preserve">&lt;a&gt;  {"abc"}  &lt;/a&gt;</eg>
                <p>If
   boundary-space policy is <code>strip</code>, this example is equivalent to <code role="parse-test">&lt;a&gt;abc&lt;/a&gt;</code>. However, if
   boundary-space policy is <code>preserve</code>, this example is
   equivalent to <code role="parse-test">&lt;a&gt;  abc  &lt;/a&gt;</code>.</p>
              </item>

  <item>
                <p>Example:</p>
                <eg role="parse-test" xml:space="preserve">&lt;a&gt; z {"abc"}&lt;/a&gt;</eg>
                <p>Since the
   whitespace surrounding the <code>z</code> is not boundary
   whitespace, it is always preserved. This example is equivalent to
   <code role="parse-test">&lt;a&gt; z abc&lt;/a&gt;</code>.</p>
              </item>

  <item>
                <p>Example:</p>
                <eg role="parse-test" xml:space="preserve">&lt;a&gt;&amp;#x20;{"abc"}&lt;/a&gt;</eg>
                <p>This
   example is equivalent to <code role="parse-test">&lt;a&gt; abc&lt;/a&gt;</code>, regardless
   of the boundary-space policy, because the space generated by the <termref def="dt-character-reference">character reference</termref> is not treated as a whitespace character.</p>
              </item>

  <item>
                <p>Example:</p>
                <eg role="parse-test" xml:space="preserve">&lt;a&gt;{"  "}&lt;/a&gt;</eg>
                <p>This example constructs an element containing two space characters,
   regardless of the boundary-space policy, because whitespace inside an enclosed expression is never considered to be boundary whitespace.</p>
              </item>
            </ulist>
            <note>
              <p>Element constructors treat attributes named <code>xml:space</code> as ordinary attributes. An <code>xml:space</code> attribute does not affect the handling of whitespace by an element constructor.</p>
            </note>
          </div4>
        </div3>
        <div3 id="id-otherConstructors">
          <head>Other Direct Constructors</head>
          <p>XQuery allows an expression to generate a processing instruction node or a comment node. This can be accomplished by using a <term>direct processing instruction constructor</term> or a <term>direct comment constructor</term>. In each case, the syntax of the constructor expression is
based on the syntax of a similar construct in XML.</p> 
<scrap headstyle="show"> 
<head/> 
 
<prod num="148" id="doc-xquery11-DirPIConstructor">
              <lhs>DirPIConstructor</lhs>
              <rhs>"&lt;?"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-PITarget" xlink:type="simple">PITarget</nt>  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-S" xlink:type="simple">S</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-DirPIContents" xlink:type="simple">DirPIContents</nt>)?  "?&gt;"</rhs>
            </prod>
            <prod num="149" id="doc-xquery11-DirPIContents">
              <lhs>DirPIContents</lhs>
              <rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Char" xlink:type="simple">Char</nt>* - (Char* '?&gt;' Char*))</rhs>
            </prod> 
<prod num="146" id="doc-xquery11-DirCommentConstructor">
              <lhs>DirCommentConstructor</lhs>
              <rhs>"&lt;!--"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-DirCommentContents" xlink:type="simple">DirCommentContents</nt>  "--&gt;"</rhs>
            </prod>
<prod num="147" id="doc-xquery11-DirCommentContents">
              <lhs>DirCommentContents</lhs>
              <rhs>((<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Char" xlink:type="simple">Char</nt> - '-')  |  ('-'  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Char" xlink:type="simple">Char</nt> - '-')))*</rhs>
            </prod>
            <!--prodrecap id="PITarget" ref="PITarget" not included here
because it invalidates the document.--> 
</scrap> 
<p>A direct processing instruction constructor creates a processing instruction node whose <code>target</code> property is <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-PITarget" xlink:type="simple">PITarget</nt> and whose <code>content</code> property is <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-DirPIContents" xlink:type="simple">DirPIContents</nt>. The <code>base-uri</code> property of the node is empty.  The <code>parent</code> property of the node is empty.</p>
          <p>The <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-PITarget" xlink:type="simple">PITarget</nt> of a processing instruction must not consist of the characters "XML" in any combination of upper and lower case. The <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-DirPIContents" xlink:type="simple">DirPIContents</nt> of a processing instruction must not contain the string "<code>?&gt;</code>".</p>
          <p>The following example illustrates a direct processing instruction constructor:</p> 
<eg role="parse-test" xml:space="preserve">&lt;?format role="output" ?&gt;</eg>
          <p>A direct comment constructor creates a comment node whose  <code>content</code> property is <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-DirCommentContents" xlink:type="simple">DirCommentContents</nt>. Its <code>parent</code> property is empty.</p>
          <p>The <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-DirCommentContents" xlink:type="simple">DirCommentContents</nt> of a comment must not contain two consecutive hyphens or end with a hyphen. These rules are syntactically enforced by the grammar shown above.</p> 
<p>The following example illustrates a direct comment constructor:</p>
          <eg role="parse-test" xml:space="preserve">&lt;!-- Tags are ignored in the following section --&gt;</eg>
          <note>
            <p>A direct comment constructor is different from a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Comment" xlink:type="simple">comment</nt>, since a direct comment constructor actually constructs a comment node, whereas a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Comment" xlink:type="simple">comment</nt> is simply used in documenting a query and is not evaluated.</p>
          </note> 
 
 
 
</div3>

<!--

2. New Section: Computed Namespace Constructors

A computed namespace constructor creates a [namespace node](DM) that
has no parent. Computed namespace constructors are usually used in the
[content expression of an element constructor].


CompNamespaceConstructor ::= "namespace" (Prefix | ("{" PrefixExpr "}"))
"{" UriExpr? "}"
Prefix ::= NCName
PrefixExpr ::= Expr
URIExpr ::= Expr

The URIExpr is evaluated, and the result is used as the URI for the
newly created namespace node. If the constructor specifies a Prefix,
it is used as the prefix for the namespace node; if the constructor
specifies a PrefixExpr, the result of evaluating the PrefixExpr is
used as the prefix for the namespace node. If the PrefixExpr evaluates
to an empty sequence or an empty string, the namespace node has an
empty prefix. The parent of the namespace node is empty.

[MK] The PrefixExpr MUST NOT evaluate to "xml" or "xmlns" (error err:#####).

By itself, a computed namespace constructor has no effect on in-scope
namespaces, but if an element constructor's content sequence contains
a namespace node, the namespace binding it represents is added to the
elements in-scope namespaces.

A computed namespace constructor has no effect on the statically known
namespaces.

Note:

   The newly created namespace node has all properties defined for a
   namespace node in the data model. Like all nodes, it has
   identity. Like all nodes who do not share a common parent, the
   relative order of these nodes is implementation dependent. As
   defined in the data model, the name of the node is the prefix, and
   the string value of the node is the URI.

Examples:

A computed namespace constructor with a prefix:

   namespace a {"http://a.example.com" }

A computed namespace constructor with a prefix expression:

   namespace {"a"} {"http://a.example.com" }

A computed namespace constructor with an empty prefix:

   namespace { "" } {"http://a.example.com" }

Computed namespace constructors are generally used to add to the
in-scope namespaces of elements created with element constructors:

  <form>
   {
      namespace a {"http://a.example.com" },
      attribute { xs:QName("a:id") } { "a-12-XE-45" },
      element { xs:QName("a:field")} { "Sample data" }
   }
  </form>

Computed namespace constructors have no effect on the statically known
namespaces. If the prefix a is not already defined in the statically
known namespaces, the following expression results in a static error
[err:XPST0081].

<a:form>
 {
  namespace a { "http://a.example.com" }
 }
</a:form>



3. Changes to element constructors:


3.7.4 In-scope Namespaces of a Constructed Element
http://www.w3.org/TR/xquery/#id-ns-nodes-on-elements

To the bulleted list, add:

* A namespace binding is created for each namespace node in the
  context sequence of the current element constructor.

Below the bulleted list, add:

[MK] In an element constructor, if two or more namespace bindings in the 
in-scope bindings would have the same prefix, then an error is raised if 
they have different URIs (err:#####); if they would have the same prefix 
and URI, duplicate bindings are ignored.


4. Changes to 3.7.1.3 Content

[MK] Change bullet point 4 to:

If the content sequence contains an attribute node <new>or a namespace 
node</new> following a node that is not an attribute node <new>or a 
namespace node</new>, a type error is raised [err:XQTY0024].

5. Changes to 3.7.3.1 Computed Element Constructors

[MK] Change bullet point 3 to:

If the content sequence contains an attribute node <new>or a namespace 
node</new> following a node that is not an attribute node <new>or a 
namespace node</new>, a type error is raised [err:XQTY0024].
-->

<div3 id="id-computedConstructors">
          <head>Computed Constructors</head>

<scrap headstyle="show">
            <head/>
<prod num="152" id="doc-xquery11-ComputedConstructor">
              <lhs>ComputedConstructor</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-CompDocConstructor" xlink:type="simple">CompDocConstructor</nt>
                <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-CompElemConstructor" xlink:type="simple">CompElemConstructor</nt>
                <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-CompAttrConstructor" xlink:type="simple">CompAttrConstructor</nt>
                <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-CompNamespaceConstructor" xlink:type="simple">CompNamespaceConstructor</nt>
                <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-CompTextConstructor" xlink:type="simple">CompTextConstructor</nt>
                <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-CompCommentConstructor" xlink:type="simple">CompCommentConstructor</nt>
                <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-CompPIConstructor" xlink:type="simple">CompPIConstructor</nt>
              </rhs>
            </prod>
          </scrap>

<p>An alternative way to create nodes is by using a <term id="term-elem-ctor">computed constructor</term>. A computed
constructor begins with a keyword that identifies the type of node to
be created: <code>element</code>, <code>attribute</code>,
<code>document</code>, <code>text</code>,
<code>processing-instruction</code>, <code>comment</code>, or
<code>namespace</code>.</p>

<p>For those kinds of nodes that have names (element, attribute, and
processing instruction nodes), the keyword that specifies the node
kind is followed by the name of the node to be created. This name may
be specified either as an EQName or as an expression enclosed in
braces. <termdef term="name expression" id="dt-name-expression">When
an expression is used to specify the name of a constructed node, that
expression is called the <term>name expression</term> of the
constructor.</termdef>
          </p>

<p>
            <termdef id="dt-content-expression" term="content expression">The
final part of a computed constructor is an expression enclosed in
braces, called the <term>content expression</term> of the constructor,
that generates the content of the node.</termdef>
          </p>

<p>The following example illustrates the use of computed element and
attribute constructors in a simple case where the names of the
constructed nodes are constants. This example generates exactly the
same result as the first example in <specref ref="id-element-constructor"/>:</p>

<eg role="parse-test" xml:space="preserve">element book { 
   attribute isbn {"isbn-0060229357" }, 
   element title { "Harold and the Purple Crayon"},
   element author { 
      element first { "Crockett" }, 
      element last {"Johnson" }
   }
}</eg>

<div4 id="id-computedElements">
            <head>Computed Element Constructors</head>

<scrap headstyle="show"> <head/> 
<prod num="154" id="doc-xquery11-CompElemConstructor">
                <lhs>CompElemConstructor</lhs>
                <rhs>"element"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-EQName" xlink:type="simple">EQName</nt>  |  ("{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Expr" xlink:type="simple">Expr</nt>  "}"))  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ContentExpr" xlink:type="simple">ContentExpr</nt>?  "}"</rhs>
              </prod>    
<prod num="155" id="doc-xquery11-ContentExpr">
                <lhs>ContentExpr</lhs>
                <rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Expr" xlink:type="simple">Expr</nt>
                </rhs>
              </prod>
            </scrap>

<p>
              <termdef term="computed element constructor" id="dt-computed-elem-const">A <term>computed element constructor</term> creates an element node, allowing both the name and the content of the node to be computed.</termdef>
            </p>
            <p>If the keyword <code>element</code> is followed by a <termref def="dt-qname">lexical QName</termref>, it is expanded using the <termref def="dt-static-namespaces">statically known namespaces</termref>, and the resulting <termref def="dt-expanded-qname">expanded QName</termref> is used as the <code>node-name</code> property of the constructed element node. If expansion of the QName is not successful, a <termref def="dt-static-error">static error</termref> is raised <errorref code="0081" class="ST"/>.</p>
            <p>If the keyword <code>element</code> is followed by a <termref def="dt-name-expression">name expression</termref>, the name expression is processed as follows:</p>

<olist>

  <item>
                <p>
                  <termref def="dt-atomization">Atomization</termref> is applied to the value of the <termref def="dt-name-expression">name expression</termref>. If the result of atomization is not a single atomic value of type <code>xs:QName</code>, <code>xs:string</code>, or <code>xs:untypedAtomic</code>, a <termref def="dt-type-error">type
   error</termref> is raised <errorref class="TY" code="0004"/>.</p>
              </item>

  <item>
                <p>If the atomized value of the <termref def="dt-name-expression">name expression</termref> is of type
   <code>xs:QName</code>, that <termref def="dt-expanded-qname">expanded QName</termref> is used as the <code>node-name</code> property of the constructed
   element, retaining the prefix part of the QName.</p>
              </item>

  <item>
                <p>If the atomized value of the <termref def="dt-name-expression">name expression</termref> is of type <code>xs:string</code> or <code>xs:untypedAtomic</code>, that value is converted to an <termref def="dt-expanded-qname">expanded QName</termref>. If the string value contains a namespace prefix, that prefix is <termref def="dt-resolve-relative-uri">resolved to a namespace URI</termref> using the <termref def="dt-static-namespaces">statically known namespaces</termref>. If the string value contains  no namespace prefix, it is treated as a local name in  the <termref def="dt-def-elemtype-ns">default element/type namespace</termref>. The resulting <termref def="dt-expanded-qname">expanded QName</termref> is used as the <code>node-name</code> property of the constructed
   element, retaining the prefix part of the QName. If conversion of the atomized <termref def="dt-name-expression">name expression</termref> to an <termref def="dt-expanded-qname">expanded QName</termref> is not successful, a <termref def="dt-dynamic-error">dynamic error</termref> is raised <errorref class="DY" code="0074"/>.</p>
              </item>
            </olist>

<!--	<change diff="add" at="XQ.E19"> -->
          <p>A <termref def="dt-dynamic-error">dynamic error</termref> is raised 
             <errorref class="DY" code="0096"/> if the node-name of the constructed 
             element node has any of the following properties:
          </p>
          <ulist>
             <item>
                <p>Its namespace prefix is <code>xmlns</code>.
             </p>
              </item>
             <item>
                <p>Its namespace URI is <code>http://www.w3.org/2000/xmlns/</code>.
             </p>
              </item>
             <item>
                <p>Its namespace prefix is <code>xml</code> and its namespace 
                URI is not <code>http://www.w3.org/XML/1998/namespace</code>.
             </p>
              </item>
             <item>
                <p>Its namespace prefix is other than <code>xml</code> and its 
                namespace URI is <code>http://www.w3.org/XML/1998/namespace</code>.
             </p>
              </item>
          </ulist>
<!--	</change> -->


<p>The <termref def="dt-content-expression">content expression</termref> of a computed element constructor (if present) is processed in exactly the same way as an enclosed expression in the content of a <termref def="dt-direct-elem-const">direct element constructor</termref>, as described in Step 1e of <specref ref="id-content"/>. The result of processing the content expression is a sequence of nodes called the <term>content sequence</term>. If the <termref def="dt-content-expression">content expression</termref> is absent, the content sequence is an empty sequence.</p>
            <p>Processing of the computed element constructor proceeds as follows:</p>

<olist>

<item diff="chg" at="XQ.E2">
                <p>If the content sequence contains a document node, the document node is replaced in the content sequence by its children.</p>
              </item>
<item diff="chg" at="XQ.E2">
                <p>Adjacent text nodes in the content sequence are merged into a single text node by concatenating their contents, with no intervening blanks. After concatenation, any text node whose content is a zero-length string is deleted from the content sequence.</p>
              </item>

  <item>
                <p> If the content
   sequence contains an attribute node or a namespace node following a node that is not an
   attribute node or a namespace node, a <termref def="dt-type-error">type error</termref>
   is raised <errorref class="TY" code="0024"/>.</p>
              </item>

  <item>
                <p>The properties of the newly constructed element node are determined as follows:</p>

<olist>

  <item>
                    <p>
                      <code>node-name</code> is the <termref def="dt-expanded-qname">expanded QName</termref> resulting from processing the specified <termref def="dt-qname">lexical QName</termref> or <termref def="dt-name-expression">name expression</termref>, as described above.</p>
                  </item>

  <item>
                    <p>
                      <code>parent</code> is empty.</p>
                  </item>

  <item>
                    <p>
                      <code>attributes</code> consist of all the attribute nodes in the content sequence, in <termref def="dt-implementation-dependent">implementation-dependent</termref> order. Note that the <code>parent</code> property of each of these attribute nodes has been set to the newly constructed element node. If two or more  attributes have the same <code>node-name</code>,  a <termref def="dt-dynamic-error">dynamic error</termref> is raised <errorref class="DY" code="0025"/>. If an attribute named <code>xml:space</code> has a value other than <code>preserve</code> or <code>default</code>, a dynamic error may be raised <errorref code="0092" class="DY"/>.</p>
                  </item>

  <item>
                    <p>
                      <code>children</code> consist of all the element, text, comment, and processing
   instruction nodes in the content sequence. Note that the <code>parent</code> property of each of these nodes has been set to the newly constructed element node.</p>
                  </item>

  <item>
                    <p>
                      <code>base-uri</code> is set to the following value:

<olist>

  <item>
                          <p>If the constructed node has an
attribute named <code>xml:base</code>, then the value of this attribute,  <termref def="dt-resolve-relative-uri">resolved (if it is relative)</termref> against the <termref def="dt-base-uri">base URI</termref> in the <termref def="dt-base-uri">static context</termref>. The value of the <code>xml:base</code> attribute is normalized as described in <bibref ref="XMLBASE"/>.</p>
                        </item>

  <item>
                          <p>Otherwise, the value of the <termref def="dt-base-uri">base URI</termref> in the <termref def="dt-base-uri">static context</termref>.</p>
                        </item>
                      </olist>
                    </p>
                  </item>

  <item>
                    <p>
                      <code>in-scope-namespaces</code> are computed as described in <specref ref="id-ns-nodes-on-elements"/>.</p>
                  </item>

  <item>
                    <p>The <code>nilled</code> property is <code>false</code>.</p>
                  </item>

  <item>
                    <p>The <code>string-value</code> property is equal to the concatenated contents of the text-node descendants in document order.</p>
                  </item>

  <item>
                    <p>The <code>typed-value</code> property is equal to the <code>string-value</code> property, as an instance of <code>xs:untypedAtomic</code>.</p>
                  </item>

  <item>
                    <p>If <termref def="dt-construction-mode">construction mode</termref> in the <termref def="dt-static-context">static context</termref> is <code>strip</code>, the <code>type-name</code> property is <code>xs:untyped</code>. On the other hand, if construction mode is <code>preserve</code>, the <code>type-name</code> property is <code>xs:anyType</code>.</p>
                  </item>

  <item>
                    <p>The <code>is-id</code> and <code>is-idrefs</code> properties are set to <code>false</code>.</p>
                  </item>
                </olist>
              </item>
            </olist> <p>A computed element constructor might be
   used to make a modified copy of an existing element. For example,
   if the variable <code>$e</code> is bound to an element with <termref def="dt-numeric">numeric</termref>
   content, the following constructor might be used to create a new
   element with the same name and attributes as <code>$e</code> and
   with numeric content equal to twice the value of
   <code>$e</code>:</p>
            <eg role="parse-test" xml:space="preserve">element {fn:node-name($e)}
   {$e/@*, 2 * fn:data($e)}</eg>
            <p>In this example, if <code>$e</code> is
   bound by the expression <code>let $e := &lt;length
   units="inches"&gt;{5}&lt;/length&gt;</code>, then the result of the
   example expression is the element <code>&lt;length
   units="inches"&gt;10&lt;/length&gt;</code>.</p>
            <note>
              <p>The <termref def="dt-static-type">static type</termref> of the expression <code role="parse-test">fn:node-name($e)</code> is <code>xs:QName?</code>, denoting zero or one QName. Therefore, if the <termref def="dt-static-typing-feature">Static Typing Feature</termref> is in effect, the above example raises a static type error, since the name expression in a computed element constructor is required to return exactly one string or QName. In order to avoid the static type error, the name expression <code role="parse-test">fn:node-name($e)</code> could be rewritten as <code role="parse-test">fn:exactly-one(fn:node-name($e))</code>. If the <termref def="dt-static-typing-feature">Static Typing Feature</termref> is not in effect, the example can be successfully evaluated as written, provided that <code>$e</code> is bound to exactly one element node with numeric content.</p>
            </note>
            <p>One important
   purpose of computed constructors is to allow the name of a node to
   be computed. We will illustrate this feature by an expression that
   translates the name of an element from one language to
   another. Suppose that the variable <code>$dict</code> is bound to a
   <code>dictionary</code> element containing a sequence of <code>entry</code> elements, each of which encodes translations for a specific word.  Here is an example
   entry that encodes the German and Italian variants of the word "address":</p> <eg role="parse-test" xml:space="preserve">
&lt;entry word="address"&gt;
   &lt;variant xml:lang="de"&gt;Adresse&lt;/variant&gt;
   &lt;variant xml:lang="it"&gt;indirizzo&lt;/variant&gt;
&lt;/entry&gt; 
</eg> 
<p>Suppose further that the variable <code>$e</code> is bound to the following element:</p> 
<eg role="parse-test" xml:space="preserve">&lt;address&gt;123 Roosevelt Ave. Flushing, NY 11368&lt;/address&gt;</eg> 
<p>Then the following expression generates a new element in which the name of <code>$e</code> has been translated into Italian and the content of <code>$e</code> (including its attributes, if any) has been preserved. The first enclosed expression after the <code>element</code> keyword generates the name of the element, and the second enclosed
expression generates the content and attributes:</p> 
<eg role="parse-test" xml:space="preserve">
  element 
    {$dict/entry[@word=name($e)]/variant[@xml:lang="it"]}
    {$e/@*, $e/node()}</eg> 
<p>The result of this expression is as follows:</p> 
<eg role="parse-test" xml:space="preserve">&lt;indirizzo&gt;123 Roosevelt Ave. Flushing, NY 11368&lt;/indirizzo&gt;</eg> 
<note>
              <p>As in the previous example, if the <termref def="dt-static-typing-feature">Static Typing Feature</termref> is in effect, the enclosed expression that computes the element name in the above computed element constructor must be wrapped in a call to the <code>fn:exactly-one</code> function in order to avoid a static type error.</p>
            </note>
            <p>Additional examples of computed element constructors can be found
   in <specref ref="id-recursive-transformations"/>.</p>
          </div4>

<div4 id="id-computedAttributes">
            <head>Computed Attribute
   Constructors</head>
            <scrap headstyle="show"> <head/> 
   <prod num="156" id="doc-xquery11-CompAttrConstructor">
                <lhs>CompAttrConstructor</lhs>
                <rhs>"attribute"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-EQName" xlink:type="simple">EQName</nt>  |  ("{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Expr" xlink:type="simple">Expr</nt>  "}"))  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Expr" xlink:type="simple">Expr</nt>?  "}"</rhs>
              </prod> 
   </scrap>

   <p>A computed attribute constructor creates a new attribute node,
   with its own node identity.</p>

   <p>If the keyword <code>attribute</code> is followed by a <termref def="dt-qname">lexical QName</termref>, that QName is expanded
   using the <termref def="dt-static-namespaces">statically known
   namespaces</termref>, and the resulting <termref def="dt-expanded-qname">expanded QName</termref> (including its
   prefix) is used as the <code>node-name</code> property of the
   constructed attribute node. If expansion of the QName is not
   successful, a <termref def="dt-static-error">static error</termref>
   is raised <errorref code="0081" class="ST"/>.</p>

   <p>If the keyword <code>attribute</code> is followed by a <termref def="dt-name-expression">name expression</termref>, the name
   expression is processed as follows:</p>


<olist>
     

  <item>
                <p>
                  <termref def="dt-atomization">Atomization</termref> is
     applied to the result of the <termref def="dt-name-expression">name expression</termref>. If the result
     of <termref def="dt-atomization">atomization</termref> is not a
     single atomic value of type <code>xs:QName</code>,
     <code>xs:string</code>, or <code>xs:untypedAtomic</code>, a
     <termref def="dt-type-error">type error</termref> is raised
     <errorref class="TY" code="0004"/>.</p>
              </item>
   
     

<item diff="chg" at="XQ.E9">
                <p>If the atomized value of the <termref def="dt-name-expression">name expression</termref> is of type
   <code>xs:QName</code>:</p>
<olist>
<item>
                    <p>If the <termref def="dt-expanded-qname">expanded QName</termref> returned by the atomized name expression has a namespace URI but has no prefix, it is given an <termref def="dt-implementation-dependent">implementation-dependent</termref> prefix.</p>
                    <note>
                      <p>This step is necessary because attributes have no default namespace. Therefore any attribute name that has a namespace URI must also have a prefix.</p>
                    </note>
                  </item>

<item>
                    <p>The resulting <termref def="dt-expanded-qname">expanded QName</termref> (including its prefix) is used as the <code>node-name</code> property of the constructed
attribute node.</p>
                  </item>
                </olist>
</item>
     

  <item>
                <p>If the atomized value of the <termref def="dt-name-expression">name expression</termref> is of type
     <code>xs:string</code> or <code>xs:untypedAtomic</code>, that
     value is converted to an <termref def="dt-expanded-qname">expanded QName</termref>. If the string
     value contains a namespace prefix, that prefix is resolved to a
     namespace URI using the <termref def="dt-static-namespaces">statically known
     namespaces</termref>. If the string value contains no namespace
     prefix, it is treated as a local name in no namespace. The
     resulting <termref def="dt-expanded-qname">expanded
     QName</termref> (including its prefix) is used as the
     <code>node-name</code> property of the constructed attribute. If
     conversion of the atomized <termref def="dt-name-expression">name
     expression</termref> to an <termref def="dt-expanded-qname">expanded QName</termref> is not
     successful, a <termref def="dt-dynamic-error">dynamic
     error</termref> is raised <errorref class="DY" code="0074"/>.</p>
              </item>

   </olist>

<!--	<change diff="chg" at="XQ.E19"> -->
          <p>A <termref def="dt-dynamic-error">dynamic error</termref> is raised 
             <errorref class="DY" code="0044"/> if the node-name of the constructed 
             attribute node has any of the following properties:
          </p>
          <ulist>
             <item>
                <p>Its namespace prefix is <code>xmlns</code>.
             </p>
              </item>
             <item>
                <p>It has no namespace prefix and its local name is 
                <code>xmlns</code>.
             </p>
              </item>
             <item>
                <p>Its namespace URI is <code>http://www.w3.org/2000/xmlns/</code>.
             </p>
              </item>
             <item>
                <p>Its namespace prefix is <code>xml</code> and its namespace 
                URI is not <code>http://www.w3.org/XML/1998/namespace</code>.
             </p>
              </item>
             <item>
                <p>Its namespace prefix is other than <code>xml</code> and its 
                namespace URI is <code>http://www.w3.org/XML/1998/namespace</code>.
             </p>
              </item>
          </ulist>
<!--	</change> -->

   <p>The <termref def="dt-content-expression">content
   expression</termref> of a computed attribute constructor is
   processed as follows:</p>

   

<olist>
     

  <item>
                <p>
                  <termref def="dt-atomization">Atomization</termref> is
     applied to the result of the <termref def="dt-content-expression">content expression</termref>,
     converting it to a sequence of atomic values. (If the <termref def="dt-content-expression">content expression</termref> is
     absent, the result of this step is an empty
     sequence.)</p>
              </item>

     

  <item>
                <p>If the result of atomization is an empty sequence, the
     value of the attribute is the zero-length string. Otherwise, each
     atomic value in the atomized sequence is cast into a
     string.</p>
              </item>

     

  <item>
                <p>The individual strings resulting from the previous step
     are merged into a single string by concatenating them with a
     single space character between each pair. The resulting string
     becomes the <code>string-value</code> property of the new
     attribute node. The <termref def="dt-type-annotation">type
     annotation</termref> (<code>type-name</code> property) of the new
     attribute node is <code>xs:untypedAtomic</code>. The
     <code>typed-value</code> property of the attribute node is the
     same as its <code>string-value</code>, as an instance of
     <code>xs:untypedAtomic</code>.</p>
              </item>

     

  <item>
                <p>The <code>parent</code> property of the attribute node
     is set to empty.</p>
              </item>

     

  <item>
                <p>If the attribute name is <code>xml:id</code>, then
     <code>xml:id</code> processing is performed as defined in <bibref ref="XMLID"/>. This ensures that the attribute node has the type
     <code>xs:ID</code> and that its value is properly normalized. If
     an error is encountered during <code>xml:id</code> processing, an
     implementation may raise a <termref def="dt-dynamic-error">dynamic error</termref> <errorref class="DY" code="0091"/>.</p>
              </item>

     

  <item>
                <p>If the attribute name is <code>xml:id</code>, the
     <code>is-id</code> property of the resulting attribute node is
     set to <code>true</code>; otherwise the <code>is-id</code>
     property is set to <code>false</code>. The <code>is-idrefs</code>
     property of the attribute node is unconditionally set to
     <code>false</code>.</p>
              </item>

     

  <item>
                <p>If the attribute name is <code>xml:space</code> and the
     attribute value is other than <code>preserve</code> or
     <code>default</code>, a dynamic error <termref def="may">MAY</termref> be raised <errorref code="0092" class="DY"/>.</p>
              </item>
            </olist>
<ulist>

     

  <item>
                <p>Example:</p>

    <eg role="parse-test" xml:space="preserve">attribute size {4 + 3}</eg>

    <p>The <termref def="dt-string-value">string
     value</termref> of the <code>size</code> attribute is
     "<code>7</code>" and its type is
     <code>xs:untypedAtomic</code>.</p>
              </item>

     

  <item>
                <p>Example:</p>

<eg role="parse-test" xml:space="preserve">
attribute  
   { if ($sex = "M") then "husband" else "wife" } 
   { &lt;a&gt;Hello&lt;/a&gt;, 1 to 3, &lt;b&gt;Goodbye&lt;/b&gt; }
</eg>

    <p>The name of the constructed attribute is
     either <code>husband</code> or
     <code>wife</code>. Its <termref def="dt-string-value">string
     value</termref> is "<code>Hello 1 2 3
     Goodbye</code>".</p>
              </item>
            </ulist>
          </div4>


<div4 id="id-documentConstructors">



  <head>Document Node Constructors</head>

<scrap headstyle="show"> <head/>
    <prod num="153" id="doc-xquery11-CompDocConstructor">
                <lhs>CompDocConstructor</lhs>
                <rhs>"document"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Expr" xlink:type="simple">Expr</nt>  "}"</rhs>
              </prod>
   </scrap>
            <p>All document node constructors are computed constructors. The result of a document node constructor is a new document node, with its own node identity.</p>
            <p>A document node constructor is useful when the result of a query is to be a document in its own right. The following example illustrates a query that returns an XML document containing a root element named <code>author-list</code>:</p>

<eg role="parse-test" xml:space="preserve">document
  {
      &lt;author-list&gt;
         {fn:doc("bib.xml")/bib/book/author}
      &lt;/author-list&gt;
  }</eg>

<p>The <termref def="dt-content-expression">content expression</termref> of a document node constructor is processed in exactly the same way as an enclosed expression in the content of a <termref def="dt-direct-elem-const">direct element constructor</termref>, as described in Step 1e of <specref ref="id-content"/>. The result of processing the content expression is a sequence of nodes called the <term>content sequence</term>. Processing of the document node constructor then proceeds as follows:</p>

<olist>

<item diff="chg" at="XQ.E2">
                <p>If the content sequence contains a document node, the document node is replaced in the content sequence by its children.</p>
              </item>
<item diff="chg" at="XQ.E2">
                <p>Adjacent text nodes in the content sequence are merged into a single text node by concatenating their contents, with no intervening blanks. After concatenation, any text node whose content is a zero-length string is deleted from the content sequence.</p>
              </item>



  <item>
                <p> If the content sequence contains an attribute node, a
<termref def="dt-type-error">type error</termref> is raised <errorref class="TY" code="0004"/>.</p>
              </item>



  <item>
                <p> If the content sequence contains a namespace node, a
<termref def="dt-type-error">type error</termref> is raised <errorref class="TY" code="0004"/>.</p>
              </item>




  <item>
                <p>The properties of the newly constructed document node are determined as follows:</p>

<olist>

  <item>
                    <p>
                      <code>base-uri</code> is taken from <termref def="dt-base-uri">base URI</termref> in the <termref def="dt-base-uri">static context</termref>. If no base URI is defined in the static context, the <code>base-uri</code> property is empty.</p>
                  </item>

  <item>
                    <p>
                      <code>children</code> consist of all the element, text, comment, and processing
   instruction nodes in the content sequence. Note that the <code>parent</code> property of each of these nodes has been set to the newly constructed document node.</p>
                  </item>

  <item>
                    <p>The <code>unparsed-entities</code> and <code>document-uri</code> properties are empty.</p>
                  </item>

  <item>
                    <p>The <code>string-value</code> property is equal to the concatenated contents of the text-node descendants in document order.</p>
                  </item>

  <item>
                    <p>The <code>typed-value</code> property is equal to the <code>string-value</code> property, as an instance of <code>xs:untypedAtomic</code>.</p>
                  </item>
                </olist>
              </item>
            </olist>
            <p>No validation is performed on the constructed document node. The <bibref ref="XML"/> rules that govern the structure of an XML document (for example, the document node must have exactly one child that is an element node)  are not enforced by the XQuery document node constructor.</p>
          </div4>
          <div4 id="id-textConstructors">
            <head>Text Node Constructors</head>
            <scrap headstyle="show"> <head/> 
    <prod num="161" id="doc-xquery11-CompTextConstructor">
                <lhs>CompTextConstructor</lhs>
                <rhs>"text"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Expr" xlink:type="simple">Expr</nt>  "}"</rhs>
              </prod>
   </scrap>
            <p>All text node constructors are computed constructors. The result of a text node constructor is a new text node, with its own node identity.</p>
            <p>The <termref def="dt-content-expression">content expression</termref> of a text node constructor is processed as follows:</p>

<olist>

  <item>
                <p>
                  <termref def="dt-atomization">Atomization</termref> is applied to the value of the <termref def="dt-content-expression">content expression</termref>, converting it to a sequence of atomic values.</p>
              </item>

  <item>
                <p>If the result of atomization is an empty sequence, no text node is constructed. Otherwise, each atomic value in the atomized sequence is cast into a string.</p>
              </item>

  <item>
                <p>The individual strings resulting from the previous step are merged into a single string by concatenating them with a single space character between each pair. The resulting string becomes the <code>content</code> property of the constructed text node.</p>
              </item>
            </olist>
            <p>The <code>parent</code> property of the constructed text node is set to empty.</p>
            <note>
              <p>It is possible for a text node constructor to construct a text node containing a zero-length string. However, if used in the content of a constructed element or document node, such a text node will be deleted or merged with another text node.</p>
            </note>
            <p>The following example illustrates a text node constructor:</p>
            <eg role="parse-test" xml:space="preserve">text {"Hello"}</eg>
          </div4>
          <div4 id="id-computed-pis">
            <head>Computed Processing Instruction Constructors</head>
            <scrap headstyle="show"> <head/> 
    
   <prod num="163" id="doc-xquery11-CompPIConstructor">
                <lhs>CompPIConstructor</lhs>
                <rhs>"processing-instruction"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-NCName" xlink:type="simple">NCName</nt>  |  ("{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Expr" xlink:type="simple">Expr</nt>  "}"))  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Expr" xlink:type="simple">Expr</nt>?  "}"</rhs>
              </prod>
            </scrap>
            <p>A computed processing instruction constructor (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-CompPIConstructor" xlink:type="simple">CompPIConstructor</nt>) constructs a new processing instruction node with its own node identity.
   </p>
            <p>If the keyword <code>processing-instruction</code> is followed by an NCName, that NCName is used as the <code>target</code> property of the constructed  node. If the keyword <code>processing-instruction</code> is followed by a <termref def="dt-name-expression">name expression</termref>, the name expression is processed as follows:</p>

<olist>

  <item>
                <p>
                  <termref def="dt-atomization">Atomization</termref> is applied to the value of the <termref def="dt-name-expression">name expression</termref>. If the result of <termref def="dt-atomization">atomization</termref> is not a single atomic value of type <code>xs:NCName</code>, <code>xs:string</code>, or <code>xs:untypedAtomic</code>, a <termref def="dt-type-error">type
   error</termref> is raised <errorref class="TY" code="0004"/>.</p>
              </item>

  <item>
                <p>If the atomized value of the <termref def="dt-name-expression">name expression</termref> is of type <code>xs:string</code> or <code>xs:untypedAtomic</code>, that value is cast to the type <code>xs:NCName</code>. If the value cannot be cast to <code>xs:NCName</code>, a <termref def="dt-dynamic-error">dynamic error</termref> is raised <errorref class="DY" code="0041"/>.</p>
              </item>

  <item>
                <p>The resulting NCName is then used as the <code>target</code> property of the newly constructed processing instruction node. However, a <termref def="dt-dynamic-error">dynamic error</termref>   is raised if the  NCName is equal to "<code>XML</code>" (in any combination of upper and lower case) <errorref class="DY" code="0064"/>.</p>
              </item>
            </olist>
            <p>The
   <termref def="dt-content-expression">content expression</termref> of a computed processing instruction constructor
   is processed as follows:</p>

<olist>

  <item>
                <p>
                  <termref def="dt-atomization">Atomization</termref> is applied to the value of the <termref def="dt-content-expression">content expression</termref>, converting it to a sequence of atomic values. (If the <termref def="dt-content-expression">content expression</termref> is absent, the result of this step is an empty sequence.)</p>
              </item>

  <item>
                <p>If the result of atomization is an empty sequence, it is replaced by a zero-length string. Otherwise, each atomic value in the atomized sequence is cast into a string. If any of the resulting strings contains the string "<code>?&gt;</code>", a <termref def="dt-dynamic-error">dynamic error</termref> <errorref class="DY" code="0026"/> is raised.</p>
              </item>

  <item>
                <p>The individual strings resulting from the previous step are merged into a single string by concatenating them with a single space character between each pair. Leading whitespace is removed from the resulting string. The resulting string then becomes the <code>content</code> property of the constructed processing instruction node.</p>
              </item>
            </olist>
            <p>The remaining properties of the new processing instruction node are determined as follows:</p>

<olist>

  <item>
                <p>The <code>parent</code> property is empty.</p>
              </item>

  <item>
                <p>The <code>base-uri</code> property is empty.</p>
              </item>
            </olist>
            <p>The following example illustrates a computed processing instruction constructor:</p>
            <eg role="parse-test" xml:space="preserve">let $target := "audio-output",
    $content := "beep" 
return processing-instruction {$target} {$content}</eg>
            <p>The processing instruction node constructed by this example might be serialized as follows:</p>
            <eg xml:space="preserve">&lt;?audio-output beep?&gt;</eg>
          </div4>

<div4 id="id-computed-comments">
            <head>Computed Comment Constructors</head>
            <scrap headstyle="show"> <head/>     
   <prod num="162" id="doc-xquery11-CompCommentConstructor">
                <lhs>CompCommentConstructor</lhs>
                <rhs>"comment"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Expr" xlink:type="simple">Expr</nt>  "}"</rhs>
              </prod>
            </scrap>
            <p>A computed comment constructor (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-CompCommentConstructor" xlink:type="simple">CompCommentConstructor</nt>) constructs a new comment node with its own node identity.
   The <termref def="dt-content-expression">content expression</termref> of a computed comment constructor is processed as follows:</p>

<olist>

  <item>
                <p>
                  <termref def="dt-atomization">Atomization</termref> is applied to the value of the <termref def="dt-content-expression">content expression</termref>, converting it to a sequence of atomic values.</p>
              </item>

  <item>
                <p>If the result of atomization is an empty sequence, it is replaced by a zero-length string. Otherwise, each atomic value in the atomized sequence is cast into a string.</p>
              </item>

  <item>
                <p>The individual strings resulting from the previous step are merged into a single string by concatenating them with a single space character between each pair. The resulting string becomes the <code>content</code> property of the constructed comment node.</p>
              </item>

  <item>
                <p>It is a <termref def="dt-dynamic-error">dynamic
 error</termref> <errorref class="DY" code="0072"/> if the result of the <termref def="dt-content-expression">content expression</termref> of a computed comment constructor contains two adjacent hyphens or ends with a hyphen.</p>
              </item>
            </olist>
            <p>The <code>parent</code> property of the constructed comment node is set to empty.</p>
            <p>The following example illustrates a computed comment constructor:</p>
            <eg role="parse-test" xml:space="preserve">let $homebase := "Houston" 
return comment {fn:concat($homebase, ", we have a problem.")}</eg>
            <p>The comment node constructed by this example might be serialized as follows:</p>
            <eg xml:space="preserve">&lt;!--Houston, we have a problem.--&gt;</eg>
          </div4>



<div4 id="id-computed-namespaces">
<head>Computed Namespace Constructors</head>
<scrap headstyle="show"> <head/> 
<prod num="157" id="doc-xquery11-CompNamespaceConstructor">
                <lhs>CompNamespaceConstructor</lhs>
                <rhs>"namespace"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Prefix" xlink:type="simple">Prefix</nt>  |  ("{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-PrefixExpr" xlink:type="simple">PrefixExpr</nt>  "}"))  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-URIExpr" xlink:type="simple">URIExpr</nt>?  "}"</rhs>
              </prod>    
<prod num="159" id="doc-xquery11-PrefixExpr">
                <lhs>PrefixExpr</lhs>
                <rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Expr" xlink:type="simple">Expr</nt>
                </rhs>
              </prod>
<prod num="160" id="doc-xquery11-URIExpr">
                <lhs>URIExpr</lhs>
                <rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Expr" xlink:type="simple">Expr</nt>
                </rhs>
              </prod>
</scrap>


   <p>A computed namespace constructor creates a new namespace node,
   with its own node identity. The parent of the newly created
   namespace node is empty.</p>

    <p>If the constructor specifies a <code>Prefix</code>, it is used
    as the prefix for the namespace node.</p>

    <p>If the constructor specifies a <code>PrefixExpr</code>, the
    prefix expression is evaluated as follows:</p>

<olist>
  <item>
                <p>
                  <termref def="dt-atomization">Atomization</termref> is
  applied to the result of the <termref def="dt-name-expression">name
  expression</termref>.</p>
              </item>

  <item>
                <p>If the result of <termref def="dt-atomization">atomization</termref> is a single atomic value
  of type <code>xs:NCName</code>, <code>xs:string</code>, or
  <code>xs:untypedAtomic</code>, it is used as the <code>prefix</code>
  property of the newly constructed namespace node. If the result is
  the empty sequence or an empty string, the <code>prefix</code>
  property of the newly constructed namespace node is empty. For any
  other result, a <termref def="dt-type-error">type error</termref> is
  raised <errorref class="TY" code="0004"/>.</p>
              </item>

  <item>
    <p>The <code>URIExpr</code> is evaluated, and the result is cast
    to <code>xs:anyURI</code> to create the <code>URI</code> property
    for the newly created node.</p>

    <p>An error <errorref class="DY" code="0101"/> is raised if the
    namespace URI in a computed namespace constructor is bound to the predefined prefix
    <code>xmlns</code>, or if a namespace URI other than
    <code>http://www.w3.org/XML/1998/namespace</code> is bound to the
    prefix <code>xml</code>, or if the prefix <code>xml</code> is
    bound to a namespace URI other than
    <code>http://www.w3.org/XML/1998/namespace.</code>
                </p>
              </item>
</olist>

    <p>By itself, a computed namespace constructor has no effect on
    in-scope namespaces, but if an element constructor's content
    sequence contains a namespace node, the namespace binding it
    represents is added to the elements in-scope namespaces.</p>

    <p>A computed namespace constructor has no effect on the statically
    known namespaces.</p>

    <note>
      <p>The newly created namespace node has all properties defined
      for a namespace node in the data model. Like all nodes, it has
      identity. Like all nodes which do not share a common parent, the
      relative order of these nodes is implementation dependent. As
      defined in the data model, the name of the node is the prefix,
      and the string value of the node is the URI.</p>
    </note>

<p>Examples:</p>


<ulist>


  <item>
<p>A computed namespace constructor with a prefix:</p>
<eg role="parse-test" xml:space="preserve">namespace a {"http://a.example.com" }</eg>
</item>


  <item>
<p>A computed namespace constructor with a prefix expression:</p>
<eg role="parse-test" xml:space="preserve">namespace {"a"} {"http://a.example.com" }</eg>
</item>


  <item>
<p>A computed namespace constructor with an empty prefix:</p>
<eg role="parse-test" xml:space="preserve">namespace { "" } {"http://a.example.com" }</eg>
</item>
</ulist>

<p>Computed namespace constructors are generally used to add to the
in-scope namespaces of elements created with element constructors:</p>
<eg role="parse-test" xml:space="preserve">
&lt;form&gt;
 {
    namespace a {"http://a.example.com" },
    attribute { xs:QName("a:id") } { "a-12-XE-45" },
    element { xs:QName("a:field")} { "Sample data" }
 }
&lt;/form&gt;
</eg>

<p>Computed namespace constructors have no effect on the statically known
namespaces. If the prefix a is not already defined in the statically
known namespaces, the following expression results in a static error
<errorref class="ST" code="0081"/>.</p>
<eg role="parse-test" xml:space="preserve">
&lt;a:form&gt;
 {
  namespace a { "http://a.example.com" }
 }
&lt;/a:form&gt;
</eg>


</div4>


</div3>

<div3 id="id-ns-nodes-on-elements">
<head>In-scope Namespaces of a Constructed Element</head>

<p>An element node constructed by a direct or computed element
constructor has an <termref def="dt-in-scope-namespaces">in-scope
namespaces</termref> property that consists of a set of <termref def="dt-in-scope-namespaces">namespace bindings</termref>.  The
in-scope namespaces of an element node may affect the way the node is
serialized (see <specref ref="id-serialization"/>), and may also
affect the behavior of certain functions that operate on nodes, such
as <code>fn:name</code>. Note the difference between <termref def="dt-in-scope-namespaces">in-scope namespaces</termref>, which is a
dynamic property of an element node, and <termref def="dt-static-namespaces">statically known namespaces</termref>,
which is a static property of an expression.  Also note that one of
the namespace bindings in the in-scope namespaces may have no prefix
(denoting the default namespace for the given element). The in-scope
namespaces of a constructed element node consist of the following
namespace bindings:</p>


<ulist>
  

  <item>
              <p>A namespace binding is created for each namespace declared
  in the current element constructor by a <termref def="dt-namespace-decl-attr">namespace declaration
  attribute</termref>.</p>
            </item>

  

  <item>
              <p>A namespace binding is created for each namespace node in
  the context sequence of the current element constructor.</p>
            </item>

  

  <item>
              <p>A namespace binding is created for each namespace that is
  declared in a <termref def="dt-namespace-decl-attr">namespace
  declaration attribute</termref> of an enclosing <termref def="dt-direct-elem-const">direct element constructor</termref> and
  not overridden by the current element constructor or an intermediate
  constructor.</p>
            </item>

  

  <item>
              <p>A namespace binding is always created to bind the prefix
  <code>xml</code> to the namespace URI
  <code>http://www.w3.org/XML/1998/namespace</code>.</p>
            </item>

  

  <item>
              <p>For each namespace used in the name of the constructed
  element or in the names of its attributes, a namespace binding must
  exist. If a namespace binding does not already exist for one of
  these namespaces, a new namespace binding is created for it.  If the
  name of the node includes a prefix, that prefix is used in the
  namespace binding; if the name has no prefix, then a binding is
  created for the empty prefix. If this would result in a conflict,
  because it would require two different bindings of the same prefix,
  then the prefix used in the node name is changed to an arbitrary
  <termref def="dt-implementation-dependent">implementation-dependent</termref>
  prefix that does not cause such a conflict, and a namespace binding
  is created for this new prefix.</p>
            </item>
</ulist>


<note>
            <p>
              <termref def="dt-copy-namespaces-mode">Copy-namespaces
mode</termref> does not affect the namespace bindings of a newly
constructed element node. It applies only to existing nodes that are
copied by a constructor expression.</p>
          </note>

<p>In an element constructor, if two or more namespace bindings in the
in-scope bindings would have the same prefix, then an error is raised
if they have different URIs <errorref class="TY" code="0102"/>; if they
would have the same prefix and URI, duplicate bindings are
ignored.</p>

<p>The following query
serves as an example:</p>

<eg role="parse-test" xml:space="preserve">declare namespace p="http://example.com/ns/p";
declare namespace q="http://example.com/ns/q";
declare namespace f="http://example.com/ns/f";

&lt;p:a q:b="{f:func(2)}" xmlns:r="http://example.com/ns/r"/&gt;
</eg>
          <p>The <termref def="dt-in-scope-namespaces">in-scope namespaces</termref> of the resulting <code>p:a</code> element consists of the following <termref def="dt-in-scope-namespaces">namespace bindings</termref>:</p>
<ulist>

  <item>
              <p>
                <code>p = "http://example.com/ns/p"</code>
              </p>
            </item>

  <item>
              <p>
                <code>q = "http://example.com/ns/q"</code>
              </p>
            </item>

  <item>
              <p>
                <code>r = "http://example.com/ns/r"
</code>
              </p>
            </item>

  <item>
              <p>
                <code>xml = "http://www.w3.org/XML/1998/namespace"</code>
              </p>
            </item>
          </ulist>
          <p>The
namespace bindings for <code>p</code> and <code>q</code> are added to the result element because their respective namespaces
are used in the names of the element and its attributes. The namespace binding <code>r="http://example.com/ns/r"</code> is added to the in-scope namespaces of the constructed
element because it is defined by a <termref def="dt-namespace-decl-attr">namespace declaration attribute</termref>, even though it is not used in a name.</p>
          <p>No  namespace binding corresponding to <code>f="http://example.com/ns/f"</code> is created, because the namespace prefix <code>f</code> appears only in the query prolog and is not used in an element or attribute name of the constructed node. This namespace binding does not appear in the query result, even though it is present in the <termref def="dt-static-namespaces">statically known namespaces</termref> and is available for use during processing of the query.</p>
          <p>Note that the following constructed element, if nested within a <code>validate</code> expression, cannot be validated:</p>
          <eg role="parse-test" xml:space="preserve">&lt;p xsi:type="xs:integer"&gt;3&lt;/p&gt;</eg>
          <p>The constructed element will have namespace bindings for the prefixes <code>xsi</code> (because it is used in a name) and <code>xml</code> (because it is defined for every constructed element node). During validation of the constructed element, the validator will be unable to interpret the namespace prefix <code>xs</code> because it is has no namespace binding. Validation of this constructed element could be made possible by providing a <termref def="dt-namespace-decl-attr">namespace declaration attribute</termref>, as in the following example:</p>
          <eg role="parse-test" xml:space="preserve">&lt;p xmlns:xs="http://www.w3.org/2001/XMLSchema"
   xsi:type="xs:integer"&gt;3&lt;/p&gt;</eg>
        </div3>
      </div2>	




<div2 id="id-flwor-expressions" role="xquery"> 
<head>FLWOR Expressions</head> 
<p>XQuery provides a versatile expression called a FLWOR expression that may contain multiple clauses. The FLWOR expression can be used for many purposes, including iterating over sequences, joining multiple documents, and performing grouping and aggregation. The name FLWOR, pronounced "flower", is suggested by the keywords <code>for</code>, <code>let</code>, <code>where</code>, <code>order by</code>, and <code>return</code>, which introduce some of the clauses used in FLWOR expressions (but this is not a complete list of such clauses.)</p>
        <p>The complete syntax of a FLWOR expression is shown here, and relevant parts of the syntax are repeated in subsequent sections of this document.</p> 
<scrap headstyle="show"> 
<head/> 
<prod num="41" id="doc-xquery11-FLWORExpr">
            <lhs>FLWORExpr</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-InitialClause" xlink:type="simple">InitialClause</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-IntermediateClause" xlink:type="simple">IntermediateClause</nt>*  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ReturnClause" xlink:type="simple">ReturnClause</nt>
            </rhs>
          </prod> 
<prod num="42" id="doc-xquery11-InitialClause">
            <lhs>InitialClause</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ForClause" xlink:type="simple">ForClause</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-LetClause" xlink:type="simple">LetClause</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-WindowClause" xlink:type="simple">WindowClause</nt>
            </rhs>
          </prod>
<prod num="43" id="doc-xquery11-IntermediateClause">
            <lhs>IntermediateClause</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-InitialClause" xlink:type="simple">InitialClause</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-WhereClause" xlink:type="simple">WhereClause</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-GroupByClause" xlink:type="simple">GroupByClause</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-OrderByClause" xlink:type="simple">OrderByClause</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-CountClause" xlink:type="simple">CountClause</nt>
            </rhs>
          </prod>
<prod num="44" id="doc-xquery11-ForClause">
            <lhs>ForClause</lhs>
            <rhs>"for"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ForBinding" xlink:type="simple">ForBinding</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ForBinding" xlink:type="simple">ForBinding</nt>)*</rhs>
          </prod> 
<prod num="45" id="noid_N14F63.doc-xquery11-ForBinding">
            <lhs>ForBinding</lhs>
            <rhs>"$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-VarName" xlink:type="simple">VarName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AllowingEmpty" xlink:type="simple">AllowingEmpty</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-PositionalVar" xlink:type="simple">PositionalVar</nt>?  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>
            </rhs>
          </prod>
<prod num="48" id="doc-xquery11-LetClause">
            <lhs>LetClause</lhs>
            <rhs>"let"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-LetBinding" xlink:type="simple">LetBinding</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-LetBinding" xlink:type="simple">LetBinding</nt>)*</rhs>
          </prod> 
<prod num="49" id="noid_N14F6A.doc-xquery11-LetBinding">
            <lhs>LetBinding</lhs>
            <rhs>"$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-VarName" xlink:type="simple">VarName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  ":="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>
            </rhs>
          </prod>
<prod num="168" id="doc-xquery11-TypeDeclaration">
            <lhs>TypeDeclaration</lhs>
            <rhs>"as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SequenceType" xlink:type="simple">SequenceType</nt>
            </rhs>
          </prod>
<prod num="46" id="doc-xquery11-AllowingEmpty">
            <lhs>AllowingEmpty</lhs>
            <rhs>"allowing"  "empty"</rhs>
          </prod>
<prod num="47" id="doc-xquery11-PositionalVar">
            <lhs>PositionalVar</lhs>
            <rhs>"at"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-VarName" xlink:type="simple">VarName</nt>
            </rhs>
          </prod>
<prod num="50" id="doc-xquery11-WindowClause">
            <lhs>WindowClause</lhs>
            <rhs>"for"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TumblingWindowClause" xlink:type="simple">TumblingWindowClause</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SlidingWindowClause" xlink:type="simple">SlidingWindowClause</nt>)</rhs>
          </prod>
<prod num="51" id="doc-xquery11-TumblingWindowClause">
            <lhs>TumblingWindowClause</lhs>
            <rhs>"tumbling"  "window"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-VarName" xlink:type="simple">VarName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-WindowStartCondition" xlink:type="simple">WindowStartCondition</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-WindowEndCondition" xlink:type="simple">WindowEndCondition</nt>?</rhs>
          </prod>
<prod num="52" id="doc-xquery11-SlidingWindowClause">
            <lhs>SlidingWindowClause</lhs>
            <rhs>"sliding"  "window"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-VarName" xlink:type="simple">VarName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-WindowStartCondition" xlink:type="simple">WindowStartCondition</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-WindowEndCondition" xlink:type="simple">WindowEndCondition</nt>
            </rhs>
          </prod>
<prod num="53" id="doc-xquery11-WindowStartCondition">
            <lhs>WindowStartCondition</lhs>
            <rhs>"start"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-WindowVars" xlink:type="simple">WindowVars</nt>  "when"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>
            </rhs>
          </prod>
<prod num="54" id="doc-xquery11-WindowEndCondition">
            <lhs>WindowEndCondition</lhs>
            <rhs>"only"?  "end"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-WindowVars" xlink:type="simple">WindowVars</nt>  "when"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>
            </rhs>
          </prod>
<prod num="55" id="doc-xquery11-WindowVars">
            <lhs>WindowVars</lhs>
            <rhs>("$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-CurrentItem" xlink:type="simple">CurrentItem</nt>)?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-PositionalVar" xlink:type="simple">PositionalVar</nt>?  ("previous"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-PreviousItem" xlink:type="simple">PreviousItem</nt>)?  ("next"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-NextItem" xlink:type="simple">NextItem</nt>)?</rhs>
          </prod>
<prod num="56" id="doc-xquery11-CurrentItem">
            <lhs>CurrentItem</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-EQName" xlink:type="simple">EQName</nt>
            </rhs>
          </prod>
<prod num="57" id="doc-xquery11-PreviousItem">
            <lhs>PreviousItem</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-EQName" xlink:type="simple">EQName</nt>
            </rhs>
          </prod>
<prod num="58" id="doc-xquery11-NextItem">
            <lhs>NextItem</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-EQName" xlink:type="simple">EQName</nt>
            </rhs>
          </prod>
<prod num="59" id="doc-xquery11-CountClause">
            <lhs>CountClause</lhs>
            <rhs>"count"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-VarName" xlink:type="simple">VarName</nt>
            </rhs>
          </prod>
<prod num="60" id="doc-xquery11-WhereClause">
            <lhs>WhereClause</lhs>
            <rhs>"where"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>
            </rhs>
          </prod> 
<prod num="61" id="doc-xquery11-GroupByClause">
            <lhs>GroupByClause</lhs>
            <rhs>"group"  "by"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-GroupingSpecList" xlink:type="simple">GroupingSpecList</nt>
            </rhs>
          </prod>
<prod num="62" id="doc-xquery11-GroupingSpecList">
            <lhs>GroupingSpecList</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-GroupingSpec" xlink:type="simple">GroupingSpec</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-GroupingSpec" xlink:type="simple">GroupingSpec</nt>)*</rhs>
          </prod> 
<prod num="63" id="doc-xquery11-GroupingSpec">
            <lhs>GroupingSpec</lhs>
            <rhs>"$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-VarName" xlink:type="simple">VarName</nt>  ("collation"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-URILiteral" xlink:type="simple">URILiteral</nt>)?</rhs>
          </prod>  
<prod num="64" id="doc-xquery11-OrderByClause">
            <lhs>OrderByClause</lhs>
            <rhs>(("order"  "by")  |  ("stable"  "order"  "by"))  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-OrderSpecList" xlink:type="simple">OrderSpecList</nt>
            </rhs>
          </prod>
          <prod num="65" id="doc-xquery11-OrderSpecList">
            <lhs>OrderSpecList</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-OrderSpec" xlink:type="simple">OrderSpec</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-OrderSpec" xlink:type="simple">OrderSpec</nt>)*</rhs>
          </prod> 
<prod num="66" id="doc-xquery11-OrderSpec">
            <lhs>OrderSpec</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-OrderModifier" xlink:type="simple">OrderModifier</nt>
            </rhs>
          </prod> 
<prod num="67" id="doc-xquery11-OrderModifier">
            <lhs>OrderModifier</lhs>
            <rhs>("ascending"  |  "descending")?  ("empty"  ("greatest"  |  "least"))?  ("collation"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-URILiteral" xlink:type="simple">URILiteral</nt>)?</rhs>
          </prod>
<prod num="68" id="doc-xquery11-ReturnClause">
            <lhs>ReturnClause</lhs>
            <rhs>"return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>
            </rhs>
          </prod>
</scrap> 
<p>The semantics of FLWOR expressions are based on a concept called a <term>tuple stream</term>. <termdef id="id-tuple-stream-foobar" term="tuple stream">A <term>tuple stream</term> is an ordered sequence of zero or more <term>tuples</term>.</termdef> <termdef term="tuple" id="id-tuple-foobar">A <term>tuple</term> is a set of zero or more named variables, each of which is bound to a value that is an <termref def="dt-data-model-instance">XDM instance</termref>.</termdef> Each tuple stream is homogeneous in the sense that all its  tuples contain variables with the same names and the same <termref def="dt-static-type">static types</termref>. The following example illustrates a tuple stream consisting of four tuples, each containing three variables named <code>$x</code>, <code>$y</code>, and <code>$z</code>:</p>
        <eg xml:space="preserve">($x = 1003, $y = "Fred", $z = &lt;age&gt;21&lt;/age&gt;)
($x = 1017, $y = "Mary", $z = &lt;age&gt;35&lt;/age&gt;)
($x = 1020, $y = "Bill", $z = &lt;age&gt;18&lt;/age&gt;)
($x = 1024, $y = "John", $z = &lt;age&gt;29&lt;/age&gt;)</eg>
        <note>
          <p>In this section, tuple streams are represented as shown in the above example. Each tuple is on a separate line and is enclosed in parentheses, and the variable bindings inside each tuple are separated by commas. This notation does not represent XQuery syntax, but is simply a representation of a tuple stream for the purpose of defining the semantics of  FLWOR expressions.</p>
        </note>
        <p>Tuples and tuple streams are not part of the <termref def="dt-datamodel">data model</termref>. They exist only as conceptual intermediate results during the processing of a FLWOR expression.</p>
        <p>A FLWOR expression consists of an initial clause, zero or more intermediate clauses, and a final clause. Conceptually, the initial clause generates a tuple stream. Each intermediate clause takes the tuple stream generated by the previous clause as input and generates a (possibly different) tuple stream as output. The final clause takes a tuple stream as input and, for each tuple in this tuple stream, generates an <termref def="dt-data-model-instance">XDM instance</termref>; the final result of the FLWOR expression is the ordered concatenation of these <termref def="dt-data-model-instance">XDM instances</termref>.</p>
        <p>The initial clause in a FLWOR expression may be a <code>for</code>, <code>let</code>, <code>window</code>, or <code>count</code> clause. Intermediate clauses may be <code>for</code>, <code>let</code>, <code>window</code>, <code>count</code>, <code>where</code>, <code>group by</code>, or <code>order by</code> clauses. These intermediate clauses may be repeated as many times as desired, in any order. The final clause of the FLWOR expression must be a <code>return</code> clause. The semantics of the various clauses are described in the following sections.</p>
        <div3 id="id-binding-rules">
          <head>Variable Bindings</head>
          <p>The following clauses in FLWOR expressions bind values to variables: <code>for</code>, <code>let</code>, <code>window</code>, and <code>count</code> (in addition, a <code>group by</code> clause changes the values of variables that were previously bound.) In each case, binding of variables is governed by the following rules:</p>

<olist>

  <item>
              <p>The scope of a bound variable includes all subexpressions of the containing FLWOR that appear after the variable binding. The scope does not include the expression to which the variable is bound. The following code fragment, containing two <code>let</code> clauses, illustrates how variable bindings may reference variables that were bound in earlier clauses, or in earlier bindings in the same clause:</p>
              <eg xml:space="preserve">let $x := 47, $y := f($x)
let $z := g($x, $y)</eg>
            </item>

  <item>
              <p>A given variable may be bound more than once in a FLWOR expression, or even within one  clause of a FLWOR expression. In such a case, each new binding occludes the previous one, which becomes inaccessible in the remainder of the FLWOR expression.</p>
            </item>

  <item>
              <p>
                <termdef term="type declaration" id="dt-type-declaration">A variable binding may be accompanied by a <term>type declaration</term>, which consists of the keyword <code>as</code> followed by the static type of the variable, declared using the syntax in  <specref ref="id-sequencetype-syntax"/>.</termdef> At run time, if the value bound to the variable does not match the declared type according to the rules for <termref def="dt-sequencetype-matching">SequenceType
matching</termref>, a <termref def="dt-type-error">type error</termref> is raised <errorref class="TY" code="0004"/>. For example, the following <code>let</code> clause raises a <termref def="dt-type-error">type error</termref> because the variable <code>$salary</code> has a type declaration that is not satisfied by the value that is bound to it:</p>
              <eg xml:space="preserve">let $salary as xs:decimal :=  "cat"</eg>
            </item>

  <item>
              <p>
                <termdef id="dt-binding-sequence" term="binding sequence">In a <code>for</code> clause or <code>window</code> clause, when an expression is preceded by the keyword <code>in</code>, the value of that expression is called a <term>binding sequence</term>.</termdef> The <code>for</code> and <code>window</code> clauses iterate over their binding sequences, producing multiple bindings for one or more variables. Details on how binding sequences are used in <code>for</code> and <code>window</code> clauses are described in the following sections.</p>
            </item>
          </olist>
        </div3>

<div3 id="id-xquery-for-clause">
          <head>For Clause</head>
<scrap headstyle="show"> 
<head/> 
<prod num="44" id="noid_N150A4.doc-xquery11-ForClause">
              <lhs>ForClause</lhs>
              <rhs>"for"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ForBinding" xlink:type="simple">ForBinding</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ForBinding" xlink:type="simple">ForBinding</nt>)*</rhs>
            </prod> 
<prod num="45" id="noid_N150A7.doc-xquery11-ForBinding">
              <lhs>ForBinding</lhs>
              <rhs>"$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-VarName" xlink:type="simple">VarName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AllowingEmpty" xlink:type="simple">AllowingEmpty</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-PositionalVar" xlink:type="simple">PositionalVar</nt>?  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>
              </rhs>
            </prod>
<prod num="168" id="noid_N150AA.doc-xquery11-TypeDeclaration">
              <lhs>TypeDeclaration</lhs>
              <rhs>"as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SequenceType" xlink:type="simple">SequenceType</nt>
              </rhs>
            </prod>
<prod num="46" id="noid_N150AD.doc-xquery11-AllowingEmpty">
              <lhs>AllowingEmpty</lhs>
              <rhs>"allowing"  "empty"</rhs>
            </prod>
<prod num="47" id="noid_N150B0.doc-xquery11-PositionalVar">
              <lhs>PositionalVar</lhs>
              <rhs>"at"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-VarName" xlink:type="simple">VarName</nt>
              </rhs>
            </prod>
</scrap>
<p>A <code>for</code> clause is used for iteration. Each variable in a <code>for</code> clause iterates over a sequence and is bound in turn to each item in the sequence.</p>

<p>If a <code>for</code> clause contains multiple variables, it is semantically equivalent to multiple <code>for</code> clauses, each containing one of the variables in the original <code>for</code> clause.</p>

<p>Example:</p>

<ulist>
<item>
              <p>The clause</p>
              <eg xml:space="preserve">for $x in $expr1, $y in $expr2</eg>
              <p>is semantically equivalent to:</p>
              <eg xml:space="preserve">for $x in $expr1 
for $y in $expr2</eg>
            </item>
</ulist>

<p>In the remainder of this section, we define the semantics of a <code>for</code> clause containing a single variable and an associated expression (following the keyword <code>in</code>) whose value is called the <termref def="dt-binding-sequence">binding sequence</termref> for that variable.</p>
          <p>If a single-variable <code>for</code> clause is the initial clause in a FLWOR expression, it iterates over its <termref def="dt-binding-sequence">binding sequence</termref>, binding the variable to each item in turn. The resulting sequence of variable bindings becomes the initial tuple stream that serves as input to the next clause of the FLWOR expression. If <termref def="dt-ordering-mode">ordering mode</termref> is <code>ordered</code>, the order of tuples in the tuple stream preserves the order of the <termref def="dt-binding-sequence">binding sequence</termref>; otherwise the order of the tuple stream is <termref def="dt-implementation-dependent">implementation-dependent</termref>.</p>
          <p>If the <termref def="dt-binding-sequence">binding sequence</termref> contains no items, the output tuple stream depends on whether <code>allowing empty</code> is specified. If <code>allowing empty</code> is specified, the output tuple stream consists of one tuple in which the variable is bound to an empty sequence. If <code>allowing empty</code> is not specified, the output tuple stream consists of zero tuples.</p>
          <p>The following  examples illustrates tuple streams that are generated by initial <code>for</code> clauses:</p>
<ulist>

  <item>
              <p>Initial clause:</p>
              <eg xml:space="preserve">for $x in (100, 200, 300)</eg>
              <p>or (equivalently):</p>
              <eg xml:space="preserve">for $x allowing empty in (100, 200, 300)</eg>
              <p>Output tuple stream:</p>
              <eg xml:space="preserve">($x = 100)
($x = 200)
($x = 300)</eg>
            </item>

  <item>
              <p>Initial clause:</p>
              <eg xml:space="preserve">for $x in ()</eg>
              <p>Output tuple stream contains no tuples.</p>
            </item>

  <item>
              <p>Initial clause:</p>
              <eg xml:space="preserve">for $x allowing empty in ()</eg>
              <p>Output tuple stream:</p>
              <eg xml:space="preserve">($x = ())</eg>
            </item>
          </ulist>
          <p>
            <termdef term="positional variable" id="dt-positional-variable">A <term>positional variable</term> is a variable that is preceded by the keyword <code>at</code>.</termdef> A positional variable may be associated with a variable that is bound in a <code>for</code> clause. In this case, as the main variable iterates over the items in its <termref def="dt-binding-sequence">binding sequence</termref>, the positional variable iterates over the integers that represent the ordinal numbers of these items in the <termref def="dt-binding-sequence">binding sequence</termref>, starting with one. Each tuple in the output tuple stream contains bindings for both the main variable and the positional variable. If the <termref def="dt-binding-sequence">binding sequence</termref> is empty and <code>allowing empty</code> is specified, the positional variable in the output tuple is bound to the integer zero. Positional variables always have the implied type <code>xs:integer</code>. The <termref def="dt-expanded-qname">expanded
			        QName</termref> of a positional variable must be distinct from the <termref def="dt-expanded-qname">expanded
			        QName</termref> of the main variable with which it is associated <errorref class="ST" code="0089"/>.</p>
          <p>The following  examples illustrate how a positional variable would have affected the results of the previous examples that generated tuples:</p>
<ulist>

  <item>
              <p>Initial clause:</p>
              <eg xml:space="preserve">for $x at $i in (100, 200, 300)</eg>
              <p>Output tuple stream:</p>
              <eg xml:space="preserve">($x = 100, $i = 1)
($x = 200, $i = 2)
($x = 300, $i = 3)</eg>
            </item>

  <item>
              <p>Initial clause:</p>
              <eg xml:space="preserve">for $x allowing empty at $i in ()</eg>
              <p>Output tuple stream:</p>
              <eg xml:space="preserve">($x = (), $i = 0)</eg>
            </item>
          </ulist>
          <p>If a single-variable <code>for</code> clause is an intermediate clause in a FLWOR expression, its <termref def="dt-binding-sequence">binding sequence</termref> is evaluated for each input tuple, given the bindings in that input tuple. Each input tuple generates  zero or more tuples in the output tuple stream. Each of these output tuples consists of  the original variable bindings of the input tuple plus a binding of the new variable to one of the items in its <termref def="dt-binding-sequence">binding sequence</termref>.</p>
          <note>
            <p>Although the <termref def="dt-binding-sequence">binding sequence</termref> is conceptually evaluated independently for each input tuple, an optimized implementation may sometimes be able to avoid re-evaluating the <termref def="dt-binding-sequence">binding sequence</termref> if it can show that the variables that the <termref def="dt-binding-sequence">binding sequence</termref> depends on have the same values as in a previous evaluation.</p>
          </note>
          <p>For a given input tuple, if the <termref def="dt-binding-sequence">binding sequence</termref> for the new variable in the <code>for</code> clause contains no items, the result depends on whether  <code>allowing empty</code> is specified. If <code>allowing empty</code> is specified, the input tuple generates one output tuple, with the original variable bindings plus a binding of the new variable to an empty sequence. If <code>allowing empty</code> is not specified, the input tuple generates zero output tuples (it is not represented in the output tuple stream.)</p>
          <p>If the new variable introduced by a <code>for</code> clause has an associated <termref def="dt-positional-variable">positional variable</termref>, the output tuples generated by the <code>for</code> clause  also contain bindings for the <termref def="dt-positional-variable">positional variable</termref>. In this case, as the new variable is bound to each item in its <termref def="dt-binding-sequence">binding sequence</termref>, the <termref def="dt-positional-variable">positional variable</termref> is bound to the ordinal position of that item within the <termref def="dt-binding-sequence">binding sequence</termref>, starting with one. Note that, since the <termref def="dt-positional-variable">positional variable</termref> represents a position within a <termref def="dt-binding-sequence">binding sequence</termref>, the output tuples corresponding to each input tuple are independently numbered, starting with one. For a given input tuple, if the <termref def="dt-binding-sequence">binding sequence</termref> is empty and <code>allowing empty</code> is specified, the <termref def="dt-positional-variable">positional variable</termref> in the output tuple is bound to the integer zero.</p>
          <p>If <termref def="dt-ordering-mode">ordering mode</termref> is <code>ordered</code>, the tuples in the output tuple stream are ordered primarily by the order of the input tuples from which they are derived, and secondarily by the order of the <termref def="dt-binding-sequence">binding sequence</termref> for the new variable; otherwise the order of the output tuple stream is <termref def="dt-implementation-dependent">implementation-dependent</termref>.</p>
          <p>The following examples illustrates the effects of  intermediate <code>for</code> clauses:</p>
<ulist>

  <item>
              <p>Input tuple stream:</p>
              <eg xml:space="preserve">($x = 1)
($x = 2)
($x = 3)
($x = 4)</eg>
              <p>Intermediate <code>for</code> clause:</p>
              <eg xml:space="preserve">for $y in ($x to 3)</eg>
              <p>Output tuple stream (assuming <termref def="dt-ordering-mode">ordering mode</termref> is <code>ordered</code>):</p>
              <eg xml:space="preserve">($x = 1, $y = 1)
($x = 1, $y = 2)
($x = 1, $y = 3)
($x = 2, $y = 2)
($x = 2, $y = 3)
($x = 3, $y = 3)
</eg>
              <note>
                <p>In this example, there is no output tuple that corresponds to the input tuple <code>($x = 4)</code> because, when the <code>for</code> clause is evaluated with the bindings in this input tuple, the resulting <termref def="dt-binding-sequence">binding sequence</termref> for <code>$y</code> is empty.</p>
              </note>
            </item>

  <item>
              <p>This  example shows how the previous example would have been affected by a <termref def="dt-positional-variable">positional variable</termref> (assuming the same input tuple stream):</p>
              <eg xml:space="preserve">for $y at $j in ($x to 3)</eg>
              <p>Output tuple stream (assuming <termref def="dt-ordering-mode">ordering mode</termref> is <code>ordered</code>):</p>
              <eg xml:space="preserve">($x = 1, $y = 1, $j = 1)
($x = 1, $y = 2, $j = 2)
($x = 1, $y = 3, $j = 3)
($x = 2, $y = 2, $j = 1)
($x = 2, $y = 3, $j = 2)
($x = 3, $y = 3, $j = 1)
</eg>
            </item>

  <item>
              <p>This example shows how the previous example would have been affected by <code>allowing empty</code>. Note that <code>allowing empty</code> causes the input tuple <code>($x = 4)</code> to be represented in the output tuple stream, even though the <termref def="dt-binding-sequence">binding sequence</termref> for <code>$y</code> contains no items for this input tuple. This example illustrates that <code>allowing empty</code> in a <code>for</code> clause serves a purpose similar to that of an "outer join" in a relational database query. (Assume the same input tuple stream as in the previous example.)</p>
              <eg xml:space="preserve">for $y allowing empty at $j in ($x to 3)</eg>
              <p>Output tuple stream (assuming <termref def="dt-ordering-mode">ordering mode</termref> is <code>ordered</code>):</p>
              <eg xml:space="preserve">($x = 1, $y = 1, $j = 1)
($x = 1, $y = 2, $j = 2)
($x = 1, $y = 3, $j = 3)
($x = 2, $y = 2, $j = 1)
($x = 2, $y = 3, $j = 2)
($x = 3, $y = 3, $j = 1)
($x = 4, $y = (), $j = 0)
</eg>
            </item>

  <item>
              <p>This example shows how a <code>for</code> clause that binds two variables is semantically equivalent to two <code>for</code> clauses that bind one variable each. We assume that this <code>for</code> clause occurs at the beginning of a FLWOR expression. It is equivalent to an initial single-variable <code>for</code> clause that provides an input tuple stream to an intermediate single-variable <code>for</code> clause.</p>
              <eg xml:space="preserve">for $x in (1, 2, 3, 4), $y in ($x to 3)</eg>
              <p>Output tuple stream (assuming <termref def="dt-ordering-mode">ordering mode</termref> is <code>ordered</code>):</p>
              <eg xml:space="preserve">($x = 1, $y = 1)
($x = 1, $y = 2)
($x = 1, $y = 3)
($x = 2, $y = 2)
($x = 2, $y = 3)
($x = 3, $y = 3)
</eg>
            </item>
          </ulist>
          <p>In the above examples, if <termref def="dt-ordering-mode">ordering mode</termref> had been <code>unordered</code>, the output tuple streams would have consisted of the same tuples, with the same values for the <termref def="dt-positional-variable">positional variables</termref>, but the ordering of the tuples would have been <termref def="dt-implementation-dependent">implementation-dependent</termref>.</p>
          <p>A <code>for</code> clause may contain one or more <termref def="dt-type-declaration">type declarations</termref>, identified by the keyword <code>as</code>. The semantics of <termref def="dt-type-declaration">type declarations</termref> are defined in <specref ref="id-binding-rules"/>.</p>
        </div3>
<div3 id="id-xquery-let-clause">
          <head>Let Clause</head>
<scrap headstyle="show">
<head/>
<prod num="48" id="noid_N152B5.doc-xquery11-LetClause">
              <lhs>LetClause</lhs>
              <rhs>"let"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-LetBinding" xlink:type="simple">LetBinding</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-LetBinding" xlink:type="simple">LetBinding</nt>)*</rhs>
            </prod>
<prod num="49" id="noid_N152B8.doc-xquery11-LetBinding">
              <lhs>LetBinding</lhs>
              <rhs>"$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-VarName" xlink:type="simple">VarName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  ":="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>
              </rhs>
            </prod>
<prod num="168" id="noid_N152BB.doc-xquery11-TypeDeclaration">
              <lhs>TypeDeclaration</lhs>
              <rhs>"as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SequenceType" xlink:type="simple">SequenceType</nt>
              </rhs>
            </prod>
</scrap> 
<p>The purpose of a <code>let</code> clause is to bind values to one or more variables. Each variable is bound to the result of evaluating an expression.</p>
<p>If a <code>let</code> clause contains multiple variables, it is semantically equivalent to multiple <code>let</code> clauses, each containing a single variable. For example, the clause</p>
<eg xml:space="preserve">let $x := $expr1, $y := $expr2</eg>
          <p>is semantically equivalent to the following sequence of clauses:</p>
          <eg xml:space="preserve">let $x := $expr1 
let $y := $expr2</eg>
          <p>In the remainder of this section, we define the semantics of a <code>let</code> clause containing a single variable <emph>V</emph> and an associated expression <emph>E</emph>.</p>
          <p>If a single-variable <code>let</code> clause is the initial clause in a FLWOR expression, it simply binds the variable <emph>V</emph> to the result of the expression <emph>E</emph>. The result of the <code>let</code> clause is a tuple stream consisting of one tuple with a single binding that binds <emph>V</emph> to the result of <emph>E</emph>. This tuple stream serves as input to the next clause in the FLWOR expression.</p>
          <p>If a single-variable <code>let</code> clause is an intermediate clause in a FLWOR expression, it adds a new binding for variable <emph>V</emph> to each tuple in the input tuple stream. For each input tuple, the value bound to <emph>V</emph> is the result of evaluating expression <emph>E</emph>, given the bindings that are already present in that input tuple. The resulting tuples become the output tuple stream of the <code>let</code> clause.</p>
          <p>The number of tuples in the output tuple stream of an intermediate <code>let</code> clause is the same as the number of tuples in the input tuple stream. The number of bindings in the output tuples is one more than the number of bindings in the input tuples, unless the input tuples already contain bindings for <emph>V</emph>; in this case, the new binding for <emph>V</emph> occludes (replaces) the earlier binding for <emph>V</emph>, and the number of bindings is unchanged.</p>
          <p>A <code>let</code> clause may contain one or more <termref def="dt-type-declaration">type declarations</termref>, identified by the keyword <code>as</code>. The semantics of type declarations are defined in <specref ref="id-binding-rules"/>.</p>
          <p>The following code fragment illustrates how a <code>for</code> clause and a <code>let</code> clause can be used together. The <code>for</code> clause produces an initial tuple stream containing a binding for variable <code>$d</code> to each department number found in a given input document. The <code>let</code> clause adds an additional binding to each tuple, binding variable <code>$e</code> to a sequence of employees whose department number matches the value of <code>$d</code> in that tuple.</p>
          <eg xml:space="preserve">for $d in fn:doc("depts.xml")/depts/deptno
let $e := fn:doc("emps.xml")/emps/emp[deptno eq $d]</eg>
        </div3>



<div3 id="id-windows">
  <head>Window Clause</head>
          <scrap headstyle="show"> 
<head/> 
<prod num="50" id="noid_N15348.doc-xquery11-WindowClause">
              <lhs>WindowClause</lhs>
              <rhs>"for"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TumblingWindowClause" xlink:type="simple">TumblingWindowClause</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SlidingWindowClause" xlink:type="simple">SlidingWindowClause</nt>)</rhs>
            </prod>
<prod num="51" id="noid_N1534B.doc-xquery11-TumblingWindowClause">
              <lhs>TumblingWindowClause</lhs>
              <rhs>"tumbling"  "window"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-VarName" xlink:type="simple">VarName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-WindowStartCondition" xlink:type="simple">WindowStartCondition</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-WindowEndCondition" xlink:type="simple">WindowEndCondition</nt>?</rhs>
            </prod>
<prod num="52" id="noid_N1534E.doc-xquery11-SlidingWindowClause">
              <lhs>SlidingWindowClause</lhs>
              <rhs>"sliding"  "window"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-VarName" xlink:type="simple">VarName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-WindowStartCondition" xlink:type="simple">WindowStartCondition</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-WindowEndCondition" xlink:type="simple">WindowEndCondition</nt>
              </rhs>
            </prod>
<prod num="53" id="noid_N15351.doc-xquery11-WindowStartCondition">
              <lhs>WindowStartCondition</lhs>
              <rhs>"start"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-WindowVars" xlink:type="simple">WindowVars</nt>  "when"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>
              </rhs>
            </prod>
<prod num="54" id="noid_N15354.doc-xquery11-WindowEndCondition">
              <lhs>WindowEndCondition</lhs>
              <rhs>"only"?  "end"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-WindowVars" xlink:type="simple">WindowVars</nt>  "when"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>
              </rhs>
            </prod>
<prod num="55" id="noid_N15357.doc-xquery11-WindowVars">
              <lhs>WindowVars</lhs>
              <rhs>("$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-CurrentItem" xlink:type="simple">CurrentItem</nt>)?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-PositionalVar" xlink:type="simple">PositionalVar</nt>?  ("previous"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-PreviousItem" xlink:type="simple">PreviousItem</nt>)?  ("next"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-NextItem" xlink:type="simple">NextItem</nt>)?</rhs>
            </prod>
<prod num="56" id="noid_N1535A.doc-xquery11-CurrentItem">
              <lhs>CurrentItem</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-EQName" xlink:type="simple">EQName</nt>
              </rhs>
            </prod>
<prod num="47" id="noid_N1535D.doc-xquery11-PositionalVar">
              <lhs>PositionalVar</lhs>
              <rhs>"at"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-VarName" xlink:type="simple">VarName</nt>
              </rhs>
            </prod>
            <prod num="57" id="noid_N1535F.doc-xquery11-PreviousItem">
              <lhs>PreviousItem</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-EQName" xlink:type="simple">EQName</nt>
              </rhs>
            </prod>
<prod num="58" id="noid_N15362.doc-xquery11-NextItem">
              <lhs>NextItem</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-EQName" xlink:type="simple">EQName</nt>
              </rhs>
            </prod>
</scrap>

<p>Like a <code>for</code> clause, a <code>window</code> clause
iterates over its <termref def="dt-binding-sequence">binding
sequence</termref> and generates a sequence of tuples. In the case of
a <code>window</code> clause, each tuple represents a window. <termdef term="window" id="dt-window">A <term>window</term> is a sequence of
consecutive items drawn from the <termref def="dt-binding-sequence">binding sequence</termref>.</termdef> Each
window is represented by at least one and at most nine bound
variables. The variables have user-specified names, but their roles
are as follows:</p>

<ulist>

  <item>
              <p>
                <emph>Window-variable:</emph> Bound to the sequence of
  items from the <termref def="dt-binding-sequence">binding
  sequence</termref> that comprise the window.</p>
            </item>

  <item>
              <p>
                <emph>Start-item:</emph> (Optional) Bound to the first item
  in the window.</p>
            </item>

  <item>
              <p>
                <emph>Start-item-position:</emph> (Optional) Bound to the
  ordinal position of the first window item in the <termref def="dt-binding-sequence">binding
  sequence</termref>. <emph>Start-item-position</emph> is a <termref def="dt-positional-variable">positional variable</termref>. Its type
  is <code>xs:integer</code>, and its <termref def="dt-expanded-qname">expanded QName</termref> must be distinct
  from the <termref def="dt-expanded-qname">expanded QName</termref> of <emph>start-item</emph> <errorref class="ST" code="0089"/>.</p>
            </item>

  <item>
              <p>
                <emph>Start-previous-item:</emph> (Optional) Bound to the
  item in the <termref def="dt-binding-sequence">binding
  sequence</termref> that precedes the first item in the window (empty
  sequence if none).</p>
            </item>

  <item>
              <p>
                <emph>Start-next-item:</emph> (Optional) Bound to the item
  in the <termref def="dt-binding-sequence">binding sequence</termref>
  that follows the first item in the window (empty sequence if
  none).</p>
            </item>

  <item>
              <p>
                <emph>End-item:</emph> (Optional) Bound to the last item in
  the window.</p>
            </item>

  <item>
              <p>
                <emph>End-item-position:</emph> (Optional) Bound to the
  ordinal position of the last window item in the <termref def="dt-binding-sequence">binding
  sequence</termref>. <emph>End-item-position</emph> is a <termref def="dt-positional-variable">positional variable</termref>. Its type
  is <code>xs:integer</code>, and its <termref def="dt-expanded-qname">expanded QName</termref> must be distinct
  from the <termref def="dt-expanded-qname">expanded QName</termref> of <emph>end-item</emph> <errorref class="ST" code="0089"/>.</p>
            </item>

  <item>
              <p>
                <emph>End-previous-item:</emph> (Optional) Bound to the
  item in the <termref def="dt-binding-sequence">binding
  sequence</termref> that precedes the last item in the window (empty
  sequence if none).</p>
            </item>

  <item>
              <p>
                <emph>End-next-item:</emph> (Optional) Bound to the item in
  the <termref def="dt-binding-sequence">binding sequence</termref>
  that follows the last item in the window (empty sequence if
  none).</p>
            </item>

</ulist>

<p>All variables in a <code>window</code> clause must have distinct names;
 otherwise a <termref def="dt-static-error">static error</termref> is raised <errorref class="ST" code="0103"/>.</p>

<p>The following is an example of a <code>window</code> clause that
binds nine variables to the roles listed above. In this example, the
variables are named <code>$w</code>, <code>$s</code>,
<code>$spos</code>, <code>$sprev</code>, <code>$snext</code>,
<code>$e</code>, <code>$epos</code>, <code>$eprev</code>, and
<code>$enext</code> respectively. A <code>window</code> clause always
binds the window variable, but typically binds only a subset of the
other variables.</p>

<eg xml:space="preserve">for tumbling window $w in (2, 4, 6, 8, 10)
start $s at $spos previous $sprev next $snext when true() end $e at
$epos previous $eprev next $enext when true()</eg>

<p>Windows are
created by iterating over the items in the <termref def="dt-binding-sequence">binding sequence</termref>, in order,
identifying the start item and the end item of each window by
evaluating the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-WindowStartCondition" xlink:type="simple">WindowStartCondition</nt> and the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-WindowEndCondition" xlink:type="simple">WindowEndCondition</nt>. Each of these
conditions is satisfied if the <termref def="dt-ebv">effective boolean
value</termref> of the expression following the <code>when</code>
keyword is <code>true</code>.

The start item of the window is an item that satisfies the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-WindowStartCondition" xlink:type="simple">WindowStartCondition</nt> (see <specref ref="id-tumbling-windows"/> and <specref ref="id-sliding-windows"/> for a more complete explanation.) The end item of the window is the first item in the <termref def="dt-binding-sequence">binding sequence</termref>, beginning with the start item, that satisfies the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-WindowEndCondition" xlink:type="simple">WindowEndCondition</nt> (again, see <specref ref="id-tumbling-windows"/> and <specref ref="id-sliding-windows"/> for more details.) Each window contains its start item, its end
item, and all items that occur between them in the <termref def="dt-binding-sequence">binding sequence</termref>.
If the end item is the start item, then the window contains only one
item.  If a start item is identified, but no following item in the <termref def="dt-binding-sequence">binding sequence</termref> satisfies the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-WindowEndCondition" xlink:type="simple">WindowEndCondition</nt>, then the <code>only</code> keyword determines whether a window is
generated: if <code>only end</code> is specified, then no window is
generated; otherwise, the end item is set to the last item in the
<termref def="dt-binding-sequence">binding sequence</termref> and a window is generated.</p>
          <p>In the above example, the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-WindowStartCondition" xlink:type="simple">WindowStartCondition</nt> and <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-WindowEndCondition" xlink:type="simple">WindowEndCondition</nt> are both <code>true()</code>, which causes each tuple in the <termref def="dt-binding-sequence">binding sequence</termref> to be in a separate window. Typically, the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-WindowStartCondition" xlink:type="simple">WindowStartCondition</nt> and <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-WindowEndCondition" xlink:type="simple">WindowEndCondition</nt> are expressed in terms of bound variables. For example, the following <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-WindowStartCondition" xlink:type="simple">WindowStartCondition</nt> might be used to start a new window for every item in the <termref def="dt-binding-sequence">binding sequence</termref> that is larger than both the previous item and the following item:</p>
          <eg xml:space="preserve">start $s previous $sprev next $snext 
   when $s &gt; $sprev and $s &gt; $snext</eg>
          <p>The scoping rules for the variables bound by a <code>window</code> clause are as follows:</p>
<ulist>

  

  <item>
              <p>In the <code>when</code>-expression of the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-WindowStartCondition" xlink:type="simple">WindowStartCondition</nt>, the following variables (identified here by their roles) are in scope (if bound): <emph>start-item, start-item-position, start-previous-item, start-next-item.</emph>
              </p>
            </item>

  

  <item>
              <p>In the <code>when</code>-expression of the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-WindowEndCondition" xlink:type="simple">WindowEndCondition</nt>, the following variables (identified here by their roles) are in scope (if bound): <emph>start-item, start-item-position, start-previous-item, start-next-item, end-item, end-item-position, end-previous-item, end-next-item.</emph>
              </p>
            </item>

  

  <item>
              <p>In the clauses of the FLWOR expression that follow the <code>window</code> clause, all nine of the variables bound by the <code>window</code> clause (including <emph>window-variable</emph>) are in scope (if bound).</p>
            </item>
          </ulist>
          <p>In a <code>window</code> clause, the keyword <code>tumbling</code> or <code>sliding</code> determines the way in which the starting item of each window is identified, as explained in the following sections.</p>
          <div4 id="id-tumbling-windows">
<head>Tumbling Windows</head>



<p>If the window type is <code>tumbling</code>, then windows
never overlap. The search for the start of the first window begins at the beginning of the <termref def="dt-binding-sequence">binding sequence</termref>. After each window is generated, the search
for the start of the next window begins with the item in the <termref def="dt-binding-sequence">binding sequence</termref> that occurs after the ending item of the last generated
window. Thus, no item that occurs in one window can occur in another
window drawn from the same <termref def="dt-binding-sequence">binding sequence</termref>.  In a tumbling window clause,
the <code>end</code> clause is optional; if it is omitted, the
<code>start</code> clause is applied to identify all potential
starting items in the <termref def="dt-binding-sequence">binding sequence</termref>, and a window is constructed
for each starting item, including all items from that starting item up
to the item before the next window's starting item, or the end of the
<termref def="dt-binding-sequence">binding sequence</termref>, whichever comes first.</p>
            <p>The following examples illustrate the use of tumbling windows.</p>
<ulist>

  

  <item>
                <p>Show non-overlapping windows of three items.</p>
<eg role="parse-test" xml:space="preserve">for tumbling window $w in (2, 4, 6, 8, 10, 12, 14)
    start at $s when fn:true()
    only end at $e when $e - $s eq 2
return &lt;window&gt;{ $w }&lt;/window&gt;</eg>

<p>Result of the above query:</p>
<eg xml:space="preserve">&lt;window&gt;2 4 6&lt;/window&gt;
&lt;window&gt;8 10 12&lt;/window&gt;</eg>
              </item>

  

  <item>
                <p>Show averages of non-overlapping three-item windows.</p>
<eg role="parse-test" xml:space="preserve">
for tumbling window $w in (2, 4, 6, 8, 10, 12, 14)
    start at $s when fn:true()
    only end at $e when $e - $s eq 2
return avg($w)</eg>

<p>Result of the above query:</p>
<eg xml:space="preserve">4 10</eg>
              </item>

  

  <item>
                <p>Show first and last items in each window of three items.</p>
<eg role="parse-test" xml:space="preserve">for tumbling window $w in (2, 4, 6, 8, 10, 12, 14)
    start $first at $s when fn:true()
    only end $last at $e when $e - $s eq 2
return &lt;window&gt;{ $first, $last }&lt;/window&gt;</eg>

<p>Result of the above query:</p>
<eg xml:space="preserve">&lt;window&gt;2 6&lt;/window&gt;
&lt;window&gt;8 12&lt;/window&gt;</eg>
              </item>

  

  <item>
                <p>Show non-overlapping windows of up to three items (illustrates <code>end</code> clause without the <code>only</code> keyword).</p>
<eg role="parse-test" xml:space="preserve">for tumbling window $w in (2, 4, 6, 8, 10, 12, 14)
    start at $s when fn:true()
    end at $e when $e - $s eq 2
return &lt;window&gt;{ $w }&lt;/window&gt;</eg>

<p>Result of the above query:</p>
<eg xml:space="preserve">&lt;window&gt;2 4 6&lt;/window&gt;
&lt;window&gt;8 10 12&lt;/window&gt;
&lt;window&gt;14&lt;/window&gt;</eg>
              </item>

  

  <item>
                <p>Show non-overlapping windows of up to three items (illustrates use of <code>start</code> without explicit <code>end</code>).</p>
<eg role="parse-test" xml:space="preserve">for tumbling window $w in (2, 4, 6, 8, 10, 12, 14)
    start at $s when $s mod 3 = 1
return &lt;window&gt;{ $w }&lt;/window&gt;</eg>

<p>Result of the above query:</p>
<eg xml:space="preserve">&lt;window&gt;2 4 6&lt;/window&gt;
&lt;window&gt;8 10 12&lt;/window&gt;
&lt;window&gt;14&lt;/window&gt;</eg>
              </item>

  

  <item>
                <p>Show non-overlapping sequences starting with a number divisible by 3.</p>

<eg role="parse-test" xml:space="preserve">for tumbling window $w in (2, 4, 6, 8, 10, 12, 14)
    start $first when $first mod 3 = 0
return &lt;window&gt;{ $w }&lt;/window&gt;</eg>

<p>Result of the above query:</p>
<eg xml:space="preserve">&lt;window&gt;6 8 10&lt;/window&gt;
&lt;window&gt;12 14&lt;/window&gt;</eg>
              </item>
            </ulist>










</div4>
          <div4 id="id-sliding-windows">
<head>Sliding Windows</head>

<p>If the window type is <code>sliding window</code>, then windows may
overlap. Every item in the <termref def="dt-binding-sequence">binding sequence</termref> that satisfies the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-WindowStartCondition" xlink:type="simple">WindowStartCondition</nt> is the starting item of a new window. Thus, a given
item may be found in multiple windows drawn from the same <termref def="dt-binding-sequence">binding sequence</termref>.</p>
            <p>The following examples illustrate the use of sliding windows.</p>


<ulist>

  

  <item>
                <p>Show windows of three items.</p>
<eg role="parse-test" xml:space="preserve">for sliding window $w in (2, 4, 6, 8, 10, 12, 14)
    start at $s when fn:true()
    only end at $e when $e - $s eq 2
return &lt;window&gt;{ $w }&lt;/window&gt;</eg>

<p>Result of the above query:</p>

<eg xml:space="preserve">&lt;window&gt;2 4 6&lt;/window&gt;
&lt;window&gt;4 6 8&lt;/window&gt;
&lt;window&gt;6 8 10&lt;/window&gt;
&lt;window&gt;8 10 12&lt;/window&gt;
&lt;window&gt;10 12 14&lt;/window&gt;</eg>
              </item>

  

  <item>
                <p>Show moving averages of three items.</p>

<eg role="parse-test" xml:space="preserve">for sliding window $w in (2, 4, 6, 8, 10, 12, 14)
    start at $s when fn:true()
    only end at $e when $e - $s eq 2
return avg($w)</eg>

<p>Result of the above query:</p>
<eg xml:space="preserve">4 6 8 10 12</eg>
              </item>

  

  <item>
                <p>Show overlapping windows of up to three items (illustrates <code>end</code> clause without the <code>only</code> keyword).</p>

<eg role="parse-test" xml:space="preserve">for sliding window $w in (2, 4, 6, 8, 10, 12, 14)
    start at $s when fn:true()
    end at $e when $e - $s eq 2
return &lt;window&gt;{ $w }&lt;/window&gt;</eg>

<p>Result of the above query:</p>
<eg xml:space="preserve">&lt;window&gt;2 4 6&lt;/window&gt;
&lt;window&gt;4 6 8&lt;/window&gt;
&lt;window&gt;6 8 10&lt;/window&gt;
&lt;window&gt;8 10 12&lt;/window&gt;
&lt;window&gt;10 12 14&lt;/window&gt;
&lt;window&gt;12 14&lt;/window&gt;
&lt;window&gt;14&lt;/window&gt;</eg>
              </item>
            </ulist>





</div4>
          <div4 id="id-effects-of-window-clauses">
            <head>Effects of Window Clauses on the Tuple Stream</head>
            <p>The effects of a <code>window</code> clause on the tuple stream are similar to the effects of a <code>for</code> clause. As described in <specref ref="id-windows"/>, a <code>window</code> clause generates zero or more windows, each of which is represented by at least one and at most nine bound variables.</p>
            <p>If the <code>window</code> clause is the initial clause in a FLWOR expression, the bound variables that describe each window become an output tuple. These tuples form the initial tuple stream that serves as input to the next clause of the FLWOR expression. If <termref def="dt-ordering-mode">ordering mode</termref> is <code>ordered</code>, the order of tuples in the tuple stream is the
order in which their start items appear in the <termref def="dt-binding-sequence">binding sequence</termref>; otherwise the order of the tuple stream is <termref def="dt-implementation-dependent">implementation-dependent</termref>. The cardinality of the tuple stream is equal to the number of windows.</p>
            <p>If a <code>window</code> clause is an intermediate clause in a FLWOR expression, each input tuple generates zero or more output tuples, each consisting of  the original bound variables of the input tuple plus the new bound variables that represent one of the generated windows. For each tuple <emph>T</emph> in the input tuple stream, the output tuple stream will contain <emph>N<sub>T</sub>
              </emph> tuples, where <emph>N<sub>T</sub>
              </emph> is the number of windows generated by the <code>window</code> clause, given the bindings in the input tuple <emph>T</emph>. Input tuples for which no windows are generated are not represented in the output tuple stream. If <termref def="dt-ordering-mode">ordering mode</termref> is <code>ordered</code>, the order of tuples in the output stream is determined primarily by the order of the input tuples from which they were derived, and secondarily by the order in which their start items appear in the <termref def="dt-binding-sequence">binding sequence</termref>. If <termref def="dt-ordering-mode">ordering mode</termref> is <code>unordered</code>, the order of tuples in the output stream is <termref def="dt-implementation-dependent">implementation-dependent</termref>.</p>
            <p>The following example illustrates a <code>window</code> clause that is the initial clause in a FLWOR expression. The example is based on input data that consists of a sequence of closing stock prices for a specific company. For this example we assume the following input data (assume that the <code>price</code> elements have a validated type of <code>xs:decimal</code>):</p>
            <eg xml:space="preserve">&lt;stock&gt;
  &lt;closing&gt; &lt;date&gt;2008-01-01&lt;/date&gt; &lt;price&gt;105&lt;/price&gt; &lt;/closing
  &lt;closing&gt; &lt;date&gt;2008-01-02&lt;/date&gt; &lt;price&gt;101&lt;/price&gt; &lt;/closing
  &lt;closing&gt; &lt;date&gt;2008-01-03&lt;/date&gt; &lt;price&gt;102&lt;/price&gt; &lt;/closing
  &lt;closing&gt; &lt;date&gt;2008-01-04&lt;/date&gt; &lt;price&gt;103&lt;/price&gt; &lt;/closing
  &lt;closing&gt; &lt;date&gt;2008-01-05&lt;/date&gt; &lt;price&gt;102&lt;/price&gt; &lt;/closing
  &lt;closing&gt; &lt;date&gt;2008-01-06&lt;/date&gt; &lt;price&gt;104&lt;/price&gt; &lt;/closing
&lt;/stock&gt;</eg>
            <p>A user wishes to find "run-ups," which are defined as sequences of dates that begin with a "low" and end with a "high" price (that is, the stock price begins to rise on the first day of the run-up, and continues to rise or remain even through the last day of the run-up.) The following query uses a tumbling window to find run-ups in the input data:</p>
            <eg role="parse-test" xml:space="preserve">for tumbling window $w in //closing
   start $first next $second when $first/price &lt; $second/price
   end $last next $beyond when $last/price &gt; $beyond/price
return
   &lt;run-up&gt;
      &lt;start-date&gt;{fn:data($first/date)}&lt;/start-date&gt;
      &lt;start-price&gt;{fn:data($first/price)}&lt;/start-price&gt;
      &lt;end-date&gt;{fn:data($last/date)}&lt;/end-date&gt;
      &lt;end-price&gt;{fn:data($last/price)}&lt;/end-price&gt;
   &lt;/run-up&gt;</eg>
            <p>For our sample input data, this <code>tumbling window</code> clause generates a tuple stream consisting of two tuples, each representing a window and containing five bound variables named <code>$w</code>, <code>$first</code>, <code>$second</code>, <code>$last</code>, and <code>$beyond</code>. The <code>return</code> clause is evaluated for each of these tuples, generating the following query result:</p>
            <eg xml:space="preserve">&lt;run-up&gt;
   &lt;start-date&gt;2008-01-02&lt;/start-date&gt;
   &lt;start-price&gt;101&lt;/start-price&gt;
   &lt;end-date&gt;2008-01-04&lt;/start-date&gt;
   &lt;end-price&gt;103&lt;/end-price&gt;
&lt;/run-up&gt;
&lt;run-up&gt;
   &lt;start-date&gt;2008-01-05&lt;/start-date&gt;
   &lt;start-price&gt;102&lt;/start-price&gt;
   &lt;end-date&gt;2008-01-06&lt;/start-date&gt;
   &lt;end-price&gt;104&lt;/end-price&gt;
&lt;/run-up&gt;</eg>
            <p>The following example illustrates a <code>window</code> clause that is an intermediate clause in a FLWOR expression. In this example, the input data contains closing stock prices for several different companies, each identified by a three-letter symbol. We assume the following input data (again assuming that the type of the <code>price</code> element is <code>xs:decimal</code>):</p>
            <eg xml:space="preserve">&lt;stocks&gt;
  &lt;closing&gt; &lt;symbol&gt;ABC&lt;/symbol&gt; &lt;date&gt;2008-01-01&lt;/date&gt; &lt;price&gt;105&lt;/price&gt; &lt;/closing&gt;
  &lt;closing&gt; &lt;symbol&gt;DEF&lt;/symbol&gt; &lt;date&gt;2008-01-01&lt;/date&gt; &lt;price&gt;057&lt;/price&gt; &lt;/closing&gt;
  &lt;closing&gt; &lt;symbol&gt;ABC&lt;/symbol&gt; &lt;date&gt;2008-01-02&lt;/date&gt; &lt;price&gt;101&lt;/price&gt; &lt;/closing&gt;
  &lt;closing&gt; &lt;symbol&gt;DEF&lt;/symbol&gt; &lt;date&gt;2008-01-02&lt;/date&gt; &lt;price&gt;054&lt;/price&gt; &lt;/closing&gt;
  &lt;closing&gt; &lt;symbol&gt;ABC&lt;/symbol&gt; &lt;date&gt;2008-01-03&lt;/date&gt; &lt;price&gt;102&lt;/price&gt; &lt;/closing&gt;
  &lt;closing&gt; &lt;symbol&gt;DEF&lt;/symbol&gt; &lt;date&gt;2008-01-03&lt;/date&gt; &lt;price&gt;056&lt;/price&gt; &lt;/closing&gt;
  &lt;closing&gt; &lt;symbol&gt;ABC&lt;/symbol&gt; &lt;date&gt;2008-01-04&lt;/date&gt; &lt;price&gt;103&lt;/price&gt; &lt;/closing&gt;
  &lt;closing&gt; &lt;symbol&gt;DEF&lt;/symbol&gt; &lt;date&gt;2008-01-04&lt;/date&gt; &lt;price&gt;052&lt;/price&gt; &lt;/closing&gt;
  &lt;closing&gt; &lt;symbol&gt;ABC&lt;/symbol&gt; &lt;date&gt;2008-01-05&lt;/date&gt; &lt;price&gt;101&lt;/price&gt; &lt;/closing&gt;
  &lt;closing&gt; &lt;symbol&gt;DEF&lt;/symbol&gt; &lt;date&gt;2008-01-05&lt;/date&gt; &lt;price&gt;055&lt;/price&gt; &lt;/closing&gt;
  &lt;closing&gt; &lt;symbol&gt;ABC&lt;/symbol&gt; &lt;date&gt;2008-01-06&lt;/date&gt; &lt;price&gt;104&lt;/price&gt; &lt;/closing&gt;
  &lt;closing&gt; &lt;symbol&gt;DEF&lt;/symbol&gt; &lt;date&gt;2008-01-06&lt;/date&gt; &lt;price&gt;059&lt;/price&gt; &lt;/closing&gt;
&lt;/stocks&gt;</eg>
            <p>As in the previous example, we want to find "run-ups," which are defined as sequences of dates that begin with a "low" and end with a "high" price for a specific company. In this example, however, the input data consists of stock prices for multiple companies. Therefore it is necessary to isolate the stock prices of each company before forming windows. This can be accomplished by an initial <code>for</code> and <code>let</code> clause, followed by a <code>window</code> clause, as follows:</p>
            <eg role="parse-test" xml:space="preserve">for $symbol in fn:distinct-values(//symbol)
let $closings := //closing[symbol = $symbol]
for tumbling window $w in $closings
   start $first next $second when $first/price &lt; $second/price
   end $last next $beyond when $last/price &gt; $beyond/price
return
   &lt;run-up symbol="{$symbol}"&gt;
      &lt;start-date&gt;{fn:data($first/date)}&lt;/start-date&gt;
      &lt;start-price&gt;{fn:data($first/price)}&lt;/start-price&gt;
      &lt;end-date&gt;{fn:data($last/date)}&lt;/end-date&gt;
      &lt;end-price&gt;{fn:data($last/price)}&lt;/end-price&gt;
   &lt;/run-up&gt;</eg>
            <note>
              <p>In the above example, the <code>for</code> and <code>let</code> clauses could be rewritten as follows:</p>
              <eg xml:space="preserve">for $closings in //closing
let $symbol := $closings/symbol
group by $symbol</eg>
              <p>The <code>group by</code> clause is described in <specref ref="id-group-by"/>.</p>
            </note>
            <p>The <code>for</code> and <code>let</code> clauses in this query generate an initial tuple stream consisting of two tuples. In the first tuple, <code>$symbol</code> is bound to "ABC" and <code>$closings</code> is bound to the sequence of <code>closing</code> elements for company ABC. In the second tuple, <code>$symbol</code> is bound to "DEF" and <code>$closings</code> is bound to the sequence of <code>closing</code> elements for company DEF.</p>
            <p>The <code>window</code> clause operates on this initial tuple stream, generating two windows for the first tuple and two windows for the second tuple. The result is a tuple stream consisting of four tuples, each with the following bound variables: <code>$symbol</code>, <code>$closings</code>, <code>$w</code>, <code>$first</code>, <code>$second</code>, <code>$last</code>, and <code>$beyond</code>. The <code>return</code> clause is then evaluated for each of these tuples, generating the following query result:</p>
            <eg xml:space="preserve">&lt;run-up symbol="ABC"&gt;
   &lt;start-date&gt;2008-01-02&lt;/start-date&gt;
   &lt;start-price&gt;101&lt;/start-price&gt;
   &lt;end-date&gt;2008-01-04&lt;/start-date&gt;
   &lt;end-price&gt;103&lt;/end-price&gt;
&lt;/run-up&gt;
&lt;run-up symbol="ABC"&gt;
   &lt;start-date&gt;2008-01-05&lt;/start-date&gt;
   &lt;start-price&gt;101&lt;/start-price&gt;
   &lt;end-date&gt;2008-01-06&lt;/start-date&gt;
   &lt;end-price&gt;104&lt;/end-price&gt;
&lt;/run-up&gt;
&lt;run-up symbol="DEF"&gt;
   &lt;start-date&gt;2008-01-02&lt;/start-date&gt;
   &lt;start-price&gt;54&lt;/start-price&gt;
   &lt;end-date&gt;2008-01-03&lt;/start-date&gt;
   &lt;end-price&gt;56&lt;/end-price&gt;
&lt;/run-up&gt;
&lt;run-up symbol="DEF"&gt;
   &lt;start-date&gt;2008-01-04&lt;/start-date&gt;
   &lt;start-price&gt;52&lt;/start-price&gt;
   &lt;end-date&gt;2008-01-06&lt;/start-date&gt;
   &lt;end-price&gt;59&lt;/end-price&gt;
&lt;/run-up&gt;</eg>
          </div4>
        </div3>


<div3 id="id-where">
          <head>Where Clause</head>
<scrap headstyle="show"> 
<head/> 
<prod num="60" id="noid_N156DC.doc-xquery11-WhereClause">
              <lhs>WhereClause</lhs>
              <rhs>"where"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>
              </rhs>
            </prod> 
</scrap>
<p>A <code>where</code> clause serves as a filter for the tuples in its input tuple stream. The expression in the <code>where</code> clause, called the <term>where-expression</term>, is evaluated once for
each of these tuples. If the <termref def="dt-ebv">effective boolean value</termref> of the
where-expression is <code>true</code>, the tuple is retained in the output tuple stream; otherwise the tuple is discarded.</p>
          <p>Examples:</p>
<ulist>

  

  <item>
              <p>This example illustrates the effect of a <code>where</code> clause on a tuple stream:</p>
              <p>Input tuple stream:</p>
              <eg xml:space="preserve">($a = 5, $b = 11)
($a = 91, $b = 42)
($a = 17, $b = 30)
($a = 85, $b = 63)</eg>
              <p>
                <code>where</code> clause:</p>
              <eg xml:space="preserve">where $a &gt; $b</eg>
              <p>Output tuple stream:</p>
              <eg xml:space="preserve">($a = 91, $b = 42)
($a = 85, $b = 63)</eg>
            </item>

  

  <item>
              <p>The following query illustrates how a <code>where</code> clause might be used with a <termref def="dt-positional-variable">positional variable</termref> to perform sampling on an input sequence. The query returns one value out of each one hundred input values.</p>
              <eg role="parse-test" xml:space="preserve">
                <phrase role="parse-test">for $x at $i in $inputvalues
    where $i mod 100 = 0   
    return $x</phrase>
              </eg>
            </item>
          </ulist>
</div3>

<div3 id="id-count">
          <head>Count Clause</head>
<scrap headstyle="show"> 
<head/> 
<prod num="59" id="noid_N1572B.doc-xquery11-CountClause">
              <lhs>CountClause</lhs>
              <rhs>"count"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-VarName" xlink:type="simple">VarName</nt>
              </rhs>
            </prod> 
</scrap>

<p>The purpose of a <code>count</code> clause is to enhance the tuple
stream with a new variable that is bound, in each tuple, to the
ordinal position of that tuple in the tuple stream. The name of the
new variable is specified in the <code>count</code> clause.</p>

<p>The output tuple stream of a <code>count</code> clause is the same
as its input tuple stream, with each tuple enhanced by one additional
variable that is bound to the ordinal position of that tuple in the
tuple stream. However, if the name of the new variable is the same as
the name of an existing variable in the input tuple stream, the new
variable occludes (replaces) the existing variable of the same name,
and the number of bound variables in each tuple is unchanged.</p>

<p>The following examples illustrate uses of the <code>count</code> clause:</p>


<ulist>

  

  <item>
              <p>This example illustrates the effect of a <code>count</code> clause on an input tuple stream:</p>
<p>Input tuple stream:</p>
<eg xml:space="preserve">($name = "Bob", $age = 21)
($name = "Carol", $age = 19)
($name = "Ted", $age = 20)
($name = "Alice", $age = 22)</eg>
              <p>
                <code>count</code> clause:</p>
              <eg xml:space="preserve">count $counter</eg>
              <p>Output tuple stream:</p>
              <eg xml:space="preserve">($name = "Bob", $age = 21, $counter = 1)
($name = "Carol", $age = 19, $counter = 2)
($name = "Ted", $age = 20, $counter = 3)
($name = "Alice", $age = 22, $counter = 4)</eg>
            </item>



  

  <item>
              <p>This example illustrates how a counter might be used to filter the result of a query. The query ranks products in order by decreasing sales, and returns the three products with the highest sales. Assume that the variable <code>$products</code> is bound to a sequence of <code>product</code> elements, each of which has <code>name</code> and <code>sales</code> child-elements.</p>
              <eg role="parse-test" xml:space="preserve">for $p in $products
order by $p/sales descending
count $rank
where $rank &lt;= 3
return
   &lt;product rank="{$rank}"&gt;
      {$p/name, $p/sales}
   &lt;/product&gt;</eg>
              <p>The result of this query has the following structure:</p>
              <eg xml:space="preserve">&lt;product rank="1"&gt;
   &lt;name&gt;Toaster&lt;/name&gt;
   &lt;sales&gt;968&lt;/sales&gt;
&lt;/product&gt;
&lt;product rank="2"&gt;
   &lt;name&gt;Blender&lt;/name&gt;
   &lt;sales&gt;520&lt;/sales&gt;
&lt;/product&gt;
&lt;product rank="3"&gt;
   &lt;name&gt;Can Opener&lt;/name&gt;
   &lt;sales&gt;475&lt;/sales&gt;
&lt;/product&gt;</eg>
            </item>
          </ulist>
        </div3>

<div3 id="id-group-by">
          <head>Group By Clause</head>
          <scrap headstyle="show"> 
<head/> 
<prod num="61" id="noid_N15782.doc-xquery11-GroupByClause">
              <lhs>GroupByClause</lhs>
              <rhs>"group"  "by"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-GroupingSpecList" xlink:type="simple">GroupingSpecList</nt>
              </rhs>
            </prod>
<prod num="62" id="noid_N15785.doc-xquery11-GroupingSpecList">
              <lhs>GroupingSpecList</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-GroupingSpec" xlink:type="simple">GroupingSpec</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-GroupingSpec" xlink:type="simple">GroupingSpec</nt>)*</rhs>
            </prod> 
<prod num="63" id="noid_N15788.doc-xquery11-GroupingSpec">
              <lhs>GroupingSpec</lhs>
              <rhs>"$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-VarName" xlink:type="simple">VarName</nt>  ("collation"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-URILiteral" xlink:type="simple">URILiteral</nt>)?</rhs>
            </prod>  
</scrap>
          <p>A <code>group by</code> clause generates an output tuple stream in which each tuple represents a group of tuples from the input tuple stream. We will refer to the tuples in the input tuple stream as  <term>pre-grouping tuples</term>, and the tuples in the output tuple stream as <term>post-grouping tuples</term>.</p>

<p>The post-grouping tuples have exactly the same variable-names as
the pre-grouping tuples. The number of post-grouping tuples is less
than or equal to the number of pre-grouping tuples. The <code>group
by</code> clause assigns each pre-grouping tuple to a group, and
generates one post-grouping tuple for each group. Subsequent clauses
in the FLWOR expression see only the variable bindings in the
post-grouping tuples; they no longer have access to the variable
bindings in the pre-grouping tuples.</p>


<p>
            <termdef id="dt-grouping-variable" term="grouping variable">A <code>group by</code> clause consists of the
keywords <code>group by</code> followed by one or more variables
called <term>grouping variables</term>.</termdef> The name of each
grouping variable must be equal (by the <code>eq</code> operator on
<termref def="dt-expanded-qname">expanded QNames</termref>) to the name of a bound variable in the input tuple
stream; otherwise a <termref def="dt-static-error">static
error</termref> is raised <errorref class="ST" code="0094"/>. </p>

<p>The process of group formation proceeds as follows:

<olist>

  
  <item>
                <p> <termdef term="grouping key" id="dt-grouping-key">The
  atomized value of a <termref def="dt-grouping-variable">grouping
  variable</termref> is called a <term>grouping
  key</term>.</termdef>  For each pre-grouping tuple, the <termref def="dt-grouping-key">grouping keys</termref> are created by <termref def="dt-atomization">atomizing</termref> the values of the <termref def="dt-grouping-variable">grouping variables</termref>.  If the
  resulting value for any <termref def="dt-grouping-variable">grouping
  variable</termref> consists of more than one item, a <termref def="dt-dynamic-error">dynamic error</termref> is raised <errorref class="TY" code="0004"/>. </p>
  </item>

  <item>
                <p>The input tuple stream is partitioned into groups of tuples
  whose grouping keys are <termref def="dt-equivalent-grouping-keys">equivalent</termref>. <termdef id="dt-equivalent-grouping-keys" term="equivalent grouping keys">Two
  tuples <var>T1</var> and <var>T2</var> have <term>equivalent
  grouping keys</term> if and only if, for each grouping variable
  <var>GV</var>, the atomized value of <var>GV</var> in <var>T1</var>
  is deep-equal to the atomized value of <var>GV</var> in
  <var>T2</var>, as defined by applying the function
  <function>fn:deep-equal</function> using the appropriate
  collation.</termdef>

     <note>
                    <p>The atomized grouping key will always be either an empty
     sequence or a single atomic value. Defining equivalence by
     reference to the <function>fn:deep-equal</function> function
     ensures that the empty sequence is equivalent only to the empty
     sequence, that <code>NaN</code> is equivalent to
     <code>NaN</code>, that untypedAtomic values are compared as
     strings, and that values for which the <code>eq</code> operator
     is not defined are considered
     non-equivalent.</p>
                  </note>
                </p>
              </item>

   <item>
                <p>The appropriate collation for comparing two grouping keys is the collation
   specified in the pertinent <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-GroupingSpec" xlink:type="simple">GroupingSpec</nt> if present, or the default collation
   from the static context otherwise. If the collation is specified by a relative
   URI, that relative URI is  <termref def="dt-resolve-relative-uri">resolved to an absolute URI</termref> using the base URI in the
   static context. If the specified collation is not found in statically known
   collations, a static error is raised  <errorref class="ST" code="0076"/>.</p>
              </item>

</olist>
          </p>



<p>Each group of tuples produced by the above process results in one
post-grouping tuple. The pre-grouping tuples from which the group is
derived have <emph>equivalent</emph> <termref def="dt-grouping-key">grouping keys</termref>, but these keys are not
necessarily identical (for example, the strings "Frog" and "frog"
might be <emph>equivalent</emph> according to the collation in use.)

In the post-grouping tuple, each <termref def="dt-grouping-variable">grouping variable</termref> is bound to the
value of that variable in one of the pre-grouping tuples from which
the group is derived.  The choice of tuple is <termref def="dt-implementation-dependent">implementation-dependent</termref>.
</p>

<ednote>
<edtext>Some members of the XQuery Working Group would prefer that the
grouping variables in the post-grouping tuple contain the grouping key
for a grouping variable in a pre-grouping tuple, which is atomized,
rather than the value of the grouping variable in a pre-grouping
tuple. We welcome feedback on this question.</edtext>
          </ednote>

<p>In the post-grouping tuple generated for a given group, each
non-grouping variable is bound to a sequence containing the
concatenated values of that variable in all the pre-grouping tuples
that were assigned to that group. If <termref def="dt-ordering-mode">ordering mode</termref> is
<code>ordered</code>, the values derived from individual tuples are
concatenated in a way that preserves the order of the pre-grouping
tuple stream; otherwise the ordering of these values is <termref def="dt-implementation-dependent">implementation-dependent</termref>.</p>


<note>
            <p>This behavior may be surprising to SQL programmers, since SQL reduces
the equivalent of a non-grouping variable to one representative
value. Consider the following query:</p>
<eg role="parse-test" xml:space="preserve">

let $x := 64000
for $c in //customer
let $d := $c/department
where $c/salary &gt; $x
group by $d
return 
 &lt;department name="{$d}"&gt;
  Number of employees earning more than ${$x} is {count($c)}
 &lt;/department&gt;</eg>

<p>If there are three qualifying customers in the sales department this
evaluates to:</p>

<eg xml:space="preserve">

&lt;department name="sales"&gt;
  Number of employees earning more than $64000 64000 64000 is 3
&lt;/department&gt;</eg>

<p>In XQuery, each group is a sequence of items that match the group
by criteria—in a tree-structured language like XQuery, this is
convenient, because further structures can be built based on the items
in this sequence. Because there are three items in the group,
<code>$x</code> evaluates to a sequence of three items. To reduce this
to one item, use <code>fn:distinct-values()</code>:</p>

<eg role="parse-test" xml:space="preserve">
let $x := 64000
for $c in //customer
let $d := $c/department
where $c/salary &gt; $x
group by $d
return 
 &lt;department name="{$d}"&gt;
  Number of employees earning more than ${distinct-values($x)} is {count($c)}
 &lt;/department&gt;</eg>

</note>

<note>
            <p>In general, the <termref def="dt-static-type">static
type</termref> of a variable in a post-grouping tuple is different
from the <termref def="dt-static-type">static type</termref> of the
variable with the same name in the pre-grouping
tuples.</p>
          </note>
          <p>The order in which tuples appear in the
post-grouping tuple stream is <termref def="dt-implementation-dependent">implementation-dependent</termref>.</p>
          <note>
            <p>An
<code>order by</code> clause can be used to impose a value-based
ordering on the post-grouping tuple stream. Similarly, if it is
desired to impose a value-based ordering within a group (i.e., on the
sequence of items bound to a non-grouping variable), this can be
accomplished by a nested FLWOR expression that iterates over these
items and applies an <code>order by</code> clause. In some cases, a
value-based ordering within groups can be accomplished by applying an
<code>order by</code> clause on a non-grouping variable before
applying the <code>group by</code> clause.</p>
          </note>
          <p>A <code>group
by</code> clause rebinds all the variables in the input tuple
stream. The scopes of these variables are not affected by the
<code>group by</code> clause, but in post-grouping tuples the values
of the variables represent group properties rather than properties of
individual pre-grouping tuples.</p>

<p>Examples:</p>
<ulist>
  <item>
              <p>This example illustrates the effect of a <code>group by</code> clause on a tuple stream.</p>

<p>Input tuple stream:</p>

<eg xml:space="preserve">($storeno = &lt;storeno&gt;S101&lt;/storeno&gt;, $itemno = &lt;itemno&gt;P78395&lt;/itemno&gt;)
($storeno = &lt;storeno&gt;S102&lt;/storeno&gt;, $itemno = &lt;itemno&gt;P94738&lt;/itemno&gt;)
($storeno = &lt;storeno&gt;S101&lt;/storeno&gt;, $itemno = &lt;itemno&gt;P41653&lt;/itemno&gt;)
($storeno = &lt;storeno&gt;S102&lt;/storeno&gt;, $itemno = &lt;itemno&gt;P70421&lt;/itemno&gt;)
</eg>

<p>
                <code>group by</code> clause:</p>

<eg xml:space="preserve">group by $storeno</eg>

<p>Output tuple stream:</p>

<eg xml:space="preserve">($storeno =  &lt;storeno&gt;S101&lt;/storeno&gt;, $itemno = (&lt;itemno&gt;P78395&lt;/itemno&gt;, &lt;itemno&gt;P41653&lt;itemno&gt;))
($storeno =  &lt;storeno&gt;S102&lt;/storeno&gt;, $itemno = (&lt;itemno&gt;P94738&lt;/itemno&gt;, &lt;itemno&gt;P70421&lt;/itemno&gt;))</eg>
            </item>
          </ulist>
<ulist>

  

  <item>
              <p>This example and the ones that follow are based on two separate sequences of elements, named <code>$sales</code> and <code>$products</code>. We assume that the variable <code>$sales</code> is bound to a sequence of elements with the following structure:</p>
              <eg xml:space="preserve">&lt;sales&gt;
   &lt;storeno&gt;S101&lt;/storeno&gt;
   &lt;itemno&gt;P78395&lt;/itemno&gt;
   &lt;qty&gt;125&lt;/qty&gt;
&lt;/sales&gt;</eg>
              <p>We also assume that the variable <code>$products</code> is bound to a sequence of  elements with the following structure:</p>
              <eg xml:space="preserve">&lt;product&gt;
   &lt;itemno&gt;P78395&lt;/itemno&gt;
   &lt;price&gt;25.00&lt;/price&gt;
   &lt;category&gt;Men's Wear&lt;/category&gt;
&lt;/product&gt;</eg>
              <p>The simplest kind of grouping query has a single <termref def="dt-grouping-variable">grouping variable</termref>. The query in this example finds the total quantity of items sold by each store:</p>
              <eg role="parse-test" xml:space="preserve">for $s in $sales
let $storeno := $s/storeno
group by $storeno
return &lt;store number="{$storeno}" total-qty="{sum($s/qty)}"/&gt;</eg>
              <p>The result of this query is a sequence of elements with the following structure:</p>
              <eg xml:space="preserve">&lt;store number="S101" total-qty="1550" /&gt;
&lt;store number="S102" total-qty="2125" /&gt;</eg>
            </item>

  

  <item>
              <p>In a more realistic example, a user might be interested in the total revenue generated by each store for each product category. Revenue depends on both the quantity sold of various items and the price of each item. The following query joins the two input sequences and groups the resulting tuples by two <termref def="dt-grouping-variable">grouping variables</termref>:</p>
              <eg role="parse-test" xml:space="preserve">for $s in $sales,
    $p in $products[itemno = $s/itemno]
let $storeno := $s/storeno,
    $category := $p/category,
    $revenue := $s/qty * $p/price
group by $storeno, $category
return
    &lt;summary storeno="{$storeno}" 
             category="{$category}" 
             revenue="{sum($revenue)}"/&gt;
</eg>
              <p>The result of this query is a sequence of elements with the following structure:</p>
              <eg xml:space="preserve">&lt;summary storeno="S101" category="Men's Wear" revenue="10185"/&gt;
&lt;summary storeno="S101" category="Stationery" revenue="4520"/&gt;
&lt;summary storeno="S102" category="Men's Wear" revenue="9750"/&gt;
&lt;summary storeno="S102" category="Appliances" revenue="22650"/&gt;
&lt;summary storeno="S102" category="Jewelry" revenue="30750"/&gt;</eg>
            </item>

  

  <item>
              <p>The result of the previous example was a "flat" list of elements. A user might prefer the query result to be presented in the form of a  hierarchical report, grouped primarily by store (in order by store number) and secondarily by product category. Within each store, the user might want to see only those product categories whose total revenue exceeds $10,000, presented in descending order by their total revenue. This report is generated by the following query:</p>
              <eg role="parse-test" xml:space="preserve">for $s1 in $sales
let $storeno := $s1/storeno
group by $storeno
order by $storeno
return
  &lt;store storeno="{$storeno}"&gt;
    {for $s2 in $s1, 
         $p in $products[itemno = $s2/itemno]
     let $category := $p/category,
         $revenue := $s2/qty * $p/price
     group by $category
     let $group-revenue := sum($revenue)
     where $group-revenue &gt; 10000
     order by $group-revenue descending
     return &lt;category name="{$category}" revenue="{$group-revenue}"/&gt;
    }
  &lt;/store&gt;
</eg>
              <p>The result of this example query has the following structure:</p>
              <eg xml:space="preserve">&lt;store storeno="S101"&gt;
   &lt;category name="Men's Wear" revenue="10185"/&gt;
&lt;/store&gt;
&lt;store storeno="S102"&gt;
   &lt;category name="Jewelry" revenue="30750"/&gt;
   &lt;category name="Appliances" revenue="22650"/&gt;
&lt;/store&gt;</eg>
            </item>

  

  <item>
              <p>When writing a query that includes a <code>group by</code> clause, it is important to remember that, in each post-grouping tuple, each <termref def="dt-grouping-variable">grouping variable</termref> is bound to a single atomic value (a <termref def="dt-grouping-key">grouping key</termref>), and all other variables are bound to sequences of items derived from all the pre-grouping tuples from which the group was formed. The following example illustrates how to avoid a possible pitfall in writing grouping queries.</p>
              <eg role="parse-test" xml:space="preserve">let $high-price := 1000
for $p in $products[price &gt; $high-price]
let $category := $p/category
group by $category
return
   &lt;category name="{$category}"&gt;
      {fn:count($p)} products have price greater than {$high-price}.
   &lt;/category&gt;</eg>
              <p>If three products in the "Men's Wear" category have prices greater than 1000, the result of this query might look (in part) like this:</p>
              <eg xml:space="preserve">&lt;category name="Men's Wear"&gt;
   3 products have price greater than 1000 1000 1000.
&lt;/category&gt;</eg>
              <p>The repetition of "1000" in this query result is due to the fact that <code>$high-price</code> is not a <termref def="dt-grouping-variable">grouping variable</termref>. One way to avoid this repetition is to move the binding of <code>$high-price</code> to an outer-level FLWOR expression, as follows:</p>
              <eg role="parse-test" xml:space="preserve">let $high-price := 1000
return
   for $p in $products[price &gt; $high-price]
   let $category := $p/category
   group by $category
   return
      &lt;category name="{$category}"&gt;
         {fn:count($p)} products have price greater than {$high-price}.
      &lt;/category&gt;</eg>
              <p>The result of the revised query might contain the following element:</p>
              <eg xml:space="preserve">&lt;category name="Men's Wear"&gt;
   3 products have price greater than 1000.
&lt;/category&gt;</eg>
            </item>
          </ulist> 
</div3>
        <div3 id="id-order-by-clause">
          <head>Order By Clause</head>
          <scrap headstyle="show"> 
<head/> 
<prod num="64" id="noid_N15943.doc-xquery11-OrderByClause">
              <lhs>OrderByClause</lhs>
              <rhs>(("order"  "by")  |  ("stable"  "order"  "by"))  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-OrderSpecList" xlink:type="simple">OrderSpecList</nt>
              </rhs>
            </prod>
            <prod num="65" id="noid_N15945.doc-xquery11-OrderSpecList">
              <lhs>OrderSpecList</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-OrderSpec" xlink:type="simple">OrderSpec</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-OrderSpec" xlink:type="simple">OrderSpec</nt>)*</rhs>
            </prod> 
<prod num="66" id="noid_N15948.doc-xquery11-OrderSpec">
              <lhs>OrderSpec</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-OrderModifier" xlink:type="simple">OrderModifier</nt>
              </rhs>
            </prod> 
<prod num="67" id="noid_N1594B.doc-xquery11-OrderModifier">
              <lhs>OrderModifier</lhs>
              <rhs>("ascending"  |  "descending")?  ("empty"  ("greatest"  |  "least"))?  ("collation"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-URILiteral" xlink:type="simple">URILiteral</nt>)?</rhs>
            </prod>

</scrap>
<p>The purpose of an <code>order by</code> clause is to impose a value-based ordering on the tuples in the tuple stream. The output tuple stream of the <code>order by</code> clause contains the same tuples as its input tuple stream, but the tuples may be in a different order.</p> 
<p>An <code>order by</code> clause contains one or more ordering specifications, called <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-OrderSpec" xlink:type="simple">orderspecs</nt>, as shown in the grammar. For each tuple in the input tuple stream, the orderspecs are evaluated, using the variable bindings in that tuple. The relative order of two tuples is determined by comparing the values of their orderspecs, working from left to right until a pair of unequal values is encountered. If an orderspec specifies a <termref def="dt-collation">collation</termref>, that collation is used in comparing values of type <code>xs:string</code>, <code>xs:anyURI</code>, or types derived from them (otherwise, the <termref def="dt-def-collation">default collation</termref> is used in comparing values of these types). If an orderspec specifies a collation by a relative URI, that relative URI is  <termref def="dt-resolve-relative-uri">resolved to an absolute URI</termref> using the <termref def="dt-base-uri">base URI</termref> in the <termref def="dt-static-context">static context</termref>. If an orderspec specifies a collation that is not found in <termref def="dt-static-collations">statically known collations</termref>, an error is raised <errorref class="ST" code="0076"/>.</p>
          <p>The process of evaluating and comparing the orderspecs is based on
the following rules:</p> 

<ulist>

  

  <item> 
<p>
                <termref def="dt-atomization">Atomization</termref> is applied to the result of the expression
in each orderspec.  If the result of atomization is neither a single atomic value nor an empty sequence, a <termref def="dt-type-error">type error</termref> is raised <errorref class="TY" code="0004"/>.</p> 
</item>

  

  <item> 
<p>If the value of an orderspec has the <termref def="dt-dynamic-type">dynamic type</termref> <code>xs:untypedAtomic</code> (such as character
data in a schemaless document), it is cast to the type <code>xs:string</code>.</p> 
<note>
                <p>Consistently treating untyped values as strings enables the sorting process to begin without complete knowledge of the types of all the values to be sorted.</p>
              </note>
            </item>

  

  <item>
              <p>All the non-empty orderspec values must be convertible to a common type by  <termref def="dt-subtype-substitution">subtype substitution</termref> and/or <termref def="dt-type-promotion">type promotion</termref>. The ordering is performed in the least common type that has a <code>gt</code> operator. If two or more non-empty orderspec values are not convertible to a common type that has a <code>gt</code> operator, a <termref def="dt-type-error">type error</termref> is raised <errorref class="TY" code="0004"/>.</p>
<ulist>

  

  <item>
                  <p>Example: The orderspec values include a value of type <code>hatsize</code>, which is derived from <code>xs:integer</code>, and a value of type <code>shoesize</code>, which is derived from <code>xs:decimal</code>. The least common type reachable by subtype substitution and type promotion is <code>xs:decimal</code>.</p>
                </item>

  

  <item>
                  <p>Example: The orderspec values include a value of type <code>xs:string</code> and a value of type <code>xs:anyURI</code>. The least common type reachable by subtype substitution and type promotion is <code>xs:string</code>.</p>
                </item>
              </ulist>
            </item>
          </ulist>

<!-- <change diff="chg" at="XQ.E17"> -->
<p>For the purpose of determining their relative
             position in the ordering sequence, the <emph>greater-than</emph> 
             relationship between two orderspec values <emph>W</emph> and <emph>V</emph> is defined as follows:</p>
          <ulist>
             <item>
                <p>When the orderspec specifies <code>empty least</code>, 
                   the following rules are applied in order:
                </p>
                <olist>
                   <item>
                      <p>If <emph>V</emph> is an empty sequence and <emph>W</emph> is not an empty sequence,
                         then <emph>W</emph> <emph>greater-than</emph> <emph>V </emph> is true.</p>
                   </item>
                <item>
                      <p>If <emph>V</emph> is <code>NaN</code> and <emph>W</emph> is neither <code>NaN</code> 
                         nor an empty sequence, then 
                         <emph>W</emph> <emph>greater-than</emph> <emph>V</emph> is true.</p>
                   </item>
                <item>
                      <p>If a specific collation <emph>C</emph> is specified, and <emph>V</emph> and <emph>W</emph> are 
                         both of type <code>xs:string</code> or are convertible to 
                         <code>xs:string</code> by <termref def="dt-subtype-substitution">subtype substitution</termref> and/or <termref def="dt-type-promotion">type promotion</termref>, then:</p>
                  <p>If <code>fn:compare(V, W, C)</code> is less than 
                         zero, then <emph>W</emph> <emph>greater-than</emph> <emph>V</emph> is true; otherwise <emph>W</emph> <emph>greater-than</emph> <emph>V</emph> is false.</p>
                   </item>
                <item>
                  <p>If none of the above rules apply, then:</p>
                  <p>If <code>W gt V</code> is true, 
                         then <emph>W</emph> <emph>greater-than</emph> <emph>V</emph> is true; otherwise <emph>W</emph> <emph>greater-than</emph> <emph>V</emph> is false.</p>
                </item>
                </olist>
             </item>
            <item>
                <p>When the orderspec specifies <code>empty greatest</code>, 
                   the following rules are applied in order:
                </p>
                <olist>
                   <item>
                      <p>If <emph>W</emph> is an empty sequence and <emph>V</emph> is not an empty sequence,
                         then <emph>W</emph> <emph>greater-than</emph> <emph>V</emph> is true.</p>
                   </item>
                <item>
                      <p>If <emph>W</emph> is <code>NaN</code> and <emph>V</emph> is neither <code>NaN</code> 
                         nor an empty sequence, then 
                         <emph>W</emph> <emph>greater-than</emph> <emph>V</emph> is true.</p>
                   </item>
                <item>
                      <p>If a specific collation <emph>C</emph> is specified, and <emph>V</emph> and <emph>W</emph> are 
                         both of type <code>xs:string</code> or are convertible to 
                         <code>xs:string</code> by <termref def="dt-subtype-substitution">subtype substitution</termref> and/or <termref def="dt-type-promotion">type promotion</termref>, then:</p>
                   <p>If <code>fn:compare(V, W, C)</code> is less than 
                         zero, then <emph>W</emph> <emph>greater-than</emph> <emph>V</emph> is true; otherwise <emph>W</emph> <emph>greater-than</emph> <emph>V</emph> is false.</p>
                </item>
                <item>
                  <p>If none of the above rules apply, then:</p>
                  <p>If <code>W gt V</code> is true, 
                         then <emph>W</emph> <emph>greater-than</emph> <emph>V</emph> is true; otherwise <emph>W</emph> <emph>greater-than</emph> <emph>V</emph> is false.</p>
                </item>
                </olist>
             </item>
            <item>
                <p>When the orderspec specifies neither <code>empty least</code> 
                   nor <code>empty greatest</code>, the 
                   <termref def="dt-default-empty-order">default order for empty 
                   sequences</termref> in the 
                   <termref def="dt-static-context">static context</termref> 
                   determines whether the rules for <code>empty least</code> 
                   or <code>empty greatest</code> are used.
                </p>
             </item>
          </ulist> 
<!-- </change> -->

<p>If <emph>T1</emph> and <emph>T2</emph> are two tuples in the input tuple stream, and <emph>V1</emph> and <emph>V2</emph> are the first pair of  values encountered when evaluating their orderspecs  from left to right for which one value is <emph>greater-than</emph> the other (as defined above), then:</p> 


<olist> 


  

  <item> <p>If <emph>V1</emph> is <emph>greater-than</emph> <emph>V2:</emph> If the orderspec specifies <code>descending</code>, then <emph>T1</emph> precedes <emph>T2</emph> in the output tuple stream; otherwise, <emph>T2</emph> precedes <emph>T1</emph> in the output tuple stream.</p>
            </item>

  

  <item>
              <p>If <emph>V2</emph> is <emph>greater-than</emph> <emph>V1</emph>: If the orderspec specifies <code>descending</code>, then <emph>T2</emph> precedes <emph>T1</emph> in the output tuple stream; otherwise, <emph>T1</emph> precedes <emph>T2</emph> in the output tuple stream.</p>
            </item> 
 
 
 
</olist>
          <p>If neither <emph>V1</emph> nor <emph>V2</emph> is <emph>greater-than</emph> the other for any pair of orderspecs for tuples <emph>T1</emph> and <emph>T2</emph>, the following rules apply.</p>

<olist>

  

  <item>
              <p>If <code>stable</code> is specified, the original order of <emph>T1</emph> and <emph>T2</emph> is preserved in the output tuple stream.</p>
            </item>

  

  <item>
              <p>If <code>stable</code> is not specified, the order of <emph>T1</emph> and <emph>T2</emph> in the output tuple stream is <termref def="dt-implementation-dependent">implementation-dependent</termref>.</p>
            </item>
          </olist> 
<note>
            <p>If two orderspecs return the special floating-point values positive and negative zero, neither of these values is <emph>greater-than</emph> the other, since <code role="parse-test">+0.0 gt -0.0</code> and <code role="parse-test">-0.0 gt +0.0</code> are both <code>false</code>.</p>
          </note>
          <p>Examples:</p>
<ulist>

  

  <item>
              <p>This example illustrates the effect of an <code>order by</code> clause on a tuple stream. The keyword <code>stable</code> indicates that, when two tuples have equal sort keys, their order in the input tuple stream is preserved.</p>
              <p>Input tuple stream:</p>
              <eg xml:space="preserve">($license = "PFQ519", $make = "Ford",  $value = 16500)
($license = "HAJ865", $make = "Honda", $value = 22750)
($license = "NKV473", $make = "Ford",  $value = 21650)
($license = "RCM922", $make = "Dodge", $value = 11400)
($license = "ZBX240", $make = "Ford",  $value = 16500)
($license = "KLM030", $make = "Dodge", $value = () )</eg>
              <p>
                <code>order by</code> clause:</p>
              <eg xml:space="preserve">stable order by $make,
   $value descending empty least</eg>
              <p>Output tuple stream:</p>
              <eg xml:space="preserve">($license = "RCM922", $make = "Dodge", $value = 11400)
($license = "KLM030", $make = "Dodge", $value = () )
($license = "NKV473", $make = "Ford",  $value = 21650)
($license = "PFQ519", $make = "Ford",  $value = 16500)
($license = "ZBX240", $make = "Ford",  $value = 16500)
($license = "HAJ865", $make = "Honda", $value = 22750)</eg>
            </item>

  

  <item>
              <p>The following example shows how an <code>order by</code> clause can be used to sort the result of a query, even if the sort key is not included in the query result. This query returns employee names in descending order by salary, without returning the actual salaries:</p>
              <eg role="parse-test" xml:space="preserve">for $e in $employees 
order by $e/salary descending 
return $e/name</eg>

</item>
          </ulist>
          <note>
            <p>Since the <code>order by</code> clause in a FLWOR expression is the only facility provided by XQuery for specifying a value ordering, a FLWOR expression must be used in some queries where iteration would not otherwise be necessary. For example, a list of books with price less than 100 might be obtained by a simple <termref def="dt-path-expression">path expression</termref> such as <code role="parse-test">$books/book[price &lt; 100]</code>. But if these books are to be returned in alphabetic order by title, the query must be expressed as follows:</p>

<eg role="parse-test" xml:space="preserve">for $b in $books/book[price &lt; 100]
order by $b/title
return $b</eg>
          </note> 
 
 
</div3>
        <div3 id="id-return-clause">
          <head>Return Clause</head>
          <scrap headstyle="show"> 
<head/> 
 

<prod num="68" id="noid_N15BFD.doc-xquery11-ReturnClause">
              <lhs>ReturnClause</lhs>
              <rhs>"return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>
              </rhs>
            </prod>
</scrap>
          <p>The <code>return</code> clause is the final clause of a FLWOR expression. The <code>return</code> clause is evaluated once for each tuple in its input tuple stream,  using the variable bindings in the respective tuples, in the order in which these tuples appear in the input tuple stream. The results of these evaluations are concatenated, as if by the <termref def="dt-comma-operator">comma operator</termref>, to form the result of the FLWOR expression.</p>
          <p>The following example illustrates a FLWOR expression containing several clauses. The <code>for</code> clause iterates over all the departments in an input document named <code>depts.xml</code>, binding the variable <code>$d</code> to each department  in turn. For each binding of <code>$d</code>, the <code>let</code> clause binds variable <code>$e</code> to all the employees in the given department, selected from another input document named <code>emps.xml</code> (the relationship between employees and departments is represented by matching their <code>deptno</code> values). Each tuple in the resulting tuple stream contains a pair of bindings for <code>$d</code> and <code>$e</code> (<code>$d</code> is bound to a department and <code>$e</code> is bound to a set of employees in that department). The <code>where</code> clause filters the tuple stream, retaining only those tuples that represent departments having at least ten employees. The <code>order by</code> clause orders the surviving tuples in descending order by the average salary of the employees in the department. The <code>return</code> clause constructs a new <code>big-dept</code> element for each surviving tuple, containing the department number, headcount, and average salary.</p>
          <eg role="parse-test" xml:space="preserve">for $d in fn:doc("depts.xml")//dept
let $e := fn:doc("emps.xml")//emp[deptno eq $d/deptno]
where fn:count($e) &gt;= 10
order by fn:avg($e/salary) descending
return
   &lt;big-dept&gt;
      {
      $d/deptno,
      &lt;headcount&gt;{fn:count($e)}&lt;/headcount&gt;,
      &lt;avgsal&gt;{fn:avg($e/salary)}&lt;/avgsal&gt;
      }
   &lt;/big-dept&gt;</eg>
          <notes>
<ulist>

  

  <item>
                <p>The order in which items appear in the result of a FLWOR expression depends on the ordering of the input tuple stream to the <code>return</code> clause, which in turn is influenced by <code>order by</code> clauses and by <termref def="dt-ordering-mode">ordering mode</termref>. For example, consider the following query, which is based on the same two input documents as the previous example:</p>
                <eg role="parse-test" xml:space="preserve">for $d in fn:doc("depts.xml")//dept
order by $d/deptno
for $e in fn:doc("emps.xml")//emp[deptno eq $d/deptno]
return
   &lt;assignment&gt;
      {$d/deptno, $e/name}
   &lt;/assignment&gt;</eg>
                <p>The result of this query is a sequence of <code>assignment</code> elements, each containing a <code>deptno</code> element and a <code>name</code> element. The sequence will be ordered primarily by the <code>deptno</code> values because of the <code>order by</code> clause. If <termref def="dt-ordering-mode">ordering mode</termref> is <code>ordered</code>, subsequences of <code>assignment</code> elements with equal <code>deptno</code> values will be ordered by the document order of their <code>name</code> elements within the <code>emps.xml</code> document; otherwise the ordering of these subsequences will be <termref def="dt-implementation-dependent">implementation-dependent</termref>.</p>
              </item>

  <item>
                <p>Parentheses are helpful in <code>return</code> clauses that contain comma operators, 
since FLWOR expressions have a higher precedence than the comma 
operator. For example, the following query raises an error because 
after the comma, <code>$j</code> is no longer within the FLWOR expression, and is an 
undefined variable:</p>
                <eg role="parse-test" xml:space="preserve">let $i := 5,
    $j := 20 * $i
return $i, $j</eg>
                <p>Parentheses can be used to bring <code>$j</code> into the <code>return</code> clause of the FLWOR expression, as the 
programmer probably intended:</p>
                <eg role="parse-test" xml:space="preserve">let $i := 5,
    $j := 20 * $i
return ($i, $j)</eg>
              </item>
            </ulist>
          </notes>
        </div3>
      </div2>	
<div2 role="xquery" id="id-unordered-expressions"> 
<head>Ordered and Unordered Expressions</head> 
<scrap headstyle="show"> 
<head/> <prod num="132" id="doc-xquery11-OrderedExpr">
            <lhs>OrderedExpr</lhs>
            <rhs>"ordered"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Expr" xlink:type="simple">Expr</nt>  "}"</rhs>
          </prod> 
<prod num="133" id="doc-xquery11-UnorderedExpr">
            <lhs>UnorderedExpr</lhs>
            <rhs>"unordered"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Expr" xlink:type="simple">Expr</nt>  "}"</rhs>
          </prod>
        </scrap>
        <p>The purpose of <code>ordered</code> and <code>unordered</code> expressions is to set the <termref def="dt-ordering-mode">ordering mode</termref> in the <termref def="dt-static-context">static context</termref> to <code>ordered</code> or <code>unordered</code> for a certain region in a query. The specified ordering mode applies to the expression nested inside the curly braces. For expressions where the ordering of the result is not significant, a performance advantage may be realized by setting the ordering mode to <code>unordered</code>, thereby granting the system flexibility to return the result in the order that it finds most efficient.</p>
        <p> <termref def="dt-ordering-mode">Ordering mode</termref> affects the behavior of <termref def="dt-path-expression">path expressions</termref> that include a "<code>/</code>" or "<code>//</code>" operator or an <termref def="dt-axis-step">axis step</termref>; <code>union</code>, <code>intersect</code>, and <code>except</code> expressions; the <code>fn:id</code> and <code>fn:idref</code> functions; and certain clauses within a FLWOR expression. If ordering mode is <code>ordered</code>, node sequences returned by path expressions, <code>union</code>, <code>intersect</code>, and <code>except</code> expressions, and the <code>fn:id</code> and <code>fn:idref</code> functions are in <termref def="dt-document-order">document order</termref>; otherwise the order of these return sequences is <termref def="dt-implementation-dependent">implementation-dependent</termref>. The effect of ordering mode on FLWOR expressions is described in <specref ref="id-xquery-for-clause"/>, <specref ref="id-effects-of-window-clauses"/>, and <specref ref="id-group-by"/>. Ordering mode has no effect on duplicate elimination.</p>
        <note>
          <p>In a region of a query where ordering mode is <code>unordered</code>, the result of an expression may be nondeterministic if the expression invokes certain functions that are affected by the ordering of node sequences. These functions include <code>fn:position</code>, <code>fn:last</code>, <code>fn:index-of</code>, <code>fn:insert-before</code>, <code>fn:remove</code>, <code>fn:reverse</code>, and <code>fn:subsequence</code>. Also, within a <termref def="dt-path-expression">path expression</termref> in an  unordered region, <termref def="dt-numeric-predicate">numeric predicates</termref> are nondeterministic. For example, in an ordered region, the path expression <code role="parse-test">(//a/b)[5]</code> will return the fifth qualifying <code>b</code>-element in <termref def="dt-document-order">document order</termref>. In an unordered region, the same expression will return an <termref def="dt-implementation-dependent">implementation-dependent</termref> qualifying <code>b</code>-element.</p>
        </note>
        <note>
          <p>The <code>fn:id</code> and <code>fn:idref</code> functions are described in <bibref ref="xpath-functions-11"/> as returning their results in <termref def="dt-document-order">document order</termref>. Since ordering mode is a feature of XQuery, relaxation of the ordering requirement for function results when ordering mode is <code>unordered</code> is a feature of XQuery rather than of the functions themselves.</p>
        </note> 
	

<p>The use of an <code>unordered</code> expression is illustrated by the following example, which joins together two documents named <code>parts.xml</code> and <code>suppliers.xml</code>. The example returns the part numbers of red parts, paired with the supplier numbers of suppliers who supply these parts. If an <code>unordered</code> expression were not used, the resulting list of (part number, supplier number) pairs would be required to have an ordering that is controlled primarily by the <termref def="dt-document-order">document order</termref> of <code>parts.xml</code> and secondarily by the <termref def="dt-document-order">document order</termref> of <code>suppliers.xml</code>. However, this might not be the most efficient way to process the query if the ordering of the result is not important. An XQuery implementation might be able to process the query more efficiently by using an index to find the red parts, or by using <code>suppliers.xml</code> rather than <code>parts.xml</code> to control the primary ordering of the result. The <code>unordered</code> expression gives the query evaluator freedom to make these kinds of optimizations.</p>
        <eg role="parse-test" xml:space="preserve">unordered {
  for $p in fn:doc("parts.xml")/parts/part[color = "Red"],
      $s in fn:doc("suppliers.xml")/suppliers/supplier
  where $p/suppno = $s/suppno  
  return
    &lt;ps&gt;
       { $p/partno, $s/suppno }
    &lt;/ps&gt;
}</eg>
        <p>In addition to <code>ordered</code> and <code>unordered</code> expressions, XQuery provides a function named <code>fn:unordered</code> that operates on any sequence of items and returns the same sequence in a nondeterministic order. A call to the <code>fn:unordered</code> function may be thought of as giving permission for the argument expression to be materialized in whatever order the system finds most efficient. The <code>fn:unordered</code> function relaxes ordering only for the sequence that is its immediate operand, whereas an <code>unordered</code> expression sets the <termref def="dt-ordering-mode">ordering mode</termref> for its operand expression and all nested expressions.</p>
      </div2>	

<div2 id="id-conditionals"> 
<head>Conditional Expressions</head> 
<p>XQuery 1.1 supports a conditional expression based on the keywords <code>if</code>, <code>then</code>, and <code>else</code>.</p> 
<scrap headstyle="show"> 
<head/> <prod num="76" id="doc-xquery11-IfExpr">
            <lhs>IfExpr</lhs>
            <rhs>"if"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Expr" xlink:type="simple">Expr</nt>  ")"  "then"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>  "else"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>
            </rhs>
          </prod> 
</scrap> 
<p>The expression following the <code>if</code> keyword is called the <term>test expression</term>, and the expressions
following the <code>then</code> and <code>else</code> keywords are called the <term>then-expression</term> and <term>else-expression</term>, respectively.</p> 
<p>The first step in processing a conditional expression is to find
the <termref def="dt-ebv">effective boolean value</termref> of the test expression, as defined in <specref ref="id-ebv"/>.</p> 
 
<p>The value of a conditional expression is defined as follows: If the
effective boolean value of the test expression is <code>true</code>, the value of the then-expression is returned. If the
effective boolean value of the test expression is <code>false</code>,
the value of the else-expression is returned.</p>
        <p>Conditional expressions have a special rule for propagating <termref def="dt-dynamic-error">dynamic errors</termref>. If the effective value of the test expression is <code>true</code>, the conditional expression ignores (does not raise) any dynamic errors encountered in the else-expression. In this case, since the else-expression can have no observable effect, it need not be evaluated. Similarly, if the effective value of the test expression is <code>false</code>, the conditional expression ignores any <termref def="dt-dynamic-error">dynamic errors</termref> encountered in the then-expression, and the then-expression need not be evaluated.</p> 
<p>Here are some examples of conditional expressions:</p> 

<ulist> 


  

  <item> 
<p>In this example, the test expression is a comparison expression:</p> 
<eg role="parse-test" xml:space="preserve">if ($widget1/unit-cost &lt; $widget2/unit-cost) 
  then $widget1
  else $widget2</eg> 
</item> 


  

  <item> 
<p>In this example, the test expression tests for the existence of an attribute
named <code>discounted</code>, independently of its value:</p> 
<eg role="parse-test" xml:space="preserve">if ($part/@discounted) 
  then $part/wholesale 
  else $part/retail</eg> 
</item> 
</ulist>	
</div2>	

<div2 id="id-switch" role="xquery">
<head>Switch Expression</head>
<scrap headstyle="show"> 
<head/> 
 <prod num="70" id="doc-xquery11-SwitchExpr">
            <lhs>SwitchExpr</lhs>
            <rhs>"switch"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Expr" xlink:type="simple">Expr</nt>  ")"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SwitchCaseClause" xlink:type="simple">SwitchCaseClause</nt>+  "default"  "return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>
            </rhs>
          </prod> 
<prod num="71" id="doc-xquery11-SwitchCaseClause">
            <lhs>SwitchCaseClause</lhs>
            <rhs>("case"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SwitchCaseOperand" xlink:type="simple">SwitchCaseOperand</nt>)+  "return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>
            </rhs>
          </prod>  
<prod num="72" id="doc-xquery11-SwitchCaseOperand">
            <lhs>SwitchCaseOperand</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>
            </rhs>
          </prod>  
</scrap>
<p>
The <term>switch expression</term> chooses one of several expressions to evaluate based on the 
input value. 
</p>
<p>
In a <code>switch</code> expression, the <code>switch</code> keyword is followed by an expression enclosed 
in parentheses, called the <term>switch operand expression</term>. This is the expression whose value is 
being compared. The remainder of the <code>switch</code> expression consists of one or more 
<code>case</code> clauses, with one or more <code>case operand
expressions</code> each, and a <code>default</code> clause. </p>


<p>The first step in evaluating a switch expression is to apply
atomization to the value of the switch operand expression. If the
result is a sequence of length greater than one, a type error is
raised <errorref class="TY" code="0004"/>.</p>

<p>The resulting value is matched against each <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SwitchCaseOperand" xlink:type="simple">SwitchCaseOperand</nt> in turn until a
match is found or the list is exhausted. The matching is performed as follows:</p>

<olist>
<item>
            <p>The <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SwitchCaseOperand" xlink:type="simple">SwitchCaseOperand</nt> is evaluated.</p>
          </item>
<item>
            <p>The resulting value is atomized.</p>
          </item>
<item>
            <p>If the atomized sequence has length greater than one, a type error is raised
 <errorref class="TY" code="0004"/>.</p>
          </item>
<item>
            <p>The atomized value of the switch operand expression is compared with the
atomized value of the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SwitchCaseOperand" xlink:type="simple">SwitchCaseOperand</nt> using the <function>fn:deep-equal</function> function,
with the default collation from the static context.</p>
          </item>
</olist>

<p>
          <termdef id="id-effective-case-switch-expression" term="effective case"> The <term>effective case</term> of a switch expression is the
first case clause that matches, using the rules given above, or the
default clause if no such case clause exists.</termdef> The value of
the switch expression is the value of the return expression in the
effective case.</p>

<p>Switch expressions have rules regarding the propagation of dynamic
errors that take precedence over the general rules given in <specref ref="id-errors-and-opt"/>.

The return clauses of a switch expression must not raise any dynamic
errors except in the effective case.  Dynamic errors raised in the
operand expressions of the switch or the case clauses are propagated;
however, an implementation must not raise dynamic errors in the
operand expressions of case clauses that occur after the effective
case. An implementation is permitted to raise dynamic errors in the
operand expressions of case clauses that occur before the effective
case, but not required to do so.</p>
 
<p>The following example shows how a switch expression might be used:</p>
 
<eg role="parse-test" xml:space="preserve">
switch ($animal) 
   case "Cow" return "Moo"
   case "Cat" return "Meow"
   case "Duck" return "Quack"
   default return "What's that odd noise?" 
 </eg>
</div2>

<div2 id="id-quantified-expressions">
<head>Quantified Expressions</head> 
<p>Quantified expressions support existential and universal quantification. The
value of a quantified expression is always <code>true</code> or <code>false</code>.</p>
<scrap headstyle="show">
<head/> 
<prod num="69" id="doc-xquery11-QuantifiedExpr">
            <lhs>QuantifiedExpr</lhs>
            <rhs>("some"  |  "every")  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-VarName" xlink:type="simple">VarName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-VarName" xlink:type="simple">VarName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>)*  "satisfies"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>
            </rhs>
          </prod>
<prod num="168" id="noid_N15EA9.doc-xquery11-TypeDeclaration">
            <lhs>TypeDeclaration</lhs>
            <rhs>"as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SequenceType" xlink:type="simple">SequenceType</nt>
            </rhs>
          </prod>
        </scrap>
<p>A <term>quantified expression</term> begins with
a <term>quantifier</term>, which is the keyword <code>some</code> or <code>every</code>, followed by one or more in-clauses that are used to bind variables,
followed by the keyword <code>satisfies</code> and a test expression. Each in-clause associates a variable with an
expression that returns a sequence of items, called the binding sequence for that variable. The in-clauses generate tuples of variable bindings, including a tuple for each combination of items in the binding sequences of the respective variables. Conceptually, the test expression is evaluated for each
tuple of variable bindings. Results depend on the <termref def="dt-ebv">effective boolean value</termref> of the test expressions, as defined in <specref ref="id-ebv"/>. The value of the quantified expression is defined
by the following rules:</p>


<olist>


  

  <item>
<p>If the quantifier is <code>some</code>, the quantified expression is <code>true</code> if at least one evaluation of the test expression has the <termref def="dt-ebv">effective boolean value</termref> <code>true</code>; otherwise the quantified expression is <code>false</code>. This rule implies that, if the in-clauses generate zero binding
tuples, the value of the quantified expression is <code>false</code>.</p>
</item>


  

  <item>
<p>If the quantifier is <code>every</code>, the quantified expression is <code>true</code> if every evaluation of the test expression has the <termref def="dt-ebv">effective boolean value</termref> <code>true</code>; otherwise the quantified expression is <code>false</code>. This rule implies that, if the in-clauses generate zero binding
tuples, the value of the quantified 
expression is <code>true</code>.</p>
</item>
</olist>


<p>The scope of a variable bound in a quantified expression comprises all
subexpressions of the quantified expression that appear after the variable binding. The scope does not include the expression to which the variable is bound.
</p>
        <p role="xquery">Each variable bound in an in-clause of a quantified expression may have an optional <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TypeDeclaration" xlink:type="simple">type declaration</nt>. If the type of a value bound to the variable does not match the declared type according to the rules for <termref def="dt-sequencetype-matching">SequenceType
matching</termref>, a <termref def="dt-type-error">type error</termref> is raised <errorref class="TY" code="0004"/>.</p>
        <p>The order in which test expressions are evaluated for the various binding
tuples is <termref def="dt-implementation-dependent">implementation-dependent</termref>. If the quantifier 
is <code>some</code>, an implementation may 
return <code>true</code> as soon as it finds one binding tuple for which the test expression has
an <termref def="dt-ebv">effective boolean value</termref> of <code>true</code>, and it may raise a <termref def="dt-dynamic-error">dynamic error</termref> as soon as it finds one binding tuple for
which the test expression raises an error. Similarly, if the quantifier is <code>every</code>, an implementation may return <code>false</code> as soon as it finds one binding tuple for which the test expression has
an <termref def="dt-ebv">effective boolean value</termref> of <code>false</code>, and it may raise a <termref def="dt-dynamic-error">dynamic error</termref> as soon as it finds one binding tuple for
which the test expression raises an error. As a result of these rules, the
value of a quantified expression is not deterministic in the presence of
errors, as illustrated in the examples below.</p>
<p>Here are some examples of quantified expressions:</p>

<ulist>


  

  <item>
<p>This expression is <code>true</code> if every <code>part</code> element has a <code>discounted</code> attribute (regardless of the values of these attributes):</p> 
<eg role="parse-test" xml:space="preserve">every $part in /parts/part satisfies $part/@discounted</eg>
</item> 


  

  <item>
<p>This expression is <code>true</code> if at least 
one <code>employee</code> element satisfies the given comparison expression:</p> 
<eg role="parse-test" xml:space="preserve">some $emp in /emps/employee satisfies 
     ($emp/bonus &gt; 0.25 * $emp/salary)</eg>
</item>


  

  <item>
<p>In the following examples, each quantified expression evaluates its test
expression over nine tuples of variable bindings, formed from the Cartesian
product of the sequences <code>(1, 2, 3)</code> and <code>(2, 3, 4)</code>. The expression beginning with <code>some</code> evaluates to <code>true</code>, and the expression beginning with <code>every</code> evaluates to <code>false</code>.</p>
<eg role="parse-test" xml:space="preserve">some $x in (1, 2, 3), $y in (2, 3, 4) 
satisfies $x + $y = 4</eg>

<eg role="parse-test" xml:space="preserve">every $x in (1, 2, 3), $y in (2, 3, 4) 
satisfies $x + $y = 4</eg>
</item>

  <item>
<p>This quantified expression may either return  <code>true</code> or raise a <termref def="dt-type-error">type error</termref>, since its test expression returns <code>true</code> for one variable binding 
and raises a <termref def="dt-type-error">type error</termref> for another:</p>
<eg role="parse-test" xml:space="preserve">some $x in (1, 2, "cat") satisfies $x * 2 = 4</eg>
</item>


  

  <item>
<p>This quantified expression may either return <code>false</code> or raise a <termref def="dt-type-error">type error</termref>, since its test expression returns <code>false</code> for one variable binding and raises a <termref def="dt-type-error">type error</termref> for another:</p>
<eg role="parse-test" xml:space="preserve">every $x in (1, 2, "cat") satisfies $x * 2 = 4</eg>
</item> 


  

  <item role="xquery">
<p>This quantified expression  contains a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TypeDeclaration" xlink:type="simple">type declaration</nt> that is not satisfied by every item in the  test expression. If the <termref def="dt-static-typing-feature">Static Typing Feature</termref> is implemented, this expression raises a <termref def="dt-type-error">type error</termref> during the <termref def="dt-static-analysis">static analysis
phase</termref>. Otherwise, the expression may either return <code>true</code> or raise a <termref def="dt-type-error">type error</termref> during the <termref def="dt-dynamic-evaluation">dynamic evaluation
phase</termref>.</p>
<eg role="parse-test" xml:space="preserve">some $x as xs:integer in (1, 2, "cat") satisfies $x * 2 = 4</eg>
</item>
        </ulist>
</div2>
<div2 id="id-try-catch" role="xquery">
<head>Try/Catch Expressions</head>
               
<p>The try/catch expression provides error handling for dynamic errors
and type errors raised during dynamic evaluation, including errors
raised by the XQuery implementation and errors explicitly raised in a
query using the <code>fn:error()</code> function.</p>

<scrap headstyle="show">
<head/> 
<prod num="77" id="doc-xquery11-TryCatchExpr">
            <lhs>TryCatchExpr</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TryClause" xlink:type="simple">TryClause</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-CatchClause" xlink:type="simple">CatchClause</nt>+</rhs>
          </prod>
<prod num="78" id="doc-xquery11-TryClause">
            <lhs>TryClause</lhs>
            <rhs>"try"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TryTargetExpr" xlink:type="simple">TryTargetExpr</nt>  "}"</rhs>
          </prod>
<prod num="79" id="doc-xquery11-TryTargetExpr">
            <lhs>TryTargetExpr</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Expr" xlink:type="simple">Expr</nt>
            </rhs>
          </prod>
<prod num="80" id="doc-xquery11-CatchClause">
            <lhs>CatchClause</lhs>
            <rhs>"catch"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-CatchErrorList" xlink:type="simple">CatchErrorList</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-CatchVars" xlink:type="simple">CatchVars</nt>?  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Expr" xlink:type="simple">Expr</nt>  "}"</rhs>
          </prod>
<prod num="81" id="doc-xquery11-CatchErrorList">
            <lhs>CatchErrorList</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-NameTest" xlink:type="simple">NameTest</nt>  ("|"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-NameTest" xlink:type="simple">NameTest</nt>)*</rhs>
          </prod>
<prod num="82" id="doc-xquery11-CatchVars">
            <lhs>CatchVars</lhs>
            <rhs>"("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-CatchErrorCode" xlink:type="simple">CatchErrorCode</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-CatchErrorDesc" xlink:type="simple">CatchErrorDesc</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-CatchErrorVal" xlink:type="simple">CatchErrorVal</nt>)?)?  ")"</rhs>
          </prod>
<prod num="83" id="doc-xquery11-CatchErrorCode">
            <lhs>CatchErrorCode</lhs>
            <rhs>"$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-VarName" xlink:type="simple">VarName</nt>
            </rhs>
          </prod>
<prod num="84" id="doc-xquery11-CatchErrorDesc">
            <lhs>CatchErrorDesc</lhs>
            <rhs>"$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-VarName" xlink:type="simple">VarName</nt>
            </rhs>
          </prod>
<prod num="85" id="doc-xquery11-CatchErrorVal">
            <lhs>CatchErrorVal</lhs>
            <rhs>"$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-VarName" xlink:type="simple">VarName</nt>
            </rhs>
          </prod>
</scrap>

                <p>A try/catch expression catches <termref def="dt-dynamic-error">dynamic errors</termref> and
                <termref def="dt-type-error">type errors</termref>
                raised during dynamic evaluation for expressions that
                are lexically contained within the <code>try</code>
                clause. If the target expression does not raise a
                dynamic error or a type error, the result of the
                try/catch expression is the result of the target
                expression.</p>

                <p>If the target expression raises a dynamic error or
                a type error, the result of the try/catch expression
                is obtained by evaluating the first <code>catch</code>
                clause that "matches" the error value, as described
                below.  A <code>catch</code> clause with one or more
                NameTests matches any error whose error code matches
                one of these NameTests. For instance, if the error
                code is <code>err:FOER0000</code>, then it matches a
                <code>catch</code> clause whose ErrorList is
                <code>err:FOER0000 | err:FOER0001</code>. Wildcards
                may be used in NameTests; thus, the error code
                <code>err:FOER0000</code> also matches a
                <code>catch</code> clause whose ErrorList is
                <code>err:*</code> or <code>*:FOER0000</code> or
                <code>*</code>.</p>


                <p>If an error is matched, the optional variables in
                the <code>catch</code> clause are bound, in order, to
                the error's code, description, and value. These
                variables are then in scope in the <code>catch</code>
                clause.  The types of these variables match the types
                of the corresponding parameters in the
                <code>error()</code> function: <code>ErrorCode</code>
                has type <code>xs:QName</code>,
                <code>ErrorDescr</code> has type
                <code>xs:string?</code>, and <code>ErrorVal</code> has
                type <code>item()*</code>. If no <code>catch</code>
                clause matches an error, the try/catch expression
                raises that error.  If an error is raised in a catch
                clause, the try/catch expression raises that error.
                </p>

                <p>If an error found in a <code>try</code> clause can
                be detected statically, an implementation is free to
                raise a static error. Static errors are not caught by
                the try/catch expression.</p>


                <p>If a function call occurs within a <code>try</code> clause,
                errors raised by evaluating the corresponding function are caught by the try/catch
                expression. If a variable reference is used in a <code>try</code>
                clause, errors raised by binding a value to the variable are not
                caught unless the binding expression occurs within the <code>try</code>
                clause.</p>


                <note>
                  <p>The presence of a try/catch expression does not
                  prevent an implementation from using a lazy
                  evaluation strategy, nor does it prevent an
                  optimizer performing expression rewrites. However,
                  if the evaluation of an expression inside a
                  try/catch is rewritten or deferred in this way, it
                  must take its try/catch context with it. Similarly,
                  expressions that were written outside the try/catch
                  expression may be evaluated inside the try/catch,
                  but only if they retain their original try/catch
                  behavior. The presence of a try/catch does not
                  change the rules that allow the processor to
                  evaluate expressions in such a way that may avoid
                  the detection of some errors. </p>
                </note>


		<p>Here are some examples of try/catch expressions.</p>

		
<ulist>
		  

  

  <item>
<p>A try/catch expression without a CatchErrorList catches any error:</p>

<eg role="parse-test" xml:space="preserve">try {
    $x cast as xs:integer
}
catch * {
    0
}</eg>
          </item>



  

  <item>
<p>The CatchErrorList in this try/catch expression specifies that only <code>err:FORG0001</code> is caught:</p>

<eg role="parse-test" xml:space="preserve">try {
    $x cast as xs:integer
}
catch err:FORG0001 {
    0
}</eg>
          </item>


  

  <item>
<p>The CatchErrorList in this try/catch expression specifies that errors <code>err:FORG0001</code> and <code>err:XPTY0004</code> are caught:</p>


<eg role="parse-test" xml:space="preserve">try {
    $x cast as xs:integer
}
catch err:FORG0001 | err:XPTY0004 {
    0
}</eg>
	<note>
              <p>In some implementations, <code>err:XPTY0004</code> is detected during static
	evaluation; it can only be caught if it is raised during dynamic evaluation.</p>
            </note>
  
</item>



  <item>
<p>This try/catch expression shows how to bind variables to the error code, error description, and error value. Since the CatchErrorList is a wildcard, it catches any error:</p>

<eg role="parse-test" xml:space="preserve">try {
    fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))
}
catch * ($errcode, $errdesc, $errval) {
    $errcode, $errdesc
}</eg>
          </item>

  

  <item>
<p>Errors raised by using the result of a try/catch expression are not caught, since they are outside the scope of the <code>try</code> expression.</p>

<eg role="parse-test" xml:space="preserve">
declare function local:thrice($x as xs:integer) as xs:integer
{
    3*$x
};

local:thrice(try { "oops" } catch * { 3 } )
</eg>
<p>In this example, the try block succeeds, returning the string "oops", which is not a valid argument to the function.</p>
          </item>
		</ulist>

</div2>
<div2 id="id-expressions-on-datatypes"> 
<head>Expressions on SequenceTypes</head> 
<p>
          <phrase role="xquery">In addition to their use in function parameters and results, </phrase>
          <termref def="dt-sequence-type">sequence types</termref> are used in <code>instance of</code>, <phrase role="xquery">
            <code>typeswitch</code>,</phrase> <code>cast</code>, <code>castable</code>, and <code>treat</code> expressions.</p> 
 
 
 
 
 
 
 
 
<div3 id="id-instance-of">
          <head>Instance Of</head>
          <scrap headstyle="show"> 
<head/> 
<prod num="94" id="doc-xquery11-InstanceofExpr">
              <lhs>InstanceofExpr</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TreatExpr" xlink:type="simple">TreatExpr</nt> ( "instance"  "of"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SequenceType" xlink:type="simple">SequenceType</nt> )?</rhs>
            </prod>    
</scrap>
          <p>The boolean 
operator <code>instance of</code> 
returns <code>true</code> if the value of its first operand matches
the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SequenceType" xlink:type="simple">SequenceType</nt> in its second
operand, according to the rules for <termref def="dt-sequencetype-matching">SequenceType
matching</termref>; otherwise it returns <code>false</code>. For example:</p> 

<ulist>

  

  <item>
              <p>
                <code role="parse-test">5 instance of xs:integer</code>
              </p>
              <p>This example returns <code>true</code> because the given value is an instance of the given type.</p>
            </item>

  

  <item>
              <p>
                <code>5 instance of xs:decimal</code>
              </p>
              <p>This example returns <code>true</code> because the given value is an integer literal, and <code>xs:integer</code> is derived by restriction from <code>xs:decimal</code>.</p>
            </item>

  

  <item role="xquery">
              <p>
                <code role="parse-test">&lt;a&gt;{5}&lt;/a&gt; instance of xs:integer</code>
              </p>
              <p>This example returns <code>false</code> because the given value is an element rather than an integer.</p>
            </item>

  

  <item>
              <p>
                <code role="parse-test">(5, 6) instance of xs:integer+</code>
              </p>
              <p>This example returns <code>true</code> because the given sequence contains two integers, and is a valid instance of the specified type.</p>
            </item>

  

  <item>
              <p>
                <code role="parse-test">. instance of element()</code>
              </p>
              <p>This example returns <code>true</code> if the context item is an element node or <code>false</code> if the context item is defined but is not an element node. If the context item is undefined, a <termref def="dt-dynamic-error">dynamic error</termref> is raised <errorref class="DY" code="0002"/>.</p>
            </item>
          </ulist>
        </div3>

<div3 id="id-typeswitch" role="xquery">
          <head>Typeswitch</head>
<scrap headstyle="show"> 
<head/> 
 <prod num="73" id="doc-xquery11-TypeswitchExpr">
              <lhs>TypeswitchExpr</lhs>
              <rhs>"typeswitch"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Expr" xlink:type="simple">Expr</nt>  ")"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-CaseClause" xlink:type="simple">CaseClause</nt>+  "default"  ("$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-VarName" xlink:type="simple">VarName</nt>)?  "return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>
              </rhs>
            </prod> 
<prod num="74" id="doc-xquery11-CaseClause">
              <lhs>CaseClause</lhs>
              <rhs>"case"  ("$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-VarName" xlink:type="simple">VarName</nt>  "as")?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SequenceTypeUnion" xlink:type="simple">SequenceTypeUnion</nt>  "return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>
              </rhs>
            </prod>  
<prod num="75" id="doc-xquery11-SequenceTypeUnion">
              <lhs>SequenceTypeUnion</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SequenceType" xlink:type="simple">SequenceType</nt>  ("|"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SequenceType" xlink:type="simple">SequenceType</nt>)*</rhs>
            </prod>  
</scrap>
<p role="xquery">The <term>typeswitch</term> expression chooses one of
several expressions to evaluate based on the <termref def="dt-dynamic-type">dynamic type</termref> of an input value.</p>

<p role="xquery">In a <code>typeswitch</code> expression, the
<code>typeswitch</code> keyword is followed by an expression enclosed
in parentheses, called the <term>operand expression</term>. This is
the expression whose type is being tested. The remainder of the
<code>typeswitch</code> expression consists of one or more
<code>case</code> clauses and a <code>default</code> clause.</p>

<p role="xquery">Each <code>case</code> clause specifies one or more
<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SequenceType" xlink:type="simple">SequenceType</nt>s followed by a
<code>return</code> expression. <termdef term="effective case" id="dt-effective-case">The <term>effective case</term> in a
<code>typeswitch</code> expression is the first <code>case</code>
clause in which the value of the operand expression matches a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SequenceType" xlink:type="simple">SequenceType</nt> in the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SequenceType" xlink:type="simple">SequenceTypeUnion</nt> of the <code>case</code>
clause, using the rules of <termref def="dt-sequencetype-matching">SequenceType matching</termref>.
</termdef> 

The value of the <code>typeswitch</code> expression is the value of
the <code>return</code> expression in the effective case. If the value
of the operand expression does not match any <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SequenceType" xlink:type="simple">SequenceType</nt> named in a <code>case</code>
clause, the value of the <code>typeswitch</code> expression is the
value of the <code>return</code> expression in the
<code>default</code> clause.</p>
          <p>In a <code>case</code> or
<code>default</code> clause, if the value to be returned depends on
the value of the operand expression, the clause must specify a
variable name. Within the <code>return</code> expression of the
<code>case</code> or <code>default</code> clause, this variable name
is bound to the value of the operand expression. 

Inside a <code>case</code> clause, the <termref def="dt-static-type">static type</termref> of the variable is the
union of the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SequenceType" xlink:type="simple">SequenceType</nt>s named in the
<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SequenceType" xlink:type="simple">SequenceTypeUnion</nt>.  Inside a
<code>default</code> clause, the static type of the variable is the
same as the static type of the operand expression.

If the value to be returned by a <code>case</code> or
<code>default</code> clause does not depend on the value of the
operand expression, the clause need not specify a variable.</p>
          <p>The
scope of a variable binding in a <code>case</code> or
<code>default</code> clause comprises that clause. It is not an error
for more than one <code>case</code> or <code>default</code> clause in
the same <code>typeswitch</code> expression to bind variables with the
same name.
</p> 
 
<p>A special rule applies to propagation of <termref def="dt-dynamic-error">dynamic errors</termref> by <code>typeswitch</code> expressions. A <code>typeswitch</code> expression ignores (does not raise) any dynamic errors encountered in <code>case</code> clauses other than the <termref def="dt-effective-case">effective case</termref>. Dynamic errors encountered in the <code>default</code> clause are raised only if there is no <termref def="dt-effective-case">effective case</termref>.
An implementation is permitted to raise dynamic errors in the
operand expressions of case clauses that occur before the  <termref def="dt-effective-case">effective
case</termref>, but not required to do so.</p>

<p role="xquery">The following example shows how a <code>typeswitch</code> expression might
be used to process an expression in a way that depends on its <termref def="dt-dynamic-type">dynamic type</termref>.</p>
<eg role="parse-test" xml:space="preserve">typeswitch($customer/billing-address)
   case $a as element(*, USAddress) return $a/state
   case $a as element(*, CanadaAddress) return $a/province
   case $a as element(*, JapanAddress) return $a/prefecture
   default return "unknown"
</eg>

<p>The following example shows a union of sequence types in a single case:</p>

<eg role="parse-test" xml:space="preserve">typeswitch($customer/billing-address)
   case $a as element(*, USAddress) 
            | element(*, AustraliaAddress) 
            | element(*, MexicoAddress)
     return $a/state
   case $a as element(*, CanadaAddress) 
     return $a/province
   case $a as element(*, JapanAddress)
     return $a/prefecture
   default
     return "unknown"</eg>

</div3>
        <div3 id="id-cast">
          <head>Cast</head>
          <scrap headstyle="show"> 
<head/> 
   <prod num="97" id="doc-xquery11-CastExpr">
              <lhs>CastExpr</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-UnaryExpr" xlink:type="simple">UnaryExpr</nt> ( "cast"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SingleType" xlink:type="simple">SingleType</nt> )?</rhs>
            </prod> 
<prod num="167" id="doc-xquery11-SingleType">
              <lhs>SingleType</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AtomicType" xlink:type="simple">AtomicType</nt>  "?"?</rhs>
            </prod>
          </scrap>
          <p>Occasionally
it is necessary to convert a value to a specific datatype. For this
purpose, XQuery 1.1 provides a <code>cast</code> expression that
creates a new value of a specific type based on an existing value. A
<code>cast</code> expression takes two operands: an <term>input
expression</term> and a <term>target type</term>. The type of the
input expression is called the <term>input type</term>. The target
type must be an atomic type that is in the <termref def="dt-is-types">in-scope schema types</termref> <errorref class="ST" code="0051"/>. In addition, the target type cannot be <code>xs:NOTATION</code> or <code>xs:anyAtomicType</code> <errorref class="ST" code="0080"/>. The optional occurrence indicator "<code>?</code>" denotes that an empty
sequence is permitted. If the target type has no namespace prefix, it
is considered to be in the <termref def="dt-def-elemtype-ns">default element/type
namespace</termref>. The semantics of the <code>cast</code> expression
are as follows:</p>

<olist>

  

  <item>
              <p>
                <termref def="dt-atomization">Atomization</termref> is performed on the input
expression.</p>
            </item>

  

  <item>
              <p> If the result of atomization is a
sequence of more than one atomic value, a <termref def="dt-type-error">type error</termref> is raised <errorref class="TY" code="0004"/>.</p>
            </item>

  

  <item>
              <p>If the result
of atomization is an empty sequence:</p>

<olist>

  

  <item>
                  <p>If
<code>?</code> is specified after the target type, the result of the
<code>cast</code> expression is an empty sequence.</p>
                </item>

  

  <item>
                  <p>
If <code>?</code> is not specified after the target type, a <termref def="dt-type-error">type error</termref> is raised <errorref class="TY" code="0004"/>.</p>
                </item>
              </olist>
            </item>

  

  <item>
<p>If the result of atomization is a single atomic value, the result
of the cast expression depends on the input type and the target
type. In general, the cast expression attempts to create a new value
of the target type based on the input value. Only certain combinations
of input type and target type are supported. A summary of the rules
are listed below—the normative definition of these rules is
given in <bibref ref="xpath-functions-11"/>. For the purpose of
these rules, an implementation may determine
that one type is derived by restriction from another type either by examining the <termref def="dt-issd">in-scope schema definitions</termref> or by using an
alternative, <termref def="dt-implementation-dependent">implementation-dependent</termref> mechanism such as a data
dictionary.</p>



<olist>

  

  <item>
                  <p>
                    <code>cast</code> is supported for the combinations of
input type and target type listed in <xspecref spec="FO" ref="casting-from-primitive-to-primitive"/>. For each of these combinations, both
the input type and the target type are primitive <termref def="dt-schema-type">schema types</termref>. For
example, a value of type <code>xs:string</code> can be cast into the
schema type <code>xs:decimal</code>. For each of these built-in combinations,
the semantics of casting are specified in <bibref ref="xpath-functions-11"/>.</p>
                </item>

  

  <item>
                  <p>
                    <code>cast</code> is
supported if the input type is a non-primitive atomic type that is derived by restriction from the target
type. In this case, the input value
is mapped into the value space of the target type, unchanged except
for its type. For example, if <code>shoesize</code> is derived by
restriction from <code>xs:integer</code>, a value of type
<code>shoesize</code> can be cast into the schema type
<code>xs:integer</code>.</p>
                </item>

  

 <item diff="chg" at="XQ.E15 and XP.E8">

     <p>
                    <code>cast</code> is supported if the target type is a
     non-primitive atomic type and the input type is
     <code>xs:string</code> or <code>xs:untypedAtomic</code>. The
     input value is first converted to a value in the lexical space of
     the target type by applying the whitespace normalization rules
     for the target type (as defined in <bibref ref="XMLSchema"/>). The lexical value is then converted to the
     value space of the target type using the schema-defined rules for
     the target type. If the input value fails to satisfy some facet
     of the target type, a <termref def="dt-dynamic-error">dynamic
     error</termref> may be raised as specified in <bibref ref="xpath-functions-11"/>.</p>

   </item>

  

  <item>
                  <p>
                    <code>cast</code> is supported if
the target type is a non-primitive atomic type that is derived by restriction from the input type. The input value must satisfy all the
facets of the target type (in the case of the pattern facet, this is
checked by generating a string representation of the input value,
using the rules for casting to <code>xs:string</code>). The resulting
value is the same as the input value, but with a different <termref def="dt-dynamic-type">dynamic type</termref>.</p>
                </item>

  

  <item>
                  <p>If a primitive type P1 can be cast into a
primitive type P2, then any type derived by restriction from P1 can be cast into any type derived by restriction from P2, provided that the facets of the target type are
satisfied. First the input value is cast to P1 using rule (b)
above. Next, the value of type P1 is cast to the type P2, using rule
(a) above. Finally, the value of type P2 is cast to the target type,
using rule (d) above.</p>
                </item>

  

  <item>
                  <p> For any combination of input
type and target type that is not in the above list, a
<code>cast</code> expression raises a <termref def="dt-type-error">type error</termref> <errorref class="TY" code="0004"/>.</p>
                </item>
              </olist>

</item>
          </olist>
          <p> If casting from the input type to the target type is supported but nevertheless it is not possible to cast the input value into the value space of the target type, a <termref def="dt-dynamic-error">dynamic error</termref> is raised. [err:FORG0001] This includes the case when any facet of the target type is not satisfied. For example, the expression <code role="parse-test">"2003-02-31" cast as xs:date</code> would raise a <termref def="dt-dynamic-error">dynamic error</termref>.</p> 
</div3>
        <div3 id="id-castable">
          <head>Castable</head>
          <scrap headstyle="show"> 
<head/> 
    
<prod num="96" id="doc-xquery11-CastableExpr">
              <lhs>CastableExpr</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-CastExpr" xlink:type="simple">CastExpr</nt> ( "castable"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SingleType" xlink:type="simple">SingleType</nt> )?</rhs>
            </prod>
            <prod num="167" id="noid_N16359.doc-xquery11-SingleType">
              <lhs>SingleType</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AtomicType" xlink:type="simple">AtomicType</nt>  "?"?</rhs>
            </prod>
          </scrap>
          <p>XQuery 1.1
provides an expression that tests whether a given value
is castable into a given target type. The target
type must be an atomic type that is in the <termref def="dt-is-types">in-scope schema types</termref> <errorref class="ST" code="0051"/>. In addition, the target type cannot be <code>xs:NOTATION</code> or <code>xs:anyAtomicType</code> <errorref class="ST" code="0080"/>. The optional occurrence indicator "<code>?</code>" denotes that an empty
sequence is permitted. </p>

<p diff="chg" at="XQ.E5 and XP.E5">The expression <code role="parse-test">E castable
as T</code> returns <code>true</code> if the result of evaluating <code>E</code>  can
be successfully cast into the target type <code>T</code> by using a
<code>cast</code> expression; otherwise it returns
<code>false</code>. If evaluation of <code>E</code> fails with a dynamic error, the <code>castable</code> expression as a whole fails. The <code>castable</code> expression can be used as a <termref def="dt-predicate">predicate</termref>  to
avoid errors at evaluation time. It can also be used to select an
appropriate type for processing of a given value, as illustrated in
the following example:</p>

<eg role="parse-test" xml:space="preserve">
if ($x castable as hatsize) 
   then $x cast as hatsize 
   else if ($x castable as IQ) 
   then $x cast as IQ 
   else $x cast as xs:string</eg>
</div3>
        <div3 id="id-constructor-functions">
          <head>Constructor
Functions</head>
          <p>For every atomic type in the <termref def="dt-is-types">in-scope schema types</termref>  (except <code>xs:NOTATION</code> and <code>xs:anyAtomicType</code>, which are not instantiable), a <term>constructor function</term> is implicitly defined. In each case, the name of the constructor function is the same as the name of its target type (including namespace). The signature of the constructor function for type
<emph>T</emph> is as follows:</p>

<eg xml:space="preserve">T($arg as xs:anyAtomicType?) as T?</eg>

<p> <termdef term="constructor function" id="dt-constructor-function">The <term>constructor function</term> for a given type is used to convert instances of other atomic types into the given type. The semantics of the constructor function call <code>T($arg)</code> are defined to be equivalent to the expression <code role="parse-test">(($arg) cast as T?)</code>.</termdef>
          </p>
<p>The following examples illustrate the use of constructor functions:</p>
<ulist>

  

  <item>
              <p>This
example is equivalent to <code role="parse-test">("2000-01-01" cast as
xs:date?)</code>.</p>

<eg role="parse-test" xml:space="preserve">xs:date("2000-01-01")</eg>
            </item>

  

  <item>
              <p>This
example is equivalent to 

<code role="parse-test">(($floatvalue * 0.2E-5) cast as xs:decimal?)</code>.</p>
              <eg role="parse-test" xml:space="preserve">xs:decimal($floatvalue * 0.2E-5)</eg>
            </item>

  

  <item>
              <p>This example returns a
<code>xs:dayTimeDuration</code> value equal to 21 days. It is
equivalent to <code role="parse-test">("P21D" cast as xs:dayTimeDuration?)</code>.</p>
              <eg role="parse-test" xml:space="preserve">xs:dayTimeDuration("P21D")</eg>
            </item>

  

  <item>
              <p>If
<code>usa:zipcode</code> is a user-defined  atomic type
in the <termref def="dt-is-types">in-scope schema types</termref>, then the
following expression is equivalent to the
expression <code role="parse-test">("12345" cast as
usa:zipcode?)</code>.</p>
              <eg role="parse-test" xml:space="preserve">usa:zipcode("12345")</eg>
            </item>
          </ulist>

<note>
            <p>An instance of an atomic type that is not in a namespace can be constructed in either of the following ways:</p>
<ulist>

  

  <item>
                <p>By using a <code>cast</code> expression, if the <termref def="dt-def-elemtype-ns">default element/type
		  namespace</termref> is "none". <phrase role="xquery">(See <specref ref="id-default-namespace"/> for how to undeclare the <termref def="dt-def-elemtype-ns">default element/type
		  namespace</termref>).</phrase>
                </p>
                <eg role="parse-test" xml:space="preserve">17 cast as apple</eg>
              </item>

  

  <item>
                <p>By using a constructor function, if the <termref def="dt-def-fn-ns">default function
		namespace</termref> is "none". <phrase role="xquery">(See <specref ref="id-default-namespace"/> for how to undeclare the <termref def="dt-def-fn-ns">default function
		namespace</termref>).</phrase>
                </p>
                <eg role="parse-test" xml:space="preserve">apple(17)
</eg>
              </item>
            </ulist>
          </note>
        </div3>
        <div3 id="id-treat">
          <head>Treat</head>
          <scrap headstyle="show"> <head/> <prod num="95" id="doc-xquery11-TreatExpr">
              <lhs>TreatExpr</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-CastableExpr" xlink:type="simple">CastableExpr</nt> ( "treat"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SequenceType" xlink:type="simple">SequenceType</nt> )?</rhs>
            </prod> </scrap>
          <p>XQuery 1.1 provides an
expression called <code>treat</code> that can be used to modify the
<termref def="dt-static-type">static type</termref> of its
operand.</p>
          <p>Like <code>cast</code>, the <code>treat</code>
expression takes two operands: an expression and a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SequenceType" xlink:type="simple">SequenceType</nt>. Unlike
<code>cast</code>, however, <code>treat</code> does not change the
<termref def="dt-dynamic-type">dynamic type</termref> or value of its operand. Instead, the purpose of
<code>treat</code> is to ensure that an expression has an expected
dynamic type at evaluation time.</p>
          <p>The semantics of <emph>
              <code>expr1</code>
            </emph>
            <code> treat as </code>
            <emph>
              <code>type1</code>
            </emph> are as
follows:</p>
<ulist>

  

  <item>
              <p>During static analysis:</p>
              <p> The
<termref def="dt-static-type">static type</termref> of the
<code>treat</code> expression is <emph>
                  <code>type1</code>
                </emph>. This enables the
expression to be used as an argument of a function that requires a
parameter of <emph>
                  <code>type1</code>
                </emph>.</p>
            </item>

  

  <item>
              <p>During expression
evaluation:</p>
              <p>If <emph>
                  <code>expr1</code>
                </emph> matches <emph>
                  <code>type1</code>
                </emph>,
using the rules for <termref def="dt-sequencetype-matching">SequenceType
matching</termref>,
the <code>treat</code> expression returns the value of
<emph>
                  <code>expr1</code>
                </emph>; otherwise, it raises a <termref def="dt-dynamic-error">dynamic error</termref> <errorref class="DY" code="0050"/>.
If the value of <emph>
                  <code>expr1</code>
                </emph> is returned, its identity is
preserved. The <code>treat</code> expression ensures that the value of
its expression operand conforms to the expected type at
run-time.</p>
            </item>

  

  <item>
              <p>Example:</p>
              <eg role="parse-test" xml:space="preserve">$myaddress treat as element(*, USAddress)</eg>
              <p>The
<termref def="dt-static-type">static type</termref> of
<code>$myaddress</code> may be <code>element(*, Address)</code>, a
less specific type than <code>element(*, USAddress)</code>. However,
at run-time, the value of <code>$myaddress</code> must match the type
<code>element(*, USAddress)</code> using rules for <termref def="dt-sequencetype-matching">SequenceType
matching</termref>;
otherwise a <termref def="dt-dynamic-error">dynamic error</termref> is
raised <errorref class="DY" code="0050"/>.</p>
            </item>
          </ulist>
        </div3>
      </div2> 


<div2 id="id-validate" role="xquery">
    <head>Validate Expressions</head>
    
    <scrap headstyle="show">        
        <head/> 
        <prod num="103" id="doc-xquery11-ValidateExpr">
            <lhs>ValidateExpr</lhs>
            <rhs>"validate"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ValidationMode" xlink:type="simple">ValidationMode</nt>  |  ("type"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TypeName" xlink:type="simple">TypeName</nt>))?  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Expr" xlink:type="simple">Expr</nt>  "}"</rhs>
          </prod>
        <prod num="104" id="doc-xquery11-ValidationMode">
            <lhs>ValidationMode</lhs>
            <rhs>"lax"  |  "strict"</rhs>
          </prod>
    </scrap>
    
    <p>A <code>validate</code> expression can be used to validate a
        document node or an element node with respect to the <termref def="dt-issd">in-scope schema definitions</termref>, using the schema
        validation process defined in <bibref ref="XMLSchema"/>. If the
        operand of a <code>validate</code> expression does not evaluate to
        exactly one document or element node, a <termref def="dt-type-error">type error</termref> is raised <errorref class="TY" code="0030"/>. In this specification, the node that is the
        operand of a <code>validate</code> expression is called the
        <term>operand node</term>.</p>

    
    <p>A <code>validate</code> expression returns a new node with its own identity and with no parent. 
        The new node and its descendants are given <termref def="dt-type-annotation">type annotations</termref> 
        that are generated by applying a validation process to the operand node. In some cases, default values 
        may also be generated by the validation process.</p>
    
    <p>A <code>validate</code> expression may optionally specify a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ValidationMode" xlink:type="simple">validation mode</nt>. The default 
        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ValidationMode" xlink:type="simple">validation mode</nt> 
        <phrase diff="add">(applicable when no type name is provided)</phrase>

        is <code>strict</code>.</p>
    
    <p>A <code>validate</code> expression may optionally specify a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TypeName" xlink:type="simple">TypeName</nt>. This type name must be found in the <termref def="dt-issd">in-scope
            schema definitions</termref>; if it is not, a <termref def="dt-static-error">static error</termref> is raised <errorref class="ST" code="0104"/>.  If the type name is unprefixed, it is
        interpreted as a name in the default namespace for elements and
        types.
        
    </p>

    
    <p>The result of a <code>validate</code> expression is defined by the following rules.</p>
    
    <olist>
        
        
        <item>
            <p> If the operand node is a document node, its children must
            consist of exactly one element node and zero or more comment and
            processing instruction nodes, in any order; otherwise, a <termref def="dt-dynamic-error">dynamic error</termref> <errorref class="DY" code="0061"/> is raised.</p>
          </item>
        
        
        
        <item>
            <p>The operand node is converted to an XML Information Set
            (<bibref ref="XINFO"/>) according to the "Infoset Mapping" rules
            defined in <bibref ref="xpath-datamodel-11"/>. Note that this process
            discards any existing <termref def="dt-type-annotation">type
            annotations</termref>. 
            <phrase diff="chg">Validity assessment is carried out on the root element
                    information item of the resulting Infoset, using the <termref def="dt-issd">in-scope schema definitions</termref> as the effective
                    schema.  The process of validation applies recursively to contained
                    elements and attributes to the extent required by the effective
                    schema. </phrase>
            </p>
          </item>

        
        <item>
            <p> If a type name is provided, schema-validity assessment is
            carried out according to the rules defined in <bibref ref="XMLSchema"/>, section 3.3.4 "Element
            Declaration Validation Rules", clauses 1.2 and 2, using this type definition as the 
            <quote>processor-stipulated type definition</quote> for validation.</p>
          </item>
        
        
        
        <item>
            <p>
              <phrase diff="chg">When no type name is provided:</phrase>
            </p>
            
            <olist>
                               
                <item>
                <p>If <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ValidationMode" xlink:type="simple">validation mode</nt> is <code>strict</code>, then there must be a
                    top-level element declaration in the <termref def="dt-is-elems">in-scope element declarations</termref> 
                    that matches the root element information
                    item in the Infoset, and schema-validity assessment is
                    carried out using that declaration in accordance with item
                    2 of <bibref ref="XMLSchema"/> Part 1, section 5.2, "Assessing Schema-Validity."
                    
                    If there is no such element declaration, a <termref def="dt-dynamic-error">dynamic error</termref> is
                    raised <errorref code="0084" class="DY"/>.</p>
              </item>

                
                
                
                <item>
                <p>If <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ValidationMode" xlink:type="simple">validation mode</nt> is <code>lax</code>, then schema-validity 
                    assessment is carried out in accordance with item
                    3 of <bibref ref="XMLSchema"/> Part 1, section 5.2, "Assessing Schema-Validity."</p>
                    
                    <p>If <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ValidationMode" xlink:type="simple">validation mode</nt> is <code>lax</code> and the root element
                        information item has neither a top-level element
                        declaration nor an <code>xsi:type</code> attribute, <bibref ref="XMLSchema"/> defines the recursive checking of children
                        and attributes as optional. During processing of an XQuery <code>validate</code> expression, this
                        recursive checking is required.</p>
              </item>
                
            <item>
                <p diff="chg" at="XQ.E7">If the operand node is an element node, the validation rules named  
                "Validation Root Valid (ID/IDREF)" is not applied. This means that document-level constraints 
                relating to uniqueness and referential integrity are not enforced.</p>
              </item>  
            
            <item>
                <p>There is no check that the document contains unparsed entities whose names match the 
                values of nodes of type <code>xs:ENTITY</code> or <code>xs:ENTITIES</code>.</p>
              </item>
            
             
            <item>
                <p>There is no check that the document contains notations whose names match the values 
                of nodes of type <code>xs:NOTATION</code>.</p>
              </item>

            </olist>
            
            
            <note>
              <p>Validity assessment is affected by the presence or absence of <code>xsi:type</code> attributes
            on the elements being validated, and may generate new information items such as default attributes.</p>
            </note>
        </item>
        
        
        
        <item>
            <p>
              <phrase diff="chg">The outcome of the validation expression depends on the </phrase> 
            <code>validity</code> property of the root element information item in the PSVI that results 
            from the validation process.</p>

            
            <olist>
                
                
                <item>
                <p>If the <code>validity</code> property of the root element
                    information item is <code>valid</code>,
                    
                    or if <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ValidationMode" xlink:type="simple">validation mode</nt> is
                    <code>lax</code> and the <code>validity</code> property of the root
                    element information item is <code>notKnown</code>,
                    
                    the PSVI is converted back into an <termref def="dt-data-model-instance">XDM instance</termref>

                    
                    as described in <bibref ref="xpath-datamodel-11"/> Section
                    3.3, "Construction from a PSVI". 
                    
                    The resulting node (a new node of the same kind as the operand node)
                    is returned as the result of the <code>validate</code>
                    expression.</p>
              </item>
                
                
                
                <item>
                <p>Otherwise, a <termref def="dt-dynamic-error">dynamic
                error</termref> is raised  <errorref class="DY" code="0027"/>.</p>
              </item>
            </olist>

        </item>
    </olist>
    
    <note>
        <p>The effect of these rules is as follows, where <phrase diff="chg">the <emph>validated element</emph> means 
            either the operand node or (if the operand node is a document node) its element child.</phrase>:
        <ulist>
            <item>
                <p>If <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ValidationMode" xlink:type="simple">validation mode</nt> is <code>strict</code>, 
            the validated element must have a top-level element declaration in the effective schema, and must conform to this 
            declaration.</p>
              </item>

            
            <item>
                <p>If <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ValidationMode" xlink:type="simple">validation mode</nt> is <code>lax</code>, the validated element must conform 
            to its top-level element declaration if such a declaration exists in the effective schema. If 
            <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ValidationMode" xlink:type="simple">validation mode</nt>
                        is <code>lax</code> and there is no top-level element declaration for the
                        element, and the element has an <code>xsi:type</code> attribute, then the
                        <code>xsi:type</code> attribute must name a top-level type definition in the
                        effective schema, and the element must conform to that type.</p>
              </item> 
                        
            <item>
                <p>
                  <phrase diff="add">If a type name is specified in the validate expression, no attempt is
                made to locate an element declaration matching the name of the validated
                element; the element can have any name, and its content is validated against
                the named type.</phrase>
                </p>
              </item>

                        
        </ulist>
        </p>
        </note>
    
    <note>
          <p>During conversion of the PSVI into an <termref def="dt-data-model-instance">XDM instance</termref> 
        after validation, any element information items whose validity property is <code>notKnown</code> are 
        converted into element nodes with <termref def="dt-type-annotation">type annotation</termref> 
        <code>xs:anyType</code>, and any attribute information items whose validity property is 
        <code>notKnown</code> are converted into attribute nodes with <termref def="dt-type-annotation">type annotation</termref> 
        <code>xs:untypedAtomic</code>, as described in <xspecref spec="DM" ref="PSVI2NodeTypes"/>.
    </p>
        </note>

</div2>



<!--
<div2 id="id-validate" role="xquery">
    <head>Validate Expressions</head>
    
    <scrap>        
        <head></head> 
        <prodrecap id="ValidateExpr" ref="ValidateExpr"/>
        <prodrecap id="ValidationMode" ref="ValidationMode"/>
    </scrap>
    
    <p>A <code>validate</code> expression can be used to validate a
        document node or an element node with respect to the <termref
            def="dt-issd">in-scope schema definitions</termref>, using the schema
        validation process defined in <bibref ref="XMLSchema"/>. If the
        operand of a <code>validate</code> expression does not evaluate to
        exactly one document or element node, a <termref
            def="dt-type-error">type error</termref> is raised <errorref
                class="TY" code="0030"/>. In this specification, the node that is the
        operand of a <code>validate</code> expression is called the
        <term>operand node</term>.</p>

    
    <p>A <code>validate</code> expression returns a new node with its own identity and with no parent. 
        The new node and its descendants are given <termref def="dt-type-annotation">type annotations</termref> 
        that are generated by applying a validation process to the operand node. In some cases, default values 
        may also be generated by the validation process.</p>
    
    <p>A <code>validate</code> expression may optionally specify a <nt
        def="ValidationMode">validation mode</nt>. The default 
        <nt def="ValidationMode">validation mode</nt> 
        <phrase diff="add">(applicable when no type name is provided)</phrase>

        is <code>strict</code>.</p>
    
    <p>A <code>validate</code> expression may optionally specify a <nt
        def="TypeName">TypeName</nt>. This type name must be found in the <termref def="dt-issd">in-scope
            schema definitions</termref>; if it is not, a <termref
                def="dt-static-error">static error</termref> is raised <errorref
                    class="ST" code="0104"/>.  If the type name is unprefixed, it is
        interpreted as a name in the default namespace for elements and
        types.
        
    </p>

    
    <p>The result of a <code>validate</code> expression is defined by the following rules.</p>
    
    <olist>
        
        
        <item><p> If the operand node is a document node, its children must
            consist of exactly one element node and zero or more comment and
            processing instruction nodes, in any order; otherwise, a <termref
                def="dt-dynamic-error">dynamic error</termref> <errorref class="DY"
                    code="0061"/> is raised.</p></item>
        
        
        
        <item><p>The operand node is converted to an XML Information Set
            (<bibref ref="XINFO"/>) according to the "Infoset Mapping" rules
            defined in <bibref ref="xpath-datamodel-11"/>. Note that this process
            discards any existing <termref def="dt-type-annotation">type
            annotations</termref>. 
            <phrase diff="add">Validity assessment is carried out on the root element
                    information item of the resulting Infoset, using the <termref
                        def="dt-issd">in-scope schema definitions</termref> as the effective
                    schema.  The process of validation applies recursively to contained
                    elements and attributes to the extent required by the effective
                    schema. </phrase></p></item>

        
        <item><p> If a type name is provided, schema-validity assessment is
            carried out according to the rules defined in <bibref ref="XMLSchema"/>, section 3.3.4 "Element
            Declaration Validation Rules", clauses 1.2 and 2, using this type definition as the 
            <quote>processor-stipulated type definition</quote> for validation.</p></item>
        
        
        
        <item><p><phrase diff="chg">When no type name is provided:</phrase></p>
            
            <olist>
                               
                <item><p>If <nt def="ValidationMode">validation mode</nt> is <code>strict</code>, then there must be a
                    top-level element declaration in the <termref def="dt-is-elems">in-scope element declarations</termref> 
                    that matches the root element information
                    item in the Infoset, and schema-validity assessment is
                    carried out using that declaration in accordance with item
                    2 of <bibref ref="XMLSchema"/> Part 1, section 5.2, "Assessing Schema-Validity."
                    
                    If there is no such element declaration, a <termref def="dt-dynamic-error">dynamic error</termref> is
                    raised <errorref code="0084" class="DY"/>.</p></item>

                
                
                
                <item><p>If <nt def="ValidationMode">validation mode</nt> is <code>lax</code>, then schema-validity 
                    assessment is carried out in accordance with item
                    3 of <bibref ref="XMLSchema"/> Part 1, section 5.2, "Assessing Schema-Validity."</p>
                    
                    <p>If <nt def="ValidationMode">validation mode</nt> is <code>lax</code> and the root element
                        information item has neither a top-level element
                        declaration nor an <code>xsi:type</code> attribute, <bibref ref="XMLSchema"/> defines the recursive checking of children
                        and attributes as optional. During processing of an XQuery <code>validate</code> expression, this
                        recursive checking is required.</p></item>

                
                
            <item><p diff="chg" at="XQ.E7">If the operand node is an element node, the validation rules named  
                "Validation Root Valid (ID/IDREF)" is not applied. This means that document-level constraints 
                relating to uniqueness and referential integrity are not enforced.</p></item>  
            
            <item><p>There is no check that the document contains unparsed entities whose names match the 
                values of nodes of type <code>xs:ENTITY</code> or <code>xs:ENTITIES</code>.</p></item>
            
             
            <item><p>There is no check that the document contains notations whose names match the values 
                of nodes of type <code>xs:NOTATION</code>.</p></item>

            </olist>

            <note><p>Validity assessment is affected by the presence or absence of <code>xsi:type</code> attributes
            on the elements being validated, and may generate new information items such as default attributes.</p>
            </note>

           
        </item>
        
        
        
        <item><p><phrase diff="chg">The outcome of the validation expression depends on the </phrase> 
            <code>validity</code> property of the root element information item in the PSVI that results 
            from the validation process.</p>

            
            <olist>
                
                
                <item><p>If the <code>validity</code> property of the root element
                    information item is <code>valid</code>,
                    
                    or if <nt def="ValidationMode">validation mode</nt> is
                    <code>lax</code> and the <code>validity</code> property of the root
                    element information item is <code>notKnown</code>,
                    
                    the PSVI is converted back into an <termref
                        def="dt-data-model-instance">XDM instance</termref>

                    
                    as described in <bibref ref="xpath-datamodel-11"/> Section
                    3.3, "Construction from a PSVI". 
                    
                    The resulting node (a new node of the same kind as the operand node)
                    is returned as the result of the <code>validate</code>
                    expression.</p></item>
                
                
                
                <item><p>Otherwise, a <termref def="dt-dynamic-error">dynamic
                error</termref> is raised  <errorref class="DY" code="0027"/>.</p></item>
            </olist>

        </item>
    </olist>
    
    <note>
        <p>The effect of these rules is as follows, where <phrase diff="add">the <emph>validated element</emph> means 
            either the operand node or (if the operand node is a document node) its element child.</phrase>:
        <ulist>
            <item><p>If <nt def="ValidationMode">validation mode</nt> is <code>strict</code>, 
            the validated element must have a top-level element declaration in the effective schema, and must conform to this 
            declaration.</p></item>

            
            <item><p>If <nt def="ValidationMode">validation mode</nt> is <code>lax</code>, the validated element must conform 
            to its top-level element declaration if such a declaration exists in the effective schema. If 
            <nt def="ValidationMode">validation mode</nt>
                        is <code>lax</code> and there is no top-level element declaration for the
                        element, and the element has an <code>xsi:type</code> attribute, then the
                        <code>xsi:type</code> attribute must name a top-level type definition in the
                        effective schema, and the element must conform to that type.</p></item> 
                        
            <item><p><phrase diff="add">If a type name is specified in the validate expression, no attempt is
                made to locate an element declaration matching the name of the validated
                element; the element can have any name, and its content is validated against
                the named type.</phrase></p></item>

                        
        </ulist>
        </p></note>
    
    <note><p>During conversion of the PSVI into an <termref def="dt-data-model-instance">XDM instance</termref> 
        after validation, any element information items whose validity property is <code>notKnown</code> are 
        converted into element nodes with <termref def="dt-type-annotation">type annotation</termref> 
        <code>xs:anyType</code>, and any attribute information items whose validity property is 
        <code>notKnown</code> are converted into attribute nodes with <termref def="dt-type-annotation">type annotation</termref> 
        <code>xs:untypedAtomic</code>, as described in <xspecref spec="DM" ref="PSVI2NodeTypes"></xspecref>.
    </p></note>

</div2>
-->

<div2 id="id-extension-expressions" role="xquery">
        <head>Extension Expressions</head>
        <p>
          <termdef id="dt-extension-expression" term="extension expression">An <term>extension expression</term> is an expression whose semantics are
<termref def="dt-implementation-defined">implementation-defined</termref>.</termdef> Typically a particular extension will be recognized
by some implementations and not by others. The syntax is designed so that
extension expressions can be successfully parsed by all implementations, and
so that fallback behavior can be defined for implementations that do not
recognize a particular extension.</p>
        <scrap headstyle="show">

<head/> <prod num="105" id="doc-xquery11-ExtensionExpr">
            <lhs>ExtensionExpr</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Pragma" xlink:type="simple">Pragma</nt>+  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Expr" xlink:type="simple">Expr</nt>?  "}"</rhs>
          </prod>
<prod num="106" id="doc-xquery11-Pragma">
            <lhs>Pragma</lhs>
            <rhs>"(#"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-S" xlink:type="simple">S</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-EQName" xlink:type="simple">EQName</nt>  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-S" xlink:type="simple">S</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-PragmaContents" xlink:type="simple">PragmaContents</nt>)?  "#)"</rhs>
          </prod>
          <prod num="107" id="doc-xquery11-PragmaContents">
            <lhs>PragmaContents</lhs>
            <rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Char" xlink:type="simple">Char</nt>* - (Char* '#)' Char*))</rhs>
          </prod>
        </scrap>
        <p>An extension expression consists of one or more <term>pragmas</term>, followed by an expression enclosed in curly braces. <termdef term="pragma" id="dt-pragma">A <term>pragma</term> is denoted by the delimiters <code>(#</code> and <code>#)</code>, and consists of an identifying EQName followed by <termref def="dt-implementation-defined">implementation-defined</termref> content.</termdef> The content of a pragma may consist of any string of characters that does not contain the ending delimiter <code>#)</code>.  If the EQName of a 
pragma is a  <termref def="dt-qname">lexical QName</termref>, it must resolve to a namespace URI and local name, using the <termref def="dt-static-namespaces">statically known namespaces</termref> <errorref class="ST" code="0081"/>.</p>
        <note>
          <p>Since there is no default namespace for
pragmas, a pragma's EQName must provide a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-URILiteral" xlink:type="simple">URILiteral</nt> or a namespace prefix.</p>
        </note>
        <p>Each implementation recognizes an <termref def="dt-implementation-defined">implementation-defined</termref> set of namespace
URIs used to denote pragmas.</p>
        <p>If the namespace URI of a pragma's  <termref def="dt-expanded-qname">expanded QName</termref> is not recognized by the
implementation as a pragma namespace, then the pragma
is ignored. If all the pragmas in an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExtensionExpr" xlink:type="simple">ExtensionExpr</nt> are ignored, then the
value of the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExtensionExpr" xlink:type="simple">ExtensionExpr</nt> is the value of the expression enclosed in curly braces; if this expression is absent, then a <termref def="dt-static-error">static error</termref> is
raised <errorref class="ST" code="0079"/>.</p>
        <p>If an implementation recognizes the namespace of one or more pragmas in an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExtensionExpr" xlink:type="simple">ExtensionExpr</nt>, then the value
of the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExtensionExpr" xlink:type="simple">ExtensionExpr</nt>, including its error behavior, is <termref def="dt-implementation-defined">implementation-defined</termref>. For example, an implementation that recognizes the namespace of
a pragma's  <termref def="dt-expanded-qname">expanded QName</termref>, but does not recognize the local part of the name, might choose
either to raise an error or to ignore the pragma.</p>
        <p>It is a  <termref def="dt-static-error">static error</termref> <errorref code="0013" class="ST"/> 
if an implementation recognizes a pragma but
determines that its content is  invalid.</p>
        <p>If an implementation recognizes a pragma, it must report any static
errors in the following expression even if it will not evaluate that
expression (however, static type errors are raised only if the <termref def="dt-static-typing-feature">Static Typing Feature</termref> is in effect.)</p>
        <note>
          <p>The following examples illustrate three ways in which extension expressions might be
used.</p>
<ulist>

  

  <item>
              <p>A pragma can be used to furnish a hint for how to evaluate the
following expression, without actually changing the result.
For example:</p>
              <eg role="parse-test" xml:space="preserve">declare namespace exq = "http://example.org/XQueryImplementation";
   (# exq:use-index #)
      { $bib/book/author[name='Berners-Lee'] }
</eg>
              <p>An implementation that recognizes the <code>exq:use-index</code> pragma might use an
index to evaluate the  expression that follows. An implementation that
does not recognize this pragma would evaluate the expression in its normal
way.</p>
            </item>

  

  <item>
              <p>A pragma might be used to modify the semantics of the following
expression in ways that would not (in the absence of the pragma) be
conformant with this specification. For example, a pragma might be used to
permit comparison of <code>xs:duration</code> values using implementation-defined
semantics (this would normally be an error). Such changes to the language
semantics must be scoped to the expression contained within the curly
braces following the pragma.</p>
            </item>

  

  <item>
              <p>A pragma might contain syntactic constructs that are
evaluated in place of the following expression. In this case, the
following expression itself (if it is present) provides a fallback for use by
implementations that do not recognize the pragma. For example:</p>
              <eg role="parse-test" xml:space="preserve">declare namespace exq = "http://example.org/XQueryImplementation";
   for $x in
      (# exq:distinct //city by @country #)
      { //city[not(@country = preceding::city/@country)] }
   return f:show-city($x)
</eg>
              <p>Here an implementation that recognizes the pragma will return the result of
evaluating the proprietary syntax <code>exq:distinct //city by
@country</code>,
while an implementation that does not recognize the pragma will instead
return the result of the expression <code role="parse-test">//city[not(@country =
preceding::city/@country)]</code>. If no fallback expression is required, or
if none is feasible, then the expression between the curly braces may be
omitted, in which case implementations that do not recognize the pragma will
raise a <termref def="dt-static-error">static error</termref>.</p>
            </item>
          </ulist>
        </note>
      </div2>
    </div1>


<div1 role="xquery" id="id-query-prolog">	
  <head role="xquery">Modules and Prologs</head>	
  <scrap headstyle="show"> 
	 <head/> <prod num="1" id="doc-xquery11-Module">
          <lhs>Module</lhs>
          <rhs>
            <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-VersionDecl" xlink:type="simple">VersionDecl</nt>?  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-LibraryModule" xlink:type="simple">LibraryModule</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-MainModule" xlink:type="simple">MainModule</nt>)</rhs>
        </prod> 

	 <prod num="3" id="doc-xquery11-MainModule">
          <lhs>MainModule</lhs>
          <rhs>
            <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Prolog" xlink:type="simple">Prolog</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-QueryBody" xlink:type="simple">QueryBody</nt>
          </rhs>
        </prod>
        <prod num="4" id="doc-xquery11-LibraryModule">
          <lhs>LibraryModule</lhs>
          <rhs>
            <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ModuleDecl" xlink:type="simple">ModuleDecl</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Prolog" xlink:type="simple">Prolog</nt>
          </rhs>
        </prod>
        <prod num="6" id="doc-xquery11-Prolog">
          <lhs>Prolog</lhs>
          <rhs>((<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-DefaultNamespaceDecl" xlink:type="simple">DefaultNamespaceDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Setter" xlink:type="simple">Setter</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-NamespaceDecl" xlink:type="simple">NamespaceDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Import" xlink:type="simple">Import</nt>)  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Separator" xlink:type="simple">Separator</nt>)*  ((<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ContextItemDecl" xlink:type="simple">ContextItemDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AnnotatedDecl" xlink:type="simple">AnnotatedDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-OptionDecl" xlink:type="simple">OptionDecl</nt>)  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Separator" xlink:type="simple">Separator</nt>)*</rhs>
        </prod>	
  <prod num="8" id="doc-xquery11-Setter">
          <lhs>Setter</lhs>
          <rhs>
            <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-BoundarySpaceDecl" xlink:type="simple">BoundarySpaceDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-DefaultCollationDecl" xlink:type="simple">DefaultCollationDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-BaseURIDecl" xlink:type="simple">BaseURIDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ConstructionDecl" xlink:type="simple">ConstructionDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-OrderingModeDecl" xlink:type="simple">OrderingModeDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-EmptyOrderDecl" xlink:type="simple">EmptyOrderDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-CopyNamespacesDecl" xlink:type="simple">CopyNamespacesDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-DecimalFormatDecl" xlink:type="simple">DecimalFormatDecl</nt>
          </rhs>
        </prod>
        <prod num="20" id="doc-xquery11-Import">
          <lhs>Import</lhs>
          <rhs>
            <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SchemaImport" xlink:type="simple">SchemaImport</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ModuleImport" xlink:type="simple">ModuleImport</nt>
          </rhs>
        </prod>
        <prod num="7" id="doc-xquery11-Separator">
          <lhs>Separator</lhs>
          <rhs>";"</rhs>
        </prod>
        <prod num="38" id="doc-xquery11-QueryBody">
          <lhs>QueryBody</lhs>
          <rhs>
            <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Expr" xlink:type="simple">Expr</nt>
          </rhs>
        </prod>
      </scrap>
      <p>A query can be assembled from one or more fragments called <term>modules</term>. <termdef term="module" id="dt-module">A <term>module</term> is a fragment of XQuery code that conforms to the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Module" xlink:type="simple">Module</nt> grammar and can independently undergo the <termref def="dt-static-analysis">static analysis phase</termref> described in <specref ref="id-expression-processing"/>. Each module is either a <termref def="dt-main-module">main module</termref> or a <termref def="dt-library-module">library module</termref>.</termdef>
      </p>
      <p> <termdef id="dt-main-module" term="main module">A <term>main module</term> consists of a
<termref def="dt-prolog">Prolog</termref> followed by a <termref def="dt-queryBody">Query Body</termref>.</termdef> A query has exactly one
main module. In a main module, the <termref def="dt-queryBody">Query Body</termref> can be evaluated, and
its value is the result of the query. </p>
      <p>
        <termdef id="dt-library-module" term="library module">A module that does not contain a <termref def="dt-queryBody">Query Body</termref> is called a <term>library module</term>. A library module consists of a <termref def="dt-module-declaration">module declaration</termref> followed by  a <termref def="dt-prolog">Prolog</termref>.</termdef> A library module cannot be evaluated directly; instead, it provides function and variable declarations that can be imported into other modules.</p>
      <p>The XQuery syntax does not allow a <termref def="dt-module">module</termref> to contain both a <termref def="dt-module-declaration">module declaration</termref> and a <termref def="dt-queryBody">Query Body</termref>.</p>
      <p>
        <termdef id="dt-prolog" term="Prolog">A <term>Prolog</term> is a series of declarations and imports that define the processing environment for the <termref def="dt-module">module</termref> that contains the Prolog.</termdef> Each declaration or import is followed by a semicolon. A Prolog is organized into two parts. </p>
      <p>The first part of the Prolog consists of setters, imports, namespace declarations, and default namespace declarations. <termdef term="setter" id="dt-setter">
          <term>Setters</term> are declarations that set the value of some property that affects query processing, such as construction mode, ordering mode, or default collation.</termdef> Namespace declarations and default namespace declarations affect the interpretation of  <termref def="dt-qname">lexical QNames</termref> within the query.  Imports are used to  import definitions from schemas and modules. <termdef term="target namespace" id="dt-target-namespace">Each imported schema or module is identified by its <term>target namespace</term>, which is the namespace of the objects (such as elements or functions) that are defined by the schema or module.</termdef>
      </p>
      <p>The second part of the Prolog consists of declarations of variables, functions, and options. These declarations appear at the end of the Prolog because they may be affected by declarations and imports in the first part of the Prolog.</p>
      <p>
        <termdef id="dt-queryBody" term="query body">The <term>Query Body</term>, if present, consists of an expression that defines the result of the query.</termdef> Evaluation of expressions is described in <specref ref="id-expressions"/>. A module can be evaluated only if it has a Query Body.</p>	
   
   
  <div2 id="id-version-declaration">
        <head>Version Declaration</head>
        <scrap headstyle="show"> 
		<head/> <prod num="2" id="doc-xquery11-VersionDecl">
            <lhs>VersionDecl</lhs>
            <rhs>"xquery"  (("encoding"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-StringLiteral" xlink:type="simple">StringLiteral</nt>)  |  ("version"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-StringLiteral" xlink:type="simple">StringLiteral</nt>  ("encoding"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-StringLiteral" xlink:type="simple">StringLiteral</nt>)?))  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Separator" xlink:type="simple">Separator</nt>
            </rhs>
          </prod> 
		 
		 
	 </scrap>

<p>
          <termdef term="version declaration" id="dt-version-declaration"> A
<term>version declaration</term> can identify the applicable XQuery
syntax and semantics for a <termref def="dt-module">module</termref>,
as well as its encoding.</termdef> The version number "1.0" indicates
a requirement that the module must be processed by an <termref def="dt-xquery-10-processor">XQuery 1.0 processor</termref>; the
version number "1.1" indicates a requirement that the module must be
processed by an <termref def="dt-xquery-11-processor">XQuery 1.1
processor</termref>. If the version declaration is not present or the
version is not included in the declaration, an XQuery 1.1 processor
assumes a version of "1.1". If an XQuery 1.1 processor processes a
module labeled with a version of "1.0", it must either raise a static
error <errorref code="0031" class="ST"/>, or attempt to process the
module with an XQuery 1.0 processor. <phrase diff="add"> If any
version number other than 1.1 or 1.0 is encountered, a static error
<errorref code="0031" class="ST"/> is raised.</phrase>
        </p>

<!-- DIFF DEL
It is the intent of the XQuery
working group to give later versions of this specification numbers
other than "1.0" and "1.1", but this intent does not indicate a
commitment to produce any future versions of XQuery, nor if any are
produced, to use any particular numbering scheme.</p> -->


<p>
          <termdef term="encoding declaration" id="dt-encoding-declaration">If present, a version declaration may optionally include an <term>encoding declaration</term>. The value of the string literal following the keyword <code>encoding</code> is an encoding
name, and must conform to the definition of <code>EncName</code> specified in <bibref ref="XML"/>
            <errorref code="0087" class="ST"/>. The purpose of an encoding declaration is to allow the writer of a query to provide a string that indicates how the query is encoded, such as "<code>UTF-8</code>", "<code>UTF-16</code>", or "<code>US-ASCII</code>".</termdef> Since the encoding of a query may change as the query moves from one environment to another, there can be no guarantee that the encoding declaration is correct.</p>
        <p>The handling of an encoding declaration is <termref def="dt-implementation-dependent">implementation-dependent</termref>. If an implementation has <emph>a priori</emph> knowledge of the encoding of a query, it may use this knowledge  and disregard the encoding declaration. The semantics of a query are not affected by the presence or absence of an encoding declaration.</p>
        <p>If a version declaration is present, no <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Comment" xlink:type="simple">Comment</nt> may occur before the end of the version declaration. If such a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Comment" xlink:type="simple">Comment</nt> is present, the result is <termref def="dt-implementation-dependent">implementation-dependent</termref>.<note>
            <p>The effect of a Comment before the end of a version declaration is implementation-dependent because it may suppress query processing by interfering with detection of the encoding declaration.</p>
          </note>
        </p>
        <p>The following examples illustrate version declarations:</p>
        <eg role="frag-prolog-parse-test" xml:space="preserve">xquery version "1.0";</eg>
        <eg role="frag-prolog-parse-test" xml:space="preserve">xquery version "1.0" encoding "utf-8";</eg>
      </div2>

<div2 id="id-module-declaration">
  <head>Module Declaration</head>
  <scrap headstyle="show">
    <head>
    </head>
    <prod num="5" id="doc-xquery11-ModuleDecl">
            <lhs>ModuleDecl</lhs>
            <rhs>"module"  "namespace"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-NCName" xlink:type="simple">NCName</nt>  "="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-URILiteral" xlink:type="simple">URILiteral</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Separator" xlink:type="simple">Separator</nt>
            </rhs>
          </prod>
  </scrap>
  <p>
    <termdef id="dt-module-declaration" term="module declaration">A
    <term>module declaration</term> serves to identify a <termref def="dt-module">module</termref> as a <termref def="dt-library-module">library module</termref>. A module
    declaration begins with the keyword <code>module</code> and
    contains a namespace prefix and a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-URILiteral" xlink:type="simple">URILiteral</nt>.</termdef> The URILiteral must be
    of nonzero length <errorref class="ST" code="0088"/>. The
    URILiteral identifies the <termref def="dt-target-namespace">target namespace</termref> of the
    library module, which is the namespace for all variables and
    functions exported by the library module. The name of every
    variable and function declared in a library module must have a
    namespace URI that is the same as the target namespace of the
    module; otherwise a <termref def="dt-static-error">static
    error</termref> is raised <errorref class="ST" code="0048"/>. In
    the <termref def="dt-static-namespaces">statically known
    namespaces</termref> of the library module, the namespace prefix
    specified in the module declaration is bound to the module's
    target namespace.</p>
  <p>The namespace prefix specified in a module declaration must not
  be <code>xml</code> or <code>xmlns</code> <errorref class="ST" code="0070"/>, and must not be the same as any namespace prefix
  bound in the same module by a <termref def="dt-schema-import">schema
  import</termref>, by a <termref def="dt-namespace-declaration">namespace declaration</termref>, or
  by a <termref def="dt-module-import">module import</termref> with a
  different target namespace <errorref class="ST" code="0033"/>.</p>
  <p>Any <termref def="dt-module">module</termref> may import one or
  more library modules by means of a <termref def="dt-module-import">module import</termref> that specifies the
  target namespace of the library modules to be imported. When a
  module imports one or more library modules, the variables and
  functions declared in the imported modules are added to the <termref def="dt-static-context">static context</termref> and (where
  applicable) to the <termref def="dt-dynamic-context">dynamic
  context</termref> of the importing module.</p>
  <p>The following is an example of a module declaration:</p>
  <eg role="frag-prolog-parse-test" xml:space="preserve">module namespace math = "http://example.org/math-functions";</eg>
</div2>

<div2 id="id-boundary-space-decls">
  <head>Boundary-space Declaration</head>
  <scrap headstyle="show"> 
    <head>
    </head>      
    <prod num="9" id="doc-xquery11-BoundarySpaceDecl">
            <lhs>BoundarySpaceDecl</lhs>
            <rhs>"declare"  "boundary-space"  ("preserve"  |  "strip")</rhs>
          </prod> 
  </scrap>
  <p>
  <termdef id="dt-boundary-space-decl" term="boundary-space declaration">A <term>boundary-space declaration</term> sets the <termref def="dt-boundary-space-policy">boundary-space policy</termref> in the <termref def="dt-static-context">static context</termref>, overriding any implementation-defined default. Boundary-space policy controls whether <termref def="dt-boundary-whitespace">boundary whitespace</termref> is preserved by element constructors during processing of the query.</termdef> If boundary-space policy is <code>preserve</code>, boundary whitespace is preserved. If boundary-space policy is <code>strip</code>, boundary whitespace is stripped (deleted). A further discussion of whitespace in constructed elements can be found in <specref ref="id-whitespace"/>.</p>
  <p>The following example illustrates a boundary-space declaration:</p>
  <eg role="frag-prolog-parse-test" xml:space="preserve">declare boundary-space preserve;</eg>
  <p>If a Prolog contains more than one boundary-space declaration, a <termref def="dt-static-error">static error</termref> is raised <errorref class="ST" code="0068"/>.</p>
</div2>
<div2 id="id-default-collation-declaration">
  <head>Default Collation Declaration</head>
  <scrap headstyle="show"> 
    <head>
    </head>  
    
    <prod num="10" id="doc-xquery11-DefaultCollationDecl">
            <lhs>DefaultCollationDecl</lhs>
            <rhs>"declare"  "default"  "collation"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-URILiteral" xlink:type="simple">URILiteral</nt>
            </rhs>
          </prod> 
  </scrap>
  <p>
    <termdef term="default collation declaration" id="dt-default-collation-decl">A <term>default collation
    declaration</term> sets the value of the <termref def="dt-def-collation">default collation</termref> in the <termref def="dt-static-context">static context</termref>, overriding any
    implementation-defined default.</termdef> The default collation is
    the collation that is used by functions and operators that require
    a collation if no other collation is specified. For example, the
    <code>gt</code> operator on strings is defined by a call to the
    <code>fn:compare</code> function, which takes an optional
    collation parameter. Since the <code>gt</code> operator does not
    specify a collation, the <code>fn:compare</code> function
    implements <code>gt</code> by using the default collation.</p>
  <p>If neither the implementation nor the Prolog
  specifies a default collation, the Unicode codepoint collation
  (<code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code>)
  is used. </p>
  <p>The following example illustrates a default collation
  declaration:</p>
  <eg role="frag-prolog-parse-test" xml:space="preserve">declare default collation
  "http://example.org/languages/Icelandic";</eg>
  <p>If a default collation declaration specifies a collation by a
  relative URI, that relative URI is  <termref def="dt-resolve-relative-uri">resolved to an absolute URI</termref> using
  the <termref def="dt-base-uri">base URI</termref> in the <termref def="dt-static-context">static context</termref>. If a Prolog
  contains more than one default collation declaration, or the value
  specified by a default collation declaration (after resolution of a
  relative URI, if necessary) is not present in <termref def="dt-static-collations">statically known collations</termref>, a
  <termref def="dt-static-error">static error</termref> is raised
  <errorref class="ST" code="0038"/>.</p>
</div2>
<div2 id="id-base-uri-decl">
         <head>Base URI Declaration</head>
         <scrap headstyle="show">
		<head>
</head> 
<prod num="11" id="doc-xquery11-BaseURIDecl">
            <lhs>BaseURIDecl</lhs>
            <rhs>"declare"  "base-uri"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-URILiteral" xlink:type="simple">URILiteral</nt>
            </rhs>
          </prod> 
         </scrap>
 
         <p>
<termdef id="dt-base-uri-decl" term="base URI declaration">A <term>base URI declaration</term> specifies the
         <termref def="dt-base-uri">base URI</termref> property of the <termref def="dt-static-context">static context</termref>. The  <termref def="dt-base-uri">base URI</termref> property
         is used when resolving relative URIs within a
         <termref def="dt-module">module</termref>.</termdef> For example, the <code>fn:doc</code>
         function  <termref def="dt-resolve-relative-uri">resolves a relative URI</termref> using the base URI of the calling module.</p>

<p>The following is an example of a base URI declaration:</p>
<eg role="frag-prolog-parse-test" xml:space="preserve">declare base-uri "http://example.org";</eg>
<p>If a Prolog contains more than one base URI declaration, a <termref def="dt-static-error">static error</termref> is raised <errorref class="ST" code="0032"/>.</p>
<p>In the terminology of <bibref ref="RFC3986"/> Section 5.1,
the URILiteral of the base URI declaration is considered to be a "base URI
embedded in content". If no base URI declaration is present, the <termref def="dt-base-uri">base URI</termref> in
the <termref def="dt-static-context">static context</termref> is established according to the principles outlined
in <bibref ref="RFC3986"/> Section 5.1—that is, it defaults first to the base URI of
the encapsulating entity, then to the URI used to retrieve the entity, and
finally to an implementation-defined default. If the URILiteral in the base URI
declaration is a relative URI, then it is made absolute by resolving it with
respect to this same hierarchy. For example, if the URILiteral in the base URI declaration is <code>../data/</code>,
and the query is contained in a file whose URI is
<code>file:///C:/temp/queries/query.xq</code>, then the <termref def="dt-base-uri">base URI</termref> in the <termref def="dt-static-context">static context</termref> is <code>file:///C:/temp/data/</code>.</p>

<p diff="chg" at="XQ.E11">It is not intrinsically an error if this process fails to establish an absolute base URI; however, the <termref def="dt-base-uri">base URI</termref> in the <termref def="dt-static-context">static context</termref> is then <termref def="dt-undefined">undefined</termref> 
<errorref class="ST" code="0001"/>.  When the base URI in the static context is <termref def="dt-undefined">undefined</termref>, any attempt to use its value to  <termref def="dt-resolve-relative-uri">resolve a relative URI reference</termref> will result in an error <errorref class="ST" code="0001"/>. When the base URI of a constructed node is taken from the base URI in the static context and the latter is <termref def="dt-undefined">undefined</termref>, then the base-uri property of the constructed node is empty.</p>
</div2>

<div2 id="id-construction-declaration">
<head>Construction Declaration</head>
<scrap headstyle="show"> 
		<head>
</head>  
		 
		<prod num="12" id="doc-xquery11-ConstructionDecl">
            <lhs>ConstructionDecl</lhs>
            <rhs>"declare"  "construction"  ("strip"  |  "preserve")</rhs>
          </prod> 
	 </scrap>
<p>
<termdef term="construction declaration" id="dt-construction-decl">A <term>construction declaration</term> sets the <termref def="dt-construction-mode">construction
	 mode</termref> in the <termref def="dt-static-context">static
	 context</termref>, overriding any implementation-defined default.</termdef> The
			 construction mode governs the behavior of element and document node constructors. If construction mode is <code>preserve</code>, the type of a constructed element node is <code>xs:anyType</code>, and all attribute and element nodes copied during node construction    retain their original types. If construction mode is <code>strip</code>, the type of a constructed element node is <code>xs:untyped</code>; all element nodes copied during node construction receive the type <code>xs:untyped</code>, and all attribute nodes copied during node construction receive the type <code>xs:untypedAtomic</code>.</p>
<p>The following example illustrates a construction declaration:</p>
<eg role="frag-prolog-parse-test" xml:space="preserve">declare construction strip;</eg>
<p>If a Prolog specifies more than one construction declaration,  a <termref def="dt-static-error">static error</termref> is raised <errorref class="ST" code="0067"/>.</p>
</div2>
<div2 id="id-default-ordering-decl">
<head>Ordering Mode Declaration</head>
<scrap headstyle="show"> 
		<head>
</head>  
		 
		<prod num="13" id="doc-xquery11-OrderingModeDecl">
            <lhs>OrderingModeDecl</lhs>
            <rhs>"declare"  "ordering"  ("ordered"  |  "unordered")</rhs>
          </prod> 
	 </scrap>
<p>
<termdef id="dt-ordering-mode-decl" term="ordering mode declaration">An <term>ordering mode declaration</term> sets the <termref def="dt-ordering-mode">ordering mode</termref> in the <termref def="dt-static-context">static context</termref>, overriding any implementation-defined default.</termdef>  This ordering mode applies to all expressions in a <termref def="dt-module">module</termref> (including both the <termref def="dt-prolog">Prolog</termref> and the <termref def="dt-queryBody">Query Body</termref>, if any), unless overridden by an <code>ordered</code> or <code>unordered</code> expression.</p>
<p> 
<termref def="dt-ordering-mode">Ordering mode</termref> affects the behavior of <termref def="dt-path-expression">path expressions</termref> that include a "<code>/</code>" or "<code>//</code>" operator or an <termref def="dt-axis-step">axis step</termref>; <code>union</code>, <code>intersect</code>, and <code>except</code> expressions; and FLWOR expressions that have no <code>order by</code> clause. If ordering mode is <code>ordered</code>, node sequences returned by path,  <code>union</code>, <code>intersect</code>, and <code>except</code> expressions are in <termref def="dt-document-order">document order</termref>; otherwise the order of these return sequences is <termref def="dt-implementation-dependent">implementation-dependent</termref>. The effect of ordering mode on FLWOR expressions is described in <specref ref="id-flwor-expressions"/>.</p>
<p>The following example illustrates an ordering mode declaration:</p>
<eg role="frag-prolog-parse-test" xml:space="preserve">declare ordering unordered;</eg>
<p>If a Prolog contains more than one ordering mode declaration, a <termref def="dt-static-error">static error</termref> is raised <errorref class="ST" code="0065"/>.</p>
</div2>
<div2 id="id-empty-order-decl">
<head>Empty Order Declaration</head>
<scrap headstyle="show"> 
		<head>
</head>  
		 
		<prod num="14" id="doc-xquery11-EmptyOrderDecl">
            <lhs>EmptyOrderDecl</lhs>
            <rhs>"declare"  "default"  "order"  "empty"  ("greatest"  |  "least")</rhs>
          </prod> 
	 </scrap>
<p>
<termdef term="empty order declaration" id="dt-empty-order-decl">An <term>empty order declaration</term> sets the <termref def="dt-default-empty-order">default order for empty sequences</termref> in the <termref def="dt-static-context">static context,</termref> overriding any implementation-defined default. This declaration controls the processing of empty sequences and <code>NaN</code> values as ordering keys in an <code>order by</code> clause in a FLWOR expression.</termdef> An individual <code>order by</code> clause may override the default order for empty sequences by specifying <code>empty greatest</code> or <code>empty least</code>.</p>
<p>The following example illustrates an empty order declaration:</p>
<eg role="frag-prolog-parse-test" xml:space="preserve">declare default order empty least;</eg>
<p>If a Prolog contains more than one empty order declaration, a <termref def="dt-static-error">static error</termref> is raised <errorref class="ST" code="0069"/>.</p>
<note>
<p>It is important to distinguish an <termref def="dt-empty-order-decl">empty order declaration</termref> from an <termref def="dt-ordering-mode-decl">ordering mode declaration</termref>. An <termref def="dt-empty-order-decl">empty order declaration</termref> applies only when an <code>order by</code> clause is present, and specifies how empty sequences are treated by the <code>order by</code> clause (unless overridden). An <termref def="dt-ordering-mode-decl">ordering mode declaration</termref>, on the other hand, applies only in the absence of an <code>order by</code> clause.</p>
</note>
</div2>


<div2 id="id-copy-namespaces-decl">
<head>Copy-Namespaces Declaration</head>
<scrap headstyle="show"> 
<head>
</head>  
<prod num="15" id="doc-xquery11-CopyNamespacesDecl">
            <lhs>CopyNamespacesDecl</lhs>
            <rhs>"declare"  "copy-namespaces"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-PreserveMode" xlink:type="simple">PreserveMode</nt>  ","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-InheritMode" xlink:type="simple">InheritMode</nt>
            </rhs>
          </prod>
<prod num="16" id="doc-xquery11-PreserveMode">
            <lhs>PreserveMode</lhs>
            <rhs>"preserve"  |  "no-preserve"</rhs>
          </prod> 
<prod num="17" id="doc-xquery11-InheritMode">
            <lhs>InheritMode</lhs>
            <rhs>"inherit"  |  "no-inherit"</rhs>
          </prod>
</scrap>

<p>
<termdef id="dt-copy-namespaces-decl" term="copy-namespaces declaration">A <term>copy-namespaces declaration</term> sets the value
of <termref def="dt-copy-namespaces-mode">copy-namespaces
mode</termref> in the <termref def="dt-static-context">static
context</termref>, overriding any implementation-defined
default. Copy-namespaces mode controls the namespace bindings that are
assigned when an existing element node is copied by an element
constructor or document constructor.</termdef> Handling of namespace
bindings by element constructors is described in <specref ref="id-element-constructor"/>.</p>

<p>The following example illustrates a copy-namespaces
declaration:</p>

<eg role="frag-prolog-parse-test" xml:space="preserve">declare copy-namespaces preserve, no-inherit;</eg>

<p>If a Prolog contains more than one copy-namespaces declaration, a
<termref def="dt-static-error">static error</termref> is raised
<errorref class="ST" code="0055"/>.</p>
</div2>


<div2 id="id-decimal-format-decl">
<head>Decimal-Format Declaration</head>
<scrap headstyle="show">
<head>
</head>  
<prod num="18" id="doc-xquery11-DecimalFormatDecl">
            <lhs>DecimalFormatDecl</lhs>
            <rhs>"declare"  (("decimal-format"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-EQName" xlink:type="simple">EQName</nt>)  |  ("default"  "decimal-format"))  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-DFPropertyName" xlink:type="simple">DFPropertyName</nt>  "="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-StringLiteral" xlink:type="simple">StringLiteral</nt>)*</rhs>
          </prod>
<prod num="19" id="doc-xquery11-DFPropertyName">
            <lhs>DFPropertyName</lhs>
            <rhs>"decimal-separator"  |  "grouping-separator"  |  "infinity"  |  "minus-sign"  |  "NaN"  |  "percent"  |  "per-mille"  |  "zero-digit"  |  "digit"  |  "pattern-separator"</rhs>
          </prod>
</scrap>

<p>
<termdef id="dt-decimal-format-decl" term="decimal-format declaration">A <term>decimal-format declaration</term> defines
<termref def="dt-static-decimal-formats">statically known decimal
formats</termref>, which define the properties used to format numbers
using the <code>fn:format-number()</code> function</termdef>, as
described in <bibref ref="xpath-functions-11"/>.</p>

<p>It is a  <termref def="dt-static-error">static error</termref> for a query prolog to contain two decimal
formats with the same name, or to contain two default decimal formats.
<errorref class="ST" code="0111"/>.

It is a  <termref def="dt-static-error">static error</termref> for a decimal-format to specify a value that is
not legal for a given property, as described in <termref def="dt-static-decimal-formats">statically known decimal
formats</termref> 
<errorref class="ST" code="0097"/>.

It is a  <termref def="dt-static-error">static error</termref> if, for any named or unnamed decimal format, the
properties representing characters used in a picture string do not
each have distinct values.

These properties are
<termref def="id-static-decimal-separator">decimal-separator-sign</termref>, 
<termref def="id-static-decimal-format-grouping-separator">grouping-separator</termref>, 
<termref def="id-static-decimal-format-percent-sign">percent-sign</termref>, 
<termref def="id-static-decimal-format-per-mille-sign">per-mille-sign</termref>,
<termref def="id-static-decimal-format-zero-digit">zero-digit</termref>, 
<termref def="id-static-decimal-format-digit-sign">digit-sign</termref>, and 
<termref def="id-static-decimal-format-pattern-separator-sign">pattern-separator-sign</termref> 
<errorref class="ST" code="0098"/>.
</p>

</div2>

<div2 id="id-schema-import">
<head>Schema Import</head>
<scrap headstyle="show"> 
		<head>
</head>  
		 
		<prod num="21" id="doc-xquery11-SchemaImport">
            <lhs>SchemaImport</lhs>
            <rhs>"import"  "schema"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SchemaPrefix" xlink:type="simple">SchemaPrefix</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-URILiteral" xlink:type="simple">URILiteral</nt>  ("at"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-URILiteral" xlink:type="simple">URILiteral</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-URILiteral" xlink:type="simple">URILiteral</nt>)*)?</rhs>
          </prod> 
	 <prod num="22" id="doc-xquery11-SchemaPrefix">
            <lhs>SchemaPrefix</lhs>
            <rhs>("namespace"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-NCName" xlink:type="simple">NCName</nt>  "=")  |  ("default"  "element"  "namespace")</rhs>
          </prod>
</scrap>


<p>
<termdef id="dt-schema-import" term="schema import">A <term>schema
import</term> imports the element declarations, attribute declarations, and type definitions
from a schema into the <termref def="dt-issd">in-scope schema
definitions</termref>.
<phrase diff="chg" at="XQ.E29">For each user-defined atomic type in the schema, schema import also adds a corresponding
<termref def="dt-constructor-function">constructor function</termref>.</phrase>

</termdef> 

The schema to be imported is identified by its <termref def="dt-target-namespace">target namespace</termref>. The schema import may bind a namespace prefix to the target namespace of the imported schema, or may declare that target namespace to be the <termref def="dt-def-elemtype-ns">default element/type namespace</termref>. The schema import may also provide optional hints for locating the schema.</p>
<p>The namespace prefix specified in a schema import must not be <code>xml</code> or <code>xmlns</code> 
<errorref class="ST" code="0070"/>, and must not be the same as any namespace prefix bound in the same module by another schema import, a <termref def="dt-module-import">module import</termref>, a <termref def="dt-namespace-declaration">namespace declaration</termref>, or a <termref def="dt-module-import">module declaration</termref>  
<errorref class="ST" code="0033"/>.

It is a static error if the expanded QName and arity of a
constructor function are respectively equal to the
expanded QName and arity of a function declared in the importing
module or in another imported module (even if the declarations are
consistent) 
<errorref class="ST" code="0034"/>.
</p>



<p> The first <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-URILiteral" xlink:type="simple">URILiteral</nt> in a schema import specifies the target namespace of the schema to be imported. The URILiterals that follow the <code>at</code> keyword are optional location hints, and can be interpreted or disregarded in an implementation-dependent way. Multiple location hints might be used to indicate more than one possible place to look for the schema or multiple physical resources to be assembled to form the schema.</p>
<p>A schema import that specifies a zero-length string as target namespace is considered to import a schema that has no target namespace. Such a schema import must not bind a namespace prefix <errorref class="ST" code="0057"/>, but it may set the default element/type namespace to a zero-length string (representing "no namespace"), thus enabling the definitions in the imported namespace to be referenced. If the default element/type namespace is not set to "no namespace", there is no way to reference the definitions in an imported schema that has no target namespace.</p>
<p>It is a <termref def="dt-static-error">static error</termref> 
<errorref class="ST" code="0058"/> if more than one schema import in the same <termref def="dt-prolog">Prolog</termref> specifies the same target namespace. It is a <termref def="dt-static-error">static error</termref> 
<errorref class="ST" code="0059"/> if the implementation is not able to process a schema import by finding a valid schema with the specified target namespace. It is a <termref def="dt-static-error">static error</termref> 
<errorref class="ST" code="0035"/> if multiple imported schemas, or multiple physical resources within one schema, contain definitions for the same name in the same symbol space (for example, two definitions for the same element name, even if the definitions are consistent).  However, it is not an error to import the schema with target namespace <code>http://www.w3.org/2001/XMLSchema </code>(predeclared prefix <code>xs</code>), even though the built-in types defined in this schema are implicitly included in the <termref def="dt-is-types">in-scope schema types.</termref>
</p>



<p>
It is a  <termref def="dt-static-error">static error</termref> 
<errorref code="0012" class="ST"/> if the set of
definitions contained in all schemas imported by a Prolog do not satisfy the
conditions for schema validity specified in Sections 3 and 5 of
<bibref ref="XMLSchema"/> Part 1--i.e., each definition must
be valid, complete, and unique.</p>
<p>The following example imports a schema,
specifying both its target namespace and its location, and binding the
prefix <code>soap</code> to the target namespace:</p>
	
	 <eg role="frag-prolog-parse-test" xml:space="preserve">import schema namespace soap="http://www.w3.org/2003/05/soap-envelope"
at "http://www.w3.org/2003/05/soap-envelope/";</eg>
<p>The
            following example imports a schema by specifying only its
            target namespace, and makes it the default element/type
            namespace:</p>
<eg role="frag-prolog-parse-test" xml:space="preserve">import schema default element namespace "http://example.org/abc";</eg>
<p>The following example imports a schema that has no target namespace, providing a location hint, and sets the default element/type namespace to "no namespace" so that the definitions in the imported schema can be referenced:</p>
<eg role="frag-prolog-parse-test" xml:space="preserve">import schema default element namespace "" 
at "http://example.org/xyz.xsd";</eg>
<p>The following example imports a schema that has no target namespace and sets the default element/type namespace to "no namespace". Since no location hint is provided, it is up to the implementation to find the schema to be imported.</p>
<eg role="frag-prolog-parse-test" xml:space="preserve">import schema default element namespace "";</eg>
</div2>
<div2 id="id-module-import">
  <head>Module Import</head>
  <scrap headstyle="show"> 
    <head>
    </head>  
    
    <prod num="23" id="doc-xquery11-ModuleImport">
            <lhs>ModuleImport</lhs>
            <rhs>"import"  "module"  ("namespace"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-NCName" xlink:type="simple">NCName</nt>  "=")?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-URILiteral" xlink:type="simple">URILiteral</nt>  ("at"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-URILiteral" xlink:type="simple">URILiteral</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-URILiteral" xlink:type="simple">URILiteral</nt>)*)?</rhs>
          </prod> 
  </scrap>
  <p>
    <termdef term="module import" id="dt-module-import">A <term>module import</term> imports the <phrase diff="chg">variable declarations and public function
    declarations</phrase>  from one or more
  <termref def="dt-library-module">library modules</termref> into the <termref def="dt-function-signature">function signatures</termref> and  <termref def="dt-in-scope-variables">in-scope variables</termref> of the importing <termref def="dt-module">module</termref>.</termdef> Each module import names a  <termref def="dt-target-namespace">target namespace</termref> and imports an <termref def="dt-implementation-defined">implementation-defined</termref> set of modules that share this target namespace. The module import may bind a namespace prefix to the target namespace, and it may provide optional hints for locating the modules to be imported.</p>
  <p>The namespace prefix specified in a module import must not be <code>xml</code> or <code>xmlns</code> 
  <errorref class="ST" code="0070"/>, and must not be the same as any namespace prefix bound in the same module by another module import, a <termref def="dt-schema-import">schema import</termref>,  a <termref def="dt-namespace-declaration">namespace declaration</termref>, or a <termref def="dt-module-declaration">module declaration</termref> with a different target namespace <errorref class="ST" code="0033"/>.</p>
  <p>The first <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-URILiteral" xlink:type="simple">URILiteral</nt> in a module import must be of nonzero length <errorref class="ST" code="0088"/>, and specifies the target namespace of the modules to be imported. The URILiterals that follow the <code>at</code> keyword are optional location hints, and can be interpreted or disregarded in an <termref def="dt-implementation-defined">implementation-defined</termref> way.</p>
  <p>It is a <termref def="dt-static-error">static error</termref> 
  <errorref class="ST" code="0047"/> if more than one module import in a <termref def="dt-prolog">Prolog</termref> specifies the same target namespace. It is a <termref def="dt-static-error">static error</termref> 
  <errorref class="ST" code="0059"/> if the implementation is not able to process a module import by finding a valid module definition with the specified target namespace. It is a <termref def="dt-static-error">static error</termref> if the <termref def="dt-expanded-qname">expanded QName</termref> and arity of a function declared in an imported module are respectively equal to the <termref def="dt-expanded-qname">expanded QName</termref> and arity of a function declared in the importing module or in another imported module  (even if the declarations are consistent) <errorref class="ST" code="0034"/>. It is a <termref def="dt-static-error">static error</termref> if the <termref def="dt-expanded-qname">expanded QName</termref> of a variable declared in an imported module is equal (as defined by the <code>eq</code> operator) to the <termref def="dt-expanded-qname">expanded QName</termref> of a variable declared in the importing module or in another imported module (even if the declarations are consistent) <errorref class="ST" code="0049"/>.</p>
  <p>Each <termref def="dt-module">module</termref> has its own <termref def="dt-static-context">static context</termref>. A <termref def="dt-module-import">module import</termref> imports only 
  functions and variable declarations; it does not import other objects from the imported modules, such as 
  <termref def="dt-issd">in-scope schema definitions</termref> or <termref def="dt-static-namespaces">statically known namespaces</termref>. Module imports are not 
  transitive—that is, importing a module provides access only to function and 
  variable declarations contained directly in the imported module. For 
  example, if module A imports module B, and module B imports module C, 
  module A does not have access to the functions and variables declared in module C. </p>


  <p diff="chg" at="XQ.E8">A module may import its own target namespace (this is interpreted as importing an <termref def="dt-implementation-defined">implementation-defined</termref> set of other modules that share its target namespace.)</p>

  <!--	  <change diff="chg" at="XQ.E6"> -->
  <p>
    It is a <termref def="dt-static-error">static error</termref> 
    <errorref class="ST" code="0036"/> to import a module if the 
    <termref def="dt-issd">in-scope schema definitions</termref>
    of the importing module do not include all of the following:
  </p>
  <olist>
    <item>
      <p>An <termref def="dt-is-types">in-scope schema type</termref> 
      for each type-name that appears:
      </p>
      <olist>
	<item>
	  <p>in the type of a variable that is declared in the imported module
	  and referenced in the importing module, OR
	  </p>
	</item>
	<item>
	  <p>in a parameter-type or result-type of a function that is declared
	  in the imported module and referenced in the importing module.
	  </p>
	</item>
      </olist>
    </item>

    <item>
      <p>An <termref def="dt-is-elems">in-scope element declaration</termref>
      for each element-name <code>EN</code> such that:
      </p>
      <olist>
	<item>
	  <p>
	    <code>schema-element(EN)</code> appears in the declared 
	    type of a variable 
	    in the imported module, and that variable is referenced 
	    in the importing module, OR
	  </p>
	</item>
	<item>
	  <p>
	    <code>schema-element(EN)</code> appears in a parameter-type or 
	    result-type of a function declared in the imported module, and 
	    that function is referenced in the importing module.
	  </p>
	</item>
      </olist>
    </item>


    <item>
      <p>An <termref def="dt-is-attrs">in-scope attribute declaration</termref>
      for each attribute-name <code>AN</code> such that:
      </p>
      <olist>
	<item>
	  <p>
	    <code>schema-attribute(AN)</code> appears in the declared 
	    type of a variable 
	    in the imported module, and that variable is referenced 
	    in the importing module, OR
	  </p>
	</item>
	<item>
	  <p>
	    <code>schema-attribute(AN)</code> appears in a parameter-type 
	    or result-type 
	    of a function declared in the imported module, and that function 
	    is referenced in the importing module.
	  </p>
	</item>
      </olist>
    </item>
  </olist>
  <!--	</change> -->

  <p>To illustrate the above rules, suppose that a certain schema
  defines a type named <code>triangle</code>. Suppose that a library
  module imports the schema, binds its target namespace to the prefix
  <code>geometry</code>, and declares a function with the following
  <termref def="dt-function-signature">function signature</termref>:
  <code>math:area($t as geometry:triangle) as xs:double</code>. If a
  query wishes to use this function, it must import <emph>both</emph>
  the library module and the schema on which it is based. Importing the
  library module alone would not provide access to the definition of the
  type <code>geometry:triangle</code> used in the signature of the
  <code>area</code> function.</p>

  <p>The following example illustrates a module import:</p>
  <eg role="frag-prolog-parse-test" xml:space="preserve">import module namespace math =
  "http://example.org/math-functions";</eg>


  <div3 id="id-module-handling-module-uris">
    <head>Module URIs</head>

    <p>Module URIs should be treated in the same way as other namespace
    URIs.</p>

    <p>To maximize interoperability, query authors should use a string
    that is a legal absolute IRI.</p>

    <p>Implementions must accept any string of Unicode characters. Module
    URIs are compared using the Unicode codepoint collation rather than
    any concept of semantic equivalence.</p>

    <p>Implementations may provide mechanisms allowing the module URI to be used as
    input to a process that delivers the module as a resource, for example a
    catalog, module repository, or URI resolver. For interoperability, such
    mechanisms should not prevent the user from choosing an arbitrary URI for
    naming a module.</p>

    <p>Similarly, implementations may perform syntactic transformations on
    the module URI to obtain the names of related resources, for example
    to implement a convention relating the name or location of compiled
    code to the module URI; but again, such mechanisms should not prevent
    the user from choosing an arbitrary module URI.</p>

    <p>As with other namespace URIs, it is common practice to use module
    URIs whose scheme is "http" and whose authority part uses a DNS domain
    name under the control of the user.</p>

    <p>The specifications allow, and some users might consider it good
    practice, for the module URI of a function library to be the same as
    the namespace URI of the XML vocabulary manipulated by the functions
  in that library.</p> </div3>

  <div3 id="id-module-handling-multiple-same">
    <head>Multiple Modules with the same Module URI</head>

    <p>Several different modules with the same Module URI can be used in
    the same query. The names of global variables and functions must be
    unique within the query as a whole: that is, if two modules with the
    same module URI are used in the same query, the names of their global
    variables and functions must not overlap.</p>

    <p>If one module contains an "import module" declaration for the
    module URI M, then all global variables and functions declared in
    participating modules whose module URI is M must be accessible in the
    importing module, regardless whether the participation of the imported
    module was directly due to this "import module" declaration.</p>

    <p>There must be only one instance of a global variable with any given
    name.  For example, if a global variable V is initialized using an
    element constructor, then there must be only one instance of this
    element, even if the module in which V is declared is imported by
    several other modules.</p>

    <p>In an environment where a group of modules can be compiled as a
    unit, an implementation may consider a module used in the compiled
    unit distinct from another instance of the same module imported from
    elsewhere in the query.</p>

  </div3>


  <div3 id="id-module-handling-location-uris">
    <head>Location URIs</head>

    <p>The term "location URIs" refers to the URIs in the "at" clause of
    an "import module" declaration.</p>

    <p>Products should (by default or at user option) take account of all the
    location URIs in an "import module" declaration, treating each location URI
    as a reference to a module with the specified module URI. Location URIs
    should be made absolute with respect to the static base URI of the query
    module containing the "import module" declaration where they appear. The
    mapping from location URIs to module source code or compiled code MAY be
    done in any way convenient to the implementation. If possible given the
    product's
    architecture, security requirements, etc, the product should allow this 
    to fetch the source code of the module to use the standard web mechanisms
    for dereferencing URIs in
    standard schemes such as the "http" URI scheme.</p>

    <p>When the same absolutized location URI is used more than once,
    either in the same "import module" declaration or in different "import
    module" declarations within the same query, a single copy of the
    resource containing the module is loaded. When different absolutized
    location URIs are used, each results in a single module being loaded,
    unless the implementation is able to determine that the different URIs
    are references to the same resource.

    No error due to duplicate variable or functions names should arise
    from the same module being imported more than once, so long as the
    absolute location URI is the same in each case.</p>

    <p>Implementations must report a static error if a location URI cannot
    be resolved after all available recovery strategies have been
    exhausted.</p>

  </div3>
  <div3 id="id-module-handling-cycles">
          <head>Cycles</head>

  <p>It is not an error to have a cycle in the import graph, either at
  the level of module URIs or at the level of location URIs. The only
  rules concerning cycles are the rules for functions and variables
  declared in different modules.</p>
  </div3>

</div2>
<div2 id="id-namespace-declaration">

	 <head>Namespace Declaration</head> 
	 <scrap headstyle="show"> 
		<head>
</head> 
<prod num="24" id="doc-xquery11-NamespaceDecl">
            <lhs>NamespaceDecl</lhs>
            <rhs>"declare"  "namespace"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-NCName" xlink:type="simple">NCName</nt>  "="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-URILiteral" xlink:type="simple">URILiteral</nt>
            </rhs>
          </prod> 
		 
		 
	 </scrap> 
	  
	 <p>
<termdef id="dt-namespace-declaration" term="namespace declaration">A <term>namespace declaration</term> declares a namespace prefix and
	 associates it with a namespace URI, adding the (prefix, URI) pair to the set of
	 <termref def="dt-static-namespaces">statically known namespaces</termref>.</termdef> The namespace declaration is in scope throughout the query
	 in which it is declared, unless it is overridden by a <termref def="dt-namespace-decl-attr">namespace declaration attribute</termref> in a <termref def="dt-direct-elem-const">direct element constructor</termref>.</p>
<p>If the URILiteral part of a namespace declaration is a zero-length 
string, any existing namespace binding for the given prefix is removed 
from the <termref def="dt-static-namespaces">statically known namespaces</termref>. This feature provides a way to 
remove predeclared namespace prefixes such as <code>local</code>.</p>
<p>The following query illustrates a namespace declaration:</p> 
	 <eg role="parse-test" xml:space="preserve">
declare namespace foo = "http://example.org";
&lt;foo:bar&gt; Lentils &lt;/foo:bar&gt;
</eg> 
	 <p>In the query result, the newly created node is in the namespace
	 associated with the namespace URI <code>http://example.org</code>.</p> 
	  
	  
	  
	  
	   <p diff="chg" at="XQ.E19">The namespace prefix specified in a namespace declaration must not be 
             <code>xml</code> or <code>xmlns</code> 
<errorref class="ST" code="0070"/>. 
             The namespace URI specified in a namespace declaration must not be 
             <code>http://www.w3.org/XML/1998/namespace</code> or 
             <code>http://www.w3.org/2000/xmlns/</code> 
             <errorref class="ST" code="0070"/>. 
             The namespace prefix specified in a namespace declaration must not be 
             the same as any namespace prefix bound in the same module by a 
             <termref def="dt-module-import">module import</termref>, 
             <termref def="dt-schema-import">schema import</termref>, 
             <termref def="dt-module-import">module declaration</termref>, 
             or another namespace declaration <errorref class="ST" code="0033"/>.
          </p>

<p>It is a <termref def="dt-static-error">static error</termref> 
<errorref class="ST" code="0081"/> if an expression contains a  <termref def="dt-qname">lexical QName</termref> with a namespace prefix that is not in the <termref def="dt-static-namespaces">statically known namespaces</termref>.</p> 
	  
	 <p>XQuery has several predeclared namespace prefixes that are present in the <termref def="dt-static-namespaces">statically known namespaces</termref> before each query is processed. These prefixes may be used without an explicit declaration. They may be overridden by <termref def="dt-namespace-declaration">namespace declarations</termref> in a <termref def="dt-prolog">Prolog</termref> or by <termref def="dt-namespace-decl-attr">namespace declaration attributes</termref>  on constructed elements (however,  the prefix <code>xml</code> must not be redeclared, and no other prefix may be bound to the namespace URI associated with the prefix <code>xml</code> 
<errorref class="ST" code="0070"/>). The predeclared namespace prefixes are as follows:</p>
<ulist>
<item>
<p>
<code>xml = http://www.w3.org/XML/1998/namespace</code>
</p>
</item>
<item>
<p>
<code>xs = http://www.w3.org/2001/XMLSchema</code>
</p>
</item>
<item>
<p>
<code>xsi = http://www.w3.org/2001/XMLSchema-instance</code>
</p>
</item>
<item>
<p>
<code>fn = http://www.w3.org/2005/xpath-functions</code>
</p>
</item>
<item>
<p>
<code>local = http://www.w3.org/2005/xquery-local-functions</code> (see <specref ref="FunctionDeclns"/>.)</p>
</item>
</ulist> 
	  
	 
	 	
<p>Additional predeclared namespace prefixes may be added to the <termref def="dt-static-namespaces">statically known namespaces</termref> by an implementation.</p> 
	  
	  
	 <p>When element or attribute names are compared, they are considered identical if
	 the local parts and namespace URIs match on a codepoint basis. Namespace prefixes need not be identical for two names to match, as illustrated by the following example:</p> 
	 <eg role="parse-test" xml:space="preserve">
declare namespace xx = "http://example.org";

let $i := &lt;foo:bar xmlns:foo = "http://example.org"&gt;
              &lt;foo:bing&gt; Lentils &lt;/foo:bing&gt;
          &lt;/foo:bar&gt;
return $i/xx:bing
</eg> 
	 <p>Although the namespace prefixes <code>xx</code> and <code>foo</code> differ, both are bound to the namespace URI <code>"http://example.org"</code>. Since <code>xx:bing</code> and <code>foo:bing</code> have the same local name and the same namespace URI, they match. The
	 output of the above query is as follows.</p> 
	 <eg role="parse-test" xml:space="preserve">
&lt;foo:bing xmlns:foo = "http://example.org"&gt; Lentils &lt;/foo:bing&gt;
</eg>
</div2>
<div2 id="id-default-namespace">
<head>Default Namespace Declaration</head>
<scrap headstyle="show"> 
		<head>
</head>  
		<prod num="25" id="doc-xquery11-DefaultNamespaceDecl">
            <lhs>DefaultNamespaceDecl</lhs>
            <rhs>"declare"  "default"  ("element"  |  "function")  "namespace"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-URILiteral" xlink:type="simple">URILiteral</nt>
            </rhs>
          </prod> 
		 
	 </scrap>
<p>
<term>Default namespace declarations</term> can be
	 used in a <termref def="dt-prolog">Prolog</termref> to facilitate the use of unprefixed
	 QNames. The following kinds of default namespace declarations
	 are supported:</p>
<ulist>
<item>
<p>A <term>default element/type namespace declaration</term> declares a namespace URI that is associated with unprefixed names of elements and types. This declaration is recorded as the <termref def="dt-def-elemtype-ns">default element/type namespace</termref> in the <termref def="dt-static-context">static
		context</termref>. A <termref def="dt-prolog">Prolog</termref> may contain at most one default element/type namespace declaration <errorref class="ST" code="0066"/>. If the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-URILiteral" xlink:type="simple">URILiteral</nt> in a default element/type namespace declaration is a zero-length string, the <termref def="dt-def-elemtype-ns">default element/type namespace</termref> is undeclared (set to "none"), and unprefixed names of elements and types are considered to be in no
	 namespace. The following example illustrates the declaration
	 of a default namespace for elements and types:</p>
<eg role="frag-prolog-parse-test" xml:space="preserve">declare default element namespace "http://example.org/names";</eg>
<p>A default element/type namespace declaration may be overridden by a <termref def="dt-namespace-decl-attr">namespace declaration attribute</termref> in a <termref def="dt-direct-elem-const">direct element constructor</termref>.</p>
<p>If no default
	 element/type namespace declaration is present, unprefixed element and type names are in no namespace (however, an implementation may define a different default  as specified in <specref ref="id-xq-static-context-components"/>.)</p>
</item>
<item>
<p>A <term>default function namespace declaration</term> declares a namespace URI that is associated with unprefixed function names in function calls and function declarations. This declaration is recorded as the <termref def="dt-def-fn-ns">default function namespace</termref> in the <termref def="dt-static-context">static
		context</termref>. A <termref def="dt-prolog">Prolog</termref> may contain at most one default function namespace declaration <errorref class="ST" code="0066"/>. If the StringLiteral in a default function
namespace declaration is a zero-length string, the default function
namespace is undeclared (set to "none"). In that case, any functions that are associated
with a namespace can be called only by using an explicit namespace prefix.</p>
<p>If no default
	 function namespace declaration is present, the default function namespace is the namespace of XPath/XQuery functions,
	 <code>http://www.w3.org/2005/xpath-functions</code> (however, an implementation may define a different default  as specified in <specref ref="id-xq-static-context-components"/>.)</p>
<p>The
	 following example illustrates the declaration of a default
	 function namespace:</p>
<eg role="frag-prolog-parse-test" xml:space="preserve">declare default function namespace 
     "http://example.org/math-functions";</eg>
<p>The effect of declaring
	 a default function namespace is that all functions in the
	 default function namespace, including implicitly-declared
	 <termref def="dt-constructor-function">constructor functions</termref>, can be invoked without
specifying a namespace prefix.  When a function call uses a
	 function name with no prefix, the local name of the function
	 must match a function (including
	 implicitly-declared <termref def="dt-constructor-function">constructor functions</termref>) in the default
	 function namespace <errorref class="ST" code="0017"/>.</p>
<note>
<p>Only <termref def="dt-constructor-function">constructor functions</termref> can be in no namespace.</p>
</note>
</item>
</ulist>
<p> Unprefixed attribute names and variable names are in no namespace.</p>
</div2>

<div2 id="id-annotations">
<head>Annotations</head>

<scrap headstyle="show"> 
<head>
</head>
<prod num="26" id="doc-xquery11-AnnotatedDecl">
            <lhs>AnnotatedDecl</lhs>
            <rhs>"declare"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Annotation" xlink:type="simple">Annotation</nt>*  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-VarDecl" xlink:type="simple">VarDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-FunctionDecl" xlink:type="simple">FunctionDecl</nt>)</rhs>
          </prod> 
<prod num="27" id="doc-xquery11-Annotation">
            <lhs>Annotation</lhs>
            <rhs>"%"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-EQName" xlink:type="simple">EQName</nt>  ("("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Literal" xlink:type="simple">Literal</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Literal" xlink:type="simple">Literal</nt>)*  ")")?</rhs>
          </prod>   	
</scrap>

<p>XQuery uses annotations to declare properties associated with
functions and variables. For instance, a function may be declared
<code>%public</code>, <code>%private</code>,
<code>%deterministic</code> or <code>%nondeterministic</code>. The
semantics associated with these properties are described in <specref ref="FunctionDeclns"/>.</p>

<p>Annotations are <code>(QName, value)</code> pairs. If the EQName of
the annotation is a <termref def="dt-qname">lexical QName</termref>,
the prefix of the QName is resolved using the statically known
namespaces; if no prefix is present, the name is in the <termref def="dt-def-fn-ns">default function namespace</termref>. The XQuery
family of languages define annotations in the <code>fn</code>
namespace.  Assuming this the default element namespace is
<code>fn</code>, the annotations <code>%private</code> and
<code>%fn:private</code> both have the same annotation name.</p>

<p>Implementations can add their own annotations, which should not be
in the <code>fn</code> namespace. For instance, if the <code>eg</code>
prefix is bound to a namespace associated with a particular
implementation, it could define annotations like
<code>eg:sequential</code>. The semantics and error handling
associated with such annotations are beyond the scope of this
specification.</p>

<p>An annotation always has a value. If no explicit value is provided, the
value is <code>fn:true()</code>. For instance, the annotation
<code>%private</code> sets the value of the <code>private</code>
property to <code>true</code>. An annotation can provide values
explicitly using a parenthesized list of 
<termref def="id-literals">literals</termref>. For instance, the
annotation <code>%java:method("java.lang.Math.sin")</code> sets the
value of the <code>java:method</code> property to the string value
<code>java.lang.Math.sin</code>.</p>

</div2>


<div2 id="id-variable-declarations">
<head>Variable Declaration</head>

<scrap headstyle="show"> 
<head>
</head>
<prod num="26" id="noid_N1706E.doc-xquery11-AnnotatedDecl">
            <lhs>AnnotatedDecl</lhs>
            <rhs>"declare"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Annotation" xlink:type="simple">Annotation</nt>*  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-VarDecl" xlink:type="simple">VarDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-FunctionDecl" xlink:type="simple">FunctionDecl</nt>)</rhs>
          </prod> 
<prod num="27" id="noid_N17071.doc-xquery11-Annotation">
            <lhs>Annotation</lhs>
            <rhs>"%"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-EQName" xlink:type="simple">EQName</nt>  ("("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Literal" xlink:type="simple">Literal</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Literal" xlink:type="simple">Literal</nt>)*  ")")?</rhs>
          </prod>   	
<prod num="28" id="doc-xquery11-VarDecl">
            <lhs>VarDecl</lhs>
            <rhs>"variable"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-VarName" xlink:type="simple">VarName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  ((":="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-VarValue" xlink:type="simple">VarValue</nt>)  |  ("external"  (":="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-VarDefaultValue" xlink:type="simple">VarDefaultValue</nt>)?))</rhs>
          </prod> 
<prod num="129" id="noid_N17078.doc-xquery11-VarName">
            <lhs>VarName</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-EQName" xlink:type="simple">EQName</nt>
            </rhs>
          </prod>
<prod num="168" id="noid_N1707B.doc-xquery11-TypeDeclaration">
            <lhs>TypeDeclaration</lhs>
            <rhs>"as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SequenceType" xlink:type="simple">SequenceType</nt>
            </rhs>
          </prod>
<prod num="29" id="doc-xquery11-VarValue">
            <lhs>VarValue</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>
            </rhs>
          </prod>
<prod num="30" id="doc-xquery11-VarDefaultValue">
            <lhs>VarDefaultValue</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>
            </rhs>
          </prod>
</scrap>



<p>A <term>variable declaration</term> adds the <termref def="dt-static-type">static type</termref> of a variable to the
<termref def="dt-in-scope-variables">in-scope variables</termref>, and
may also add a value for the variable to the <termref def="dt-variable-values">variable values</termref>. </p>

<note>
  <p>A <term>variable declaration</term> always refers to a
  declaration of a variable in a Prolog. The binding of a variable to
  a value in a query expression, such as a FLWOR expression, is known
  as a <term>variable binding</term>, and does not make the variable visible to an
  importing module.</p>
</note>

  <p>During static analysis, a variable declaration causes a pair
  <code>(expanded QName N, type T)</code> to be added to the <termref def="dt-in-scope-variables">in-scope variables</termref>.

  The expanded QName N is the <code>VarName</code>. If N is equal (as
  defined by the eq operator) to the expanded QName of another
  variable in in-scope variables, a  <termref def="dt-static-error">static error</termref> is raised <errorref class="ST" code="0049"/>.</p>

  <p>All variable names declared in a library module must (when
  expanded) be in the target namespace of the library module <errorref class="ST" code="0048"/>. When a library module is imported,
  variables declared in the imported module are added to the in-scope
  variables of the importing module.</p>

  <p>Variable names that have no namespace prefix are in no namespace.
  Variable declarations that have no namespace prefix may appear only
  in a main module.</p>

<p>Here are some examples of variable declarations:</p>

<ulist>
  <item> 
<p>The following declaration specifies both the type and
the value of a variable. This declaration causes the type
<code>xs:integer</code> to be associated with variable <code>$x</code>
in the <termref def="dt-static-context">static context</termref>, and
the value <code>7</code> to be associated with variable
<code>$x</code> in the <termref def="dt-dynamic-context">dynamic
context</termref>.</p>

<eg role="frag-prolog-parse-test" xml:space="preserve">declare variable $x as xs:integer := 7;</eg>

</item>
<item>
<p>The following
declaration specifies a value but not a type. The <termref def="dt-static-type">static type</termref> of the variable is inferred
from the static type of its value. In this case, the variable
<code>$x</code> has a static type of <code>xs:decimal</code>, inferred
from its value which is 7.5.</p>

<eg role="frag-prolog-parse-test" xml:space="preserve">declare variable $x := 7.5;</eg>

</item>
<item>
<p>The following declaration specifies a type
but not a value. The keyword <code>external</code> indicates that the
value of the variable will be provided by the external environment. At
evaluation time, if the variable <code>$x</code> in the <termref def="dt-dynamic-context">dynamic context</termref> does not have a
value of type <code>xs:integer</code>, a  <termref def="dt-type-error">type error</termref> is raised.</p>
<eg role="frag-prolog-parse-test" xml:space="preserve">declare variable $x as xs:integer external;</eg>
</item>
<item>
<p>The following declaration specifies
neither a type nor a value. It simply declares that the query depends
on the existence of a variable named <code>$x</code>, whose type and
value will be provided by the external environment. During query
analysis, the type of <code>$x</code> is considered to be
<code>item()*</code>. During query evaluation, the <termref def="dt-dynamic-context">dynamic context</termref> must include a type
and a value for <code>$x</code>, and its value must be compatible with
its type.</p>
<eg role="frag-prolog-parse-test" xml:space="preserve">declare variable $x external;</eg>
</item>
<item>
<p>The following declaration, which might
appear in a library module, declares a variable whose name includes a
namespace prefix:</p>
<eg role="frag-prolog-parse-test" xml:space="preserve">declare variable $math:pi as xs:double := 3.14159E0;</eg>
</item>

<item>
<p>This is an example of an external variable declaration that provides a <code>VarDefaultValue</code>:</p>
<eg role="frag-prolog-parse-test" xml:space="preserve">declare variable $x as xs:integer external := 47;</eg>
</item>
</ulist>

  <p>The syntax for variable declarations allows annotations, but XQuery 1.1 does not define annotations that apply to variable declarations. An implementation can provide annotations it needs. For instance, an implemenation that supports volatile external variables might allow them to be declared using an annotation:</p>

    <eg role="frag-prolog-parse-test" xml:space="preserve">declare %eg:volatile variable $time as xs:time external;</eg>

  <p>The type of the declared variable is as follows:</p>

  <ulist>
    <item>
<p>If <code>TypeDeclaration</code> is present, then the <code>SequenceType</code> in the
  <code>TypeDeclaration</code>; otherwise</p>
</item>

  <item>
<p>If the Static Typing Feature is in effect and <code>VarValue</code>
  is present, then the static type inferred from static analysis of
  the expression <code>VarValue</code>;</p>

  <note>
<p>Type inference might not be computable until after the
  check for circular dependencies, described below, is
  complete.</p>
</note>
</item>

  <item>
<p> Otherwise, <code>item()*</code>.</p>
</item>
</ulist>

<p>
<termdef term="initializing expression" id="dt-initializing-expression">If a variable declaration includes an
expression (<code>VarValue</code> or <code>VarDefaultValue</code>),
the expression is called an <term>initializing expression.</term> The
static context for an initializing expression includes all functions,
variables, and namespaces that are declared or imported anywhere in
the Prolog, other than the variable being declared.</termdef>
</p>

<!-- ================================================= -->

<p>
<termdef term="depends on a variable" id="dt-depends-on-variable"> 
An expression <code>E</code> 
<term>depends on a variable</term>
<code>V</code> if any of the following is true:
<table>
<tbody>
<tr>
<td rowspan="1" colspan="1">
<ulist>
<item>
<p>
<code>E</code> is a variable reference bound to variable <code>V</code>
</p>
</item>
<item>
<p>
<code>E</code> 
<termref def="dt-depends-on-variable">depends on a variable</termref> whose initializer depends on <code>V</code>
</p>
</item>

<item>
<p>
<code>E</code> 
<termref def="dt-depends-on-context-item">depends on the context item</termref>
and the initializer of the context item <termref def="dt-depends-on-variable">depends on</termref> 
<code>V</code>
</p>
</item>

<item>
<p>
<code>E</code> 
<termref def="dt-depends-on-function">depends on a function</termref> whose body <termref def="dt-depends-on-variable">depends on</termref> 
<code>V</code>
</p>
</item>

<item>
<p>
<code>E</code> contains (directly or indirectly) an expression that <termref def="dt-depends-on-variable">depends on</termref> 
<code>V</code>
</p>
</item>
</ulist>
</td>
</tr>
</tbody>
</table>
</termdef>
</p>

<!-- ================================================= -->
<!--
<p>
<termdef term="function depends on" id="dt-function-depends"> A
<term>function</term> 
<code>f1</code> 
<term>depends on</term> a
variable <code>$y</code> or a function <code>f2</code> if a reference
to <code>$y</code> or <code>f2</code> appears in the body of
<code>f1</code>, or if there exists a variable <code>$z</code> or a
function <code>f3</code> such that <code>f1</code> depends on
<code>$z</code> or <code>f3</code> and <code>$z</code> or
<code>f3</code> depends on <code>$y</code> or
<code>f2</code>.</termdef>
</p> -->

<p>If the initializer of a variable <code>V</code> 
<termref def="dt-depends-on-variable">depends on</termref> 
<code>V</code>, 
a static error is raised, a <termref def="dt-static-error">static error</termref> is raised <errorref class="ST" code="0054"/>.</p>

<p>During query evaluation, each variable declaration causes a pair
<code>(expanded QName N, value V)</code> to be added to
the <termref def="dt-prolog">Prolog</termref> 
<termref def="dt-variable-values">variable
values</termref>. The expanded QName N is
the <code>VarName</code>. The value V is as follows:</p>

<ulist>
  <item>
<p>If <code>VarValue</code> is specified, then V is the result of
  evaluating <code>VarValue</code> as described below.</p>
</item>

  <item>
<p> If <code>external</code> is specified, then:</p>

  <ulist>
    <item>
<p> if a value is provided for the variable by the
   external environment, then V is that value.  The means by which
   typed values of external variables are provided by the external
   environment is implementation-defined.</p>
</item>

   <item>
<p> if no value is provided for the variable by the
   external environment, and <code>VarDefaultValue</code> is
   specified, then V is the result of evaluating
   <code>VarDefaultValue</code> as described below.</p>
</item>

   <item>
<p>If no value is provided for the variable by the
   external environment, and <code>VarDefaultValue</code> is not
   specified, then a  <termref def="dt-dynamic-error">dynamic error</termref> is raised <errorref class="DY" code="0002"/>.
    </p> 
    <p>It is implementation-dependent whether this error is raised if
    the evaluation of the query does not reference the value of the
    variable.</p>
</item>
</ulist>

<p>In all cases the value V must match the type T according to the rules
for SequenceType matching; otherwise a  <termref def="dt-type-error">type error</termref> is raised <errorref class="TY" code="0004"/>.</p>

<p>If <code>VarValue</code> or <code>VarDefaultValue</code> is evaluated, the dynamic context for the
evaluation is as follows:</p>

<ulist>
<item>
<p> The <termref def="dt-variable-values">variable values</termref> contain the values of all variables present in the static context. </p>
<note>
<p>A cyclic dependency between variables is a static
error, so it is always possible to evaluate all the variables that V depends
on before evaluating V.)</p>
</note>
</item>

<item>
<p>The function implementations contains the implementation of each function
present in the static context</p>
</item>

<item>
<p>All other properties of the dynamic context, including the context item,
position, and size, are the same as for the evaluation of the <code>QueryBody</code> of
the main module.</p>
</item>
</ulist>
</item>
</ulist>

</div2>

<div2 id="id-context-item-declarations">
<head>Context Item Declaration</head>

<scrap headstyle="show"> 
<head>
</head>  	
<prod num="31" id="noid_N172BD.doc-xquery11-ContextItemDecl">
            <lhs>ContextItemDecl</lhs>
            <rhs>"declare"  "context"  "item"  ("as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ItemType" xlink:type="simple">ItemType</nt>)?  ((":="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-VarValue" xlink:type="simple">VarValue</nt>)  |  ("external"  (":="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-VarDefaultValue" xlink:type="simple">VarDefaultValue</nt>)?))</rhs>
          </prod>
</scrap>

<!-- ================================================================== -->
<p>A context item declaration allows a query to specify
the <termref def="dt-static-type">static type</termref>, value, or
default value for the initial context item.</p>

<p>In a library module, a context item declaration specifies only the
static type.  Specifying a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-VarValue" xlink:type="simple">VarValue</nt> or <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-VarDefaultValue" xlink:type="simple">VarDefaultValue</nt> for a context item
declaration in a library module is a static error <errorref class="ST" code="0113"/>.</p>

<p>In every module that does not contain a context item declaration, the effect
is as if the declaration</p>

<eg xml:space="preserve">declare context item as item() external;</eg>

<p>appeared in that module.</p>

<p>During static analysis, the context item declaration has the effect
of setting the context item static type in the static context.  The
context item static type is set to <code>ItemType</code> if specified,
or to <code>item()</code> otherwise.</p>

<p>If a module contains more than one context item declaration, a static
error is raised <errorref class="ST" code="0099"/>.</p>

<p>The static context for an initializing expression includes all 
functions, variables, and namespaces that are declared or imported 
anywhere in the Prolog.</p>

<p>
<termdef id="dt-depends-on-context-item" term="expression depends on"> An expression <code>E</code> 
<term>depends on
the context item</term> if any of the following is true:

<table>
<tbody>
<tr>
<td rowspan="1" colspan="1">
<ulist>
<item>
<p>
<code>E</code> is "."</p>
</item>
<item>
<p>
<code>E</code> is "/", or any path expression beginning with "/" or "//"</p>
</item>
<item>
<p>
<code>E</code> is <code>position()</code> or <code>last()</code>
</p>
</item>
<item>
<p>
<code>E</code> is an axis step (including an abbreviated axis step such as '..' or '@x')</p>
</item>
<item>
<p>
<code>E</code> is a call to a built-in function that takes the context item as an
implicit argument</p>
</item>
<item>
<p>
<code>E</code> has a subexpression that depends on the context item, and <code>E</code> does not
bind the context item for that subexpression</p>
</item>
<item>
<p>
<code>E</code> 
<termref def="dt-depends-on-variable">depends on</termref> a variable whose initializer <termref def="dt-depends-on-context-item">depends on</termref> the context item</p>
</item>
<item>
<p>
<code>E</code> 
<termref def="dt-depends-on-function">depends on</termref> a function whose body <termref def="dt-depends-on-context-item">depends on</termref> the context item</p>
</item>
</ulist>
</td>
</tr>
</tbody>
</table>
</termdef>
</p>

<p>If the initializer of the context item <termref def="dt-depends-on-context-item">depends on</termref> the context item,
a static error is raised  <errorref class="ST" code="0107"/>.</p>

<p>During query evaluation, the context item in the dynamic context for the
evaluation of the <code>QueryBody</code> in the main module, and for the initializing
expression of every variable declaration in every module, is set as follows:</p>

<ulist>
<item>
<p>If <code>VarValue</code> is specified, then the result of evaluating <code>VarValue</code> as
described below.</p>
</item>
<item>
<p>If <code>external</code> is specified, then:</p>
<ulist>
  <item>
<p>if a value is provided for the context item by the external
  environment, then that value.</p> 
<p>The means by which an external
  value is provided by the external environment is
  implementation-defined.</p>
</item>

  <item>
<p>if no value is provided for the context item by the
  external environment, and <code>VarDefaultValue</code> is specified,
  then the result of evaluating <code>VarDefaultValue</code> as
  described below.</p>
</item>

  <item>
<p>if no value is provided for the context item by the
  external environment, and <code>VarDefaultValue</code> is not
  specified, then the context item is <termref def="dt-undefined">undefined</termref>, and a dynamic error is
  raised <errorref class="DY" code="0002"/> if the context item is
  referenced in the query.</p>
</item>
</ulist>
</item>
</ulist>
   
<p>In all cases where the context item has a value, that value must
match the type <code>T
</code> according to the rules for SequenceType
matching; otherwise a type error is raised <errorref class="TY" code="0004"/>.  If more than one module contains a context item
declaration, the context item must match the type declared in each
one.</p>

<p>If <code>VarValue</code> or <code>VarDefaultValue</code> is evaluated, the dynamic context for the
evaluation is as follows:</p>
<ulist>
<item>
<p>The variable values contains the values of all variables
present in the static context</p>
</item>
<item>
<p>The context item, position, and size are <termref def="dt-undefined">undefined</termref>
</p>
</item>
<item>
<p>Function implementations includes an implementation of each function
present in the static context of the expression</p>
</item>
<item>
<p>All other properties of the dynamic context are the same as for the
evaluation of the <code>QueryBody</code> of the main module.</p>
</item>
</ulist>

<p>Here are some examples of context item declarations.</p>

<ulist>
<item>
<p>Declare the type of the context item:</p>
<eg role="frag-prolog-parse-test" xml:space="preserve">declare namespace env="http://www.w3.org/2003/05/soap-envelope";
declare context item as element(env:Envelope) external;</eg>
</item>
<item>
<p>Declare a default context item, which is a system log in a default 
location. If the system log is in a different location, it can be 
specified in the external environment:</p>
<eg role="frag-prolog-parse-test" xml:space="preserve">
declare context item as element(sys:log) external := doc("/var/xlogs/sysevent.xml");
</eg>
</item>
<item>
<p>Declare the context item to always point to a particular collection:</p>
<eg role="frag-prolog-parse-test" xml:space="preserve">
declare context item := collection("docs");
</eg>
</item>
</ulist>
</div2>


<div2 id="FunctionDeclns"> 
<head>Function Declaration</head> 
<p>In addition to the built-in functions described in
<bibref ref="xpath-functions-11"/>, XQuery allows users to declare functions
of their own. A function declaration specifies the name of the function, the
names and datatypes of the parameters, and the datatype of the result. All
datatypes are specified using the syntax described in
<specref ref="id-types"/>. A function declaration causes the declared function to be added to the <termref def="dt-function-signature">function signatures</termref> of the <termref def="dt-module">module</termref> in which it appears.</p>
 
<scrap headstyle="show"> 
<head>
</head> 
<prod num="26" id="noid_N17446.doc-xquery11-AnnotatedDecl">
            <lhs>AnnotatedDecl</lhs>
            <rhs>"declare"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Annotation" xlink:type="simple">Annotation</nt>*  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-VarDecl" xlink:type="simple">VarDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-FunctionDecl" xlink:type="simple">FunctionDecl</nt>)</rhs>
          </prod> 
<prod num="27" id="noid_N17449.doc-xquery11-Annotation">
            <lhs>Annotation</lhs>
            <rhs>"%"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-EQName" xlink:type="simple">EQName</nt>  ("("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Literal" xlink:type="simple">Literal</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Literal" xlink:type="simple">Literal</nt>)*  ")")?</rhs>
          </prod> 
<prod num="32" id="doc-xquery11-FunctionDecl">
            <lhs>FunctionDecl</lhs>
            <rhs>"function"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-EQName" xlink:type="simple">EQName</nt>  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ParamList" xlink:type="simple">ParamList</nt>?  ")"  ("as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SequenceType" xlink:type="simple">SequenceType</nt>)?  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-FunctionBody" xlink:type="simple">FunctionBody</nt>  |  "external")</rhs>
          </prod> 
<prod num="33" id="doc-xquery11-ParamList">
            <lhs>ParamList</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Param" xlink:type="simple">Param</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Param" xlink:type="simple">Param</nt>)*</rhs>
          </prod> 
<prod num="34" id="doc-xquery11-Param">
            <lhs>Param</lhs>
            <rhs>"$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-EQName" xlink:type="simple">EQName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?</rhs>
          </prod>
<prod num="35" id="doc-xquery11-FunctionBody">
            <lhs>FunctionBody</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-EnclosedExpr" xlink:type="simple">EnclosedExpr</nt>
            </rhs>
          </prod>
<prod num="168" id="noid_N1745C.doc-xquery11-TypeDeclaration">
            <lhs>TypeDeclaration</lhs>
            <rhs>"as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SequenceType" xlink:type="simple">SequenceType</nt>
            </rhs>
          </prod>
</scrap>

<p> A function declaration specifies whether a function is <termref def="dt-udf">user-defined</termref> or <termref def="dt-external-function">external</termref>.</p>

<p>
<termdef id="dt-udf" term="user-defined function">

<term>User defined functions</term> are functions that contain a <term>function body</term>, 
which provides the implementation of the function as an XQuery expression.</termdef>

The <termref def="dt-static-context">static context</termref> for a
function body includes all functions, variables, and namespaces that are declared or imported
anywhere in the <termref def="dt-prolog">Prolog</termref>, including
the function being declared.</p>

		<p> 
<termdef id="dt-external-function" term="external function">
<term>External functions</term> are functions that are implemented outside the query environment.</termdef> For example, an XQuery implementation might provide a set of external functions in addition to the core function library described in <bibref ref="xpath-functions-11"/>. External functions are identified by the keyword <code>external</code>. The purpose of a function declaration for an external function is to declare the datatypes of the function parameters and result, for use in type checking of the query that contains or imports the function declaration.</p>

<p diff="add">A function declaration may use function annotations to specify that a function is <code>%private</code> or <code>%public</code> (which is the default). <termdef id="dt-private-function" term="private function">A <term>private function</term> is hidden from <termref def="dt-module-import">module import</termref>, which can not import it into the <termref def="dt-function-signature">function signatures</termref> of another module. </termdef>
<termdef id="dt-public-function" term="public function">A <term>public function</term> is accessible to <termref def="dt-module-import">module import</termref>, which can import it into the <termref def="dt-function-signature">function signatures</termref> of another module. </termdef>
It is a <termref def="dt-static-error">static error</termref> 
<errorref class="ST" code="0106"/>
if a function's annotations contain more than one annotation named <code>%private</code> or <code>%public</code>.
</p>
 
		<p>A function declaration may use function annotations to specify that an external function is <code>%deterministic</code> (which is the default) or <code>%nondeterministic</code>. <termdef id="dt-deterministic-function" term="deterministic function">A <term>deterministic function</term> is a function that always evaluates to the same result if it is invoked with the same arguments.</termdef> 
<termdef id="dt-nondeterministic-function" term="nondeterministic function">A <term>nondeterministic function</term> is a function that is not guaranteed to always return the same result when it is invoked with the same arguments.</termdef>.

It is a <termref def="dt-static-error">static error</termref> 
<errorref class="ST" code="0106"/>
if a function's annotations contain more than one annotation named <code>%deterministic</code> or <code>%nondeterministic</code>.


An XQuery processor can use static analysis to determine
whether a user-defined function is deterministic (the syntax of function declarations does not allow a user-defined function to be declared deterministic or nondeterministic).</p>



<p>When rewriting expressions into equivalent expressions, as described in 
<specref ref="id-errors-and-opt"/>, a conforming XQuery 
implementation must ensure that each run-time invocation of a 
nondeterministic function in the original expression results in exactly 
one run-time invocation of the function in the rewritten expression. For instance, suppose the <code>random()</code> function is declared to be nondeterministic:</p>

<eg role="frag-prolog-parse-test" xml:space="preserve">
declare %nondeterministic function my:random( ) as xs:integer external;
</eg>

<p>Given the above declaration, this expression:
</p>

<eg role="parse-test" xml:space="preserve">let $r := my:random( )
return
   if ($r &gt; 0 and $r &lt; 10) then "Yes" else "No"
</eg>

<p>must not be rewritten as</p>

<eg role="parse-test" xml:space="preserve">if (my:random( ) &gt; 0 and my:random( ) &lt; 10) then "Yes" else "No"</eg>

<p>Similarly, this expression:</p>

<eg role="parse-test" xml:space="preserve">for $i in 1 to 10
return my:random( )</eg>

<p>must not be rewritten as</p>

<eg role="parse-test" xml:space="preserve">let $r := my:random( )
return
     for $i in 1 to 10
     return $r</eg>

		<p>An XQuery implementation may provide a facility whereby external functions can be implemented using a host programming language, but it is not required to do so. If such a facility is provided, the protocols by which parameters are passed to an external function, and the result of the function is returned to the invoking query, are <termref def="dt-implementation-defined">implementation-defined</termref>. An XQuery implementation may augment the type system of
<bibref ref="xpath-datamodel-11"/> with additional types  that are designed to facilitate exchange of data with host programming
languages, or it may provide mechanisms for the user to define such
types. For example, a type might be provided that encapsulates an object returned by an
external function, such as an SQL database connection. These additional types, if defined, are considered to be derived
by restriction from <code>xs:anyAtomicType</code>.</p>

<p>An implementation can define annotations, in its own namespace, to support functionality beyond the scope of this specification. For instance, an implementation that supports external Java functions might use an annotation to associate a Java function with an XQuery external function:</p>

<eg role="frag-prolog-parse-test" xml:space="preserve">declare %java:method("java.lang.Math.sin") function math:sin($a) external;</eg>

<p>Every user-defined function must be in a namespace--that is, every declared function name must (when expanded) have a non-null namespace URI <errorref class="ST" code="0060"/>. If the function name in a function declaration has no namespace prefix, it is considered to be in the <termref def="dt-def-fn-ns">default function namespace</termref>. Every function name declared in a <termref def="dt-library-module">library module</termref> must (when expanded) be in the <termref def="dt-target-namespace">target namespace</termref> of the library module <errorref class="ST" code="0048"/>.  It is a <termref def="dt-static-error">static error</termref> 
<errorref class="ST" code="0045"/> if the function name in a function declaration (when expanded) is in any of the following namespaces:</p>
<ulist>
<item>
<p>
<code>http://www.w3.org/XML/1998/namespace</code>
</p>
</item>
<item>
<p>
<code>http://www.w3.org/2001/XMLSchema</code>
</p>
</item>
<item>
<p>
<code>http://www.w3.org/2001/XMLSchema-instance</code>
</p>
</item>
<item>
<p>
<code>http://www.w3.org/2005/xpath-functions</code>
</p>
</item>
</ulist>
<p>It is a <termref def="dt-static-error">static error</termref> 
<errorref class="ST" code="0034"/> if the <termref def="dt-expanded-qname">expanded QName</termref> and arity (number of arguments) of the declared function are equal (as defined by the <code>eq</code> operator) to  the <termref def="dt-expanded-qname">expanded QName</termref> and arity of another function in <termref def="dt-function-signature">function signatures</termref>.</p>
<p>In order to allow main modules to declare functions for local use within the  module without defining a new namespace, XQuery predefines the namespace prefix <code>local</code> to the namespace <code>http://www.w3.org/2005/xquery-local-functions</code>. It is suggested (but not required) that this namespace be used for defining local functions.</p> 
 
<p>If a function parameter is declared using a name but no type, its default type is <code>item()*</code>. If the result type is omitted from a function declaration, its default result type is <code>item()*</code>.</p>
<p>The parameters of a function declaration are considered to be variables whose scope is the function body.

It is an <termref def="dt-static-error">static error</termref> 
<errorref class="ST" code="0039"/> for a function declaration to have more than one parameter with the same name.

The type of a function parameter can be any type that can be expressed as a <termref def="dt-sequence-type">sequence type</termref>.</p>
<p>The following example illustrates the declaration and use of a local function that
accepts a sequence of <code>employee</code> elements, summarizes them by department, and returns a sequence of <code>dept</code> elements.</p> 
<ulist> 
<item>
<p>Using a function, prepare a summary of employees that are located in
Denver.</p>
<eg role="parse-test" xml:space="preserve">declare function local:summary($emps as element(employee)*) 
   as element(dept)*
{
   for $d in fn:distinct-values($emps/deptno)
   let $e := $emps[deptno = $d]
   return
      &lt;dept&gt;
         &lt;deptno&gt;{$d}&lt;/deptno&gt;
         &lt;headcount&gt; {fn:count($e)} &lt;/headcount&gt;
         &lt;payroll&gt; {fn:sum($e/salary)} &lt;/payroll&gt;
      &lt;/dept&gt;
};

local:summary(fn:doc("acme_corp.xml")//employee[location = "Denver"])</eg>
 </item>
</ulist>
<p>Rules for converting function arguments to their declared parameter types, and for converting the result of a function to its declared result type, are described in <specref ref="id-function-calls"/>.</p> 
<p>A function declaration may be recursive—that is, it may reference itself. Mutually recursive functions, whose bodies reference each other,
are also allowed. The following example declares a recursive function that
computes the maximum depth of a node hierarchy, and calls the function to
find the maximum depth of a particular document. In its declaration, the
user-declared function <code>local:depth</code> calls the built-in functions <code>empty</code> and <code>max</code>, which are in the default function namespace.</p> 
<ulist> 
<item>
<p>Find the maximum depth of the document named <code>partlist.xml</code>.</p>
<eg role="parse-test" xml:space="preserve">declare function local:depth($e as node()) as xs:integer
{
   (: A node with no children has depth 1 :)
   (: Otherwise, add 1 to max depth of children :)
   if (fn:empty($e/*)) then 1
   else fn:max(for $c in $e/* return local:depth($c)) + 1
};

local:depth(fn:doc("partlist.xml"))
</eg>
</item>
</ulist> 
<p>Since a
<termref def="dt-constructor-function">constructor function</termref> is effectively declared for every
user-defined atomic type in the <termref def="dt-is-types">in-scope schema types</termref>, a <termref def="dt-static-error">static
error</termref> 
<errorref class="ST" code="0034"/>  is raised if the Prolog attempts to declare a single-parameter function with the same <termref def="dt-expanded-qname">expanded QName</termref>  as any of these types.</p> 

<!-- ============================================================ -->

<p>
<termdef id="dt-depends-on-function" term="depends on a function"> An expression <code>E</code> 
<term>depends on
a function</term> if any of the following is true:

<table>
<tbody>
<tr>
<td rowspan="1" colspan="1">
<ulist>
<item>
<p>
<code>E</code> is a call on function <code>F</code>
</p>
</item>
<item>
<p>
<code>E</code> 
<termref def="dt-depends-on-function">depends on a function</termref> whose body <termref def="dt-depends-on-function">depends on</termref> 
<code>F</code>.</p>
</item>
<item>
<p>
<code>E</code> 
<termref def="dt-depends-on-context-item">depends on the context item</termref> and the initializer of the context item <termref def="dt-depends-on-function">depends on</termref> 
<code>F</code>
</p>
</item>
<item>
<p>
<code>E</code> 
<termref def="dt-depends-on-variable">depends on a variable</termref> whose initializer  <termref def="dt-depends-on-function">depends on</termref> 
<code>F</code>
</p>
</item>
<item>
<p>
<code>E</code> contains (directly or indirectly) an expression that <termref def="dt-depends-on-function">depends on</termref> 
<code>F</code>
</p>
</item>
</ulist>
</td>
</tr>
</tbody>
</table>
</termdef>
</p>

<!-- ============================================================ -->

</div2>
<div2 id="id-option-declaration">
<head>Option Declaration</head>
<p>
<termdef term="option declaration" id="dt-option-declaration">An <term>option declaration</term> declares an option that affects the behavior of
a particular implementation. Each option consists of an identifying EQName and a StringLiteral.</termdef>
</p>
<scrap headstyle="show"> 
<head>
</head> 
<prod num="37" id="doc-xquery11-OptionDecl">
            <lhs>OptionDecl</lhs>
            <rhs>"declare"  "option"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-EQName" xlink:type="simple">EQName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-StringLiteral" xlink:type="simple">StringLiteral</nt>
            </rhs>
          </prod> 
 

</scrap>
<p>Typically, a particular option will be recognized by some implementations and
not by others. The syntax is designed so that option declarations can be
successfully parsed by all implementations.</p>
<p>If the EQName of an option is a <termref def="dt-qname">lexical QName</termref>, it must resolve to a namespace URI and local name, using the <termref def="dt-static-namespaces">statically known namespaces</termref> 
<errorref class="ST" code="0081"/>.</p>
<note>
<p>There is no default namespace for
options.</p>
</note>
<p>Each implementation recognizes an <termref def="dt-implementation-defined">implementation-defined</termref> set of namespace
URIs used to denote option declarations.</p>
<p>If the namespace part of the expanded QName is not a namespace recognized by the
implementation as one used to denote option declarations, then the option
declaration is ignored.</p>
<p>Otherwise, the effect of the option declaration, including its error behavior, is <termref def="dt-implementation-defined">implementation-defined</termref>.
For example, if the local part of the QName is
not recognized, or if the StringLiteral does not conform to the rules
defined by the implementation for the particular option declaration, the implementation may choose
whether to report an error, ignore the option declaration, or take some
other action.</p>
<p>Implementations may impose rules on where particular option declarations may
appear relative to variable declarations and function declarations, and the
interpretation of an option declaration may depend on its position.</p>
<p>An option declaration must not be used to change the syntax accepted by the
processor, or to suppress the detection of  <termref def="dt-static-error">static errors</termref>. However, it may be
used without restriction to modify the semantics of the query. The scope of
the option declaration is <termref def="dt-implementation-defined">implementation-defined</termref>—for example, an option
declaration might apply to the whole query, to the current module, or to
the immediately following function declaration.</p>
<p>The following examples illustrate several possible uses for option declarations:</p>
<ulist>
<!--  DIFF=DEL
<item>
<p>This option declaration might be used to set a serialization parameter:</p>
<eg role="frag-prolog-parse-test">declare namespace exq = "http://example.org/XQueryImplementation";
declare option exq:output "encoding = iso-8859-1";
</eg>
</item> -->
<item>
<p>This option declaration might be used to specify how comments in source documents returned by
the <code>fn:doc()</code> function should be handled:</p>
<eg role="frag-prolog-parse-test" xml:space="preserve">declare option exq:strip-comments "true";
</eg>
</item>
<item>
<p>This option declaration might be used to associate a namespace used in function names with a
Java class:
</p>
<eg role="frag-prolog-parse-test" xml:space="preserve">declare namespace math = "http://example.org/MathLibrary";
declare option exq:java-class "math = java.lang.Math";
</eg>
</item>
</ulist>
</div2>
</div1>



<div1 id="id-xquery-conformance" role="xquery">
    <head>Conformance</head>

    <note>
        <p>The XQuery Working Group has not yet determined conformance criteria for
	XQuery 1.1; in particular, we have not decided which of the new features of XQuery 1.1
        are optional. This section currently contains the conformance criteria for XQuery 1.0,
	with two modifications: (1) support for all axes is now required, (2) conformance
        criteria for syntax extensions are given.</p>
      </note>

    <p>This section defines the conformance criteria for an XQuery processor. In this section, the
        following terms are used to indicate the requirement levels defined in <bibref ref="RFC2119"/>. <termdef id="must" term="must">
            <term>MUST</term> means that the item is an absolute requirement of the specification.</termdef>
        <termdef id="may" term="may">
            <term>MAY</term> means that an item is truly optional.</termdef>
        <termdef id="should" term="should">
            <term>SHOULD</term> means that there may exist valid reasons in particular circumstances
            to ignore a particular item, but the full implications must be understood and carefully
            weighed before choosing a different course.</termdef>
    </p>
    <p>An XQuery processor that claims to conform to this specification <termref def="must">MUST</termref> include a claim of Minimal Conformance as defined in <specref ref="id-minimal-conformance"/>. In addition to a claim of Minimal Conformance, it
            <termref def="may">MAY</termref> claim conformance to one or more optional features
        defined in <specref ref="id-conform-optional-features"/>.</p>
    <div2 id="id-minimal-conformance">
        <head>Minimal Conformance</head>
        <p>Minimal Conformance to this specification <termref def="must">MUST</termref> include all
            of the following items:</p>
        <olist>
            <item>
                <p>Support for everything specified in this document except those features specified
                    in <specref ref="id-conform-optional-features"/> to be optional. If an
                    implementation does not provide a given optional feature, it <termref def="must">MUST</termref> implement any requirements specified in <specref ref="id-conform-optional-features"/> for implementations that do not provide
                    that feature.</p>
            </item>
            <item>
                <p>A definition of every item specified to be <termref def="dt-implementation-defined">implementation-defined</termref>, unless
                    that item is part of an optional feature that is not supported by the
                    implementation. A list of <termref def="dt-implementation-defined">implementation-defined</termref> items can be found in <specref ref="id-impl-defined-items"/>.</p>
                <note>
                    <p>Implementations are not required to define items specified to be <termref def="dt-implementation-dependent">implementation-dependent</termref>.</p>
                </note>
            </item>
            <item>
                <p>Support for <bibref ref="xpath-datamodel-11"/>, as specified in <specref ref="id-data-model-conformance"/>.</p>
            </item>
            <item>
                <p>Support for all functions defined in <bibref ref="xpath-functions-11"/>.</p>
            </item>
        </olist>
    </div2>
    <div2 id="id-conform-optional-features">
        <head>Optional Features</head>
        <div3 id="id-schema-import-feature">
            <head>Schema Import Feature</head>
            <p>
                <termdef id="dt-schema-import-feature" term="schema import feature">The <term>Schema
                        Import Feature</term> permits the query Prolog to contain a <termref def="dt-schema-import">schema import</termref>.</termdef>
            </p>
            <p>If an XQuery implementation does not support the Schema Import Feature, it <termref def="must">MUST</termref> raise a static error <errorref class="ST" code="0009"/> if it encounters a schema import.</p>
            <note>
                <p>If an implementation does not support the Schema Import Feature, the <termref def="dt-is-types">in-scope schema types</termref> consist only of built-in
                    and <termref def="dt-implementation-defined">implementation-defined</termref>
                    schema type definitions, as described in <specref ref="id-xq-static-context-components"/>.</p>
            </note>
        </div3>
        <div3 id="id-schema-validation-feature">
            <head>Schema Validation Feature</head>
            <p>
                <termdef id="dt-schema-validation-feature" term="schema validation feature">The
                        <term>Schema Validation Feature</term> permits a query to contain a
                        <code>validate</code> expression (see <specref ref="id-validate"/>.)</termdef>
            </p>
            <p>If an XQuery implementation does not support the Schema Validation Feature, it
                    <termref def="must">MUST</termref> raise a static error <errorref class="ST" code="0075"/> if it encounters a <code>validate</code> expression.</p>
        </div3>
        <div3 id="id-static-typing-feature">
            <head>Static Typing Feature</head>
            <p>

              <termdef id="dt-static-typing-feature" term="static     typing feature" role="xquery">The <term>Static
		  Typing Feature</term> requires implementations to
		  report all <termref def="dt-type-error">type
		  errors</termref> during
		  the <termref def="dt-static-analysis">static
		  analysis phase</termref>.</termdef>
            </p>


            <p>If an implementation supports
	      the <termref def="dt-static-typing-feature">Static
	      Typing Feature</termref>, then
	      it <termref def="must">MUST</termref> report an error
	      during static analysis whenever the inferred static type
	      of an expression is not subsumed by the required type
	      for the context in which it appears.</p>

            <p>If an implementation does not support
	      the <termref def="dt-static-typing-feature">Static
	      Typing Feature</termref>, then it  <termref def="may">MAY</termref>
	      report type errors during the static analysis phase only in cases where the
	      inferred static type and the required type have an empty intersection (that
	      is, where evaluation of the expression is guaranteed to fail). It  <termref def="may">MAY</termref> defer
	      some or all type checking until the dynamic evaluation phase.</p>
        </div3>
<!--
        <div3 diff="del" id="id-full-axis-feature">
            <head>Full Axis Feature</head>
            <p>
                <termdef term="optional axis" id="dt-optional-axis">The following axes are
                    designated as <term>optional axes</term>: <code>ancestor</code>,
                        <code>ancestor-or-self</code>, <code>following</code>,
                        <code>following-sibling</code>, <code>preceding</code>, and
                        <code>preceding-sibling</code>.</termdef>
            </p>
            <p>
                <termdef id="dt-full-axis-feature" term="Full Axis Feature">A conforming XQuery
                    implementation that supports the <term>Full Axis Feature</term>
                    <termref def="must">MUST</termref> support all the <termref def="dt-optional-axis">optional axes</termref>.</termdef>
            </p>
            <p>Conforming XQuery implementations that do not support the Full Axis Feature <termref def="may">MAY</termref> support one or more optional axes; it is <termref def="dt-implementation-defined">implementation-defined</termref> which optional
                axes are supported by such implementations. A conforming implementation that
                encounters a reference to an optional axis that it does not support <termref def="must">MUST</termref> raise a <termref def="dt-static-error">static error</termref>
                <errorref class="ST" code="0010"/>.</p>
            <note>
                <p>XQuery does not recognize the <code>namespace</code> axis (defined by XPath 1.0
                    and deprecated by XPath 2.0).</p>
            </note>
        </div3>
-->
        <div3 id="id-module-feature">
            <head>Module Feature</head>
            <p>
                <termdef id="dt-module-feature" term="module feature">A conforming XQuery
                    implementation that supports the <term>Module Feature</term> allows a query
                    Prolog to contain a <term>Module Import</term> and allows <term>library
                    modules</term> to be created.</termdef>
            </p>
            <p>A conforming implementation that does not support the Module Feature <termref def="must">MUST</termref> raise a <termref def="dt-static-error">static error</termref>
                <errorref class="ST" code="0016"/> if it encounters a <termref def="dt-module-declaration">module declaration</termref> or a <termref def="dt-module-import">module import</termref>. Since a <termref def="dt-module-declaration">module declaration</termref> is required in a
                    <termref def="dt-library-module">library module</termref>, the Module Feature is
                required in order to create a <termref def="dt-library-module">library
                module</termref>. </p>
            <note>
                <p>In the absence of the Module Feature, each query consists of a single <termref def="dt-main-module">main module</termref>.</p>
            </note>
        </div3>
        <div3 id="id-serialization-feature">
            <head>Serialization Feature</head>
            <p>
                <termdef id="dt-serialization-feature" term="serialization feature">A conforming
                    XQuery implementation that supports the <term>Serialization Feature</term>
                    <termref def="must">MUST</termref> provide means for serializing the result of a
                    query, as specified in <specref ref="id-serialization"/>.</termdef>
            </p>
            <p>A conforming XQuery implementation that supports the Serialization Feature <termref def="must">MUST</termref> conform to <specref ref="id-xq-serialization-parameters"/>. The means by which serialization is
                invoked is <termref def="dt-implementation-defined">implementation-defined</termref>.</p>
            <p>If an error is raised during the serialization process as specified in <bibref ref="xslt-xquery-serialization-11"/>, an conforming XQuery implementation <termref def="must">MUST</termref> report the error to the calling environment.</p>
            <note>
                <p>Not all implementations need to serialize. For instance, an implementation might
                    provide results via an XML API instead of producing a textual
                representation.</p>
            </note>
        </div3>
    </div2>
    <div2 id="id-data-model-conformance">
        <head>Data Model Conformance</head>
        <p>All XQuery implementations process data represented in the <termref def="dt-datamodel">data model</termref> as specified in <bibref ref="xpath-datamodel-11"/>. The data model specification relies on languages such as XQuery to specify conformance criteria for the data model in their respective
            environments, and suggests that the following issues should be considered:</p>
        <olist>
            <item>
                <p>
                    <emph>Support for normative construction from an infoset.</emph> A conforming
                    implementation <termref def="may">MAY</termref> choose to claim conformance to
                        <xspecref spec="DM" ref="const-infoset"/>, which defines a
                    normative way to construct an <termref def="dt-data-model-instance">XDM instance</termref> from an XML document that is
                    merely well-formed or is governed by a DTD.</p>
            </item>
            <item>
                <p>
                    <emph>Support for normative construction from a PSVI.</emph> A conforming
                    implementation <termref def="may">MAY</termref> choose to claim conformance to
                        <xspecref spec="DM" ref="const-psvi"/>, which defines a
                    normative way to construct an <termref def="dt-data-model-instance">XDM instance</termref> from an XML document that is
                    governed by a W3C XML Schema.</p>
            </item>
            <item>
                <p>
                    <emph>Support for XML 1.0 and XML 1.1.</emph> The <bibref ref="xpath-datamodel-11"/>
                    supports either <bibref ref="XML"/> or <bibref ref="XML1.1"/>. In XQuery, the
                    choice of which XML version to support is <termref def="dt-implementation-defined">implementation-defined</termref>.</p>
            <p>At the time of writing there is no published version of XML Schema that references the XML 1.1 specifications. This means that datatypes such as <code>xs:NCName</code> and <code>xs:ID</code> are constrained by the XML 1.0 rules. It is recommended that an XQuery 1.0 processor should implement the rules defined by later versions of XML Schema as they become available.</p>
            <note>
              <p>For suggestions on processing XML 1.1 documents, see <bibref ref="xml11schema10"/>.</p>
            </note>
          </item>
          <item>
            <p>
              <emph>Ranges of data values.</emph> In XQuery, the following limits are
<termref def="dt-implementation-defined">implementation-defined</termref>:</p>
            <olist>
              <item>
                <p>For the <code>xs:decimal</code> type, the maximum number of decimal digits 
(<code>totalDigits</code> facet) (must be at least 18).</p>
              </item>
              <item>
                <p>For the types <code>xs:date</code>, <code>xs:time</code>, <code>xs:dateTime</code>, <code>xs:gYear</code>, 
and <code>xs:gYearMonth</code>: the maximum value of the year component and the maximum number of fractional second digits (must be at least 3).</p>
              </item>
              <item>
                <p>For the <code>xs:duration type</code>: the maximum absolute values of the 
years, months, days, hours, minutes, and seconds components.</p>
              </item>
              <item>
                <p>For the <code>xs:yearMonthDuration</code> type: the maximum absolute value,
expressed as an integer number of months.</p>
              </item>
              <item>
                <p>For the <code>xs:dayTimeDuration</code> type: the maximum absolute value,
expressed as a decimal number of seconds.</p>
              </item>
              <item>
                <p>For the types <code>xs:string</code>, <code>xs:hexBinary</code>, <code>xs:base64Binary</code>, <code>xs:QName</code>, 
<code>xs:anyURI</code>, <code>xs:NOTATION</code>, and types derived from them: limitations (if any)
imposed by the implementation on lengths of values.</p>
              </item>
            </olist>
            <p>The limits listed above
need not be fixed, but may depend on environmental factors such as 
system resources. For example, the length of a value of type <code>xs:string</code> may be limited by available memory.</p>
          </item>
        </olist>
    </div2>
    <div2 id="id-syntax-extensions" role="xquery" diff="add" at="XQ.E22">
	<head>Syntax Extensions</head>
<p>Any syntactic extensions to XQuery are <termref def="dt-implementation-defined">implementation-defined</termref>. The effect of syntactic extensions, including their
error behavior, is <termref def="dt-implementation-defined">implementation-defined</termref>. Syntactic extensions may be used without restriction to modify the semantics of a XQuery expression.</p>
      
    </div2>
</div1>
</body>
<back id="id-appendices">

<div1 id="nt-bnf">
  <head>XQuery 1.1 Grammar</head>
  <div2 id="id-grammar">
    <head>EBNF</head>
    <p>The grammar of XQuery 1.1 uses the same simple Extended
    Backus-Naur Form (EBNF) notation as 
    <bibref ref="XML"/> with the following minor differences.</p>
    <ulist>
      <item>
        <p>All named symbols have a name that begins with an
        uppercase letter.</p>
      </item>
      <item>
        <p>It adds a notation for referring to productions in
        external specs.</p>
      </item>
      <item>
        <p>Comments or extra-grammatical constraints on grammar
        productions are between '/*' and '*/' symbols.</p>
        <ulist>
          <item>
            <p>A 'xgc:' prefix is an extra-grammatical constraint,
            the details of which are explained in 
            <specref ref="extra-grammatical-constraints"/>
                </p>
          </item>
          <item>
            <p>A 'ws:' prefix explains the whitespace rules for the
            production, the details of which are explained in 
            <specref ref="whitespace-rules"/>
                </p>
          </item>
          <item>
            <p>A 'gn:' prefix means a 'Grammar Note', and is meant
            as a clarification for parsing rules, and is explained
            in 
            <specref ref="notes-on-parsing"/>. These notes are not
            normative.</p>
          </item>
        </ulist>
      </item>
    </ulist>
    <p>The terminal symbols for this grammar include the quoted
    strings used in the production rules below, and the terminal
    symbols defined in section 
    <specref ref="terminal-symbols"/>.</p>
    <p>The EBNF notation is described in more detail in 
    <specref ref="EBNFNotation"/>.</p>
    <p>To increase readability, the EBNF in the main body of this
    document omits some of these notational features. This appendix
    is the normative version of the EBNF.</p>
    <scrap id="BNF-Grammar" role="non-terminal-structure-expand" headstyle="show">
      <head/>
      <prod num="1" id="prod-xquery11-Module">
            <lhs>Module</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-VersionDecl" xlink:type="simple">VersionDecl</nt>?  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-LibraryModule" xlink:type="simple">LibraryModule</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-MainModule" xlink:type="simple">MainModule</nt>)</rhs>
          </prod>
          <prod num="2" id="prod-xquery11-VersionDecl">
            <lhs>VersionDecl</lhs>
            <rhs>"xquery"  (("encoding"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-StringLiteral" xlink:type="simple">StringLiteral</nt>)  |  ("version"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-StringLiteral" xlink:type="simple">StringLiteral</nt>  ("encoding"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-StringLiteral" xlink:type="simple">StringLiteral</nt>)?))  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Separator" xlink:type="simple">Separator</nt>
            </rhs>
          </prod>
          <prod num="3" id="prod-xquery11-MainModule">
            <lhs>MainModule</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Prolog" xlink:type="simple">Prolog</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-QueryBody" xlink:type="simple">QueryBody</nt>
            </rhs>
          </prod>
          <prod num="4" id="prod-xquery11-LibraryModule">
            <lhs>LibraryModule</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ModuleDecl" xlink:type="simple">ModuleDecl</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Prolog" xlink:type="simple">Prolog</nt>
            </rhs>
          </prod>
          <prod num="5" id="prod-xquery11-ModuleDecl">
            <lhs>ModuleDecl</lhs>
            <rhs>"module"  "namespace"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-NCName" xlink:type="simple">NCName</nt>  "="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-URILiteral" xlink:type="simple">URILiteral</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Separator" xlink:type="simple">Separator</nt>
            </rhs>
          </prod>
          <prod num="6" id="prod-xquery11-Prolog">
            <lhs>Prolog</lhs>
            <rhs>((<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-DefaultNamespaceDecl" xlink:type="simple">DefaultNamespaceDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Setter" xlink:type="simple">Setter</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-NamespaceDecl" xlink:type="simple">NamespaceDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Import" xlink:type="simple">Import</nt>)  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Separator" xlink:type="simple">Separator</nt>)*  ((<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ContextItemDecl" xlink:type="simple">ContextItemDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-AnnotatedDecl" xlink:type="simple">AnnotatedDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-OptionDecl" xlink:type="simple">OptionDecl</nt>)  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Separator" xlink:type="simple">Separator</nt>)*</rhs>
          </prod>
          <prod num="7" id="prod-xquery11-Separator">
            <lhs>Separator</lhs>
            <rhs>";"</rhs>
          </prod>
          <prod num="8" id="prod-xquery11-Setter">
            <lhs>Setter</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-BoundarySpaceDecl" xlink:type="simple">BoundarySpaceDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-DefaultCollationDecl" xlink:type="simple">DefaultCollationDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-BaseURIDecl" xlink:type="simple">BaseURIDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ConstructionDecl" xlink:type="simple">ConstructionDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-OrderingModeDecl" xlink:type="simple">OrderingModeDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-EmptyOrderDecl" xlink:type="simple">EmptyOrderDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-CopyNamespacesDecl" xlink:type="simple">CopyNamespacesDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-DecimalFormatDecl" xlink:type="simple">DecimalFormatDecl</nt>
            </rhs>
          </prod>
          <prod num="9" id="prod-xquery11-BoundarySpaceDecl">
            <lhs>BoundarySpaceDecl</lhs>
            <rhs>"declare"  "boundary-space"  ("preserve"  |  "strip")</rhs>
          </prod>
          <prod num="10" id="prod-xquery11-DefaultCollationDecl">
            <lhs>DefaultCollationDecl</lhs>
            <rhs>"declare"  "default"  "collation"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-URILiteral" xlink:type="simple">URILiteral</nt>
            </rhs>
          </prod>
          <prod num="11" id="prod-xquery11-BaseURIDecl">
            <lhs>BaseURIDecl</lhs>
            <rhs>"declare"  "base-uri"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-URILiteral" xlink:type="simple">URILiteral</nt>
            </rhs>
          </prod>
          <prod num="12" id="prod-xquery11-ConstructionDecl">
            <lhs>ConstructionDecl</lhs>
            <rhs>"declare"  "construction"  ("strip"  |  "preserve")</rhs>
          </prod>
          <prod num="13" id="prod-xquery11-OrderingModeDecl">
            <lhs>OrderingModeDecl</lhs>
            <rhs>"declare"  "ordering"  ("ordered"  |  "unordered")</rhs>
          </prod>
          <prod num="14" id="prod-xquery11-EmptyOrderDecl">
            <lhs>EmptyOrderDecl</lhs>
            <rhs>"declare"  "default"  "order"  "empty"  ("greatest"  |  "least")</rhs>
          </prod>
          <prod num="15" id="prod-xquery11-CopyNamespacesDecl">
            <lhs>CopyNamespacesDecl</lhs>
            <rhs>"declare"  "copy-namespaces"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-PreserveMode" xlink:type="simple">PreserveMode</nt>  ","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-InheritMode" xlink:type="simple">InheritMode</nt>
            </rhs>
          </prod>
          <prod num="16" id="prod-xquery11-PreserveMode">
            <lhs>PreserveMode</lhs>
            <rhs>"preserve"  |  "no-preserve"</rhs>
          </prod>
          <prod num="17" id="prod-xquery11-InheritMode">
            <lhs>InheritMode</lhs>
            <rhs>"inherit"  |  "no-inherit"</rhs>
          </prod>
          <prod num="18" id="prod-xquery11-DecimalFormatDecl">
            <lhs>DecimalFormatDecl</lhs>
            <rhs>"declare"  (("decimal-format"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-EQName" xlink:type="simple">EQName</nt>)  |  ("default"  "decimal-format"))  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-DFPropertyName" xlink:type="simple">DFPropertyName</nt>  "="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-StringLiteral" xlink:type="simple">StringLiteral</nt>)*</rhs>
          </prod>
          <prod num="19" id="prod-xquery11-DFPropertyName">
            <lhs>DFPropertyName</lhs>
            <rhs>"decimal-separator"  |  "grouping-separator"  |  "infinity"  |  "minus-sign"  |  "NaN"  |  "percent"  |  "per-mille"  |  "zero-digit"  |  "digit"  |  "pattern-separator"</rhs>
          </prod>
          <prod num="20" id="prod-xquery11-Import">
            <lhs>Import</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-SchemaImport" xlink:type="simple">SchemaImport</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ModuleImport" xlink:type="simple">ModuleImport</nt>
            </rhs>
          </prod>
          <prod num="21" id="prod-xquery11-SchemaImport">
            <lhs>SchemaImport</lhs>
            <rhs>"import"  "schema"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-SchemaPrefix" xlink:type="simple">SchemaPrefix</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-URILiteral" xlink:type="simple">URILiteral</nt>  ("at"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-URILiteral" xlink:type="simple">URILiteral</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-URILiteral" xlink:type="simple">URILiteral</nt>)*)?</rhs>
          </prod>
          <prod num="22" id="prod-xquery11-SchemaPrefix">
            <lhs>SchemaPrefix</lhs>
            <rhs>("namespace"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-NCName" xlink:type="simple">NCName</nt>  "=")  |  ("default"  "element"  "namespace")</rhs>
          </prod>
          <prod num="23" id="prod-xquery11-ModuleImport">
            <lhs>ModuleImport</lhs>
            <rhs>"import"  "module"  ("namespace"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-NCName" xlink:type="simple">NCName</nt>  "=")?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-URILiteral" xlink:type="simple">URILiteral</nt>  ("at"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-URILiteral" xlink:type="simple">URILiteral</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-URILiteral" xlink:type="simple">URILiteral</nt>)*)?</rhs>
          </prod>
          <prod num="24" id="prod-xquery11-NamespaceDecl">
            <lhs>NamespaceDecl</lhs>
            <rhs>"declare"  "namespace"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-NCName" xlink:type="simple">NCName</nt>  "="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-URILiteral" xlink:type="simple">URILiteral</nt>
            </rhs>
          </prod>
          <prod num="25" id="prod-xquery11-DefaultNamespaceDecl">
            <lhs>DefaultNamespaceDecl</lhs>
            <rhs>"declare"  "default"  ("element"  |  "function")  "namespace"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-URILiteral" xlink:type="simple">URILiteral</nt>
            </rhs>
          </prod>
          <prod num="26" id="prod-xquery11-AnnotatedDecl">
            <lhs>AnnotatedDecl</lhs>
            <rhs>"declare"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Annotation" xlink:type="simple">Annotation</nt>*  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-VarDecl" xlink:type="simple">VarDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-FunctionDecl" xlink:type="simple">FunctionDecl</nt>)</rhs>
          </prod>
          <prod num="27" id="prod-xquery11-Annotation">
            <lhs>Annotation</lhs>
            <rhs>"%"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-EQName" xlink:type="simple">EQName</nt>  ("("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Literal" xlink:type="simple">Literal</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Literal" xlink:type="simple">Literal</nt>)*  ")")?</rhs>
          </prod>
          <prod num="28" id="prod-xquery11-VarDecl">
            <lhs>VarDecl</lhs>
            <rhs>"variable"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-VarName" xlink:type="simple">VarName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  ((":="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-VarValue" xlink:type="simple">VarValue</nt>)  |  ("external"  (":="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-VarDefaultValue" xlink:type="simple">VarDefaultValue</nt>)?))</rhs>
          </prod>
          <prod num="29" id="prod-xquery11-VarValue">
            <lhs>VarValue</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>
            </rhs>
          </prod>
          <prod num="30" id="prod-xquery11-VarDefaultValue">
            <lhs>VarDefaultValue</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>
            </rhs>
          </prod>
          <prod num="31" id="prod-xquery11-ContextItemDecl">
            <lhs>ContextItemDecl</lhs>
            <rhs>"declare"  "context"  "item"  ("as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ItemType" xlink:type="simple">ItemType</nt>)?  ((":="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-VarValue" xlink:type="simple">VarValue</nt>)  |  ("external"  (":="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-VarDefaultValue" xlink:type="simple">VarDefaultValue</nt>)?))</rhs>
          </prod>
          <prod num="32" id="prod-xquery11-FunctionDecl">
            <lhs>FunctionDecl</lhs>
            <rhs>"function"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-EQName" xlink:type="simple">EQName</nt>  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ParamList" xlink:type="simple">ParamList</nt>?  ")"  ("as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-SequenceType" xlink:type="simple">SequenceType</nt>)?  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-FunctionBody" xlink:type="simple">FunctionBody</nt>  |  "external")</rhs>
            <com>
              <phrase>
                <xspecref ref="parse-note-reserved-function-names" spec="XQ">xgc: reserved-function-names</xspecref>
              </phrase>
            </com>
          </prod>
          <prod num="33" id="prod-xquery11-ParamList">
            <lhs>ParamList</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Param" xlink:type="simple">Param</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Param" xlink:type="simple">Param</nt>)*</rhs>
          </prod>
          <prod num="34" id="prod-xquery11-Param">
            <lhs>Param</lhs>
            <rhs>"$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-EQName" xlink:type="simple">EQName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?</rhs>
          </prod>
          <prod num="35" id="prod-xquery11-FunctionBody">
            <lhs>FunctionBody</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-EnclosedExpr" xlink:type="simple">EnclosedExpr</nt>
            </rhs>
          </prod>
          <prod num="36" id="prod-xquery11-EnclosedExpr">
            <lhs>EnclosedExpr</lhs>
            <rhs>"{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Expr" xlink:type="simple">Expr</nt>  "}"</rhs>
          </prod>
          <prod num="37" id="prod-xquery11-OptionDecl">
            <lhs>OptionDecl</lhs>
            <rhs>"declare"  "option"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-EQName" xlink:type="simple">EQName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-StringLiteral" xlink:type="simple">StringLiteral</nt>
            </rhs>
          </prod>
          <prod num="38" id="prod-xquery11-QueryBody">
            <lhs>QueryBody</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Expr" xlink:type="simple">Expr</nt>
            </rhs>
          </prod>
          <prod num="39" id="prod-xquery11-Expr">
            <lhs>Expr</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>)*</rhs>
          </prod>
          <prod num="40" id="prod-xquery11-ExprSingle">
            <lhs>ExprSingle</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-FLWORExpr" xlink:type="simple">FLWORExpr</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-QuantifiedExpr" xlink:type="simple">QuantifiedExpr</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-SwitchExpr" xlink:type="simple">SwitchExpr</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-TypeswitchExpr" xlink:type="simple">TypeswitchExpr</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-IfExpr" xlink:type="simple">IfExpr</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-TryCatchExpr" xlink:type="simple">TryCatchExpr</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-OrExpr" xlink:type="simple">OrExpr</nt>
            </rhs>
          </prod>
          <prod num="41" id="prod-xquery11-FLWORExpr">
            <lhs>FLWORExpr</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-InitialClause" xlink:type="simple">InitialClause</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-IntermediateClause" xlink:type="simple">IntermediateClause</nt>*  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ReturnClause" xlink:type="simple">ReturnClause</nt>
            </rhs>
          </prod>
          <prod num="42" id="prod-xquery11-InitialClause">
            <lhs>InitialClause</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ForClause" xlink:type="simple">ForClause</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-LetClause" xlink:type="simple">LetClause</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-WindowClause" xlink:type="simple">WindowClause</nt>
            </rhs>
          </prod>
          <prod num="43" id="prod-xquery11-IntermediateClause">
            <lhs>IntermediateClause</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-InitialClause" xlink:type="simple">InitialClause</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-WhereClause" xlink:type="simple">WhereClause</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-GroupByClause" xlink:type="simple">GroupByClause</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-OrderByClause" xlink:type="simple">OrderByClause</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-CountClause" xlink:type="simple">CountClause</nt>
            </rhs>
          </prod>
          <prod num="44" id="prod-xquery11-ForClause">
            <lhs>ForClause</lhs>
            <rhs>"for"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ForBinding" xlink:type="simple">ForBinding</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ForBinding" xlink:type="simple">ForBinding</nt>)*</rhs>
          </prod>
          <prod num="45" id="prod-xquery11-ForBinding">
            <lhs>ForBinding</lhs>
            <rhs>"$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-VarName" xlink:type="simple">VarName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-AllowingEmpty" xlink:type="simple">AllowingEmpty</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-PositionalVar" xlink:type="simple">PositionalVar</nt>?  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>
            </rhs>
          </prod>
          <prod num="46" id="prod-xquery11-AllowingEmpty">
            <lhs>AllowingEmpty</lhs>
            <rhs>"allowing"  "empty"</rhs>
          </prod>
          <prod num="47" id="prod-xquery11-PositionalVar">
            <lhs>PositionalVar</lhs>
            <rhs>"at"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-VarName" xlink:type="simple">VarName</nt>
            </rhs>
          </prod>
          <prod num="48" id="prod-xquery11-LetClause">
            <lhs>LetClause</lhs>
            <rhs>"let"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-LetBinding" xlink:type="simple">LetBinding</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-LetBinding" xlink:type="simple">LetBinding</nt>)*</rhs>
          </prod>
          <prod num="49" id="prod-xquery11-LetBinding">
            <lhs>LetBinding</lhs>
            <rhs>"$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-VarName" xlink:type="simple">VarName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  ":="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>
            </rhs>
          </prod>
          <prod num="50" id="prod-xquery11-WindowClause">
            <lhs>WindowClause</lhs>
            <rhs>"for"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-TumblingWindowClause" xlink:type="simple">TumblingWindowClause</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-SlidingWindowClause" xlink:type="simple">SlidingWindowClause</nt>)</rhs>
          </prod>
          <prod num="51" id="prod-xquery11-TumblingWindowClause">
            <lhs>TumblingWindowClause</lhs>
            <rhs>"tumbling"  "window"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-VarName" xlink:type="simple">VarName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-WindowStartCondition" xlink:type="simple">WindowStartCondition</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-WindowEndCondition" xlink:type="simple">WindowEndCondition</nt>?</rhs>
          </prod>
          <prod num="52" id="prod-xquery11-SlidingWindowClause">
            <lhs>SlidingWindowClause</lhs>
            <rhs>"sliding"  "window"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-VarName" xlink:type="simple">VarName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-WindowStartCondition" xlink:type="simple">WindowStartCondition</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-WindowEndCondition" xlink:type="simple">WindowEndCondition</nt>
            </rhs>
          </prod>
          <prod num="53" id="prod-xquery11-WindowStartCondition">
            <lhs>WindowStartCondition</lhs>
            <rhs>"start"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-WindowVars" xlink:type="simple">WindowVars</nt>  "when"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>
            </rhs>
          </prod>
          <prod num="54" id="prod-xquery11-WindowEndCondition">
            <lhs>WindowEndCondition</lhs>
            <rhs>"only"?  "end"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-WindowVars" xlink:type="simple">WindowVars</nt>  "when"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>
            </rhs>
          </prod>
          <prod num="55" id="prod-xquery11-WindowVars">
            <lhs>WindowVars</lhs>
            <rhs>("$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-CurrentItem" xlink:type="simple">CurrentItem</nt>)?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-PositionalVar" xlink:type="simple">PositionalVar</nt>?  ("previous"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-PreviousItem" xlink:type="simple">PreviousItem</nt>)?  ("next"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-NextItem" xlink:type="simple">NextItem</nt>)?</rhs>
          </prod>
          <prod num="56" id="prod-xquery11-CurrentItem">
            <lhs>CurrentItem</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-EQName" xlink:type="simple">EQName</nt>
            </rhs>
          </prod>
          <prod num="57" id="prod-xquery11-PreviousItem">
            <lhs>PreviousItem</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-EQName" xlink:type="simple">EQName</nt>
            </rhs>
          </prod>
          <prod num="58" id="prod-xquery11-NextItem">
            <lhs>NextItem</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-EQName" xlink:type="simple">EQName</nt>
            </rhs>
          </prod>
          <prod num="59" id="prod-xquery11-CountClause">
            <lhs>CountClause</lhs>
            <rhs>"count"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-VarName" xlink:type="simple">VarName</nt>
            </rhs>
          </prod>
          <prod num="60" id="prod-xquery11-WhereClause">
            <lhs>WhereClause</lhs>
            <rhs>"where"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>
            </rhs>
          </prod>
          <prod num="61" id="prod-xquery11-GroupByClause">
            <lhs>GroupByClause</lhs>
            <rhs>"group"  "by"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-GroupingSpecList" xlink:type="simple">GroupingSpecList</nt>
            </rhs>
          </prod>
          <prod num="62" id="prod-xquery11-GroupingSpecList">
            <lhs>GroupingSpecList</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-GroupingSpec" xlink:type="simple">GroupingSpec</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-GroupingSpec" xlink:type="simple">GroupingSpec</nt>)*</rhs>
          </prod>
          <prod num="63" id="prod-xquery11-GroupingSpec">
            <lhs>GroupingSpec</lhs>
            <rhs>"$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-VarName" xlink:type="simple">VarName</nt>  ("collation"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-URILiteral" xlink:type="simple">URILiteral</nt>)?</rhs>
          </prod>
          <prod num="64" id="prod-xquery11-OrderByClause">
            <lhs>OrderByClause</lhs>
            <rhs>(("order"  "by")  |  ("stable"  "order"  "by"))  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-OrderSpecList" xlink:type="simple">OrderSpecList</nt>
            </rhs>
          </prod>
          <prod num="65" id="prod-xquery11-OrderSpecList">
            <lhs>OrderSpecList</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-OrderSpec" xlink:type="simple">OrderSpec</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-OrderSpec" xlink:type="simple">OrderSpec</nt>)*</rhs>
          </prod>
          <prod num="66" id="prod-xquery11-OrderSpec">
            <lhs>OrderSpec</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-OrderModifier" xlink:type="simple">OrderModifier</nt>
            </rhs>
          </prod>
          <prod num="67" id="prod-xquery11-OrderModifier">
            <lhs>OrderModifier</lhs>
            <rhs>("ascending"  |  "descending")?  ("empty"  ("greatest"  |  "least"))?  ("collation"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-URILiteral" xlink:type="simple">URILiteral</nt>)?</rhs>
          </prod>
          <prod num="68" id="prod-xquery11-ReturnClause">
            <lhs>ReturnClause</lhs>
            <rhs>"return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>
            </rhs>
          </prod>
          <prod num="69" id="prod-xquery11-QuantifiedExpr">
            <lhs>QuantifiedExpr</lhs>
            <rhs>("some"  |  "every")  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-VarName" xlink:type="simple">VarName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-VarName" xlink:type="simple">VarName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>)*  "satisfies"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>
            </rhs>
          </prod>
          <prod num="70" id="prod-xquery11-SwitchExpr">
            <lhs>SwitchExpr</lhs>
            <rhs>"switch"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Expr" xlink:type="simple">Expr</nt>  ")"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-SwitchCaseClause" xlink:type="simple">SwitchCaseClause</nt>+  "default"  "return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>
            </rhs>
          </prod>
          <prod num="71" id="prod-xquery11-SwitchCaseClause">
            <lhs>SwitchCaseClause</lhs>
            <rhs>("case"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-SwitchCaseOperand" xlink:type="simple">SwitchCaseOperand</nt>)+  "return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>
            </rhs>
          </prod>
          <prod num="72" id="prod-xquery11-SwitchCaseOperand">
            <lhs>SwitchCaseOperand</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>
            </rhs>
          </prod>
          <prod num="73" id="prod-xquery11-TypeswitchExpr">
            <lhs>TypeswitchExpr</lhs>
            <rhs>"typeswitch"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Expr" xlink:type="simple">Expr</nt>  ")"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-CaseClause" xlink:type="simple">CaseClause</nt>+  "default"  ("$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-VarName" xlink:type="simple">VarName</nt>)?  "return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>
            </rhs>
          </prod>
          <prod num="74" id="prod-xquery11-CaseClause">
            <lhs>CaseClause</lhs>
            <rhs>"case"  ("$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-VarName" xlink:type="simple">VarName</nt>  "as")?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-SequenceTypeUnion" xlink:type="simple">SequenceTypeUnion</nt>  "return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>
            </rhs>
          </prod>
          <prod num="75" id="prod-xquery11-SequenceTypeUnion">
            <lhs>SequenceTypeUnion</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-SequenceType" xlink:type="simple">SequenceType</nt>  ("|"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-SequenceType" xlink:type="simple">SequenceType</nt>)*</rhs>
          </prod>
          <prod num="76" id="prod-xquery11-IfExpr">
            <lhs>IfExpr</lhs>
            <rhs>"if"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Expr" xlink:type="simple">Expr</nt>  ")"  "then"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>  "else"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>
            </rhs>
          </prod>
          <prod num="77" id="prod-xquery11-TryCatchExpr">
            <lhs>TryCatchExpr</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-TryClause" xlink:type="simple">TryClause</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-CatchClause" xlink:type="simple">CatchClause</nt>+</rhs>
          </prod>
          <prod num="78" id="prod-xquery11-TryClause">
            <lhs>TryClause</lhs>
            <rhs>"try"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-TryTargetExpr" xlink:type="simple">TryTargetExpr</nt>  "}"</rhs>
          </prod>
          <prod num="79" id="prod-xquery11-TryTargetExpr">
            <lhs>TryTargetExpr</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Expr" xlink:type="simple">Expr</nt>
            </rhs>
          </prod>
          <prod num="80" id="prod-xquery11-CatchClause">
            <lhs>CatchClause</lhs>
            <rhs>"catch"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-CatchErrorList" xlink:type="simple">CatchErrorList</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-CatchVars" xlink:type="simple">CatchVars</nt>?  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Expr" xlink:type="simple">Expr</nt>  "}"</rhs>
          </prod>
          <prod num="81" id="prod-xquery11-CatchErrorList">
            <lhs>CatchErrorList</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-NameTest" xlink:type="simple">NameTest</nt>  ("|"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-NameTest" xlink:type="simple">NameTest</nt>)*</rhs>
          </prod>
          <prod num="82" id="prod-xquery11-CatchVars">
            <lhs>CatchVars</lhs>
            <rhs>"("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-CatchErrorCode" xlink:type="simple">CatchErrorCode</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-CatchErrorDesc" xlink:type="simple">CatchErrorDesc</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-CatchErrorVal" xlink:type="simple">CatchErrorVal</nt>)?)?  ")"</rhs>
          </prod>
          <prod num="83" id="prod-xquery11-CatchErrorCode">
            <lhs>CatchErrorCode</lhs>
            <rhs>"$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-VarName" xlink:type="simple">VarName</nt>
            </rhs>
          </prod>
          <prod num="84" id="prod-xquery11-CatchErrorDesc">
            <lhs>CatchErrorDesc</lhs>
            <rhs>"$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-VarName" xlink:type="simple">VarName</nt>
            </rhs>
          </prod>
          <prod num="85" id="prod-xquery11-CatchErrorVal">
            <lhs>CatchErrorVal</lhs>
            <rhs>"$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-VarName" xlink:type="simple">VarName</nt>
            </rhs>
          </prod>
          <prod num="86" id="prod-xquery11-OrExpr">
            <lhs>OrExpr</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-AndExpr" xlink:type="simple">AndExpr</nt> ( "or"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-AndExpr" xlink:type="simple">AndExpr</nt> )*</rhs>
          </prod>
          <prod num="87" id="prod-xquery11-AndExpr">
            <lhs>AndExpr</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ComparisonExpr" xlink:type="simple">ComparisonExpr</nt> ( "and"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ComparisonExpr" xlink:type="simple">ComparisonExpr</nt> )*</rhs>
          </prod>
          <prod num="88" id="prod-xquery11-ComparisonExpr">
            <lhs>ComparisonExpr</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-RangeExpr" xlink:type="simple">RangeExpr</nt> ( (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ValueComp" xlink:type="simple">ValueComp</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-GeneralComp" xlink:type="simple">GeneralComp</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-NodeComp" xlink:type="simple">NodeComp</nt>)  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-RangeExpr" xlink:type="simple">RangeExpr</nt> )?</rhs>
          </prod>
          <prod num="89" id="prod-xquery11-RangeExpr">
            <lhs>RangeExpr</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-AdditiveExpr" xlink:type="simple">AdditiveExpr</nt> ( "to"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-AdditiveExpr" xlink:type="simple">AdditiveExpr</nt> )?</rhs>
          </prod>
          <prod num="90" id="prod-xquery11-AdditiveExpr">
            <lhs>AdditiveExpr</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-MultiplicativeExpr" xlink:type="simple">MultiplicativeExpr</nt> ( ("+"  |  "-")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-MultiplicativeExpr" xlink:type="simple">MultiplicativeExpr</nt> )*</rhs>
          </prod>
          <prod num="91" id="prod-xquery11-MultiplicativeExpr">
            <lhs>MultiplicativeExpr</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-UnionExpr" xlink:type="simple">UnionExpr</nt> ( ("*"  |  "div"  |  "idiv"  |  "mod")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-UnionExpr" xlink:type="simple">UnionExpr</nt> )*</rhs>
          </prod>
          <prod num="92" id="prod-xquery11-UnionExpr">
            <lhs>UnionExpr</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-IntersectExceptExpr" xlink:type="simple">IntersectExceptExpr</nt> ( ("union"  |  "|")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-IntersectExceptExpr" xlink:type="simple">IntersectExceptExpr</nt> )*</rhs>
          </prod>
          <prod num="93" id="prod-xquery11-IntersectExceptExpr">
            <lhs>IntersectExceptExpr</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-InstanceofExpr" xlink:type="simple">InstanceofExpr</nt> ( ("intersect"  |  "except")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-InstanceofExpr" xlink:type="simple">InstanceofExpr</nt> )*</rhs>
          </prod>
          <prod num="94" id="prod-xquery11-InstanceofExpr">
            <lhs>InstanceofExpr</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-TreatExpr" xlink:type="simple">TreatExpr</nt> ( "instance"  "of"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-SequenceType" xlink:type="simple">SequenceType</nt> )?</rhs>
          </prod>
          <prod num="95" id="prod-xquery11-TreatExpr">
            <lhs>TreatExpr</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-CastableExpr" xlink:type="simple">CastableExpr</nt> ( "treat"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-SequenceType" xlink:type="simple">SequenceType</nt> )?</rhs>
          </prod>
          <prod num="96" id="prod-xquery11-CastableExpr">
            <lhs>CastableExpr</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-CastExpr" xlink:type="simple">CastExpr</nt> ( "castable"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-SingleType" xlink:type="simple">SingleType</nt> )?</rhs>
          </prod>
          <prod num="97" id="prod-xquery11-CastExpr">
            <lhs>CastExpr</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-UnaryExpr" xlink:type="simple">UnaryExpr</nt> ( "cast"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-SingleType" xlink:type="simple">SingleType</nt> )?</rhs>
          </prod>
          <prod num="98" id="prod-xquery11-UnaryExpr">
            <lhs>UnaryExpr</lhs>
            <rhs>("-"  |  "+")* <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ValueExpr" xlink:type="simple">ValueExpr</nt>
            </rhs>
          </prod>
          <prod num="99" id="prod-xquery11-ValueExpr">
            <lhs>ValueExpr</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ValidateExpr" xlink:type="simple">ValidateExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-PathExpr" xlink:type="simple">PathExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ExtensionExpr" xlink:type="simple">ExtensionExpr</nt>
            </rhs>
          </prod>
          <prod num="100" id="prod-xquery11-GeneralComp">
            <lhs>GeneralComp</lhs>
            <rhs>"="  |  "!="  |  "&lt;"  |  "&lt;="  |  "&gt;"  |  "&gt;="</rhs>
          </prod>
          <prod num="101" id="prod-xquery11-ValueComp">
            <lhs>ValueComp</lhs>
            <rhs>"eq"  |  "ne"  |  "lt"  |  "le"  |  "gt"  |  "ge"</rhs>
          </prod>
          <prod num="102" id="prod-xquery11-NodeComp">
            <lhs>NodeComp</lhs>
            <rhs>"is"  |  "&lt;&lt;"  |  "&gt;&gt;"</rhs>
          </prod>
          <prod num="103" id="prod-xquery11-ValidateExpr">
            <lhs>ValidateExpr</lhs>
            <rhs>"validate"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ValidationMode" xlink:type="simple">ValidationMode</nt>  |  ("type"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-TypeName" xlink:type="simple">TypeName</nt>))?  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Expr" xlink:type="simple">Expr</nt>  "}"</rhs>
          </prod>
          <prod num="104" id="prod-xquery11-ValidationMode">
            <lhs>ValidationMode</lhs>
            <rhs>"lax"  |  "strict"</rhs>
          </prod>
          <prod num="105" id="prod-xquery11-ExtensionExpr">
            <lhs>ExtensionExpr</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Pragma" xlink:type="simple">Pragma</nt>+  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Expr" xlink:type="simple">Expr</nt>?  "}"</rhs>
          </prod>
          <prod num="106" id="prod-xquery11-Pragma">
            <lhs>Pragma</lhs>
            <rhs>"(#"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-S" xlink:type="simple">S</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-EQName" xlink:type="simple">EQName</nt>  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-S" xlink:type="simple">S</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-PragmaContents" xlink:type="simple">PragmaContents</nt>)?  "#)"</rhs>
            <com>
              <phrase>
                <xspecref ref="ws-explicit" spec="XQ">ws: explicit</xspecref>
              </phrase>
            </com>
          </prod>
          <prod num="107" id="prod-xquery11-PragmaContents">
            <lhs>PragmaContents</lhs>
            <rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Char" xlink:type="simple">Char</nt>* - (Char* '#)' Char*))</rhs>
          </prod>
          <prod num="108" id="prod-xquery11-PathExpr">
            <lhs>PathExpr</lhs>
            <rhs>("/"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt>?)<br/>|  ("//"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt>)<br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt>
            </rhs>
            <com>
              <phrase>
                <xspecref ref="parse-note-leading-lone-slash" spec="XQ">xgc: leading-lone-slash</xspecref>
              </phrase>
            </com>
          </prod>
          <prod num="109" id="prod-xquery11-RelativePathExpr">
            <lhs>RelativePathExpr</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-StepExpr" xlink:type="simple">StepExpr</nt>  (("/"  |  "//")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-StepExpr" xlink:type="simple">StepExpr</nt>)*</rhs>
          </prod>
          <prod num="110" id="prod-xquery11-StepExpr">
            <lhs>StepExpr</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-PostfixExpr" xlink:type="simple">PostfixExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-AxisStep" xlink:type="simple">AxisStep</nt>
            </rhs>
          </prod>
          <prod num="111" id="prod-xquery11-AxisStep">
            <lhs>AxisStep</lhs>
            <rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ReverseStep" xlink:type="simple">ReverseStep</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ForwardStep" xlink:type="simple">ForwardStep</nt>)  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-PredicateList" xlink:type="simple">PredicateList</nt>
            </rhs>
          </prod>
          <prod num="112" id="prod-xquery11-ForwardStep">
            <lhs>ForwardStep</lhs>
            <rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ForwardAxis" xlink:type="simple">ForwardAxis</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-NodeTest" xlink:type="simple">NodeTest</nt>)  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-AbbrevForwardStep" xlink:type="simple">AbbrevForwardStep</nt>
            </rhs>
          </prod>
          <prod num="113" id="prod-xquery11-ForwardAxis">
            <lhs>ForwardAxis</lhs>
            <rhs>("child"  "::")<br/>|  ("descendant"  "::")<br/>|  ("attribute"  "::")<br/>|  ("self"  "::")<br/>|  ("descendant-or-self"  "::")<br/>|  ("following-sibling"  "::")<br/>|  ("following"  "::")</rhs>
          </prod>
          <prod num="114" id="prod-xquery11-AbbrevForwardStep">
            <lhs>AbbrevForwardStep</lhs>
            <rhs>"@"?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-NodeTest" xlink:type="simple">NodeTest</nt>
            </rhs>
          </prod>
          <prod num="115" id="prod-xquery11-ReverseStep">
            <lhs>ReverseStep</lhs>
            <rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ReverseAxis" xlink:type="simple">ReverseAxis</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-NodeTest" xlink:type="simple">NodeTest</nt>)  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-AbbrevReverseStep" xlink:type="simple">AbbrevReverseStep</nt>
            </rhs>
          </prod>
          <prod num="116" id="prod-xquery11-ReverseAxis">
            <lhs>ReverseAxis</lhs>
            <rhs>("parent"  "::")<br/>|  ("ancestor"  "::")<br/>|  ("preceding-sibling"  "::")<br/>|  ("preceding"  "::")<br/>|  ("ancestor-or-self"  "::")</rhs>
          </prod>
          <prod num="117" id="prod-xquery11-AbbrevReverseStep">
            <lhs>AbbrevReverseStep</lhs>
            <rhs>".."</rhs>
          </prod>
          <prod num="118" id="prod-xquery11-NodeTest">
            <lhs>NodeTest</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-KindTest" xlink:type="simple">KindTest</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-NameTest" xlink:type="simple">NameTest</nt>
            </rhs>
          </prod>
          <prod num="119" id="prod-xquery11-NameTest">
            <lhs>NameTest</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-EQName" xlink:type="simple">EQName</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Wildcard" xlink:type="simple">Wildcard</nt>
            </rhs>
          </prod>
          <prod num="120" id="prod-xquery11-Wildcard">
            <lhs>Wildcard</lhs>
            <rhs>"*"<br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-NCName" xlink:type="simple">NCName</nt>  ":"  "*")<br/>|  ("*"  ":"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-NCName" xlink:type="simple">NCName</nt>)</rhs>
            <com>
              <phrase>
                <xspecref ref="ws-explicit" spec="XQ">ws: explicit</xspecref>
              </phrase>
            </com>
          </prod>
          <prod num="121" id="prod-xquery11-PostfixExpr">
            <lhs>PostfixExpr</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-PrimaryExpr" xlink:type="simple">PrimaryExpr</nt>  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Predicate" xlink:type="simple">Predicate</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ArgumentList" xlink:type="simple">ArgumentList</nt>)*</rhs>
          </prod>
          <prod num="122" id="prod-xquery11-ArgumentList">
            <lhs>ArgumentList</lhs>
            <rhs>"("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Argument" xlink:type="simple">Argument</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Argument" xlink:type="simple">Argument</nt>)*)?  ")"</rhs>
          </prod>
          <prod num="123" id="prod-xquery11-PredicateList">
            <lhs>PredicateList</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Predicate" xlink:type="simple">Predicate</nt>*</rhs>
          </prod>
          <prod num="124" id="prod-xquery11-Predicate">
            <lhs>Predicate</lhs>
            <rhs>"["  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Expr" xlink:type="simple">Expr</nt>  "]"</rhs>
          </prod>
          <prod num="125" id="prod-xquery11-PrimaryExpr">
            <lhs>PrimaryExpr</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Literal" xlink:type="simple">Literal</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-VarRef" xlink:type="simple">VarRef</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ParenthesizedExpr" xlink:type="simple">ParenthesizedExpr</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ContextItemExpr" xlink:type="simple">ContextItemExpr</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-FunctionCall" xlink:type="simple">FunctionCall</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-OrderedExpr" xlink:type="simple">OrderedExpr</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-UnorderedExpr" xlink:type="simple">UnorderedExpr</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Constructor" xlink:type="simple">Constructor</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-FunctionItemExpr" xlink:type="simple">FunctionItemExpr</nt>
            </rhs>
          </prod>
          <prod num="126" id="prod-xquery11-Literal">
            <lhs>Literal</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-NumericLiteral" xlink:type="simple">NumericLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-StringLiteral" xlink:type="simple">StringLiteral</nt>
            </rhs>
          </prod>
          <prod num="127" id="prod-xquery11-NumericLiteral">
            <lhs>NumericLiteral</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-IntegerLiteral" xlink:type="simple">IntegerLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-DecimalLiteral" xlink:type="simple">DecimalLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-DoubleLiteral" xlink:type="simple">DoubleLiteral</nt>
            </rhs>
          </prod>
          <prod num="128" id="prod-xquery11-VarRef">
            <lhs>VarRef</lhs>
            <rhs>"$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-VarName" xlink:type="simple">VarName</nt>
            </rhs>
          </prod>
          <prod num="129" id="prod-xquery11-VarName">
            <lhs>VarName</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-EQName" xlink:type="simple">EQName</nt>
            </rhs>
          </prod>
          <prod num="130" id="prod-xquery11-ParenthesizedExpr">
            <lhs>ParenthesizedExpr</lhs>
            <rhs>"("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Expr" xlink:type="simple">Expr</nt>?  ")"</rhs>
          </prod>
          <prod num="131" id="prod-xquery11-ContextItemExpr">
            <lhs>ContextItemExpr</lhs>
            <rhs>"."</rhs>
          </prod>
          <prod num="132" id="prod-xquery11-OrderedExpr">
            <lhs>OrderedExpr</lhs>
            <rhs>"ordered"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Expr" xlink:type="simple">Expr</nt>  "}"</rhs>
          </prod>
          <prod num="133" id="prod-xquery11-UnorderedExpr">
            <lhs>UnorderedExpr</lhs>
            <rhs>"unordered"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Expr" xlink:type="simple">Expr</nt>  "}"</rhs>
          </prod>
          <prod num="134" id="prod-xquery11-FunctionCall">
            <lhs>FunctionCall</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-EQName" xlink:type="simple">EQName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ArgumentList" xlink:type="simple">ArgumentList</nt>
            </rhs>
            <com>
              <phrase>
                <xspecref ref="parse-note-reserved-function-names" spec="XQ">xgc: reserved-function-names</xspecref>
              </phrase>
            </com>
            <com>
              <phrase>
                <xspecref ref="parse-note-parens" spec="XQ">gn: parens</xspecref>
              </phrase>
            </com>
          </prod>
          <prod num="135" id="prod-xquery11-Argument">
            <lhs>Argument</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ExprSingle" xlink:type="simple">ExprSingle</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ArgumentPlaceholder" xlink:type="simple">ArgumentPlaceholder</nt>
            </rhs>
          </prod>
          <prod num="136" id="prod-xquery11-ArgumentPlaceholder">
            <lhs>ArgumentPlaceholder</lhs>
            <rhs>"?"</rhs>
          </prod>
          <prod num="137" id="prod-xquery11-Constructor">
            <lhs>Constructor</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-DirectConstructor" xlink:type="simple">DirectConstructor</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ComputedConstructor" xlink:type="simple">ComputedConstructor</nt>
            </rhs>
          </prod>
          <prod num="138" id="prod-xquery11-DirectConstructor">
            <lhs>DirectConstructor</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-DirElemConstructor" xlink:type="simple">DirElemConstructor</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-DirCommentConstructor" xlink:type="simple">DirCommentConstructor</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-DirPIConstructor" xlink:type="simple">DirPIConstructor</nt>
            </rhs>
          </prod>
          <prod num="139" id="prod-xquery11-DirElemConstructor">
            <lhs>DirElemConstructor</lhs>
            <rhs>"&lt;"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-QName" xlink:type="simple">QName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-DirAttributeList" xlink:type="simple">DirAttributeList</nt>  ("/&gt;"  |  ("&gt;"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-DirElemContent" xlink:type="simple">DirElemContent</nt>*  "&lt;/"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-QName" xlink:type="simple">QName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-S" xlink:type="simple">S</nt>?  "&gt;"))</rhs>
            <com>
              <phrase>
                <xspecref ref="ws-explicit" spec="XQ">ws: explicit</xspecref>
              </phrase>
            </com>
          </prod>
          <prod num="140" id="prod-xquery11-DirAttributeList">
            <lhs>DirAttributeList</lhs>
            <rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-S" xlink:type="simple">S</nt>  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-QName" xlink:type="simple">QName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-S" xlink:type="simple">S</nt>?  "="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-S" xlink:type="simple">S</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-DirAttributeValue" xlink:type="simple">DirAttributeValue</nt>)?)*</rhs>
            <com>
              <phrase>
                <xspecref ref="ws-explicit" spec="XQ">ws: explicit</xspecref>
              </phrase>
            </com>
          </prod>
          <prod num="141" id="prod-xquery11-DirAttributeValue">
            <lhs>DirAttributeValue</lhs>
            <rhs>('"'  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-EscapeQuot" xlink:type="simple">EscapeQuot</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-QuotAttrValueContent" xlink:type="simple">QuotAttrValueContent</nt>)*  '"')<br/>|  ("'"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-EscapeApos" xlink:type="simple">EscapeApos</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-AposAttrValueContent" xlink:type="simple">AposAttrValueContent</nt>)*  "'")</rhs>
            <com>
              <phrase>
                <xspecref ref="ws-explicit" spec="XQ">ws: explicit</xspecref>
              </phrase>
            </com>
          </prod>
          <prod num="142" id="prod-xquery11-QuotAttrValueContent">
            <lhs>QuotAttrValueContent</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-QuotAttrContentChar" xlink:type="simple">QuotAttrContentChar</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-CommonContent" xlink:type="simple">CommonContent</nt>
            </rhs>
          </prod>
          <prod num="143" id="prod-xquery11-AposAttrValueContent">
            <lhs>AposAttrValueContent</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-AposAttrContentChar" xlink:type="simple">AposAttrContentChar</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-CommonContent" xlink:type="simple">CommonContent</nt>
            </rhs>
          </prod>
          <prod num="144" id="prod-xquery11-DirElemContent">
            <lhs>DirElemContent</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-DirectConstructor" xlink:type="simple">DirectConstructor</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-CDataSection" xlink:type="simple">CDataSection</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-CommonContent" xlink:type="simple">CommonContent</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ElementContentChar" xlink:type="simple">ElementContentChar</nt>
            </rhs>
          </prod>
          <prod num="145" id="prod-xquery11-CommonContent">
            <lhs>CommonContent</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-PredefinedEntityRef" xlink:type="simple">PredefinedEntityRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-CharRef" xlink:type="simple">CharRef</nt>  |  "{{"  |  "}}"  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-EnclosedExpr" xlink:type="simple">EnclosedExpr</nt>
            </rhs>
          </prod>
          <prod num="146" id="prod-xquery11-DirCommentConstructor">
            <lhs>DirCommentConstructor</lhs>
            <rhs>"&lt;!--"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-DirCommentContents" xlink:type="simple">DirCommentContents</nt>  "--&gt;"</rhs>
            <com>
              <phrase>
                <xspecref ref="ws-explicit" spec="XQ">ws: explicit</xspecref>
              </phrase>
            </com>
          </prod>
          <prod num="147" id="prod-xquery11-DirCommentContents">
            <lhs>DirCommentContents</lhs>
            <rhs>((<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Char" xlink:type="simple">Char</nt> - '-')  |  ('-'  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Char" xlink:type="simple">Char</nt> - '-')))*</rhs>
            <com>
              <phrase>
                <xspecref ref="ws-explicit" spec="XQ">ws: explicit</xspecref>
              </phrase>
            </com>
          </prod>
          <prod num="148" id="prod-xquery11-DirPIConstructor">
            <lhs>DirPIConstructor</lhs>
            <rhs>"&lt;?"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-PITarget" xlink:type="simple">PITarget</nt>  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-S" xlink:type="simple">S</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-DirPIContents" xlink:type="simple">DirPIContents</nt>)?  "?&gt;"</rhs>
            <com>
              <phrase>
                <xspecref ref="ws-explicit" spec="XQ">ws: explicit</xspecref>
              </phrase>
            </com>
          </prod>
          <prod num="149" id="prod-xquery11-DirPIContents">
            <lhs>DirPIContents</lhs>
            <rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Char" xlink:type="simple">Char</nt>* - (Char* '?&gt;' Char*))</rhs>
            <com>
              <phrase>
                <xspecref ref="ws-explicit" spec="XQ">ws: explicit</xspecref>
              </phrase>
            </com>
          </prod>
          <prod num="150" id="prod-xquery11-CDataSection">
            <lhs>CDataSection</lhs>
            <rhs>"&lt;![CDATA["  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-CDataSectionContents" xlink:type="simple">CDataSectionContents</nt>  "]]&gt;"</rhs>
            <com>
              <phrase>
                <xspecref ref="ws-explicit" spec="XQ">ws: explicit</xspecref>
              </phrase>
            </com>
          </prod>
          <prod num="151" id="prod-xquery11-CDataSectionContents">
            <lhs>CDataSectionContents</lhs>
            <rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Char" xlink:type="simple">Char</nt>* - (Char* ']]&gt;' Char*))</rhs>
            <com>
              <phrase>
                <xspecref ref="ws-explicit" spec="XQ">ws: explicit</xspecref>
              </phrase>
            </com>
          </prod>
          <prod num="152" id="prod-xquery11-ComputedConstructor">
            <lhs>ComputedConstructor</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-CompDocConstructor" xlink:type="simple">CompDocConstructor</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-CompElemConstructor" xlink:type="simple">CompElemConstructor</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-CompAttrConstructor" xlink:type="simple">CompAttrConstructor</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-CompNamespaceConstructor" xlink:type="simple">CompNamespaceConstructor</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-CompTextConstructor" xlink:type="simple">CompTextConstructor</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-CompCommentConstructor" xlink:type="simple">CompCommentConstructor</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-CompPIConstructor" xlink:type="simple">CompPIConstructor</nt>
            </rhs>
          </prod>
          <prod num="153" id="prod-xquery11-CompDocConstructor">
            <lhs>CompDocConstructor</lhs>
            <rhs>"document"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Expr" xlink:type="simple">Expr</nt>  "}"</rhs>
          </prod>
          <prod num="154" id="prod-xquery11-CompElemConstructor">
            <lhs>CompElemConstructor</lhs>
            <rhs>"element"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-EQName" xlink:type="simple">EQName</nt>  |  ("{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Expr" xlink:type="simple">Expr</nt>  "}"))  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ContentExpr" xlink:type="simple">ContentExpr</nt>?  "}"</rhs>
          </prod>
          <prod num="155" id="prod-xquery11-ContentExpr">
            <lhs>ContentExpr</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Expr" xlink:type="simple">Expr</nt>
            </rhs>
          </prod>
          <prod num="156" id="prod-xquery11-CompAttrConstructor">
            <lhs>CompAttrConstructor</lhs>
            <rhs>"attribute"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-EQName" xlink:type="simple">EQName</nt>  |  ("{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Expr" xlink:type="simple">Expr</nt>  "}"))  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Expr" xlink:type="simple">Expr</nt>?  "}"</rhs>
          </prod>
          <prod num="157" id="prod-xquery11-CompNamespaceConstructor">
            <lhs>CompNamespaceConstructor</lhs>
            <rhs>"namespace"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Prefix" xlink:type="simple">Prefix</nt>  |  ("{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-PrefixExpr" xlink:type="simple">PrefixExpr</nt>  "}"))  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-URIExpr" xlink:type="simple">URIExpr</nt>?  "}"</rhs>
          </prod>
          <prod num="158" id="prod-xquery11-Prefix">
            <lhs>Prefix</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-NCName" xlink:type="simple">NCName</nt>
            </rhs>
          </prod>
          <prod num="159" id="prod-xquery11-PrefixExpr">
            <lhs>PrefixExpr</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Expr" xlink:type="simple">Expr</nt>
            </rhs>
          </prod>
          <prod num="160" id="prod-xquery11-URIExpr">
            <lhs>URIExpr</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Expr" xlink:type="simple">Expr</nt>
            </rhs>
          </prod>
          <prod num="161" id="prod-xquery11-CompTextConstructor">
            <lhs>CompTextConstructor</lhs>
            <rhs>"text"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Expr" xlink:type="simple">Expr</nt>  "}"</rhs>
          </prod>
          <prod num="162" id="prod-xquery11-CompCommentConstructor">
            <lhs>CompCommentConstructor</lhs>
            <rhs>"comment"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Expr" xlink:type="simple">Expr</nt>  "}"</rhs>
          </prod>
          <prod num="163" id="prod-xquery11-CompPIConstructor">
            <lhs>CompPIConstructor</lhs>
            <rhs>"processing-instruction"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-NCName" xlink:type="simple">NCName</nt>  |  ("{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Expr" xlink:type="simple">Expr</nt>  "}"))  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Expr" xlink:type="simple">Expr</nt>?  "}"</rhs>
          </prod>
          <prod num="164" id="prod-xquery11-FunctionItemExpr">
            <lhs>FunctionItemExpr</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-LiteralFunctionItem" xlink:type="simple">LiteralFunctionItem</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-InlineFunction" xlink:type="simple">InlineFunction</nt>
            </rhs>
          </prod>
          <prod num="165" id="prod-xquery11-LiteralFunctionItem">
            <lhs>LiteralFunctionItem</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-EQName" xlink:type="simple">EQName</nt>  "#"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-IntegerLiteral" xlink:type="simple">IntegerLiteral</nt>
            </rhs>
            <com>
              <phrase>
                <xspecref ref="parse-note-reserved-function-names" spec="XQ">xgc: reserved-function-names</xspecref>
              </phrase>
            </com>
          </prod>
          <prod num="166" id="prod-xquery11-InlineFunction">
            <lhs>InlineFunction</lhs>
            <rhs>"function"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ParamList" xlink:type="simple">ParamList</nt>?  ")"  ("as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-SequenceType" xlink:type="simple">SequenceType</nt>)?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-EnclosedExpr" xlink:type="simple">EnclosedExpr</nt>
            </rhs>
          </prod>
          <prod num="167" id="prod-xquery11-SingleType">
            <lhs>SingleType</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-AtomicType" xlink:type="simple">AtomicType</nt>  "?"?</rhs>
          </prod>
          <prod num="168" id="prod-xquery11-TypeDeclaration">
            <lhs>TypeDeclaration</lhs>
            <rhs>"as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-SequenceType" xlink:type="simple">SequenceType</nt>
            </rhs>
          </prod>
          <prod num="169" id="prod-xquery11-SequenceType">
            <lhs>SequenceType</lhs>
            <rhs>("empty-sequence"  "("  ")")<br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ItemType" xlink:type="simple">ItemType</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt>?)</rhs>
          </prod>
          <prod num="170" id="prod-xquery11-OccurrenceIndicator">
            <lhs>OccurrenceIndicator</lhs>
            <rhs>"?"  |  "*"  |  "+"</rhs>
            <com>
              <phrase>
                <xspecref ref="parse-note-occurrence-indicators" spec="XQ">xgc: occurrence-indicators</xspecref>
              </phrase>
            </com>
          </prod>
          <prod num="171" id="prod-xquery11-ItemType">
            <lhs>ItemType</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-KindTest" xlink:type="simple">KindTest</nt>  |  ("item"  "("  ")")  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-FunctionTest" xlink:type="simple">FunctionTest</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-AtomicType" xlink:type="simple">AtomicType</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ParenthesizedItemType" xlink:type="simple">ParenthesizedItemType</nt>
            </rhs>
          </prod>
          <prod num="172" id="prod-xquery11-AtomicType">
            <lhs>AtomicType</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-EQName" xlink:type="simple">EQName</nt>
            </rhs>
          </prod>
          <prod num="173" id="prod-xquery11-KindTest">
            <lhs>KindTest</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-DocumentTest" xlink:type="simple">DocumentTest</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ElementTest" xlink:type="simple">ElementTest</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-AttributeTest" xlink:type="simple">AttributeTest</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-SchemaAttributeTest" xlink:type="simple">SchemaAttributeTest</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-PITest" xlink:type="simple">PITest</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-CommentTest" xlink:type="simple">CommentTest</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-TextTest" xlink:type="simple">TextTest</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-NamespaceNodeTest" xlink:type="simple">NamespaceNodeTest</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-AnyKindTest" xlink:type="simple">AnyKindTest</nt>
            </rhs>
          </prod>
          <prod num="174" id="prod-xquery11-AnyKindTest">
            <lhs>AnyKindTest</lhs>
            <rhs>"node"  "("  ")"</rhs>
          </prod>
          <prod num="175" id="prod-xquery11-DocumentTest">
            <lhs>DocumentTest</lhs>
            <rhs>"document-node"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ElementTest" xlink:type="simple">ElementTest</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt>)?  ")"</rhs>
          </prod>
          <prod num="176" id="prod-xquery11-TextTest">
            <lhs>TextTest</lhs>
            <rhs>"text"  "("  ")"</rhs>
          </prod>
          <prod num="177" id="prod-xquery11-CommentTest">
            <lhs>CommentTest</lhs>
            <rhs>"comment"  "("  ")"</rhs>
          </prod>
          <prod num="178" id="prod-xquery11-NamespaceNodeTest">
            <lhs>NamespaceNodeTest</lhs>
            <rhs>"namespace-node"  "("  ")"</rhs>
          </prod>
          <prod num="179" id="prod-xquery11-PITest">
            <lhs>PITest</lhs>
            <rhs>"processing-instruction"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-NCName" xlink:type="simple">NCName</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-StringLiteral" xlink:type="simple">StringLiteral</nt>)?  ")"</rhs>
          </prod>
          <prod num="180" id="prod-xquery11-AttributeTest">
            <lhs>AttributeTest</lhs>
            <rhs>"attribute"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-AttribNameOrWildcard" xlink:type="simple">AttribNameOrWildcard</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-TypeName" xlink:type="simple">TypeName</nt>)?)?  ")"</rhs>
          </prod>
          <prod num="181" id="prod-xquery11-AttribNameOrWildcard">
            <lhs>AttribNameOrWildcard</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-AttributeName" xlink:type="simple">AttributeName</nt>  |  "*"</rhs>
          </prod>
          <prod num="182" id="prod-xquery11-SchemaAttributeTest">
            <lhs>SchemaAttributeTest</lhs>
            <rhs>"schema-attribute"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-AttributeDeclaration" xlink:type="simple">AttributeDeclaration</nt>  ")"</rhs>
          </prod>
          <prod num="183" id="prod-xquery11-AttributeDeclaration">
            <lhs>AttributeDeclaration</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-AttributeName" xlink:type="simple">AttributeName</nt>
            </rhs>
          </prod>
          <prod num="184" id="prod-xquery11-ElementTest">
            <lhs>ElementTest</lhs>
            <rhs>"element"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ElementNameOrWildcard" xlink:type="simple">ElementNameOrWildcard</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-TypeName" xlink:type="simple">TypeName</nt>  "?"?)?)?  ")"</rhs>
          </prod>
          <prod num="185" id="prod-xquery11-ElementNameOrWildcard">
            <lhs>ElementNameOrWildcard</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ElementName" xlink:type="simple">ElementName</nt>  |  "*"</rhs>
          </prod>
          <prod num="186" id="prod-xquery11-SchemaElementTest">
            <lhs>SchemaElementTest</lhs>
            <rhs>"schema-element"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ElementDeclaration" xlink:type="simple">ElementDeclaration</nt>  ")"</rhs>
          </prod>
          <prod num="187" id="prod-xquery11-ElementDeclaration">
            <lhs>ElementDeclaration</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ElementName" xlink:type="simple">ElementName</nt>
            </rhs>
          </prod>
          <prod num="188" id="prod-xquery11-AttributeName">
            <lhs>AttributeName</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-EQName" xlink:type="simple">EQName</nt>
            </rhs>
          </prod>
          <prod num="189" id="prod-xquery11-ElementName">
            <lhs>ElementName</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-EQName" xlink:type="simple">EQName</nt>
            </rhs>
          </prod>
          <prod num="190" id="prod-xquery11-TypeName">
            <lhs>TypeName</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-EQName" xlink:type="simple">EQName</nt>
            </rhs>
          </prod>
          <prod num="191" id="prod-xquery11-FunctionTest">
            <lhs>FunctionTest</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Annotation" xlink:type="simple">Annotation</nt>*  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-AnyFunctionTest" xlink:type="simple">AnyFunctionTest</nt>
              <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-TypedFunctionTest" xlink:type="simple">TypedFunctionTest</nt>)</rhs>
          </prod>
          <prod num="192" id="prod-xquery11-AnyFunctionTest">
            <lhs>AnyFunctionTest</lhs>
            <rhs>"function"  "("  "*"  ")"</rhs>
          </prod>
          <prod num="193" id="prod-xquery11-TypedFunctionTest">
            <lhs>TypedFunctionTest</lhs>
            <rhs>"function"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-SequenceType" xlink:type="simple">SequenceType</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-SequenceType" xlink:type="simple">SequenceType</nt>)*)?  ")"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-SequenceType" xlink:type="simple">SequenceType</nt>
            </rhs>
          </prod>
          <prod num="194" id="prod-xquery11-ParenthesizedItemType">
            <lhs>ParenthesizedItemType</lhs>
            <rhs>"("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-ItemType" xlink:type="simple">ItemType</nt>  ")"</rhs>
          </prod>
          <prod num="195" id="prod-xquery11-URILiteral">
            <lhs>URILiteral</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-StringLiteral" xlink:type="simple">StringLiteral</nt>
            </rhs>
          </prod>
          <prod num="196" id="prod-xquery11-EQName">
            <lhs>EQName</lhs>
            <rhs>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-QName" xlink:type="simple">QName</nt>  |  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-URILiteral" xlink:type="simple">URILiteral</nt>  ":"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-NCName" xlink:type="simple">NCName</nt>)</rhs>
            <com>
              <phrase>
                <xspecref ref="ws-explicit" spec="XQ">ws: explicit</xspecref>
              </phrase>
            </com>
          </prod>
    </scrap>
    <div3 id="EBNFNotation">
      <head>Notation</head>
      <p>The following definitions will be helpful in defining
      precisely this exposition.</p>
      <p>
        <termdef id="symbol" term="symbol">Each rule in the grammar
        defines one 
        <term>symbol</term>, using the following format:
        <eg xml:space="preserve">symbol ::= expression</eg>
            </termdef>
      </p>
      <p>
      <termdef term="terminal" id="terminal">A 
      <term>terminal</term> is a symbol or string or pattern that
      can appear in the right-hand side of a rule, but never
      appears on the left hand side in the main grammar, although
      it may appear on the left-hand side of a rule in the grammar
      for terminals.</termdef> The following constructs are used to
      match strings of one or more characters in a terminal:</p>
      <glist>
        <gitem>
          <label>[a-zA-Z]</label>
          <def>
            <p>matches any 
            <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Char" xlink:type="simple">Char</nt> with a value in the
            range(s) indicated (inclusive).</p>
          </def>
        </gitem>
        <gitem>
          <label>[abc]</label>
          <def>
            <p>matches any 
            <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Char" xlink:type="simple">Char</nt> with a value among the
            characters enumerated. 
            <phrase diff="del">Enumerations and ranges can be mixed
            in one set of brackets.</phrase>
                </p>
          </def>
        </gitem>
        <gitem>
          <label>[^abc]</label>
          <def>
            <p>matches any 
            <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Char" xlink:type="simple">Char</nt> with a value not among the
            characters given.
            <phrase diff="del">Enumerations and ranges of forbidden
            values can be mixed in one set of
            brackets.</phrase>
                </p>
          </def>
        </gitem>
        <gitem>
          <label>"string"</label>
          <def>
            <p>matches the sequence of characters that appear
            inside the double quotes.</p>
          </def>
        </gitem>
        <gitem>
          <label>'string'</label>
          <def>
            <p>matches the sequence of characters that appear
            inside the single quotes.</p>
          </def>
        </gitem>
        <gitem>
          <label>
          [http://www.w3.org/TR/REC-example/#NT-Example]</label>
          <def>
            <p>matches any string matched by the production defined
            in the external specification as per the provided
            reference.</p>
          </def>
        </gitem>
      </glist>
      <p>Patterns (including the above constructs) can be combined
      with grammatical operators to form more complex patterns,
      matching more complex sets of character strings. In the
      examples that follow, A and B represent (sub-)patterns.</p>
      <glist>
        <gitem>
          <label>(A)</label>
          <def>
            <p>
            <code>A</code> is treated as a unit and may be combined
            as described in this list.</p>
          </def>
        </gitem>
        <gitem>
          <label>A?</label>
          <def>
            <p>matches 
            <code>A</code> or nothing; optional 
            <code>A</code>.</p>
          </def>
        </gitem>
        <gitem>
          <label>A B</label>
          <def>
            <p>matches 
            <code>A</code> followed by 
            <code>B</code>. This operator has higher precedence
            than alternation; thus 
            <code>A B | C D</code> is identical to 
            <code>(A B) | (C D)</code>.</p>
          </def>
        </gitem>
        <gitem>
          <label>A | B</label>
          <def>
            <p>matches 
            <code>A</code> or 
            <code>B</code> but not both.</p>
          </def>
        </gitem>
        <gitem>
          <label>A - B</label>
          <def>
            <p>matches any string that matches 
            <code>A</code> but does not match 
            <code>B</code>.</p>
          </def>
        </gitem>
        <gitem>
          <label>A+</label>
          <def>
            <p>matches one or more occurrences of 
            <code>A</code>. Concatenation has higher precedence
            than alternation; thus 
            <code>A+ | B+</code> is identical to 
            <code>(A+) | (B+)</code>.</p>
          </def>
        </gitem>
      </glist>
      <glist>
        <gitem>
          <label>A*</label>
          <def>
            <p>matches zero or more occurrences of 
            <code>A</code>. Concatenation has higher precedence
            than alternation; thus 
            <code>A* | B*</code> is identical to 
            <code>(A*) | (B*)</code>
                </p>
          </def>
        </gitem>
      </glist>
    </div3>
    <div3 id="extra-grammatical-constraints">
      <head>Extra-grammatical Constraints</head>
      <p>This section contains constraints on the EBNF productions,
      which are required to parse legal sentences. The notes below
      are referenced from the right side of the production, with
      the notation: 
      <emph>/* xgc: &lt;id&gt; */</emph>.</p>
      <constraintnote id="parse-note-leading-lone-slash" type="xgc" diff="chg" at="XQ.E24 and XP.E16">
        <head>leading-lone-slash</head>
        <p>A single slash may appear either as a complete path
        expression or as the first part of a path expression in
        which it is followed by a 
        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt>. In some
        cases, the next token after the slash is insufficient to
        allow a parser to distinguish these two possibilities: the 
        <code>*</code> token and keywords like 
        <code>union</code> could be either an operator or a 
        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-NameTest" xlink:type="simple">NameTest</nt>
        <phrase role="xquery">, and the 
        <code>&lt;</code> token could be either an operator or the
        start of a 
        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-DirectConstructor" xlink:type="simple">
        DirectConstructor</nt>
              </phrase>. For example, without
        lookahead the first part of the expression 
        <code>/ * 5</code> is easily taken to be a complete
        expression, 
        <code role="parse-test">/ *</code>, which has a very different interpretation
        (the child nodes of 
        <code>/</code>).</p>
        <p>Therefore to reduce the need for lookahead, if the token
        immediately following a slash can form the start of a 
        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt>, then the
        slash must be the beginning of a 
        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-PathExpr" xlink:type="simple">PathExpr</nt>, not the entirety of
        it.</p>
        <p>A single slash may be used as the left-hand argument of
        an operator by parenthesizing it: 
        <code role="parse-test">(/) * 5</code>. The expression 
        <code role="parse-test">5 * /</code>, on the other hand, is legal without
        parentheses.</p>
      </constraintnote>
      <constraintnote id="parse-note-xml-version" type="xgc">
        <head>xml-version</head>
        <p>An implementation's choice to support the <bibref ref="XML"/> and <bibref ref="XMLNAMES"/>, or <bibref ref="XML1.1"/>
        and <bibref ref="XMLNAMES11"/> lexical specification
        determines the external document from which to obtain the
        definition for this production. The EBNF only has references
        to the 1.0 versions. In some cases, the XML 1.0 and XML 1.1
        definitions may be exactly the same. Also please note that
        these external productions follow the whitespace rules of
        their respective specifications, and not the rules of this
        specification, in particular <specref ref="DefaultWhitespaceHandling"/>. Thus <code>prefix :
        localname</code> is not a valid <termref def="dt-qname">lexical QName</termref> for purposes of this
        specification, just as it is not permitted in a XML
        document. Also, comments are not permissible on either side of
        the colon. Also extra-grammatical constraints such as
        well-formedness constraints must be taken into account.</p>
      </constraintnote>

      <constraintnote id="parse-note-reserved-function-names" type="xgc">
        <head>reserved-function-names</head>
        <p>Unprefixed function names spelled the same way as
        language keywords could make the language harder to
        recognize. For instance, 
        <code>if(foo)</code> could be taken either as a 
        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-FunctionCall" xlink:type="simple">FunctionCall</nt> or as the beginning
        of an 
        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-IfExpr" xlink:type="simple">IfExpr</nt>.  Therefore, an unprefixed
	function name must not be any of the names in
	<specref ref="id-reserved-fn-names"/>.</p>
       
        <p>A function named "if" can be called by binding its
        namespace to a prefix and using the prefixed form:
        "library:if(foo)" instead of "if(foo)".</p>
      </constraintnote>
      <constraintnote id="parse-note-occurrence-indicators" type="xgc">
        <head>occurrence-indicators</head> <p>As written, the grammar
        in <specref ref="nt-bnf"/> is ambiguous for some forms using
        the '+' and '*' Kleene operators. The ambiguity is resolved as
        follows: these operators are tightly bound to the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SequenceType" xlink:type="simple">SequenceType</nt> expression, and have
        higher precedence than other uses of these symbols.  Any
        occurrence of '+' and '*', as well as '?', following a
        sequence type is assumed to be an occurrence indicator, which
        binds to the last <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ItemType" xlink:type="simple">ItemType</nt> in the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SequenceType" xlink:type="simple">SequenceType</nt>.</p>

	<p>Thus, <code role="parse-test">4 treat as item() + -
	5</code> must be interpreted as <code role="parse-test">(4
	treat as item()+) - 5</code>, taking the '+' as an
	OccurrenceIndicator and the '-' as a subtraction operator. To
	force the interpretation of "+" as an addition operator (and
	the corresponding interpretation of the "-" as a unary minus),
	parentheses may be used: the form <code role="parse-test">(4
	treat as item()) + -5</code> surrounds the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SequenceType" xlink:type="simple">SequenceType</nt> expression with
	parentheses and leads to the desired interpretation.</p>

	<p> <code>function () as xs:string *</code>
	is interpreted as <code>function () as
	(xs:string *)</code>, not as <code>(function
	() as xs:string) *</code>.  Parentheses can be used as shown
	to force the latter interpretation.</p>

        <p>This rule has as a consequence that certain forms which
        would otherwise be legal and unambiguous are not
        recognized: in "4 treat as item() + 5", the "+" is taken as
        an 
        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt>, and
        not as an operator, which means this is not a legal
        expression.</p>
      </constraintnote>
    </div3>
    <div3 id="notes-on-parsing">
      <head>Grammar Notes</head>
      <p>This section contains general notes on the EBNF
      productions, which may be helpful in understanding how to
      interpret and implement the EBNF. These notes are not
      normative. The notes below are referenced from the right side
      of the production, with the notation: 
      <emph>/* gn: &lt;id&gt; */</emph>.</p>
      <note>
        <glist>
          <gitem id="parse-note-parens">
            <label>grammar-note: parens</label>
            <def>
              <p>Look-ahead is required to distinguish 
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-FunctionCall" xlink:type="simple">FunctionCall</nt> from a EQName
              or keyword followed by a 
              <phrase role="xquery">
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Pragma" xlink:type="simple">Pragma</nt> or </phrase>
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Comment" xlink:type="simple">Comment</nt>. For example: 
              <code role="parse-test">address (: this may be empty
              :)</code> may be mistaken for a call to a function
              named "address" unless this lookahead is employed.
              Another example is 
              <code role="parse-test">for (: whom the bell :)
              $tolls in 3 return $tolls</code>, where the keyword
              "for" must not be mistaken for a function name.</p>
            </def>
          </gitem>
          <gitem id="parse-note-comments">
            <label>grammar-note: comments</label>
            <def>
              <p>Comments are allowed everywhere that 
              <termref def="IgnorableWhitespace">ignorable
              whitespace</termref> is allowed, and the 
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Comment" xlink:type="simple">Comment</nt> symbol does not
              explicitly appear on the right-hand side of the
              grammar (except in its own production). See 
              <specref ref="DefaultWhitespaceHandling"/>. 
              <phrase role="xquery">Note that comments are not
              allowed in direct constructor content, though they
              are allowed in nested 
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-EnclosedExpr" xlink:type="simple">
              EnclosedExprs</nt>.</phrase>
                  </p>
              <p>A comment can contain nested comments, as long as
              all "(:" and ":)" patterns are balanced, no matter
              where they occur within the outer comment.</p>
              <note>
                <p>Lexical analysis may typically handle nested
                comments by incrementing a counter for each "(:"
                pattern, and decrementing the counter for each ":)"
                pattern. The comment does not terminate until the
                counter is back to zero.</p>
              </note>
              <p>Some illustrative examples:</p>
              <ulist>
                <item>
                  <p>
                  <code>(: commenting out a (: comment :) may be
                  confusing, but often helpful :)</code> is a legal
                  Comment, since balanced nesting of comments is
                  allowed.</p>
                </item>
                <item>
                  <p>
                  <code role="parse-test">"this is just a string
                  :)"</code> is a legal expression. However, 
                  <code>(: "this is just a string :)" :)</code> will
                  cause a syntax error. Likewise, 
                  <code role="parse-test">"this is another string
                  (:"</code> is a legal expression, but 
                  <code>(: "this is another string (:"
                  :)</code> will cause a syntax error. It is a
                  limitation of nested comments that literal
                  content can cause unbalanced nesting of
                  comments.</p>
                </item>
                <item>
                  <p>
                  <code role="parse-test">for (: set up loop :) $i
                  in $x return $i</code> is syntactically legal,
                  ignoring the comment.</p>
                </item>
                <item>
                  <p>
                  <code role="parse-test">5 instance (: strange
                  place for a comment :) of xs:integer</code> is
                  also syntactically legal.</p>
                </item>
                <item role="xquery">
                  <p>
                  <code>
                    &lt;eg (: an example:)&gt;{$i//title}&lt;/eg&gt;
</code> is not syntactically legal.</p>
                </item>
                <item role="xquery">
                  <p>
                  <code role="parse-test">
                    &lt;eg&gt; (: an example:) &lt;/eg&gt;
</code> is syntactically legal, but the characters that look like a
comment are in fact literal element content.</p>
                </item>
              </ulist>
            </def>
          </gitem>
        </glist>
      </note>
    </div3>
  </div2>
  <div2 id="lexical-structure">
    <head>Lexical structure</head>
    <p>The terminal symbols assumed by the grammar above are
    described in this section.</p>
    <p>Quoted strings appearing in production rules are terminal
    symbols.</p>
    <p>Other terminal symbols are defined in 
    <specref ref="terminal-symbols"/>.</p>
    
    <p role="xquery">It is 
    <termref def="dt-implementation-defined">
    implementation-defined</termref> whether the lexical rules of 
    <bibref ref="XML"/> and 
    <bibref ref="XMLNAMES"/> are followed, or alternatively, the
    lexical rules of 
    <bibref ref="XML1.1"/> and 
    <bibref ref="XMLNAMES11"/> are followed. Implementations that
    support the full 
    <bibref ref="XML1.1"/> character set 
    <termref def="should">SHOULD</termref>, for purposes of
    interoperability, provide a mode that follows only the 
    <bibref ref="XML"/> and 
    <bibref ref="XMLNAMES"/> lexical rules.</p>
    <p>When tokenizing, the longest possible match that is valid in
    the current context is used.</p>

    <p>All keywords are case sensitive. Keywords are not
    reserved—that is, any <termref def="dt-qname">lexical
    QName</termref> may duplicate a keyword except as noted in
    <specref ref="id-reserved-fn-names"/>.</p>

    <div3 id="terminal-symbols">
      <head>Terminal Symbols</head>
      <scrap headstyle="show">
        <head/>
        <prod num="197" id="prod-xquery11-IntegerLiteral">
              <lhs>IntegerLiteral</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Digits" xlink:type="simple">Digits</nt>
              </rhs>
            </prod>
            <prod num="198" id="prod-xquery11-DecimalLiteral">
              <lhs>DecimalLiteral</lhs>
              <rhs>("."  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Digits" xlink:type="simple">Digits</nt>)  |  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Digits" xlink:type="simple">Digits</nt>  "."  [0-9]*)</rhs>
              <com>
                <phrase>
                  <xspecref ref="ws-explicit" spec="XQ">ws: explicit</xspecref>
                </phrase>
              </com>
            </prod>
            <prod num="199" id="prod-xquery11-DoubleLiteral">
              <lhs>DoubleLiteral</lhs>
              <rhs>(("."  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Digits" xlink:type="simple">Digits</nt>)  |  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Digits" xlink:type="simple">Digits</nt>  ("."  [0-9]*)?))  [eE]  [+-]?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Digits" xlink:type="simple">Digits</nt>
              </rhs>
              <com>
                <phrase>
                  <xspecref ref="ws-explicit" spec="XQ">ws: explicit</xspecref>
                </phrase>
              </com>
            </prod>
            <prod num="200" id="prod-xquery11-StringLiteral">
              <lhs>StringLiteral</lhs>
              <rhs>('"'  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-PredefinedEntityRef" xlink:type="simple">PredefinedEntityRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-CharRef" xlink:type="simple">CharRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-EscapeQuot" xlink:type="simple">EscapeQuot</nt>  |  [^"&amp;])*  '"')  |  ("'"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-PredefinedEntityRef" xlink:type="simple">PredefinedEntityRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-CharRef" xlink:type="simple">CharRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-EscapeApos" xlink:type="simple">EscapeApos</nt>  |  [^'&amp;])*  "'")</rhs>
              <com>
                <phrase>
                  <xspecref ref="ws-explicit" spec="XQ">ws: explicit</xspecref>
                </phrase>
              </com>
            </prod>
            <prod num="201" id="prod-xquery11-PredefinedEntityRef">
              <lhs>PredefinedEntityRef</lhs>
              <rhs>"&amp;"  ("lt"  |  "gt"  |  "amp"  |  "quot"  |  "apos")  ";"</rhs>
              <com>
                <phrase>
                  <xspecref ref="ws-explicit" spec="XQ">ws: explicit</xspecref>
                </phrase>
              </com>
            </prod>
            <prod num="202" id="prod-xquery11-EscapeQuot">
              <lhs>EscapeQuot</lhs>
              <rhs>'""'</rhs>
            </prod>
            <prod num="203" id="prod-xquery11-EscapeApos">
              <lhs>EscapeApos</lhs>
              <rhs>"''"</rhs>
            </prod>
            <prod num="204" id="prod-xquery11-ElementContentChar">
              <lhs>ElementContentChar</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Char" xlink:type="simple">Char</nt> - [{}&lt;&amp;]</rhs>
            </prod>
            <prod num="205" id="prod-xquery11-QuotAttrContentChar">
              <lhs>QuotAttrContentChar</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Char" xlink:type="simple">Char</nt> - ["{}&lt;&amp;]</rhs>
            </prod>
            <prod num="206" id="prod-xquery11-AposAttrContentChar">
              <lhs>AposAttrContentChar</lhs>
              <rhs>
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Char" xlink:type="simple">Char</nt> - ['{}&lt;&amp;]</rhs>
            </prod>
            <prod num="207" id="prod-xquery11-Comment">
              <lhs>Comment</lhs>
              <rhs>"(:"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-CommentContents" xlink:type="simple">CommentContents</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Comment" xlink:type="simple">Comment</nt>)*  ":)"</rhs>
              <com>
                <phrase>
                  <xspecref ref="ws-explicit" spec="XQ">ws: explicit</xspecref>
                </phrase>
              </com>
              <com>
                <phrase>
                  <xspecref ref="parse-note-comments" spec="XQ">gn: comments</xspecref>
                </phrase>
              </com>
            </prod>
            <prod num="208" id="prod-xquery11-PITarget">
              <lhs>PITarget</lhs>
              <rhs>
                <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XML" ref="NT-PITarget" xlink:type="simple">[http://www.w3.org/TR/REC-xml#NT-PITarget]</xnt>
              </rhs>
              <com>
                <phrase>
                  <xspecref ref="parse-note-xml-version" spec="XQ">xgc: xml-version</xspecref>
                </phrase>
              </com>
            </prod>
            <prod num="209" id="prod-xquery11-CharRef">
              <lhs>CharRef</lhs>
              <rhs>
                <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XML" ref="NT-CharRef" xlink:type="simple">[http://www.w3.org/TR/REC-xml#NT-CharRef]</xnt>
              </rhs>
              <com>
                <phrase>
                  <xspecref ref="parse-note-xml-version" spec="XQ">xgc: xml-version</xspecref>
                </phrase>
              </com>
            </prod>
            <prod num="210" id="prod-xquery11-QName">
              <lhs>QName</lhs>
              <rhs>
                <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="Names" ref="NT-QName" xlink:type="simple">[http://www.w3.org/TR/REC-xml-names/#NT-QName]</xnt>
              </rhs>
              <com>
                <phrase>
                  <xspecref ref="parse-note-xml-version" spec="XQ">xgc: xml-version</xspecref>
                </phrase>
              </com>
            </prod>
            <prod num="211" id="prod-xquery11-NCName">
              <lhs>NCName</lhs>
              <rhs>
                <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="Names" ref="NT-NCName" xlink:type="simple">[http://www.w3.org/TR/REC-xml-names/#NT-NCName]</xnt>
              </rhs>
              <com>
                <phrase>
                  <xspecref ref="parse-note-xml-version" spec="XQ">xgc: xml-version</xspecref>
                </phrase>
              </com>
            </prod>
            <prod num="212" id="prod-xquery11-S">
              <lhs>S</lhs>
              <rhs>
                <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XML" ref="NT-S" xlink:type="simple">[http://www.w3.org/TR/REC-xml#NT-S]</xnt>
              </rhs>
              <com>
                <phrase>
                  <xspecref ref="parse-note-xml-version" spec="XQ">xgc: xml-version</xspecref>
                </phrase>
              </com>
            </prod>
            <prod num="213" id="prod-xquery11-Char">
              <lhs>Char</lhs>
              <rhs>
                <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XML" ref="NT-Char" xlink:type="simple">[http://www.w3.org/TR/REC-xml#NT-Char]</xnt>
              </rhs>
              <com>
                <phrase>
                  <xspecref ref="parse-note-xml-version" spec="XQ">xgc: xml-version</xspecref>
                </phrase>
              </com>
            </prod>
      </scrap>
      <p>The following symbols are used only in the definition of
      terminal symbols; they are not terminal symbols in the
      grammar of 
      <specref ref="id-grammar"/>.</p>
      <scrap headstyle="show">
        <head/>
        <prod num="214" id="prod-xquery11-Digits">
              <lhs>Digits</lhs>
              <rhs>[0-9]+</rhs>
            </prod>
            <prod num="215" id="prod-xquery11-CommentContents">
              <lhs>CommentContents</lhs>
              <rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-Char" xlink:type="simple">Char</nt>+ - (Char* ('(:' | ':)') Char*))</rhs>
            </prod>
      </scrap>
    </div3>
    <div3 id="id-terminal-delimitation">
      <head>Terminal Delimitation</head>
      <p>XQuery 1.1 expressions consist of 
      <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#terminal-symbols" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">terminal symbols</loc> and 
      <termref def="symbolseparators">symbol
      separators</termref>.</p>
      <p>Terminal symbols that are not used exclusively in 
      <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">/* ws: explicit */</loc> productions
      are of two kinds: delimiting and non-delimiting.</p>
      <!-- The next paragraph is "filled in" by various stylesheets used to generate the "assembled" source files. -->
      <p>
        <termdef id="delimiting-token" term="delimiting terminal symbol">The 
        <term>delimiting terminal symbols</term> are: 
        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-S" xlink:type="simple">S</nt>, "-", (comma), (semi-colon), (colon), "::", ":=", "!=", "?", "?&gt;", "/", "//", "/&gt;", (dot), "..", <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-StringLiteral" xlink:type="simple">StringLiteral</nt>, "(", "(#", ")", "[", "]", "]]&gt;", "{", "}", "@", "$", "*", "#", "#)", "%", "+", "&lt;", "&lt;!--", "&lt;![CDATA[", "&lt;?", "&lt;/", "&lt;&lt;", "&lt;=", "=", "&gt;", "--&gt;", "&gt;=", "&gt;&gt;", "|"</termdef>
      </p>
      <!-- The next paragraph is "filled in" by various stylesheets used to generate the "assembled" source files. -->
      <p>
        <termdef id="non-delimiting-token" term="non-delimiting terminal symbol">The 
        <term>non-delimiting terminal symbols</term> are: 
        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-IntegerLiteral" xlink:type="simple">IntegerLiteral</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-NCName" xlink:type="simple">NCName</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-QName" xlink:type="simple">QName</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-DecimalLiteral" xlink:type="simple">DecimalLiteral</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery11-DoubleLiteral" xlink:type="simple">DoubleLiteral</nt>, "allowing", "ancestor", "ancestor-or-self", "and", "as", "ascending", "at", "attribute", "base-uri", "boundary-space", "by", "case", "cast", "castable", "catch", "child", "collation", "comment", "construction", "context", "copy-namespaces", "count", "decimal-format", "decimal-separator", "declare", "default", "descendant", "descendant-or-self", "descending", "digit", "div", "document", "document-node", "element", "else", "empty", "empty-sequence", "encoding", "end", "eq", "every", "except", "external", "following", "following-sibling", "for", "function", "ge", "greatest", "group", "grouping-separator", "gt", "idiv", "if", "import", "in", "infinity", "inherit", "instance", "intersect", "is", "item", "lax", "le", "least", "let", "lt", "minus-sign", "mod", "module", "namespace", "namespace-node", "NaN", "ne", "next", "node", "no-inherit", "no-preserve", "of", "only", "option", "or", "order", "ordered", "ordering", "parent", "pattern-separator", "percent", "per-mille", "preceding", "preceding-sibling", "preserve", "previous", "processing-instruction", "return", "satisfies", "schema", "schema-attribute", "schema-element", "self", "sliding", "some", "stable", "start", "strict", "strip", "switch", "text", "then", "to", "treat", "try", "tumbling", "type", "typeswitch", "union", "unordered", "validate", "variable", "version", "when", "where", "window", "xquery", "zero-digit"</termdef>
      </p>
      <p>
        <termdef id="symbolseparators" term="symbol separators">
        <termref def="Whitespace">Whitespace</termref> and 
        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Comment" xlink:type="simple">Comments</nt> function as 
        <term>symbol separators</term>. For the most part, they are
        not mentioned in the grammar, and may occur between any two
        terminal symbols mentioned in the grammar, except where
        that is forbidden by the 
        <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">/* ws: explicit */</loc> annotation
        in the EBNF, or by the 
        <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-xml-version" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">/* xgc: xml-version
        */</loc> annotation.</termdef>
      </p>
      <p>It is customary to separate consecutive terminal symbols
      by 
      <termref def="Whitespace">whitespace</termref> and 
      <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Comment" xlink:type="simple">Comments</nt>, but this is required only
      when otherwise two non-delimiting symbols would be adjacent
      to each other. There are two exceptions to this, that of "."
      and "-", which do require a 
      <termref def="symbolseparators">symbol separator</termref> if
      they follow a QName or NCName. Also, "." requires a separator
      if it precedes or follows a numeric literal.</p>
    </div3>
    <div3 id="id-eol-handling">
      <head>End-of-Line Handling</head>
      <p>The XQuery 1.1 processor must behave as if it
      normalized all line breaks on input, before parsing. The
      normalization should be done according to the choice to
      support either 
      <bibref ref="XML"/> or 
      <bibref ref="XML1.1"/> lexical processing.</p>
      <div4 id="id-xml10-eol-handling">
        <head>XML 1.0 End-of-Line Handling</head>
        <p>For 
        <bibref ref="XML"/> processing, all of the following must
        be translated to a single #xA character:</p>
        <olist>
          <item>
            <p>the two-character sequence #xD #xA</p>
          </item>
          <item>
            <p>any #xD character that is not immediately followed
            by #xA.</p>
          </item>
        </olist>
      </div4>
      <div4 id="id-xml11-eol-handling">
        <head>XML 1.1 End-of-Line Handling</head>
        <p>For 
        <bibref ref="XML1.1"/> processing, all of the following
        must be translated to a single #xA character:</p>
        <olist>
          <item>
            <p>the two-character sequence #xD #xA</p>
          </item>
          <item>
            <p>the two-character sequence #xD #x85</p>
          </item>
          <item>
            <p>the single character #x85</p>
          </item>
          <item>
            <p>the single character #x2028</p>
          </item>
          <item>
            <p>any #xD character that is not immediately followed
            by #xA or #x85.</p>
          </item>
        </olist>
        <p role="xquery">The characters #x85 and #x2028 cannot be
        reliably recognized and translated until the 
        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-VersionDecl" xlink:type="simple">VersionDecl</nt> declaration (if
        present) has been read.</p>
      </div4>
    </div3>
    <div3 id="whitespace-rules">
      <head>Whitespace Rules</head>
      <div4 id="DefaultWhitespaceHandling">
        <head>Default Whitespace Handling</head>
        <p>
          <termdef id="Whitespace" term="whitespace">A 
          <term>whitespace</term> character is any of the characters
          defined by 
          <xnt xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/REC-xml#NT-S" xlink:type="simple">
          [http://www.w3.org/TR/REC-xml#NT-S]</xnt>.</termdef>
        </p>
        <p>
        <termdef term="ignorable whitespace" id="IgnorableWhitespace">
        <term>Ignorable whitespace</term> consists of any 
        <termref def="Whitespace">whitespace</termref> characters
        that may occur between 
        <termref def="terminal">terminals</termref>, unless these
        characters occur in the context of a production marked with
        a 
        <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ExplicitWhitespaceHandling" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
        ws:explicit</loc> annotation, in which case they can occur
        only where explicitly specified (see 
        <specref ref="ExplicitWhitespaceHandling"/>).</termdef> Ignorable
        whitespace characters are not significant to the semantics
        of an expression. Whitespace is allowed before the first
        terminal and after the last terminal of a module.
        Whitespace is allowed between any two 
        <termref def="terminal">terminals</termref>. 
        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Comment" xlink:type="simple">Comments</nt> may also act as "whitespace"
        to prevent two adjacent terminals from being recognized as
        one. Some illustrative examples are as follows:</p>
        <ulist>
          <item>
            <p>
            <code>foo- foo</code> results in a syntax error. "foo-"
            would be recognized as a QName.</p>
          </item>
          <item>
            <p>
            <code role="parse-test">foo -foo</code> is syntactically
            equivalent to 
            <code role="parse-test">foo - foo</code>, two QNames
            separated by a subtraction operator.</p>
          </item>
          <item>
            <p>
            <code role="parse-test">foo(: This is a comment :)-
            foo</code> is syntactically equivalent to 
            <code>foo - foo</code>. This is because the comment
            prevents the two adjacent terminals from being
            recognized as one.</p>
          </item>
          <item>
            <p>
            <code role="parse-test">foo-foo</code> is syntactically equivalent to
            single QName. This is because "-" is a valid character
            in a QName. When used as an operator after the
            characters of a name, the "-" must be separated from
            the name, e.g. by using whitespace or parentheses.</p>
          </item>
          <item>
            <p>
            <code>10div 3</code> results in a syntax error.</p>
          </item>
          <item>
            <p>
            <code>10 div3</code> also results in a syntax error.</p>
          </item>
          <item>
            <p>
            <code>10div3</code> also results in a syntax error.</p>
          </item>
        </ulist>
      </div4>
      <div4 id="ExplicitWhitespaceHandling">
        <head>Explicit Whitespace Handling</head>
        <p>Explicit whitespace notation is specified with the EBNF
        productions, when it is different from the default rules,
        using the notation shown below. This notation is not
        inherited. In other words, if an EBNF rule is marked as /*
        ws: explicit */, the notation does not automatically apply
        to all the 'child' EBNF productions of that rule.</p>
        <glist>
          <gitem id="ws-explicit">
            <label>ws: explicit</label>
            <def>
              <p>/* ws: explicit */ means that the EBNF notation
              explicitly notates, with 
              <code>S</code> or otherwise, where 
              <termref def="Whitespace">whitespace
              characters</termref> are allowed. In productions with
              the /* ws: explicit */ annotation, 
              <specref ref="DefaultWhitespaceHandling"/> does not
              apply. 
              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Comment" xlink:type="simple">Comments</nt> are also not allowed
              in these productions.</p>
            </def>
          </gitem>
        </glist>
        <p role="xquery" id="ws-explicit-lex-states">For example,
        whitespace is not freely allowed by the direct constructor
        productions, but is specified explicitly in the grammar, in
        order to be more consistent with XML.</p>
      </div4>
    </div3>
  </div2>
  <div2 id="id-reserved-fn-names">
    <head>Reserved Function Names</head>
    <p>The following names are not allowed as function names in an
    unprefixed form because expression syntax takes precedence.</p>
    <!-- Note to editors: This list is (or should be) in alphabetical order. -->
    <ulist>
      <item>
        <p>
          <code>attribute</code>
        </p>
      </item>
      <item>
        <p>
          <code>comment</code>
        </p>
      </item>
      <item>
        <p>
          <code>document-node</code>
        </p>
      </item>
      <item>
        <p>
          <code>element</code>
        </p>
      </item>
      <item>
        <p>
          <code>empty-sequence</code>
        </p>
      </item>
      <item>
        <p>
          <code>function</code>
        </p>
      </item>
      <item>
        <p>
          <code>if</code>
        </p>
      </item>
      <item>
        <p>
          <code>item</code>
        </p>
      </item>
      <item>
        <p>
          <code>namespace-node</code>
        </p>
      </item>
      <item>
        <p>
          <code>node</code>
        </p>
      </item>
      <item>
        <p>
          <code>processing-instruction</code>
        </p>
      </item>
      <item>
        <p>
          <code>schema-attribute</code>
        </p>
      </item>
      <item>
        <p>
          <code>schema-element</code>
        </p>
      </item>
      <item>
        <p>
          <code>switch</code>
        </p>
      </item>
      <item>
        <p>
          <code>text</code>
        </p>
      </item>
      <item>
        <p>
          <code>typeswitch</code>
        </p>
      </item>
    </ulist>
    
  </div2>
  <div2 id="id-precedence-order">
    <head>Precedence Order (Non-Normative)</head>
    <p diff="chg" at="XQ.E26 and XP.E18">The grammar in
    <specref ref="id-grammar"/> normatively defines built-in
    precedence among the operators of XQuery. These operators are
    summarized here to make clear the order of their precedence
    from lowest to highest. The associativity column indicates the
    order in which operators of equal precedence in an expression
    are applied.</p>
    <table border="1">
      <tbody>
        <tr>
          <th rowspan="1" colspan="1">#</th>
          <th rowspan="1" colspan="1">Operator</th>
          <th rowspan="1" colspan="1">Associativity</th>
        </tr>
        <tr>
          <td rowspan="1" colspan="1">1</td>
          <td rowspan="1" colspan="1">, (comma)</td>
          <td rowspan="1" colspan="1">either</td>
        </tr>
        <tr>
          <td rowspan="1" colspan="1">2</td>
          <td rowspan="1" colspan="1">
            
            
            <phrase role="xquery">
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-FLWORExpr" xlink:type="simple">FLWOR</nt>,</phrase>
            <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-QuantifiedExpr" xlink:type="simple">some, every</nt>, 
            <phrase role="xquery">
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SwitchExpr" xlink:type="simple">switch</nt>,</phrase>
            <phrase role="xquery">
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TypeswitchExpr" xlink:type="simple">typeswitch</nt>,</phrase>
            <phrase role="xquery">
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TryCatchExpr" xlink:type="simple">try</nt>,</phrase>
            <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-IfExpr" xlink:type="simple">if</nt>
          </td>
          <td rowspan="1" colspan="1">NA</td>
        </tr>
        <tr>
          <td rowspan="1" colspan="1">3</td>
          <td rowspan="1" colspan="1">
            <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-OrExpr" xlink:type="simple">or</nt>
          </td>
          <td rowspan="1" colspan="1">either</td>
        </tr>
        <tr>
          <td rowspan="1" colspan="1">4</td>
          <td rowspan="1" colspan="1">
            <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AndExpr" xlink:type="simple">and</nt>
          </td>
          <td rowspan="1" colspan="1">either</td>
        </tr>
        <tr>
          <td rowspan="1" colspan="1">5</td>
          <td rowspan="1" colspan="1">
            <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ValueComp" xlink:type="simple">eq, ne, lt, le, gt, ge</nt>, 
            <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-GeneralComp" xlink:type="simple">=, !=, &lt;, &lt;=, &gt;, &gt;=</nt>, 
            <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-NodeComp" xlink:type="simple">is, &lt;&lt;, &gt;&gt;</nt>
          </td>
          <td rowspan="1" colspan="1">NA</td>
        </tr>
        <tr>
          <td rowspan="1" colspan="1">6</td>
          <td rowspan="1" colspan="1">
            <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-RangeExpr" xlink:type="simple">to</nt>
          </td>
          <td rowspan="1" colspan="1">NA</td>
        </tr>
        <tr>
          <td rowspan="1" colspan="1">7</td>
          <td rowspan="1" colspan="1">
            <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AdditiveExpr" xlink:type="simple">+, - (binary)</nt>
          </td>
          <td rowspan="1" colspan="1">left-to-right</td>
        </tr>
        <tr>
          <td rowspan="1" colspan="1">8</td>
          <td rowspan="1" colspan="1">
            <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-MultiplicativeExpr" xlink:type="simple">*, div, idiv, mod</nt>
          </td>
          <td rowspan="1" colspan="1">left-to-right</td>
        </tr>
        <tr>
          <td rowspan="1" colspan="1">9</td>
          <td rowspan="1" colspan="1">
            <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-UnionExpr" xlink:type="simple">union, |</nt>
          </td>
          <td rowspan="1" colspan="1">either</td>
        </tr>
        <tr>
          <td rowspan="1" colspan="1">10</td>
          <td rowspan="1" colspan="1">
            <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-IntersectExceptExpr" xlink:type="simple">intersect, except</nt>
          </td>
          <td rowspan="1" colspan="1">left-to-right</td>
        </tr>
        <tr>
          <td rowspan="1" colspan="1">11</td>
          <td rowspan="1" colspan="1">
            <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-InstanceofExpr" xlink:type="simple">instance of</nt>
          </td>
          <td rowspan="1" colspan="1">NA</td>
        </tr>
        <tr>
          <td rowspan="1" colspan="1">12</td>
          <td rowspan="1" colspan="1">
            <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TreatExpr" xlink:type="simple">treat as</nt>
          </td>
          <td rowspan="1" colspan="1">NA</td>
        </tr>
        <tr>
          <td rowspan="1" colspan="1">13</td>
          <td rowspan="1" colspan="1">
            <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-CastableExpr" xlink:type="simple">castable as</nt>
          </td>
          <td rowspan="1" colspan="1">NA</td>
        </tr>
        <tr>
          <td rowspan="1" colspan="1">14</td>
          <td rowspan="1" colspan="1">
            <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-CastExpr" xlink:type="simple">cast as</nt>
          </td>
          <td rowspan="1" colspan="1">NA</td>
        </tr>
        <tr>
          <td rowspan="1" colspan="1">15</td>
          <td rowspan="1" colspan="1">
            <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-UnaryExpr" xlink:type="simple">-, + (unary)</nt>
          </td>
          <td rowspan="1" colspan="1">right-to-left</td>
        </tr>
        <tr>
          <td rowspan="1" colspan="1">16</td>
          <td rowspan="1" colspan="1">
            <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-PathExpr" xlink:type="simple">/, //</nt>
          </td>
          <td rowspan="1" colspan="1">left-to-right</td>
        </tr>
<!--        <tr diff="chg" at="XQ.E26 and XP.E18"> -->
        <tr>
          <td rowspan="1" colspan="1">17</td>
          <td rowspan="1" colspan="1">
            <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-Predicate" xlink:type="simple">[ ]</nt>
          </td>
          <td rowspan="1" colspan="1">left-to-right</td>
        </tr>
      </tbody>
    </table>

    <p>
      In the "Associativity" column,
      "either"
      indicates that all the operators at that level have the associative property
      (i.e., <code>(A op B) op C</code> is equivalent to <code>A op (B op C)</code>),
      so their associativity is inconsequential.
      "NA" (not applicable)
      indicates that the EBNF does not allow
      an expression that directly contains
      multiple operators from that precedence level,
      so the question of their associativity does not arise.
    </p>

    <note diff="chg" at="XQ.E26 and XP.E18">
      <p>Parentheses can be used to override the operator
      precedence in the usual way. Square brackets in an expression
      such as A[B] serve two roles: they act as an operator causing
      B to be evaluated once for each item in the value of A, and
      they act as parentheses enclosing the expression B.</p>
      <p role="xquery">Curly braces in an expression such as
      validate{E} or ordered{E} perform a similar bracketing role
      to the parentheses in a function call, but with the
      difference in most cases that E is an Expr rather than
      ExprSingle, meaning that it can use the comma operator.</p>
    </note>
  </div2>
</div1>

<div1 id="id-type-promotion-and-operator-mapping">
<head>Type Promotion and Operator Mapping</head>

<div2 id="promotion">
<head>Type Promotion</head>

<p>
          <termdef term="type promotion" id="dt-type-promotion">Under certain circumstances, an atomic value can be promoted from
one type to another. <term>Type promotion</term> is used in evaluating function calls (see <specref ref="id-function-calls"/>)<phrase role="xquery">, <code>order by</code> clauses (see <specref ref="id-order-by-clause"/>),</phrase>  and operators that accept numeric or string operands (see <specref ref="mapping"/>).</termdef> The following type promotions are permitted:</p>

<olist>
<item>
            <p>Numeric type promotion:</p>
            <olist>
<item>
                <p>A value of type <code>xs:float</code> (or any type
derived by restriction from <code>xs:float</code>) can be promoted to
the type <code>xs:double</code>. The result is the
<code>xs:double</code> value that is the same as the original
value.</p>
              </item>


<item>
                <p>A value of type <code>xs:decimal</code> (or any type derived
by restriction from <code>xs:decimal</code>) can be promoted to either
of the types <code>xs:float</code> or <code>xs:double</code>.  The
result of this promotion is created by casting the original value to
the required type. This kind of promotion may cause loss of
precision.</p>
              </item>
            </olist>
          </item>
<item>
            <p>URI type promotion: A value of type <code>xs:anyURI</code> (or any type derived by restriction from <code>xs:anyURI</code>) can be promoted to the type <code>xs:string</code>. The result of this promotion is created by casting the original value to the type <code>xs:string</code>.</p>
            <note>
              <p>Since <code>xs:anyURI</code> values can be promoted to <code>xs:string</code>, functions and operators that compare strings using the <termref def="dt-def-collation">default collation</termref> also compare <code>xs:anyURI</code> values using the <termref def="dt-def-collation">default collation</termref>. This ensures that orderings that include strings, <code>xs:anyURI</code> values, or any combination of the two types are consistent and well-defined.</p>
            </note>
          </item>


</olist>
<p>Note that <termref def="dt-type-promotion">type promotion</termref> is different from <termref def="dt-subtype-substitution">subtype substitution</termref>. For example:</p>
        <ulist>
<item>
            <p>A function that expects a parameter <code>$p</code> of type <code>xs:float</code> can be invoked with a value of type <code>xs:decimal</code>. This is an example of <termref def="dt-type-promotion">type promotion</termref>. The value is actually converted to the expected type. Within the body of the function, <code>$p instance of xs:decimal</code> returns <code>false</code>.</p>
          </item>
<item>
            <p>A function that expects a parameter <code>$p</code> of type <code>xs:decimal</code> can be invoked with a value of type <code>xs:integer</code>. This is an example of <termref def="dt-subtype-substitution">subtype substitution</termref>. The value retains its original type. Within the body of the function, <code>$p instance of xs:integer</code> returns <code>true</code>.</p>
          </item>
        </ulist>
      </div2>

<div2 id="mapping">
<head>Operator Mapping</head> <p>The operator mapping tables in this section list the
combinations of types for which the various operators of XQuery 1.1
are defined. <termdef term="operator function" id="dt-operator-function">For each operator and valid combination of operand types, the operator mapping tables specify a result type and an <term>operator function</term> that implements the semantics of the operator for the given types.</termdef> The definitions of the operator functions are given in  <bibref ref="xpath-functions-11"/>. The result of an operator may be the raising of an error by its operator function, as defined in <bibref ref="xpath-functions-11"/>. In some cases, the operator function does not implement the full semantics of
a given operator. For the definition of each operator (including its
behavior for empty sequences or sequences of length greater than one),
see the descriptive material in the main part of this
document.</p>
        <p>The <code>and</code> and
<code>or</code> operators are defined directly in the main body of
this document, and do not occur in the operator mapping tables.</p>
        <p>If an operator in the operator mapping tables expects an operand of type 
<emph>ET</emph>, that operator can be applied to an operand of type <emph>AT</emph> if type <emph>AT</emph> can 
be converted to type <emph>ET</emph> by a combination of <termref def="dt-type-promotion">type promotion</termref> and <termref def="dt-subtype-substitution">subtype substitution</termref>. For example, a table entry indicates that the <code>gt</code> operator may
be applied to two <code>xs:date</code> operands, returning
<code>xs:boolean</code>. Therefore, the <code>gt</code> operator may
also be applied to two (possibly different) subtypes of
<code>xs:date</code>, also returning <code>xs:boolean</code>.</p>
        <p>
          <termdef id="dt-numeric" term="numeric">When referring to a type, the term <term>numeric</term> denotes the types
<code>xs:integer</code>, <code>xs:decimal</code>,
<code>xs:float</code>, and <code>xs:double</code>.</termdef> An operator whose
operands and result are designated as <termref def="dt-numeric">numeric</termref> might be
thought of as representing four operators, one for each of the numeric
types. For example, the numeric <code>+</code> operator might be
thought of as representing the following four operators:</p>


<table width="80%" border="1" summary="Operators">
          <tbody>
<tr>
              <td align="center" rowspan="1" colspan="1">Operator</td>
              <td align="center" rowspan="1" colspan="1">First operand type</td>
              <td align="center" rowspan="1" colspan="1">Second operand type</td>
              <td align="center" rowspan="1" colspan="1">Result type</td>
            </tr>
<tr>
              <td align="center" rowspan="1" colspan="1">
                <code>+</code>
              </td>
              <td align="center" rowspan="1" colspan="1">
                <code>xs:integer</code>
              </td>
              <td align="center" rowspan="1" colspan="1">
                <code>xs:integer</code>
              </td>
              <td align="center" rowspan="1" colspan="1">
                <code>xs:integer</code>
              </td>
            </tr>
<tr>
              <td align="center" rowspan="1" colspan="1">
                <code>+</code>
              </td>
              <td align="center" rowspan="1" colspan="1">
                <code>xs:decimal</code>
              </td>
              <td align="center" rowspan="1" colspan="1">
                <code>xs:decimal</code>
              </td>
              <td align="center" rowspan="1" colspan="1">
                <code>xs:decimal</code>
              </td>
            </tr>
<tr>
              <td align="center" rowspan="1" colspan="1">
                <code>+</code>
              </td>
              <td align="center" rowspan="1" colspan="1">
                <code>xs:float</code>
              </td>
              <td align="center" rowspan="1" colspan="1">
                <code>xs:float</code>
              </td>
              <td align="center" rowspan="1" colspan="1">
                <code>xs:float</code>
              </td>
            </tr>
<tr>
              <td align="center" rowspan="1" colspan="1">
                <code>+</code>
              </td>
              <td align="center" rowspan="1" colspan="1">
                <code>xs:double</code>
              </td>
              <td align="center" rowspan="1" colspan="1">
                <code>xs:double</code>
              </td>
              <td align="center" rowspan="1" colspan="1">
                <code>xs:double</code>
              </td>
            </tr>
          </tbody>
        </table>
        <p>A numeric operator may be validly applied to an operand of type <emph>AT</emph> if type 
<emph>AT</emph> can be converted to any of the four numeric types by a combination of 
<termref def="dt-type-promotion">type promotion</termref> and <termref def="dt-subtype-substitution">subtype substitution</termref>. If the result type of an 
operator is listed as numeric, it means "the first type in the ordered list <code>(xs:integer, xs:decimal, xs:float, xs:double)</code> into which all operands can be converted by <termref def="dt-subtype-substitution">subtype substitution</termref> and <termref def="dt-type-promotion">type promotion</termref>." As an example, suppose that the type <code>hatsize</code> is derived from <code>xs:integer</code> and the type <code>shoesize</code> is derived from <code>xs:float</code>.   Then if the <code>+</code> operator is invoked with operands of type <code>hatsize</code> and <code>shoesize</code>, it returns a result of type <code>xs:float</code>.  Similarly, if <code>+</code> is invoked with two operands of type <code>hatsize</code> it returns a result of type <code>xs:integer</code>.</p>
        <p>
          <termdef id="dt-gregorian" term="Gregorian">In the operator mapping tables,
the term <term>Gregorian</term> refers to the types
<code>xs:gYearMonth</code>, <code>xs:gYear</code>,
<code>xs:gMonthDay</code>, <code>xs:gDay</code>, and
<code>xs:gMonth</code>.</termdef>  For binary operators that accept two
Gregorian-type operands, both operands must have the same type (for
example, if one operand is of type <code>xs:gDay</code>, the other
operand must be of type <code>xs:gDay</code>.)</p>

<table border="1" summary="Binary operators" role="small">
<caption>Binary Operators</caption>
<tbody>

<tr>
<th rowspan="1" colspan="1">Operator</th>
<th rowspan="1" colspan="1">Type(A)</th>
<th rowspan="1" colspan="1">Type(B)</th>
<th rowspan="1" colspan="1">Function</th>
<th rowspan="1" colspan="1">Result type</th>
</tr>

<tr>
              <td rowspan="1" colspan="1">A + B</td>
              <td rowspan="1" colspan="1">numeric</td>
              <td rowspan="1" colspan="1">numeric</td>
              <td rowspan="1" colspan="1">op:numeric-add(A, B)</td>
              <td rowspan="1" colspan="1">numeric</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A + B</td>
              <td rowspan="1" colspan="1">xs:date</td>
              <td rowspan="1" colspan="1">xs:yearMonthDuration</td>
              <td rowspan="1" colspan="1">op:add-yearMonthDuration-to-date(A, B)</td>
              <td rowspan="1" colspan="1">xs:date</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A + B</td>
              <td rowspan="1" colspan="1">xs:yearMonthDuration</td>
              <td rowspan="1" colspan="1">xs:date</td>
              <td rowspan="1" colspan="1">op:add-yearMonthDuration-to-date(B, A)</td>
              <td rowspan="1" colspan="1">xs:date</td>
            </tr>
<tr>
              <td rowspan="1" colspan="1">A + B</td>
              <td rowspan="1" colspan="1">xs:date</td>
              <td rowspan="1" colspan="1">xs:dayTimeDuration</td>
              <td rowspan="1" colspan="1">op:add-dayTimeDuration-to-date(A, B)</td>
              <td rowspan="1" colspan="1">xs:date</td>
            </tr>
<tr>
              <td rowspan="1" colspan="1">A + B</td>
              <td rowspan="1" colspan="1">xs:dayTimeDuration</td>
              <td rowspan="1" colspan="1">xs:date</td>
              <td rowspan="1" colspan="1">op:add-dayTimeDuration-to-date(B, A)</td>
              <td rowspan="1" colspan="1">xs:date</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A + B</td>
              <td rowspan="1" colspan="1">xs:time</td>
              <td rowspan="1" colspan="1">xs:dayTimeDuration</td>
              <td rowspan="1" colspan="1">op:add-dayTimeDuration-to-time(A, B)</td>
              <td rowspan="1" colspan="1">xs:time</td>
            </tr>
<tr>
              <td rowspan="1" colspan="1">A + B</td>
              <td rowspan="1" colspan="1">xs:dayTimeDuration</td>
              <td rowspan="1" colspan="1">xs:time</td>
              <td rowspan="1" colspan="1">op:add-dayTimeDuration-to-time(B, A)</td>
              <td rowspan="1" colspan="1">xs:time</td>
            </tr>


<tr>
              <td rowspan="1" colspan="1">A + B</td>
              <td rowspan="1" colspan="1">xs:dateTime</td>
              <td rowspan="1" colspan="1">xs:yearMonthDuration</td>
              <td rowspan="1" colspan="1">op:add-yearMonthDuration-to-dateTime(A, B)</td>
              <td rowspan="1" colspan="1">xs:dateTime</td>
            </tr>
<tr>
              <td rowspan="1" colspan="1">A + B</td>
              <td rowspan="1" colspan="1">xs:yearMonthDuration</td>
              <td rowspan="1" colspan="1">xs:dateTime</td>
              <td rowspan="1" colspan="1">op:add-yearMonthDuration-to-dateTime(B, A)</td>
              <td rowspan="1" colspan="1">xs:dateTime</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A + B</td>
              <td rowspan="1" colspan="1">xs:dateTime</td>
              <td rowspan="1" colspan="1">xs:dayTimeDuration</td>
              <td rowspan="1" colspan="1">op:add-dayTimeDuration-to-dateTime(A, B)</td>
              <td rowspan="1" colspan="1">xs:dateTime</td>
            </tr>
<tr>
              <td rowspan="1" colspan="1">A + B</td>
              <td rowspan="1" colspan="1">xs:dayTimeDuration</td>
              <td rowspan="1" colspan="1">xs:dateTime</td>
              <td rowspan="1" colspan="1">op:add-dayTimeDuration-to-dateTime(B, A)</td>
              <td rowspan="1" colspan="1">xs:dateTime</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A + B</td>
              <td rowspan="1" colspan="1">xs:yearMonthDuration</td>
              <td rowspan="1" colspan="1">xs:yearMonthDuration</td>
              <td rowspan="1" colspan="1">op:add-yearMonthDurations(A, B)</td>
              <td rowspan="1" colspan="1">xs:yearMonthDuration</td>
            </tr>
<tr>
              <td rowspan="1" colspan="1">A + B</td>
              <td rowspan="1" colspan="1">xs:dayTimeDuration</td>
              <td rowspan="1" colspan="1">xs:dayTimeDuration</td>
              <td rowspan="1" colspan="1">op:add-dayTimeDurations(A, B)</td>
              <td rowspan="1" colspan="1">xs:dayTimeDuration</td>
            </tr>


<tr>
              <td rowspan="1" colspan="1">A - B</td>
              <td rowspan="1" colspan="1">numeric</td>
              <td rowspan="1" colspan="1">numeric</td>
              <td rowspan="1" colspan="1">op:numeric-subtract(A, B)</td>
              <td rowspan="1" colspan="1">numeric</td>
            </tr>


<tr>
              <td rowspan="1" colspan="1">A - B</td>
              <td rowspan="1" colspan="1">xs:date</td>
              <td rowspan="1" colspan="1">xs:date</td>
              <td rowspan="1" colspan="1">op:subtract-dates(A, B)</td>
              <td rowspan="1" colspan="1">xs:dayTimeDuration</td>
            </tr>
<tr>
              <td rowspan="1" colspan="1">A - B</td>
              <td rowspan="1" colspan="1">xs:date</td>
              <td rowspan="1" colspan="1">xs:yearMonthDuration</td>
              <td rowspan="1" colspan="1">op:subtract-yearMonthDuration-from-date(A, B)</td>
              <td rowspan="1" colspan="1">xs:date</td>
            </tr>
<tr>
              <td rowspan="1" colspan="1">A - B</td>
              <td rowspan="1" colspan="1">xs:date</td>
              <td rowspan="1" colspan="1">xs:dayTimeDuration</td>
              <td rowspan="1" colspan="1">op:subtract-dayTimeDuration-from-date(A, B)</td>
              <td rowspan="1" colspan="1">xs:date</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A - B</td>
              <td rowspan="1" colspan="1">xs:time</td>
              <td rowspan="1" colspan="1">xs:time</td>
              <td rowspan="1" colspan="1">op:subtract-times(A, B)</td>
              <td rowspan="1" colspan="1">xs:dayTimeDuration</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A - B</td>
              <td rowspan="1" colspan="1">xs:time</td>
              <td rowspan="1" colspan="1">xs:dayTimeDuration</td>
              <td rowspan="1" colspan="1">op:subtract-dayTimeDuration-from-time(A, B)</td>
              <td rowspan="1" colspan="1">xs:time</td>
            </tr>


<tr>
              <td rowspan="1" colspan="1">A - B</td>
              <td rowspan="1" colspan="1">xs:dateTime</td>
              <td rowspan="1" colspan="1">xs:dateTime</td>
              <td rowspan="1" colspan="1">op:subtract-dateTimes(A, B)</td>
              <td rowspan="1" colspan="1">xs:dayTimeDuration</td>
            </tr>
<tr>
              <td rowspan="1" colspan="1">A - B</td>
              <td rowspan="1" colspan="1">xs:dateTime</td>
              <td rowspan="1" colspan="1">xs:yearMonthDuration</td>
              <td rowspan="1" colspan="1">op:subtract-yearMonthDuration-from-dateTime(A, B)</td>
              <td rowspan="1" colspan="1">xs:dateTime</td>
            </tr>
<tr>
              <td rowspan="1" colspan="1">A - B</td>
              <td rowspan="1" colspan="1">xs:dateTime</td>
              <td rowspan="1" colspan="1">xs:dayTimeDuration</td>
              <td rowspan="1" colspan="1">op:subtract-dayTimeDuration-from-dateTime(A, B)</td>
              <td rowspan="1" colspan="1">xs:dateTime</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A - B</td>
              <td rowspan="1" colspan="1">xs:yearMonthDuration</td>
              <td rowspan="1" colspan="1">xs:yearMonthDuration</td>
              <td rowspan="1" colspan="1">op:subtract-yearMonthDurations(A, B)</td>
              <td rowspan="1" colspan="1">xs:yearMonthDuration</td>
            </tr>
<tr>
              <td rowspan="1" colspan="1">A - B</td>
              <td rowspan="1" colspan="1">xs:dayTimeDuration</td>
              <td rowspan="1" colspan="1">xs:dayTimeDuration</td>
              <td rowspan="1" colspan="1">op:subtract-dayTimeDurations(A, B)</td>
              <td rowspan="1" colspan="1">xs:dayTimeDuration</td>
            </tr>


<tr>
              <td rowspan="1" colspan="1">A * B</td>
              <td rowspan="1" colspan="1">numeric</td>
              <td rowspan="1" colspan="1">numeric</td>
              <td rowspan="1" colspan="1">op:numeric-multiply(A, B)</td>
              <td rowspan="1" colspan="1">numeric</td>
            </tr>
<tr>
              <td rowspan="1" colspan="1">A * B</td>
              <td rowspan="1" colspan="1">xs:yearMonthDuration</td>
              <td rowspan="1" colspan="1">numeric</td>
              <td rowspan="1" colspan="1">op:multiply-yearMonthDuration(A, B)</td>
              <td rowspan="1" colspan="1">xs:yearMonthDuration</td>
            </tr>
<tr>
              <td rowspan="1" colspan="1">A * B</td>
              <td rowspan="1" colspan="1">numeric</td>
              <td rowspan="1" colspan="1">xs:yearMonthDuration</td>
              <td rowspan="1" colspan="1">op:multiply-yearMonthDuration(B, A)</td>
              <td rowspan="1" colspan="1">xs:yearMonthDuration</td>
            </tr>
<tr>
              <td rowspan="1" colspan="1">A * B</td>
              <td rowspan="1" colspan="1">xs:dayTimeDuration</td>
              <td rowspan="1" colspan="1">numeric</td>
              <td rowspan="1" colspan="1">op:multiply-dayTimeDuration(A, B)</td>
              <td rowspan="1" colspan="1">xs:dayTimeDuration</td>
            </tr>
<tr>
              <td rowspan="1" colspan="1">A * B</td>
              <td rowspan="1" colspan="1">numeric</td>
              <td rowspan="1" colspan="1">xs:dayTimeDuration</td>
              <td rowspan="1" colspan="1">op:multiply-dayTimeDuration(B, A)</td>
              <td rowspan="1" colspan="1">xs:dayTimeDuration</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A idiv B</td>
              <td rowspan="1" colspan="1">numeric</td>
              <td rowspan="1" colspan="1">numeric</td>
              <td rowspan="1" colspan="1">op:numeric-integer-divide(A, B)</td>
              <td rowspan="1" colspan="1">xs:integer</td>
            </tr>
<tr>
              <td rowspan="1" colspan="1">A div B</td>
              <td rowspan="1" colspan="1">numeric</td>
              <td rowspan="1" colspan="1">numeric</td>
              <td rowspan="1" colspan="1">op:numeric-divide(A, B)</td>
              <td rowspan="1" colspan="1">numeric; but xs:decimal if both operands are xs:integer</td>
            </tr>
<tr>
              <td rowspan="1" colspan="1">A div B</td>
              <td rowspan="1" colspan="1">xs:yearMonthDuration</td>
              <td rowspan="1" colspan="1">numeric</td>
              <td rowspan="1" colspan="1">op:divide-yearMonthDuration(A, B)</td>
              <td rowspan="1" colspan="1">xs:yearMonthDuration</td>
            </tr>
<tr>
              <td rowspan="1" colspan="1">A div B</td>
              <td rowspan="1" colspan="1">xs:dayTimeDuration</td>
              <td rowspan="1" colspan="1">numeric</td>
              <td rowspan="1" colspan="1">op:divide-dayTimeDuration(A, B)</td>
              <td rowspan="1" colspan="1">xs:dayTimeDuration</td>
            </tr>
<tr>
              <td rowspan="1" colspan="1">A div B</td>
              <td rowspan="1" colspan="1">xs:yearMonthDuration</td>
              <td rowspan="1" colspan="1">xs:yearMonthDuration</td>
              <td rowspan="1" colspan="1">op:divide-yearMonthDuration-by-yearMonthDuration (A, B)</td>
              <td rowspan="1" colspan="1">xs:decimal</td>
            </tr>
<tr>
              <td rowspan="1" colspan="1">A div B</td>
              <td rowspan="1" colspan="1">xs:dayTimeDuration</td>
              <td rowspan="1" colspan="1">xs:dayTimeDuration</td>
              <td rowspan="1" colspan="1">op:divide-dayTimeDuration-by-dayTimeDuration (A, B)</td>
              <td rowspan="1" colspan="1">xs:decimal</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A mod B</td>
              <td rowspan="1" colspan="1">numeric</td>
              <td rowspan="1" colspan="1">numeric</td>
              <td rowspan="1" colspan="1">op:numeric-mod(A, B)</td>
              <td rowspan="1" colspan="1">numeric</td>
            </tr>


<tr>
              <td rowspan="1" colspan="1">A eq B</td>
              <td rowspan="1" colspan="1">numeric</td>
              <td rowspan="1" colspan="1">numeric</td>
              <td rowspan="1" colspan="1">op:numeric-equal(A, B)</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A eq B</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
              <td rowspan="1" colspan="1">op:boolean-equal(A, B)</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A eq B</td>
              <td rowspan="1" colspan="1">xs:string</td>
              <td rowspan="1" colspan="1">xs:string</td>
              <td rowspan="1" colspan="1">op:numeric-equal(fn:compare(A, B), 0)</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A eq B</td>
              <td rowspan="1" colspan="1">xs:date</td>
              <td rowspan="1" colspan="1">xs:date</td>
              <td rowspan="1" colspan="1">op:date-equal(A, B)</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A eq B</td>
              <td rowspan="1" colspan="1">xs:time</td>
              <td rowspan="1" colspan="1">xs:time</td>
              <td rowspan="1" colspan="1">op:time-equal(A, B)</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A eq B</td>
              <td rowspan="1" colspan="1">xs:dateTime</td>
              <td rowspan="1" colspan="1">xs:dateTime</td>
              <td rowspan="1" colspan="1">op:dateTime-equal(A, B)</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A eq B</td>
              <td rowspan="1" colspan="1">xs:duration</td>
              <td rowspan="1" colspan="1">xs:duration</td>
              <td rowspan="1" colspan="1">op:duration-equal(A, B)</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A eq B</td>
              <td rowspan="1" colspan="1">Gregorian</td>
              <td rowspan="1" colspan="1">Gregorian</td>
              <td rowspan="1" colspan="1">op:gYear-equal(A, B) etc.</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A eq B</td>
              <td rowspan="1" colspan="1">xs:hexBinary</td>
              <td rowspan="1" colspan="1">xs:hexBinary</td>
              <td rowspan="1" colspan="1">op:hexBinary-equal(A, B)</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A eq B</td>
              <td rowspan="1" colspan="1">xs:base64Binary</td>
              <td rowspan="1" colspan="1">xs:base64Binary</td>
              <td rowspan="1" colspan="1">op:base64Binary-equal(A, B)</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A eq B</td>
              <td rowspan="1" colspan="1">xs:anyURI</td>
              <td rowspan="1" colspan="1">xs:anyURI</td>
              <td rowspan="1" colspan="1">op:numeric-equal(fn:compare(A, B), 0)</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A eq B</td>
              <td rowspan="1" colspan="1">xs:QName</td>
              <td rowspan="1" colspan="1">xs:QName</td>
              <td rowspan="1" colspan="1">op:QName-equal(A, B)</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>
<tr>
              <td rowspan="1" colspan="1">A eq B</td>
              <td rowspan="1" colspan="1">xs:NOTATION</td>
              <td rowspan="1" colspan="1">xs:NOTATION</td>
              <td rowspan="1" colspan="1">op:NOTATION-equal(A, B)</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>


<tr>
              <td rowspan="1" colspan="1">A ne B</td>
              <td rowspan="1" colspan="1">numeric</td>
              <td rowspan="1" colspan="1">numeric</td>
              <td rowspan="1" colspan="1">fn:not(op:numeric-equal(A, B))</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A ne B</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
              <td rowspan="1" colspan="1">fn:not(op:boolean-equal(A, B))</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A ne B</td>
              <td rowspan="1" colspan="1">xs:string</td>
              <td rowspan="1" colspan="1">xs:string</td>
              <td rowspan="1" colspan="1">fn:not(op:numeric-equal(fn:compare(A, B), 0))</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A ne B</td>
              <td rowspan="1" colspan="1">xs:date</td>
              <td rowspan="1" colspan="1">xs:date</td>
              <td rowspan="1" colspan="1">fn:not(op:date-equal(A, B))</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A ne B</td>
              <td rowspan="1" colspan="1">xs:time</td>
              <td rowspan="1" colspan="1">xs:time</td>
              <td rowspan="1" colspan="1">fn:not(op:time-equal(A, B))</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A ne B</td>
              <td rowspan="1" colspan="1">xs:dateTime</td>
              <td rowspan="1" colspan="1">xs:dateTime</td>
              <td rowspan="1" colspan="1">fn:not(op:dateTime-equal(A, B))</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A ne B</td>
              <td rowspan="1" colspan="1">xs:duration</td>
              <td rowspan="1" colspan="1">xs:duration</td>
              <td rowspan="1" colspan="1">fn:not(op:duration-equal(A, B))</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A ne B</td>
              <td rowspan="1" colspan="1">Gregorian</td>
              <td rowspan="1" colspan="1">Gregorian</td>
              <td rowspan="1" colspan="1">fn:not(op:gYear-equal(A, B)) etc.</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A ne B</td>
              <td rowspan="1" colspan="1">xs:hexBinary</td>
              <td rowspan="1" colspan="1">xs:hexBinary</td>
              <td rowspan="1" colspan="1">fn:not(op:hexBinary-equal(A, B))</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A ne B</td>
              <td rowspan="1" colspan="1">xs:base64Binary</td>
              <td rowspan="1" colspan="1">xs:base64Binary</td>
              <td rowspan="1" colspan="1">fn:not(op:base64Binary-equal(A, B))</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A ne B</td>
              <td rowspan="1" colspan="1">xs:anyURI</td>
              <td rowspan="1" colspan="1">xs:anyURI</td>
              <td rowspan="1" colspan="1">fn:not(op:numeric-equal(fn:compare(A, B), 0))</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A ne B</td>
              <td rowspan="1" colspan="1">xs:QName</td>
              <td rowspan="1" colspan="1">xs:QName</td>
              <td rowspan="1" colspan="1">fn:not(op:QName-equal(A, B))</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>


<tr>
              <td rowspan="1" colspan="1">A ne B</td>
              <td rowspan="1" colspan="1">xs:NOTATION</td>
              <td rowspan="1" colspan="1">xs:NOTATION</td>
              <td rowspan="1" colspan="1">fn:not(op:NOTATION-equal(A, B))</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>


<tr>
              <td rowspan="1" colspan="1">A gt B</td>
              <td rowspan="1" colspan="1">numeric</td>
              <td rowspan="1" colspan="1">numeric</td>
              <td rowspan="1" colspan="1">op:numeric-greater-than(A, B)</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A gt B</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
              <td rowspan="1" colspan="1">op:boolean-greater-than(A, B)</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A gt B</td>
              <td rowspan="1" colspan="1">xs:string</td>
              <td rowspan="1" colspan="1">xs:string</td>
              <td rowspan="1" colspan="1">op:numeric-greater-than(fn:compare(A, B), 0)</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A gt B</td>
              <td rowspan="1" colspan="1">xs:date</td>
              <td rowspan="1" colspan="1">xs:date</td>
              <td rowspan="1" colspan="1">op:date-greater-than(A, B)</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A gt B</td>
              <td rowspan="1" colspan="1">xs:time</td>
              <td rowspan="1" colspan="1">xs:time</td>
              <td rowspan="1" colspan="1">op:time-greater-than(A, B)</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A gt B</td>
              <td rowspan="1" colspan="1">xs:dateTime</td>
              <td rowspan="1" colspan="1">xs:dateTime</td>
              <td rowspan="1" colspan="1">op:dateTime-greater-than(A, B)</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A gt B</td>
              <td rowspan="1" colspan="1">xs:yearMonthDuration</td>
              <td rowspan="1" colspan="1">xs:yearMonthDuration</td>
              <td rowspan="1" colspan="1">op:yearMonthDuration-greater-than(A, B)</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>
<tr>
              <td rowspan="1" colspan="1">A gt B</td>
              <td rowspan="1" colspan="1">xs:dayTimeDuration</td>
              <td rowspan="1" colspan="1">xs:dayTimeDuration</td>
              <td rowspan="1" colspan="1">op:dayTimeDuration-greater-than(A, B)</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>
<tr>
              <td rowspan="1" colspan="1">A gt B</td>
              <td rowspan="1" colspan="1">xs:anyURI</td>
              <td rowspan="1" colspan="1">xs:anyURI</td>
              <td rowspan="1" colspan="1">op:numeric-greater-than(fn:compare(A, B), 0)</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>


<tr>
              <td rowspan="1" colspan="1">A lt B</td>
              <td rowspan="1" colspan="1">numeric</td>
              <td rowspan="1" colspan="1">numeric</td>
              <td rowspan="1" colspan="1">op:numeric-less-than(A, B)</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A lt B</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
              <td rowspan="1" colspan="1">op:boolean-less-than(A, B)</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A lt B</td>
              <td rowspan="1" colspan="1">xs:string</td>
              <td rowspan="1" colspan="1">xs:string</td>
              <td rowspan="1" colspan="1">op:numeric-less-than(fn:compare(A, B), 0)</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A lt B</td>
              <td rowspan="1" colspan="1">xs:date</td>
              <td rowspan="1" colspan="1">xs:date</td>
              <td rowspan="1" colspan="1">op:date-less-than(A, B)</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A lt B</td>
              <td rowspan="1" colspan="1">xs:time</td>
              <td rowspan="1" colspan="1">xs:time</td>
              <td rowspan="1" colspan="1">op:time-less-than(A, B)</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A lt B</td>
              <td rowspan="1" colspan="1">xs:dateTime</td>
              <td rowspan="1" colspan="1">xs:dateTime</td>
              <td rowspan="1" colspan="1">op:dateTime-less-than(A, B)</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A lt B</td>
              <td rowspan="1" colspan="1">xs:yearMonthDuration</td>
              <td rowspan="1" colspan="1">xs:yearMonthDuration</td>
              <td rowspan="1" colspan="1">op:yearMonthDuration-less-than(A, B)</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>
<tr>
              <td rowspan="1" colspan="1">A lt B</td>
              <td rowspan="1" colspan="1">xs:dayTimeDuration</td>
              <td rowspan="1" colspan="1">xs:dayTimeDuration</td>
              <td rowspan="1" colspan="1">op:dayTimeDuration-less-than(A, B)</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>
<tr>
              <td rowspan="1" colspan="1">A lt B</td>
              <td rowspan="1" colspan="1">xs:anyURI</td>
              <td rowspan="1" colspan="1">xs:anyURI</td>
              <td rowspan="1" colspan="1">op:numeric-less-than(fn:compare(A, B), 0)</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>


<tr>
              <td rowspan="1" colspan="1">A ge B</td>
              <td rowspan="1" colspan="1">numeric</td>
              <td rowspan="1" colspan="1">numeric</td>
              <td rowspan="1" colspan="1">op:numeric-greater-than(A, B) or op:numeric-equal(A, B)</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>
<tr>
              <td rowspan="1" colspan="1">A ge B</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
              <td rowspan="1" colspan="1">fn:not(op:boolean-less-than(A, B))</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A ge B</td>
              <td rowspan="1" colspan="1">xs:string</td>
              <td rowspan="1" colspan="1">xs:string</td>
              <td rowspan="1" colspan="1">op:numeric-greater-than(fn:compare(A, B), -1)</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A ge B</td>
              <td rowspan="1" colspan="1">xs:date</td>
              <td rowspan="1" colspan="1">xs:date</td>
              <td rowspan="1" colspan="1">fn:not(op:date-less-than(A, B))</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A ge B</td>
              <td rowspan="1" colspan="1">xs:time</td>
              <td rowspan="1" colspan="1">xs:time</td>
              <td rowspan="1" colspan="1">fn:not(op:time-less-than(A, B))</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A ge B</td>
              <td rowspan="1" colspan="1">xs:dateTime</td>
              <td rowspan="1" colspan="1">xs:dateTime</td>
              <td rowspan="1" colspan="1">fn:not(op:dateTime-less-than(A, B))</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A ge B</td>
              <td rowspan="1" colspan="1">xs:yearMonthDuration</td>
              <td rowspan="1" colspan="1">xs:yearMonthDuration</td>
              <td rowspan="1" colspan="1">fn:not(op:yearMonthDuration-less-than(A, B))</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>
<tr>
              <td rowspan="1" colspan="1">A ge B</td>
              <td rowspan="1" colspan="1">xs:dayTimeDuration</td>
              <td rowspan="1" colspan="1">xs:dayTimeDuration</td>
              <td rowspan="1" colspan="1">fn:not(op:dayTimeDuration-less-than(A, B))</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>
<tr>
              <td rowspan="1" colspan="1">A ge B</td>
              <td rowspan="1" colspan="1">xs:anyURI</td>
              <td rowspan="1" colspan="1">xs:anyURI</td>
              <td rowspan="1" colspan="1">op:numeric-greater-than(fn:compare(A, B), -1)</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>


<tr>
              <td rowspan="1" colspan="1">A le B</td>
              <td rowspan="1" colspan="1">numeric</td>
              <td rowspan="1" colspan="1">numeric</td>
              <td rowspan="1" colspan="1">op:numeric-less-than(A, B) or op:numeric-equal(A, B)</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>
<tr>
              <td rowspan="1" colspan="1">A le B</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
              <td rowspan="1" colspan="1">fn:not(op:boolean-greater-than(A, B))</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A le B</td>
              <td rowspan="1" colspan="1">xs:string</td>
              <td rowspan="1" colspan="1">xs:string</td>
              <td rowspan="1" colspan="1">op:numeric-less-than(fn:compare(A, B), 1)</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A le B</td>
              <td rowspan="1" colspan="1">xs:date</td>
              <td rowspan="1" colspan="1">xs:date</td>
              <td rowspan="1" colspan="1">fn:not(op:date-greater-than(A, B))</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A le B</td>
              <td rowspan="1" colspan="1">xs:time</td>
              <td rowspan="1" colspan="1">xs:time</td>
              <td rowspan="1" colspan="1">fn:not(op:time-greater-than(A, B))</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A le B</td>
              <td rowspan="1" colspan="1">xs:dateTime</td>
              <td rowspan="1" colspan="1">xs:dateTime</td>
              <td rowspan="1" colspan="1">fn:not(op:dateTime-greater-than(A, B))</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A le B</td>
              <td rowspan="1" colspan="1">xs:yearMonthDuration</td>
              <td rowspan="1" colspan="1">xs:yearMonthDuration</td>
              <td rowspan="1" colspan="1">fn:not(op:yearMonthDuration-greater-than(A, B))</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>
<tr>
              <td rowspan="1" colspan="1">A le B</td>
              <td rowspan="1" colspan="1">xs:dayTimeDuration</td>
              <td rowspan="1" colspan="1">xs:dayTimeDuration</td>
              <td rowspan="1" colspan="1">fn:not(op:dayTimeDuration-greater-than(A, B))</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>
<tr>
              <td rowspan="1" colspan="1">A le B</td>
              <td rowspan="1" colspan="1">xs:anyURI</td>
              <td rowspan="1" colspan="1">xs:anyURI</td>
              <td rowspan="1" colspan="1">op:numeric-less-than(fn:compare(A, B), 1)</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>


<tr>
              <td rowspan="1" colspan="1">A is B</td>
              <td rowspan="1" colspan="1">node()</td>
              <td rowspan="1" colspan="1">node()</td>
              <td rowspan="1" colspan="1">op:is-same-node(A, B)</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>



<tr>
              <td rowspan="1" colspan="1">A &lt;&lt; B</td>
              <td rowspan="1" colspan="1">node()</td>
              <td rowspan="1" colspan="1">node()</td>
              <td rowspan="1" colspan="1">op:node-before(A, B)</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A &gt;&gt; B</td>
              <td rowspan="1" colspan="1">node()</td>
              <td rowspan="1" colspan="1">node()</td>
              <td rowspan="1" colspan="1">op:node-after(A, B)</td>
              <td rowspan="1" colspan="1">xs:boolean</td>
            </tr>




<tr>
              <td rowspan="1" colspan="1">A union B</td>
              <td rowspan="1" colspan="1">node()*</td>
              <td rowspan="1" colspan="1">node()*</td>
              <td rowspan="1" colspan="1">op:union(A, B)</td>
              <td rowspan="1" colspan="1">node()*</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A | B</td>
              <td rowspan="1" colspan="1">node()*</td>
              <td rowspan="1" colspan="1">node()*</td>
              <td rowspan="1" colspan="1">op:union(A, B)</td>
              <td rowspan="1" colspan="1">node()*</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A intersect B</td>
              <td rowspan="1" colspan="1">node()*</td>
              <td rowspan="1" colspan="1">node()*</td>
              <td rowspan="1" colspan="1">op:intersect(A, B)</td>
              <td rowspan="1" colspan="1">node()*</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A except B</td>
              <td rowspan="1" colspan="1">node()*</td>
              <td rowspan="1" colspan="1">node()*</td>
              <td rowspan="1" colspan="1">op:except(A, B)</td>
              <td rowspan="1" colspan="1">node()*</td>
            </tr>


<tr>
              <td rowspan="1" colspan="1">A to B</td>
              <td rowspan="1" colspan="1">xs:integer</td>
              <td rowspan="1" colspan="1">xs:integer</td>
              <td rowspan="1" colspan="1">op:to(A, B)</td>
              <td rowspan="1" colspan="1">xs:integer*</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">A , B</td>
              <td rowspan="1" colspan="1">item()*</td>
              <td rowspan="1" colspan="1">item()*</td>
              <td rowspan="1" colspan="1">op:concatenate(A, B)</td>
              <td rowspan="1" colspan="1">item()*</td>
            </tr>

</tbody>
</table>

<table border="1" summary="Unary operators" role="small">
<caption>Unary Operators</caption>
<tbody>

<tr>
<th rowspan="1" colspan="1">Operator</th>
<th rowspan="1" colspan="1">Operand type</th>
<th rowspan="1" colspan="1">Function</th>
<th rowspan="1" colspan="1">Result type</th>
</tr>

<tr>
              <td rowspan="1" colspan="1">+ A</td>
              <td rowspan="1" colspan="1">numeric</td>
              <td rowspan="1" colspan="1">op:numeric-unary-plus(A)</td>
              <td rowspan="1" colspan="1">numeric</td>
            </tr>

<tr>
              <td rowspan="1" colspan="1">- A</td>
              <td rowspan="1" colspan="1">numeric</td>
              <td rowspan="1" colspan="1">op:numeric-unary-minus(A)</td>
              <td rowspan="1" colspan="1">numeric</td>
            </tr>
</tbody>
</table>


</div2>
</div1>

<div1 role="xquery" id="id-xq-context-components">
  <head>Context Components</head>

  <p>The tables in this section describe how values are assigned to
  the various components of the static context and dynamic context,
  and to the parameters that control the serialization process.</p>

  <p>
        <termdef term="scope of a component" id="dt-scope">The
  <term>scope of a component</term> is the context in which the
  component is associated with a value.</termdef> The following scopes are defined:</p>

  <ulist>
    <item>
          <p>
            <termdef term="global scope" id="td-global-scope">If a
    component has <term>global scope</term>, then every expression in
    the query has the same value for that component, and it can not be
    overwritten by the query module or by an
    expression.</termdef>
          </p>
        </item>

    <item>
          <p> <termdef term="module scope" id="td-module-scope">If a
    component has <term>module scope</term>, then every expression in
    a given module has the same value for that component, and it can
    be overwritten or augmented for a given
    module.</termdef>
          </p>
        </item>

    <item>
          <p>
            <termdef term="lexical scope" id="td-lexical-scope">If a
    component has <term>lexical scope</term>, then it is defined by a
    query expression, and its scope is defined by the semantics of the
    expression that defines it.</termdef>
          </p>
        </item>

    <item>
          <p>
            <termdef term="dynamic scope" id="td-dynamic-scope">If a
    component has <term>dynamic scope</term>, then it is defined by a
    query expression, its scope is defined by the semantics of the
    expression that defines it, and run-time evaluation may influence
    its value.</termdef>
          </p>
        </item>
  </ulist>

<div2 id="id-xq-static-context-components">
<head>Static Context Components</head>

<p>The following table describes the components of the <term>static context</term>. The following aspects of each component are described:</p>

<ulist>
<item>
            <p>
              <emph>Default initial value:</emph> This is the
initial value of the component if it is not overridden or augmented by
the implementation or by a query.</p> </item>
<item>
            <p>
              <emph>Can be
overwritten or augmented by implementation:</emph> Indicates whether
an XQuery implementation is allowed to replace the default initial
value of the component by a different, <termref def="dt-implementation-defined">implementation-defined</termref> value
and/or to augment the default initial value by additional <termref def="dt-implementation-defined">implementation-defined</termref>
values.</p>
          </item>
<item>
            <p>
              <emph>Can be overwritten or augmented by a
query:</emph> Indicates whether a query is allowed to replace and/or
augment the initial value provided by default or by the
implementation. If so, indicates how this is accomplished (for
example, by a declaration in the
prolog).</p>
          </item>
<item>
            <p>
              <emph>Scope:</emph> the <termref def="dt-scope">scope of the
component</termref>.</p>
          </item>
<item>
            <p>
              <emph>Consistency
Rules:</emph> Indicates rules that must be observed in assigning
values to the component. Additional consistency rules may be found in
<specref ref="id-consistency-constraints"/>.</p>
          </item>
        </ulist>

<table width="100%" border="1" summary="Static Context" role="small">
<caption>Static Context Components</caption>
<tbody>

<tr>
<th rowspan="1" colspan="1">Component</th>
<th rowspan="1" colspan="1">Default initial value</th>
<th rowspan="1" colspan="1">Can be overwritten or augmented by implementation?</th>
<th rowspan="1" colspan="1">Can be overwritten or augmented by a query?</th>
<th rowspan="1" colspan="1">Scope</th>
<th rowspan="1" colspan="1">Consistency rules</th>
</tr>

<tr>
<td rowspan="1" colspan="1">XPath 1.0 Compatibility Mode</td>
<td rowspan="1" colspan="1">
                <code>false</code>
              </td>
<td rowspan="1" colspan="1">no</td>
<td rowspan="1" colspan="1">no</td>
<td rowspan="1" colspan="1">global</td>
<td rowspan="1" colspan="1">Must be <code>false</code>.</td>
</tr>
<tr>
<td rowspan="1" colspan="1">Statically known namespaces</td>
<td rowspan="1" colspan="1">
                <code>fn</code>, <code>xml</code>, <code>xs</code>, <code>xsi</code>,  <code>local</code>
              </td>
<td rowspan="1" colspan="1">overwriteable and augmentable (except for <code>xml</code>)</td>
<td rowspan="1" colspan="1">overwriteable and augmentable by prolog or element constructor</td>
<td rowspan="1" colspan="1">lexical</td>
<td rowspan="1" colspan="1">Only one namespace can be assigned to a given prefix
per lexical scope.</td>
</tr>
<tr>
              <td rowspan="1" colspan="1">Default element/type namespace</td>
  <td rowspan="1" colspan="1">no namespace</td>
  <td rowspan="1" colspan="1">overwriteable</td>
  <td rowspan="1" colspan="1">overwriteable by prolog or element constructor</td>
  <td rowspan="1" colspan="1">lexical</td>
  <td rowspan="1" colspan="1">Only one default namespace per lexical scope.</td>
            </tr>
<tr>
  <td rowspan="1" colspan="1">Default function namespace</td>
  <td rowspan="1" colspan="1">
                <code>fn</code>
              </td>
  <td rowspan="1" colspan="1">overwriteable (not recommended)</td>
  <td rowspan="1" colspan="1">overwriteable by prolog</td>
  <td rowspan="1" colspan="1">module</td>
  <td rowspan="1" colspan="1">None.</td>
            </tr>
<tr>
  <td rowspan="1" colspan="1">In-scope schema types</td>
  <td rowspan="1" colspan="1">built-in types in <code>xs</code>
              </td>
  <td rowspan="1" colspan="1">augmentable</td>
  <td rowspan="1" colspan="1">augmentable by schema import in prolog</td>
  <td rowspan="1" colspan="1">module</td>
  <td rowspan="1" colspan="1">Only one definition per global or local type.</td>
            </tr>
<tr>
  <td rowspan="1" colspan="1">In-scope element declarations</td>
  <td rowspan="1" colspan="1">none</td>
  <td rowspan="1" colspan="1">augmentable</td>
  <td rowspan="1" colspan="1">augmentable by schema import in prolog</td>
  <td rowspan="1" colspan="1">module</td>
  <td rowspan="1" colspan="1">Only one definition per global or local element name.</td>
            </tr>
<tr>
  <td rowspan="1" colspan="1">In-scope attribute declarations</td>
  <td rowspan="1" colspan="1">none</td>
  <td rowspan="1" colspan="1">augmentable</td>
  <td rowspan="1" colspan="1">augmentable by schema import in prolog</td>
  <td rowspan="1" colspan="1">module</td>
  <td rowspan="1" colspan="1">Only one definition per global or local attribute name.</td>
            </tr>
<tr>
  <td rowspan="1" colspan="1">In-scope variables</td>
  <td rowspan="1" colspan="1">none</td>
  <td rowspan="1" colspan="1">augmentable</td>
  <td rowspan="1" colspan="1">overwriteable and augmentable by prolog and by variable-binding expressions</td>
  <td rowspan="1" colspan="1">lexical</td>
  <td rowspan="1" colspan="1">Only one definition per variable per lexical scope.</td>
            </tr>

<tr>
  <td rowspan="1" colspan="1">Context item static type</td>
  <td rowspan="1" colspan="1">none</td>
  <td rowspan="1" colspan="1">overwriteable</td>
  <td rowspan="1" colspan="1">overwriteable via a context item declaration, and by expresssions that set the context item</td>
  <td rowspan="1" colspan="1">lexical</td>
  <td rowspan="1" colspan="1">None.</td>
            </tr>
<tr>
  <td rowspan="1" colspan="1">Function signatures</td>
  <td rowspan="1" colspan="1">functions in <code>fn</code> namespace, and constructors for built-in atomic types</td>
  <td rowspan="1" colspan="1">augmentable</td>
  <td diff="chg" rowspan="1" colspan="1">augmentable by module import and by function declaration in prolog; augmentable by schema import (which adds constructor functions for user-defined types)</td>
  <td rowspan="1" colspan="1">module</td>
  <td rowspan="1" colspan="1">Each function must have a unique <termref def="dt-expanded-qname">expanded QName</termref> and number of arguments.</td>
            </tr>
<tr>
  <td rowspan="1" colspan="1">Statically known collations</td>
  <td rowspan="1" colspan="1">only the default collation</td>
  <td rowspan="1" colspan="1">augmentable</td>
  <td rowspan="1" colspan="1">no</td>
  <td rowspan="1" colspan="1">module</td>
  <td rowspan="1" colspan="1">Each URI uniquely identifies a collation.</td>
            </tr>
<tr>
  <td rowspan="1" colspan="1">Default collation</td>
  <td rowspan="1" colspan="1">Unicode codepoint collation</td>
  <td rowspan="1" colspan="1">overwriteable</td>
  <td rowspan="1" colspan="1">overwriteable by prolog</td>
  <td rowspan="1" colspan="1">module</td>
  <td rowspan="1" colspan="1">None.</td>
            </tr>
<tr>
  <td rowspan="1" colspan="1">Construction mode</td>
  <td rowspan="1" colspan="1">
                <code>preserve</code>
              </td>
  <td rowspan="1" colspan="1">overwriteable</td>
  <td rowspan="1" colspan="1">overwriteable by prolog</td>
  <td rowspan="1" colspan="1">module</td>
  <td rowspan="1" colspan="1">Value must be <code>preserve</code> or <code>strip</code>. </td>
            </tr>
<tr>
  <td rowspan="1" colspan="1">Ordering mode</td>
  <td rowspan="1" colspan="1">
                <code>ordered</code>
              </td>
  <td rowspan="1" colspan="1">overwriteable</td>
  <td rowspan="1" colspan="1">overwriteable by prolog or expression</td>
  <td rowspan="1" colspan="1">lexical</td>
  <td rowspan="1" colspan="1">Value must be <code>ordered</code> or <code>unordered</code>.</td>
            </tr>
<tr>
  <td rowspan="1" colspan="1">Default order for empty sequences</td>
  <td rowspan="1" colspan="1">implementation-defined</td>
  <td rowspan="1" colspan="1">overwriteable</td>
  <td rowspan="1" colspan="1">overwriteable by prolog</td>
  <td rowspan="1" colspan="1">module</td>
  <td rowspan="1" colspan="1">Value must be <code>greatest</code> or <code>least</code>.</td>
            </tr>
<tr>
  <td rowspan="1" colspan="1">Boundary-space policy</td>
  <td rowspan="1" colspan="1">
                <code>strip</code>
              </td>
  <td rowspan="1" colspan="1">overwriteable</td>
  <td rowspan="1" colspan="1">overwriteable by prolog</td>
  <td rowspan="1" colspan="1">module</td>
  <td rowspan="1" colspan="1">Value must be <code>preserve</code> or <code>strip</code>. </td>
            </tr>
<tr>
  <td rowspan="1" colspan="1">Copy-namespaces mode</td>
  <td rowspan="1" colspan="1">
                <code>inherit, preserve</code>
              </td>
  <td rowspan="1" colspan="1">overwriteable</td>
  <td rowspan="1" colspan="1">overwriteable by prolog</td>
  <td rowspan="1" colspan="1">module</td>
  <td rowspan="1" colspan="1">Value consists of <code>inherit</code> or <code>no-inherit</code>, and <code>preserve</code> or <code>no-preserve</code>.</td>
            </tr>
<tr>
  <td rowspan="1" colspan="1">Base URI</td>
  <td rowspan="1" colspan="1">See rules in <specref ref="id-base-uri-decl"/>
              </td>
  <td rowspan="1" colspan="1">overwriteable</td>
  <td rowspan="1" colspan="1">overwriteable by prolog</td>
  <td rowspan="1" colspan="1">module</td>
  <td rowspan="1" colspan="1">Value must be a valid lexical representation of the type xs:anyURI.</td>
            </tr>
<tr>
  <td rowspan="1" colspan="1">Statically known documents</td>
  <td rowspan="1" colspan="1">none</td>
  <td rowspan="1" colspan="1">augmentable</td>
  <td rowspan="1" colspan="1">no</td>
  <td rowspan="1" colspan="1">module</td>
  <td rowspan="1" colspan="1">None.</td>
            </tr>
<tr>
  <td rowspan="1" colspan="1">Statically known collections</td>
  <td rowspan="1" colspan="1">none</td>
  <td rowspan="1" colspan="1">augmentable</td>
  <td rowspan="1" colspan="1">no</td>
  <td rowspan="1" colspan="1">module </td>
  <td rowspan="1" colspan="1">None.</td>
            </tr>
<tr>
  <td rowspan="1" colspan="1">Statically known default collection type</td>
  <td rowspan="1" colspan="1">
                <code>node()*</code>
              </td>
  <td rowspan="1" colspan="1">overwriteable</td>
  <td rowspan="1" colspan="1">no</td>
  <td rowspan="1" colspan="1">module</td>
  <td rowspan="1" colspan="1">None.</td>
            </tr>
</tbody>
</table>
      </div2>
<div2 id="id-xq-evaluation-context-components">
  <head>Dynamic Context Components</head>

  <p>The following table describes the components of the <term>dynamic context</term>. The following aspects of each component are described:</p>
        <ulist>
<item>
            <p>
              <emph>Default initial value:</emph> This is the initial value of the component if it is not overridden or augmented by the implementation or by a query.</p> </item>
<item>
            <p>
              <emph>Can be overwritten or augmented by implementation:</emph> Indicates whether an XQuery implementation is allowed to replace the default initial value of the component by a different <termref def="dt-implementation-defined">implementation-defined</termref> value and/or to augment the default initial value by additional <termref def="dt-implementation-defined">implementation-defined</termref> values.</p>
          </item>
<item>
            <p>
              <emph>Can be overwritten or augmented by a query:</emph> Indicates whether a query is allowed to replace and/or augment the initial value provided by default or by the implementation. If so, indicates how this is accomplished.</p>
          </item>
<item>
            <p>
              <emph>Scope:</emph> the <termref def="dt-scope">scope of the
component</termref>.</p>
          </item>
<item>
            <p>
              <emph>Consistency Rules:</emph> Indicates rules that must be observed in assigning values to the component. Additional consistency rules may be found in <specref ref="id-consistency-constraints"/>.</p>
          </item>
        </ulist>
        <table width="100%" border="1" summary="Static Context" role="small">
<caption>Dynamic Context Components</caption>
<tbody>

<tr>
<th rowspan="1" colspan="1">Component</th>
<th rowspan="1" colspan="1">Default initial value</th>
<th rowspan="1" colspan="1">Can be overwritten or augmented by implementation?</th>
<th rowspan="1" colspan="1">Can be overwritten or augmented by a query?</th>
<th rowspan="1" colspan="1">Scope</th>
<th rowspan="1" colspan="1">Consistency rules</th>
</tr>

<tr>

  <td rowspan="1" colspan="1">Context item</td>

  <td rowspan="1" colspan="1">none</td>

  <td rowspan="1" colspan="1">overwriteable</td>

  <td rowspan="1" colspan="1">overwritten during evaluation of path expressions and predicates - initial value may be overwritten with a context item declaration.</td>

  <td rowspan="1" colspan="1">dynamic</td>

  <td rowspan="1" colspan="1">None</td>
</tr>
<tr>

  <td rowspan="1" colspan="1">Context position</td>

  <td rowspan="1" colspan="1">none</td>

  <td rowspan="1" colspan="1">overwriteable </td>

  <td rowspan="1" colspan="1">overwritten during evaluation of path expressions and predicates</td>

  <td rowspan="1" colspan="1">dynamic</td>

  <td rowspan="1" colspan="1">If context item is defined, context position must be &gt;0 and &lt;= context size; else  context position is undefined. </td>
</tr>
<tr>
  <td rowspan="1" colspan="1">Context size</td>
  <td rowspan="1" colspan="1">none</td>
  <td rowspan="1" colspan="1">overwriteable</td>
  <td rowspan="1" colspan="1">overwritten during evaluation of path expressions and predicates</td>
  <td rowspan="1" colspan="1">dynamic</td>
  <td rowspan="1" colspan="1">If context item is defined, context size must be &gt;0; else context size is undefined.</td>
            </tr>
<tr>
  <td rowspan="1" colspan="1">Variable values</td>
  <td rowspan="1" colspan="1">none</td>
  <td rowspan="1" colspan="1">augmentable</td>
  <td rowspan="1" colspan="1">overwriteable and augmentable by prolog and by variable-binding expressions</td>
  <td rowspan="1" colspan="1">dynamic</td>
  <td rowspan="1" colspan="1">Names and values must be consistent with in-scope variables.</td>
            </tr>
<tr>
  <td rowspan="1" colspan="1">Function implementations</td>
  <td rowspan="1" colspan="1">functions in <code>fn</code> namespace, and constructors for built-in atomic types</td>
  <td rowspan="1" colspan="1">augmentable</td>
  <td diff="chg" rowspan="1" colspan="1">augmentable by module import and by function declaration in prolog; augmentable by schema import (which adds constructor functions for user-defined types)</td>
  <td rowspan="1" colspan="1">global</td>
  <td rowspan="1" colspan="1">Must be consistent with function signatures</td>
            </tr>
<tr>
  <td rowspan="1" colspan="1">Current dateTime</td>
  <td rowspan="1" colspan="1">none</td>
  <td rowspan="1" colspan="1">must be initialized by implementation</td>
  <td rowspan="1" colspan="1">no</td>
  <td rowspan="1" colspan="1">global</td>
  <td rowspan="1" colspan="1">Must include a timezone. Remains constant during evaluation of a query.</td>
            </tr>
<tr>
  <td rowspan="1" colspan="1">Implicit timezone</td>
  <td rowspan="1" colspan="1">none</td>
  <td rowspan="1" colspan="1">must be initialized by implementation</td>
  <td rowspan="1" colspan="1">no</td>
  <td rowspan="1" colspan="1">global</td>
  <td rowspan="1" colspan="1">Remains constant during evaluation of a query.</td>
            </tr>
<tr>
  <td rowspan="1" colspan="1">Available documents</td>
  <td rowspan="1" colspan="1">none</td>
  <td rowspan="1" colspan="1">must be initialized by implementation</td>
  <td rowspan="1" colspan="1">no</td>
  <td rowspan="1" colspan="1">global</td>
  <td rowspan="1" colspan="1">None</td>
            </tr>
<tr>
  <td rowspan="1" colspan="1">Available collections</td>
  <td rowspan="1" colspan="1">none</td>
  <td rowspan="1" colspan="1">must be initialized by implementation</td>
  <td rowspan="1" colspan="1">no</td>
  <td rowspan="1" colspan="1">global</td>
  <td rowspan="1" colspan="1">None</td>
            </tr>
<tr>
  <td rowspan="1" colspan="1">Default collection</td>
  <td rowspan="1" colspan="1">none</td>
  <td rowspan="1" colspan="1">overwriteable</td>
  <td rowspan="1" colspan="1">no</td>
  <td rowspan="1" colspan="1">global</td>
  <td rowspan="1" colspan="1">None</td>
            </tr>
</tbody>
</table>
      </div2>
<div2 id="id-xq-serialization-parameters">
        <head>Serialization Parameters</head>
        <p>The following table specifies default values for  the parameters that control the process of serializing an <termref def="dt-data-model-instance">XDM instance</termref> into XML notation (<code>method = "xml"</code>). The meanings of the various parameters are defined in <bibref ref="xslt-xquery-serialization-11"/>. For each parameter, an XQuery implementation may (but is not required to) allow a query to override the default value with an option declaration, as discussed in <specref ref="id-serialization"/>.
</p>
        <table border="1" width="60%" summary="Unary operators" role="small">
<caption>Serialization Parameters</caption>
<tbody>

<tr>
<th rowspan="1" colspan="1">Parameter</th>
<th rowspan="1" colspan="1">Default Value</th>
</tr>

<tr>
  <td rowspan="1" colspan="1">byte-order-mark</td>
  <td rowspan="1" colspan="1">implementation-defined</td>
            </tr>
<tr>
  <td rowspan="1" colspan="1">cdata-section-elements</td>
  <td rowspan="1" colspan="1">empty</td>
            </tr>
<tr>
  <td rowspan="1" colspan="1">doctype-public</td>
  <td rowspan="1" colspan="1">(none)</td>
            </tr>
<tr>
  <td rowspan="1" colspan="1">doctype-system</td>
  <td rowspan="1" colspan="1">(none)</td>
            </tr>
<tr>
  <td rowspan="1" colspan="1">encoding</td>
  <td rowspan="1" colspan="1">implementation-defined choice between "utf-8" and "utf-16"</td>
            </tr>

<tr>
  <td rowspan="1" colspan="1">escape-uri-attributes</td>
  <td rowspan="1" colspan="1">(not applicable when method = xml)</td>
            </tr>
<tr>
  <td rowspan="1" colspan="1">include-content-type</td>
  <td rowspan="1" colspan="1">(not applicable when method = xml)</td>
            </tr>
<tr>
  <td rowspan="1" colspan="1">indent</td>
  <td rowspan="1" colspan="1">no</td>
            </tr>
<tr>
  <td rowspan="1" colspan="1">media-type</td>
  <td rowspan="1" colspan="1">implementation-defined</td>
            </tr>
<tr>
  <td rowspan="1" colspan="1">method</td>
  <td rowspan="1" colspan="1">xml</td>
            </tr>
<tr>
  <td rowspan="1" colspan="1">normalization-form</td>
  <td rowspan="1" colspan="1">implementation-defined</td>
            </tr>
<tr>
  <td rowspan="1" colspan="1">omit-xml-declaration</td>
  <td rowspan="1" colspan="1">implementation-defined</td>
            </tr>
<tr>
  <td rowspan="1" colspan="1">standalone</td>
  <td rowspan="1" colspan="1">implementation-defined</td>
            </tr>
<tr>
  <td rowspan="1" colspan="1">suppress-indentation</td>
  <td rowspan="1" colspan="1">empty</td>
            </tr>
<tr>
  <td rowspan="1" colspan="1">undeclare-prefixes</td>
  <td rowspan="1" colspan="1">no</td>
            </tr>
<tr>
  <td rowspan="1" colspan="1">use-character-maps</td>
  <td rowspan="1" colspan="1">empty</td>
            </tr>
<tr>
  <td rowspan="1" colspan="1">version</td>
  <td rowspan="1" colspan="1">implementation-defined</td>
            </tr>
</tbody>
</table>
      </div2>
    </div1>

<div1 id="id-impl-defined-items">
      <head>Implementation-Defined Items</head>
      <p>The following items in this specification are <termref def="dt-implementation-defined">implementation-defined</termref>:</p>
      <olist>
<item>
          <p>The version of Unicode that is used to construct expressions.</p>
        </item>
<item>
          <p>The <termref def="dt-static-collations">statically-known collations</termref>.</p>
        </item>
<item>
          <p>The <termref def="dt-timezone">implicit timezone</termref>.</p>
        </item>
<item>
          <p>The circumstances in which <termref def="dt-warning">warnings</termref> are raised, and the ways in which warnings are handled.</p>
        </item>
<item>
          <p>The method by which errors are reported to the external processing environment.</p>
        </item>
<item diff="chg" at="XQ.E21">
          <p>Whether the implementation is based on the rules of  <bibref ref="XML"/> and <bibref ref="XMLNAMES"/> or the rules of <bibref ref="XML1.1"/> and <bibref ref="XMLNAMES11"/>. One of these sets of rules must be applied consistently by all aspects of the implementation. If the implementation is based on the rules of <bibref ref="XML"/>, the edition used must be at least Third Edition; the edition used is <termref def="dt-implementation-defined">implementation-defined</termref>, but we recommend that implementations use the latest version.</p>
        </item>
<item role="xquery">
          <p>Any components of the <termref def="dt-static-context">static context</termref> or <termref def="dt-dynamic-context">dynamic context</termref> that are overwritten or augmented by the implementation.</p>
        </item>
<!--
<item role="xquery" diff="del"><p>Which of the <termref def="dt-optional-axis">optional axes</termref> are supported by the implementation, if the <termref def="dt-full-axis-feature">Full-Axis Feature</termref> is not supported.</p></item>
-->
<item role="xquery">
          <p>The default handling of empty sequences returned by an ordering key (orderspec) in an <code>order by</code> clause (<code>empty least</code> or <code>empty greatest</code>).</p>
        </item>
        <item role="xquery">
          <p>The names and semantics of any <termref def="dt-extension-expression">extension expressions</termref> (<termref def="dt-pragma">pragmas</termref>) recognized by the implementation.</p>
        </item>
        <item role="xquery">
          <p>The names and semantics of any <termref def="dt-option-declaration">option declarations</termref>  recognized by the implementation.</p>
        </item>
        <item role="xquery">
          <p>Protocols (if any) by which parameters can be passed to an external function, and the result of the function can returned to the invoking query.</p>
        </item>
        <item role="xquery">
          <p>The process by which the specific modules to be imported by a 
<termref def="dt-module-import">module import</termref> are identified, if the <termref def="dt-module-feature">Module Feature</termref> is supported (includes processing of location hints, if any.)</p>
        </item>

<item role="xquery">
          <p>The means by which serialization is invoked, if the <termref def="dt-serialization-feature">Serialization Feature</termref> is supported.</p>
        </item>
        <item role="xquery">
          <p>The default values for the <code>byte-order-mark</code>, <code>encoding</code>, <code>media-type</code>, <code>normalization-form</code>, <code>omit-xml-declaration</code>, <code>standalone</code>, and <code>version</code> parameters, if the <termref def="dt-serialization-feature">Serialization Feature</termref> is supported.</p>
        </item>
        <item role="xquery">
          <p>The result of an unsuccessful call to an external function (for example,
if the function implementation cannot be found or does not return a value
of the declared type).</p>
        </item>
        <item role="xquery">
          <p>Limits on ranges of values for various data types, as enumerated in <specref ref="id-data-model-conformance"/>.</p>
        </item>

<item role="xquery" diff="add" at="XQ.E22">
          <p>Syntactic extensions to XQuery, including both their syntax and semantics, as discussed in <specref ref="id-syntax-extensions"/>.</p>
        </item>

</olist>
      <note>
        <p>Additional <termref def="dt-implementation-defined">implementation-defined</termref> items are listed in <bibref ref="xpath-datamodel-11"/> and <bibref ref="xpath-functions-11"/>.</p>
      </note>
    </div1>
<div1 id="id-references">
<head>References</head>
<div2 id="id-normative-references">
<head>Normative References</head>

<blist>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC2119" key="RFC 2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">S. Bradner. 
      <emph>Key Words for use in RFCs to Indicate Requirement Levels.</emph> IETF RFC 2119. 
      See <loc href="http://rfc.net/rfc2119.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.ietf.org/rfc/rfc2119.txt</loc>.</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC3986" key="RFC3986" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">T. Berners-Lee, R. Fielding, and
      L. Masinter.  <emph>Uniform Resource Identifiers (URI): Generic
      Syntax</emph>. IETF RFC 3986. 
      See <loc href="http://www.ietf.org/rfc/rfc3986.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.ietf.org/rfc/rfc3986.txt</loc>.</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC3987" key="RFC3987" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">M. Duerst and M. Suignard. 
      <emph>Internationalized Resource Identifiers (IRIs)</emph>. 
      IETF RFC 3987. See <loc href="http://www.ietf.org/rfc/rfc3987.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.ietf.org/rfc/rfc3987.txt</loc>.</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="ISO10646" key="ISO/IEC 10646" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ISO (International Organization for Standardization). 
      <emph>ISO/IEC 10646:2003. Information technology—Universal Multiple-Octet Coded Character Set (UCS)</emph>,
      as, from time to time, amended, replaced by a new edition, or expanded by the addition of new parts. 
      [Geneva]: International Organization for Standardization. 
      (See <loc href="http://www.iso.org" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.iso.org</loc> for the latest version.)</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="Unicode" key="Unicode" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">The Unicode Consortium. <emph>The Unicode Standard</emph>
      Reading, Mass.: Addison-Wesley, 2003, as updated from time to time by the publication of new versions. 
      See <loc href="http://www.unicode.org/unicode/standard/versions" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.unicode.org/unicode/standard/versions</loc>
      for the latest version and additional information on versions of the standard and of the Unicode Character Database. 
      The version of Unicode to be used is <termref def="dt-implementation-defined">implementation-defined</termref>,
      but implementations are recommended to use the latest Unicode version.</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XML" key="XML 1.0" diff="chg" at="XQ.E21 and XP.E13" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium.
      <emph>Extensible Markup Language (XML) 1.0.</emph>
      W3C Recommendation.
      See <loc href="http://www.w3.org/TR/REC-xml" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/REC-xml</loc>. 
      The edition of XML 1.0 must be no earlier than the Third Edition;
      the edition used is <termref def="dt-implementation-defined">implementation-defined</termref>,
      but we recommend that implementations use the latest version.
</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XML1.1" key="XML 1.1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium.
      <emph>Extensible Markup Language (XML) 1.1.</emph>
      W3C Recommendation.
      See <loc href="http://www.w3.org/TR/xml11/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xml11/</loc>
</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XMLBASE" key="XML Base" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium. 
      <emph>XML Base.</emph> W3C Recommendation. See
      <loc href="http://www.w3.org/TR/xmlbase/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xmlbase/</loc>
</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XMLNAMES" key="XML Names" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium. 
      <emph>Namespaces in XML.</emph> W3C Recommendation. See
      <loc href="http://www.w3.org/TR/REC-xml-names/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/REC-xml-names/</loc>
</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XMLNAMES11" key="XML Names 1.1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium. 
      <emph>Namespaces in XML 1.1.</emph> W3C Recommendation. See
      <loc href="http://www.w3.org/TR/xml-names11/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xml-names11/</loc>
</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XMLID" key="XML ID" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium. <emph>xml:id Version 1.0.</emph>
      W3C Recommendation. See <loc href="http://www.w3.org/TR/xml-id/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xml-id/</loc>
          </bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XMLSchema" key="XML Schema" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium. 
      <emph>XML Schema, Parts 0, 1, and 2 (Second Edition)</emph>. W3C Recommendation, 28 October 2004. 
      See <loc href="http://www.w3.org/TR/xmlschema-0/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xmlschema-0/</loc>,
      <loc href="http://www.w3.org/TR/xmlschema-1/" id="schema1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xmlschema-1/</loc>,
      and <loc href="http://www.w3.org/TR/xmlschema-2/" id="schema2" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xmlschema-2/</loc>.</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" key="XQuery and XPath Data Model (XDM) 1.1" id="xpath-datamodel-11" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xpath-functions-11" key="XQuery and XPath Functions and Operators 1.1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" key="XSLT and XQuery Serialization 1.1" id="xslt-xquery-serialization-11" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>

</blist>
</div2>
<div2 id="id-non-normative-references">
<head>Non-normative References</head>

<blist>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xquery-11-requirements" key="XQuery 1.1 Requirements" role="xquery" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" key="XML Path Language (XPath) 2.1" id="xpath-21" role="xpath21 xquery xquery11" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>



<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xquery-semantics" key="XQuery 1.0 and XPath 2.0 Formal Semantics" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
					
<bibl xmlns:xlink="http://www.w3.org/1999/xlink" key="XQueryX 1.1" id="xqueryx-11" role="xquery" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xslt-21" key="XSL Transformations (XSLT) Version 2.1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="DOM" key="Document Object Model" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium. <emph>Document Object Model (DOM) Level 3 Core Specification.</emph> W3C Recommendation, April 7, 2004. See <loc href="http://www.w3.org/TR/DOM-Level-3-Core/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/DOM-Level-3-Core/</loc>.</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XINFO" key="XML Infoset" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web
Consortium. <emph>XML Information Set.</emph> W3C Recommendation 24 October 2001. See
<loc href="http://www.w3.org/TR/xml-infoset/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xml-infoset/</loc>
</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" key="XML Path Language (XPath) Version 1.0" id="xpath" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XPTR" key="XPointer" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium. <emph>XML
Pointer Language (XPointer).</emph> W3C Last Call Working Draft 8 January 2001. See <loc href="http://www.w3.org/TR/WD-xptr" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/WD-xptr</loc>
          </bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="UseCases" key="XML Query Use Cases" role="xquery" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide
Web Consortium. <emph>XML Query Use Cases</emph>. W3C Working Draft, 8 June 2006. See <loc href="http://www.w3.org/TR/xquery-use-cases/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xquery-use-cases/</loc>.</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xml11schema10" key="XML 1.1 and Schema 1.0" role="xquery" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide
Web Consortium. <emph>Processing XML 1.0 Documents with XML Schema 1.0 Processors</emph>. W3C Working Group Note, 11 May 2005. See <loc href="http://www.w3.org/TR/xml11schema10/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xml11schema10/</loc>.</bibl>
<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC1738" key="Uniform Resource Locators (URL)" role="xquery" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Internet Engineering Task Force (IETF).  <emph>Uniform Resource Locators (URL)</emph>. Request For Comment No. 1738, Dec. 1994. See <loc href="http://www.ietf.org/rfc/rfc1738.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.ietf.org/rfc/rfc1738.txt</loc>.</bibl>


<bibl xmlns:xlink="http://www.w3.org/1999/xlink" key="ODMG" id="ODMG" role="xquery" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Rick Cattell et al. <emph>The
Object Database Standard: ODMG-93, Release 1.2</emph>. Morgan Kaufmann
Publishers, San Francisco, 1996.</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" key="Quilt" id="Quilt" role="xquery" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Don Chamberlin,
Jonathan Robie, and Daniela Florescu. <emph>Quilt: an XML Query Language for
Heterogeneous Data Sources</emph>.  In <emph>Lecture Notes in Computer
Science</emph>, Springer-Verlag, Dec. 2000.  Also available at <loc href="http://www.almaden.ibm.com/cs/people/chamberlin/quilt_lncs.pdf" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.almaden.ibm.com/cs/people/chamberlin/quilt_lncs.pdf</loc>.
See also <loc href="http://www.almaden.ibm.com/cs/people/chamberlin/quilt.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.almaden.ibm.com/cs/people/chamberlin/quilt.html</loc>.</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" key="XML-QL" id="XML-QL" role="xquery" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Alin Deutsch, Mary Fernandez,
Daniela Florescu, Alon Levy, and Dan Suciu.
<emph>A Query Language for XML</emph>.
</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" key="SQL" id="SQL" role="xquery" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">International Organization for
Standardization (ISO).  <emph>Information Technology — Database Language
SQL</emph>. Standard No. ISO/IEC 9075:2008.  (Available from American
National Standards Institute, New York, NY 10036, (212)
642-4900.)</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" key="XQL" id="XQL" role="xquery" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">J. Robie, J. Lapp, D. Schach. <emph>XML
Query Language (XQL)</emph>. See <loc href="http://www.w3.org/TandS/QL/QL98/pp/xql.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TandS/QL/QL98/pp/xql.html</loc>.</bibl> 

</blist>
</div2>

<div2 id="id-background-material">
        <head>Background Material</head>
<blist>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="CHARMOD" key="Character Model" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium.
<emph>Character Model for the World Wide Web.</emph> W3C Working
Draft. See <loc href="http://www.w3.org/TR/charmod/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/charmod/</loc>.</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xslt" key="XSL Transformations (XSLT) Version 1.0" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="UseCaseQueries" key="Use Case Sample Queries" role="xquery" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Queries
from the XQuery 1.0 Use Cases, presented in a single file.
See
<loc href="http://www.w3.org/TR/xquery-11-use-cases/xquery-11-use-case-queries.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xquery-11-use-cases/xquery-11-use-case-queries.txt</loc>.
</bibl>
			
<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XQueryQueries" key="XQuery Sample Queries" role="xquery" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Queries
from this document, presented in a single file.
See
<loc href="http://www.w3.org/TR/xquery-11-use-cases/xquery-11-wd-queries.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xquery-11-use-cases/xquery-11-wd-queries.txt</loc>.
</bibl>

</blist>
</div2>
</div1>


<div1 id="id-errors">	
<head>Error Conditions</head>	
<error-list>
<error spec="XP" code="0001" class="ST" type="static">
<p>
It is a <termref def="dt-static-error">static error</termref>
if analysis of an 
expression relies on some component of the <termref def="dt-static-context">static context</termref> that has not been 
assigned a value.</p>
        </error>

<error spec="XP" code="0002" class="DY" type="dynamic">
<p>It is a  <termref def="dt-dynamic-error">dynamic error</termref>
if evaluation of an expression relies on some part of the <termref def="dt-dynamic-context">dynamic
context</termref> that has not been assigned a value.</p>
        </error>

<error spec="XP" code="0003" class="ST" type="static">
<p>
It is a <termref def="dt-static-error">static error</termref> if an expression 
is not a valid instance of the grammar defined in <specref ref="id-grammar"/>.</p>
        </error>

<error spec="XP" code="0004" class="TY" type="type">
<p>It is a  <termref def="dt-type-error">type error</termref> 
if, during the <termref def="dt-static-analysis">static analysis phase</termref>, an expression is found to have a <termref def="dt-static-type">static type</termref> that is not appropriate
for the context in which the expression occurs, or during the <termref def="dt-dynamic-evaluation">dynamic evaluation
phase</termref>, the <termref def="dt-dynamic-type">dynamic type</termref> of a value does not match a required type as
specified by the matching rules in <specref ref="id-sequencetype-matching"/>.</p>
        </error>

<error spec="XP" code="0005" class="ST" type="static">
<p>
During the analysis phase,
it is a  <termref def="dt-static-error">static error</termref> 
if the <termref def="dt-static-type">static type</termref> assigned to an expression other than the expression <code>()</code> or <code>data(())</code> is <code>empty-sequence()</code>.</p>
        </error>

<error spec="XP" code="0006" class="TY" type="type">
<p>
(Not currently used.)</p>
        </error>

<error spec="XP" code="0007" class="TY" type="type">
<p>(Not currently used.)</p>
</error>

<error spec="XP" code="0008" class="ST" type="static">
<p>
It is a  <termref def="dt-static-error">static error</termref>  if
an expression refers to an element name, attribute name,  schema type name, namespace prefix,
or variable name that is not defined in the 
<termref def="dt-static-context">static context</termref>, except for an ElementName in an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ElementTest" xlink:type="simple">ElementTest</nt> or an AttributeName in an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AttributeTest" xlink:type="simple">AttributeTest</nt>.</p>
</error>

<error spec="XQ" role="xquery" code="0009" class="ST" type="static">
<p>
An implementation that does not support the Schema Import Feature must raise a  <termref def="dt-static-error">static error</termref> if 
a Prolog contains a schema import.</p>
</error>

<error spec="XP" code="0010" class="ST" type="static">
<p>
An implementation  must raise a  <termref def="dt-static-error">static error</termref> if 
it encounters a reference to an axis that it does not support.</p>
</error>

<error spec="XQ" role="xquery" code="0012" class="ST" type="static">
<p>
It is a  <termref def="dt-static-error">static error</termref> if the set of
definitions contained in all schemas imported by a Prolog do not satisfy the
conditions for schema validity specified in Sections 3 and 5 of
<bibref ref="XMLSchema"/> Part 1--i.e., each definition must
be valid, complete, and unique.</p>
</error>

<error spec="XQ" role="xquery" code="0013" class="ST" type="static">
<p>It is a  <termref def="dt-static-error">static error</termref> 
if an implementation recognizes a pragma but
determines that its content is  invalid.</p>
</error>

<error spec="XQ" role="xquery" code="0014" class="ST" type="static">
<p>(Not currently used.)</p>
</error>

<error spec="XQ" role="xquery" code="0015" class="ST" type="static">
<p>(Not currently used.)</p>
</error>

<error spec="XQ" role="xquery" code="0016" class="ST" type="static">
<p>An implementation that does not support the Module  Feature raises a  <termref def="dt-static-error">static 
error</termref> if it encounters a <termref def="dt-module-declaration">module declaration</termref> or a   <termref def="dt-module-import">module import</termref>.</p>
</error>

<error spec="XP" code="0017" class="ST" type="static">
<p>
It is a <termref def="dt-static-error">static error</termref> if the <termref def="dt-expanded-qname">expanded QName</termref> and number of arguments in a function call do
not match the name and arity of a <termref def="dt-function-signature">function signature</termref> in
the <termref def="dt-static-context">static context</termref>.</p>
</error>

<error spec="XP" code="0018" class="TY" type="type">
<p>It is a  <termref def="dt-type-error">type error</termref> if
the result of  the last step in a path expression contains both nodes and non-nodes.</p>
</error>

<error spec="XP" code="0019" class="TY" type="type">
<p>
It is a  <termref def="dt-type-error">type error</termref> if
the result of a step (other than the last step) in a path expression contains an atomic value.</p>
</error>

<error spec="XP" code="0020" class="TY" type="type">
<p>
It is a <termref def="dt-type-error">type error</termref> if,
in an axis step, the context item is not a node.</p>
</error>

<error spec="XP" code="0021" class="DY" type="dynamic">
<p>
(Not currently used.)</p>
</error>

<error spec="XQ" role="xquery" code="0022" class="ST" type="static">
<p>
It is a <termref def="dt-static-error">static error</termref>
if the value of a <termref def="dt-namespace-decl-attr">namespace declaration
attribute</termref> is not a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-URILiteral" xlink:type="simple">URILiteral</nt>.
</p>
</error>

<error spec="XQ" role="xquery" code="0023" class="TY" type="type">
<p>(Not currently used.)</p>
</error>

<error spec="XQ" role="xquery" code="0024" class="TY" type="type">
<p>
It is  a <termref def="dt-type-error">type error</termref>
if the content sequence in an element constructor contains an attribute
node following a node that is not an attribute node.</p>
        </error>

<error spec="XQ" role="xquery" code="0025" class="DY" type="dynamic">
<p>
It is a <termref def="dt-dynamic-error">dynamic error</termref>
if any attribute of a constructed element 
does not have a name that is distinct from the names of all other attributes of the constructed element.</p>
</error>

<error spec="XQ" role="xquery" code="0026" class="DY" type="dynamic">
<p>
It is a <termref def="dt-dynamic-error">dynamic error</termref> if the result of the content expression of a computed processing instruction constructor contains the string "<code>?&gt;</code>".</p>
</error>

<error spec="XQ" role="xquery" code="0027" class="DY" type="dynamic">
<p>
In a validate expression, 
it is a <termref def="dt-dynamic-error">dynamic error</termref> if
the root element information item in the PSVI resulting from validation does not have the expected validity property: <code>valid</code> if validation mode is <code>strict</code>, or either <code>valid</code> or <code>notKnown</code> if  validation mode is <code>lax</code>.</p>
</error>

<error spec="XQ" role="xquery" code="0028" class="TY" type="type">
<p>
(Not currently used.)</p>
</error>

<error spec="XQ" code="0029" class="DY" type="dynamic" role="xquery">
<p>(Not currently used.)</p>
</error>

<error spec="XQ" role="xquery" code="0030" class="TY" type="type">
<p>
It is a <termref def="dt-type-error">type error</termref> 
if the argument of a <code>validate</code> expression does not
evaluate to exactly one document or element node.
</p>
</error>

<error spec="XQ" role="xquery" code="0031" class="ST" type="static">
<p>It is a <termref def="dt-static-error">static error</termref>
if the version number specified in a version declaration is not
supported by the implementation.
</p>
</error>

<error spec="XQ" role="xquery" code="0032" class="ST" type="static">
<p>A <termref def="dt-static-error">static error</termref> is raised 
if a Prolog contains more than one <termref def="dt-base-uri-decl">base URI declaration</termref>.</p>
</error>

<error spec="XQ" role="xquery" code="0033" class="ST" type="static">
<p>It is a <termref def="dt-static-error">static error</termref>
if a module contains multiple bindings for the same
namespace prefix.</p>
</error>

<error spec="XQ" role="xquery" code="0034" class="ST" type="static">
<p>It is a <termref def="dt-static-error">static error</termref> 
if multiple functions declared or imported by a <termref def="dt-module">module</termref> have the <phrase diff="add" at="XQ.E25">same</phrase> number of arguments and their <termref def="dt-expanded-qname">expanded QNames</termref> are equal (as defined by the <code>eq</code> operator).</p>
</error>

<error spec="XQ" role="xquery" code="0035" class="ST" type="static">
<p>
It is a <termref def="dt-static-error">static error</termref> to import two schema components that both define the same
name in the same symbol space and in the same scope. </p>
</error>

<error spec="XQ" role="xquery" code="0036" class="ST" type="type">
<!--	<change diff="chg" at="XQ.E6"> -->
          <p>
            It is a <termref def="dt-static-error">static error</termref> 
            to import a module if the 
            <termref def="dt-issd">in-scope schema definitions</termref>
            of the importing module do not include all of the following:
          </p>
          <olist>
             <item>
                <p>An <termref def="dt-is-types">in-scope schema type</termref> 
                   for each type-name that appears:
                </p>
                <olist>
                   <item>
                      <p>in the type of a variable that is declared in the imported module
                         and referenced in the importing module, OR
                      </p>
                   </item>
                <item>
                      <p>in a parameter-type or result-type of a function that is declared
                         in the imported module and referenced in the importing module.
                      </p>
                   </item>
                </olist>
             </item>
            <item>
                <p>An <termref def="dt-is-elems">in-scope element declaration</termref>
                   for each element-name <code>EN</code> such that:
                </p>
                <olist>
                   <item>
                      <p>
                    <code>schema-element(EN)</code> appears in the declared 
                         type of a variable 
                         in the imported module, and that variable is referenced 
                         in the importing module, OR
                      </p>
                   </item>
                <item>
                      <p>
                    <code>schema-element(EN)</code> appears in a parameter-type or 
                         result-type of a function declared in the imported module, and 
                         that function is referenced in the importing module.
                      </p>
                   </item>
                </olist>
             </item>
            <item>
                <p>An <termref def="dt-is-attrs">in-scope attribute declaration</termref>
                   for each attribute-name <code>AN</code> such that:
                </p>
                <olist>
                   <item>
                      <p>
                    <code>schema-attribute(AN)</code> appears in the declared 
                         type of a variable 
                         in the imported module, and that variable is referenced 
                         in the importing module, OR
                      </p>
                   </item>
                <item>
                      <p>
                    <code>schema-attribute(AN)</code> appears in a parameter-type 
                         or result-type 
                         of a function declared in the imported module, and that function 
                         is referenced in the importing module.
                      </p>
                   </item>
                </olist>
             </item>
          </olist>
<!--	</change> -->
</error>

<error spec="XQ" role="xquery" code="0037" class="ST" type="static">
<p>(Not currently used.)</p>
</error>

<error spec="XQ" role="xquery" code="0038" class="ST" type="static">
<p>
It is a <termref def="dt-static-error">static error</termref>
if a Prolog contains more than one <termref def="dt-default-collation-decl">default
collation declaration</termref>, or the value specified by a default collation declaration is not present in <termref def="dt-static-collations">statically known collations</termref>.</p>
</error>

<error spec="XQ" role="xquery" code="0039" class="ST" type="static">
<p>
It is a <termref def="dt-static-error">static error</termref> for a
function declaration to have more than one parameter with the same name.
</p>
</error>

<error spec="XQ" role="xquery" code="0040" class="ST" type="static">
<p>
It is a <termref def="dt-static-error">static error</termref> if the attributes specified by a direct element constructor do not have distinct <termref def="dt-expanded-qname">expanded QNames</termref>.</p>
</error>

<error spec="XQ" role="xquery" code="0041" class="DY" type="dynamic">
<p>
It is  a <termref def="dt-dynamic-error">dynamic error</termref>
if the value of the name expression in a computed processing instruction constructor cannot be cast to the type <code>xs:NCName</code>.</p>
        </error>

<error spec="XQ" role="xquery" code="0042" class="ST" type="static">
<p>
(Not currently used.)</p>
</error>

<error spec="XQ" role="xquery" code="0043" class="ST" type="static">
<p>
(Not currently used.)</p>
</error>

<error spec="XQ" role="xquery" code="0044" class="DY" type="dynamic">
<!-- <change diff="chg" at="XQ.E19"> -->
             <p>It is a <termref def="dt-dynamic-error">dynamic error</termref>
                the node-name of a node constructed by a computed 
                attribute constructor has any of the following properties:
             </p>
             <ulist>
                <item>
              <p>Its namespace prefix is <code>xmlns</code>.
                </p>
            </item>
                <item>
              <p>It has no namespace prefix and its local name is 
                   <code>xmlns</code>.
                </p>
            </item>
                <item>
              <p>Its namespace URI is <code>http://www.w3.org/2000/xmlns/</code>.
                </p>
            </item>
                <item>
              <p>Its namespace prefix is <code>xml</code> and its namespace 
                   URI is not <code>http://www.w3.org/XML/1998/namespace</code>.
                </p>
            </item>
                <item>
              <p>Its namespace prefix is other than <code>xml</code> and its 
                   namespace URI is <code>http://www.w3.org/XML/1998/namespace</code>.
                </p>
            </item>
             </ulist>
<!-- </change> -->
</error>

<error spec="XQ" role="xquery" code="0045" class="ST" type="static">
<p>
It is  a <termref def="dt-static-error">static error</termref>
if the function name in a function declaration is in one of the following namespaces: <code>http://www.w3.org/XML/1998/namespace, http://www.w3.org/2001/XMLSchema, http://www.w3.org/2001/XMLSchema-instance, http://www.w3.org/2005/xpath-functions</code>.</p>
</error>

<error spec="XQ" role="xquery" code="0046" class="ST" type="static">
<p>An implementation <termref def="may">MAY</termref> raise a <termref def="dt-static-error">static error</termref> if the value of a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-URILiteral" xlink:type="simple">URILiteral</nt> is of nonzero length and is not in the lexical
space of <code>xs:anyURI</code>.</p>
</error>

<error spec="XQ" role="xquery" code="0047" class="ST" type="static">
<p>
It is  a <termref def="dt-static-error">static error</termref>
if multiple module imports in the same Prolog specify the same target namespace.</p>
</error>

<error spec="XQ" role="xquery" code="0048" class="ST" type="static">
<p>
It is  a <termref def="dt-static-error">static error</termref>
if a function or variable declared in a library module is not in the target namespace of the library module.</p>
</error>

<error spec="XQ" role="xquery" code="0049" class="ST" type="static">
<p>It is a <termref def="dt-static-error">static error</termref> 
if two or more variables declared or imported by a <termref def="dt-module">module</termref> have equal <termref def="dt-expanded-qname">expanded QNames</termref> (as defined by the <code>eq</code> operator.)</p>
</error>

<error spec="XP" code="0050" class="DY" type="dynamic">
<p>It is  a <termref def="dt-dynamic-error">dynamic error</termref>
if the <termref def="dt-dynamic-type">dynamic type</termref> of the operand of a <code>treat</code> expression does not match the <termref def="dt-sequence-type">sequence type</termref> specified by the <code>treat</code> expression. This error might also be raised by a path expression beginning with "<code>/</code>" or "<code>//</code>" if the context node is not in a tree that is rooted at a document node. This is because a leading "<code>/</code>" or "<code>//</code>" in a path expression is an abbreviation for an initial step that includes the clause <code>treat as document-node()</code>.</p>
</error>

<error spec="XP" code="0051" class="ST" type="static">
<p>It is  a <termref def="dt-static-error">static error</termref>
if the <termref def="dt-expanded-qname">expanded QName</termref> for an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-AtomicType" xlink:type="simple">AtomicType</nt> in a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-SequenceType" xlink:type="simple">SequenceType</nt> is not defined in the <termref def="dt-is-types">in-scope schema types</termref> as an atomic type.</p>
        </error>

<error spec="XQ" role="xquery" code="0052" class="DY" type="dynamic">
<p>(Not currently used.)</p>
</error>

<error spec="XQ" role="xquery" code="0053" class="ST" type="static">
<p>
(Not currently used.)</p>
</error>

<error spec="XQ" role="xquery" code="0054" class="ST" type="static">
<p>It is a <termref def="dt-static-error">static error</termref> if a variable <termref def="dt-depends-on-variable">depends</termref> on itself.</p>
</error>

<error spec="XQ" code="0055" class="ST" type="static" role="xquery">
<p>It is a <termref def="dt-static-error">static error</termref> if a Prolog contains more than one <termref def="dt-copy-namespaces-decl">copy-namespaces declaration</termref>.</p>
</error>

<error spec="XQ" code="0056" class="ST" type="static" role="xquery">
<p>
(Not currently used.)</p>
</error>

<error spec="XQ" code="0057" class="ST" type="static" role="xquery">
<p>
It is  a <termref def="dt-static-error">static error</termref>
if a schema import binds a namespace prefix but does not specify a target namespace other than a zero-length string.</p>
</error>

<error spec="XQ" code="0058" class="ST" type="static" role="xquery">
<p>
It is  a <termref def="dt-static-error">static error</termref>
if multiple schema imports specify the same target namespace.</p>
</error>

<error spec="XQ" code="0059" class="ST" type="static" role="xquery">
<p>
It is  a <termref def="dt-static-error">static error</termref>
if an implementation is unable to process a schema or module import by finding a schema or module with the specified target namespace.</p>
</error>

<error spec="XQ" code="0060" class="ST" type="static" role="xquery">
<p>
It is a <termref def="dt-static-error">static error</termref> if the name of a function in a function declaration is not in a namespace (<termref def="dt-expanded-qname">expanded QName</termref> has a null namespace URI).</p>
</error>

<error spec="XQ" role="xquery" code="0061" class="DY" type="dynamic">
<p>
It is a <termref def="dt-dynamic-error">dynamic error</termref>
if the operand of a validate expression is a document node whose children do not consist of exactly one element node  and zero or more comment and processing instruction nodes, in any order.</p>
</error>

<error spec="XQ" role="xquery" code="0062" class="DY" type="dynamic">
<p>(Not currently used.)</p>
</error>

<error spec="XQ" code="0063" class="ST" type="static" role="xquery">
<p>
(Not currently used.)</p>
</error>

<error spec="XQ" role="xquery" code="0064" class="DY" type="dynamic">
<p>
It is  a <termref def="dt-dynamic-error">dynamic error</termref>
if the value of the name expression in a computed processing instruction constructor is equal to "XML" (in any combination of upper and lower case).</p>
</error>

<error spec="XQ" role="xquery" code="0065" class="ST" type="static">
<p>A <termref def="dt-static-error">static error</termref> is raised 
if a Prolog contains more than one <termref def="dt-ordering-mode-decl">ordering mode declaration</termref>.</p>
</error>

<error spec="XQ" role="xquery" code="0066" class="ST" type="static">
<p>A <termref def="dt-static-error">static error</termref> is raised 
if a Prolog contains more than one default element/type namespace declaration, or more than one default function namespace declaration.
</p>
</error>

<error spec="XQ" role="xquery" code="0067" class="ST" type="static">
<p>A <termref def="dt-static-error">static error</termref> is raised 
if a Prolog contains more than one <termref def="dt-construction-decl">construction declaration</termref>.</p>
</error>

<error spec="XQ" role="xquery" code="0068" class="ST" type="static">
<p>A <termref def="dt-static-error">static error</termref> is raised 
if a Prolog contains more than one <termref def="dt-boundary-space-decl">boundary-space declaration</termref>.</p>
</error>

<error spec="XQ" role="xquery" code="0069" class="ST" type="static">
<p>A <termref def="dt-static-error">static error</termref> is raised 
if a Prolog contains more than one <termref def="dt-empty-order-decl">empty order declaration</termref>.</p>
</error>

<error spec="XQ" role="xquery" code="0070" class="ST" type="static">
<!-- <change diff="chg" at="XQ.E19"> -->
             <p>A <termref def="dt-static-error">static error</termref> is raised 
                if one of the predefined prefixes <code>xml</code> or <code>xmlns</code> 
                appears in a namespace declaration, or if any of the following conditions 
                is statically detected in any expression or declaration:
             </p>
             <ulist>
                <item>
              <p>The prefix <code>xml</code> is bound to some namespace URI 
                   other than <code>http://www.w3.org/XML/1998/namespace</code>.
                </p>
            </item>
                <item>
              <p>A prefix other than <code>xml</code> is bound to the 
                   namespace URI <code>http://www.w3.org/XML/1998/namespace</code>.
                </p>
            </item>
                <item>
              <p>The prefix <code>xmlns</code> is bound to any namespace URI.
                </p>
            </item>
                <item>
              <p>A prefix other than <code>xmlns</code> is bound to the 
                   namespace URI <code>http://www.w3.org/2000/xmlns/</code>.
                </p>
            </item>
             </ulist>
<!-- </change> -->
</error>

<error spec="XQ" role="xquery" code="0071" class="ST" type="static">
<p>A <termref def="dt-static-error">static error</termref> is raised 
if the namespace declaration attributes of a direct element constructor do not have distinct names.</p>
</error>

<error spec="XQ" role="xquery" code="0072" class="DY" type="dynamic">
<p>
It is a <termref def="dt-dynamic-error">dynamic
error</termref> if the result of the content expression of a computed comment constructor contains two adjacent hyphens or ends with a hyphen.</p>
</error>

<error spec="XQ" role="xquery" code="0073" class="ST" type="static">
<p diff="chg" at="XQ.E8">(Not currently used.)</p>
</error>

<error spec="XQ" role="xquery" code="0074" class="DY" type="dynamic">
<p>
It is  a <termref def="dt-dynamic-error">dynamic error</termref>
if the value of the name expression in a computed element or attribute constructor cannot be converted to an <termref def="dt-expanded-qname">expanded QName</termref> (for example, because it contains a namespace prefix not found in <termref def="dt-static-namespaces">statically known namespaces</termref>.)</p>
</error>

<error spec="XQ" role="xquery" code="0075" class="ST" type="static">
<p>
An implementation that does not support the Validation Feature must raise a  <termref def="dt-static-error">static error</termref> if 
it encounters a <code>validate</code> expression.</p>
</error>

<error spec="XQ" role="xquery" code="0076" class="ST" type="static">
<p>
It is a <termref def="dt-static-error">static
error</termref>
if a <code>collation</code> subclause in an <code>order by</code> clause of a FLWOR expression does not identify a collation that is present in <termref def="dt-static-collations">statically known collations</termref>.</p>
</error>

<error spec="XQ" role="xquery" code="0077" class="ST" type="static">
<p>
(Not currently used.)</p>
</error>

<error spec="XQ" role="xquery" code="0078" class="ST" type="static">
<p>
(Not currently used.)</p>
</error>

<error spec="XQ" role="xquery" code="0079" class="ST" type="static">
<p>
It is a <termref def="dt-static-error">static error</termref>
if an extension expression contains neither a <termref def="dt-pragma">pragma</termref> that is recognized by the implementation nor an expression enclosed in curly braces.</p>
</error>

<error spec="XP" code="0080" class="ST" type="static">
<p>It is a 
<termref def="dt-static-error">static
error</termref> if the target type of a <code>cast</code> or <code>castable</code> expression is  <code>xs:NOTATION</code> or <code>xs:anyAtomicType</code>.</p>
</error>

<error spec="XP" code="0081" class="ST" type="static">
<p>
It is a <termref def="dt-static-error">static
error</termref>
if a QName used in <phrase role="xquery">a query</phrase> contains a namespace prefix that cannot be expanded into a namespace URI by using the <termref def="dt-static-namespaces">statically known namespaces</termref>.</p>
</error>

<error spec="XQ" role="xquery" code="0082" class="ST" type="static">
<p>(Not currently used.)</p>
</error>

<error spec="XP" code="0083" class="ST" type="static">
<p>
(Not currently used.)</p>
</error>

<error spec="XQ" code="0084" class="DY" type="dynamic" role="xquery">
<p>
It is a <termref def="dt-dynamic-error">dynamic error</termref>
if the element validated by a <code>validate</code> statement does not have a top-level element declaration in the <termref def="dt-is-elems">in-scope element declarations</termref>, if validation mode is <code>strict</code>.</p>
</error>

<error spec="XQ" role="xquery" code="0085" class="ST" type="static">
<p>
It is a <termref def="dt-static-error">static
error</termref>
if the namespace URI in a namespace declaration attribute is a zero-length string, and the implementation does not support <bibref ref="XMLNAMES11"/>.</p>
</error>

<error spec="XQ" role="xquery" code="0086" class="TY" type="type">
<p>
It is a <termref def="dt-type-error">type error</termref> 
if the typed value of a copied element or attribute node is <termref def="dt-namespace-sensitive">namespace-sensitive</termref> when <termref def="dt-construction-mode">construction mode</termref> is <code>preserve</code> and <termref def="dt-copy-namespaces-mode">copy-namespaces mode</termref> is <code>no-preserve</code>.</p>
</error>

<error spec="XQ" role="xquery" code="0087" class="ST" type="static">
<p>
It is a <termref def="dt-static-error">static
error</termref>
if the encoding specified in a Version Declaration does not conform to  the definition of <code>EncName</code> specified in <bibref ref="XML"/>.</p>
</error>

<error spec="XQ" role="xquery" code="0088" class="ST" type="static">
<p>
It is a <termref def="dt-static-error">static
error</termref>
if the literal that specifies the target namespace in a <termref def="dt-module-import">module import</termref> or a <termref def="dt-module-declaration">module declaration</termref> is of zero length.</p>
</error>

<error spec="XQ" role="xquery" code="0089" class="ST" type="static">
<p>
It is a <termref def="dt-static-error">static
error</termref>
if a variable bound in a <code>for</code> or <code>window</code> clause of a FLWOR expression, and its associated positional variable, do not have distinct names (<termref def="dt-expanded-qname">expanded QNames</termref>).</p>
</error>

<error spec="XQ" role="xquery" code="0090" class="ST" type="static">
<p>
It is a <termref def="dt-static-error">static
error</termref>
if a <termref def="dt-character-reference">character reference</termref>
does not identify a valid character in the version of XML that is in use.</p>
</error>

<error spec="XQ" role="xquery" code="0091" class="DY" type="dynamic">
<p>An implementation <termref def="may">MAY</termref> raise a <termref def="dt-dynamic-error">dynamic error</termref>
if an <code>xml:id</code> error, as defined in <bibref ref="XMLID"/>, is encountered during construction of an attribute named <code>xml:id</code>.</p>
</error>

<error spec="XQ" role="xquery" code="0092" class="DY" type="dynamic">
<p>An implementation <termref def="may">MAY</termref> raise a <termref def="dt-dynamic-error">dynamic error</termref>
if a constructed attribute named <code>xml:space</code> has a value other than <code>preserve</code> or <code>default</code>.</p>
</error>
<!--
<error spec="XQ" role="xquery" code="0093" class="ST" type="static">
<p>
It is a <termref def="dt-static-error">static
error</termref> to import a module M<sub>1</sub> if there exists a sequence of modules M<sub>1</sub> ... M<sub>i</sub> ... M<sub>1</sub> such that each module <termref def="dt-module-directly-depends">directly depends</termref> on the next module in the sequence (informally, if M<sub>1</sub> depends on itself through some chain of module dependencies.)</p>
</error>
-->

<error spec="XQ" role="xquery" code="0094" class="ST" type="static">
<p>
In the <code>group by</code> clause of a FLWOR expression, it is a <termref def="dt-static-error">static
error</termref> if the name of a grouping variable is not equal (by the <code>eq</code> operator on <termref def="dt-expanded-qname">expanded QNames</termref>) to the name of a variable that is bound by a <code>for</code> or <code>let</code> clause that precedes the <code>group by</code> clause.</p>
</error>
        <error spec="XQ" role="xquery" code="0095" class="DY" type="dynamic">
<p>
In the <code>group by</code> clause of a FLWOR expression, it is a <termref def="dt-dynamic-error">dynamic error</termref>
if the value bound to a grouping  variable consists of a sequence of more than one item.</p>
</error>

<!-- ################ -->

<error spec="XQ" role="xquery" code="0096" class="DY" type="dynamic">
<!-- 	   <change diff="chg" at="XQ.E19"> -->
             <p>It is a <termref def="dt-dynamic-error">dynamic error</termref>
                the node-name of a node constructed by a computed 
                element constructor has any of the following properties:
             </p>
             <ulist>
                <item>
              <p>Its namespace prefix is <code>xmlns</code>.
                </p>
            </item>
                <item>
              <p>Its namespace URI is <code>http://www.w3.org/2000/xmlns/</code>.
                </p>
            </item>
                <item>
              <p>Its namespace prefix is <code>xml</code> and its namespace 
                   URI is not <code>http://www.w3.org/XML/1998/namespace</code>.
                </p>
            </item>
                <item>
              <p>Its namespace prefix is other than <code>xml</code> and its 
                   namespace URI is <code>http://www.w3.org/XML/1998/namespace</code>.
                </p>
            </item>
             </ulist>
<!--	    </change>          -->
</error>

<error spec="XQ" role="xquery" code="0097" class="ST" type="static">
<p>
It is a static error for a decimal-format to specify a value that is
not legal for a given property, as described in <termref def="dt-static-decimal-formats">statically known decimal
formats</termref>
          </p>
</error>

<error spec="XQ" role="xquery" code="0098" class="ST" type="static">
<p>

It is a static error if, for any named or unnamed decimal format, the
properties representing characters used in a picture string do not
each have distinct values.

These properties are
<termref def="id-static-decimal-separator">decimal-separator-sign</termref>, 
<termref def="id-static-decimal-format-grouping-separator">grouping-separator</termref>, 
<termref def="id-static-decimal-format-percent-sign">percent-sign</termref>, 
<termref def="id-static-decimal-format-per-mille-sign">per-mille-sign</termref>,
<termref def="id-static-decimal-format-zero-digit">zero-digit</termref>, 
<termref def="id-static-decimal-format-digit-sign">digit-sign</termref>, and 
<termref def="id-static-decimal-format-pattern-separator-sign">pattern-separator-sign</termref>.
</p>
</error>

<error spec="XQ" role="xquery" code="0099" class="ST" type="static">
<p>
A <code>ContextItemDecl</code> must not occur after an expression that relies on the initial 
context item, and no query may contain more than one ContextItemDecl.
</p>
</error>

<error spec="XQ" role="xquery" code="0100" class="ST" type="static">
<p>
  It is a static error if any of the following decimal format properties is not a single character.
</p>
  <ulist>

  <item>
              <p>
                <termref def="id-static-decimal-separator">decimal-separator</termref>
              </p>
            </item>
  <item>
              <p>
                <termref def="id-static-decimal-format-grouping-separator">grouping-separator</termref>
              </p>
            </item>

    <item>
              <p>
                <termref def="id-static-decimal-format-percent-sign">percent-sign</termref>
              </p>
            </item>

    <item>
              <p>
                <termref def="id-static-decimal-format-per-mille-sign">per-mille-sign</termref>
              </p>
            </item>

    <item>
              <p>
                <termref def="id-static-decimal-format-zero-digit">zero-digit</termref>
              </p>
            </item>

    <item>
              <p>
                <termref def="id-static-decimal-format-digit-sign">digit-sign</termref>
              </p>
            </item>
    <item>
              <p>
                <termref def="id-static-decimal-format-pattern-separator-sign">pattern-separator-sign</termref>
              </p>
            </item>
  </ulist>
</error>

<error spec="XQ" role="xquery" code="0101" class="DY" type="dynamic">

    <p>An error is raised if the
    namespace URI in a computed namespace constructor is bound to the predefined prefix
    <code>xmlns</code>, or if a namespace URI other than
    <code>http://www.w3.org/XML/1998/namespace</code> is bound to the
    prefix <code>xml</code>, or if the prefix <code>xml</code> is
    bound to a namespace URI other than
    <code>http://www.w3.org/XML/1998/namespace.</code>
          </p>
</error>

<error spec="XQ" role="xquery" code="0102" class="TY" type="type">
<p>
In an element constructor, if two or more namespace bindings in the
in-scope bindings would have the same prefix, then an error is raised
if they have different URIs; if they would have the same prefix and
URI, duplicate bindings are ignored.
</p>
</error>

<error spec="XQ" role="xquery" code="0103" class="ST" type="static">

<p>All variables in a <code>window</code> clause must have distinct names.</p>
</error>

<error spec="XQ" role="xquery" code="0104" class="ST" type="static">

<p>A <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-TypeName" xlink:type="simple">TypeName</nt> that is specified in a <code>validate</code> expression must be found in the <termref def="dt-issd">in-scope
  schema definitions</termref>
</p>
</error>

<error spec="XQ" role="xquery" code="0105" class="TY" type="type">
<p>
It is  a <termref def="dt-type-error">type error</termref>
if the content sequence in an element constructor contains a function item.</p>
        </error>

<error spec="XQ" role="xquery" code="0106" class="ST" type="static">
<p>
It is a <termref def="dt-static-error">static error</termref>
if a function's annotations contain more than one annotation named <code>%private</code> or <code>%public</code>.</p>

<p>
It is a <termref def="dt-static-error">static error</termref> if a
function's annotations contain more than one annotation named
<code>%deterministic</code> or <code>%nondeterministic</code>. </p>
</error>


<!-- ############ -->

<error spec="XQ" role="xquery" code="0107" class="ST" type="static">
<p>
It is a <termref def="dt-static-error">static error</termref> if the initializer of the context item  <termref def="dt-depends-on-context-item">depends on</termref> the context item.
</p>
</error>

<error spec="XQ" role="xquery" code="0108" class="ST" type="static">
<p>
It is a <termref def="dt-static-error">static error</termref> if an <termref def="dt-output-declaration">output declaration</termref> occurs in a  <termref def="dt-library-module">library module</termref>.
</p>
</error>

<error spec="XQ" role="xquery" code="0109" class="ST" type="static">
<p>
It is a <termref def="dt-static-error">static error</termref> if the local name of an output declaration in the <code>http://www.w3.org/2009/xquery-serialization</code> namespace is not  one of
the serialization parameter names listed in <specref ref="id-xq-serialization-parameters"/>.
</p>
</error>

<error spec="XQ" role="xquery" code="0110" class="ST" type="static">
<p>
It is a <termref def="dt-static-error">static error</termref> if the same serialization parameter is used more than once in an <termref def="dt-output-declaration">output declaration</termref>.</p>

</error>


<error spec="XQ" role="xquery" code="0111" class="ST" type="static">

<p>It is a  <termref def="dt-static-error">static error</termref> for a query prolog to contain two decimal
formats with the same name, or to contain two default decimal formats.
<errorref class="ST" code="0111"/>.
</p>
</error>

<error spec="XP" code="0112" class="ST" type="static">
<p>It is a <termref def="dt-static-error">static error</termref> to partially apply or create a function item for a function which accesses the focus <errorref class="ST" code="0112"/>.
</p>
</error>

<error spec="XQ" role="xquery" code="0113" class="ST" type="static">
<p>
Specifying a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-VarValue" xlink:type="simple">VarValue</nt> or <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-VarDefaultValue" xlink:type="simple">VarDefaultValue</nt> for a context item declaration
in a library module is a  <termref def="dt-static-error">static error</termref>.
</p>
</error>


<!--


<error  spec="XQ" role="xquery" code="010X" class="ST" type="static">
<p>
</p>
</error>

<error  spec="XQ" role="xquery" code="010X" class="ST" type="static">
<p>
</p>
</error>

<error  spec="XQ" role="xquery" code="010X" class="ST" type="static">
<p>
</p>
</error>

<error  spec="XQ" role="xquery" code="010X" class="ST" type="static">
<p>
</p>
</error>

<error  spec="XQ" role="xquery" code="010X" class="ST" type="static">
<p>
</p>
</error>

-->

</error-list>
</div1>



<div1 role="xquery" id="id-mime-type">

  <head>The <code>application/xquery</code> Media Type</head>



  <p>This Appendix 

    specifies the media type for XQuery Version 1.0.  XQuery is a language for querying over

    collections of data from XML data sources, as specified in the main body of this document. This media type is being 

submitted to the IESG (Internet Engineering Steering Group)

for review, approval, and registration with IANA (Internet Assigned Numbers

Authority.)</p>



  <div2 id="id-mime-type-intro">

    <head>Introduction</head>

    <p>

	This document, found at

	<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/xquery/" role="xquery" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xquery/</loc>,

	together with its normative references,  defines the language XQuery Version 1.0.  This Appendix

      provides information about the <code>application/xquery</code> media type,

      which is intended to be used for transmitting queries written in the

      XQuery language.</p>

    <p>This document was prepared by members of the W3C XML Query Working

      Group.  Please send comments to public-qt-comments@w3.org,

      a public mailing list with archives at

      <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://lists.w3.org/Archives/Public/public-qt-comments" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://lists.w3.org/Archives/Public/public-qt-comments</loc>.</p>
      </div2>



  <div2 id="id-registration-of-mime-type">

    <head>Registration of MIME Media Type <code>application/xquery</code>
        </head>



    <p>MIME media type name:  <code>application</code>
        </p>

    <p>MIME subtype name:    <code>xquery</code>
        </p>

    <p>Required parameters:  none</p>

    <p>Optional parameters: none</p>

    <p>The syntax of XQuery is expressed in Unicode but may be written

	with any Unicode-compatible character encoding, including UTF-8 or

	UTF-16, or transported as US-ASCII or ISO-8859-1 with Unicode

	characters outside the range of the given encoding represented using

	an XML-style <code>&amp;#xddd;</code> syntax.</p>



      



      <div3 id="id-interoperability-considerations">
          <head>Interoperability Considerations</head>

	<p>None known.</p>
        </div3>



      <div3 id="id-applications-of-media-type">
          <head>Applications Using this Media Type</head>

	<p>The public

	  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/Query" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XQuery Web page</loc>

	  lists more than two dozen implementations of the XQuery language,

	  both proprietary and open source.</p>



	<p>This new media type is being registered to allow for deployment

	  of XQuery on the World Wide Web.</p>
        </div3>



      <div3 id="id-file-extensions">
          <head>File Extensions</head>

	<p>The most common file extensions in use for XQuery are

	  <code>.xq</code> and <code>.xquery</code>.</p>



	<p>The appropriate Macintosh file type code is <code>TEXT</code>.</p>

      </div3>



      



    <div3 id="id-intended-usage">
          <head>Intended Usage</head>

      <p>The intended usage of this media type is for interchange

	of XQuery expressions.</p>
        </div3>



    <div3 id="id-author-change-controller">
          <head>Author/Change Controller</head>

      <p>XQuery was produced by, and is maintained by, the World Wide Web

	Consortium's XML Query Working Group.  The W3C has change

	control over this specification.</p>
        </div3>
      </div2>



  <div2 id="xquery-mime-encoding">
        <head>Encoding Considerations</head>



    <p>For use with transports that are not 8-bit clean, quoted-printable

    encoding is recommended since the XQuery syntax itself uses the

    US-ASCII-compatible subset of Unicode.</p>



  <p>An XQuery document may contain an <termref def="dt-encoding-declaration">encoding 

declaration</termref> as part of its <termref def="dt-version-declaration">version declaration</termref>:</p>

  <eg role="frag-prolog-parse-test" xml:space="preserve">xquery version "1.0" encoding "utf-8";</eg>



  </div2>



<div2 id="xquery-mime-recognizing">

  <head>Recognizing XQuery Files</head>



  <p>An XQuery file may have the string <code>xquery version "V.V"</code> near the

    beginning of the document, where <code>"V.V"</code> is a version number.

    Currently the version number, if present, must be <code>"1.0"</code>.</p>
      </div2>



<div2 id="id-charset-default-rules">
        <head>Charset Default Rules</head>



  <p>XQuery documents use the Unicode character set and, by default, the UTF-8 encoding.</p>
      </div2>



<div2 id="id-security-considerations">
        <head>Security Considerations</head>



  <p>Queries written in XQuery may cause arbitrary URIs or IRIs to be

    dereferenced.  Therefore, the security issues of <bibref ref="RFC3987"/> Section 8 should be considered.

    In addition, the contents of resources identified by  <code>file:</code> URIs can in some cases be

    accessed, processed and returned as results. XQuery expressions can invoke any of the functions defined in

<bibref ref="xpath-functions-11"/>. For example, the

<code>fn:doc()</code> and <code>fn:doc-available()</code> functions  allow local filesystem probes as well as

access to any URI-defined resource accessible from the system

evaluating the XQuery expression.</p>
        <p>XQuery is a full declarative programming language, and supports

user-defined functions, external function libraries (modules)

referenced by URI, and system-specific "native" functions.</p>
        <p>Arbitrary recursion is possible, as is arbitrarily large

memory usage, and implementations may place limits on CPU

and memory usage, as well as restricting access to system-defined

functions.</p>



  <p>The XML Query Working group is working on a facility to

    allow XQuery expressions to create and update 

    persistent data.  Untrusted queries should not be given write

    access to data.</p>
        <p>Furthermore, because the XQuery language permits extensions, 

    it is possible that <code>application/xquery</code>

    may describe content that has

    security implications beyond those described here.</p>

  </div2>

  </div1>
<inform-div1 id="id-glossary">
      <head>Glossary</head>
<!-- This processing instruction automatically generates the glossary. -->
<?glossary?>
</inform-div1>



<inform-div1 role="xquery" id="id-example-applications">
	<head>Example Applications</head> 

	<p>This section
	contains examples of several important classes of queries that
	can be expressed using XQuery.  The applications described here include joins across
	multiple data sources, grouping and aggregation, queries
	based on sequential relationships, recursive transformations, and selection of distinct combinations of values.</p>

	<note>
	  <p>This section needs to be rewritten in light of the new
	  features of XQuery 1.1, which can significantly simplify some of these queries.</p>
	</note>

	
	<div2 id="id-joins">
		<head>Joins</head>
		<p>Joins, which
				combine data from multiple sources
				into a single result, are a very
				important type of query. In this
				section we will illustrate how several
				types of joins can be expressed in
				XQuery. We will base our examples on
				the following three documents:</p>
		<olist>
			<item>
				<p>A document named
						<code>parts.xml</code> that
						contains many
						<code>part</code> elements;
						each <code>part</code>
						element in turn
						contains
						<code>partno</code> and
						<code>description</code>
						subelements.</p>
			</item>
			<item>
				<p>A document named
						<code>suppliers.xml</code> that
						contains many
						<code>supplier</code>
						elements; each
						<code>supplier</code>
						element in turn
						contains
						<code>suppno</code> and
						<code>suppname</code>
						subelements.</p>
			</item>
			<item>
				<p>A document named
						<code>catalog.xml</code> that
						contains information
						about the
						relationships between
						suppliers and
						parts. The catalog
						document contains many
						<code>item</code> elements,
						each of which in turn
						contains
						<code>partno</code>,
						<code>suppno</code>, and
						<code>price</code>
						subelements.</p>
			</item>
		</olist>
		<p>A conventional ("inner") join
				returns information from two or more
				related sources, as illustrated by the
				following example, which combines
				information from three documents. The example
					generates a "descriptive
					catalog" derived from the
					catalog document, but
					containing part descriptions
					instead of part numbers and
					supplier names instead of
					supplier numbers. The
					new catalog is ordered 
					alphabetically by
					part description and
					secondarily by supplier
					name.</p>
		<eg role="parse-test" xml:space="preserve">&lt;descriptive-catalog&gt;
   { 
     for $i in fn:doc("catalog.xml")/items/item,
         $p in fn:doc("parts.xml")/parts/part[partno = $i/partno],
         $s in fn:doc("suppliers.xml")/suppliers
                  /supplier[suppno = $i/suppno]
     order by $p/description, $s/suppname
     return
        &lt;item&gt;
           {
           $p/description,
           $s/suppname,
           $i/price
           }
        &lt;/item&gt;
   }
&lt;/descriptive-catalog&gt;</eg>
		<p>The previous query returns
				information only about parts that have
				suppliers and suppliers that have
				parts. An <term>outer join</term> is a join that
				preserves information from one or more
				of the participating sources,
				including elements that have no
				matching element in the other
				source. For example, a <term>left outer
				join</term> between suppliers and parts
				might return information about
				suppliers that have no matching parts.
				 </p>
		<p>The following query
					demonstrates a left outer
					join. It returns names of all
					the suppliers in alphabetic
					order, including those that
					supply no parts.  In the
					result, each supplier element
					contains the descriptions of
					all the parts it supplies, in
					alphabetic order.</p>
		<eg role="parse-test" xml:space="preserve">for $s in fn:doc("suppliers.xml")/suppliers/supplier
order by $s/suppname
return
   &lt;supplier&gt;
      { 
        $s/suppname,
        for $i in fn:doc("catalog.xml")/items/item
                 [suppno = $s/suppno],
            $p in fn:doc("parts.xml")/parts/part
                 [partno = $i/pno]
        order by $p/description
        return $p/description 
      }
   &lt;/supplier&gt;</eg>

		<p>The previous query preserves information about
		suppliers that supply no parts. Another type of join,
		called a <term>full outer join</term>, might be used
		to preserve information about both suppliers that
		supply no parts and parts that have no supplier. The
		result of a full outer join can be structured in any
		of several ways.  The following query generates a list
		of <code>supplier</code> elements, each containing
		nested <code>part</code> elements for the parts that
		it supplies (if any), followed by a list of
		<code>part</code> elements for the parts that have no
		supplier. This might be thought of as a
		"supplier-centered" full outer join. Other forms of
		outer join queries are also possible.</p>

		<eg role="parse-test" xml:space="preserve">&lt;master-list&gt;
 {
    for $s in fn:doc("suppliers.xml")/suppliers/supplier
    order by $s/suppname
    return
        &lt;supplier&gt;
           { 
             $s/suppname,
             for $i in fn:doc("catalog.xml")/items/item
                     [suppno = $s/suppno],
                 $p in fn:doc("parts.xml")/parts/part
                     [partno = $i/partno]
             order by $p/description
             return
                &lt;part&gt;
                   {
                     $p/description,
                     $i/price
                   }
                &lt;/part&gt; 
           }
        &lt;/supplier&gt; 
    ,
    (: parts that have no supplier :)
    &lt;orphan-parts&gt;
       { for $p in fn:doc("parts.xml")/parts/part
         where fn:empty(fn:doc("catalog.xml")/items/item
               [partno = $p/partno] )
         order by $p/description
         return $p/description 
       }
    &lt;/orphan-parts&gt;
 }
&lt;/master-list&gt;</eg>

		<p>The previous query uses an element constructor to
		enclose its output inside a <code>master-list</code>
		element. The concatenation operator (",") is used to
		combine the two main parts of the query. The result is
		an ordered sequence of <code>supplier</code> elements
		followed by an <code>orphan-parts</code> element that
		contains descriptions of all the parts that have no
		supplier.</p>
	</div2>

	<div2 id="id-queries-on-sequence">
		<head>Queries on Sequence</head> <p>XQuery uses the
		<code>&lt;&lt;</code> and <code>&gt;&gt;</code>
		operators to compare nodes based on document
		order. Although these operators are quite simple, they
		can be used to express complex queries for XML
		documents in which sequence is meaningful.  The first
		two queries in this section involve a surgical report
		that contains <code>procedure</code>,
		<code>incision</code>, <code>instrument</code>,
		<code>action</code>, and <code>anesthesia</code>
		elements.</p>
        <p>The following query returns all the
		<code>action</code> elements that occur between the
		first and second <code>incision</code> elements inside
		the first procedure.  The original document order
		among these nodes is preserved in the result of the
		query.</p> <eg role="parse-test" xml:space="preserve">let $proc := /report/procedure[1]
for $i in $proc//action
where $i &gt;&gt; ($proc//incision)[1]
   and $i &lt;&lt; ($proc//incision)[2]
return $i</eg>

		<p>It is worth noting here that document order is
		defined in such a way that a node is considered to
		precede its descendants in document order. In the
		surgical report, an <code>action</code> is never part
		of an <code>incision</code>, but an
		<code>instrument</code> is. Since the
		<code>&gt;&gt;</code> operator is based on document
		order, the predicate <code>$i &gt;&gt;
		($proc//incision)[1]</code> is true for any
		<code>instrument</code> element that is a descendant
		of the first <code>incision</code> element in the
		first procedure.</p>
        <p>For some queries, it may be
		helpful to define a function that can test whether a
		node precedes another node without being its
		ancestor. The following function returns
		<code>true</code> if its first operand precedes its
		second operand but is not an ancestor of its second
		operand; otherwise it returns <code>false</code>:</p>

<eg role="frag-prolog-parse-test" xml:space="preserve">declare function local:precedes($a as node(), $b as node()) 
   as boolean
   {
      $a &lt;&lt; $b
        and
      fn:empty($a//node() intersect $b) 
   };
</eg>


<p>Similarly, a <code>local:follows</code> function could be written:</p>

<eg role="frag-prolog-parse-test" xml:space="preserve">declare function local:follows($a as node(), $b as node()) 
   as boolean
   {
      $a &gt;&gt; $b
        and
      fn:empty($b//node() intersect $a) 
   };
</eg>

<p>Using the <code>local:precedes</code> function, we can write a
query that finds <code>instrument</code> elements between the first
two incisions, excluding from the query result any
<code>instrument</code> that is a descendant of the first
<code>incision</code>:</p>

<eg role="parse-test" xml:space="preserve">let $proc := /report/procedure[1]
for $i in $proc//instrument
where local:precedes(($proc//incision)[1], $i)
   and local:precedes($i, ($proc//incision)[2])
return $i</eg>

<p>The following query reports incisions for which no prior anesthesia
was recorded in the surgical report. Since an <code>anesthesia</code>
is never part of an <code>incision</code>, we can use
<code>&lt;&lt;</code> instead of the less-efficient
<code>local:precedes</code> function:</p>

		<eg role="parse-test" xml:space="preserve">for $proc in /report/procedure
where some $i in $proc//incision satisfies
         fn:empty($proc//anesthesia[. &lt;&lt; $i])
return $proc</eg>
		<p>In some documents, particular sequences
			of elements may indicate a logical hierarchy.
			This is most commonly true of HTML. The following
			query returns the introduction of an XHTML document,
			wrapping it in a <code>div</code> element. In this example, we
			assume that an <code>h2</code> element containing the text
			"Introduction" marks the beginning of the introduction,
			and the introduction continues until the next <code>h2</code>
			or <code>h1</code> element, or the end of the document, whichever
			comes first.
			</p>
		<eg role="parse-test" xml:space="preserve">let $intro := //h2[text()="Introduction"],
    $next-h := //(h1|h2)[. &gt;&gt; $intro][1]
return
   &lt;div&gt;
     {
       $intro,
       if (fn:empty($next-h))
         then //node()[. &gt;&gt; $intro]
         else //node()[. &gt;&gt; $intro and . &lt;&lt; $next-h]
     }
   &lt;/div&gt;</eg>
		<p>Note that the above query makes explicit the hierarchy that was implicit in the
			original document. In this example, we assume that the <code>h2</code> element containing the text "Introduction" has no subelements.</p>
	</div2>
<div2 id="id-recursive-transformations">
        <head>Recursive Transformations</head>
        <p>Occasionally it is necessary to scan over a hierarchy of elements, applying some transformation at each level of the hierarchy. In XQuery this can be accomplished by defining a recursive function. In this section we will present two examples of such recursive functions.</p>
        <p>Suppose that we need to compute a table of contents for a given document by scanning over the document, retaining only elements named <code>section</code> or <code>title</code>, and preserving the hierarchical relationships among these elements. For each <code>section</code>, we retain subelements named <code>section</code> or <code>title</code>; but for each <code>title</code>, we retain the full content of the element. This might be accomplished by the following recursive function:</p>
        <eg role="frag-prolog-parse-test" xml:space="preserve">declare function local:sections-and-titles($n as node()) as node()?
   {
   if (fn:local-name($n) = "section")
   then element
          { fn:local-name($n) }
          { for $c in $n/* return local:sections-and-titles($c) }
   else if (fn:local-name($n) = "title")
   then $n
   else ( )
   };</eg>
        <p>The "skeleton" of a given document, containing only its sections and titles, can then be obtained by invoking the <code>local:sections-and-titles</code> function on the root node of the document, as follows:</p>
        <eg role="parse-test" xml:space="preserve">local:sections-and-titles(fn:doc("cookbook.xml"))</eg>
        <p>As another example of a recursive transformation, suppose that we wish to scan over a document, transforming every attribute named <code>color</code> to an element named <code>color</code>, and every element named <code>size</code> to an attribute named <code>size</code>. This can be accomplished by the following recursive function (note that the element constructor in case <code>$e</code> generates attributes before child elements):</p>
        <eg role="frag-prolog-parse-test" xml:space="preserve">declare function local:swizzle($n as node()) as node() 
  { 
   typeswitch($n)
     case $a as attribute(color)
       return element color { fn:string($a) } 
     case $es as element(size) 
       return attribute size { fn:string($es) } 
     case $e as element() 
       return element 
         { fn:local-name($e) } 
         { for $c in 
             ($e/@* except $e/@color,     (: attr -&gt; attr :)
              $e/size,                    (: elem -&gt; attr :)
              $e/@color,                  (: attr -&gt; elem :)
              $e/node() except $e/size )  (: elem -&gt; elem :)
           return local:swizzle($c) }
     case $d as document-node() 
       return document 
         { for $c in $d/* return local:swizzle($c) } 
     default return $n 
  };</eg>
        <p>The transformation can be applied to a whole document by invoking the <code>local:swizzle</code> function on the root node of the document, as follows:</p>
        <eg role="parse-test" xml:space="preserve">local:swizzle(fn:doc("plans.xml"))</eg>
      </div2>
      <div2 id="id-select-distinct">
        <head>Selecting Distinct Combinations</head>
        <p>It is sometimes necessary to search through a set of data to find all the distinct combinations of a given list of properties. For example, an input data set might consist of a large set of <code>order</code> elements, each of which has the same basic structure, as illustrated by the following example:</p>
        <eg xml:space="preserve">&lt;order&gt;
   &lt;date&gt;2003-10-15&lt;/date&gt;
   &lt;product&gt;Dress Shirt&lt;/product&gt;
   &lt;size&gt;M&lt;/size&gt;
   &lt;color&gt;Blue&lt;/color&gt;
   &lt;supplier&gt;Fashion Trends&lt;/supplier&gt;
   &lt;quantity&gt;50&lt;/quantity&gt;
&lt;/order&gt;</eg>
        <p>From this data set, a user might wish to find all the distinct combinations of <code>product</code>, <code>size</code>, and <code>color</code> that occur together in an <code>order</code>. The following query returns this list, enclosing each distinct combination in a new element named <code>option</code>:</p>
        <eg role="parse-test" xml:space="preserve">for $p in fn:distinct-values(/orders/order/product),
    $s in fn:distinct-values(/orders/order/size),
    $c in fn:distinct-values(/orders/order/color)
    order by $p, $s, $c
    return
       if (fn:exists(/orders/order[product eq $p
                and size eq $s and color eq $c]))
       then
          &lt;option&gt;
             &lt;product&gt;{$p}&lt;/product&gt;
             &lt;size&gt;{$s}&lt;/size&gt;
             &lt;color&gt;{$c}&lt;/color&gt;
          &lt;/option&gt;
       else ()</eg>
      </div2>
    </inform-div1>






<inform-div1 id="id-revision-log">
<head>Change Log</head>

<p role="xquery">This appendix lists the changes that have been made to this
specification since the publication of the XQuery 1.0 Recommendation
on 23 January 2007.</p>



<div2>
<head>Substantive Changes</head>

<p>The following substantive changes have been made.</p>

<!--

1. 2e changes

Added:

        2.5.5 SequenceType Subtype Relationships
            2.5.5.1 The SequenceType Subtype Judgement
            2.5.5.2 The ItemType Subtype Judgement

            3.1.5.1 Function Item Coercion

        3.1.6 Literal Function Items
        3.1.7 Inline Functions

    3.8 Let Expressions

Removed         F.1.1 Static Typing Extensions


Added:  type information for derived-from() -->

<olist>
  <item role="xquery">
            <p>Applied all <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/2007/qt-errata/xquery-errata.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XQuery 2ed errata</loc>.</p>
          </item>
  
  <item role="xquery">
            <p>Added <code>group by</code> clause to FLWOR Expressions (<specref ref="id-group-by"/>).</p>
          </item>
  <item role="xquery">
            <p>Added <code>tumbling window</code> and <code>sliding window</code> in FLWOR Expressions (<specref ref="id-windows"/>).</p>
          </item>
  <item role="xquery">
            <p>Added <code>count</code> clause in FLWOR Expressions (<specref ref="id-count"/>).</p>
          </item>
  <item role="xquery">
            <p>Added <code>allowing empty</code> in <specref ref="id-xquery-for-clause"/>, for functionality similar to outer joins in SQL.</p>
          </item>
  <item role="xquery">
            <p>Added <specref ref="id-try-catch"/> for handling dynamic errors and type errors.</p>
          </item>

 
  <item>
            <p>Added literal function items (<specref ref="id-literal-func-ref"/>).</p>
          </item>
  <item>
            <p>Added inline functions (<specref ref="id-inline-func"/>).</p>
          </item>
  <item>
            <p>Added dynamic function invocation (<specref ref="id-dynamic-function-invocation"/>).</p>
          </item>
  <item>
            <p>Added <specref ref="id-function-coercion"/>.</p>
          </item>
  <item>
            <p>Added <specref ref="id-sequencetype-subtype"/>, moving sequence type subtype judgements into the language specification rather than the formal semantics.</p>
          </item>
  <item role="xquery">
            <p>Added private functions (<specref ref="FunctionDeclns"/>).</p>
          </item>
  <item role="xquery">
            <p>Added support for nondeterministic functions (<specref ref="FunctionDeclns"/>)</p>
          </item>
  <item role="xquery">
            <p>Added switch expressions (<specref ref="id-switch"/>)</p>
          </item>
  <item role="xquery">
            <p>Added computed namespace constructors (<specref ref="id-computed-namespaces"/>).</p>
          </item>
  <item role="xquery">
            <p>Added output declarations (<specref ref="id-serialization"/>).</p>
          </item>
  <item role="xquery">
            <p>Added annotations (<specref ref="id-annotations"/>).</p>
          </item>
  <item role="xquery">
            <p>Added annotation assertions (<specref ref="id-annotation-assertion"/>).</p>
          </item>
  <item role="xquery">
            <p>Simplified BNF for FLWOR expressions, changed description of semantics so that each clause is understood as accepting a tuple stream as input, 
acting on that tuple stream, and producing a tuple stream as output.</p>
          </item>
  <item role="xquery">
            <p>Modified <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-ValidateExpr" xlink:type="simple">validate expressions</nt> to allow validation against a type that is explicitly specified in the query using the <code>type</code> keyword.</p>
          </item> 
  <item role="xquery">
            <p>Added support for declaring nondeterministic external functions in <specref ref="FunctionDeclns"/>, using annotations.</p>
          </item>
  <item role="xquery">
            <p>Extended <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-VarDecl" xlink:type="simple">variable declarations</nt> to allow default values for external variables.</p>
          </item>
  <item role="xquery">
            <p>Added <specref ref="id-context-item-declarations"/>.</p>
          </item>
  <item role="xquery">
            <p>Modified <specref ref="id-version-declaration"/> to add support for XQuery 1.1.</p>
          </item>
  <item role="xquery">
            <p>Added <specref ref="id-decimal-format-decl"/> to allow a query to specify formats for <function>fn:format-number()</function>. Added corresponding properties to the static context.</p>
          </item>

  <item role="xquery">
            <p>Relaxed constraints on module imports in <specref ref="id-module-import"/> to allow modules to reference each other without restriction and to remove restrictions on forwards references to global variables.</p>
          </item>
  <item role="xquery">
            <p>Modified <specref ref="id-variable-declarations"/> to clarify type information and remove ambiguities with respect to types.</p>
          </item>

  <item role="xquery">
            <p>Removed obsolete Latin-1, using  ISO-8859-1 instead. Resolves <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Bugs/Public/show_bug.cgi?id=7797" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 7797</loc>.</p>
          </item>
  <item role="xquery">
            <p>Changed conformance section to make full-axis support mandatory. Added note saying the Working Group has not yet decided which XQuery 1.1 features are optional.</p>
          </item>

  <item role="xquery">
            <p>Added normative rules for resolving module URIs to <specref ref="id-module-import"/>.</p>
          </item>

  <item>
            <p>Clarified type information available to <function>derives-from()</function> in <specref ref="id-sequencetype-matching"/>. Resolves <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Bugs/Public/show_bug.cgi?id=6513#c21" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 6513, Comment #21</loc>.</p>
          </item>

  <item>
            <p>Modified <function>derives-from()</function> in <specref ref="id-sequencetype-matching"/> to support union types. Resolves <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Bugs/Public/show_bug.cgi?id=7749#c2" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 7749</loc>.</p>
          </item>

  <item>
            <p>Added <termref def="dt-annotation-assertion">annotation assertions</termref> to <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery11-FunctionTest" xlink:type="simple">function tests</nt>.</p>
          </item>

  
  <item>
            <p>Removed section on static typing extensions.</p>
          </item>
</olist>

</div2>

<div2>
<head>Incompatibilities</head>
<p>No change in this specification introduces an incompatibility with XQuery 1.0.</p>
</div2>

<div2 role="xquery">
<head>Editorial Changes</head>

<p>The following are some of the editorial changes that have been made.</p>

<olist role="xquery">
  <item role="xquery">
            <p>Add Note to group-by section on unexpected replication of LET-bindings after grouping. Advises users to use a separate FLWOR to bind the expression, and a nested FLWOR for grouping, like this: let $x := 47 return for $e in //emps group by $d := $e/dept return f($d, $x)</p>
          </item>
  <item>
            <p>Changed introductory text on the relationship between XQuery and XPath to list the cases where a syntactically valid query can return different results in the two languages - see http://www.w3.org/Bugs/Public/show_bug.cgi?id=7163. </p>
          </item>
  <item>
            <p>Introduced definitions of scope, global scope, module scope, lexical scope, and dynamic scope to <specref ref="id-xq-context-components"/>.</p>
          </item>
  <item>
            <p>Fixed names of <code>op:hexBinary-equal</code> and <code>op:base64Binary-equal</code> in <specref ref="mapping"/>. Resolves <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Bugs/Public/show_bug.cgi?id=7048" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 7048</loc>.</p>
          </item>
  <item role="xquery">
            <p>Clarified overwriteability of the context item static type, resolving <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Bugs/Public/show_bug.cgi?id=8875#c1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 8875</loc>.</p>
          </item>
</olist>

</div2>

</inform-div1>


</back>
</spec>
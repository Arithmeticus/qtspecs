<!--XSLT Processor: SAXON 9.1.0.5 from Saxonica SAXON 9.1.0.5--><spec id="spec-top" w3c-doctype="other"><header id="spec-header"><title>Maps in XSLT and XQuery: Candidate Requirements and Use Cases</title><w3c-designation>WD-xpath-maps-30-requirements</w3c-designation><w3c-doctype>W3C Exploratory SWAT Team Document</w3c-doctype><pubdate><day>2</day><month>February</month><year>2012</year></pubdate><publoc>
      <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/Group/qtspecs/requirements/xpath-maps-30/html/Overview.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/XML/Group/qtspecs/requirements/xpath-maps-30/html/Overview.html</loc>
    </publoc><latestloc>
      <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/Group/qtspecs/requirements/xpath-maps-30/html/Overview.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/XML/Group/qtspecs/requirements/xpath-maps-30/html/Overview.html</loc>
    </latestloc><!-- <prevlocs></prevlocs> --><authlist><author><name>John Snelson</name><affiliation>MarkLogic</affiliation><email xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:john.snelson@marklogic.com" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">john.snelson@marklogic.com</email></author><author><name>Jonathan Robie</name><email xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:jonathan.robie@gmail.com" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">jonathan.robie@gmail.com</email></author><author><name>Michael Kay</name><email xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:mike@saxonica.com" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">mike@saxonica.com</email></author></authlist><!-- &status-section; --><status><p/></status><abstract><p>This document specifies candidate requirements and use cases for Maps in XSLT and XQuery in XSLT and XQuery. It has not yet been reviewed or approved by either Working Group.</p></abstract><langusage><language id="en">English</language></langusage><revisiondesc><p>First publication for the SWAT team.</p></revisiondesc></header><body><div1 id="requirements"><head>Requirements</head><div2 id="terminology"><head>Terminology</head><p>In this specification the words
    <!-- <rfc2119>must</rfc2119> -->
    <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">must</loc>,
    <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">must not</loc>,
    <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">should</loc>,
    <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">should not</loc>,
    <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">may</loc>
    and
    <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">recommended</loc>, when
    are to be interpreted as described in <bibref ref="RFC2119"/>.

    When these words are used in this technical
    sense, they occur as a hyperlink to <bibref ref="RFC2119"/>. These words will also be used with
    their conventional English meaning, in which case there is no hyperlink.</p></div2><div2 id="motivation"><head>Motivation</head><p>The XDM data model used in XSLT 2.0, XPath 2.0, and XQuery 1.0 has proved adequate for a wide range
      of requirements. On occasions, however, its limitations make themselves felt; these arise particularly
      when complex algorithms are needed, or when data structures need to be designed with particular
      attention to efficiency. Over time, a number
      of solutions to these requirements have been proposed: these include proposals for "nested sequences",
      "node references", "tuples", and "maps".
    </p><p>In the 3.0 family of specifications, functions become first-class objects in the data model, 
      and this allows many of these limitations to be circumvented. However, the resulting solutions 
      often lack usability.
    </p><p>The purpose of this document is to analyze a representative sample of use cases where the 
      limitations of the existing XDM model make themselves felt, and to abstract from these a set 
      of requirements for extending the data model with new data types and corresponding functions and operators.
    </p><p>Two particular motivations for undertaking this study were:
    </p><olist><item><p>The XSLT work on streaming. When a large source document is processed in streaming mode, 
        a processor only gets to see each piece of information in the document once, and if it wishes 
        to make use of this information later, it needs to retain the information in working variables. 
        Equivalently, a function that makes a single pass over an input document needs to return a complex 
        result, in preference to calling multiple functions that return simple results. This creates a 
        need for richer data structures to represent this working data.
      </p></item><item><p>Work in both the XSLT and XQuery communities on support for JSON. JSON support can be 
        seen as an important use case in its own right, and it can also be seen as an example of a more 
        general requirement to support externally-defined data structures other than XML. While conversion 
        of JSON to XML is not especially difficult, doing the conversion in a way that both retains all 
        information in the original input and also generates XML that is easy to manipulate has proved 
        challenging: most proposed solutions compromise one of these objectives to satisfy the other. 
        The underlying cause of this problem is the limited expressive power of the XDM data model, and 
        new data structures that more closely reflect JSON concepts such as arrays and "objects" 
        (known in other languages as maps, dictionaries, or associative arrays) are seen as a potential solution.
      </p></item></olist><p>Clearly, integration of any new data structures into the existing model is a prerequisite, and a common
      approach between XSLT and XQuery is highly desirable.
      Existing functions and operators need to be reusable with any new data structures to the maximum extent possible. 
      Integration with the existing processing models of XPath, XSLT, and XQuery is also necessary; 
      and in this respect, the starting position is that we have a core set of languages that are declarative, 
      with immutable values (though with a limited form of nondeterminism in that expression evaluation can
      return a "new" node with unique identity); layered on top of this, we have XQuery Update and Scripting 
      which provide mutable values and imperative functionality with side-effects. 
  </p></div2><div2 id="general-requirements"><head>Candidate Requirements</head><p>
      These have been identified as candidate requirements by the SWAT team currently working on this document.
      The Working Groups have made no decisions on requirements at this time.
    </p><div3 id="req-dm"><head>Data Model</head><glist role="req"><gitem><label>Multiple Results</label><def><p>
	      It <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">must</loc> be possible to return multiple sequences
	      of XDM values from a function or template invocation. In particular, it <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	      must</loc> be possible to return multiple sequence results from the application of a
	      streaming mode template in XSLT 3.0.
	    </p><p><emph>Motivation:</emph> <specref ref="streaming-query1"/></p></def></gitem><gitem><label>Compound Items</label><def><p>
              It <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">must</loc> be possible to use maps to represent
              compound values or data structures, for example the value of a complex number or a sparse matrix,
              consisting of multiple sequences of items.
            </p><p><emph>Motivation:</emph> <specref ref="streaming-query1"/>, <specref ref="complex"/></p></def></gitem><gitem><label>No observable identity</label><def><p>
              In a target language without side-effects, maps <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">must</loc> have no observable identity.
              <note><p>Currently the operations that can observe the identity of nodes are the <code>is</code>,
              <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>union</code>, <code>intersect</code>, and
              <code>except</code> operators, and any operation that exposes document order.
              </p></note>
            </p></def></gitem><gitem><label>Maps as Functions</label><def><p>
              It <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">may</loc> be possible to use maps as functions.
            </p><p><emph>Motivation:</emph> <specref ref="parameter-query3"/>, <specref ref="parameter-query4"/></p></def></gitem></glist></div3><div3><head>Keys</head><glist role="req"><gitem><label>Atomic Values as Keys</label><def><p>
		The map feature <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">may</loc> allow any atomic value
		to be used as a key.
                <note><p>
                  Specific types may be treated as exceptions; for instance, untypedAtomic may be treated as a string, NaN may be either disallowed or treated as equal to itself, etc. There may be issues related to transitivity, or reasons to restrict the types used in any one map.
                </p></note>
	      </p></def></gitem><gitem><label>String Values as Keys</label><def><p>
		The map feature <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">must</loc> allow any instance of <code>xs:string</code> or any instance of a type derived from <code>xs:string</code> to be used as a key.
	      </p><p><emph>Motivation:</emph> <specref ref="json-query1"/></p></def></gitem><gitem><label>xs:untypedAtomics as Keys</label><def><p>
		The map feature <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">must</loc> allow an <code>xs:untypedAtomic</code> to be used as a key,
	        but there is no requirement that an <code>xs:untypedAtomic</code> value be treated differently from an
	        equivalent <code>xs:string</code>.
	      </p></def></gitem><gitem><label>QNames as Keys</label><def><p>
		The map feature <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">must</loc> allow an <code>xs:QName</code> or any type derived from <code>xs:QName</code> to be used as a key.
	      </p><p><emph>Motivation:</emph> <specref ref="parameter-query1"/></p></def></gitem><gitem><label>Numeric types as Keys</label><def><p>
		The map feature <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">must</loc> allow an <code>xs:decimal</code> or any type derived from <code>xs:decimal</code> to be used as a key.
	      </p><p><emph>Motivation:</emph> <specref ref="json-query1"/></p></def></gitem><gitem><label>URIs as Keys</label><def><p>
		The map feature <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">must</loc> allow an <code>xs:anyURI</code> or any type derived from <code>xs:anyURI</code> to be used as a key.
	      </p></def></gitem><gitem><label>Dates as Keys</label><def><p>
		The map feature <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">must</loc> allow an xs:date or any type derived from xs:date to be used as a key.
	      </p></def></gitem><gitem><label>Times as Keys</label><def><p>
                The map feature <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">must</loc> allow an <code>xs:time</code> or any type derived from <code>xs:time</code> to be used as a key.
	      </p></def></gitem><gitem><label>Collations for comparing Keys</label><def><p>
	        The map feature <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">may</loc> allow the comparison of string-valued keys to be controlled
	        by a user-specified collation.
	      </p></def></gitem><gitem><label>Heterogeneous Keys</label><def><p>
		The map feature <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">may</loc> allow a
		map to exist in which different entries have keys of
		different atomic types.
	      </p></def></gitem></glist></div3><div3><head>Values</head><glist role="req"><gitem><label>Any XDM Sequence</label><def><p>
		The map feature <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">must</loc> allow any XDM
		sequence as the value part of a key/value association within a map.
	      </p><p><emph>Motivation:</emph> <specref ref="parameter-query1"/></p></def></gitem><gitem><label>Nested Maps</label><def><p>
		The map feature <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">must</loc> allow any map as the value part of a key/value association; that is, maps can nest.
	      </p><p><emph>Motivation:</emph> <specref ref="json-query1"/></p></def></gitem><gitem><label>Identity Preservation</label><def><p>
		The map feature <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">must</loc> retain the identity of XML nodes they contain.
	      </p><p><emph>Motivation:</emph> <specref ref="parameter-query1"/></p></def></gitem><gitem><label>Function Items</label><def><p>
		The map feature <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">must</loc> be able to hold function items as sub-values.
	      </p><p><emph>Motivation:</emph> <specref ref="interface"/>, <specref ref="parameter-query2"/></p></def></gitem><gitem><label>Heterogeneous Values</label><def><p>
		The map feature <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">should</loc> be able to contain heterogeneous values; that is, the value 
	        associated with any key should be an arbitrary sequence of items, potentially of a different type
	        from the values associated with other keys in the same map. In particular
                they <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">should</loc> be able to hold both function items and other data in
                different entries (or the same entry) simultaneously.
	      </p><p><emph>Motivation:</emph> <specref ref="interface"/></p></def></gitem></glist></div3><div3 id="req-operations"><head>Operations</head><glist role="req"><gitem><label>Construction</label><def><p>
		The map feature <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">must</loc> provide a convenient syntax for
		constructing a new instance of the data structure.
	      </p></def></gitem><gitem><label>Composability in Constructors</label><def><p>
		The syntax of map constructors <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">must</loc> allow an expression to occur anywhere that a value may occur.
	      </p><p><emph>Motivation:</emph> <specref ref="indexes-query1"/></p></def></gitem><gitem><label>Modified Copies</label><def><p>
		The map feature <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">must</loc> provide a convenient syntax for creating modified copies of maps, for example by the addition and deletion of entries.
	      </p><p>
		It <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">must</loc> be possible to
		identify changes to specific items in deeply nested
		maps.
	      </p></def></gitem><gitem><label>Serialization</label><def><p>
		The map feature <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">must</loc> define a JSON-compatible serialization 
	        for those maps/arrays that are representable as JSON values.
	      </p><p>
	        The map feature <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">should</loc> 
	        define a serialization for all maps.
	      </p></def></gitem><gitem><label>Member Accessors</label><def><p>
		The map feature <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">must</loc> provide a convenient syntax for
		accessing a member of a map by specifying its key.
	      </p></def></gitem><gitem><label>Key/Value Access</label><def><p>
                There <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">must</loc> be a way to access the keys and values of all the entries in a map.
	      </p></def></gitem><gitem><label>Enumerating content</label><def><p>
		It  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">must</loc> be possible to enumerate the keys, and/or the key/value associations,
		that are present in the map.
	      </p><p><emph>Motivation:</emph> <specref ref="json-query1"/></p></def></gitem><gitem><label>Language Generalization</label><def><p>
		 Existing functions and operators, and syntactic
		 constructs such as FLWOR expressions,  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">should</loc>
		 be generalized to work with any new data structures.
	      </p></def></gitem></glist></div3><div3 id="req-json"><head>JSON</head><glist role="req"><gitem><label>JSON</label><def><p>The XDM <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">must</loc> be extended with maps and arrays in such a way as to allow
	      importing and exporting JSON without loss of information.</p><p><emph>Motivation:</emph> <specref ref="json-query1"/></p></def></gitem><gitem><label>Arrays</label><def><p>
                It <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">must</loc> be possible to process all the values within an array.
              </p><p>
                It <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">must</loc> be possible to construct an arbitrary array.
	      </p><p><emph>Motivation:</emph> <specref ref="json-query1"/>, <specref ref="json-query2"/></p><note><p>
                  The Maps SWAT team believe that more in-depth work is needed on the requirements for arrays.
                </p></note></def></gitem><gitem><label>Converting among XML and JSON</label><def><p>
              The maps facility <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">must</loc> be able to express queries that convert XML to JSON, or JSON to XML.
            </p><p><emph>Motivation:</emph> <specref ref="json-query2"/></p><note><p>
              There is a consensus that there is no signle definitive canonical mapping from XML to JSON that
              satisfies all requirements that users have for such a mapping.
            </p></note></def></gitem></glist></div3><div3 id="req-apps"><head>Applications</head><glist role="req"><gitem><label>Optional Parameters</label><def><p>
              It <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">must</loc> be possible to use maps to provide sparse options to
              a function call, including options defined by a function item.
            </p><p><emph>Motivation:</emph> <specref ref="parameter-query2"/></p></def></gitem><gitem><label>Indexes</label><def><p>
              It <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">may</loc> be possible to use maps to provide indexes
              for manual optimization.
            </p><p><emph>Motivation:</emph> <specref ref="indexes-query1"/></p></def></gitem><gitem><label>Representation of FLWOR Tuples</label><def><p>
                The maps design <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">should not</loc> preclude the use of maps to represent
                the intermediate tuples in FLWOR expressions.
	      </p><note><p>
                  The Maps SWAT team did not reach consensus on this requirement.
                </p></note></def></gitem><gitem><label>Representation of PULs</label><def><p>
                The maps design <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">should not</loc> preclude the use of maps to represent
                pending update lists.
	      </p><note><p>
                  The Maps SWAT team did not reach consensus on this requirement.
                </p></note></def></gitem></glist></div3><div3 id="req-updates"><head>Updates</head><glist role="req"><gitem><label>In-situ Updates</label><def><p>
                The maps facility in XQuery <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">must not</loc> preclude providing update operations
                that add, replace, or remove entries in maps in the XQuery Update facility.
              </p><p>
		The XQuery Update Facility <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">must</loc> provide update operations
		that add, replace, or remove entries in maps.
	      </p></def></gitem></glist></div3></div2></div1><div1 id="use-cases"><head>Use Cases</head><p>The solutions provided for the following Use Cases include solutions in the following languages:</p><ulist><item><p>XSLT Maps: the maps provided in the current Working Draft of XSLT. See <bibref ref="xslt-30"/>.</p></item><item><p>XQuery 3.0: the XQuery 3.0 language, without maps. See <bibref ref="xquery-30"/>.</p></item><item><p>JSONiq: the JSONiq proposal. See <bibref ref="JSONiq"/>.</p></item></ulist><!--**************************************************--><div2 id="streaming"><head>Streaming</head><p>In a streaming application you only get one chance to look at each piece of data in the source file. Therefore, if the output is not a pure event-to-event function of the input, you have to selectively remember some of the things you have seen in the input for use later. This sometimes creates a need for data structures to hold working data in memory. This is an important motivating use case for maps in XSLT. Some of the motivating examples for XSLT can be solved in other ways in XQuery; because XQuery does not have a streaming facility, it's unclear whether maps would be the best solution for these examples in a streaming XQuery processor.</p><note><p>This is solved in XSLT 3.0 using the streaming facility.</p></note><!--     <div3 id="streaming-data"> --><!--       <head>Input Data</head> --><!--       <p>The employees.xml document:</p> --><!--       <eg role="data"><![CDATA[ --><!-- ]]></eg> --><!--     </div3> --><div3 id="streaming-query1"><head>Simple Grouping</head><p>Find the highest earning employee in each department.</p><div4><head>Solution in XQuery 3.0</head><eg xml:space="preserve">for $e in doc("employees.xml")/employees/employee,
    $d in $e/department
group by $d
return
   &lt;department name="{$d}"&gt;
     {
       let $max := max($e/salary)
       return $e[salary=$max]
     }
   &lt;/department&gt;</eg></div4><div4><head>Solution in XQuery 3.0 with XSLT Maps</head><eg xml:space="preserve">
declare function local:search-employees(
  $employees as element(employee)*,
  $highest-earners as map(xs:string, element(employee))
)
{
  if(empty($employees)) then $highest-earners else

  let $this := head($employees)
  let $existing := $highest-earners($this/department)
  let $new-earners :=
    if ($existing/salary gt $this/salary) then $highest-earners
    else map:new(($highest-earners, map:entry($this/department, $this)))
  return local:search-employees(tail($employees), $new-earners)
};

let $highest-earners := local:search-employees(doc("employees.xml")/*/employee, map:new())
for $department in map:keys($highest-earners)
return
  &lt;department name="{$department}"&gt;{ $highest-earners($department) }&lt;/department&gt;
</eg></div4><div4><head>Solution in XSLT 3.0</head><eg xml:space="preserve">
&lt;xsl:stream href="employees.xml"&gt;
  &lt;xsl:iterate select="*/employee"&gt;
    &lt;xsl:param name="highest-earners"
               as="map(xs:string, element(employee))"
               select="map:new()"/&gt;
    &lt;xsl:variable name="this" select="copy-of(.)" as="element(employee)"/&gt;
    &lt;xsl:next-iteration&gt;
      &lt;xsl:with-param name="highest-earners"
                      select="let $existing := $highest-earners($this/department)
                              return if ($existing/salary gt $this/salary)
                                then $highest-earners
                                else map:new(($highest-earners,
                                  map:entry($this/department, $this)))"/&gt;
    &lt;/xsl:next-iteration&gt;
    &lt;xsl:on-completion&gt;
      &lt;xsl:for-each select="map:keys($highest-earners)"&gt;
        &lt;department name="{.}"&gt;
          &lt;xsl:copy-of select="$highest-earners(.)"/&gt;
        &lt;/department&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:on-completion&gt;
  &lt;/xsl:iterate&gt;
&lt;/xsl:stream&gt;
</eg></div4><!--       <div4> --><!--         <head>Result</head> --><!--           <eg role="result"><![CDATA[ --><!-- ]]></eg> --><!--       </div4> --></div3><div3 id="streaming-query2"><head>Simultaneous Grouping</head><p>Find both the highest earning employee in each department, and the total number of employees to job-type across all departments.</p><div4><head>Solution in XQuery 3.0</head><eg xml:space="preserve">
for $employee in doc("employees.xml")/*/employee
let $salary := $employee/salary
group by $department := $employee/department
let $max-salary := max($salary)
let $highest-earners := $employee[salary = $max-salary]
return
   &lt;department name="{$department}"&gt;{ $highest-earners }&lt;/department&gt;,

for $employee in doc("employees.xml")/*/employee
let $salary := $employee/salary
group by $job-type := $employee/job-type
let $totals := count($employee)
return
   &lt;total-by-job-type type="{$job-type}"&gt;{ $totals }&lt;/total-by-job-type&gt;

	  </eg></div4><div4><head>Solution in XQuery 3.0 with XSLT Maps</head><eg xml:space="preserve">
declare function local:search-employees(
  $employees as element(employee)*,
  $highest-earners as map(xs:string, element(employee),
  $totals as map(xs:string, xs:double))
)
{
  if(empty($employees)) then ($highest-earners, $totals) else

  let $this := head($employees)
  let $existing := $highest-earners($this/department)
  let $new-earners :=
    if ($existing/salary gt $this/salary) then $highest-earners
    else map:new(($highest-earners, map:entry($this/department, $this)))
  let $job-type := $this/job-type/string()
  let $new-totals := map:new(($totals, map { $job-type := $totals($job-type) + 1 }))
  return local:search-employees(tail($employees), $new-earners, $new-totals)
};

let $results := local:search-employees(doc("employees.xml")/*/employee, map:new())
let $highest-earners := $results[1]
let $totals := results[2]
return (
  for $department in map:keys($highest-earners)
  return
    &lt;department name="{$department}"&gt;{ $highest-earners($department) }&lt;/department&gt;,
  for $job-type in map:keys($totals)
  return
    &lt;total-by-job-type type="{$job-type}"&gt;{ $totals($job-type) }&lt;/total-by-job-type&gt;
)
</eg></div4><!--       <div4> --><!--         <head>Result</head> --><!--           <eg role="result"><![CDATA[ --><!-- ]]></eg> --><!--       </div4> --></div3><div3 id="streaming-query3"><head>Word Count by Lemma</head><p>Calculate the word count by lemma of the verbs in the following document.</p><div4 id="streaming-query3-data"><head>Input Data</head><p>The XML document, gnt.xml.</p><eg role="data" xml:space="preserve">
&lt;gnt&gt;
&lt;s&gt;
 &lt;w pos="PP"&gt;I&lt;/w&gt;
 &lt;w pos="V" lemma="go"&gt;go&lt;/w&gt;
 &lt;pu&gt;.&lt;/pu&gt;
&lt;/s&gt;
&lt;s&gt;
 &lt;w pos="PP"&gt;She&lt;/w&gt;
 &lt;w pos="V" lemma="go"&gt;went&lt;/w&gt;
 &lt;pu&gt;.&lt;/pu&gt;
&lt;/s&gt;
&lt;s&gt;
 &lt;w pos="PP"&gt;He&lt;/w&gt;
 &lt;w pos="V" lemma="go"&gt;goes&lt;/w&gt;
 &lt;pu&gt;.&lt;/pu&gt;
&lt;/s&gt;
&lt;s&gt;
 &lt;w pos="PP"&gt;I&lt;/w&gt;
 &lt;w pos="V" lemma="see"&gt;see&lt;/w&gt;
 &lt;pu&gt;.&lt;/pu&gt;
&lt;/s&gt;
&lt;s&gt;
 &lt;w pos="PP"&gt;She&lt;/w&gt;
 &lt;w pos="V" lemma="see"&gt;sees&lt;/w&gt;
 &lt;pu&gt;.&lt;/pu&gt;
&lt;/s&gt;
&lt;s&gt;
 &lt;w pos="PP"&gt;I&lt;/w&gt;
 &lt;w pos="V" lemma="have"&gt;have&lt;/w&gt;
 &lt;pu&gt;.&lt;/pu&gt;
&lt;/s&gt;
&lt;s&gt;
 &lt;w pos="PP"&gt;She&lt;/w&gt;
 &lt;w pos="V" lemma="have"&gt;has&lt;/w&gt;
 &lt;pu&gt;.&lt;/pu&gt;
&lt;/s&gt;
&lt;/gnt&gt;
</eg></div4><div4><head>Result</head><eg role="result" xml:space="preserve">
&lt;verb lemma="go" count="3"/&gt;
&lt;verb lemma="see" count="2"/&gt;
&lt;verb lemma="have" count="2"/&gt;
</eg></div4><div4><head>Solution in XQuery 3.0 with XSLT Maps:</head><eg xml:space="preserve">
declare function local:word-count($words, $result)
{
  if(empty($words)) then $result else

  let $word := head($words)
  return local:word-count(tail($words),
    map:new(($result, map { $word/@lemma := ($result($word/@lemma), 0)[1] + 1 })))
};

let $counts := local:word-count(doc("gnt.xml")//w[m:is-verb(.)], map{})
for $lemma in map:keys($counts)
let $count := $counts($lemma)
order by $count
return
  &lt;verb lemma="{ $lemma }" count="{ $count }"/&gt;
</eg></div4><div4><head>Alternative Solution in XQuery 3.0 with XSLT Maps:</head><eg xml:space="preserve">
let $counts := fold-left(function($map, $word) {
    map:new(($result, map { $word/@lemma := ($map($word/@lemma), 0)[1] + 1 }))
  }, map{}, doc("gnt.xml")//w[m:is-verb(.)])
for $lemma in map:keys($counts)
let $count := $counts($lemma)
order by $count
return
  &lt;verb lemma="{ $lemma }" count="{ $count }"/&gt;
</eg></div4><div4><head>Solution Using Grouping in XQuery 3.0:</head><p>A solution just using grouping, without maps.</p><eg xml:space="preserve">
for $word in doc("gnt.xml")//w
let $lemma := $word/@lemma
where m:is-verb($word)
group by $lemma
order by count($word) descending
return
  &lt;verb lemma="{ $lemma }" count="{count($word)}" /&gt;
</eg></div4><div4><head>Solution in XSLT 3.0:</head><eg xml:space="preserve">
&lt;xsl:iterate select="doc("gnt.xml")//w"&gt;
  &lt;xsl:param name="result" select="map{}"/&gt;
  &lt;xsl:next-iteration&gt;
    &lt;xsl:with-param name="result"
      select="map:new(($map, map { $word := ($map($word), 0)[1] + 1 }))"/&gt;
  &lt;/xsl:next-iteration&gt;
  &lt;xsl:on-completion&gt;
    &lt;xsl:for-each select="map:keys($result)"&gt;
      &lt;xsl:sort select="$result(.)"/&gt;
      &lt;verb lemma="{ . }" count="{ $result(.) }"/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:on-completion&gt;
&lt;/xsl:iterate&gt;
</eg></div4></div3></div2><!--**************************************************--><div2 id="complex"><head>Compound Values</head><div3 id="complex-query1"><head>Complex Number Library</head><p>
      Implement a complex number library for XQuery or XSLT 3.0. Complex numbers should be represented as a single item, so they
      can themselves be manipulated like regular numbers by returning sequences of them etc.
    </p><div4><head>Solution in XQuery 3.0 with XSLT Maps:</head><eg xml:space="preserve">
declare function i:complex(
  $real as xs:double,
  $imaginary as xs:double
) as map(xs:boolean, xs:double)
{
  map{ true() := $real, false() := $imaginary }
};

declare function i:real(
  $complex as map(xs:boolean, xs:double)
) as xs:double
{
  $complex(true())
};

declare function i:imaginary(
  $complex as map(xs:boolean, xs:double)
) as xs:double
{
  $complex(false())
};

declare function i:add(
  $arg1 as map(xs:boolean, xs:double),
  $arg2 as map(xs:boolean, xs:double)
) as map(xs:boolean, xs:double)
}
  i:complex(i:real($arg1)+i:real($arg2),
    i:imaginary($arg1)+i:imaginary($arg2))
};

declare function i:multiply(
  $arg1 as map(xs:boolean, xs:double),
  $arg2 as map(xs:boolean, xs:double)
) as map(xs:boolean, xs:double)
{
  i:complex(
    i:real($arg1)*i:real($arg2) - i:imaginary($arg1)*i:imaginary($arg2),
    i:real($arg1)*i:imaginary($arg2) + i:imaginary($arg1)*i:real($arg2))
};
</eg></div4><div4><head>Solution in XSLT 3.0 (using type-alias proposal, still in discussion):</head><eg xml:space="preserve">
&lt;xsl:type-alias name="i:complex" as="map(xs:boolean, xs:double)"/&gt;

&lt;xsl:function name="i:complex" as="i:complex"&gt;
&lt;xsl:param name="real" as="xs:double"/&gt;
&lt;xsl:param name="imaginary" as="xs:double"/&gt;
&lt;xsl:sequence select="map{ true() := $real, false() := $imaginary }"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:function name="i:real" as="xs:double"&gt;
&lt;xsl:param name="complex" as="i:complex"/&gt;
&lt;xsl:sequence select="$complex(true())"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:function name="i:imaginary" as="xs:double"&gt;
&lt;xsl:param name="complex" as="i:complex"/&gt;
&lt;xsl:sequence select="$complex(false())"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:function name="i:add" as="i:complex"&gt;
&lt;xsl:param name="arg1" as="i:complex"/&gt;
&lt;xsl:param name="arg2" as="i:complex"/&gt;
&lt;xsl:sequence select="i:complex(i:real($arg1)+i:real($arg2),
  i:imaginary($arg1)+i:imaginary($arg2))"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:function name="i:multiply" as="i:complex"&gt;
&lt;xsl:param name="arg1" as="i:complex"/&gt;
&lt;xsl:param name="arg2" as="i:complex"/&gt;
&lt;xsl:sequence select="i:complex(
       i:real($arg1)*i:real($arg2) - i:imaginary($arg1)*i:imaginary($arg2),
       i:real($arg1)*i:imaginary($arg2) + i:imaginary($arg1)*i:real($arg2))"/&gt;
&lt;/xsl:function&gt;
</eg></div4></div3></div2><!--**************************************************--><div2 id="indexes"><head>Manual Indexing</head><p>Build an index to manually optimize retrieval of books in a catalog by their ISBN number.</p><div3 id="indexes-query1"><head>Simple Manual Join</head><p>Construct a list of all authors, and the books they have written.</p><div4 id="indexes-data"><head>Input Data</head><p>Book elements of the form:</p><eg role="data" xml:space="preserve">
&lt;book&gt;
&lt;isbn&gt;0470192747&lt;/isbn&gt;
&lt;publisher&gt;Wiley&lt;/publisher&gt;
&lt;title&gt;XSLT 2.0 and XPath 2.0 Programmer's Reference&lt;/title&gt;
&lt;/book&gt;
</eg><p>Author elements of the form:</p><eg role="data" xml:space="preserve">
&lt;author&gt;
&lt;author&gt;Michael H. Kay&lt;/author&gt;
&lt;isbn&gt;0470192747&lt;/isbn&gt;
&lt;isbn&gt;...&lt;/isbn&gt;
&lt;/book&gt;
</eg></div4><div4><head>Solution in XQuery 3.0 with XSLT Maps:</head><eg xml:space="preserve">
declare variable $index := map:new(//book ! map{isbn := .});

&lt;table&gt;{
  for $a in //author
  return &lt;tr&gt;
    &lt;td&gt;{ $a/name/string() }&lt;/td&gt;
    &lt;td&gt;{ string-join($a/isbn ! $index(.)/title/string(), ", ") }&lt;/td&gt;
  &lt;/tr&gt;
}&lt;/table&gt;
</eg></div4><div4><head>Solution in XSLT 3.0:</head><p>
          XSLT has the xsl:key functionality, which is preferable. However, a straight forward translation
          from the XQuery solution follows:
        </p><eg xml:space="preserve">
&lt;xsl:variable name="index" select="map:new(//book ! map{isbn := .})"/&gt;

&lt;table&gt;
  &lt;xsl:for-each select="//author"&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;xsl:value-of select="name"/&gt;&lt;/td&gt;
      &lt;td&gt;&lt;xsl:value-of select="string-join(isbn ! $index(.)/title/string(), ', ')"/&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/xsl:for-each&gt;
}&lt;/table&gt;
</eg></div4></div3></div2><!--**************************************************--><div2 id="interface"><head>Interface / Implementation Pattern</head><p>As in Javascript, a map whose keys are strings and whose associated
    values are function items can be used in a similar way to a class in
    object-oriented programming languages.</p><div3 id="interface-query1"><head>Data Variety</head><p>Suppose an application needs to handle customer order information that
    may arrive in three different formats, with different hierarchic
    arrangement.</p><p>An application can isolate itself from these differences by defining a
      set of functions to navigate the relationships between customers,
      orders, and products: orders-for-customer, orders-for-product,
      customer-for-order, product-for-order. These functions can be
      implemented in different ways for the three different input formats.</p><div4 id="interface-data1"><head>Input Data</head><p>Flat structure:</p><eg role="data" xml:space="preserve">
&lt;customer id="c123"&gt;...&lt;/customer&gt;
&lt;product id="p789"&gt;...&lt;/product&gt;
&lt;order customer="c123" product="p789"&gt;...&lt;/order&gt;
</eg><p>Orders within customer elements:</p><eg role="data" xml:space="preserve">
&lt;customer id="c123"&gt;
&lt;order product="p789"&gt;...&lt;/order&gt;
&lt;/customer&gt;
&lt;product id="p789"&gt;...&lt;/product&gt;
</eg><p>Orders within product elements:</p><eg role="data" xml:space="preserve">
&lt;customer id="c123"&gt;...&lt;/customer&gt;
&lt;product id="p789"&gt;
&lt;order customer id="c123"&gt;...&lt;/order&gt;
&lt;/product&gt;
</eg></div4><div4><head>Solution in XQuery 3.0 with XSLT Maps:</head><p>For example, with the first format the implementation might be:</p><eg xml:space="preserve">
let $flat-input-functions as map(xs:string, function(*))*
return map {
  'orders-for-customer' := function($c as element(customer)) as element(order)*
    { $c/../order[@customer=$c/@id] },
  'orders-for-product' := function($p as element(product)) as element(order)*
    { $p/../order[@product=$p/@id] },
  'customer-for-order' := function($o as element(order)) as element(customer)
    { $o/../customer[@id=$o/@customer] },
  'product-for-order' := function($o as element(order)) as element(product)
    { $o/../product[@id=$o/@product] }
}
</eg></div4><div4><head>Solution in XSLT 3.0:</head><eg xml:space="preserve">
&lt;xsl:variable name="flat-input-functions" as="map(xs:string, function(*))*"
   select="map {
             'orders-for-customer' :=
                  function($c as element(customer)) as element(order)*
                     {$c/../order[@customer=$c/@id]},
             'orders-for-product' :=
                  function($p as element(product)) as element(order)*
                     {$p/../order[@product=$p/@id]},
             'customer-for-order' :=
                  function($o as element(order)) as element(customer)
                     {$o/../customer[@id=$o/@customer]},
             'product-for-order' :=
                  function($o as element(order)) as element(product)
                     {$o/../product[@id=$o/@product]} }
          "/&gt;
</eg></div4></div3><div3 id="interface-query2"><head>Search and Snippeting</head><p>Create a general interface that takes as input some words, does a
full-text search for them, and returns snippets of the top 10 results,  
ordered
by score, where the nodes to search, their structure, how to construct  
snippets
and how to score them differ for different data sets.</p><div4><head>Solution in XQuery Full Text 3.0 with XSLT Maps:</head><p>Create a template method and use a map of functions to define the
implementation of the plug-in points.</p><eg xml:space="preserve">
(: General interface module :)

module namespace this="http://example.com/search-interface/";

declare function this:search(
    $words as xs:string*, $collection as map(xs:string, function(*)) )
{
    (for $d in $collection('select')[. contains text {$words} any word]
     order by $collection('score', $d, $words)
     return $collection('snippet', $d, $words))[position()&lt;=10]
};

(: Specific implementation example :)

import module namespace s="http://example.com/search-interface/";

declare variable $twitter as map(xs:string, function(*)) :=
    map {
      'select' := function() as node()*
          { collection("twitter") },
      'score' := function($n as node(), $words as xs:string*) as xs:double
          { let score $s1 := $n contains text {$words} any word
            let score $s2 := $n contains text {$words} all words
            return $s1 + $s2
          },
      'snippet' := function($node as node(), $words as xs:string*) as node()
          { $node },
    };

declare variable $blog as map(xs:string, function(*)) :=
    map {
      'select' := function() as node()*
          { collection("blogs")/body },
      'score' := function($n as node(), $words as xs:string*) as xs:double
          {
            let $s1 :=
              avg(
                for $p score $s in $n/para[. contains text {$words} any  
word]
                return $s)
            let $s2 :=
              avg(
                for $p score $s in
                  $n/comment[. contains text {$words} weight 0.5 any word]
                return $s)
            let score $s3 := $n/title contains text {$words} weight 5.0 any  
word
            return $s1 + $s2 + $s3
          },
      'snippet' := function($node as node(), $words as xs:string*) as node()
          { &lt;result&gt;{$node/title, $node/para[1], $node/comment[1]}&lt;/result&gt;  
},
    };

declare variable $books as map(xs:string, function(*)) :=
    map {
      'select' := function() as node()*
          { collection()//chapter },
      'score' := function($n as node(), $words as xs:string*) as xs:double
          { let score $s1 := $n contains text {$words} any word
            let score $s2 := $n/title contains text {$words} weight 5.0 any  
word
            return $s1 + $s2
          },
      'snippet' := function($node as node(), $words as xs:string*) as node()
          { &lt;result&gt;{$node/title,
            ((for $p score $s in $node/p[. contains text {$words} all words]
              order by $s
              return $p),
             (for $p score $s in $node/p[. contains text {$words} any word]
              order by $s
              return $p))[1]
            }&lt;/result&gt; },
    };

(: Get top 10 from various sources :)
s:search(("fire","earthquake"),$books),
s:search(("fire","earthquake"),$twitter),
s:search(("fire","earthquake"),$blog)
</eg></div4></div3><div3 id="interface-query3"><head>Abstracting Document Structure</head><p>Provide access to various pieces of metadata to application,  
      insulating that application code from variations in document structure.</p><div4><head>Solution in XQuery 3.0 with XSLT Maps:</head><p>Define the metadata interface through a map of functions.</p><eg xml:space="preserve">
(: Specific implementations :)
declare namespace xh="http://www.w3.org/1999/xhtml";
declare variable $xhtml as map(xs:string, function(*)) :=
    map {
      'title' := function($n as document-node()) as xs:string?
          { $n/xh:head/xh:title },
      'author' := function($n as document-node()) as xs:string?
          { $n/xh:head/xh:meta[@name='author']/@content },
      'pubdate' := function($n as document-node()) as xs:string?
          { $n/xh:head/xh:meta[@name='created']/@content },
      'publisher' := function($n as document-node()) as xs:string?
          { () }
    };

declare variable $medline-citation as map(xs:string, function(*)) :=
    map {
      'title' := function($n as document-node()) as xs:string?
          { $n/MedlineCitation/Article/ArticleTitle },
      'author' := function($n as document-node()) as xs:string?
          {
            string-join(
              for $a in $n/MedlineCitation//Author return
              concat($a/LastName, ", ", $a/ForeName), "; ")
          },
      'pubdate' := function($n as document-node()) as xs:string?
          {
             let $d := $n/MedlineCitation/Article/PubDate
             return string-join(($d/Day,$d/Month,$d/Year), " ")
          },
      'publisher' := function($n as document-node()) as xs:string?
          {  $n/MedlineCitation/MedlineJournalIngo/MedlineTA }
    };
</eg></div4></div3></div2><!--**************************************************--><div2 id="parameter"><head>Parameter Passing</head><p>Often library functions may have a large number of optional arguments, which are awkward or impossible to
    provide using the existing mechanism of variable arity functions.</p><div3 id="parameter-query1"><head>XSLT Stylesheet Parameters</head><p>Pass the list of parameter names and values to the xdmp:xslt-invoke() function, which invokes
      an XSLT stylesheet.</p><div4><head>Solution in XQuery 3.0 with XSLT Maps:</head><eg xml:space="preserve">
declare function xdmp:xslt-invoke($path as xs:string, $input as node(),
  $params as map(xs:QName, item()*)) as document-node()* external;

xdmp:xslt-invoke("my-stylesheet.xsl", doc("my-doc.xml"), map {
  xs:QName("toc") := true(),
  xs:QName("index") := doc("index_terms.xml")
})
</eg></div4></div3><div3 id="parameter-query2"><head>Function Options</head><p>Provide a machanism to supply (otherwise defaulted) option values to the fn:doc() function, which control aspects of it's behaviour, including:
      </p><ulist><item><p>Parsing of external entities</p></item><item><p>DTD validation</p></item><item><p>XML Schema validation</p></item><item><p>Lax (XML Schema) validation</p></item><item><p>Whitespace stripping</p></item><item><p>URI resolution</p></item></ulist><p>Using maps in this scenario brings benefits over using XML structure, including:</p><ulist><item><p>Nodes are not copied; identity is retained</p></item><item><p>Atomic items are not serialized, and retain their specific type</p></item><item><p>Functions can be passed in as options - the relevant example in this case being the URI resolver.</p></item></ulist><div4><head>Solution in XQuery 3.0 with XSLT Maps:</head><eg xml:space="preserve">
declare function fn:doc($uri as xs:string, $options as map(xs:string, item()*)) as document-node()? external;

(: Enable lax XML Schema validation :)
doc("validate-me.xml", map {
  "schema-validation" := true(),
  "lax-validation" := true()
}),

(: Enable whitespace stripping, and a custom URI resolution :)
doc("../relative-uri.xml", map {
  "strip-whitespace" := true(),
  "uri-resolver" := resolve-uri(?, base-uri())
})
</eg></div4><div4><head>Solution in XQuery 3.0 with XSLT Maps enhanced with stronger typing:</head><eg xml:space="preserve">
declare function fn:doc(
  $uri as xs:string,
  $options as strong-map(
    external-entities as xs:boolean?,
    dtd-validation as xs:boolean?,
    schema-validation as xs:boolean?,
    lax-validation as xs:boolean?,
    strip-whitespace as xs:boolean?,
    uri-resolver as function(xs:string) as xs:string
  )
) as document-node()? external;

(: Enable lax XML Schema validation :)
doc("validate-me.xml", map {
  xs:QName("schema-validation") := true(),
  xs:QName("lax-validation") := true()
}),

(: Enable whitespace stripping, and a custom URI resolution :)
doc("../relative-uri.xml", map {
  xs:QName("strip-whitespace") := true(),
  xs:QName("uri-resolver") := resolve-uri(?, base-uri())
})
</eg></div4></div3><div3 id="parameter-query3"><head>Translation</head><p>Design a language-agnostic game (here just the core), which allows a translation function or map as a parameter.</p><div4><head>Solution in XQuery 3.0 with XSLT Maps:</head><eg xml:space="preserve">
declare function local:play(
  $secret-number as xs:integer,
  $guessed-number as xs:integer,
  $translator as function(xs:string) as xs:string)
{
  switch (true())
  case $guessed-number eq $secret-number
    return $translator("You won!")
  case $guessed-number lt $secret-number
    return $translator("The secret number is greater.")
  default case (: $guessed-number gt $secret-number :)
    return $translator("The secret number is lower.")
};

local:play(76, 86, function($x) { $x }), (: Keep English :)

local:play(76, 86, map {
  "You won!" := "Du hast gewonnen!",
  "The secret number is greater." := "Die geheime Zahl ist groesser.",
  "The secret number is lower." :=  Die geheime Zahl ist kleiner." }
),

local:play(76, 86, $automated-translator-based-on-natural-language-processing)
</eg></div4></div3><div3 id="parameter-query4"><head>Cipher Functions</head><p>Provide an encryption function which will encode some input according to a cipher that can be a codebook implemented as a map or an explicit algorithm.</p><div4><head>Solution in XQuery 3.0 with XSLT Maps:</head><eg xml:space="preserve">
declare function local:encode(
  $input as xs:string,
  $cipher as function(xs:integer) as xs:integer)
{
  codepoints-to-string($cipher(string-to-codepoints($input)))
};

let $code := {
  string-to-codepoints("a") := string-to-codepoints("z"),
  string-to-codepoints("b") := string-to-codepoints("e"),
  ...
}
return
local:encode("Message", $code),

local:encode("Message",
  function($c) { $c + 3 (: Caesar's cipher :) })
</eg></div4></div3></div2><!--**************************************************--><div2 id="json"><head>JSON</head><p>JSON is becoming an important data format that many XQuery and XSLT users have to deal with.
    Tasks performed can include importing JSON, processing it, and exporting JSON.</p><div3 id="json-query1"><head>Information Retrieval</head><p>Import a JSON document and retrieve the mobile phone number from it.</p><p>
        The fn:parse-json() function parses a JSON document into an XDM value as follows:
      </p><olist><item><p>A JSON object is converted into a map of type map(xs:string, item()?).</p></item><item><p>A JSON array is converted into a map of type map(xs:integer, item()?).</p></item><item><p>A JSON string is converted into an xs:string atomic value.</p></item><item><p>A JSON number is converted into an xs:double atomic value.</p></item><item><p>A JSON boolean is converted into an xs:boolean atomic value.</p></item><item><p>A JSON null is converted into the empty sequence.</p></item></olist><div4 id="json-query1-data"><head>Input Data</head><p>The JSON document, mildred.json:</p><eg role="data" xml:space="preserve">
{
     "firstname": "Mildred",
     "lastname": "Moore",
     "age": 32,
     "address":
     {
         "street": "91 High Street",
         "town": "Biscester",
         "county": "Oxfordshire",
         "postcode": "OX6 3PD"
     },
     "phone":
     [
         {
           "type": "home",
           "number": "01869 378073"
         },
         {
           "type": "mobile",
           "number": "07356 740756"
         }
     ]
}</eg></div4><div4><head>Result</head><eg role="result" xml:space="preserve">
"07356 740756"
</eg></div4><div4><head>Solution in XQuery 3.0 with XSLT Maps:</head><!-- <ednote><name>John Snelson</name> --><!-- <edtext>This solution is overly complex - I think we need an easier way to iterate the values from --><!-- a JSON array.</edtext></ednote> --><eg xml:space="preserve">
let $phoneArray := parse-json(unparsed-text("mildred.json"))("phone")
for $n in map:keys($phoneArray)
let $entry := $phoneArray($n)
where $entry("type") = "mobile"
return $entry("number")
</eg></div4><div4><head>Alternative Solution in XQuery 3.0 with XSLT Maps:</head><eg xml:space="preserve">
declare function map:entries($map as map(*)) as map(*)*
{
  for $k in map:keys($map)
  return map { "key" := $k, "value" := $map($k) }
};

parse-json(unparsed-text("mildred.json"))
  ("phone")!map:entries(.)[.("value")("type") = "mobile"]("number")
</eg></div4><div4><head>Solution in JSONiq:</head><eg xml:space="preserve">
	let $mildred := json("mildred.json")
	let $phones := values($mildred("phone"))
	return $phones[.("type") = "mobile"]("number")
</eg></div4></div3><div3 id="json-query2"><head>Converting JSON to XML</head><p>Convert a JSON data file to XML.</p><div4 id="json-query2-data"><head>Input Data</head><p>The JSON document, employees.json:</p><eg role="data" xml:space="preserve">
{ "accounting" : [
      { "firstName" : "John",
        "lastName"  : "Doe",
        "age"       : 23 },

      { "firstName" : "Mary",
        "lastName"  : "Smith",
        "age"       : 32 }
                 ],
  "sales"     : [
      { "firstName" : "Sally",
        "lastName"  : "Green",
        "age"       : 27 },

      { "firstName" : "Jim",
        "lastName"  : "Galley",
        "age"       : 41 }
                  ]
}</eg></div4><div4><head>Result</head><eg role="result" xml:space="preserve">
&lt;department name="accounting"&gt;
  &lt;employee&gt;
    &lt;firstName&gt;John&lt;/firstName&gt;
    &lt;lastName&gt;Doe&lt;/lastName&gt;
    &lt;age&gt;23&lt;/age&gt;
  &lt;/employee&gt;
  &lt;employee&gt;
    &lt;firstName&gt;Mary&lt;/firstName&gt;
    &lt;lastName&gt;Smith&lt;/lastName&gt;
    &lt;age&gt;32&lt;/age&gt;
  &lt;/employee&gt;
&lt;/department&gt;
&lt;department name="sales"&gt;
  &lt;employee&gt;
    &lt;firstName&gt;Sally&lt;/firstName&gt;
    &lt;lastName&gt;Green&lt;/lastName&gt;
    &lt;age&gt;27&lt;/age&gt;
  &lt;/employee&gt;
  &lt;employee&gt;
    &lt;firstName&gt;Jim&lt;/firstName&gt;
    &lt;lastName&gt;Galley&lt;/lastName&gt;
    &lt;age&gt;41&lt;/age&gt;
  &lt;/employee&gt;
&lt;/department&gt;
</eg></div4><div4><head>Solution in XQuery 3.0 with XSLT Maps:</head><eg xml:space="preserve">
let $input := parse-json(unparsed-text('employees.json'))
for $k in map:keys($input)
return
  &lt;department name="{$k}"&gt;{
    let $array := $input($k)
    for $i in map:keys($array)
    let $emp := $array($i)
    return
      &lt;employee&gt;
        &lt;firstName&gt;{ $emp('firstName') }&lt;/firstName&gt;
        &lt;lastName&gt;{ $emp('lastName') }&lt;/lastName&gt;
        &lt;age&gt;{ $emp('age') }&lt;/age&gt;
      &lt;/employee&gt;
  }&lt;/department&gt;
</eg></div4><div4><head>Solution in JSONiq:</head><eg xml:space="preserve">
for $dept in pairs(json("employees.json"))
return
   &lt;department name="{ name($dept) }"&gt; {
       for $employee in members(value($dept))
       return
         &lt;employee&gt;
           &lt;firstName&gt;{ $employee('firstName') }&lt;/firstName&gt;
           &lt;lastName&gt;{ $employee('lastName') }&lt;/lastName&gt;
           &lt;age&gt;{ $employee('age') }&lt;/age&gt;
         &lt;/employee&gt;
   }&lt;/department&gt;
     </eg></div4><div4><head>Solution in XSLT 3.0:</head><eg xml:space="preserve">
&lt;xsl:template name="main"&gt;
  &lt;xsl:variable name="input"
                as="map(xs:string, map(xs:string, xs:anyAtomicType)*)"
                select="parse-json(unparsed-text('employees.json'))"/&gt;
  &lt;xsl:for-each select="map:keys($input)"&gt;
    &lt;department name="{.}"&gt;
      &lt;xsl:for-each select="$input(.)"&gt;
        &lt;employee&gt;
          &lt;firstName&gt;&lt;xsl:value-of select=".('firstName')"/&gt;&lt;/firstName&gt;
          &lt;lastName&gt;&lt;xsl:value-of select=".('lastName')"/&gt;&lt;/lastName&gt;
          &lt;age&gt;&lt;xsl:value-of select=".('age')"/&gt;&lt;/age&gt;
        &lt;/employee&gt;
      &lt;/xsl:for-each&gt;
    &lt;/department&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;
</eg></div4></div3><div3 id="json-query3"><head>Update by Copying</head><p>Update the first name of the author "Dan Suciu" to "John" in the "bookinfo.json" document.</p><div4 id="json-query3-data"><head>Input Data</head><p>The JSON document, bookinfo.json:</p><eg role="data" xml:space="preserve">
{
    "book": {
        "title": "Data on the Web",
        "year": 2000,
        "author": [
            {
                "last": "Abiteboul",
                "first": "Serge"
            },
            {
                "last": "Buneman",
                "first": "Peter"
            },
            {
                "last": "Suciu",
                "first": "Dan"
            }
        ],
        "publisher": "Morgan Kaufmann Publishers",
        "price": 39.95
    }
}</eg></div4><div4><head>Solution in XQuery 3.0 with XSLT Maps:</head><eg xml:space="preserve">
declare function local:map-transform($map as map(*))
{
  typeswitch($arg)
  case $map as map(*) return
    map:new((
      for $k in map:keys($map)
      let $v := $map($k)
      return map { $k := local:map-transform($v) },
      if($map('last')='Suciu') then map { 'first' := "John" } else ()
    ))
  default $arg
};

local:map-transform(parse-json(unparsed-text("bookinfo.json")))
</eg></div4><div4><head>Solution in XSLT 3.0:</head><p>Assuming a function map:entries() which returns the entries in a map
        as a sequence of singleton maps.</p><!-- <ednote><name>John Snelson</name> --><!-- <edtext>This solution does not look correct to me.</edtext></ednote> --><eg xml:space="preserve">
&lt;xsl:template match="~map(*)" mode="john" as="map(*)"&gt;
  &lt;xsl:variable name="entries" as="map(*)*&gt;
    &lt;xsl:apply-templates select="map:entries(.)" mode="john"/&gt;
  &lt;/xsl:variable&gt;
  &lt;xsl:sequence select="map:new($entries)"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="~map(*)[.('last')='Suciu']" mode="john"&gt;
  &lt;xsl:sequence select="map:new((., map{'first':='John'}))"/&gt;
&lt;/xsl:template&gt;
</eg></div4></div3><!--
#############################################################################
#############################################################################
#############################################################################
--><div3 id="json.joins"><head>Joins</head><div4><head>Input Data</head><p>The following queries are based on a social media site that allows users to interact with their friends. <code>collection("users")</code> contains data on users and their friends:</p><eg xml:space="preserve">{
  "name" : "Sarah",
  "age" : 13,
  "gender" : "female",
  "friends" : [ "Jim", "Mary", "Jennifer"]
}

{
  "name" : "Jim",
  "age" : 13,
  "gender" : "male",
  "friends" : [ "Sarah" ]
}
          </eg></div4><div4><head>Solution in JSONiq:</head><p>The following query performs a join on Sarah's friend list to return the Object representing each of her friends:</p><eg xml:space="preserve">for $sarah in collection("users")
    $friend in collection("users")
where $sarah("name") = "Sarah"
  and values($sarah("friends")) = $friend("name")
return $friend </eg><p>The query can be simplified using a filter. In the following expression, <code>[.("name") = "Sarah"]</code> is a filter that restricts the set of users to the one named "Sarah":</p><eg xml:space="preserve">let $sarah := collection("users")[.("name") eq "Sarah"]
for $friend in values($sarah("friends"))
return collection("users")[.("name") eq $friend]
          </eg></div4><div4><head>Solution in XSLT 3.0:</head><p>Solution using the XSLT maps proposal: essentially the same as the above, assuming (a) the existence
          of some mechanism similar to <code>collection()</code> to get a collection of JSON inputs and parse them using the
          <code>parse-json()</code> function, and (b) the existence of a (potentially user-written) function
          <code>values()</code> to extract the values of the map representing a JSON array. This function might be written:</p><eg xml:space="preserve">
&lt;xsl:function name="values" as="item(*)"&gt;
  &lt;xsl:param name="array" as="map(xs:integer, item())"/&gt;
  &lt;xsl:for-each select="map:keys($array)"&gt;
    &lt;xsl:sequence select="$array(.)"/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:function&gt;</eg></div4></div3><div3 id="jsongrouping"><head>Grouping Queries for JSON</head><note><p>These queries are based on similar queries in the XQuery 3.0 Use Cases.</p></note><div4><head>Input Data</head><p>The input is a sequence (whose order is of no concern) that contains the following sales data, 
            represented here in JSON notation:</p><eg xml:space="preserve">{ "product" : "broiler", "store number" : 1, "quantity" : 20  },
{ "product" : "toaster", "store number" : 2, "quantity" : 100 },
{ "product" : "toaster", "store number" : 2, "quantity" : 50 },
{ "product" : "toaster", "store number" : 3, "quantity" : 50 },
{ "product" : "blender", "store number" : 3, "quantity" : 100 },
{ "product" : "blender", "store number" : 3, "quantity" : 150 },
{ "product" : "socks", "store number" : 1, "quantity" : 500 },
{ "product" : "socks", "store number" : 2, "quantity" : 10 },
{ "product" : "shirt", "store number" : 3, "quantity" : 10 }
</eg><p>We want to group sales by product, across stores.</p></div4><div4><head>Result</head><eg xml:space="preserve">{
  "blender" : 250,
  "broiler" : 20,
  "shirt" : 10,
  "socks" : 510,
  "toaster" : 200
  }       </eg></div4><div4><head>Solution in JSONiq:</head><p>We assume a function collection("sales") that returns a sequence of items representing the rows in this table.</p><p>Query:</p><eg xml:space="preserve">{
  for $sales in collection("sales")
  let $pname := $sales("product")
  group by $pname
  return $pname : sum(for $s in $sales return $s("quantity"))
}       </eg></div4><div4><head>Solution in XSLT 3.0:</head><p>Solution using the XSLT maps proposal: assuming that collection("sales") delivers a sequence of unparsed JSON texts, and 
           that the result is to be serialized as a JSON text:</p><eg xml:space="preserve">
  &lt;xsl:variable name="entries" as="map(xs:string, xs:integer)"&gt;
    &lt;xsl:for-each-group select="collection('sales')!parse-json(.)" group-by=".('product')"&gt;
      &lt;xsl:sequence select="map{ current-grouping-key() := sum(current-group()('quantity')) }"/&gt;
    &lt;/xsl:for-each-group&gt;
  &lt;/xsl:variable&gt;
  &lt;xsl:sequence select="serialize-json($entries)"/&gt; 
  </eg></div4></div3><div3 id="jsongrouping2"><head>More Complex Grouping Queries for JSON</head><p>Now let's do a more complex grouping query, showing sales by category within each state. We need further data to describe the categories of products and the location of stores.</p><div4><head>Input Data</head><p>collection("products") contains the following data:</p><eg xml:space="preserve">{ "name" : "broiler", "category" : "kitchen", "price" : 100, "cost" : 70 },
{ "name" : "toaster", "category" : "kitchen", "price" : 30, "cost" : 10 },
{ "name" : "blender", "category" : "kitchen", "price" : 50, "cost" : 25 },
{ "name" : "socks", "category" : "clothes", "price" : 5, "cost" : 2 },
{ "name" : "shirt", "category" : "clothes", "price" : 10, "cost" : 3 }</eg><p>collection("stores") contains the following data:</p><eg xml:space="preserve">{ "store number" : 1, "state" : CA },
{ "store number" : 2, "state" : CA },
{ "store number" : 3, "state" : MA },
{ "store number" : 4, "state" : MA }
        </eg></div4><div4><head>Result</head><eg xml:space="preserve">
            [
              { "CA" : 
                [
                  {"kitchen" : { "broiler" : 20, "toaster" : 150 }},
                  {"clothes" : { "socks" : 510 }}
                ]
              },
              { "MA" : 
                [ 
                  { "kitchen" : { "blender" : 250, "toaster" : 50 }},
                  { "clothes" : { "shirt" : 10 }}
                ]
              }
            ]
        </eg></div4><div4><head>Solution in JSONiq:</head><p>The following query groups by state, then by category, then lists individual products and the sales associated with each.</p><p>Query:</p><eg xml:space="preserve">{
  for $store in collection("stores")
  let $state := $store("state")
  group by $state
  return
     $state : {
       for $product in collection("products")
       let $category := $product("category")
       group by $category
       return
         $category : {
            for $sales in collection("sales")
            where $sales("store number") = $store("store number")
              and $sales("product") = $product("name")
            let $pname := $sales("product")
            group by $pname
            return $pname : sum( for $s in $sales return $s("quantity") )
         }
      }
}
        </eg></div4><div4><head>Solution in XSLT 3.0:</head><p>An equivalent XSLT solution is given below. This uses the syntax of the proposed maps facility in XSLT.</p><!-- example has been tested with Saxon 9.4 --><eg xml:space="preserve">
&lt;xsl:stylesheet version="3.0" 
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:map="http://www.w3.org/2005/xpath-functions/map"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    exclude-result-prefixes="map xs"&gt;
    
    &lt;xsl:output method="text"/&gt;
    
    &lt;xsl:variable name="sales" as="map(*)*" select='
        map{ "product" := "broiler", "store number" := 1, "quantity" := 20  },
        map{ "product" := "toaster", "store number" := 2, "quantity" := 100 },
        map{ "product" := "toaster", "store number" := 2, "quantity" := 50 },
        map{ "product" := "toaster", "store number" := 3, "quantity" := 50 },
        map{ "product" := "blender", "store number" := 3, "quantity" := 100 },
        map{ "product" := "blender", "store number" := 3, "quantity" := 150 },
        map{ "product" := "socks", "store number" := 1, "quantity" := 500 },
        map{ "product" := "socks", "store number" := 2, "quantity" := 10 },
        map{ "product" := "shirt", "store number" := 3, "quantity" := 10 }'/&gt;
    
    &lt;xsl:variable name="products" as="map(*)*" select='
        map{ "name" := "broiler", "category" := "kitchen", "price" := 100, "cost" := 70 },
        map{ "name" := "toaster", "category" := "kitchen", "price" := 30, "cost" := 10 },
        map{ "name" := "blender", "category" := "kitchen", "price" := 50, "cost" := 25 },
        map{ "name" := "socks", "category" := "clothes", "price" := 5, "cost" := 2 },
        map{ "name" := "shirt", "category" := "clothes", "price" := 10, "cost" := 3 }'/&gt;
    
    &lt;xsl:variable name="stores" as="map(*)*" select='
        map{ "store number" := 1, "state" := "CA" },
        map{ "store number" := 2, "state" := "CA" },
        map{ "store number" := 3, "state" := "MA" },
        map{ "store number" := 4, "state" := "MA" }'/&gt;
    
    &lt;xsl:template name="main"&gt;
        &lt;xsl:variable name="state-maps" as="map(*)*"&gt;
            &lt;xsl:for-each-group select="$stores" group-by=".('state')"&gt;
                &lt;xsl:variable name="state" select="current-grouping-key()" 
                                           as="xs:string"/&gt;
                &lt;xsl:variable name="stores-in-state" select="current-group()!.('store number')" 
                                                     as="xs:integer*"/&gt;
                &lt;xsl:variable name="state-map-entry" as="map(*)*"&gt;
                    &lt;xsl:for-each-group select="$products" group-by=".('category')"&gt;
                        &lt;xsl:variable name="category" select="current-grouping-key()" as="xs:string"/&gt;
                        &lt;xsl:variable name="products-in-category" select="current-group()" as="map(*)*"/&gt;
                        &lt;xsl:variable name="totals-map" as="map(*)*"&gt;
                            &lt;xsl:variable name="totals-map-entries" as="map(*)*"&gt;
                                &lt;xsl:for-each select="$products-in-category"&gt;
                                   &lt;xsl:variable name="product-name" select=".('name')"/&gt;
                                   &lt;xsl:variable name="product-sales" 
                                       select="$sales[.('product') = $product-name and 
                                                         .('store number') = $stores-in-state]"/&gt;                      
                                   &lt;xsl:if test="exists($product-sales)"&gt;                      
                                      &lt;xsl:sequence select="map{ $product-name := 
                                                                 sum($product-sales!.('quantity')) }"/&gt;
                                   &lt;/xsl:if&gt;   
                                &lt;/xsl:for-each&gt;
                            &lt;/xsl:variable&gt;
                            &lt;xsl:sequence select="map:new($totals-map-entries)"/&gt;
                        &lt;/xsl:variable&gt;
                        &lt;xsl:sequence select="map{ $category := $totals-map }"/&gt;
                    &lt;/xsl:for-each-group&gt;
                &lt;/xsl:variable&gt;    
                &lt;xsl:sequence select=" map { $state := $state-map-entry }"/&gt;
            &lt;/xsl:for-each-group&gt;
        &lt;/xsl:variable&gt;
        &lt;xsl:value-of select="serialize-json($state-maps, map{ 'indent' := true()} )"/&gt;
    &lt;/xsl:template&gt;   
    
&lt;/xsl:stylesheet&gt;
</eg><p>Note that this example appears to suffer badly from the lack of composability between the
          XPath <code>map{}</code> construct and the XSLT <code>xsl:for-each-group</code> instruction.
          For such use cases, an XSLT instruction to construct maps could be a better approach.</p></div4></div3><div3 id="json2json"><head>JSON to JSON Transformations</head><p>The following query takes satellite data, and summarizes
        which satellites are visible. The data for the query is a
        simplified version of a Stellarium file that contains this
        information.</p><div4><head>Input Data</head><eg xml:space="preserve">{
  "creator" : "Satellites plugin version 0.6.4",
  "satellites" : {
    "AAU CUBESAT" : {
      "tle1" : "1 27846U 03031G 10322.04074654  .00000056  00000-0  45693-4 0  8768",
      "visible" : false
    },
    "AJISAI (EGS)" : {
      "tle1" : "1 16908U 86061A 10321.84797408 -.00000083  00000-0  10000-3 0  3696",
      "visible" : true
    },
    "AKARI (ASTRO-F)" : {
      "tle1" : "1 28939U 06005A 10321.96319841  .00000176  00000-0  48808-4 0  4294",
      "visible" : true
    }
  }
}</eg><p>We want to query this data to return a summary that looks like this.</p></div4><div4><head>Result</head><eg xml:space="preserve">{
  "visible" : [
     "AJISAI (EGS)",
     "AKARI (ASTRO-F)"
  ],
  "invisible" : [
     "AAU CUBESAT"
  ]
}       </eg></div4><div4><head>Solution in JSONiq:</head><p>The following is a JSONiq query that returns the desired result.</p><p><emph>Query:</emph></p><eg xml:space="preserve">let $sats := json("satellites.json")("satellites")
return {
  "visible" : [
     for $sat in pairs($sats)
     where $sat("visible")
     return name($sat)
  ],
  "invisible" : [
     for $sat in pairs($sats)
     where not($sat)("visible"))
     return name($sat)
  ]
  }</eg></div4><div4><head>Solution in XSLT 3.0:</head><p>Equivalent using the XSLT maps proposal:</p><eg xml:space="preserve">
  &lt;xsl:variable name="sats" select="parse-json(unparsed-text('satellites.json'))('satellites')"/&gt;
  &lt;xsl:sequence select="map{
     'visible' := array(map:keys($sats)[$sats(.)('visible')]),
     'invisible' := array(map:keys($sats)[$sats(.)('invisible')])}"/&gt;
     </eg><p>This assumes the existence of a (potentially user-written) function array() that takes
    a sequence and turns it into a map with consecutive integer keys:</p><eg xml:space="preserve">
&lt;xsl:function name="array" as="map(xs:integer, item())"&gt;
  &lt;xsl:param name="seq" as="item()*"/&gt;
  &lt;xsl:sequence select="map:new(for $i in 1 to count($seq) return map{$i := $seq[$i]})"/&gt;
&lt;/xsl:function&gt;</eg></div4></div3><div3 id="wikipedia.example"><head>Converting XML to JSON</head><p>JSON programmers frequently need to convert XML to JSON. The following query is based on a Wikipedia XML export format, using data from the category "Origami". Here is an excerpt of this data:</p><div4><head>Input Data</head><eg xml:space="preserve">&lt;mediawiki&gt;
  &lt;siteinfo&gt;
    &lt;sitename&gt;Wikipedia&lt;/sitename&gt;

    &lt;page&gt;
      &lt;title&gt;Kawasaki's theorem&lt;/title&gt;
      &lt;id&gt;14511776&lt;/id&gt;
      &lt;revision&gt;
        &lt;id&gt;435519187&lt;/id&gt;
        &lt;timestamp&gt;2011-06-21T20:08:56Z&lt;/timestamp&gt;
        &lt;contributor&gt;
          &lt;username&gt;Some jerk on the Internet&lt;/username&gt;
          &lt;id&gt;6636894&lt;/id&gt;
        &lt;/contributor&gt;

!!! SNIP !!!

    &lt;page&gt;
      &lt;title&gt;Origami techniques&lt;/title&gt;
      &lt;id&gt;193590&lt;/id&gt;
      &lt;revision&gt;
        &lt;id&gt;447687387&lt;/id&gt;
        &lt;timestamp&gt;2011-08-31T17:21:49Z&lt;/timestamp&gt;
        &lt;contributor&gt;
          &lt;username&gt;Dmcq&lt;/username&gt;
          &lt;id&gt;3784322&lt;/id&gt;
        &lt;/contributor&gt;

!!! SNIP !!!

    &lt;page&gt;
      &lt;title&gt;Mathematics of paper folding&lt;/title&gt;
      &lt;id&gt;232840&lt;/id&gt;
      &lt;revision&gt;
        &lt;id&gt;440970828&lt;/id&gt;
        &lt;timestamp&gt;2011-07-23T09:10:42Z&lt;/timestamp&gt;
        &lt;contributor&gt;
          &lt;username&gt;Tabletop&lt;/username&gt;
          &lt;id&gt;173687&lt;/id&gt;
        &lt;/contributor&gt;
       </eg></div4><div4><head>Result</head><eg xml:space="preserve">[
 {
  "title" : "Kawasaki's theorem",
  "id" : "14511776",
  "timestamp" : "2011-06-21T20:08:56Z",
  "authors" : ["Some jerk on the Internet" ]
 },
 {
  "title" : "Origami techniques",
  "id" : "193590",
  "timestamp" : "2011-08-31T17:21:49Z",
  "authors" : ["Dmcq" ]
 },
 {
  "title" : "Mathematics of paper folding",
  "id" : "232840",
  "timestamp" : "2011-07-23T09:10:42Z",
  "authors" : ["Tabletop" ]
 }
]
          </eg></div4><div4><head>Solution in JSONiq:</head><p>The following query converts this data to JSON:</p><p>Query:</p><eg xml:space="preserve">[
 for $page in doc("Wikipedia-Origami.xml")//page
 return {
  "title": string($page/title),
  "id" : string($page/id),
  "last updated" : string($page/revision[1]/timestamp),
  "authors" : [
       for $a in $page/revision/contributor/username
       return string($a)
  ]
 }
]          </eg></div4></div3><div3 id="svg.example"><head>Transforming JSON to SVG</head><p>Suppose a JavaScript implementation provides an interface for JSONiq queries, and a JavaScript program contains the following data <footnote><p>This example is based on an example on Stefan Goessner's JSONT site (<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://goessner.net/articles/jsont/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://goessner.net/articles/jsont/</loc>).</p></footnote>:</p><div4><head>Input Data</head><eg xml:space="preserve">var data = {
   "color" : "blue",
   "closed" : true,
   "points" : [[10,10], [20,10], [20,20], [10,20]]
   };
          </eg></div4><div4><head>Solution in JSONiq:</head><p>This data can be converted to SVG by placing the text of a query in a JavaScript variable and calling the appropriate JavaScript function to invoke the query:</p><eg xml:space="preserve">
var query =
 "declare variable stroke := attribute stroke { color };
  declare variable points := attribute points { points };
  if (closed) then
    &lt;svg&gt;&lt;polygon&gt;{ $stroke, $points }&lt;/polygon&gt;&lt;/svg&gt;
  else
    &lt;svg&gt;&lt;polyline&gt;{ $stroke, $points }&lt;/polyline&gt;&lt;/svg&gt;" </eg><p>This query can be invoked with a JavaScript API call:</p><eg xml:space="preserve">
jsoniq(data, query)
          </eg><p>Here is the result of the above query:</p><eg xml:space="preserve">&lt;svg&gt;&lt;polygon stroke="blue" points="10 10 20 10 20 20 10 20" /&gt;&lt;/svg&gt;</eg></div4></div3><div3 id="html.example"><head>Transforming Arrays to HTML Tables</head><p>The data in a JSON array is frequently displayed using HTML tables. The following query shows how to transform from the former to the latter.</p><div4><head>Input Data</head><p>The following Object contains the labels desired for columns and rows, as well as the data for the table.</p><eg xml:space="preserve">{
  "col labels" : ["singular", "plural"],
  "row labels" : ["1p", "2p", "3p"],
  "data" :
     [
        ["spinne", "spinnen"],
        ["spinnst", "spinnt"],
        ["spinnt", "spinnen"]
     ]
}</eg></div4><div4><head>Solution in JSONiq:</head><p>The following query creates an HTML table, using the column headings and row labels as well as the data in the Object shown above.</p><eg xml:space="preserve">&lt;html&gt;
  &lt;body&gt;

    &lt;table&gt;
      &lt;tr&gt; (: Column headings :)
         {
            &lt;th&gt; &lt;/th&gt;,
            for $th in values(json("table.json")("col labels"))
            return &lt;th&gt;{ $th }&lt;/th&gt;
         }
      &lt;/tr&gt;
      {  (: Data for each row :)
         for $r at $i in values(json("table.json")("data"))
         return
            &lt;tr&gt;
             {
               &lt;th&gt;{ values(json("table.json")("row labels")[$i]) }&lt;/th&gt;,
               for $c in $r
               return &lt;td&gt;{ $c }&lt;/td&gt;
             }
            &lt;/tr&gt;
      }
    &lt;/table&gt;

  &lt;/body&gt;
&lt;/html&gt;    </eg></div4></div3><div3 id="windowing.example"><head>Windowing Queries</head><p>XQuery provides support for both sliding windows and
	  tumbling windows, frequently used to analyze event streams
	  or other sequential data. This simple windowing example
	  converts a sequence of items to a table with three columns
	  (using as many rows as necessary), and assigns a row number
	  to each row.</p><div4><head>Input Data</head><eg xml:space="preserve">[
  { "color" : "Green" },
  { "color" : "Pink" },
  { "color" : "Lilac" },
  { "color" : "Turquoise" },
  { "color" : "Peach" },
  { "color" : "Opal" },
  { "color" : "Champagne" }
}
	  </eg></div4><div4><head>Result</head><p>Result:</p><eg xml:space="preserve">&lt;table&gt;
  &lt;tr&gt;
    &lt;td&gt;Green&lt;/td&gt;
    &lt;td&gt;Pink&lt;/td&gt;
    &lt;td&gt;Lilac&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Turquoise&lt;/td&gt;
    &lt;td&gt;Peach&lt;/td&gt;
    &lt;td&gt;Opal&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Champagne&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
	  </eg></div4><div4><head>Solution in JSONiq:</head><p>Query:</p><eg xml:space="preserve">
&lt;table&gt;{
  for tumbling window $w in values(json("colors.json"))
    start at $x when fn:true()
    end at $y when $y - $x = 2
  return
    &lt;tr&gt;{
      for $i in $w
      return
        &lt;td&gt;{ $i }&lt;/td&gt;
    }&lt;/tr&gt;
}&lt;/table&gt;
	  </eg></div4></div3><div3 id="rdb.example"><head>JSON views in middleware</head><p>This example assumes a middleware system that presents relational tables as JSON arrays. The following two tables are used as sample data.</p><div4><head>Input Data</head><table border="1"><caption>Users</caption><thead><tr><td rowspan="1" colspan="1">userid</td><td rowspan="1" colspan="1">firstname</td><td rowspan="1" colspan="1">lastname</td></tr></thead><tbody><tr><td rowspan="1" colspan="1">W0342</td><td rowspan="1" colspan="1">Walter</td><td rowspan="1" colspan="1">Denisovich</td></tr><tr><td rowspan="1" colspan="1">M0535</td><td rowspan="1" colspan="1">Mick</td><td rowspan="1" colspan="1">Goulish</td></tr></tbody></table><p>The JSON representation this particular implementation provides for the above table looks like this:</p><eg xml:space="preserve">[
  { "userid" : "W0342", "firstname" : "Walter", "lastname" : "Denisovich" },
  { "userid" : "M0535", "firstname" : "Mick", "lastname" : "Goulish" }
]       </eg><table border="1"><caption>Holdings</caption><thead><tr><td rowspan="1" colspan="1">userid</td><td rowspan="1" colspan="1">ticker</td><td rowspan="1" colspan="1">shares</td></tr></thead><tbody><tr><td rowspan="1" colspan="1">W0342</td><td rowspan="1" colspan="1">DIS</td><td rowspan="1" colspan="1">153212312</td></tr><tr><td rowspan="1" colspan="1">M0535</td><td rowspan="1" colspan="1">DIS</td><td rowspan="1" colspan="1">10</td></tr><tr><td rowspan="1" colspan="1">M0535</td><td rowspan="1" colspan="1">AIG</td><td rowspan="1" colspan="1">23412</td></tr></tbody></table><p>The JSON representation this particular implementation provides for the above table looks like this:</p><eg xml:space="preserve">[
  { "userid" : "W0342", "ticker" : "DIS", "shares" : 153212312 },
  { "userid" : "M0535", "ticker" : "DIS", "shares" : 10 },
  { "userid" : "M0535", "ticker" : "AIG", "shares" : 23412 }
]       </eg></div4><div4><head>Solution in JSONiq:</head><p>The following query uses the fictitious vendor's <function>vendor:table()</function> function to retrieve the values from a table, and creates an Object for each user, with a list of the user's holdings in the value of that Object.</p><eg xml:space="preserve">[
  for $u in vendor:table("Users")
  order by $u("userid")
  return {
    "userid" : $u("userid"),
    "first" :  $u("firstname"),
    "last" :   $u("lastname"),
    "holdings" : [
         for $h in vendor:table("Holdings")
         where $h("userid") = $u("userid")
         order by $h("ticker")
         return {
            "ticker" : $u("ticker"),
            "share" : $u("shares")
         }
    ]
  }
]       </eg></div4></div3><div3 id="update.example"><head>In-Place Updates</head><p>The XQuery Update Facility allows XML data to be updated. JSONiq provides updating functions to allow JSON to be updated.</p><p>Suppose an application receives an order that contains a credit card number, and needs to put the user on probation.</p><div4><head>Input Data</head><p>Data for an order:</p><eg xml:space="preserve">{
  "user" : "Deadbeat Jim",
  "credit card" : VISA 4111 1111 1111 1111,
  "product" : "lottery tickets",
  "quantity" : 243
}
        </eg><p>collection("users") contains the data for each individual user:</p><eg xml:space="preserve">{
  "name" : "Deadbeat Jim",
  "address" : "1 E 161st St, Bronx, NY 10451",
  "risk tolerance" : "high"
}
        </eg></div4><div4><head>Solution in JSONiq:</head><p>The following query adds  <code>"status" : "credit card declined"</code> to the user's record.</p><eg xml:space="preserve">let $dbj := collection("users")[ .("name") = "Deadbeat Jim" ]
return json:insert-into($dbj, "status" : "credit card declined")
        </eg><p>After the update is finished, the user's record looks like this:</p><eg xml:space="preserve">{
  "name" : "Deadbeat Jim",
  "address" : "1 E 161st St, Bronx, NY 10451",
  "status" : "credit card declined",
  "risk tolerance" : "high"
}
        </eg></div4></div3><div3><head>Data Transformations</head><p>Many applications need to modify data before forwarding it to another source. The XQuery Update Facility provides an expression called a tranform expression that can be used to create modified copies. The transform expression uses updating expressions to perform a transformation. JSONiq defines updating functions for JSON, which can be used in the XQuery transform expression.</p><div4><head>Input Data</head><p>Suppose an application make videos available using feeds from Youtube. The following data comes from one such feed:</p><eg xml:space="preserve">{
    "encoding" : "UTF-8",
    "feed" : {
        "author" : [
            {
                "name" : {
                    "$t" : "YouTube"
                },
                "uri" : {
                    "$t" : "http://www.youtube.com/"
                }
            }
        ],
        "category" : [
            {
                "scheme" : "http://schemas.google.com/g/2005#kind",
                "term" : "http://gdata.youtube.com/schemas/2007#video"
            }
        ],
        "entry" : [
            {
                "app$control" : {
                    "yt$state" : {
                        "$t" : "Syndication of this video was restricted by its owner.",
                        "name" : "restricted",
                        "reasonCode" : "limitedSyndication"
                    }
                },
                "author" : [
                    {
                        "name" : {
                            "$t" : "beyonceVEVO"
                        },
                        "uri" : {
                            "$t" : "http://gdata.youtube.com/feeds/api/users/beyoncevevo"
                        }
                    }
                ]
!!! SNIP !!!         </eg></div4><div4><head>Solution in JSONiq:</head><p>The following query creates a modified copy of the feed by removing all entries that restrict syndication.</p><eg xml:space="preserve">let $feed := json("incoming.json")
return
   copy $out := $feed
   modify
      for $entry in $out("feed")("entry")
      where $entry("app$control")("yt$state")("name") = "restricted"
      return json:delete($entry)
   return $out</eg></div4></div3><!--
#############################################################################
#############################################################################
#############################################################################
--></div2><!--**************************************************--></div1></body><back><div1 id="references"><head>References</head><blist><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC2119" key="RFC 2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	  S. Bradner. <emph>Key Words for use in RFCs to Indicate Requirement Levels.</emph> IETF
	  RFC 2119.  See <loc href="http://www.ietf.org/rfc/rfc2119.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.ietf.org/rfc/rfc2119.txt</loc>.
	</bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" key="XQuery and XPath Data Model 3.0" id="datamodel-30" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	  World Wide Web Consortium. <emph>XQuery and XPath Data Model 3.0</emph>.  W3C Working
	  Draft, 16 September 2010.  See <loc href="http://www.w3.org/TR/xpath-datamodel-30/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xpath-datamodel-30/</loc>.
	</bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" key="XPath 3.0" id="xpath-30" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	  World Wide Web Consortium. <emph>XPath 3.0</emph>.  W3C Working Draft, 14 June 2011.
	  See <loc href="http://www.w3.org/TR/xpath-30/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xpath-30/</loc>.
	</bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" key="XQuery 3.0" id="xquery-30" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	  World Wide Web Consortium. <emph>XPath 3.0</emph>.  W3C Working Draft, 14 June 2011.
	  See <loc href="http://www.w3.org/TR/xquery-30/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xquery-30/</loc>.
	</bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" key="XSLT 3.0" id="xslt-30" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	  World Wide Web Consortium. <emph>XSLT 3.0</emph>. W3C Working Draft 24 July 2011.
	  See <loc href="http://www.w3.org/TR/2011/WD-xslt-21-20110724/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2011/WD-xslt-21-20110724/</loc>.
	</bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" key="JSONiq" id="JSONiq" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	  Jonathan Robie, Matthias Brantner, Daniela Florescu, Ghislain Fourny, Till Westmann. <emph>JSONiq: XQuery for JSON, JSON for XQuery</emph>. See
	  <loc href="http://jsoniq.com/docs/spec/en-US/html/index.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://jsoniq.com/docs/spec/en-US/html/index.html</loc>.
	</bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" key="JSONiq Use Cases" id="JSONiq-UseCases" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	  Jonathan Robie, Matthias Brantner, Daniela Florescu, Ghislain Fourny, Till Westmann. <emph>JSONiq Use Cases</emph>. See
          <loc href="http://jsoniq.com/docs/use-cases/en-US/html/index.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://jsoniq.com/docs/use-cases/en-US/html/index.html</loc>.
	</bibl></blist></div1></back></spec>
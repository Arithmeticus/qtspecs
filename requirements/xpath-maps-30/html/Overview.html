<?xml version="1.0" encoding="utf-8"?>
<!--XSLT Processor: SAXON 9.1.0.5 from Saxonica SAXON 9.1.0.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns:xs="http://www.w3.org/2001/XMLSchema" lang="en" xmlns=
"http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta name="generator" content=
"HTML Tidy for Linux (vers 25 March 2009), see www.w3.org" />
<title>Maps in XSLT and XQuery: Candidate Requirements and Use
Cases</title>

<style type="text/css">
/*<![CDATA[*/
code           { font-family: monospace; }

div.constraint,
div.issue,
div.note,
div.notice     { margin-left: 2em; }

div.issue
p.title        { margin-left: -2em; }

ol.enumar      { list-style-type: decimal; }
ol.enumla      { list-style-type: lower-alpha; }
ol.enumlr      { list-style-type: lower-roman; }
ol.enumua      { list-style-type: upper-alpha; }
ol.enumur      { list-style-type: upper-roman; }

li p           { margin-top: 0.3em;
                 margin-bottom: 0.3em; }

sup small      { font-style: italic;
                 color: #8F8F8F;
               }
    
div.exampleInner pre { margin-left: 1em;
                       margin-top: 0em; margin-bottom: 0em}
div.exampleOuter {border: 4px double gray;
                  margin: 0em; padding: 0em}
div.exampleInner { background-color: #d5dee3;
                   border-top-width: 4px;
                   border-top-style: double;
                   border-top-color: #d3d3d3;
                   border-bottom-width: 4px;
                   border-bottom-style: double;
                   border-bottom-color: #d3d3d3;
                   padding: 4px; margin: 0em }
div.exampleWrapper { margin: 4px }
div.exampleHeader { font-weight: bold;
                    margin: 4px}

div.issue { border-bottom-color: black;
            border-bottom-style: solid;
            border-bottom-width: 1pt;
            margin-bottom: 20pt;
}

th.issue-toc-head { border-bottom-color: black;
                    border-bottom-style: solid;
                    border-bottom-width: 1pt;
}

      
table.small                             { font-size: x-small; }
a.judgment:visited, a.judgment:link     { font-family: sans-serif;
                                          color: black; 
                                          text-decoration: none }
a.processing:visited, a.processing:link { color: black; 
                                                text-decoration: none }
a.env:visited, a.env:link               { color: black; 
                                          text-decoration: none }
/*]]>*/
</style>
<link rel="stylesheet" type="text/css" href=
"http://www.w3.org/StyleSheets/TR/base.css" />
</head>
<body>
<div class="head">
<p><a href="http://www.w3.org/"><img src=
"http://www.w3.org/Icons/w3c_home" alt="W3C" height="48" width=
"72" /></a></p>
<h1><a name="title" id="title"></a>Maps in XSLT and XQuery:
Candidate Requirements and Use Cases</h1>
<h2><a name="w3c-doctype" id="w3c-doctype"></a>W3C Exploratory SWAT
Team Document 2 February 2012</h2>
<dl>
<dt>This version:</dt>
<dd><a href=
"http://www.w3.org/XML/Group/qtspecs/requirements/xpath-maps-30/html/Overview.html">
http://www.w3.org/XML/Group/qtspecs/requirements/xpath-maps-30/html/Overview.html</a></dd>
<dt>Latest version:</dt>
<dd><a href=
"http://www.w3.org/XML/Group/qtspecs/requirements/xpath-maps-30/html/Overview.html">
http://www.w3.org/XML/Group/qtspecs/requirements/xpath-maps-30/html/Overview.html</a></dd>
<dt>Editors:</dt>
<dd>John Snelson, MarkLogic <a href=
"mailto:john.snelson@marklogic.com">&lt;john.snelson@marklogic.com&gt;</a></dd>
<dd>Jonathan Robie <a href=
"mailto:jonathan.robie@gmail.com">&lt;jonathan.robie@gmail.com&gt;</a></dd>
<dd>Michael Kay <a href=
"mailto:mike@saxonica.com">&lt;mike@saxonica.com&gt;</a></dd>
</dl>
<p class="copyright"><a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>&#160;©&#160;2012&#160;<a href="http://www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>®</sup>
(<a href="http://www.csail.mit.edu/"><acronym title=
"Massachusetts Institute of Technology">MIT</acronym></a>, <a href=
"http://www.ercim.eu/"><acronym title=
"European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>,
<a href="http://www.keio.ac.jp/">Keio</a>), All Rights Reserved.
W3C <a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
<a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a>
and <a href=
"http://www.w3.org/Consortium/Legal/copyright-documents">document
use</a> rules apply.</p>
</div>
<hr />
<div>
<h2><a name="abstract" id="abstract"></a>Abstract</h2>
<p>This document specifies candidate requirements and use cases for
Maps in XSLT and XQuery in XSLT and XQuery. It has not yet been
reviewed or approved by either Working Group.</p>
</div>
<div>
<h2><a name="status" id="status"></a>Status of this Document</h2>
</div>
<div class="toc">
<h2><a name="contents" id="contents"></a>Table of Contents</h2>
<p class="toc">1 <a href="#requirements">Requirements</a><br />
&#160;&#160;&#160;&#160;1.1 <a href=
"#terminology">Terminology</a><br />
&#160;&#160;&#160;&#160;1.2 <a href=
"#motivation">Motivation</a><br />
&#160;&#160;&#160;&#160;1.3 <a href=
"#general-requirements">Candidate Requirements</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;1.3.1 <a href=
"#req-dm">Data Model</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;1.3.2 <a href=
"#d3e202">Keys</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;1.3.3 <a href=
"#d3e354">Values</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;1.3.4 <a href=
"#req-operations">Operations</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;1.3.5 <a href=
"#req-json">JSON</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;1.3.6 <a href=
"#req-apps">Applications</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;1.3.7 <a href=
"#req-updates">Updates</a><br />
2 <a href="#use-cases">Use Cases</a><br />
&#160;&#160;&#160;&#160;2.1 <a href=
"#streaming">Streaming</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.1.1 <a href=
"#streaming-query1">Simple Grouping</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.1.1.1
<a href="#d3e703">Solution in XQuery 3.0</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.1.1.2
<a href="#d3e708">Solution in XQuery 3.0 with XSLT Maps</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.1.1.3
<a href="#d3e713">Solution in XSLT 3.0</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.1.2 <a href=
"#streaming-query2">Simultaneous Grouping</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.1.2.1
<a href="#d3e728">Solution in XQuery 3.0</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.1.2.2
<a href="#d3e733">Solution in XQuery 3.0 with XSLT Maps</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.1.3 <a href=
"#streaming-query3">Word Count by Lemma</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.1.3.1
<a href="#streaming-query3-data">Input Data</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.1.3.2
<a href="#d3e756">Result</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.1.3.3
<a href="#d3e761">Solution in XQuery 3.0 with XSLT Maps:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.1.3.4
<a href="#d3e766">Alternative Solution in XQuery 3.0 with XSLT
Maps:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.1.3.5
<a href="#d3e771">Solution Using Grouping in XQuery 3.0:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.1.3.6
<a href="#d3e778">Solution in XSLT 3.0:</a><br />
&#160;&#160;&#160;&#160;2.2 <a href="#complex">Compound
Values</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.1 <a href=
"#complex-query1">Complex Number Library</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.1.1
<a href="#d3e792">Solution in XQuery 3.0 with XSLT Maps:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.1.2
<a href="#d3e797">Solution in XSLT 3.0 (using type-alias proposal,
still in discussion):</a><br />
&#160;&#160;&#160;&#160;2.3 <a href="#indexes">Manual
Indexing</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3.1 <a href=
"#indexes-query1">Simple Manual Join</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3.1.1
<a href="#indexes-data">Input Data</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3.1.2
<a href="#d3e824">Solution in XQuery 3.0 with XSLT Maps:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3.1.3
<a href="#d3e829">Solution in XSLT 3.0:</a><br />
&#160;&#160;&#160;&#160;2.4 <a href="#interface">Interface /
Implementation Pattern</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.1 <a href=
"#interface-query1">Data Variety</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.1.1
<a href="#interface-data1">Input Data</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.1.2
<a href="#d3e864">Solution in XQuery 3.0 with XSLT Maps:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.1.3
<a href="#d3e871">Solution in XSLT 3.0:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.2 <a href=
"#interface-query2">Search and Snippeting</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.2.1
<a href="#d3e881">Solution in XQuery Full Text 3.0 with XSLT
Maps:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.3 <a href=
"#interface-query3">Abstracting Document Structure</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.3.1
<a href="#d3e893">Solution in XQuery 3.0 with XSLT Maps:</a><br />
&#160;&#160;&#160;&#160;2.5 <a href="#parameter">Parameter
Passing</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.1 <a href=
"#parameter-query1">XSLT Stylesheet Parameters</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.1.1
<a href="#d3e912">Solution in XQuery 3.0 with XSLT Maps:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.2 <a href=
"#parameter-query2">Function Options</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.2.1
<a href="#d3e953">Solution in XQuery 3.0 with XSLT Maps:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.2.2
<a href="#d3e958">Solution in XQuery 3.0 with XSLT Maps enhanced
with stronger typing:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.3 <a href=
"#parameter-query3">Translation</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.3.1
<a href="#d3e968">Solution in XQuery 3.0 with XSLT Maps:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.4 <a href=
"#parameter-query4">Cipher Functions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.4.1
<a href="#d3e978">Solution in XQuery 3.0 with XSLT Maps:</a><br />
&#160;&#160;&#160;&#160;2.6 <a href="#json">JSON</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.1 <a href=
"#json-query1">Information Retrieval</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.1.1
<a href="#json-query1-data">Input Data</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.1.2
<a href="#d3e1022">Result</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.1.3
<a href="#d3e1027">Solution in XQuery 3.0 with XSLT Maps:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.1.4
<a href="#d3e1035">Alternative Solution in XQuery 3.0 with XSLT
Maps:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.1.5
<a href="#d3e1040">Solution in JSONiq:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.2 <a href=
"#json-query2">Converting JSON to XML</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.2.1
<a href="#json-query2-data">Input Data</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.2.2
<a href="#d3e1057">Result</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.2.3
<a href="#d3e1062">Solution in XQuery 3.0 with XSLT Maps:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.2.4
<a href="#d3e1067">Solution in JSONiq:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.2.5
<a href="#d3e1072">Solution in XSLT 3.0:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.3 <a href=
"#json-query3">Update by Copying</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.3.1
<a href="#json-query3-data">Input Data</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.3.2
<a href="#d3e1089">Solution in XQuery 3.0 with XSLT Maps:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.3.3
<a href="#d3e1094">Solution in XSLT 3.0:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.4 <a href=
"#json.joins">Joins</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.4.1
<a href="#d3e1107">Input Data</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.4.2
<a href="#d3e1117">Solution in JSONiq:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.4.3
<a href="#d3e1131">Solution in XSLT 3.0:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.5 <a href=
"#jsongrouping">Grouping Queries for JSON</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.5.1
<a href="#d3e1153">Input Data</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.5.2
<a href="#d3e1162">Result</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.5.3
<a href="#d3e1167">Solution in JSONiq:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.5.4
<a href="#d3e1176">Solution in XSLT 3.0:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.6 <a href=
"#jsongrouping2">More Complex Grouping Queries for JSON</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.6.1
<a href="#d3e1188">Input Data</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.6.2
<a href="#d3e1199">Result</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.6.3
<a href="#d3e1204">Solution in JSONiq:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.6.4
<a href="#d3e1213">Solution in XSLT 3.0:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.7 <a href=
"#json2json">JSON to JSON Transformations</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.7.1
<a href="#d3e1234">Input Data</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.7.2
<a href="#d3e1241">Result</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.7.3
<a href="#d3e1246">Solution in JSONiq:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.7.4
<a href="#d3e1256">Solution in XSLT 3.0:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.8 <a href=
"#wikipedia.example">Converting XML to JSON</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.8.1
<a href="#d3e1272">Input Data</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.8.2
<a href="#d3e1277">Result</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.8.3
<a href="#d3e1282">Solution in JSONiq:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.9 <a href=
"#svg.example">Transforming JSON to SVG</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.9.1
<a href="#d3e1304">Input Data</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.9.2
<a href="#d3e1309">Solution in JSONiq:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.10 <a href=
"#html.example">Transforming Arrays to HTML Tables</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.10.1
<a href="#d3e1329">Input Data</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.10.2
<a href="#d3e1336">Solution in JSONiq:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.11 <a href=
"#windowing.example">Windowing Queries</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.11.1
<a href="#d3e1348">Input Data</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.11.2
<a href="#d3e1353">Result</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.11.3
<a href="#d3e1360">Solution in JSONiq:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.12 <a href=
"#rdb.example">JSON views in middleware</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.12.1
<a href="#d3e1372">Input Data</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.12.2
<a href="#d3e1442">Solution in JSONiq:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.13 <a href=
"#update.example">In-Place Updates</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.13.1
<a href="#d3e1459">Input Data</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.13.2
<a href="#d3e1470">Solution in JSONiq:</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.14 <a href=
"#d3e1484">Data Transformations</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.14.1
<a href="#d3e1489">Input Data</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6.14.2
<a href="#d3e1496">Solution in JSONiq:</a><br /></p>
<h3><a name="appendices" id="appendices"></a>Appendix</h3>
<p class="toc">A <a href="#references">References</a><br /></p>
<p class="toc"><a href="#endnotes">End Notes</a></p>
</div>
<hr />
<div class="body">
<div class="div1">
<h2><a name="requirements" id="requirements"></a>1
Requirements</h2>
<div class="div2">
<h3><a name="terminology" id="terminology"></a>1.1 Terminology</h3>
<p>In this specification the words <a href="#RFC2119">must</a>,
<a href="#RFC2119">must not</a>, <a href="#RFC2119">should</a>,
<a href="#RFC2119">should not</a>, <a href="#RFC2119">may</a> and
<a href="#RFC2119">recommended</a>, when are to be interpreted as
described in <a href="#RFC2119">[RFC 2119]</a>. When these words
are used in this technical sense, they occur as a hyperlink to
<a href="#RFC2119">[RFC 2119]</a>. These words will also be used
with their conventional English meaning, in which case there is no
hyperlink.</p>
</div>
<div class="div2">
<h3><a name="motivation" id="motivation"></a>1.2 Motivation</h3>
<p>The XDM data model used in XSLT 2.0, XPath 2.0, and XQuery 1.0
has proved adequate for a wide range of requirements. On occasions,
however, its limitations make themselves felt; these arise
particularly when complex algorithms are needed, or when data
structures need to be designed with particular attention to
efficiency. Over time, a number of solutions to these requirements
have been proposed: these include proposals for "nested sequences",
"node references", "tuples", and "maps".</p>
<p>In the 3.0 family of specifications, functions become
first-class objects in the data model, and this allows many of
these limitations to be circumvented. However, the resulting
solutions often lack usability.</p>
<p>The purpose of this document is to analyze a representative
sample of use cases where the limitations of the existing XDM model
make themselves felt, and to abstract from these a set of
requirements for extending the data model with new data types and
corresponding functions and operators.</p>
<p>Two particular motivations for undertaking this study were:</p>
<ol class="enumar">
<li>
<p>The XSLT work on streaming. When a large source document is
processed in streaming mode, a processor only gets to see each
piece of information in the document once, and if it wishes to make
use of this information later, it needs to retain the information
in working variables. Equivalently, a function that makes a single
pass over an input document needs to return a complex result, in
preference to calling multiple functions that return simple
results. This creates a need for richer data structures to
represent this working data.</p>
</li>
<li>
<p>Work in both the XSLT and XQuery communities on support for
JSON. JSON support can be seen as an important use case in its own
right, and it can also be seen as an example of a more general
requirement to support externally-defined data structures other
than XML. While conversion of JSON to XML is not especially
difficult, doing the conversion in a way that both retains all
information in the original input and also generates XML that is
easy to manipulate has proved challenging: most proposed solutions
compromise one of these objectives to satisfy the other. The
underlying cause of this problem is the limited expressive power of
the XDM data model, and new data structures that more closely
reflect JSON concepts such as arrays and "objects" (known in other
languages as maps, dictionaries, or associative arrays) are seen as
a potential solution.</p>
</li>
</ol>
<p>Clearly, integration of any new data structures into the
existing model is a prerequisite, and a common approach between
XSLT and XQuery is highly desirable. Existing functions and
operators need to be reusable with any new data structures to the
maximum extent possible. Integration with the existing processing
models of XPath, XSLT, and XQuery is also necessary; and in this
respect, the starting position is that we have a core set of
languages that are declarative, with immutable values (though with
a limited form of nondeterminism in that expression evaluation can
return a "new" node with unique identity); layered on top of this,
we have XQuery Update and Scripting which provide mutable values
and imperative functionality with side-effects.</p>
</div>
<div class="div2">
<h3><a name="general-requirements" id=
"general-requirements"></a>1.3 Candidate Requirements</h3>
<p>These have been identified as candidate requirements by the SWAT
team currently working on this document. The Working Groups have
made no decisions on requirements at this time.</p>
<div class="div3">
<h4><a name="req-dm" id="req-dm"></a>1.3.1 Data Model</h4>
<dl>
<dt class="label">1.3.1.1 Multiple Results</dt>
<dd>
<p>It <a href="#RFC2119">must</a> be possible to return multiple
sequences of XDM values from a function or template invocation. In
particular, it <a href="#RFC2119">must</a> be possible to return
multiple sequence results from the application of a streaming mode
template in XSLT 3.0.</p>
<p><em>Motivation:</em> <a href="#streaming-query1"><b>2.1.1 Simple
Grouping</b></a></p>
</dd>
<dt class="label">1.3.1.2 Compound Items</dt>
<dd>
<p>It <a href="#RFC2119">must</a> be possible to use maps to
represent compound values or data structures, for example the value
of a complex number or a sparse matrix, consisting of multiple
sequences of items.</p>
<p><em>Motivation:</em> <a href="#streaming-query1"><b>2.1.1 Simple
Grouping</b></a>, <a href="#complex"><b>2.2 Compound
Values</b></a></p>
</dd>
<dt class="label">1.3.1.3 No observable identity</dt>
<dd>
<p>In a target language without side-effects, maps <a href=
"#RFC2119">must</a> have no observable identity.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Currently the operations that can observe the identity of nodes
are the <code>is</code>, <code>&lt;&lt;</code>,
<code>&gt;&gt;</code>, <code>union</code>, <code>intersect</code>,
and <code>except</code> operators, and any operation that exposes
document order.</p>
</div>
</dd>
<dt class="label">1.3.1.4 Maps as Functions</dt>
<dd>
<p>It <a href="#RFC2119">may</a> be possible to use maps as
functions.</p>
<p><em>Motivation:</em> <a href="#parameter-query3"><b>2.5.3
Translation</b></a>, <a href="#parameter-query4"><b>2.5.4 Cipher
Functions</b></a></p>
</dd>
</dl>
</div>
<div class="div3">
<h4><a name="d3e202" id="d3e202"></a>1.3.2 Keys</h4>
<dl>
<dt class="label">1.3.2.1 Atomic Values as Keys</dt>
<dd>
<p>The map feature <a href="#RFC2119">may</a> allow any atomic
value to be used as a key.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Specific types may be treated as exceptions; for instance,
untypedAtomic may be treated as a string, NaN may be either
disallowed or treated as equal to itself, etc. There may be issues
related to transitivity, or reasons to restrict the types used in
any one map.</p>
</div>
</dd>
<dt class="label">1.3.2.2 String Values as Keys</dt>
<dd>
<p>The map feature <a href="#RFC2119">must</a> allow any instance
of <code>xs:string</code> or any instance of a type derived from
<code>xs:string</code> to be used as a key.</p>
<p><em>Motivation:</em> <a href="#json-query1"><b>2.6.1 Information
Retrieval</b></a></p>
</dd>
<dt class="label">1.3.2.3 xs:untypedAtomics as Keys</dt>
<dd>
<p>The map feature <a href="#RFC2119">must</a> allow an
<code>xs:untypedAtomic</code> to be used as a key, but there is no
requirement that an <code>xs:untypedAtomic</code> value be treated
differently from an equivalent <code>xs:string</code>.</p>
</dd>
<dt class="label">1.3.2.4 QNames as Keys</dt>
<dd>
<p>The map feature <a href="#RFC2119">must</a> allow an
<code>xs:QName</code> or any type derived from
<code>xs:QName</code> to be used as a key.</p>
<p><em>Motivation:</em> <a href="#parameter-query1"><b>2.5.1 XSLT
Stylesheet Parameters</b></a></p>
</dd>
<dt class="label">1.3.2.5 Numeric types as Keys</dt>
<dd>
<p>The map feature <a href="#RFC2119">must</a> allow an
<code>xs:decimal</code> or any type derived from
<code>xs:decimal</code> to be used as a key.</p>
<p><em>Motivation:</em> <a href="#json-query1"><b>2.6.1 Information
Retrieval</b></a></p>
</dd>
<dt class="label">1.3.2.6 URIs as Keys</dt>
<dd>
<p>The map feature <a href="#RFC2119">must</a> allow an
<code>xs:anyURI</code> or any type derived from
<code>xs:anyURI</code> to be used as a key.</p>
</dd>
<dt class="label">1.3.2.7 Dates as Keys</dt>
<dd>
<p>The map feature <a href="#RFC2119">must</a> allow an xs:date or
any type derived from xs:date to be used as a key.</p>
</dd>
<dt class="label">1.3.2.8 Times as Keys</dt>
<dd>
<p>The map feature <a href="#RFC2119">must</a> allow an
<code>xs:time</code> or any type derived from <code>xs:time</code>
to be used as a key.</p>
</dd>
<dt class="label">1.3.2.9 Collations for comparing Keys</dt>
<dd>
<p>The map feature <a href="#RFC2119">may</a> allow the comparison
of string-valued keys to be controlled by a user-specified
collation.</p>
</dd>
<dt class="label">1.3.2.10 Heterogeneous Keys</dt>
<dd>
<p>The map feature <a href="#RFC2119">may</a> allow a map to exist
in which different entries have keys of different atomic types.</p>
</dd>
</dl>
</div>
<div class="div3">
<h4><a name="d3e354" id="d3e354"></a>1.3.3 Values</h4>
<dl>
<dt class="label">1.3.3.1 Any XDM Sequence</dt>
<dd>
<p>The map feature <a href="#RFC2119">must</a> allow any XDM
sequence as the value part of a key/value association within a
map.</p>
<p><em>Motivation:</em> <a href="#parameter-query1"><b>2.5.1 XSLT
Stylesheet Parameters</b></a></p>
</dd>
<dt class="label">1.3.3.2 Nested Maps</dt>
<dd>
<p>The map feature <a href="#RFC2119">must</a> allow any map as the
value part of a key/value association; that is, maps can nest.</p>
<p><em>Motivation:</em> <a href="#json-query1"><b>2.6.1 Information
Retrieval</b></a></p>
</dd>
<dt class="label">1.3.3.3 Identity Preservation</dt>
<dd>
<p>The map feature <a href="#RFC2119">must</a> retain the identity
of XML nodes they contain.</p>
<p><em>Motivation:</em> <a href="#parameter-query1"><b>2.5.1 XSLT
Stylesheet Parameters</b></a></p>
</dd>
<dt class="label">1.3.3.4 Function Items</dt>
<dd>
<p>The map feature <a href="#RFC2119">must</a> be able to hold
function items as sub-values.</p>
<p><em>Motivation:</em> <a href="#interface"><b>2.4 Interface /
Implementation Pattern</b></a>, <a href=
"#parameter-query2"><b>2.5.2 Function Options</b></a></p>
</dd>
<dt class="label">1.3.3.5 Heterogeneous Values</dt>
<dd>
<p>The map feature <a href="#RFC2119">should</a> be able to contain
heterogeneous values; that is, the value associated with any key
should be an arbitrary sequence of items, potentially of a
different type from the values associated with other keys in the
same map. In particular they <a href="#RFC2119">should</a> be able
to hold both function items and other data in different entries (or
the same entry) simultaneously.</p>
<p><em>Motivation:</em> <a href="#interface"><b>2.4 Interface /
Implementation Pattern</b></a></p>
</dd>
</dl>
</div>
<div class="div3">
<h4><a name="req-operations" id="req-operations"></a>1.3.4
Operations</h4>
<dl>
<dt class="label">1.3.4.1 Construction</dt>
<dd>
<p>The map feature <a href="#RFC2119">must</a> provide a convenient
syntax for constructing a new instance of the data structure.</p>
</dd>
<dt class="label">1.3.4.2 Composability in Constructors</dt>
<dd>
<p>The syntax of map constructors <a href="#RFC2119">must</a> allow
an expression to occur anywhere that a value may occur.</p>
<p><em>Motivation:</em> <a href="#indexes-query1"><b>2.3.1 Simple
Manual Join</b></a></p>
</dd>
<dt class="label">1.3.4.3 Modified Copies</dt>
<dd>
<p>The map feature <a href="#RFC2119">must</a> provide a convenient
syntax for creating modified copies of maps, for example by the
addition and deletion of entries.</p>
<p>It <a href="#RFC2119">must</a> be possible to identify changes
to specific items in deeply nested maps.</p>
</dd>
<dt class="label">1.3.4.4 Serialization</dt>
<dd>
<p>The map feature <a href="#RFC2119">must</a> define a
JSON-compatible serialization for those maps/arrays that are
representable as JSON values.</p>
<p>The map feature <a href="#RFC2119">should</a> define a
serialization for all maps.</p>
</dd>
<dt class="label">1.3.4.5 Member Accessors</dt>
<dd>
<p>The map feature <a href="#RFC2119">must</a> provide a convenient
syntax for accessing a member of a map by specifying its key.</p>
</dd>
<dt class="label">1.3.4.6 Key/Value Access</dt>
<dd>
<p>There <a href="#RFC2119">must</a> be a way to access the keys
and values of all the entries in a map.</p>
</dd>
<dt class="label">1.3.4.7 Enumerating content</dt>
<dd>
<p>It <a href="#RFC2119">must</a> be possible to enumerate the
keys, and/or the key/value associations, that are present in the
map.</p>
<p><em>Motivation:</em> <a href="#json-query1"><b>2.6.1 Information
Retrieval</b></a></p>
</dd>
<dt class="label">1.3.4.8 Language Generalization</dt>
<dd>
<p>Existing functions and operators, and syntactic constructs such
as FLWOR expressions, <a href="#RFC2119">should</a> be generalized
to work with any new data structures.</p>
</dd>
</dl>
</div>
<div class="div3">
<h4><a name="req-json" id="req-json"></a>1.3.5 JSON</h4>
<dl>
<dt class="label">1.3.5.1 JSON</dt>
<dd>
<p>The XDM <a href="#RFC2119">must</a> be extended with maps and
arrays in such a way as to allow importing and exporting JSON
without loss of information.</p>
<p><em>Motivation:</em> <a href="#json-query1"><b>2.6.1 Information
Retrieval</b></a></p>
</dd>
<dt class="label">1.3.5.2 Arrays</dt>
<dd>
<p>It <a href="#RFC2119">must</a> be possible to process all the
values within an array.</p>
<p>It <a href="#RFC2119">must</a> be possible to construct an
arbitrary array.</p>
<p><em>Motivation:</em> <a href="#json-query1"><b>2.6.1 Information
Retrieval</b></a>, <a href="#json-query2"><b>2.6.2 Converting JSON
to XML</b></a></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The Maps SWAT team believe that more in-depth work is needed on
the requirements for arrays.</p>
</div>
</dd>
<dt class="label">1.3.5.3 Converting among XML and JSON</dt>
<dd>
<p>The maps facility <a href="#RFC2119">must</a> be able to express
queries that convert XML to JSON, or JSON to XML.</p>
<p><em>Motivation:</em> <a href="#json-query2"><b>2.6.2 Converting
JSON to XML</b></a></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>There is a consensus that there is no signle definitive
canonical mapping from XML to JSON that satisfies all requirements
that users have for such a mapping.</p>
</div>
</dd>
</dl>
</div>
<div class="div3">
<h4><a name="req-apps" id="req-apps"></a>1.3.6 Applications</h4>
<dl>
<dt class="label">1.3.6.1 Optional Parameters</dt>
<dd>
<p>It <a href="#RFC2119">must</a> be possible to use maps to
provide sparse options to a function call, including options
defined by a function item.</p>
<p><em>Motivation:</em> <a href="#parameter-query2"><b>2.5.2
Function Options</b></a></p>
</dd>
<dt class="label">1.3.6.2 Indexes</dt>
<dd>
<p>It <a href="#RFC2119">may</a> be possible to use maps to provide
indexes for manual optimization.</p>
<p><em>Motivation:</em> <a href="#indexes-query1"><b>2.3.1 Simple
Manual Join</b></a></p>
</dd>
<dt class="label">1.3.6.3 Representation of FLWOR Tuples</dt>
<dd>
<p>The maps design <a href="#RFC2119">should not</a> preclude the
use of maps to represent the intermediate tuples in FLWOR
expressions.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The Maps SWAT team did not reach consensus on this
requirement.</p>
</div>
</dd>
<dt class="label">1.3.6.4 Representation of PULs</dt>
<dd>
<p>The maps design <a href="#RFC2119">should not</a> preclude the
use of maps to represent pending update lists.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The Maps SWAT team did not reach consensus on this
requirement.</p>
</div>
</dd>
</dl>
</div>
<div class="div3">
<h4><a name="req-updates" id="req-updates"></a>1.3.7 Updates</h4>
<dl>
<dt class="label">1.3.7.1 In-situ Updates</dt>
<dd>
<p>The maps facility in XQuery <a href="#RFC2119">must not</a>
preclude providing update operations that add, replace, or remove
entries in maps in the XQuery Update facility.</p>
<p>The XQuery Update Facility <a href="#RFC2119">must</a> provide
update operations that add, replace, or remove entries in maps.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="div1">
<h2><a name="use-cases" id="use-cases"></a>2 Use Cases</h2>
<p>The solutions provided for the following Use Cases include
solutions in the following languages:</p>
<ul>
<li>
<p>XSLT Maps: the maps provided in the current Working Draft of
XSLT. See <a href="#xslt-30">[XSLT 3.0]</a>.</p>
</li>
<li>
<p>XQuery 3.0: the XQuery 3.0 language, without maps. See <a href=
"#xquery-30">[XQuery 3.0]</a>.</p>
</li>
<li>
<p>JSONiq: the JSONiq proposal. See <a href=
"#JSONiq">[JSONiq]</a>.</p>
</li>
</ul>
<div class="div2">
<h3><a name="streaming" id="streaming"></a>2.1 Streaming</h3>
<p>In a streaming application you only get one chance to look at
each piece of data in the source file. Therefore, if the output is
not a pure event-to-event function of the input, you have to
selectively remember some of the things you have seen in the input
for use later. This sometimes creates a need for data structures to
hold working data in memory. This is an important motivating use
case for maps in XSLT. Some of the motivating examples for XSLT can
be solved in other ways in XQuery; because XQuery does not have a
streaming facility, it's unclear whether maps would be the best
solution for these examples in a streaming XQuery processor.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This is solved in XSLT 3.0 using the streaming facility.</p>
</div>
<div class="div3">
<h4><a name="streaming-query1" id="streaming-query1"></a>2.1.1
Simple Grouping</h4>
<p>Find the highest earning employee in each department.</p>
<div class="div4">
<h5><a name="d3e703" id="d3e703"></a>2.1.1.1 Solution in XQuery
3.0</h5>
<div class="exampleInner">
<pre>
for $e in doc("employees.xml")/employees/employee,
    $d in $e/department
group by $d
return
   &lt;department name="{$d}"&gt;
     {
       let $max := max($e/salary)
       return $e[salary=$max]
     }
   &lt;/department&gt;
</pre></div>
</div>
<div class="div4">
<h5><a name="d3e708" id="d3e708"></a>2.1.1.2 Solution in XQuery 3.0
with XSLT Maps</h5>
<div class="exampleInner">
<pre>
declare function local:search-employees(
  $employees as element(employee)*,
  $highest-earners as map(xs:string, element(employee))
)
{
  if(empty($employees)) then $highest-earners else

  let $this := head($employees)
  let $existing := $highest-earners($this/department)
  let $new-earners :=
    if ($existing/salary gt $this/salary) then $highest-earners
    else map:new(($highest-earners, map:entry($this/department, $this)))
  return local:search-employees(tail($employees), $new-earners)
};

let $highest-earners := local:search-employees(doc("employees.xml")/*/employee, map:new())
for $department in map:keys($highest-earners)
return
  &lt;department name="{$department}"&gt;{ $highest-earners($department) }&lt;/department&gt;
</pre></div>
</div>
<div class="div4">
<h5><a name="d3e713" id="d3e713"></a>2.1.1.3 Solution in XSLT
3.0</h5>
<div class="exampleInner">
<pre>
&lt;xsl:stream href="employees.xml"&gt;
  &lt;xsl:iterate select="*/employee"&gt;
    &lt;xsl:param name="highest-earners"
               as="map(xs:string, element(employee))"
               select="map:new()"/&gt;
    &lt;xsl:variable name="this" select="copy-of(.)" as="element(employee)"/&gt;
    &lt;xsl:next-iteration&gt;
      &lt;xsl:with-param name="highest-earners"
                      select="let $existing := $highest-earners($this/department)
                              return if ($existing/salary gt $this/salary)
                                then $highest-earners
                                else map:new(($highest-earners,
                                  map:entry($this/department, $this)))"/&gt;
    &lt;/xsl:next-iteration&gt;
    &lt;xsl:on-completion&gt;
      &lt;xsl:for-each select="map:keys($highest-earners)"&gt;
        &lt;department name="{.}"&gt;
          &lt;xsl:copy-of select="$highest-earners(.)"/&gt;
        &lt;/department&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:on-completion&gt;
  &lt;/xsl:iterate&gt;
&lt;/xsl:stream&gt;
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="streaming-query2" id="streaming-query2"></a>2.1.2
Simultaneous Grouping</h4>
<p>Find both the highest earning employee in each department, and
the total number of employees to job-type across all
departments.</p>
<div class="div4">
<h5><a name="d3e728" id="d3e728"></a>2.1.2.1 Solution in XQuery
3.0</h5>
<div class="exampleInner">
<pre>
for $employee in doc("employees.xml")/*/employee
let $salary := $employee/salary
group by $department := $employee/department
let $max-salary := max($salary)
let $highest-earners := $employee[salary = $max-salary]
return
   &lt;department name="{$department}"&gt;{ $highest-earners }&lt;/department&gt;,

for $employee in doc("employees.xml")/*/employee
let $salary := $employee/salary
group by $job-type := $employee/job-type
let $totals := count($employee)
return
   &lt;total-by-job-type type="{$job-type}"&gt;{ $totals }&lt;/total-by-job-type&gt;

          
</pre></div>
</div>
<div class="div4">
<h5><a name="d3e733" id="d3e733"></a>2.1.2.2 Solution in XQuery 3.0
with XSLT Maps</h5>
<div class="exampleInner">
<pre>
declare function local:search-employees(
  $employees as element(employee)*,
  $highest-earners as map(xs:string, element(employee),
  $totals as map(xs:string, xs:double))
)
{
  if(empty($employees)) then ($highest-earners, $totals) else

  let $this := head($employees)
  let $existing := $highest-earners($this/department)
  let $new-earners :=
    if ($existing/salary gt $this/salary) then $highest-earners
    else map:new(($highest-earners, map:entry($this/department, $this)))
  let $job-type := $this/job-type/string()
  let $new-totals := map:new(($totals, map { $job-type := $totals($job-type) + 1 }))
  return local:search-employees(tail($employees), $new-earners, $new-totals)
};

let $results := local:search-employees(doc("employees.xml")/*/employee, map:new())
let $highest-earners := $results[1]
let $totals := results[2]
return (
  for $department in map:keys($highest-earners)
  return
    &lt;department name="{$department}"&gt;{ $highest-earners($department) }&lt;/department&gt;,
  for $job-type in map:keys($totals)
  return
    &lt;total-by-job-type type="{$job-type}"&gt;{ $totals($job-type) }&lt;/total-by-job-type&gt;
)
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="streaming-query3" id="streaming-query3"></a>2.1.3 Word
Count by Lemma</h4>
<p>Calculate the word count by lemma of the verbs in the following
document.</p>
<div class="div4">
<h5><a name="streaming-query3-data" id=
"streaming-query3-data"></a>2.1.3.1 Input Data</h5>
<p>The XML document, gnt.xml.</p>
<div class="exampleInner">
<pre>
&lt;gnt&gt;
&lt;s&gt;
 &lt;w pos="PP"&gt;I&lt;/w&gt;
 &lt;w pos="V" lemma="go"&gt;go&lt;/w&gt;
 &lt;pu&gt;.&lt;/pu&gt;
&lt;/s&gt;
&lt;s&gt;
 &lt;w pos="PP"&gt;She&lt;/w&gt;
 &lt;w pos="V" lemma="go"&gt;went&lt;/w&gt;
 &lt;pu&gt;.&lt;/pu&gt;
&lt;/s&gt;
&lt;s&gt;
 &lt;w pos="PP"&gt;He&lt;/w&gt;
 &lt;w pos="V" lemma="go"&gt;goes&lt;/w&gt;
 &lt;pu&gt;.&lt;/pu&gt;
&lt;/s&gt;
&lt;s&gt;
 &lt;w pos="PP"&gt;I&lt;/w&gt;
 &lt;w pos="V" lemma="see"&gt;see&lt;/w&gt;
 &lt;pu&gt;.&lt;/pu&gt;
&lt;/s&gt;
&lt;s&gt;
 &lt;w pos="PP"&gt;She&lt;/w&gt;
 &lt;w pos="V" lemma="see"&gt;sees&lt;/w&gt;
 &lt;pu&gt;.&lt;/pu&gt;
&lt;/s&gt;
&lt;s&gt;
 &lt;w pos="PP"&gt;I&lt;/w&gt;
 &lt;w pos="V" lemma="have"&gt;have&lt;/w&gt;
 &lt;pu&gt;.&lt;/pu&gt;
&lt;/s&gt;
&lt;s&gt;
 &lt;w pos="PP"&gt;She&lt;/w&gt;
 &lt;w pos="V" lemma="have"&gt;has&lt;/w&gt;
 &lt;pu&gt;.&lt;/pu&gt;
&lt;/s&gt;
&lt;/gnt&gt;
</pre></div>
</div>
<div class="div4">
<h5><a name="d3e756" id="d3e756"></a>2.1.3.2 Result</h5>
<div class="exampleInner">
<pre>
&lt;verb lemma="go" count="3"/&gt;
&lt;verb lemma="see" count="2"/&gt;
&lt;verb lemma="have" count="2"/&gt;
</pre></div>
</div>
<div class="div4">
<h5><a name="d3e761" id="d3e761"></a>2.1.3.3 Solution in XQuery 3.0
with XSLT Maps:</h5>
<div class="exampleInner">
<pre>
declare function local:word-count($words, $result)
{
  if(empty($words)) then $result else

  let $word := head($words)
  return local:word-count(tail($words),
    map:new(($result, map { $word/@lemma := ($result($word/@lemma), 0)[1] + 1 })))
};

let $counts := local:word-count(doc("gnt.xml")//w[m:is-verb(.)], map{})
for $lemma in map:keys($counts)
let $count := $counts($lemma)
order by $count
return
  &lt;verb lemma="{ $lemma }" count="{ $count }"/&gt;
</pre></div>
</div>
<div class="div4">
<h5><a name="d3e766" id="d3e766"></a>2.1.3.4 Alternative Solution
in XQuery 3.0 with XSLT Maps:</h5>
<div class="exampleInner">
<pre>
let $counts := fold-left(function($map, $word) {
    map:new(($result, map { $word/@lemma := ($map($word/@lemma), 0)[1] + 1 }))
  }, map{}, doc("gnt.xml")//w[m:is-verb(.)])
for $lemma in map:keys($counts)
let $count := $counts($lemma)
order by $count
return
  &lt;verb lemma="{ $lemma }" count="{ $count }"/&gt;
</pre></div>
</div>
<div class="div4">
<h5><a name="d3e771" id="d3e771"></a>2.1.3.5 Solution Using
Grouping in XQuery 3.0:</h5>
<p>A solution just using grouping, without maps.</p>
<div class="exampleInner">
<pre>
for $word in doc("gnt.xml")//w
let $lemma := $word/@lemma
where m:is-verb($word)
group by $lemma
order by count($word) descending
return
  &lt;verb lemma="{ $lemma }" count="{count($word)}" /&gt;
</pre></div>
</div>
<div class="div4">
<h5><a name="d3e778" id="d3e778"></a>2.1.3.6 Solution in XSLT
3.0:</h5>
<div class="exampleInner">
<pre>
&lt;xsl:iterate select="doc("gnt.xml")//w"&gt;
  &lt;xsl:param name="result" select="map{}"/&gt;
  &lt;xsl:next-iteration&gt;
    &lt;xsl:with-param name="result"
      select="map:new(($map, map { $word := ($map($word), 0)[1] + 1 }))"/&gt;
  &lt;/xsl:next-iteration&gt;
  &lt;xsl:on-completion&gt;
    &lt;xsl:for-each select="map:keys($result)"&gt;
      &lt;xsl:sort select="$result(.)"/&gt;
      &lt;verb lemma="{ . }" count="{ $result(.) }"/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:on-completion&gt;
&lt;/xsl:iterate&gt;
</pre></div>
</div>
</div>
</div>
<div class="div2">
<h3><a name="complex" id="complex"></a>2.2 Compound Values</h3>
<div class="div3">
<h4><a name="complex-query1" id="complex-query1"></a>2.2.1 Complex
Number Library</h4>
<p>Implement a complex number library for XQuery or XSLT 3.0.
Complex numbers should be represented as a single item, so they can
themselves be manipulated like regular numbers by returning
sequences of them etc.</p>
<div class="div4">
<h5><a name="d3e792" id="d3e792"></a>2.2.1.1 Solution in XQuery 3.0
with XSLT Maps:</h5>
<div class="exampleInner">
<pre>
declare function i:complex(
  $real as xs:double,
  $imaginary as xs:double
) as map(xs:boolean, xs:double)
{
  map{ true() := $real, false() := $imaginary }
};

declare function i:real(
  $complex as map(xs:boolean, xs:double)
) as xs:double
{
  $complex(true())
};

declare function i:imaginary(
  $complex as map(xs:boolean, xs:double)
) as xs:double
{
  $complex(false())
};

declare function i:add(
  $arg1 as map(xs:boolean, xs:double),
  $arg2 as map(xs:boolean, xs:double)
) as map(xs:boolean, xs:double)
}
  i:complex(i:real($arg1)+i:real($arg2),
    i:imaginary($arg1)+i:imaginary($arg2))
};

declare function i:multiply(
  $arg1 as map(xs:boolean, xs:double),
  $arg2 as map(xs:boolean, xs:double)
) as map(xs:boolean, xs:double)
{
  i:complex(
    i:real($arg1)*i:real($arg2) - i:imaginary($arg1)*i:imaginary($arg2),
    i:real($arg1)*i:imaginary($arg2) + i:imaginary($arg1)*i:real($arg2))
};
</pre></div>
</div>
<div class="div4">
<h5><a name="d3e797" id="d3e797"></a>2.2.1.2 Solution in XSLT 3.0
(using type-alias proposal, still in discussion):</h5>
<div class="exampleInner">
<pre>
&lt;xsl:type-alias name="i:complex" as="map(xs:boolean, xs:double)"/&gt;

&lt;xsl:function name="i:complex" as="i:complex"&gt;
&lt;xsl:param name="real" as="xs:double"/&gt;
&lt;xsl:param name="imaginary" as="xs:double"/&gt;
&lt;xsl:sequence select="map{ true() := $real, false() := $imaginary }"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:function name="i:real" as="xs:double"&gt;
&lt;xsl:param name="complex" as="i:complex"/&gt;
&lt;xsl:sequence select="$complex(true())"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:function name="i:imaginary" as="xs:double"&gt;
&lt;xsl:param name="complex" as="i:complex"/&gt;
&lt;xsl:sequence select="$complex(false())"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:function name="i:add" as="i:complex"&gt;
&lt;xsl:param name="arg1" as="i:complex"/&gt;
&lt;xsl:param name="arg2" as="i:complex"/&gt;
&lt;xsl:sequence select="i:complex(i:real($arg1)+i:real($arg2),
  i:imaginary($arg1)+i:imaginary($arg2))"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:function name="i:multiply" as="i:complex"&gt;
&lt;xsl:param name="arg1" as="i:complex"/&gt;
&lt;xsl:param name="arg2" as="i:complex"/&gt;
&lt;xsl:sequence select="i:complex(
       i:real($arg1)*i:real($arg2) - i:imaginary($arg1)*i:imaginary($arg2),
       i:real($arg1)*i:imaginary($arg2) + i:imaginary($arg1)*i:real($arg2))"/&gt;
&lt;/xsl:function&gt;
</pre></div>
</div>
</div>
</div>
<div class="div2">
<h3><a name="indexes" id="indexes"></a>2.3 Manual Indexing</h3>
<p>Build an index to manually optimize retrieval of books in a
catalog by their ISBN number.</p>
<div class="div3">
<h4><a name="indexes-query1" id="indexes-query1"></a>2.3.1 Simple
Manual Join</h4>
<p>Construct a list of all authors, and the books they have
written.</p>
<div class="div4">
<h5><a name="indexes-data" id="indexes-data"></a>2.3.1.1 Input
Data</h5>
<p>Book elements of the form:</p>
<div class="exampleInner">
<pre>
&lt;book&gt;
&lt;isbn&gt;0470192747&lt;/isbn&gt;
&lt;publisher&gt;Wiley&lt;/publisher&gt;
&lt;title&gt;XSLT 2.0 and XPath 2.0 Programmer's Reference&lt;/title&gt;
&lt;/book&gt;
</pre></div>
<p>Author elements of the form:</p>
<div class="exampleInner">
<pre>
&lt;author&gt;
&lt;author&gt;Michael H. Kay&lt;/author&gt;
&lt;isbn&gt;0470192747&lt;/isbn&gt;
&lt;isbn&gt;...&lt;/isbn&gt;
&lt;/book&gt;
</pre></div>
</div>
<div class="div4">
<h5><a name="d3e824" id="d3e824"></a>2.3.1.2 Solution in XQuery 3.0
with XSLT Maps:</h5>
<div class="exampleInner">
<pre>
declare variable $index := map:new(//book ! map{isbn := .});

&lt;table&gt;{
  for $a in //author
  return &lt;tr&gt;
    &lt;td&gt;{ $a/name/string() }&lt;/td&gt;
    &lt;td&gt;{ string-join($a/isbn ! $index(.)/title/string(), ", ") }&lt;/td&gt;
  &lt;/tr&gt;
}&lt;/table&gt;
</pre></div>
</div>
<div class="div4">
<h5><a name="d3e829" id="d3e829"></a>2.3.1.3 Solution in XSLT
3.0:</h5>
<p>XSLT has the xsl:key functionality, which is preferable.
However, a straight forward translation from the XQuery solution
follows:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="index" select="map:new(//book ! map{isbn := .})"/&gt;

&lt;table&gt;
  &lt;xsl:for-each select="//author"&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;xsl:value-of select="name"/&gt;&lt;/td&gt;
      &lt;td&gt;&lt;xsl:value-of select="string-join(isbn ! $index(.)/title/string(), ', ')"/&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/xsl:for-each&gt;
}&lt;/table&gt;
</pre></div>
</div>
</div>
</div>
<div class="div2">
<h3><a name="interface" id="interface"></a>2.4 Interface /
Implementation Pattern</h3>
<p>As in Javascript, a map whose keys are strings and whose
associated values are function items can be used in a similar way
to a class in object-oriented programming languages.</p>
<div class="div3">
<h4><a name="interface-query1" id="interface-query1"></a>2.4.1 Data
Variety</h4>
<p>Suppose an application needs to handle customer order
information that may arrive in three different formats, with
different hierarchic arrangement.</p>
<p>An application can isolate itself from these differences by
defining a set of functions to navigate the relationships between
customers, orders, and products: orders-for-customer,
orders-for-product, customer-for-order, product-for-order. These
functions can be implemented in different ways for the three
different input formats.</p>
<div class="div4">
<h5><a name="interface-data1" id="interface-data1"></a>2.4.1.1
Input Data</h5>
<p>Flat structure:</p>
<div class="exampleInner">
<pre>
&lt;customer id="c123"&gt;...&lt;/customer&gt;
&lt;product id="p789"&gt;...&lt;/product&gt;
&lt;order customer="c123" product="p789"&gt;...&lt;/order&gt;
</pre></div>
<p>Orders within customer elements:</p>
<div class="exampleInner">
<pre>
&lt;customer id="c123"&gt;
&lt;order product="p789"&gt;...&lt;/order&gt;
&lt;/customer&gt;
&lt;product id="p789"&gt;...&lt;/product&gt;
</pre></div>
<p>Orders within product elements:</p>
<div class="exampleInner">
<pre>
&lt;customer id="c123"&gt;...&lt;/customer&gt;
&lt;product id="p789"&gt;
&lt;order customer id="c123"&gt;...&lt;/order&gt;
&lt;/product&gt;
</pre></div>
</div>
<div class="div4">
<h5><a name="d3e864" id="d3e864"></a>2.4.1.2 Solution in XQuery 3.0
with XSLT Maps:</h5>
<p>For example, with the first format the implementation might
be:</p>
<div class="exampleInner">
<pre>
let $flat-input-functions as map(xs:string, function(*))*
return map {
  'orders-for-customer' := function($c as element(customer)) as element(order)*
    { $c/../order[@customer=$c/@id] },
  'orders-for-product' := function($p as element(product)) as element(order)*
    { $p/../order[@product=$p/@id] },
  'customer-for-order' := function($o as element(order)) as element(customer)
    { $o/../customer[@id=$o/@customer] },
  'product-for-order' := function($o as element(order)) as element(product)
    { $o/../product[@id=$o/@product] }
}
</pre></div>
</div>
<div class="div4">
<h5><a name="d3e871" id="d3e871"></a>2.4.1.3 Solution in XSLT
3.0:</h5>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="flat-input-functions" as="map(xs:string, function(*))*"
   select="map {
             'orders-for-customer' :=
                  function($c as element(customer)) as element(order)*
                     {$c/../order[@customer=$c/@id]},
             'orders-for-product' :=
                  function($p as element(product)) as element(order)*
                     {$p/../order[@product=$p/@id]},
             'customer-for-order' :=
                  function($o as element(order)) as element(customer)
                     {$o/../customer[@id=$o/@customer]},
             'product-for-order' :=
                  function($o as element(order)) as element(product)
                     {$o/../product[@id=$o/@product]} }
          "/&gt;
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="interface-query2" id="interface-query2"></a>2.4.2
Search and Snippeting</h4>
<p>Create a general interface that takes as input some words, does
a full-text search for them, and returns snippets of the top 10
results, ordered by score, where the nodes to search, their
structure, how to construct snippets and how to score them differ
for different data sets.</p>
<div class="div4">
<h5><a name="d3e881" id="d3e881"></a>2.4.2.1 Solution in XQuery
Full Text 3.0 with XSLT Maps:</h5>
<p>Create a template method and use a map of functions to define
the implementation of the plug-in points.</p>
<div class="exampleInner">
<pre>
(: General interface module :)

module namespace this="http://example.com/search-interface/";

declare function this:search(
    $words as xs:string*, $collection as map(xs:string, function(*)) )
{
    (for $d in $collection('select')[. contains text {$words} any word]
     order by $collection('score', $d, $words)
     return $collection('snippet', $d, $words))[position()&lt;=10]
};

(: Specific implementation example :)

import module namespace s="http://example.com/search-interface/";

declare variable $twitter as map(xs:string, function(*)) :=
    map {
      'select' := function() as node()*
          { collection("twitter") },
      'score' := function($n as node(), $words as xs:string*) as xs:double
          { let score $s1 := $n contains text {$words} any word
            let score $s2 := $n contains text {$words} all words
            return $s1 + $s2
          },
      'snippet' := function($node as node(), $words as xs:string*) as node()
          { $node },
    };

declare variable $blog as map(xs:string, function(*)) :=
    map {
      'select' := function() as node()*
          { collection("blogs")/body },
      'score' := function($n as node(), $words as xs:string*) as xs:double
          {
            let $s1 :=
              avg(
                for $p score $s in $n/para[. contains text {$words} any  
word]
                return $s)
            let $s2 :=
              avg(
                for $p score $s in
                  $n/comment[. contains text {$words} weight 0.5 any word]
                return $s)
            let score $s3 := $n/title contains text {$words} weight 5.0 any  
word
            return $s1 + $s2 + $s3
          },
      'snippet' := function($node as node(), $words as xs:string*) as node()
          { &lt;result&gt;{$node/title, $node/para[1], $node/comment[1]}&lt;/result&gt;  
},
    };

declare variable $books as map(xs:string, function(*)) :=
    map {
      'select' := function() as node()*
          { collection()//chapter },
      'score' := function($n as node(), $words as xs:string*) as xs:double
          { let score $s1 := $n contains text {$words} any word
            let score $s2 := $n/title contains text {$words} weight 5.0 any  
word
            return $s1 + $s2
          },
      'snippet' := function($node as node(), $words as xs:string*) as node()
          { &lt;result&gt;{$node/title,
            ((for $p score $s in $node/p[. contains text {$words} all words]
              order by $s
              return $p),
             (for $p score $s in $node/p[. contains text {$words} any word]
              order by $s
              return $p))[1]
            }&lt;/result&gt; },
    };

(: Get top 10 from various sources :)
s:search(("fire","earthquake"),$books),
s:search(("fire","earthquake"),$twitter),
s:search(("fire","earthquake"),$blog)
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="interface-query3" id="interface-query3"></a>2.4.3
Abstracting Document Structure</h4>
<p>Provide access to various pieces of metadata to application,
insulating that application code from variations in document
structure.</p>
<div class="div4">
<h5><a name="d3e893" id="d3e893"></a>2.4.3.1 Solution in XQuery 3.0
with XSLT Maps:</h5>
<p>Define the metadata interface through a map of functions.</p>
<div class="exampleInner">
<pre>
(: Specific implementations :)
declare namespace xh="http://www.w3.org/1999/xhtml";
declare variable $xhtml as map(xs:string, function(*)) :=
    map {
      'title' := function($n as document-node()) as xs:string?
          { $n/xh:head/xh:title },
      'author' := function($n as document-node()) as xs:string?
          { $n/xh:head/xh:meta[@name='author']/@content },
      'pubdate' := function($n as document-node()) as xs:string?
          { $n/xh:head/xh:meta[@name='created']/@content },
      'publisher' := function($n as document-node()) as xs:string?
          { () }
    };

declare variable $medline-citation as map(xs:string, function(*)) :=
    map {
      'title' := function($n as document-node()) as xs:string?
          { $n/MedlineCitation/Article/ArticleTitle },
      'author' := function($n as document-node()) as xs:string?
          {
            string-join(
              for $a in $n/MedlineCitation//Author return
              concat($a/LastName, ", ", $a/ForeName), "; ")
          },
      'pubdate' := function($n as document-node()) as xs:string?
          {
             let $d := $n/MedlineCitation/Article/PubDate
             return string-join(($d/Day,$d/Month,$d/Year), " ")
          },
      'publisher' := function($n as document-node()) as xs:string?
          {  $n/MedlineCitation/MedlineJournalIngo/MedlineTA }
    };
</pre></div>
</div>
</div>
</div>
<div class="div2">
<h3><a name="parameter" id="parameter"></a>2.5 Parameter
Passing</h3>
<p>Often library functions may have a large number of optional
arguments, which are awkward or impossible to provide using the
existing mechanism of variable arity functions.</p>
<div class="div3">
<h4><a name="parameter-query1" id="parameter-query1"></a>2.5.1 XSLT
Stylesheet Parameters</h4>
<p>Pass the list of parameter names and values to the
xdmp:xslt-invoke() function, which invokes an XSLT stylesheet.</p>
<div class="div4">
<h5><a name="d3e912" id="d3e912"></a>2.5.1.1 Solution in XQuery 3.0
with XSLT Maps:</h5>
<div class="exampleInner">
<pre>
declare function xdmp:xslt-invoke($path as xs:string, $input as node(),
  $params as map(xs:QName, item()*)) as document-node()* external;

xdmp:xslt-invoke("my-stylesheet.xsl", doc("my-doc.xml"), map {
  xs:QName("toc") := true(),
  xs:QName("index") := doc("index_terms.xml")
})
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="parameter-query2" id="parameter-query2"></a>2.5.2
Function Options</h4>
<p>Provide a machanism to supply (otherwise defaulted) option
values to the fn:doc() function, which control aspects of it's
behaviour, including:</p>
<ul>
<li>
<p>Parsing of external entities</p>
</li>
<li>
<p>DTD validation</p>
</li>
<li>
<p>XML Schema validation</p>
</li>
<li>
<p>Lax (XML Schema) validation</p>
</li>
<li>
<p>Whitespace stripping</p>
</li>
<li>
<p>URI resolution</p>
</li>
</ul>
<p>Using maps in this scenario brings benefits over using XML
structure, including:</p>
<ul>
<li>
<p>Nodes are not copied; identity is retained</p>
</li>
<li>
<p>Atomic items are not serialized, and retain their specific
type</p>
</li>
<li>
<p>Functions can be passed in as options - the relevant example in
this case being the URI resolver.</p>
</li>
</ul>
<div class="div4">
<h5><a name="d3e953" id="d3e953"></a>2.5.2.1 Solution in XQuery 3.0
with XSLT Maps:</h5>
<div class="exampleInner">
<pre>
declare function fn:doc($uri as xs:string, $options as map(xs:string, item()*)) as document-node()? external;

(: Enable lax XML Schema validation :)
doc("validate-me.xml", map {
  "schema-validation" := true(),
  "lax-validation" := true()
}),

(: Enable whitespace stripping, and a custom URI resolution :)
doc("../relative-uri.xml", map {
  "strip-whitespace" := true(),
  "uri-resolver" := resolve-uri(?, base-uri())
})
</pre></div>
</div>
<div class="div4">
<h5><a name="d3e958" id="d3e958"></a>2.5.2.2 Solution in XQuery 3.0
with XSLT Maps enhanced with stronger typing:</h5>
<div class="exampleInner">
<pre>
declare function fn:doc(
  $uri as xs:string,
  $options as strong-map(
    external-entities as xs:boolean?,
    dtd-validation as xs:boolean?,
    schema-validation as xs:boolean?,
    lax-validation as xs:boolean?,
    strip-whitespace as xs:boolean?,
    uri-resolver as function(xs:string) as xs:string
  )
) as document-node()? external;

(: Enable lax XML Schema validation :)
doc("validate-me.xml", map {
  xs:QName("schema-validation") := true(),
  xs:QName("lax-validation") := true()
}),

(: Enable whitespace stripping, and a custom URI resolution :)
doc("../relative-uri.xml", map {
  xs:QName("strip-whitespace") := true(),
  xs:QName("uri-resolver") := resolve-uri(?, base-uri())
})
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="parameter-query3" id="parameter-query3"></a>2.5.3
Translation</h4>
<p>Design a language-agnostic game (here just the core), which
allows a translation function or map as a parameter.</p>
<div class="div4">
<h5><a name="d3e968" id="d3e968"></a>2.5.3.1 Solution in XQuery 3.0
with XSLT Maps:</h5>
<div class="exampleInner">
<pre>
declare function local:play(
  $secret-number as xs:integer,
  $guessed-number as xs:integer,
  $translator as function(xs:string) as xs:string)
{
  switch (true())
  case $guessed-number eq $secret-number
    return $translator("You won!")
  case $guessed-number lt $secret-number
    return $translator("The secret number is greater.")
  default case (: $guessed-number gt $secret-number :)
    return $translator("The secret number is lower.")
};

local:play(76, 86, function($x) { $x }), (: Keep English :)

local:play(76, 86, map {
  "You won!" := "Du hast gewonnen!",
  "The secret number is greater." := "Die geheime Zahl ist groesser.",
  "The secret number is lower." :=  Die geheime Zahl ist kleiner." }
),

local:play(76, 86, $automated-translator-based-on-natural-language-processing)
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="parameter-query4" id="parameter-query4"></a>2.5.4
Cipher Functions</h4>
<p>Provide an encryption function which will encode some input
according to a cipher that can be a codebook implemented as a map
or an explicit algorithm.</p>
<div class="div4">
<h5><a name="d3e978" id="d3e978"></a>2.5.4.1 Solution in XQuery 3.0
with XSLT Maps:</h5>
<div class="exampleInner">
<pre>
declare function local:encode(
  $input as xs:string,
  $cipher as function(xs:integer) as xs:integer)
{
  codepoints-to-string($cipher(string-to-codepoints($input)))
};

let $code := {
  string-to-codepoints("a") := string-to-codepoints("z"),
  string-to-codepoints("b") := string-to-codepoints("e"),
  ...
}
return
local:encode("Message", $code),

local:encode("Message",
  function($c) { $c + 3 (: Caesar's cipher :) })
</pre></div>
</div>
</div>
</div>
<div class="div2">
<h3><a name="json" id="json"></a>2.6 JSON</h3>
<p>JSON is becoming an important data format that many XQuery and
XSLT users have to deal with. Tasks performed can include importing
JSON, processing it, and exporting JSON.</p>
<div class="div3">
<h4><a name="json-query1" id="json-query1"></a>2.6.1 Information
Retrieval</h4>
<p>Import a JSON document and retrieve the mobile phone number from
it.</p>
<p>The fn:parse-json() function parses a JSON document into an XDM
value as follows:</p>
<ol class="enumar">
<li>
<p>A JSON object is converted into a map of type map(xs:string,
item()?).</p>
</li>
<li>
<p>A JSON array is converted into a map of type map(xs:integer,
item()?).</p>
</li>
<li>
<p>A JSON string is converted into an xs:string atomic value.</p>
</li>
<li>
<p>A JSON number is converted into an xs:double atomic value.</p>
</li>
<li>
<p>A JSON boolean is converted into an xs:boolean atomic value.</p>
</li>
<li>
<p>A JSON null is converted into the empty sequence.</p>
</li>
</ol>
<div class="div4">
<h5><a name="json-query1-data" id="json-query1-data"></a>2.6.1.1
Input Data</h5>
<p>The JSON document, mildred.json:</p>
<div class="exampleInner">
<pre>
{
     "firstname": "Mildred",
     "lastname": "Moore",
     "age": 32,
     "address":
     {
         "street": "91 High Street",
         "town": "Biscester",
         "county": "Oxfordshire",
         "postcode": "OX6 3PD"
     },
     "phone":
     [
         {
           "type": "home",
           "number": "01869 378073"
         },
         {
           "type": "mobile",
           "number": "07356 740756"
         }
     ]
}
</pre></div>
</div>
<div class="div4">
<h5><a name="d3e1022" id="d3e1022"></a>2.6.1.2 Result</h5>
<div class="exampleInner">
<pre>
"07356 740756"
</pre></div>
</div>
<div class="div4">
<h5><a name="d3e1027" id="d3e1027"></a>2.6.1.3 Solution in XQuery
3.0 with XSLT Maps:</h5>
<div class="exampleInner">
<pre>
let $phoneArray := parse-json(unparsed-text("mildred.json"))("phone")
for $n in map:keys($phoneArray)
let $entry := $phoneArray($n)
where $entry("type") = "mobile"
return $entry("number")
</pre></div>
</div>
<div class="div4">
<h5><a name="d3e1035" id="d3e1035"></a>2.6.1.4 Alternative Solution
in XQuery 3.0 with XSLT Maps:</h5>
<div class="exampleInner">
<pre>
declare function map:entries($map as map(*)) as map(*)*
{
  for $k in map:keys($map)
  return map { "key" := $k, "value" := $map($k) }
};

parse-json(unparsed-text("mildred.json"))
  ("phone")!map:entries(.)[.("value")("type") = "mobile"]("number")
</pre></div>
</div>
<div class="div4">
<h5><a name="d3e1040" id="d3e1040"></a>2.6.1.5 Solution in
JSONiq:</h5>
<div class="exampleInner">
<pre>
        let $mildred := json("mildred.json")
        let $phones := values($mildred("phone"))
        return $phones[.("type") = "mobile"]("number")
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="json-query2" id="json-query2"></a>2.6.2 Converting
JSON to XML</h4>
<p>Convert a JSON data file to XML.</p>
<div class="div4">
<h5><a name="json-query2-data" id="json-query2-data"></a>2.6.2.1
Input Data</h5>
<p>The JSON document, employees.json:</p>
<div class="exampleInner">
<pre>
{ "accounting" : [
      { "firstName" : "John",
        "lastName"  : "Doe",
        "age"       : 23 },

      { "firstName" : "Mary",
        "lastName"  : "Smith",
        "age"       : 32 }
                 ],
  "sales"     : [
      { "firstName" : "Sally",
        "lastName"  : "Green",
        "age"       : 27 },

      { "firstName" : "Jim",
        "lastName"  : "Galley",
        "age"       : 41 }
                  ]
}
</pre></div>
</div>
<div class="div4">
<h5><a name="d3e1057" id="d3e1057"></a>2.6.2.2 Result</h5>
<div class="exampleInner">
<pre>
&lt;department name="accounting"&gt;
  &lt;employee&gt;
    &lt;firstName&gt;John&lt;/firstName&gt;
    &lt;lastName&gt;Doe&lt;/lastName&gt;
    &lt;age&gt;23&lt;/age&gt;
  &lt;/employee&gt;
  &lt;employee&gt;
    &lt;firstName&gt;Mary&lt;/firstName&gt;
    &lt;lastName&gt;Smith&lt;/lastName&gt;
    &lt;age&gt;32&lt;/age&gt;
  &lt;/employee&gt;
&lt;/department&gt;
&lt;department name="sales"&gt;
  &lt;employee&gt;
    &lt;firstName&gt;Sally&lt;/firstName&gt;
    &lt;lastName&gt;Green&lt;/lastName&gt;
    &lt;age&gt;27&lt;/age&gt;
  &lt;/employee&gt;
  &lt;employee&gt;
    &lt;firstName&gt;Jim&lt;/firstName&gt;
    &lt;lastName&gt;Galley&lt;/lastName&gt;
    &lt;age&gt;41&lt;/age&gt;
  &lt;/employee&gt;
&lt;/department&gt;
</pre></div>
</div>
<div class="div4">
<h5><a name="d3e1062" id="d3e1062"></a>2.6.2.3 Solution in XQuery
3.0 with XSLT Maps:</h5>
<div class="exampleInner">
<pre>
let $input := parse-json(unparsed-text('employees.json'))
for $k in map:keys($input)
return
  &lt;department name="{$k}"&gt;{
    let $array := $input($k)
    for $i in map:keys($array)
    let $emp := $array($i)
    return
      &lt;employee&gt;
        &lt;firstName&gt;{ $emp('firstName') }&lt;/firstName&gt;
        &lt;lastName&gt;{ $emp('lastName') }&lt;/lastName&gt;
        &lt;age&gt;{ $emp('age') }&lt;/age&gt;
      &lt;/employee&gt;
  }&lt;/department&gt;
</pre></div>
</div>
<div class="div4">
<h5><a name="d3e1067" id="d3e1067"></a>2.6.2.4 Solution in
JSONiq:</h5>
<div class="exampleInner">
<pre>
for $dept in pairs(json("employees.json"))
return
   &lt;department name="{ name($dept) }"&gt; {
       for $employee in members(value($dept))
       return
         &lt;employee&gt;
           &lt;firstName&gt;{ $employee('firstName') }&lt;/firstName&gt;
           &lt;lastName&gt;{ $employee('lastName') }&lt;/lastName&gt;
           &lt;age&gt;{ $employee('age') }&lt;/age&gt;
         &lt;/employee&gt;
   }&lt;/department&gt;
     
</pre></div>
</div>
<div class="div4">
<h5><a name="d3e1072" id="d3e1072"></a>2.6.2.5 Solution in XSLT
3.0:</h5>
<div class="exampleInner">
<pre>
&lt;xsl:template name="main"&gt;
  &lt;xsl:variable name="input"
                as="map(xs:string, map(xs:string, xs:anyAtomicType)*)"
                select="parse-json(unparsed-text('employees.json'))"/&gt;
  &lt;xsl:for-each select="map:keys($input)"&gt;
    &lt;department name="{.}"&gt;
      &lt;xsl:for-each select="$input(.)"&gt;
        &lt;employee&gt;
          &lt;firstName&gt;&lt;xsl:value-of select=".('firstName')"/&gt;&lt;/firstName&gt;
          &lt;lastName&gt;&lt;xsl:value-of select=".('lastName')"/&gt;&lt;/lastName&gt;
          &lt;age&gt;&lt;xsl:value-of select=".('age')"/&gt;&lt;/age&gt;
        &lt;/employee&gt;
      &lt;/xsl:for-each&gt;
    &lt;/department&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="json-query3" id="json-query3"></a>2.6.3 Update by
Copying</h4>
<p>Update the first name of the author "Dan Suciu" to "John" in the
"bookinfo.json" document.</p>
<div class="div4">
<h5><a name="json-query3-data" id="json-query3-data"></a>2.6.3.1
Input Data</h5>
<p>The JSON document, bookinfo.json:</p>
<div class="exampleInner">
<pre>
{
    "book": {
        "title": "Data on the Web",
        "year": 2000,
        "author": [
            {
                "last": "Abiteboul",
                "first": "Serge"
            },
            {
                "last": "Buneman",
                "first": "Peter"
            },
            {
                "last": "Suciu",
                "first": "Dan"
            }
        ],
        "publisher": "Morgan Kaufmann Publishers",
        "price": 39.95
    }
}
</pre></div>
</div>
<div class="div4">
<h5><a name="d3e1089" id="d3e1089"></a>2.6.3.2 Solution in XQuery
3.0 with XSLT Maps:</h5>
<div class="exampleInner">
<pre>
declare function local:map-transform($map as map(*))
{
  typeswitch($arg)
  case $map as map(*) return
    map:new((
      for $k in map:keys($map)
      let $v := $map($k)
      return map { $k := local:map-transform($v) },
      if($map('last')='Suciu') then map { 'first' := "John" } else ()
    ))
  default $arg
};

local:map-transform(parse-json(unparsed-text("bookinfo.json")))
</pre></div>
</div>
<div class="div4">
<h5><a name="d3e1094" id="d3e1094"></a>2.6.3.3 Solution in XSLT
3.0:</h5>
<p>Assuming a function map:entries() which returns the entries in a
map as a sequence of singleton maps.</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="~map(*)" mode="john" as="map(*)"&gt;
  &lt;xsl:variable name="entries" as="map(*)*&gt;
    &lt;xsl:apply-templates select="map:entries(.)" mode="john"/&gt;
  &lt;/xsl:variable&gt;
  &lt;xsl:sequence select="map:new($entries)"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="~map(*)[.('last')='Suciu']" mode="john"&gt;
  &lt;xsl:sequence select="map:new((., map{'first':='John'}))"/&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="json.joins" id="json.joins"></a>2.6.4 Joins</h4>
<div class="div4">
<h5><a name="d3e1107" id="d3e1107"></a>2.6.4.1 Input Data</h5>
<p>The following queries are based on a social media site that
allows users to interact with their friends.
<code>collection("users")</code> contains data on users and their
friends:</p>
<div class="exampleInner">
<pre>
{
  "name" : "Sarah",
  "age" : 13,
  "gender" : "female",
  "friends" : [ "Jim", "Mary", "Jennifer"]
}

{
  "name" : "Jim",
  "age" : 13,
  "gender" : "male",
  "friends" : [ "Sarah" ]
}
          
</pre></div>
</div>
<div class="div4">
<h5><a name="d3e1117" id="d3e1117"></a>2.6.4.2 Solution in
JSONiq:</h5>
<p>The following query performs a join on Sarah's friend list to
return the Object representing each of her friends:</p>
<div class="exampleInner">
<pre>
for $sarah in collection("users")
    $friend in collection("users")
where $sarah("name") = "Sarah"
  and values($sarah("friends")) = $friend("name")
return $friend 
</pre></div>
<p>The query can be simplified using a filter. In the following
expression, <code>[.("name") = "Sarah"]</code> is a filter that
restricts the set of users to the one named "Sarah":</p>
<div class="exampleInner">
<pre>
let $sarah := collection("users")[.("name") eq "Sarah"]
for $friend in values($sarah("friends"))
return collection("users")[.("name") eq $friend]
          
</pre></div>
</div>
<div class="div4">
<h5><a name="d3e1131" id="d3e1131"></a>2.6.4.3 Solution in XSLT
3.0:</h5>
<p>Solution using the XSLT maps proposal: essentially the same as
the above, assuming (a) the existence of some mechanism similar to
<code>collection()</code> to get a collection of JSON inputs and
parse them using the <code>parse-json()</code> function, and (b)
the existence of a (potentially user-written) function
<code>values()</code> to extract the values of the map representing
a JSON array. This function might be written:</p>
<div class="exampleInner">
<pre>
&lt;xsl:function name="values" as="item(*)"&gt;
  &lt;xsl:param name="array" as="map(xs:integer, item())"/&gt;
  &lt;xsl:for-each select="map:keys($array)"&gt;
    &lt;xsl:sequence select="$array(.)"/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:function&gt;
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="jsongrouping" id="jsongrouping"></a>2.6.5 Grouping
Queries for JSON</h4>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>These queries are based on similar queries in the XQuery 3.0 Use
Cases.</p>
</div>
<div class="div4">
<h5><a name="d3e1153" id="d3e1153"></a>2.6.5.1 Input Data</h5>
<p>The input is a sequence (whose order is of no concern) that
contains the following sales data, represented here in JSON
notation:</p>
<div class="exampleInner">
<pre>
{ "product" : "broiler", "store number" : 1, "quantity" : 20  },
{ "product" : "toaster", "store number" : 2, "quantity" : 100 },
{ "product" : "toaster", "store number" : 2, "quantity" : 50 },
{ "product" : "toaster", "store number" : 3, "quantity" : 50 },
{ "product" : "blender", "store number" : 3, "quantity" : 100 },
{ "product" : "blender", "store number" : 3, "quantity" : 150 },
{ "product" : "socks", "store number" : 1, "quantity" : 500 },
{ "product" : "socks", "store number" : 2, "quantity" : 10 },
{ "product" : "shirt", "store number" : 3, "quantity" : 10 }
</pre></div>
<p>We want to group sales by product, across stores.</p>
</div>
<div class="div4">
<h5><a name="d3e1162" id="d3e1162"></a>2.6.5.2 Result</h5>
<div class="exampleInner">
<pre>
{
  "blender" : 250,
  "broiler" : 20,
  "shirt" : 10,
  "socks" : 510,
  "toaster" : 200
  }       
</pre></div>
</div>
<div class="div4">
<h5><a name="d3e1167" id="d3e1167"></a>2.6.5.3 Solution in
JSONiq:</h5>
<p>We assume a function collection("sales") that returns a sequence
of items representing the rows in this table.</p>
<p>Query:</p>
<div class="exampleInner">
<pre>
{
  for $sales in collection("sales")
  let $pname := $sales("product")
  group by $pname
  return $pname : sum(for $s in $sales return $s("quantity"))
}       
</pre></div>
</div>
<div class="div4">
<h5><a name="d3e1176" id="d3e1176"></a>2.6.5.4 Solution in XSLT
3.0:</h5>
<p>Solution using the XSLT maps proposal: assuming that
collection("sales") delivers a sequence of unparsed JSON texts, and
that the result is to be serialized as a JSON text:</p>
<div class="exampleInner">
<pre>
  &lt;xsl:variable name="entries" as="map(xs:string, xs:integer)"&gt;
    &lt;xsl:for-each-group select="collection('sales')!parse-json(.)" group-by=".('product')"&gt;
      &lt;xsl:sequence select="map{ current-grouping-key() := sum(current-group()('quantity')) }"/&gt;
    &lt;/xsl:for-each-group&gt;
  &lt;/xsl:variable&gt;
  &lt;xsl:sequence select="serialize-json($entries)"/&gt; 
  
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="jsongrouping2" id="jsongrouping2"></a>2.6.6 More
Complex Grouping Queries for JSON</h4>
<p>Now let's do a more complex grouping query, showing sales by
category within each state. We need further data to describe the
categories of products and the location of stores.</p>
<div class="div4">
<h5><a name="d3e1188" id="d3e1188"></a>2.6.6.1 Input Data</h5>
<p>collection("products") contains the following data:</p>
<div class="exampleInner">
<pre>
{ "name" : "broiler", "category" : "kitchen", "price" : 100, "cost" : 70 },
{ "name" : "toaster", "category" : "kitchen", "price" : 30, "cost" : 10 },
{ "name" : "blender", "category" : "kitchen", "price" : 50, "cost" : 25 },
{ "name" : "socks", "category" : "clothes", "price" : 5, "cost" : 2 },
{ "name" : "shirt", "category" : "clothes", "price" : 10, "cost" : 3 }
</pre></div>
<p>collection("stores") contains the following data:</p>
<div class="exampleInner">
<pre>
{ "store number" : 1, "state" : CA },
{ "store number" : 2, "state" : CA },
{ "store number" : 3, "state" : MA },
{ "store number" : 4, "state" : MA }
        
</pre></div>
</div>
<div class="div4">
<h5><a name="d3e1199" id="d3e1199"></a>2.6.6.2 Result</h5>
<div class="exampleInner">
<pre>
            [
              { "CA" : 
                [
                  {"kitchen" : { "broiler" : 20, "toaster" : 150 }},
                  {"clothes" : { "socks" : 510 }}
                ]
              },
              { "MA" : 
                [ 
                  { "kitchen" : { "blender" : 250, "toaster" : 50 }},
                  { "clothes" : { "shirt" : 10 }}
                ]
              }
            ]
        
</pre></div>
</div>
<div class="div4">
<h5><a name="d3e1204" id="d3e1204"></a>2.6.6.3 Solution in
JSONiq:</h5>
<p>The following query groups by state, then by category, then
lists individual products and the sales associated with each.</p>
<p>Query:</p>
<div class="exampleInner">
<pre>
{
  for $store in collection("stores")
  let $state := $store("state")
  group by $state
  return
     $state : {
       for $product in collection("products")
       let $category := $product("category")
       group by $category
       return
         $category : {
            for $sales in collection("sales")
            where $sales("store number") = $store("store number")
              and $sales("product") = $product("name")
            let $pname := $sales("product")
            group by $pname
            return $pname : sum( for $s in $sales return $s("quantity") )
         }
      }
}
        
</pre></div>
</div>
<div class="div4">
<h5><a name="d3e1213" id="d3e1213"></a>2.6.6.4 Solution in XSLT
3.0:</h5>
<p>An equivalent XSLT solution is given below. This uses the syntax
of the proposed maps facility in XSLT.</p>
<div class="exampleInner">
<pre>
&lt;xsl:stylesheet version="3.0" 
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:map="http://www.w3.org/2005/xpath-functions/map"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    exclude-result-prefixes="map xs"&gt;
    
    &lt;xsl:output method="text"/&gt;
    
    &lt;xsl:variable name="sales" as="map(*)*" select='
        map{ "product" := "broiler", "store number" := 1, "quantity" := 20  },
        map{ "product" := "toaster", "store number" := 2, "quantity" := 100 },
        map{ "product" := "toaster", "store number" := 2, "quantity" := 50 },
        map{ "product" := "toaster", "store number" := 3, "quantity" := 50 },
        map{ "product" := "blender", "store number" := 3, "quantity" := 100 },
        map{ "product" := "blender", "store number" := 3, "quantity" := 150 },
        map{ "product" := "socks", "store number" := 1, "quantity" := 500 },
        map{ "product" := "socks", "store number" := 2, "quantity" := 10 },
        map{ "product" := "shirt", "store number" := 3, "quantity" := 10 }'/&gt;
    
    &lt;xsl:variable name="products" as="map(*)*" select='
        map{ "name" := "broiler", "category" := "kitchen", "price" := 100, "cost" := 70 },
        map{ "name" := "toaster", "category" := "kitchen", "price" := 30, "cost" := 10 },
        map{ "name" := "blender", "category" := "kitchen", "price" := 50, "cost" := 25 },
        map{ "name" := "socks", "category" := "clothes", "price" := 5, "cost" := 2 },
        map{ "name" := "shirt", "category" := "clothes", "price" := 10, "cost" := 3 }'/&gt;
    
    &lt;xsl:variable name="stores" as="map(*)*" select='
        map{ "store number" := 1, "state" := "CA" },
        map{ "store number" := 2, "state" := "CA" },
        map{ "store number" := 3, "state" := "MA" },
        map{ "store number" := 4, "state" := "MA" }'/&gt;
    
    &lt;xsl:template name="main"&gt;
        &lt;xsl:variable name="state-maps" as="map(*)*"&gt;
            &lt;xsl:for-each-group select="$stores" group-by=".('state')"&gt;
                &lt;xsl:variable name="state" select="current-grouping-key()" 
                                           as="xs:string"/&gt;
                &lt;xsl:variable name="stores-in-state" select="current-group()!.('store number')" 
                                                     as="xs:integer*"/&gt;
                &lt;xsl:variable name="state-map-entry" as="map(*)*"&gt;
                    &lt;xsl:for-each-group select="$products" group-by=".('category')"&gt;
                        &lt;xsl:variable name="category" select="current-grouping-key()" as="xs:string"/&gt;
                        &lt;xsl:variable name="products-in-category" select="current-group()" as="map(*)*"/&gt;
                        &lt;xsl:variable name="totals-map" as="map(*)*"&gt;
                            &lt;xsl:variable name="totals-map-entries" as="map(*)*"&gt;
                                &lt;xsl:for-each select="$products-in-category"&gt;
                                   &lt;xsl:variable name="product-name" select=".('name')"/&gt;
                                   &lt;xsl:variable name="product-sales" 
                                       select="$sales[.('product') = $product-name and 
                                                         .('store number') = $stores-in-state]"/&gt;                      
                                   &lt;xsl:if test="exists($product-sales)"&gt;                      
                                      &lt;xsl:sequence select="map{ $product-name := 
                                                                 sum($product-sales!.('quantity')) }"/&gt;
                                   &lt;/xsl:if&gt;   
                                &lt;/xsl:for-each&gt;
                            &lt;/xsl:variable&gt;
                            &lt;xsl:sequence select="map:new($totals-map-entries)"/&gt;
                        &lt;/xsl:variable&gt;
                        &lt;xsl:sequence select="map{ $category := $totals-map }"/&gt;
                    &lt;/xsl:for-each-group&gt;
                &lt;/xsl:variable&gt;    
                &lt;xsl:sequence select=" map { $state := $state-map-entry }"/&gt;
            &lt;/xsl:for-each-group&gt;
        &lt;/xsl:variable&gt;
        &lt;xsl:value-of select="serialize-json($state-maps, map{ 'indent' := true()} )"/&gt;
    &lt;/xsl:template&gt;   
    
&lt;/xsl:stylesheet&gt;
</pre></div>
<p>Note that this example appears to suffer badly from the lack of
composability between the XPath <code>map{}</code> construct and
the XSLT <code>xsl:for-each-group</code> instruction. For such use
cases, an XSLT instruction to construct maps could be a better
approach.</p>
</div>
</div>
<div class="div3">
<h4><a name="json2json" id="json2json"></a>2.6.7 JSON to JSON
Transformations</h4>
<p>The following query takes satellite data, and summarizes which
satellites are visible. The data for the query is a simplified
version of a Stellarium file that contains this information.</p>
<div class="div4">
<h5><a name="d3e1234" id="d3e1234"></a>2.6.7.1 Input Data</h5>
<div class="exampleInner">
<pre>
{
  "creator" : "Satellites plugin version 0.6.4",
  "satellites" : {
    "AAU CUBESAT" : {
      "tle1" : "1 27846U 03031G 10322.04074654  .00000056  00000-0  45693-4 0  8768",
      "visible" : false
    },
    "AJISAI (EGS)" : {
      "tle1" : "1 16908U 86061A 10321.84797408 -.00000083  00000-0  10000-3 0  3696",
      "visible" : true
    },
    "AKARI (ASTRO-F)" : {
      "tle1" : "1 28939U 06005A 10321.96319841  .00000176  00000-0  48808-4 0  4294",
      "visible" : true
    }
  }
}
</pre></div>
<p>We want to query this data to return a summary that looks like
this.</p>
</div>
<div class="div4">
<h5><a name="d3e1241" id="d3e1241"></a>2.6.7.2 Result</h5>
<div class="exampleInner">
<pre>
{
  "visible" : [
     "AJISAI (EGS)",
     "AKARI (ASTRO-F)"
  ],
  "invisible" : [
     "AAU CUBESAT"
  ]
}       
</pre></div>
</div>
<div class="div4">
<h5><a name="d3e1246" id="d3e1246"></a>2.6.7.3 Solution in
JSONiq:</h5>
<p>The following is a JSONiq query that returns the desired
result.</p>
<p><em>Query:</em></p>
<div class="exampleInner">
<pre>
let $sats := json("satellites.json")("satellites")
return {
  "visible" : [
     for $sat in pairs($sats)
     where $sat("visible")
     return name($sat)
  ],
  "invisible" : [
     for $sat in pairs($sats)
     where not($sat)("visible"))
     return name($sat)
  ]
  }
</pre></div>
</div>
<div class="div4">
<h5><a name="d3e1256" id="d3e1256"></a>2.6.7.4 Solution in XSLT
3.0:</h5>
<p>Equivalent using the XSLT maps proposal:</p>
<div class="exampleInner">
<pre>
  &lt;xsl:variable name="sats" select="parse-json(unparsed-text('satellites.json'))('satellites')"/&gt;
  &lt;xsl:sequence select="map{
     'visible' := array(map:keys($sats)[$sats(.)('visible')]),
     'invisible' := array(map:keys($sats)[$sats(.)('invisible')])}"/&gt;
     
</pre></div>
<p>This assumes the existence of a (potentially user-written)
function array() that takes a sequence and turns it into a map with
consecutive integer keys:</p>
<div class="exampleInner">
<pre>
&lt;xsl:function name="array" as="map(xs:integer, item())"&gt;
  &lt;xsl:param name="seq" as="item()*"/&gt;
  &lt;xsl:sequence select="map:new(for $i in 1 to count($seq) return map{$i := $seq[$i]})"/&gt;
&lt;/xsl:function&gt;
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="wikipedia.example" id="wikipedia.example"></a>2.6.8
Converting XML to JSON</h4>
<p>JSON programmers frequently need to convert XML to JSON. The
following query is based on a Wikipedia XML export format, using
data from the category "Origami". Here is an excerpt of this
data:</p>
<div class="div4">
<h5><a name="d3e1272" id="d3e1272"></a>2.6.8.1 Input Data</h5>
<div class="exampleInner">
<pre>
&lt;mediawiki&gt;
  &lt;siteinfo&gt;
    &lt;sitename&gt;Wikipedia&lt;/sitename&gt;

    &lt;page&gt;
      &lt;title&gt;Kawasaki's theorem&lt;/title&gt;
      &lt;id&gt;14511776&lt;/id&gt;
      &lt;revision&gt;
        &lt;id&gt;435519187&lt;/id&gt;
        &lt;timestamp&gt;2011-06-21T20:08:56Z&lt;/timestamp&gt;
        &lt;contributor&gt;
          &lt;username&gt;Some jerk on the Internet&lt;/username&gt;
          &lt;id&gt;6636894&lt;/id&gt;
        &lt;/contributor&gt;

!!! SNIP !!!

    &lt;page&gt;
      &lt;title&gt;Origami techniques&lt;/title&gt;
      &lt;id&gt;193590&lt;/id&gt;
      &lt;revision&gt;
        &lt;id&gt;447687387&lt;/id&gt;
        &lt;timestamp&gt;2011-08-31T17:21:49Z&lt;/timestamp&gt;
        &lt;contributor&gt;
          &lt;username&gt;Dmcq&lt;/username&gt;
          &lt;id&gt;3784322&lt;/id&gt;
        &lt;/contributor&gt;

!!! SNIP !!!

    &lt;page&gt;
      &lt;title&gt;Mathematics of paper folding&lt;/title&gt;
      &lt;id&gt;232840&lt;/id&gt;
      &lt;revision&gt;
        &lt;id&gt;440970828&lt;/id&gt;
        &lt;timestamp&gt;2011-07-23T09:10:42Z&lt;/timestamp&gt;
        &lt;contributor&gt;
          &lt;username&gt;Tabletop&lt;/username&gt;
          &lt;id&gt;173687&lt;/id&gt;
        &lt;/contributor&gt;
       
</pre></div>
</div>
<div class="div4">
<h5><a name="d3e1277" id="d3e1277"></a>2.6.8.2 Result</h5>
<div class="exampleInner">
<pre>
[
 {
  "title" : "Kawasaki's theorem",
  "id" : "14511776",
  "timestamp" : "2011-06-21T20:08:56Z",
  "authors" : ["Some jerk on the Internet" ]
 },
 {
  "title" : "Origami techniques",
  "id" : "193590",
  "timestamp" : "2011-08-31T17:21:49Z",
  "authors" : ["Dmcq" ]
 },
 {
  "title" : "Mathematics of paper folding",
  "id" : "232840",
  "timestamp" : "2011-07-23T09:10:42Z",
  "authors" : ["Tabletop" ]
 }
]
          
</pre></div>
</div>
<div class="div4">
<h5><a name="d3e1282" id="d3e1282"></a>2.6.8.3 Solution in
JSONiq:</h5>
<p>The following query converts this data to JSON:</p>
<p>Query:</p>
<div class="exampleInner">
<pre>
[
 for $page in doc("Wikipedia-Origami.xml")//page
 return {
  "title": string($page/title),
  "id" : string($page/id),
  "last updated" : string($page/revision[1]/timestamp),
  "authors" : [
       for $a in $page/revision/contributor/username
       return string($a)
  ]
 }
]          
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="svg.example" id="svg.example"></a>2.6.9 Transforming
JSON to SVG</h4>
<p>Suppose a JavaScript implementation provides an interface for
JSONiq queries, and a JavaScript program contains the following
data <sup>[<a name="FN-ANCH-d3e1297" id="FN-ANCH-d3e1297" href=
"#d3e1297">1</a>]</sup>:</p>
<div class="div4">
<h5><a name="d3e1304" id="d3e1304"></a>2.6.9.1 Input Data</h5>
<div class="exampleInner">
<pre>
var data = {
   "color" : "blue",
   "closed" : true,
   "points" : [[10,10], [20,10], [20,20], [10,20]]
   };
          
</pre></div>
</div>
<div class="div4">
<h5><a name="d3e1309" id="d3e1309"></a>2.6.9.2 Solution in
JSONiq:</h5>
<p>This data can be converted to SVG by placing the text of a query
in a JavaScript variable and calling the appropriate JavaScript
function to invoke the query:</p>
<div class="exampleInner">
<pre>
var query =
 "declare variable stroke := attribute stroke { color };
  declare variable points := attribute points { points };
  if (closed) then
    &lt;svg&gt;&lt;polygon&gt;{ $stroke, $points }&lt;/polygon&gt;&lt;/svg&gt;
  else
    &lt;svg&gt;&lt;polyline&gt;{ $stroke, $points }&lt;/polyline&gt;&lt;/svg&gt;" 
</pre></div>
<p>This query can be invoked with a JavaScript API call:</p>
<div class="exampleInner">
<pre>
jsoniq(data, query)
          
</pre></div>
<p>Here is the result of the above query:</p>
<div class="exampleInner">
<pre>
&lt;svg&gt;&lt;polygon stroke="blue" points="10 10 20 10 20 20 10 20" /&gt;&lt;/svg&gt;
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="html.example" id="html.example"></a>2.6.10
Transforming Arrays to HTML Tables</h4>
<p>The data in a JSON array is frequently displayed using HTML
tables. The following query shows how to transform from the former
to the latter.</p>
<div class="div4">
<h5><a name="d3e1329" id="d3e1329"></a>2.6.10.1 Input Data</h5>
<p>The following Object contains the labels desired for columns and
rows, as well as the data for the table.</p>
<div class="exampleInner">
<pre>
{
  "col labels" : ["singular", "plural"],
  "row labels" : ["1p", "2p", "3p"],
  "data" :
     [
        ["spinne", "spinnen"],
        ["spinnst", "spinnt"],
        ["spinnt", "spinnen"]
     ]
}
</pre></div>
</div>
<div class="div4">
<h5><a name="d3e1336" id="d3e1336"></a>2.6.10.2 Solution in
JSONiq:</h5>
<p>The following query creates an HTML table, using the column
headings and row labels as well as the data in the Object shown
above.</p>
<div class="exampleInner">
<pre>
&lt;html&gt;
  &lt;body&gt;

    &lt;table&gt;
      &lt;tr&gt; (: Column headings :)
         {
            &lt;th&gt; &lt;/th&gt;,
            for $th in values(json("table.json")("col labels"))
            return &lt;th&gt;{ $th }&lt;/th&gt;
         }
      &lt;/tr&gt;
      {  (: Data for each row :)
         for $r at $i in values(json("table.json")("data"))
         return
            &lt;tr&gt;
             {
               &lt;th&gt;{ values(json("table.json")("row labels")[$i]) }&lt;/th&gt;,
               for $c in $r
               return &lt;td&gt;{ $c }&lt;/td&gt;
             }
            &lt;/tr&gt;
      }
    &lt;/table&gt;

  &lt;/body&gt;
&lt;/html&gt;    
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="windowing.example" id="windowing.example"></a>2.6.11
Windowing Queries</h4>
<p>XQuery provides support for both sliding windows and tumbling
windows, frequently used to analyze event streams or other
sequential data. This simple windowing example converts a sequence
of items to a table with three columns (using as many rows as
necessary), and assigns a row number to each row.</p>
<div class="div4">
<h5><a name="d3e1348" id="d3e1348"></a>2.6.11.1 Input Data</h5>
<div class="exampleInner">
<pre>
[
  { "color" : "Green" },
  { "color" : "Pink" },
  { "color" : "Lilac" },
  { "color" : "Turquoise" },
  { "color" : "Peach" },
  { "color" : "Opal" },
  { "color" : "Champagne" }
}
          
</pre></div>
</div>
<div class="div4">
<h5><a name="d3e1353" id="d3e1353"></a>2.6.11.2 Result</h5>
<p>Result:</p>
<div class="exampleInner">
<pre>
&lt;table&gt;
  &lt;tr&gt;
    &lt;td&gt;Green&lt;/td&gt;
    &lt;td&gt;Pink&lt;/td&gt;
    &lt;td&gt;Lilac&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Turquoise&lt;/td&gt;
    &lt;td&gt;Peach&lt;/td&gt;
    &lt;td&gt;Opal&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Champagne&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
          
</pre></div>
</div>
<div class="div4">
<h5><a name="d3e1360" id="d3e1360"></a>2.6.11.3 Solution in
JSONiq:</h5>
<p>Query:</p>
<div class="exampleInner">
<pre>
&lt;table&gt;{
  for tumbling window $w in values(json("colors.json"))
    start at $x when fn:true()
    end at $y when $y - $x = 2
  return
    &lt;tr&gt;{
      for $i in $w
      return
        &lt;td&gt;{ $i }&lt;/td&gt;
    }&lt;/tr&gt;
}&lt;/table&gt;
          
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="rdb.example" id="rdb.example"></a>2.6.12 JSON views in
middleware</h4>
<p>This example assumes a middleware system that presents
relational tables as JSON arrays. The following two tables are used
as sample data.</p>
<div class="div4">
<h5><a name="d3e1372" id="d3e1372"></a>2.6.12.1 Input Data</h5>
<table border="1">
<caption>Users</caption>
<thead>
<tr>
<td>userid</td>
<td>firstname</td>
<td>lastname</td>
</tr>
</thead>
<tbody>
<tr>
<td>W0342</td>
<td>Walter</td>
<td>Denisovich</td>
</tr>
<tr>
<td>M0535</td>
<td>Mick</td>
<td>Goulish</td>
</tr>
</tbody>
</table>
<p>The JSON representation this particular implementation provides
for the above table looks like this:</p>
<div class="exampleInner">
<pre>
[
  { "userid" : "W0342", "firstname" : "Walter", "lastname" : "Denisovich" },
  { "userid" : "M0535", "firstname" : "Mick", "lastname" : "Goulish" }
]       
</pre></div>
<table border="1">
<caption>Holdings</caption>
<thead>
<tr>
<td>userid</td>
<td>ticker</td>
<td>shares</td>
</tr>
</thead>
<tbody>
<tr>
<td>W0342</td>
<td>DIS</td>
<td>153212312</td>
</tr>
<tr>
<td>M0535</td>
<td>DIS</td>
<td>10</td>
</tr>
<tr>
<td>M0535</td>
<td>AIG</td>
<td>23412</td>
</tr>
</tbody>
</table>
<p>The JSON representation this particular implementation provides
for the above table looks like this:</p>
<div class="exampleInner">
<pre>
[
  { "userid" : "W0342", "ticker" : "DIS", "shares" : 153212312 },
  { "userid" : "M0535", "ticker" : "DIS", "shares" : 10 },
  { "userid" : "M0535", "ticker" : "AIG", "shares" : 23412 }
]       
</pre></div>
</div>
<div class="div4">
<h5><a name="d3e1442" id="d3e1442"></a>2.6.12.2 Solution in
JSONiq:</h5>
<p>The following query uses the fictitious vendor's
<code>vendor:table()</code> function to retrieve the values from a
table, and creates an Object for each user, with a list of the
user's holdings in the value of that Object.</p>
<div class="exampleInner">
<pre>
[
  for $u in vendor:table("Users")
  order by $u("userid")
  return {
    "userid" : $u("userid"),
    "first" :  $u("firstname"),
    "last" :   $u("lastname"),
    "holdings" : [
         for $h in vendor:table("Holdings")
         where $h("userid") = $u("userid")
         order by $h("ticker")
         return {
            "ticker" : $u("ticker"),
            "share" : $u("shares")
         }
    ]
  }
]       
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="update.example" id="update.example"></a>2.6.13
In-Place Updates</h4>
<p>The XQuery Update Facility allows XML data to be updated. JSONiq
provides updating functions to allow JSON to be updated.</p>
<p>Suppose an application receives an order that contains a credit
card number, and needs to put the user on probation.</p>
<div class="div4">
<h5><a name="d3e1459" id="d3e1459"></a>2.6.13.1 Input Data</h5>
<p>Data for an order:</p>
<div class="exampleInner">
<pre>
{
  "user" : "Deadbeat Jim",
  "credit card" : VISA 4111 1111 1111 1111,
  "product" : "lottery tickets",
  "quantity" : 243
}
        
</pre></div>
<p>collection("users") contains the data for each individual
user:</p>
<div class="exampleInner">
<pre>
{
  "name" : "Deadbeat Jim",
  "address" : "1 E 161st St, Bronx, NY 10451",
  "risk tolerance" : "high"
}
        
</pre></div>
</div>
<div class="div4">
<h5><a name="d3e1470" id="d3e1470"></a>2.6.13.2 Solution in
JSONiq:</h5>
<p>The following query adds <code>"status" : "credit card
declined"</code> to the user's record.</p>
<div class="exampleInner">
<pre>
let $dbj := collection("users")[ .("name") = "Deadbeat Jim" ]
return json:insert-into($dbj, "status" : "credit card declined")
        
</pre></div>
<p>After the update is finished, the user's record looks like
this:</p>
<div class="exampleInner">
<pre>
{
  "name" : "Deadbeat Jim",
  "address" : "1 E 161st St, Bronx, NY 10451",
  "status" : "credit card declined",
  "risk tolerance" : "high"
}
        
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="d3e1484" id="d3e1484"></a>2.6.14 Data
Transformations</h4>
<p>Many applications need to modify data before forwarding it to
another source. The XQuery Update Facility provides an expression
called a tranform expression that can be used to create modified
copies. The transform expression uses updating expressions to
perform a transformation. JSONiq defines updating functions for
JSON, which can be used in the XQuery transform expression.</p>
<div class="div4">
<h5><a name="d3e1489" id="d3e1489"></a>2.6.14.1 Input Data</h5>
<p>Suppose an application make videos available using feeds from
Youtube. The following data comes from one such feed:</p>
<div class="exampleInner">
<pre>
{
    "encoding" : "UTF-8",
    "feed" : {
        "author" : [
            {
                "name" : {
                    "$t" : "YouTube"
                },
                "uri" : {
                    "$t" : "http://www.youtube.com/"
                }
            }
        ],
        "category" : [
            {
                "scheme" : "http://schemas.google.com/g/2005#kind",
                "term" : "http://gdata.youtube.com/schemas/2007#video"
            }
        ],
        "entry" : [
            {
                "app$control" : {
                    "yt$state" : {
                        "$t" : "Syndication of this video was restricted by its owner.",
                        "name" : "restricted",
                        "reasonCode" : "limitedSyndication"
                    }
                },
                "author" : [
                    {
                        "name" : {
                            "$t" : "beyonceVEVO"
                        },
                        "uri" : {
                            "$t" : "http://gdata.youtube.com/feeds/api/users/beyoncevevo"
                        }
                    }
                ]
!!! SNIP !!!         
</pre></div>
</div>
<div class="div4">
<h5><a name="d3e1496" id="d3e1496"></a>2.6.14.2 Solution in
JSONiq:</h5>
<p>The following query creates a modified copy of the feed by
removing all entries that restrict syndication.</p>
<div class="exampleInner">
<pre>
let $feed := json("incoming.json")
return
   copy $out := $feed
   modify
      for $entry in $out("feed")("entry")
      where $entry("app$control")("yt$state")("name") = "restricted"
      return json:delete($entry)
   return $out
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="back">
<div class="div1">
<h2><a name="references" id="references"></a>A References</h2>
<dl>
<dt class="label"><span><a name="RFC2119" id="RFC2119"></a>RFC
2119</span></dt>
<dd>
<div>S. Bradner. <em>Key Words for use in RFCs to Indicate
Requirement Levels.</em> IETF RFC 2119. See <a href=
"http://www.ietf.org/rfc/rfc2119.txt">http://www.ietf.org/rfc/rfc2119.txt</a>.</div>
</dd>
<dt class="label"><span><a name="datamodel-30" id=
"datamodel-30"></a>XQuery and XPath Data Model 3.0</span></dt>
<dd>
<div>World Wide Web Consortium. <em>XQuery and XPath Data Model
3.0</em>. W3C Working Draft, 16 September 2010. See <a href=
"http://www.w3.org/TR/xpath-datamodel-30/">http://www.w3.org/TR/xpath-datamodel-30/</a>.</div>
</dd>
<dt class="label"><span><a name="xpath-30" id="xpath-30"></a>XPath
3.0</span></dt>
<dd>
<div>World Wide Web Consortium. <em>XPath 3.0</em>. W3C Working
Draft, 14 June 2011. See <a href=
"http://www.w3.org/TR/xpath-30/">http://www.w3.org/TR/xpath-30/</a>.</div>
</dd>
<dt class="label"><span><a name="xquery-30" id=
"xquery-30"></a>XQuery 3.0</span></dt>
<dd>
<div>World Wide Web Consortium. <em>XPath 3.0</em>. W3C Working
Draft, 14 June 2011. See <a href=
"http://www.w3.org/TR/xquery-30/">http://www.w3.org/TR/xquery-30/</a>.</div>
</dd>
<dt class="label"><span><a name="xslt-30" id="xslt-30"></a>XSLT
3.0</span></dt>
<dd>
<div>World Wide Web Consortium. <em>XSLT 3.0</em>. W3C Working
Draft 24 July 2011. See <a href=
"http://www.w3.org/TR/2011/WD-xslt-21-20110724/">http://www.w3.org/TR/2011/WD-xslt-21-20110724/</a>.</div>
</dd>
<dt class="label"><span><a name="JSONiq" id=
"JSONiq"></a>JSONiq</span></dt>
<dd>
<div>Jonathan Robie, Matthias Brantner, Daniela Florescu, Ghislain
Fourny, Till Westmann. <em>JSONiq: XQuery for JSON, JSON for
XQuery</em>. See <a href=
"http://jsoniq.com/docs/spec/en-US/html/index.html">http://jsoniq.com/docs/spec/en-US/html/index.html</a>.</div>
</dd>
<dt class="label"><span><a name="JSONiq-UseCases" id=
"JSONiq-UseCases"></a>JSONiq Use Cases</span></dt>
<dd>
<div>Jonathan Robie, Matthias Brantner, Daniela Florescu, Ghislain
Fourny, Till Westmann. <em>JSONiq Use Cases</em>. See <a href=
"http://jsoniq.com/docs/use-cases/en-US/html/index.html">http://jsoniq.com/docs/use-cases/en-US/html/index.html</a>.</div>
</dd>
</dl>
</div>
</div>
<hr />
<div class="endnotes">
<h3><a name="endnotes" id="endnotes"></a>End Notes</h3>
<dl>
<dt>[<a name="d3e1297" id="d3e1297" href=
"#FN-ANCH-d3e1297">1</a>]</dt>
<dd>
<p>This example is based on an example on Stefan Goessner's JSONT
site (<a href=
"http://goessner.net/articles/jsont/">http://goessner.net/articles/jsont/</a>).</p>
</dd>
</dl>
</div>
</body>
</html>
